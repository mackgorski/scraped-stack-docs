[{
  "url": "https://www.prisma.io/docs",
  "markdown": "# Prisma Documentation\n\nPrisma ORM works seamlessly across most popular databases and service providers. Refer to our [Database features matrix](https://www.prisma.io/docs/orm/reference/database-features) for information about supported features and types for each database.  \nTo explore supported databases for Accelerate, visit the\n\n[prerequisites section](https://www.prisma.io/docs/accelerate/getting-started#prerequisites). For Pulse, see the [database setup documentation](https://www.prisma.io/docs/pulse/database-setup).",
  "title": "Prisma Documentation",
  "description": "Get started with Prisma in the official documentation, and learn more about all Prisma's features with reference documentation, guides, and more.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference/database-features",
  "markdown": "# Database features matrix | Prisma Documentation\n\nThis page gives an overview of the features which are provided by the databases that Prisma ORM supports. Additionally, it explains how each of these features can be used in Prisma ORM with pointers to further documentation.\n\n> **Note**: If a feature is not supported natively by the database, it's also not available in Prisma ORM.\n\n## Relational database features[​](https://www.prisma.io/docs/orm/reference/database-features#relational-database-features \"Direct link to Relational database features\")\n\nThis section describes which database features exist on the relational databases that are currently supported by Prisma ORM. The **Prisma schema** column indicates how a certain feature can be represented in the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) and links to its documentation. Note that database features can be used in **Prisma Client** even though they might not yet be representable in the Prisma schema.\n\n### Constraints[​](https://www.prisma.io/docs/orm/reference/database-features#constraints \"Direct link to Constraints\")\n\n| Constraint | PostgreSQL | Microsoft SQL Server | MySQL | SQLite | CockroachDB | Prisma schema | Prisma Client | Prisma Migrate |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| `PRIMARY KEY` | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | [`@id` and `@@id`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-an-id-field) | ✔️  | ✔️  |\n| `FOREIGN KEY` | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | [Relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) | ✔️  | ✔️  |\n| `UNIQUE` | ✔️  | ✔️† | ✔️  | ✔️  | ✔️  | [`@unique` and `@@unique`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-a-unique-field) | ✔️  | ✔️  |\n| `CHECK` | ✔️  | ✔️  | ✔️\\* | ✔️  | ✔️  | Not yet | ✔️  | Not yet |\n| `NOT NULL` | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | [`?`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) | ✔️  | ✔️  |\n| `DEFAULT` | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | [`@default`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-a-default-value) | ✔️  | ✔️  |\n\n*   \\*In [MySQL 8 and higher](https://dev.mysql.com/doc/refman/8.0/en/create-table-check-constraints.html)\n*   † [Caveats apply when using the `UNIQUE` constraint with Microsoft SQL Server](https://www.prisma.io/docs/orm/overview/databases/sql-server#data-model-limitations)\n\n### Referential Actions (Delete and Update behaviors for foreign key references)[​](https://www.prisma.io/docs/orm/reference/database-features#referential-actions-delete-and-update-behaviors-for-foreign-key-references \"Direct link to Referential Actions (Delete and Update behaviors for foreign key references)\")\n\n| Deletion behavior | PostgreSQL | Microsoft SQL Server | MySQL | SQLite | CockroachDB | Prisma schema | Prisma Client | Prisma Migrate |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| `CASCADE` | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | **✔️**† | ✔️  | **✔️**† |\n| `RESTRICT` | ✔️  | No  | ✔️  | ✔️  | ✔️  | **✔️**† | ✔️  | **✔️**† |\n| `NO ACTION` | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | **✔️**† | ✔️  | **✔️**† |\n| `SET DEFAULT` | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | **✔️**† | ✔️  | **✔️**† |\n| `SET NULL` | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | **✔️**† | ✔️  | **✔️**† |\n\n*   † In [2.26.0](https://github.com/prisma/prisma/releases/tag/2.26.0) and later you can define [referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) on your relation fields. Referential actions determine what should happen to a record when a related record is deleted or updated.\n\n### Indexes[​](https://www.prisma.io/docs/orm/reference/database-features#indexes \"Direct link to Indexes\")\n\n| Index | PostgreSQL | Microsoft SQL Server | MySQL | SQLite | CockroachDB | Prisma schema | Prisma Client | Prisma Migrate |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| `UNIQUE` | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | [`@unique` and `@@unique`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-a-unique-field) | ✔️  | ✔️  |\n| `USING` | ✔️  | No  | No  | No  | ✔️  | [`type`](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#configuring-the-access-type-of-indexes-with-type-postgresql)† | ✔️  | ✔️† |\n| `WHERE` | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | Not yet | ✔️  | Not yet |\n| `(expression)` | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | Not yet | ✔️  | Not yet |\n| `INCLUDE` | ✔️  | ✔️  | No  | No  | ✔️  | Not yet | ✔️  | Not yet |\n\n*   † Available in preview in 3.6.0 and later and in general availability in 4.0.0 and later, with the PostgreSQL connector only.\n\nAlgorithm specified via `USING`:\n\n| Index type (Algorithm) | PostgreSQL | Microsoft SQL Server | MySQL | SQLite | CockroachDB | Prisma schema | Prisma Client | Prisma Migrate |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| B-tree | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | ✔️† | ✔️  | Not yet |\n| Hash | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | ✔️† | ✔️  | Not yet |\n| GiST | ✔️  | ✔️  | No  | No  | ✔️  | ✔️† | ✔️\\* | Not yet |\n| GIN | ✔️  | ✔️  | No  | No  | ✔️  | ✔️† | ✔️\\* | Not yet |\n| BRIN | ✔️  | ✔️  | No  | No  | ✔️  | ✔️† | ✔️\\* | Not yet |\n| SP-GiST | ✔️  | ✔️  | No  | No  | ✔️  | ✔️† | ✔️\\* | Not yet |\n\n*   \\* Only available if natively supported by database.\n*   † Available with the PostgreSQL connector only in Prisma ORM versions `4.0.0` and later.\n\n### Misc[​](https://www.prisma.io/docs/orm/reference/database-features#misc \"Direct link to Misc\")\n\n| Feature | PostgreSQL | Microsoft SQL Server | MySQL | SQLite | CockroachDB | Prisma schema | Prisma Client | Prisma Migrate |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Autoincrementing IDs | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | [`autoincrement()`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-a-default-value) | ✔️  | ✔️  |\n| Arrays | ✔️  | No  | No  | No  | ✔️  | [`[]`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) | ✔️\\* | ✔️\\* |\n| Enums | ✔️  | No  | ✔️  | No  | ✔️  | [`enum`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-enums) | ✔️\\* | ✔️\\* |\n| Native database types | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | Not yet |\n| SQL Views | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | Not yet | Not yet | Not yet |\n| JSON support | ✔️  | **✔️**† | ✔️  | No  | ✔️‡ | ✔️\\* | ✔️\\* | ✔️\\* |\n| Fuzzy/Phrase full text search | ✔️  | ✔️  | ✔️  | No  | ✔️  | Not yet | Not yet | Not yet |\n| Table inheritance | ✔️  | ✔️  | No  | No  | ✔️  | Not yet | ✔️\\* | Not yet |\n| Authorization and user management | ✔️  | ✔️  | ✔️  | No  | ✔️  | Not yet | Not yet | Not yet |\n\n*   \\* Only available if natively supported by database.\n*   † Only supports JSON through SQL functions, but doesn't have a JSON column type. Therefore client JSON operations are not supported.\n*   ‡ JSON arrays are not yet supported: see the [CockroachDB connector page](https://www.prisma.io/docs/orm/overview/databases/cockroachdb) for details\n\n## NoSQL database features[​](https://www.prisma.io/docs/orm/reference/database-features#nosql-database-features \"Direct link to NoSQL database features\")\n\nThis section describes which database features exist on the NoSQL databases that are currently supported by Prisma ORM.\n\n### MongoDB[​](https://www.prisma.io/docs/orm/reference/database-features#mongodb \"Direct link to MongoDB\")\n\nThe following table lists common MongoDB features and describes the level of support offered by Prisma ORM:\n\n| Feature | Supported by Prisma ORM | Notes |\n| --- | --- | --- |\n| Embedded documents | ✔️  |     |\n| Transactions | ✔️  |     |\n| Indexes | ✔️ with caveats | Indexes can only be introspected if the field they refer to includes at least some data. |\n| Autoincrementing IDs | No  |     |\n| Compound IDs | No  | MongoDB does not support composite IDs (`@@id`) |\n| Generated `ObjectId` | ✔️  | See: [Defining IDs for MongoDB](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-ids-in-mongodb) |\n| Arrays | ✔️  |     |\n| Enums | ✔️  | Implemented at Prisma ORM level |\n| Native database types | ✔️  | See: [Field mapping reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) |\n| JSON support | ✔️  | Advanced `Json` field filtering is not yet supported. |\n| DBrefs | No  |     |\n| Change streams | No  |     |\n| Direct access to the aggregation pipeline | No  |     |",
  "title": "Database features matrix | Prisma Documentation",
  "description": "Learn which database features are supported in Prisma ORM and how they map to the different Prisma ORM tools.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse/api-reference",
  "markdown": "# Pulse: API reference | Prisma Documentation\n\nThe Pulse API reference documentation on this page is based on the following schema:\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  name  String?  email String  @unique}\n```\n\n## `stream()`[​](https://www.prisma.io/docs/pulse/api-reference#stream \"Direct link to stream\")\n\n`stream()` returns an [async iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols) that receives all database change events related to the table you call this method on.\n\n```\nconst stream = await prisma.user.stream();\n```\n\nBecause an async iterable is returned, you can use a [`for await...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of) loop to wait for and receive events:\n\n```\nfor await (let event of subscription) {  console.log(event);}\n```\n\n### Notes[​](https://www.prisma.io/docs/pulse/api-reference#notes \"Direct link to Notes\")\n\n*   Usage of `stream()` requires [event persistence](https://www.prisma.io/docs/pulse/database-events#event-persistence) to be enabled in your Pulse project.\n*   `stream()` guarantees that all events will be delivered at least once and in the right order.\n\n### Options[​](https://www.prisma.io/docs/pulse/api-reference#options \"Direct link to Options\")\n\nYou can pass an object with configuration options to `stream()`. The object has the following fields:\n\n| Name | Description |\n| --- | --- |\n| `name` | The name of the stream. Providing this option enables \"resumability\" and will make sure you receive events later if your stream isn't active at the time when the event actually happened (e.g. because your server was down). |\n| `create` | An object to specify filters for the create events to be received. If you leave the object empty with `create: {}`, you will receive _all_ create events. You can filter on any scalar field of your model. |\n| `update` | An object with an `after` field to specify filters for the update events to be received. If you leave the object empty with `update: {}`, you will receive _all_ update events. The filter is applied to the values of the record _after_ an update has been performed. You can filter on any scalar field of your model. |\n| `delete` | An object to specify filters for the delete events to be received. You can filter on any scalar field of your model. |\n\n### Return type[​](https://www.prisma.io/docs/pulse/api-reference#return-type \"Direct link to Return type\")\n\nWhen called with no filter arguments, the `stream()` method returns the following type:\n\n```\nconst stream: PulseSubscription<  | PulseCreateEvent<{      id: number;      name: string | null;      email: string;    }>  | PulseUpdateEvent<{      id: number;      name: string | null;      email: string;    }>  | PulseDeleteEvent<{      id: number;      name: string | null;      email: string;    }>> = await prisma.user.stream();\n```\n\nDepending on the arguments you provide, the return type may change. For example, if you filter for only `create` events, the type will get adjusted:\n\n```\nconst stream: PulseSubscription<  PulseCreateEvent<{    id: number;    email: string;    name: string | null;  }>> = await prisma.user.stream({  create: {},});\n```\n\n### Examples[​](https://www.prisma.io/docs/pulse/api-reference#examples \"Direct link to Examples\")\n\n#### Use a `name` to be able to \"resume\" the stream[​](https://www.prisma.io/docs/pulse/api-reference#use-a-name-to-be-able-to-resume-the-stream \"Direct link to use-a-name-to-be-able-to-resume-the-stream\")\n\n```\nconst stream = await prisma.user.stream({  name: \"all-user-events\",});\n```\n\nLearn more about resuming streams [here](https://www.prisma.io/docs/pulse/database-events#resuming-event-streams)\n\n#### Filter for new `User` records with a non-null value for `name`[​](https://www.prisma.io/docs/pulse/api-reference#filter-for-new-user-records-with-a-non-null-value-for-name \"Direct link to filter-for-new-user-records-with-a-non-null-value-for-name\")\n\n```\nconst stream = await prisma.user.stream({  create: {    name: { not: null },  },});\n```\n\n#### Filter for updated `User` records where the `email` ends with `@prisma.io` after the update[​](https://www.prisma.io/docs/pulse/api-reference#filter-for-updated-user-records-where-the-email-ends-with-prismaio-after-the-update \"Direct link to filter-for-updated-user-records-where-the-email-ends-with-prismaio-after-the-update\")\n\n```\nconst stream = await prisma.user.stream({  update: {    after: {      email: { endsWith: \"@prisma.io\" },    },  },});\n```\n\n#### Filter for deleted `User` records where the `email` contains `hello`[​](https://www.prisma.io/docs/pulse/api-reference#filter-for-deleted-user-records-where-the-email-contains-hello \"Direct link to filter-for-deleted-user-records-where-the-email-contains-hello\")\n\n```\nconst stream = await prisma.user.stream({  delete: {    email: { contains: \"hello\" },  },});\n```\n\n## `subscribe()`[​](https://www.prisma.io/docs/pulse/api-reference#subscribe \"Direct link to subscribe\")\n\n`subscribe()` returns an [async iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols) that receives all database change events related to the table you call this method on.\n\n```\nconst subscription = await prisma.user.subscribe();\n```\n\nBecause an async iterable is returned, you can use a [`for await...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of) loop to wait for and receive events:\n\n```\nfor await (let event of subscription) {  console.log(event);}\n```\n\n### Notes[​](https://www.prisma.io/docs/pulse/api-reference#notes-1 \"Direct link to Notes\")\n\n*   `subscribe()` guarantees that all events will be delivered at most once. There are no guarantees about the order in which the events arrive.\n*   Events delivered with `subscribe()` are _ephemeral_, meaning they won't be delivered if your subscription isn't active during the time when the event happens in the database (e.g. because your server is down).\n\n### Options[​](https://www.prisma.io/docs/pulse/api-reference#options-1 \"Direct link to Options\")\n\nYou can pass an object with configuration options to `subscribe()`. The object has the following fields:\n\n| Name | Description |\n| --- | --- |\n| `create` | An object to specify filters for the create events to be received. If you leave the object empty with `create: {}`, you will receive _all_ create events. You can filter on any scalar field of your model. |\n| `update` | An object with an `after` field to specify filters for the update events to be received. If you leave the object empty with `update: {}`, you will receive _all_ update events. The filter is applied to the values of the record _after_ an update has been performed. You can filter on any scalar field of your model. |\n| `delete` | An object to specify filters for the delete events to be received. You can filter on any scalar field of your model. |\n\n### Return type[​](https://www.prisma.io/docs/pulse/api-reference#return-type-1 \"Direct link to Return type\")\n\nWhen called with no filter arguments, the `subscribe()` method returns the following type:\n\n```\nconst subscription: PulseSubscription<  | PulseCreateEvent<{      id: number;      name: string | null;      email: string;    }>  | PulseUpdateEvent<{      id: number;      name: string | null;      email: string;    }>  | PulseDeleteEvent<{      id: number;      name: string | null;      email: string;    }>> = await prisma.user.subscribe();\n```\n\nDepending on the arguments you provide, the return type may change. For example, if you filter for only `create` events, the type will get adjusted:\n\n```\nconst subscription: PulseSubscription<  PulseCreateEvent<{    id: number;    email: string;    name: string | null;  }>> = await prisma.user.subscribe({  create: {},});\n```\n\n### Examples[​](https://www.prisma.io/docs/pulse/api-reference#examples-1 \"Direct link to Examples\")\n\n#### Filter for new `User` records with a non-null value for `name`[​](https://www.prisma.io/docs/pulse/api-reference#filter-for-new-user-records-with-a-non-null-value-for-name-1 \"Direct link to filter-for-new-user-records-with-a-non-null-value-for-name-1\")\n\n```\nconst subscription = await prisma.user.subscribe({  create: {    name: { not: null },  },});\n```\n\n#### Filter for updated `User` records where the `email` ends with `@prisma.io` after the update[​](https://www.prisma.io/docs/pulse/api-reference#filter-for-updated-user-records-where-the-email-ends-with-prismaio-after-the-update-1 \"Direct link to filter-for-updated-user-records-where-the-email-ends-with-prismaio-after-the-update-1\")\n\n```\nconst subscription = await prisma.user.subscribe({  update: {    after: {      email: { endsWith: \"@prisma.io\" },    },  },});\n```\n\n#### Filter for deleted `User` records where the `email` contains `hello`[​](https://www.prisma.io/docs/pulse/api-reference#filter-for-deleted-user-records-where-the-email-contains-hello-1 \"Direct link to filter-for-deleted-user-records-where-the-email-contains-hello-1\")\n\n```\nconst subscription = await prisma.user.subscribe({  delete: {    email: { contains: \"hello\" },  },});\n```\n\n## `stream()` vs `subscribe()`[​](https://www.prisma.io/docs/pulse/api-reference#stream-vs-subscribe \"Direct link to stream-vs-subscribe\")\n\nFor the majority of use cases, `stream()` is the recommended option because it can provide guarantees for events to arrive on the consumer-side. Note though that because `stream()` requires event persistence to be enabled, this has implications for [event storage and costs](https://www.prisma.io/pricing).\n\nSee a [more detailed comparison](https://www.prisma.io/docs/pulse/database-events#event-delivery-semantics-in-prisma-pulse).\n\n## `stop()`[​](https://www.prisma.io/docs/pulse/api-reference#stop \"Direct link to stop\")\n\nAllows you to explicitly stop streams and subscriptions and close the connection. This is needed to ensure that the limited number of subscriptions allowed per table is not exhausted.\n\n### For `stream()`[​](https://www.prisma.io/docs/pulse/api-reference#for-stream \"Direct link to for-stream\")\n\n```\n// Create the streamconst stream = await prisma.user.stream();// ... Use the stream// Stop the streamstream.stop();\n```\n\n### For `subscribe()`[​](https://www.prisma.io/docs/pulse/api-reference#for-subscribe \"Direct link to for-subscribe\")\n\n```\n// Create the subscriptionconst subscription = await prisma.user.subscribe();// ... Use the subscription// Stop the subscriptionsubscription.stop();\n```\n\n## `PulseCreateEvent<User>`[​](https://www.prisma.io/docs/pulse/api-reference#pulsecreateeventuser \"Direct link to pulsecreateeventuser\")\n\nAn object of type `PulseCreateEvent` is returned by any `create` event that happens in the database.\n\n### Type[​](https://www.prisma.io/docs/pulse/api-reference#type \"Direct link to Type\")\n\nA `PulseCreateEvent` has the following fields:\n\n| Name | Type | Example value | Description |\n| --- | --- | --- | --- |\n| `id` | `string` | `01HYBEER1JPSBVPG2NQADNQTA6` | A unique identifier / idempotency key following the [ULID](https://github.com/ulid/spec#specification) specification. |\n| `modelName` | `string` | `User` | The name of the model affected by this event. This is a model name from your Prisma schema. |\n| `action` | `string` | `create` | The kind of write-operation performed in the database: `create` |\n| `created` | `User` | See `created` in the example below. | An object with the values of the record was just created. |\n\nThe type of the event is generic to the fields of your model. In the case, of the `User` model above, it looks as follows:\n\n```\nPulseCreateEvent<{  id: number;  email: string;  name: string | null;}>;\n```\n\n### Example[​](https://www.prisma.io/docs/pulse/api-reference#example \"Direct link to Example\")\n\nHere is an example:\n\n```\n{  action: 'create',  created: { id: 3, email: 'jane@prisma.io', name: 'Jane Doe' },  id: '0/2A5A590',  modelName: 'User'}\n```\n\n## `PulseUpdateEvent<User>`[​](https://www.prisma.io/docs/pulse/api-reference#pulseupdateeventuser \"Direct link to pulseupdateeventuser\")\n\nAn object of type `PulseUpdateEvent` is returned by any `delete` event that happens in the database.\n\n### Type[​](https://www.prisma.io/docs/pulse/api-reference#type-1 \"Direct link to Type\")\n\nA `PulseUpdateEvent` has the following fields:\n\n| Name | Type | Example value | Description |\n| --- | --- | --- | --- |\n| `id` | `string` | `01HYBEER1JPSBVPG2NQADNQTA6` | A unique identifier / idempotency key following the [ULID](https://github.com/ulid/spec#specification) specification. |\n| `modelName` | `string` | `User` | The name of the model affected by this event. This is a model name from your Prisma schema. |\n| `action` | `string` | `update` | The kind of write-operation performed in the database: `update` |\n| `before` | `User` | `null` | An object with the _old_ values of the record that was just updated. This only works with when the [`REPLICA IDENTITY`](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#replica-identity) in your database is set to `FULL`. Otherwise the value will always be `null`. |\n| `after` | `User` | See `after` in the example below. | An object with the _new_ values of the record that was just updated. |\n\nThe type of the event is generic to the fields of your model. In the case, of the `User` model above, it looks as follows:\n\n```\nPulseUpdateEvent<{  id: number;  email: string;  name: string | null;}>;\n```\n\n### Example[​](https://www.prisma.io/docs/pulse/api-reference#example-1 \"Direct link to Example\")\n\n_Without_ having set the `REPLICA IDENDITY` to `FULL`:\n\n```\n{  action: 'update',  after: { id: 2, email: 'doe@prisma.io', name: 'Jane Doe' },  before: null,  id: '0/2A5A248',  modelName: 'User'}\n```\n\n_With_ having set the `REPLICA IDENDITY` to `FULL`:\n\n```\n{  action: 'update',  after: { id: 2, email: 'support@prisma.io', name: 'Jane Doe' },  before: { id: 2, email: 'support@prisma.io', name: null },  id: '0/2A5A248',  modelName: 'User'}\n```\n\n## `PulseDeleteEvent<User>`[​](https://www.prisma.io/docs/pulse/api-reference#pulsedeleteeventuser \"Direct link to pulsedeleteeventuser\")\n\n### Type[​](https://www.prisma.io/docs/pulse/api-reference#type-2 \"Direct link to Type\")\n\nA `PulseDeleteEvent` has the following fields:\n\n| Name | Type | Example value | Description |\n| --- | --- | --- | --- |\n| `id` | `string` | `01HYBEER1JPSBVPG2NQADNQTA6` | A unique identifier / idempotency key following the [ULID](https://github.com/ulid/spec#specification) specification. |\n| `modelName` | `string` | `User` | The name of the model affected by this event. This is a model name from your Prisma schema. |\n| `action` | `string` | `delete` | The kind of write-operation performed in the database: `create`, `update` or `delete`. |\n| `deleted` | `User` | `{ id: 3 }` | An object with the values of the record that was just deleted. This only works with when the [`REPLICA IDENTITY`](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#replica-identity) in your database is set to `FULL`. Otherwise the object will only carry an `id` field. |\n\nThe type of the event is generic to the fields of your model. In the case, of the `User` model above, it looks as follows:\n\n```\nPulseDeleteEvent<{  id: number;  email: string;  name: string | null;}>;\n```\n\n### Example[​](https://www.prisma.io/docs/pulse/api-reference#example-2 \"Direct link to Example\")\n\n_Without_ having set the `REPLICA IDENDITY` to `FULL`:\n\n```\n {  action: 'delete',  deleted: { id: 1 },  id: '0/2A5A398',  modelName: 'User'}\n```\n\n_With_ having set the `REPLICA IDENDITY` to `FULL`:\n\n```\n {  action: 'delete',  deleted: { id: 42, email: 'doe@prisma.io', name: 'Jane Doe' },  id: '0/2A5A398',  modelName: 'User'}\n```",
  "title": "Pulse: API reference | Prisma Documentation",
  "description": "API reference documentation for Pulse.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/opensearch.xml",
  "markdown": null,
  "title": "",
  "description": null,
  "languageCode": null
},
{
  "url": "https://www.prisma.io/docs/pulse/database-setup",
  "markdown": "# Prisma Pulse: Database setup | Prisma Documentation\n\n## General database instruction[​](https://www.prisma.io/docs/pulse/database-setup#general-database-instruction \"Direct link to General database instruction\")\n\nPrisma Pulse requires your database to be configured in a specific way. To get your database ready for Prisma Pulse, follow the general database instructions [here](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions).\n\ninfo\n\nPrisma Pulse requires a publicly accessible PostgreSQL (**version 12+**) database with [logical replication](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#enable-logical-replication) enabled.\n\n## Provider specific instructions[​](https://www.prisma.io/docs/pulse/database-setup#provider-specific-instructions \"Direct link to Provider specific instructions\")\n\n*   [AWS RDS](https://www.prisma.io/docs/pulse/database-setup/aws-rds)\n*   [Railway](https://www.prisma.io/docs/pulse/database-setup/railway)\n*   [Supabase](https://www.prisma.io/docs/pulse/database-setup/supabase)\n*   [Neon](https://www.prisma.io/docs/pulse/database-setup/neon)",
  "title": "Prisma Pulse: Database setup | Prisma Documentation",
  "description": "Learn about configuring your database to use with Prisma Pulse",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started",
  "markdown": "# Get started with Prisma | Prisma Documentation\n\nWelcome 👋\n\nExplore our products that make it easy to build and scale data-driven applications:\n\n[**Prisma ORM**](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma) is a next-generation Node.js and TypeScript ORM that unlocks a new level of developer experience when working with databases thanks to its intuitive data model, automated migrations, type-safety & auto-completion.\n\n[**Prisma Accelerate**](https://www.prisma.io/docs/accelerate/what-is-accelerate) is a global database cache with scalable connection pooling to make your queries fast.\n\n[**Prisma Pulse**](https://www.prisma.io/docs/pulse/what-is-pulse) allows you to react to database changes with type-safe model subscriptions.\n\n## Prisma ORM[​](https://www.prisma.io/docs/getting-started#-prisma-orm \"Direct link to -prisma-orm\")\n\nAdd Prisma ORM to your application in a few minutes to start modeling your data, run schema migrations and query your database.\n\n### Explore quickly with a SQLite database[​](https://www.prisma.io/docs/getting-started#explore-quickly-with-a-sqlite-database \"Direct link to Explore quickly with a SQLite database\")\n\n_These options don't require you to have your own database running._\n\n### Choose an option to get started with your own database[​](https://www.prisma.io/docs/getting-started#choose-an-option-to-get-started-with-your-own-database \"Direct link to Choose an option to get started with your own database\")\n\n_Select one of these options if you want to connect Prisma ORM to your own database._\n\n*   New database\n*   Existing database\n\nSet up Prisma ORM **from scratch** with your favorite database and learn basic workflows like data modeling, querying, and migrations.\n\n[![](https://www.prisma.io/docs/img/technologies/postgresqlsimple.svg)](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-postgresql)[![](https://www.prisma.io/docs/img/technologies/mysqlsimple.svg)](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-mysql)[![](https://www.prisma.io/docs/img/technologies/sqlserver.svg)](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-sqlserver)[![](https://www.prisma.io/docs/img/technologies/planetscale.svg)![](https://www.prisma.io/docs/img/technologies/planetscaledark.svg)](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-planetscale)[![](https://www.prisma.io/docs/img/technologies/cockroachdbdark.svg)](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-cockroachdb)[![](https://www.prisma.io/docs/img/technologies/mongodbsimple.svg)](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb-typescript-mongodb)\n\n## Prisma Accelerate[​](https://www.prisma.io/docs/getting-started#-prisma-accelerate \"Direct link to -prisma-accelerate\")\n\nMake your database queries faster by scaling your database connections and caching database results at the edge with Prisma Accelerate.\n\n  \n[\n\n###### Speed Test\n\nRun the speed test to see how Prisma Accelerate can make your app faster.\n\n](https://accelerate-speed-test.prisma.io/)\n\n## Prisma Pulse[​](https://www.prisma.io/docs/getting-started#-prisma-pulse \"Direct link to -prisma-pulse\")\n\nBuild real-time applications by subscribing to data changes in your database using Prisma Pulse.",
  "title": "Get started with Prisma | Prisma Documentation",
  "description": "Build data-driven applications with ease using Prisma ORM, add connection pooling or global caching with Prisma Accelerate or subscribe to database changes in real-time with Prisma Pulse.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm",
  "markdown": "# ORM | Prisma Documentation\n\n[Prisma ORM](https://github.com/prisma/prisma) is a Node.js and TypeScript ORM with an intuitive data model, automated migrations, type-safety, and auto-completion.\n\n## In this section[​](https://www.prisma.io/docs/orm#in-this-section \"Direct link to In this section\")\n\n[\n\n## ORM\n\n](https://www.prisma.io/docs/orm)\n\n[\n\n## Overview\n\n](https://www.prisma.io/docs/orm/overview)\n\n[\n\n## Prisma Schema\n\n](https://www.prisma.io/docs/orm/prisma-schema)\n\n[\n\n## Prisma Client\n\n](https://www.prisma.io/docs/orm/prisma-client)\n\n[\n\n## Prisma Migrate\n\n](https://www.prisma.io/docs/orm/prisma-migrate)\n\n[\n\n## Tools\n\n](https://www.prisma.io/docs/orm/tools)\n\n[\n\n## Reference\n\n](https://www.prisma.io/docs/orm/reference)\n\n[\n\n## More\n\n](https://www.prisma.io/docs/orm/more)",
  "title": "ORM | Prisma Documentation",
  "description": "ORM",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/postgresql",
  "markdown": "# PostgreSQL database connector | Prisma Documentation\n\nThe PostgreSQL data source connector connects Prisma ORM to a [PostgreSQL](https://www.postgresql.org/) database server.\n\nBy default, the PostgreSQL connector contains a database driver responsible for connecting to your database. You can use a [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters) (Preview) to connect to your database using a JavaScript database driver from Prisma Client.\n\n## Example[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#example \"Direct link to Example\")\n\nTo connect to a PostgreSQL database server, you need to configure a [`datasource`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) block in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema):\n\nschema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nThe fields passed to the `datasource` block are:\n\n*   `provider`: Specifies the `postgresql` data source connector.\n*   `url`: Specifies the [connection URL](https://www.prisma.io/docs/orm/overview/databases/postgresql#connection-url) for the PostgreSQL database server. In this case, an [environment variable is used](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) to provide the connection URL.\n\n## Using the `node-postgres` driver[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#using-the-node-postgres-driver \"Direct link to using-the-node-postgres-driver\")\n\nAs of [`v5.4.0`](https://github.com/prisma/prisma/releases/tag/5.4.0), you can use Prisma ORM with database drivers from the JavaScript ecosystem (instead of using Prisma ORM's built-in drivers). You can do this by using a [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers).\n\nFor PostgreSQL, [`node-postgres`](https://node-postgres.com/) (`pg`) is one of the most popular drivers in the JavaScript ecosystem. It can be used with any PostgreSQL database that's accessed via TCP.\n\nThis section explains how you can use it with Prisma ORM and the `@prisma/adapter-pg` driver adapter.\n\n### 1\\. Enable the `driverAdapters` Preview feature flag[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#1-enable-the-driveradapters-preview-feature-flag \"Direct link to 1-enable-the-driveradapters-preview-feature-flag\")\n\nSince driver adapters are currently in [Preview](https://www.prisma.io/docs/orm/more/releases#preview), you need to enable its feature flag on the `datasource` block in your Prisma schema:\n\n```\n// schema.prismagenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nOnce you have added the feature flag to your schema, re-generate Prisma Client:\n\n### 2\\. Install the dependencies[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#2-install-the-dependencies \"Direct link to 2. Install the dependencies\")\n\nNext, install the `pg` package and Prisma ORM's driver adapter:\n\n```\nnpm install pgnpm install @prisma/adapter-pg\n```\n\n### 3\\. Instantiate Prisma Client using the driver adapter[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#3-instantiate-prisma-client-using-the-driver-adapter \"Direct link to 3. Instantiate Prisma Client using the driver adapter\")\n\nFinally, when you instantiate Prisma Client, you need to pass an instance of Prisma ORM's driver adapter to the `PrismaClient` constructor:\n\n```\nimport { Pool } from 'pg'import { PrismaPg } from '@prisma/adapter-pg'import { PrismaClient } from '@prisma/client'const connectionString = `${process.env.DATABASE_URL}`const pool = new Pool({ connectionString })const adapter = new PrismaPg(pool)const prisma = new PrismaClient({ adapter })\n```\n\nNotice that this code requires the `DATABASE_URL` environment variable to be set to your PostgreSQL connection string. You can learn more about the connection string below.\n\n### Notes[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#notes \"Direct link to Notes\")\n\n#### Specifying a PostgreSQL schema[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#specifying-a-postgresql-schema \"Direct link to Specifying a PostgreSQL schema\")\n\nYou can specify a [PostgreSQL schema](https://www.postgresql.org/docs/current/ddl-schemas.html) by passing in the `schema` option when instantiating `PrismaPg`:\n\n```\nconst adapter = new PrismaPg(pool, {  schema: 'myPostgresSchema'})\n```\n\n## Connection details[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#connection-details \"Direct link to Connection details\")\n\n### Connection URL[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#connection-url \"Direct link to Connection URL\")\n\nPrisma ORM follows the connection URL format specified by [PostgreSQL's official guidelines](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING), but does not support all arguments and includes additional arguments such as `schema`. Here's an overview of the components needed for a PostgreSQL connection URL:\n\n![Structure of the PostgreSQL connection URL](https://www.prisma.io/docs/assets/images/postgresql-connection-string-0615c67fb90a50fb3b0c72c345a41eb6.png)\n\n#### Base URL and path[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#base-url-and-path \"Direct link to Base URL and path\")\n\nHere is an example of the structure of the _base URL_ and the _path_ using placeholder values in uppercase letters:\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE\n```\n\nThe following components make up the _base URL_ of your database, they are always required:\n\n| Name | Placeholder | Description |\n| --- | --- | --- |\n| Host | `HOST` | IP address/domain of your database server, e.g. `localhost` |\n| Port | `PORT` | Port on which your database server is running, e.g. `5432` |\n| User | `USER` | Name of your database user, e.g. `janedoe` |\n| Password | `PASSWORD` | Password for your database user |\n| Database | `DATABASE` | Name of the [database](https://www.postgresql.org/docs/12/manage-ag-overview.html) you want to use, e.g. `mydb` |\n\n#### Arguments[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#arguments \"Direct link to Arguments\")\n\nA connection URL can also take arguments. Here is the same example from above with placeholder values in uppercase letters for three _arguments_:\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?KEY1=VALUE&KEY2=VALUE&KEY3=VALUE\n```\n\nThe following arguments can be used:\n\n| Argument name | Required | Default | Description |\n| --- | --- | --- | --- |\n| `schema` | **Yes** | `public` | Name of the [schema](https://www.postgresql.org/docs/12/ddl-schemas.html) you want to use, e.g. `myschema` |\n| `connection_limit` | No  | `num_cpus * 2 + 1` | Maximum size of the [connection pool](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool) |\n| `connect_timeout` | No  | `5` | Maximum number of seconds to wait for a new connection to be opened, `0` means no timeout |\n| `pool_timeout` | No  | `10` | Maximum number of seconds to wait for a new connection from the pool, `0` means no timeout |\n| `sslmode` | No  | `prefer` | Configures whether to use TLS. Possible values: `prefer`, `disable`, `require` |\n| `sslcert` | No  |     | Path of the server certificate. Certificate paths are [resolved relative to the `./prisma folder`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources#securing-database-connections) |\n| `sslidentity` | No  |     | Path to the PKCS12 certificate |\n| `sslpassword` | No  |     | Password that was used to secure the PKCS12 file |\n| `sslaccept` | No  | `accept_invalid_certs` | Configures whether to check for missing values in the certificate. Possible values: `accept_invalid_certs`, `strict` |\n| `host` | No  |     | Points to a directory that contains a socket to be used for the connection |\n| `socket_timeout` | No  |     | Maximum number of seconds to wait until a single query terminates |\n| `pgbouncer` | No  | `false` | Configure the Engine to [enable PgBouncer compatibility mode](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer) |\n| `statement_cache_size` | No  | `500` | Since 2.1.0: Specifies the number of [prepared statements](https://www.prisma.io/docs/orm/overview/databases/postgresql#prepared-statement-caching) cached per connection |\n| `application_name` | No  |     | Since 3.3.0: Specifies a value for the application\\_name configuration parameter |\n| `channel_binding` | No  | `prefer` | Since 4.8.0: Specifies a value for the channel\\_binding configuration parameter |\n| `options` | No  |     | Since 3.8.0: Specifies command line options to send to the server at connection start |\n\nAs an example, if you want to connect to a schema called `myschema`, set the connection pool size to `5` and configure a timeout for queries of `3` seconds. You can use the following arguments:\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=myschema&connection_limit=5&socket_timeout=3\n```\n\n### Configuring an SSL connection[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#configuring-an-ssl-connection \"Direct link to Configuring an SSL connection\")\n\nYou can add various parameters to the connection URL if your database server uses SSL. Here's an overview of the possible parameters:\n\n*   `sslmode=(disable|prefer|require)`:\n    *   `prefer` (default): Prefer TLS if possible, accept plain text connections.\n    *   `disable`: Do not use TLS.\n    *   `require`: Require TLS or fail if not possible.\n*   `sslcert=<PATH>`: Path to the server certificate. This is the root certificate used by the database server to sign the client certificate. You need to provide this if the certificate doesn't exist in the trusted certificate store of your system. For Google Cloud this likely is `server-ca.pem`. Certificate paths are [resolved relative to the `./prisma folder`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources#securing-database-connections)\n*   `sslidentity=<PATH>`: Path to the PKCS12 certificate database created from client cert and key. This is the SSL identity file in PKCS12 format which you will generate using the client key and client certificate. It combines these two files in a single file and secures them via a password (see next parameter). You can create this file using your client key and client certificate by using the following command (using `openssl`):\n    \n    ```\n    openssl pkcs12 -export -out client-identity.p12 -inkey client-key.pem -in client-cert.pem\n    ```\n    \n*   `sslpassword=<PASSWORD>`: Password that was used to secure the PKCS12 file. The `openssl` command listed in the previous step will ask for a password while creating the PKCS12 file, you will need to provide that same exact password here.\n*   `sslaccept=(strict|accept_invalid_certs)`:\n    *   `strict`: Any missing value in the certificate will lead to an error. For Google Cloud, especially if the database doesn't have a domain name, the certificate might miss the domain/IP address, causing an error when connecting.\n    *   `accept_invalid_certs` (default): Bypass this check. Be aware of the security consequences of this setting.\n\nYour database connection URL will look similar to this:\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?sslidentity=client-identity.p12&sslpassword=mypassword&sslcert=rootca.cert\n```\n\n### Connecting via sockets[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#connecting-via-sockets \"Direct link to Connecting via sockets\")\n\nTo connect to your PostgreSQL database via sockets, you must add a `host` field as a _query parameter_ to the connection URL (instead of setting it as the `host` part of the URI). The value of this parameter then must point to the directory that contains the socket, e.g.: `postgresql://USER:PASSWORD@localhost/database?host=/var/run/postgresql/`\n\nNote that `localhost` is required, the value itself is ignored and can be anything.\n\n> **Note**: You can find additional context in this [GitHub issue](https://github.com/prisma/prisma-client-js/issues/437#issuecomment-592436707).\n\n## Type mapping between PostgreSQL and Prisma schema[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#type-mapping-between-postgresql-and-prisma-schema \"Direct link to Type mapping between PostgreSQL and Prisma schema\")\n\nThese two tables show the type mapping between PostgreSQL and Prisma schema. First [how Prisma ORM scalar types are translated into PostgreSQL database column types](https://www.prisma.io/docs/orm/overview/databases/postgresql#mapping-between-prisma-orm-scalar-types-and-postgresql-database-column-types), and then [how PostgreSQL database column types relate to Prisma ORM scalar and native types](https://www.prisma.io/docs/orm/overview/databases/postgresql#mapping-between-postgresql-database-column-types-to-prisma-orm-scalar-and-native-types).\n\n> Alternatively, see [Prisma schema reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) for type mappings organized by Prisma type.\n\n### Mapping between Prisma ORM scalar types and PostgreSQL database column types[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#mapping-between-prisma-orm-scalar-types-and-postgresql-database-column-types \"Direct link to Mapping between Prisma ORM scalar types and PostgreSQL database column types\")\n\nThe PostgreSQL connector maps the [scalar types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) from the Prisma ORM [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) as follows to database column types:\n\n| Prisma ORM | PostgreSQL |\n| --- | --- |\n| `String` | `text` |\n| `Boolean` | `boolean` |\n| `Int` | `integer` |\n| `BigInt` | `bigint` |\n| `Float` | `double precision` |\n| `Decimal` | `decimal(65,30)` |\n| `DateTime` | `timestamp(3)` |\n| `Json` | `jsonb` |\n| `Bytes` | `bytea` |\n\n### Mapping between PostgreSQL database column types to Prisma ORM scalar and native types[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#mapping-between-postgresql-database-column-types-to-prisma-orm-scalar-and-native-types \"Direct link to Mapping between PostgreSQL database column types to Prisma ORM scalar and native types\")\n\n*   When [introspecting](https://www.prisma.io/docs/orm/prisma-schema/introspection) a PostgreSQL database, the database types are mapped to Prisma ORM types according to the following table.\n*   When [creating a migration](https://www.prisma.io/docs/orm/prisma-migrate) or [prototyping your schema](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) the table is also used - in the other direction.\n\n| PostgreSQL (Type \\| Aliases) | Supported | Prisma ORM | Native database type attribute | Notes |\n| --- | --- | --- | --- | --- |\n| `bigint` \\| `int8` | ✔️  | `BigInt` | `@db.BigInt`\\* | \\*Default mapping for `BigInt` - no type attribute added to schema. |\n| `boolean` \\| `bool` | ✔️  | `Bool` | `@db.Boolean`\\* | \\*Default mapping for `Bool` - no type attribute added to schema. |\n| `timestamp with time zone` \\| `timestamptz` | ✔️  | `DateTime` | `@db.Timestamptz(x)` |     |\n| `time without time zone` \\| `time` | ✔️  | `DateTime` | `@db.Time(x)` |     |\n| `time with time zone` \\| `timetz` | ✔️  | `DateTime` | `@db.Timetz(x)` |     |\n| `numeric(p,s)` \\| `decimal(p,s)` | ✔️  | `Decimal` | `@db.Decimal(x, y)` |     |\n| `real` \\| `float`, `float4` | ✔️  | `Float` | `@db.Real` |     |\n| `double precision` \\| `float8` | ✔️  | `Float` | `@db.DoublePrecision`\\* | \\*Default mapping for `Float` - no type attribute added to schema. |\n| `smallint` \\| `int2` | ✔️  | `Int` | `@db.SmallInt` |     |\n| `integer` \\| `int`, `int4` | ✔️  | `Int` | `@db.Int`\\* | \\*Default mapping for `Int` - no type attribute added to schema. |\n| `smallserial` \\| `serial2` | ✔️  | `Int` | `@db.SmallInt @default(autoincrement())` |     |\n| `serial` \\| `serial4` | ✔️  | `Int` | `@db.Int @default(autoincrement())` |     |\n| `bigserial` \\| `serial8` | ✔️  | `Int` | `@db.BigInt @default(autoincrement()` |     |\n| `character(n)` \\| `char(n)` | ✔️  | `String` | `@db.Char(x)` |     |\n| `character varying(n)` \\| `varchar(n)` | ✔️  | `String` | `@db.VarChar(x)` |     |\n| `money` | ✔️  | `Decimal` | `@db.Money` |     |\n| `text` | ✔️  | `String` | `@db.Text`\\* | \\*Default mapping for `String` - no type attribute added to schema. |\n| `timestamp` | ✔️  | `DateTime` | `@db.TimeStamp`\\* | \\*Default mapping for `DateTime` - no type attribute added to schema. |\n| `date` | ✔️  | `DateTime` | `@db.Date` |     |\n| `enum` | ✔️  | `Enum` | N/A |     |\n| `inet` | ✔️  | `String` | `@db.Inet` |     |\n| `bit(n)` | ✔️  | `String` | `@Bit(x)` |     |\n| `bit varying(n)` | ✔️  | `String` | `@VarBit` |     |\n| `oid` | ✔️  | `Int` | `@db.Oid` |     |\n| `uuid` | ✔️  | `String` | `@db.Uuid` |     |\n| `json` | ✔️  | `Json` | `@db.Json` |     |\n| `jsonb` | ✔️  | `Json` | `@db.JsonB`\\* | \\*Default mapping for `Json` - no type attribute added to schema. |\n| `bytea` | ✔️  | `Bytes` | `@db.ByteA`\\* | \\*Default mapping for `Bytes` - no type attribute added to schema. |\n| `xml` | ✔️  | `String` | `@db.Xml` |     |\n| Array types | ✔️  | `[]` |     |     |\n| `citext` | ✔️\\* | `String` | `@db.Citext` | \\* Only available if [Citext extension is enabled](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#enable-postgresql-extensions-for-native-database-functions). |\n| `interval` | Not yet | `Unsupported` |     |     |\n| `cidr` | Not yet | `Unsupported` |     |     |\n| `macaddr` | Not yet | `Unsupported` |     |     |\n| `tsvector` | Not yet | `Unsupported` |     |     |\n| `tsquery` | Not yet | `Unsupported` |     |     |\n| `int4range` | Not yet | `Unsupported` |     |     |\n| `int8range` | Not yet | `Unsupported` |     |     |\n| `numrange` | Not yet | `Unsupported` |     |     |\n| `tsrange` | Not yet | `Unsupported` |     |     |\n| `tstzrange` | Not yet | `Unsupported` |     |     |\n| `daterange` | Not yet | `Unsupported` |     |     |\n| `point` | Not yet | `Unsupported` |     |     |\n| `line` | Not yet | `Unsupported` |     |     |\n| `lseg` | Not yet | `Unsupported` |     |     |\n| `box` | Not yet | `Unsupported` |     |     |\n| `path` | Not yet | `Unsupported` |     |     |\n| `polygon` | Not yet | `Unsupported` |     |     |\n| `circle` | Not yet | `Unsupported` |     |     |\n| Composite types | Not yet | n/a |     |     |\n| Domain types | Not yet | n/a |     |     |\n\n[Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) adds native database types that are **not yet supported** as [`Unsupported`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unsupported) fields:\n\nschema.prisma\n\n```\nmodel Device {  id   Int                   @id @default(autoincrement())  name String  data Unsupported(\"circle\")}\n```\n\n## Prepared statement caching[​](https://www.prisma.io/docs/orm/overview/databases/postgresql#prepared-statement-caching \"Direct link to Prepared statement caching\")\n\nA [prepared statement](https://www.postgresql.org/docs/current/sql-prepare.html) is a feature that can be used to optimize performance. A prepared statement is parsed, compiled, and optimized only once and then can be executed directly multiple times without the overhead of parsing the query again.\n\nBy caching prepared statements, Prisma Client's [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines) does not repeatedly compile the same query which reduces database CPU usage and query latency.\n\nFor example, here is the generated SQL for two different queries made by Prisma Client:\n\n```\nSELECT * FROM user WHERE name = \"John\";SELECT * FROM user WHERE name = \"Brenda\";\n```\n\nThe two queries after parameterization will be the same, and the second query can skip the preparing step, saving database CPU and one extra roundtrip to the database. Query after parameterization:\n\n```\nSELECT * FROM user WHERE name = $1\n```\n\nEvery database connection maintained by Prisma Client has a separate cache for storing prepared statements. The size of this cache can be tweaked with the `statement_cache_size` parameter in the connection string. By default, Prisma Client caches 500 statements per connection.\n\nDue to the nature of pgBouncer, if the `pgbouncer` parameter is set to `true`, the prepared statement cache is automatically disabled for that connection.",
  "title": "PostgreSQL database connector | Prisma Documentation",
  "description": "This page explains how Prisma can connect to a PostgreSQL database using the PostgreSQL database connector.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/mysql",
  "markdown": "# MySQL database connector | Prisma Documentation\n\n## MySQL/MariaDB\n\nThe MySQL data source connector connects Prisma ORM to a [MySQL](https://www.mysql.com/) or [MariaDB](https://mariadb.org/) database server.\n\nBy default, the MySQL connector contains a database driver responsible for connecting to your database. You can use a [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters) (Preview) to connect to your database using a JavaScript database driver from Prisma Client.\n\n## Example[​](https://www.prisma.io/docs/orm/overview/databases/mysql#example \"Direct link to Example\")\n\nTo connect to a MySQL database server, you need to configure a [`datasource`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) block in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema):\n\nschema.prisma\n\n```\ndatasource db {  provider = \"mysql\"  url      = env(\"DATABASE_URL\")}\n```\n\nThe fields passed to the `datasource` block are:\n\n*   `provider`: Specifies the `mysql` data source connector, which is used both for MySQL and MariaDB.\n*   `url`: Specifies the [connection URL](https://www.prisma.io/docs/orm/overview/databases/mysql#connection-url) for the MySQL database server. In this case, an [environment variable is used](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) to provide the connection URL.\n\n## Connection details[​](https://www.prisma.io/docs/orm/overview/databases/mysql#connection-details \"Direct link to Connection details\")\n\n### Connection URL[​](https://www.prisma.io/docs/orm/overview/databases/mysql#connection-url \"Direct link to Connection URL\")\n\nHere's an overview of the components needed for a MySQL connection URL:\n\n![Structure of the MySQL connection URL](https://www.prisma.io/docs/assets/images/mysql-connection-string-a271692bb82d53b5bbba7a490ffacf36.png)\n\n#### Base URL and path[​](https://www.prisma.io/docs/orm/overview/databases/mysql#base-url-and-path \"Direct link to Base URL and path\")\n\nHere is an example of the structure of the _base URL_ and the _path_ using placeholder values in uppercase letters:\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE\n```\n\nThe following components make up the _base URL_ of your database, they are always required:\n\n| Name | Placeholder | Description |\n| --- | --- | --- |\n| Host | `HOST` | IP address/domain of your database server, e.g. `localhost` |\n| Port | `PORT` | Port on which your database server is running, e.g. `5432` (default is `3306`, or no port when using Unix socket) |\n| User | `USER` | Name of your database user, e.g. `janedoe` |\n| Password | `PASSWORD` | Password for your database user |\n| Database | `DATABASE` | Name of the [database](https://dev.mysql.com/doc/refman/8.0/en/creating-database.html) you want to use, e.g. `mydb` |\n\n#### Arguments[​](https://www.prisma.io/docs/orm/overview/databases/mysql#arguments \"Direct link to Arguments\")\n\nA connection URL can also take arguments. Here is the same example from above with placeholder values in uppercase letters for three _arguments_:\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE?KEY1=VALUE&KEY2=VALUE&KEY3=VALUE\n```\n\nThe following arguments can be used:\n\n| Argument name | Required | Default | Description |\n| --- | --- | --- | --- |\n| `connection_limit` | No  | `num_cpus * 2 + 1` | Maximum size of the [connection pool](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool) |\n| `connect_timeout` | No  | `5` | Maximum number of seconds to wait for a new connection to be opened, `0` means no timeout |\n| `pool_timeout` | No  | `10` | Maximum number of seconds to wait for a new connection from the pool, `0` means no timeout |\n| `sslcert` | No  |     | Path to the server certificate. Certificate paths are [resolved relative to the `./prisma folder`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources#securing-database-connections) |\n| `sslidentity` | No  |     | Path to the PKCS12 certificate |\n| `sslpassword` | No  |     | Password that was used to secure the PKCS12 file |\n| `sslaccept` | No  | `accept_invalid_certs` | Configures whether to check for missing values in the certificate. Possible values: `accept_invalid_certs`, `strict` |\n| `socket` | No  |     | Points to a directory that contains a socket to be used for the connection |\n| `socket_timeout` | No  |     | Number of seconds to wait until a single query terminates |\n\nAs an example, if you want to set the connection pool size to `5` and configure a timeout for queries of `3` seconds, you can use the following arguments:\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE?connection_limit=5&socket_timeout=3\n```\n\n### Configuring an SSL connection[​](https://www.prisma.io/docs/orm/overview/databases/mysql#configuring-an-ssl-connection \"Direct link to Configuring an SSL connection\")\n\nYou can add various parameters to the connection URL if your database server uses SSL. Here's an overview of the possible parameters:\n\n*   `sslcert=<PATH>`: Path to the server certificate. This is the root certificate used by the database server to sign the client certificate. You need to provide this if the certificate doesn't exist in the trusted certificate store of your system. For Google Cloud this likely is `server-ca.pem`. Certificate paths are [resolved relative to the `./prisma folder`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources#securing-database-connections)\n    \n*   `sslidentity=<PATH>`: Path to the PKCS12 certificate database created from client cert and key. This is the SSL identity file in PKCS12 format which you will generate using the client key and client certificate. It combines these two files in a single file and secures them via a password (see next parameter). You can create this file using your client key and client certificate by using the following command (using `openssl`):\n    \n    ```\n    openssl pkcs12 -export -out client-identity.p12 -inkey client-key.pem -in client-cert.pem\n    ```\n    \n*   `sslpassword=<PASSWORD>`: Password that was used to secure the PKCS12 file. The `openssl` command listed in the previous step will ask for a password while creating the PKCS12 file, you will need to provide that same exact password here.\n    \n*   `sslaccept=(strict|accept_invalid_certs)`:\n    \n    *   `strict`: Any missing value in the certificate will lead to an error. For Google Cloud, especially if the database doesn't have a domain name, the certificate might miss the domain/IP address, causing an error when connecting.\n    *   `accept_invalid_certs` (default): Bypass this check. Be aware of the security consequences of this setting.\n\nYour database connection URL will look similar to this:\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE?sslidentity=client-identity.p12&sslpassword=mypassword&sslcert=rootca.cert\n```\n\n### Connecting via sockets[​](https://www.prisma.io/docs/orm/overview/databases/mysql#connecting-via-sockets \"Direct link to Connecting via sockets\")\n\nTo connect to your MySQL/MariaDB database via a socket, you must add a `socket` field as a _query parameter_ to the connection URL (instead of setting it as the `host` part of the URI). The value of this parameter then must point to the directory that contains the socket, e.g. on a default installation of MySQL/MariaDB on Ubuntu or Debian use: `mysql://USER:PASSWORD@HOST/DATABASE?socket=/run/mysqld/mysqld.sock`\n\nNote that `localhost` is required, the value itself is ignored and can be anything.\n\n> **Note**: You can find additional context in this [GitHub issue](https://github.com/prisma/prisma-client-js/issues/437#issuecomment-592436707).\n\n## Type mapping between MySQL to Prisma schema[​](https://www.prisma.io/docs/orm/overview/databases/mysql#type-mapping-between-mysql-to-prisma-schema \"Direct link to Type mapping between MySQL to Prisma schema\")\n\nThe MySQL connector maps the [scalar types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) from the Prisma ORM [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) as follows to native column types:\n\n> Alternatively, see [Prisma schema reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) for type mappings organized by Prisma ORM type.\n\n### Native type mapping from Prisma ORM to MySQL[​](https://www.prisma.io/docs/orm/overview/databases/mysql#native-type-mapping-from-prisma-orm-to-mysql \"Direct link to Native type mapping from Prisma ORM to MySQL\")\n\n| Prisma ORM | MySQL | Notes |\n| --- | --- | --- |\n| `String` | `VARCHAR(191)` |     |\n| `Boolean` | `BOOLEAN` | In MySQL `BOOLEAN` is a synonym for `TINYINT(1)` |\n| `Int` | `INT` |     |\n| `BigInt` | `BIGINT` |     |\n| `Float` | `DOUBLE` |     |\n| `Decimal` | `DECIMAL(65,30)` |     |\n| `DateTime` | `DATETIME(3)` | Currently, Prisma ORM does not support zero dates (`0000-00-00`, `00:00:00`) in MySQL |\n| `Json` | `JSON` | Supported in MySQL 5.7+ only |\n| `Bytes` | `LONGBLOB` |     |\n\n### Native type mapping from Prisma ORM to MariaDB[​](https://www.prisma.io/docs/orm/overview/databases/mysql#native-type-mapping-from-prisma-orm-to-mariadb \"Direct link to Native type mapping from Prisma ORM to MariaDB\")\n\n| Prisma ORM | MariaDB | Notes |\n| --- | --- | --- |\n| `String` | `VARCHAR(191)` |     |\n| `Boolean` | `BOOLEAN` | In MariaDB `BOOLEAN` is a synonym for `TINYINT(1)` |\n| `Int` | `INT` |     |\n| `BigInt` | `BIGINT` |     |\n| `Float` | `DOUBLE` |     |\n| `Decimal` | `DECIMAL(65,30)` |     |\n| `DateTime` | `DATETIME(3)` |     |\n| `Json` | `LONGTEXT` | See [https://mariadb.com/kb/en/json-data-type/](https://mariadb.com/kb/en/json-data-type/) |\n| `Bytes` | `LONGBLOB` |     |\n\n### Native type mappings[​](https://www.prisma.io/docs/orm/overview/databases/mysql#native-type-mappings \"Direct link to Native type mappings\")\n\nWhen introspecting a MySQL database, the database types are mapped to Prisma ORM according to the following table:\n\n| MySQL | Prisma ORM | Supported | Native database type attribute | Notes |\n| --- | --- | --- | --- | --- |\n| `serial` | `BigInt` | ✔️  | `@db.UnsignedBigInt @default(autoincrement())` |     |\n| `bigint` | `BigInt` | ✔️  | `@db.BigInt` |     |\n| `bigint unsigned` | `BigInt` | ✔️  | `@db.UnsignedBigInt` |     |\n| `bit` | `Bytes` | ✔️  | `@db.Bit(x)` | `bit(1)` maps to `Boolean` - all other `bit(x)` map to `Bytes` |\n| `boolean` \\| `tinyint(1)` | `Boolean` | ✔️  | `@db.TinyInt(1)` |     |\n| `varbinary` | `Bytes` | ✔️  | `@db.VarBinary` |     |\n| `longblob` | `Bytes` | ✔️  | `@db.LongBlob` |     |\n| `tinyblob` | `Bytes` | ✔️  | `@db.TinyBlob` |     |\n| `mediumblob` | `Bytes` | ✔️  | `@db.MediumBlob` |     |\n| `blob` | `Bytes` | ✔️  | `@db.Blob` |     |\n| `binary` | `Bytes` | ✔️  | `@db.Binary` |     |\n| `date` | `DateTime` | ✔️  | `@db.Date` |     |\n| `datetime` | `DateTime` | ✔️  | `@db.DateTime` |     |\n| `timestamp` | `DateTime` | ✔️  | `@db.TimeStamp` |     |\n| `time` | `DateTime` | ✔️  | `@db.Time` |     |\n| `decimal(a,b)` | `Decimal` | ✔️  | `@db.Decimal(x,y)` |     |\n| `numeric(a,b)` | `Decimal` | ✔️  | `@db.Decimal(x,y)` |     |\n| `enum` | `Enum` | ✔️  | N/A |     |\n| `float` | `Float` | ✔️  | `@db.Float` |     |\n| `double` | `Float` | ✔️  | `@db.Double` |     |\n| `smallint` | `Int` | ✔️  | `@db.SmallInt` |     |\n| `smallint unsigned` | `Int` | ✔️  | `@db.UnsignedSmallInt` |     |\n| `mediumint` | `Int` | ✔️  | `@db.MediumInt` |     |\n| `mediumint unsigned` | `Int` | ✔️  | `@db.UnsignedMediumInt` |     |\n| `int` | `Int` | ✔️  | `@db.Int` |     |\n| `int unsigned` | `Int` | ✔️  | `@db.UnsignedInt` |     |\n| `tinyint` | `Int` | ✔️  | `@db.TinyInt(x)` | `tinyint(1)` maps to `Boolean` all other `tinyint(x)` map to `Int` |\n| `tinyint unsigned` | `Int` | ✔️  | `@db.UnsignedTinyInt(x)` | `tinyint(1) unsigned` **does not** map to `Boolean` |\n| `year` | `Int` | ✔️  | `@db.Year` |     |\n| `json` | `Json` | ✔️  | `@db.Json` | Supported in MySQL 5.7+ only |\n| `char` | `String` | ✔️  | `@db.Char(x)` |     |\n| `varchar` | `String` | ✔️  | `@db.VarChar(x)` |     |\n| `tinytext` | `String` | ✔️  | `@db.TinyText` |     |\n| `text` | `String` | ✔️  | `@db.Text` |     |\n| `mediumtext` | `String` | ✔️  | `@db.MediumText` |     |\n| `longtext` | `String` | ✔️  | `@db.LongText` |     |\n| `set` | `Unsupported` | Not yet |     |     |\n| `geometry` | `Unsupported` | Not yet |     |     |\n| `point` | `Unsupported` | Not yet |     |     |\n| `linestring` | `Unsupported` | Not yet |     |     |\n| `polygon` | `Unsupported` | Not yet |     |     |\n| `multipoint` | `Unsupported` | Not yet |     |     |\n| `multilinestring` | `Unsupported` | Not yet |     |     |\n| `multipolygon` | `Unsupported` | Not yet |     |     |\n| `geometrycollection` | `Unsupported` | Not yet |     |     |\n\n[Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) adds native database types that are **not yet supported** as [`Unsupported`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unsupported) fields:\n\nschema.prisma\n\n```\nmodel Device {  id   Int                   @id @default(autoincrement())  name String  data Unsupported(\"circle\")}\n```\n\n## Engine[​](https://www.prisma.io/docs/orm/overview/databases/mysql#engine \"Direct link to Engine\")\n\nIf you are using a version of MySQL where MyISAM is the default engine, you must specify `ENGINE = InnoDB;` when you create a table. If you introspect a database that uses a different engine, relations in the Prisma Schema are not created (or lost, if the relation already existed).\n\n## Permissions[​](https://www.prisma.io/docs/orm/overview/databases/mysql#permissions \"Direct link to Permissions\")\n\nA fresh new installation of MySQL/MariaDB has by default only a `root` database user. Do not use `root` user in your Prisma configuration, but instead create a database and database user for each application. On most Linux hosts (e.g. Ubuntu) you can simply run this as the Linux `root` user (which automatically has database `root` access as well):\n\n```\nmysql -e \"CREATE DATABASE IF NOT EXISTS $DB_PRISMA;\"mysql -e \"GRANT ALL PRIVILEGES ON $DB_PRISMA.* TO $DB_USER@'%' IDENTIFIED BY '$DB_PASSWORD';\"\n```\n\nThe above is enough to run the `prisma db pull` and `prisma db push` commands. In order to also run `prisma migrate` commands these permissions need to be granted:\n\n```\nmysql -e \"GRANT CREATE, DROP, REFERENCES, ALTER ON *.* TO $DB_USER@'%';\"\n```",
  "title": "MySQL database connector | Prisma Documentation",
  "description": "This page explains how Prisma can connect to a MySQL or MariaDB database using the MySQL database connector.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/accelerate",
  "markdown": "# Prisma Accelerate | Prisma Documentation\n\n[Prisma Accelerate](https://www.prisma.io/data-platform/accelerate) is a managed connection pooler with global caching that helps speed up database queries. With Accelerate, you can easily configure connection pooling and choose the right cache strategy for your app.\n\n[\n\n###### Get started\n\nSet up connection pooling and global caching for your app in 5 minutes.\n\n](https://www.prisma.io/docs/accelerate/getting-started)[\n\n###### Examples\n\nExplore our ready-to-run examples using Accelerate.\n\n](https://github.com/prisma/prisma-examples?tab=readme-ov-file#prisma-accelerate)\n\n  \n[\n\n###### Speed Test\n\nRun the speed test to see how Prisma Accelerate can make your app faster.\n\n](https://accelerate-speed-test.prisma.io/)\n\n## Supported databases[​](https://www.prisma.io/docs/accelerate#supported-databases \"Direct link to Supported databases\")\n\nAccelerate works with the database you already have, whether it is publicly accessible, or via an IP allowlist.\n\n[![](https://www.prisma.io/docs/img/technologies/postgresqlsimple.svg)](https://www.prisma.io/docs/accelerate/getting-started)[![](https://www.prisma.io/docs/img/technologies/mysqlsimple.svg)](https://www.prisma.io/docs/accelerate/getting-started)[![](https://www.prisma.io/docs/img/technologies/mariadb.svg)![](https://www.prisma.io/docs/img/technologies/mariadbdark.svg)](https://www.prisma.io/docs/accelerate/getting-started)[![](https://www.prisma.io/docs/img/technologies/planetscale.svg)![](https://www.prisma.io/docs/img/technologies/planetscaledark.svg)](https://www.prisma.io/docs/accelerate/getting-started)[![](https://www.prisma.io/docs/img/technologies/cockroachdbdark.svg)](https://www.prisma.io/docs/accelerate/getting-started)[![](https://www.prisma.io/docs/img/technologies/mongodbsimple.svg)](https://www.prisma.io/docs/accelerate/getting-started)\n\n  \n\n## In this section[​](https://www.prisma.io/docs/accelerate#in-this-section \"Direct link to In this section\")\n\n[](https://www.prisma.io/docs/accelerate)\n\n[\n\n## What is Accelerate\n\n](https://www.prisma.io/docs/accelerate/what-is-accelerate)\n\n[\n\n## Getting started\n\n](https://www.prisma.io/docs/accelerate/getting-started)\n\n[\n\n## Connection Pooling\n\n](https://www.prisma.io/docs/accelerate/connection-pooling)\n\n[\n\n## Caching\n\n](https://www.prisma.io/docs/accelerate/caching)\n\n[\n\n## API Reference\n\n](https://www.prisma.io/docs/accelerate/api-reference)\n\n[\n\n## Limitations\n\n](https://www.prisma.io/docs/accelerate/limitations)\n\n[\n\n## Evaluating\n\n](https://www.prisma.io/docs/accelerate/evaluating)\n\n[\n\n## Local development\n\n](https://www.prisma.io/docs/accelerate/local-development)\n\n[\n\n## FAQ\n\n](https://www.prisma.io/docs/accelerate/faq)\n\n[\n\n## Troubleshooting\n\n](https://www.prisma.io/docs/accelerate/troubleshoot)\n\n[\n\n## Feedback\n\n](https://www.prisma.io/docs/accelerate/feedback)",
  "title": "Prisma Accelerate | Prisma Documentation",
  "description": "Prisma Accelerate is a global database cache with built-in connection pooling that helps improve database performance in Serverless and Edge applications.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse",
  "markdown": "# Prisma Pulse | Prisma Documentation\n\n[Prisma Pulse](https://www.prisma.io/data-platform/pulse) lets you subscribe to any changes in your database easily and in a type-safe way using Prisma Client, enabling you to trigger events and actions in real-time.\n\n[\n\n###### Get started\n\nAdd Pulse to your app in minutes to stream database changes to your app in real-time.\n\n](https://www.prisma.io/docs/pulse/getting-started)[\n\n###### Examples\n\nExplore our ready-to-run examples using Pulse.\n\n](https://github.com/prisma/prisma-examples?tab=readme-ov-file#prisma-pulse)\n\n  \n\n## Supported databases and providers[​](https://www.prisma.io/docs/pulse#supported-databases-and-providers \"Direct link to Supported databases and providers\")\n\nPulse works with your existing database and providers.\n\n[![](https://www.prisma.io/docs/img/technologies/postgresqlsimple.svg)](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions)\n\n[![](https://www.prisma.io/docs/img/technologies/gcp.svg)](https://www.prisma.io/docs/pulse/database-setup)[![](https://www.prisma.io/docs/img/technologies/aws.svg)![](https://www.prisma.io/docs/img/technologies/awsdark.svg)](https://www.prisma.io/docs/pulse/database-setup/aws-rds)[![](https://www.prisma.io/docs/img/technologies/supabase.svg)](https://www.prisma.io/docs/pulse/database-setup/supabase)[![](https://www.prisma.io/docs/img/technologies/neon.svg)](https://www.prisma.io/docs/pulse/database-setup/neon)[![](https://www.prisma.io/docs/img/technologies/railway.svg)![](https://www.prisma.io/docs/img/technologies/railway-dark.svg)](https://www.prisma.io/docs/pulse/database-setup/railway)\n\n  \n\n## In this section[​](https://www.prisma.io/docs/pulse#in-this-section \"Direct link to In this section\")\n\n[](https://www.prisma.io/docs/pulse)\n\n[\n\n## What is Pulse\n\n](https://www.prisma.io/docs/pulse/what-is-pulse)\n\n[\n\n## Getting started\n\n](https://www.prisma.io/docs/pulse/getting-started)\n\n[\n\n## Database setup\n\n](https://www.prisma.io/docs/pulse/database-setup)\n\n[\n\n## Database events\n\n](https://www.prisma.io/docs/pulse/database-events)\n\n[\n\n## API reference\n\n](https://www.prisma.io/docs/pulse/api-reference)\n\n[\n\n## Known limitations\n\n](https://www.prisma.io/docs/pulse/known-limitations)\n\n[\n\n## FAQ\n\n](https://www.prisma.io/docs/pulse/faq)\n\n[\n\n## Feedback\n\n](https://www.prisma.io/docs/pulse/feedback)",
  "title": "Prisma Pulse | Prisma Documentation",
  "description": "Prisma Pulse enables real-time database events with type-safe Prisma Client subscriptions.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/sqlite",
  "markdown": "# SQLite database connector | Prisma Documentation\n\nThe SQLite data source connector connects Prisma ORM to a [SQLite](https://www.sqlite.org/) database file. These files always have the file ending `.db` (e.g.: `dev.db`).\n\nBy default, the SQLite connector contains a database driver responsible for connecting to your database. You can use a [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters) (Preview) to connect to your database using a JavaScript database driver from Prisma Client.\n\n## Example[​](https://www.prisma.io/docs/orm/overview/databases/sqlite#example \"Direct link to Example\")\n\nTo connect to a SQLite database file, you need to configure a [`datasource`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) block in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema):\n\nschema.prisma\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:./dev.db\"}\n```\n\nThe fields passed to the `datasource` block are:\n\n*   `provider`: Specifies the `sqlite` data source connector.\n*   `url`: Specifies the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for the SQLite database. The connection URL always starts with the prefix `file:` and then contains a file path pointing to the SQLite database file. In this case, the file is located in the same directory and called `dev.db`.\n\n## Type mapping between SQLite to Prisma schema[​](https://www.prisma.io/docs/orm/overview/databases/sqlite#type-mapping-between-sqlite-to-prisma-schema \"Direct link to Type mapping between SQLite to Prisma schema\")\n\nThe SQLite connector maps the [scalar types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) from the [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) to native column types as follows:\n\n> Alternatively, see [Prisma schema reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) for type mappings organized by Prisma ORM type.\n\n### Native type mapping from Prisma ORM to SQLite[​](https://www.prisma.io/docs/orm/overview/databases/sqlite#native-type-mapping-from-prisma-orm-to-sqlite \"Direct link to Native type mapping from Prisma ORM to SQLite\")\n\n| Prisma ORM | SQLite |\n| --- | --- |\n| `String` | `TEXT` |\n| `Boolean` | `BOOLEAN` |\n| `Int` | `INTEGER` |\n| `BigInt` | `INTEGER` |\n| `Float` | `REAL` |\n| `Decimal` | `DECIMAL` |\n| `DateTime` | `NUMERIC` |\n| `Json` | Not supported |\n| `Bytes` | `BLOB` |\n\n## Rounding errors on big numbers[​](https://www.prisma.io/docs/orm/overview/databases/sqlite#rounding-errors-on-big-numbers \"Direct link to Rounding errors on big numbers\")\n\nSQLite is a loosely-typed database. If your Schema has a field of type `Int`, then Prisma ORM prevents you from inserting a value larger than an integer. However, nothing prevents the database from directly accepting a bigger number. These manually-inserted big numbers cause rounding errors when queried.\n\nTo avoid this problem, Prisma ORM 4.0.0 and later checks numbers on the way out of the database to verify that they fit within the boundaries of an integer. If a number does not fit, then Prisma ORM throws a P2023 error, such as:\n\n```\nInconsistent column data: Conversion failed:Value 9223372036854775807 does not fit in an INT column,try migrating the 'int' column type to BIGINT\n```\n\n## Connection details[​](https://www.prisma.io/docs/orm/overview/databases/sqlite#connection-details \"Direct link to Connection details\")\n\n### Connection URL[​](https://www.prisma.io/docs/orm/overview/databases/sqlite#connection-url \"Direct link to Connection URL\")\n\nThe connection URL of a SQLite connector points to a file on your file system. For example, the following two paths are equivalent because the `.db` is in the same directory:\n\nschema.prisma\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:./dev.db\"}\n```\n\nis the same as:\n\nschema.prisma\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:dev.db\"}\n```\n\nYou can also target files from the root or any other place in your file system:\n\nschema.prisma\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:/Users/janedoe/dev.db\"}\n```",
  "title": "SQLite database connector | Prisma Documentation",
  "description": "This page explains how Prisma can connect to a SQLite database using the SQLite database connector.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/sql-server",
  "markdown": "# Microsoft SQL Server | Prisma Documentation\n\nThe Microsoft SQL Server data source connector connects Prisma ORM to a [Microsoft SQL Server](https://docs.microsoft.com/en-us/sql/sql-server/?view=sql-server-ver15) database server.\n\n## Example[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#example \"Direct link to Example\")\n\nTo connect to a Microsoft SQL Server database, you need to configure a [`datasource`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) block in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema):\n\nschema.prisma\n\n```\ndatasource db {  provider = \"sqlserver\"  url      = env(\"DATABASE_URL\")}\n```\n\nThe fields passed to the `datasource` block are:\n\n*   `provider`: Specifies the `sqlserver` data source connector.\n*   `url`: Specifies the [connection URL](https://www.prisma.io/docs/orm/overview/databases/sql-server#connection-details) for the Microsoft SQL Server database. In this case, an [environment variable is used](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) to provide the connection URL.\n\n## Connection details[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#connection-details \"Direct link to Connection details\")\n\nThe connection URL used to connect to an Microsoft SQL Server database follows the [JDBC standard](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15).\n\nThe following example uses SQL authentication (username and password) with an enabled TLS encrypted connection:\n\n```\nsqlserver://HOST[:PORT];database=DATABASE;user=USER;password=PASSWORD;encrypt=true\n```\n\nwarning\n\nNote: If you are using any of the following characters in your connection string, [you will need to escape them](https://learn.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver16#escaping-values-in-the-connection-url).\n\n```\n:\\=;/[]{}  # these are characters that will need to be escaped\n```\n\nTo escape these characters, use curly braces `{}` around values that contain special characters. As an example:\n\n```\nsqlserver://HOST[:PORT];database=DATABASE;user={MyServer/MyUser};password={ThisIsA:SecurePassword;};encrypt=true\n```\n\n### Arguments[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#arguments \"Direct link to Arguments\")\n\n| Argument name | Required | Default | Comments |\n| --- | --- | --- | --- |\n| *   `database`<br>*   `initial catalog` | No  | `master` | The database to connect to. |\n| *   `username`<br>*   `user`<br>*   `uid`<br>*   `userid` | No - see Comments |     | SQL Server login (such as `sa`) _or_ a valid Windows (Active Directory) username if `integratedSecurity` is set to `true` (Windows only). |\n| *   `password`<br>*   `pwd` | No - see Comments |     | Password for SQL Server login _or_ Windows (Active Directory) username if `integratedSecurity` is set to `true` (Windows only). |\n| `encrypt` | No  | `true` | Configures whether to use TLS all the time, or only for the login procedure, possible values: `true` (use always), `false` (only for login credentials). |\n| `integratedSecurity` | No  |     | Enables [Windows authentication (integrated security)](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/authentication-in-sql-server), possible values: `true`, `false`, `yes`, `no`. If set to `true` or `yes` and `username` and `password` are present, login is performed through Windows Active Directory. If login details are not given via separate arguments, the current logged in Windows user is used to login to the server. |\n| `connectionLimit` | No  | `num_cpus * 2 + 1` | Maximum size of the [connection pool](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool) |\n| `connectTimeout` | No  | `5` | Maximum number of seconds to wait for a new connection |\n| `schema` | No  | `dbo` | Added as a prefix to all the queries if schema name is not the default. |\n| *   `loginTimeout`<br>*   `connectTimeout`<br>*   `connectionTimeout` | No  |     | Number of seconds to wait for login to succeed. |\n| `socketTimeout` | No  |     | Number of seconds to wait for each query to succeed. |\n| `isolationLevel` | No  |     | Sets [transaction isolation level](https://docs.microsoft.com/en-us/sql/t-sql/statements/set-transaction-isolation-level-transact-sql?view=sql-server-ver15). |\n| `poolTimeout` | No  | `10` | Maximum number of seconds to wait for a new connection from the pool. If all connections are in use, the database will return a `PoolTimeout` error after waiting for the given time. |\n| *   `ApplicationName`<br>*   `Application Name`<br><br>(case insensitive) | No  |     | Sets the application name for the connection. Since version 2.28.0. |\n| `trustServerCertificate` | No  | `false` | Configures whether to trust the server certificate. |\n| `trustServerCertificateCA` | No  |     | A path to a certificate authority file to be used instead of the system certificates to authorize the server certificate. Must be either in `pem`, `crt` or `der` format. Cannot be used together with `trustServerCertificate` parameter. |\n\n### Using [integrated security](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/authentication-in-sql-server) (Windows only)[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#using-integrated-security-windows-only \"Direct link to using-integrated-security-windows-only\")\n\nThe following example uses the currently logged in Windows user to log in to Microsoft SQL Server:\n\n```\nsqlserver://localhost:1433;database=sample;integratedSecurity=true;trustServerCertificate=true;\n```\n\nThe following example uses a specific Active Directory user to log in to Microsoft SQL Server:\n\n```\nsqlserver://localhost:1433;database=sample;integratedSecurity=true;username=prisma;password=aBcD1234;trustServerCertificate=true;\n```\n\n#### Connect to a named instance[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#connect-to-a-named-instance \"Direct link to Connect to a named instance\")\n\nThe following example connects to a named instance of Microsoft SQL Server (`mycomputer\\sql2019`) using integrated security:\n\n```\nsqlserver://mycomputer\\sql2019;database=sample;integratedSecurity=true;trustServerCertificate=true;\n```\n\n## Type mapping between Microsoft SQL Server to Prisma schema[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#type-mapping-between-microsoft-sql-server-to-prisma-schema \"Direct link to Type mapping between Microsoft SQL Server to Prisma schema\")\n\nFor type mappings organized by Prisma ORM type, refer to the [Prisma schema reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) documentation.\n\n## Supported versions[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#supported-versions \"Direct link to Supported versions\")\n\nSee [Supported databases](https://www.prisma.io/docs/orm/reference/supported-databases).\n\n## Limitations and known issues[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#limitations-and-known-issues \"Direct link to Limitations and known issues\")\n\n### Prisma Migrate caveats[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#prisma-migrate-caveats \"Direct link to Prisma Migrate caveats\")\n\nPrisma Migrate is supported in [2.13.0](https://github.com/prisma/prisma/releases/tag/2.13.0) and later with the following caveats:\n\n#### Database schema names[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#database-schema-names \"Direct link to Database schema names\")\n\nSQL Server does not have an equivalent to the PostgreSQL `SET search_path` command familiar from PostgreSQL. This means that when you create migrations, you must define the same schema name in the connection URL that is used by the production database. For most of the users this is `dbo` (the default value). However, if the production database uses another schema name, all the migration SQL must be either edited by hand to reflect the production _or_ the connection URL must be changed before creating migrations (for example: `schema=name`).\n\n#### Cyclic references[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#cyclic-references \"Direct link to Cyclic references\")\n\nCircular references can occur between models when each model references another, creating a closed loop. When using a Microsoft SQL Server database, Prisma ORM will show a validation error if the [referential action](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) on a relation is set to something other than [`NoAction`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#noaction).\n\nSee [Special rules for referential actions in SQL Server](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions) for more information.\n\n#### Destructive changes[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#destructive-changes \"Direct link to Destructive changes\")\n\nCertain migrations will cause more changes than you might expect. For example:\n\n*   Adding or removing `autoincrement()`. This cannot be achieved by modifying the column, but requires recreating the table (including all constraints, indices, and foreign keys) and moving all data between the tables.\n*   Additionally, it is not possible to delete all the columns from a table (possible with PostgreSQL or MySQL). If a migration needs to recreate all table columns, it will also re-create the table.\n\n#### Shared default values are not supported[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#shared-default-values-are-not-supported \"Direct link to Shared default values are not supported\")\n\nIn some cases, user might want to define default values as shared objects:\n\ndefault\\_objects.sql\n\n```\nCREATE DEFAULT catcat AS 'musti';CREATE TABLE cats (    id INT IDENTITY PRIMARY KEY,    name NVARCHAR(1000));sp_bindefault 'catcat', 'dbo.cats.name';\n```\n\nUsing the stored procedure `sp_bindefault`, the default value `catcat` can be used in more than one table. The way Prisma ORM manages default values is per table:\n\ndefault\\_per\\_table.sql\n\n```\nCREATE TABLE cats (    id INT IDENTITY PRIMARY KEY,    name NVARCHAR(1000) CONSTRAINT DF_cat_name DEFAULT 'musti');\n```\n\nThe last example, when introspected, leads to the following model:\n\nschema.prisma\n\n```\nmodel cats {  id   Int     @id @default(autoincrement())  name String? @default(\"musti\")}\n```\n\nAnd the first doesn't get the default value introspected:\n\nschema.prisma\n\n```\nmodel cats {  id   Int     @id @default(autoincrement())  name String?}\n```\n\nIf using Prisma Migrate together with shared default objects, changes to them must be done manually to the SQL.\n\n### Data model limitations[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#data-model-limitations \"Direct link to Data model limitations\")\n\n#### Cannot use column with `UNIQUE` constraint and filtered index as foreign key[​](https://www.prisma.io/docs/orm/overview/databases/sql-server#cannot-use-column-with-unique-constraint-and-filtered-index-as-foreign-key \"Direct link to cannot-use-column-with-unique-constraint-and-filtered-index-as-foreign-key\")\n\nMicrosoft SQL Server [only allows one `NULL` value in a column that has a `UNIQUE` constraint](https://docs.microsoft.com/en-us/sql/relational-databases/tables/unique-constraints-and-check-constraints?view=sql-server-ver15#Unique). For example:\n\n*   A table of users has a column named `license_number`\n*   The `license_number` field has a `UNIQUE` constraint\n*   The `license_number` field only allows **one** `NULL` value\n\nThe standard way to get around this issue is to create a filtered unique index that excludes `NULL` values. This allows you to insert multiple `NULL` values. If you do not create an index in the database, you will get an error if you try to insert more than one `null` value into a column with Prisma Client.\n\n_However_, creating an index makes it impossible to use `license_number` as a foreign key in the database (or a relation scalar field in corresponding Prisma Schema)",
  "title": "Microsoft SQL Server | Prisma Documentation",
  "description": "This page explains how Prisma can connect to a Microsoft SQL Server database using the Microsoft SQL Server database connector.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/accelerate/what-is-accelerate",
  "markdown": "# What is Accelerate | Prisma Documentation\n\n[Accelerate](https://www.prisma.io/data-platform/accelerate) is a global database cache available in 300 locations that you can use to achieve up to 1000x faster database queries.\n\nIts main features are:\n\n*   a global cache\n*   scalable connection pool for serverless and edge applications\n*   usage of Prisma Client at the edge (e.g. in Cloudflare Workers or Vercel Edge Functions)\n\nThe goal of Accelerate is to improve response times and reduce database load. It works by caching data at the edge using established caching patterns that you control.\n\nWhile Accelerate is beneficial for all types of applications, being at the edge provides additional benefits to edge function environments like [Vercel Edge Functions](https://vercel.com/docs/concepts/functions/edge-functions), [Cloudflare Workers](https://workers.cloudflare.com/), and [Deno Deploy](https://deno.com/deploy). Cache hits can be served from data centers near the user regardless of the region of the database.\n\n## See Accelerate in action[​](https://www.prisma.io/docs/accelerate/what-is-accelerate#see-accelerate-in-action \"Direct link to See Accelerate in action\")\n\nWe built a small sample application, [Accelerate Speed Test](https://accelerate-speed-test.prisma.io/). The app compares the performance of cached and uncached queries side by side. The app is [open source](https://github.com/prisma/accelerate-speed-test) and you can clone it to try it yourself.\n\n![Screenshot of the Accelerate Speed Test app showing cached query performance](https://www.prisma.io/docs/assets/images/accelerate-3d29c60f63228fcc48218396505a5bb6.png)",
  "title": "What is Accelerate | Prisma Documentation",
  "description": "Learn about Accelerate, a global cache and serverless connection pool that makes your database queries faster.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/cockroachdb",
  "markdown": "# CockroachDB | Prisma Documentation\n\nThis guide discusses the concepts behind using Prisma ORM and CockroachDB, explains the commonalities and differences between CockroachDB and other database providers, and leads you through the process for configuring your application to integrate with CockroachDB.\n\ninfo\n\nThe CockroachDB connector is generally available in versions `3.14.0` and later. It was first added as a [Preview feature](https://www.prisma.io/docs/orm/reference/preview-features) in version [`3.9.0`](https://github.com/prisma/prisma/releases/tag/3.9.0) with support for Introspection, and Prisma Migrate support was added in [`3.11.0`](https://github.com/prisma/prisma/releases/tag/3.11.0).\n\n## What is CockroachDB?[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#what-is-cockroachdb \"Direct link to What is CockroachDB?\")\n\nCockroachDB is a distributed database that is designed for scalability and high availability. Features include:\n\n*   **Compatibility with PostgreSQL:** CockroachDB is compatible with PostgreSQL, allowing interoperability with a large ecosystem of existing products\n*   **Built-in scaling:** CockroachDB comes with automated replication, failover and repair capabilities to allow easy horizontal scaling of your application\n\n## Commonalities with other database providers[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#commonalities-with-other-database-providers \"Direct link to Commonalities with other database providers\")\n\nCockroachDB is largely compatible with PostgreSQL, and can mostly be used with Prisma ORM in the same way. You can still:\n\n*   model your database with the [Prisma Schema Language](https://www.prisma.io/docs/orm/prisma-schema)\n*   connect to your database, using Prisma ORM's [`cockroachdb` database connector](https://www.prisma.io/docs/orm/overview/databases/cockroachdb)\n*   use [Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) for existing projects if you already have a CockroachDB database\n*   use [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) to migrate your database schema to a new version\n*   use [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) in your application to query your database in a type safe way based on your Prisma Schema\n\n## Differences to consider[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#differences-to-consider \"Direct link to Differences to consider\")\n\nThere are some CockroachDB-specific differences to be aware of when working with Prisma ORM's `cockroachdb` connector:\n\n*   **Cockroach-specific native types:** Prisma ORM's `cockroachdb` database connector provides support for CockroachDB's native data types. To learn more, see [How to use CockroachDB's native types](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#how-to-use-cockroachdbs-native-types).\n    \n*   **Creating database keys:** Prisma ORM allows you to generate a unique identifier for each record using the [`autoincrement()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#autoincrement) function. For more information, see [How to use database keys with CockroachDB](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#how-to-use-database-keys-with-cockroachdb).\n    \n\n## How to use Prisma ORM with CockroachDB[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#how-to-use-prisma-orm-with-cockroachdb \"Direct link to How to use Prisma ORM with CockroachDB\")\n\nThis section provides more details on how to use CockroachDB-specific features.\n\n### How to use CockroachDB's native types[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#how-to-use-cockroachdbs-native-types \"Direct link to How to use CockroachDB's native types\")\n\nCockroachDB has its own set of native [data types](https://www.cockroachlabs.com/docs/stable/data-types.html) which are supported in Prisma ORM. For example, CockroachDB uses the `STRING` data type instead of PostgreSQL's `VARCHAR`.\n\nAs a demonstration of this, say you create a `User` table in your CockroachDB database using the following SQL command:\n\n```\nCREATE TABLE public.\"Post\" (  \"id\" INT8 NOT NULL,  \"title\" VARCHAR(200) NOT NULL,  CONSTRAINT \"Post_pkey\" PRIMARY KEY (\"id\" ASC),  FAMILY \"primary\" (\"id\", \"title\"));\n```\n\nAfter introspecting your database with `npx prisma db pull`, you will have a new `Post` model in your Prisma Schema:\n\nschema.prisma\n\n```\nmodel Post {  id    BigInt @id  title String @db.String(200)}\n```\n\nNotice that the `title` field has been annotated with `@db.String(200)` — this differs from PostgreSQL where the annotation would be `@db.VarChar(200)`.\n\nFor a full list of type mappings, see our [connector documentation](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#type-mapping-between-cockroachdb-and-the-prisma-schema).\n\n### How to use database keys with CockroachDB[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#how-to-use-database-keys-with-cockroachdb \"Direct link to How to use database keys with CockroachDB\")\n\nWhen generating unique identifiers for records in a distributed database like CockroachDB, it is best to avoid using sequential IDs – for more information on this, see CockroachDB's [blog post on choosing index keys](https://cockroachlabs.com/blog/how-to-choose-db-index-keys).\n\nInstead, Prisma ORM provides the [`autoincrement()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#autoincrement) attribute function, which uses CockroachDB's [`unique_rowid()` function](https://www.cockroachlabs.com/docs/stable/serial.html) for generating unique identifiers. For example, the following `User` model has an `id` primary key, generated using the `autoincrement()` function:\n\nschema.prisma\n\n```\nmodel User {  id   BigInt @id @default(autoincrement())  name String}\n```\n\nFor compatibility with existing databases, you may sometimes still need to generate a fixed sequence of integer key values. In these cases, you can use Prisma ORM's inbuilt [`sequence()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sequence) function for CockroachDB. For a list of available options for the `sequence()` function, see our [reference documentation](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sequence).\n\nFor more information on generating database keys, see CockroachDB's [Primary key best practices](https://www.cockroachlabs.com/docs/v21.2/schema-design-table#primary-key-best-practices) guide.\n\n## Example[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#example \"Direct link to Example\")\n\nTo connect to a CockroachDB database server, you need to configure a [`datasource`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) block in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema):\n\nschema.prisma\n\n```\ndatasource db {  provider = \"cockroachdb\"  url      = env(\"DATABASE_URL\")}\n```\n\nThe fields passed to the `datasource` block are:\n\n*   `provider`: Specifies the `cockroachdb` data source connector.\n*   `url`: Specifies the [connection URL](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#connection-details) for the CockroachDB database server. In this case, an [environment variable is used](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) to provide the connection URL.\n\ninfo\n\nWhile `cockroachdb` and `postgresql` connectors are similar, it is mandatory to use the `cockroachdb` connector instead of `postgresql` when connecting to a CockroachDB database from version 5.0.0.\n\n## Connection details[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#connection-details \"Direct link to Connection details\")\n\nCockroachDB uses the PostgreSQL format for its connection URL. See the [PostgreSQL connector documentation](https://www.prisma.io/docs/orm/overview/databases/postgresql#connection-details) for details of this format, and the optional arguments it takes.\n\n## Differences between CockroachDB and PostgreSQL[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#differences-between-cockroachdb-and-postgresql \"Direct link to Differences between CockroachDB and PostgreSQL\")\n\nThe following table lists differences between CockroachDB and PostgreSQL:\n\n| Issue | Area | Notes |\n| --- | --- | --- |\n| By default, the `INT` type is an alias for `INT8` in CockroachDB, whereas in PostgreSQL it is an alias for `INT4`. This means that Prisma ORM will introspect an `INT` column in CockroachDB as `BigInt`, whereas in PostgreSQL Prisma ORM will introspect it as `Int`. | Schema | For more information on the `INT` type, see the [CockroachDB documentation](https://www.cockroachlabs.com/docs/stable/int.html#considerations-for-64-bit-signed-integers) |\n| When using `@default(autoincrement())` on a field, CockroachDB will automatically generate 64-bit integers for the row IDs. These integers will be increasing but not consecutive. This is in contrast to PostgreSQL, where generated row IDs are consecutive and start from 1. | Schema | For more information on generated values, see the [CockroachDB documentation](https://www.cockroachlabs.com/docs/stable/serial.html#generated-values-for-modes-rowid-and-virtual_sequence) |\n| The `@default(autoincrement())` attribute can only be used together with the `BigInt` field type. | Schema | For more information on generated values, see the [CockroachDB documentation](https://www.cockroachlabs.com/docs/stable/serial.html#generated-values-for-modes-rowid-and-virtual_sequence) |\n\n## Type mapping limitations in CockroachDB[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#type-mapping-limitations-in-cockroachdb \"Direct link to Type mapping limitations in CockroachDB\")\n\nThe CockroachDB connector maps the [scalar types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) from the Prisma ORM [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) to native column types. These native types are mostly the same as for PostgreSQL — see the [Native type mapping from Prisma ORM to CockroachDB](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#native-type-mapping-from-prisma-orm-to-cockroachdb) for details. However, there are some limitations:\n\n| CockroachDB (Type \\| Aliases) | Prisma ORM | Supported | Native database type attribute | Notes |\n| --- | --- | --- | --- | --- |\n| `money` | `Decimal` | Not yet | `@db.Money` | Supported in PostgreSQL but [not currently in CockroachDB](https://github.com/cockroachdb/cockroach/issues/41578) |\n| `xml` | `String` | Not yet | `@db.Xml` | Supported in PostgreSQL but [not currently in CockroachDB](https://github.com/cockroachdb/cockroach/issues/43355) |\n| `jsonb` arrays | `Json[]` | Not yet | N/A | `Json[]` supported in PostgreSQL but [not currently in CockroachDB](https://github.com/cockroachdb/cockroach/issues/23468) |\n\n## Other limitations[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#other-limitations \"Direct link to Other limitations\")\n\nThe following table lists any other current known limitations of CockroachDB compared to PostgreSQL:\n\n| Issue | Area | Notes |\n| --- | --- | --- |\n| Primary keys are named `primary` instead of `TABLE_pkey`, the Prisma ORM default. | Introspection | This means that they are introspected as `@id(map: \"primary\")`. This will be [fixed in CockroachDB 22.1](https://github.com/cockroachdb/cockroach/pull/70604). |\n| Foreign keys are named `fk_COLUMN_ref_TABLE` instead of `TABLE_COLUMN_fkey`, the Prisma ORM default. | Introspection | This means that they are introspected as `@relation([...], map: \"fk_COLUMN_ref_TABLE\")`. This will be [fixed in CockroachDB 22.1](https://github.com/cockroachdb/cockroach/pull/70658) |\n| Index types `Hash`, `Gist`, `SpGist` or `Brin` are not supported. | Schema | In PostgreSQL, Prisma ORM allows [configuration of indexes](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#configuring-the-access-type-of-indexes-with-type-postgresql) to use the different index access method. CockroachDB only currently supports `BTree` and `Gin`. |\n| Pushing to `Enum` types not supported | Client | Pushing to `Enum` types (e.g. `data: { enum { push: \"A\" }, }`) is currently [not supported in CockroachDB](https://github.com/cockroachdb/cockroach/issues/71388) |\n| Searching on `String` fields without a full text index not supported | Client | Searching on `String` fields without a full text index (e.g. `where: { text: { search: \"cat & dog\", }, },`) is currently [not supported in CockroachDB](https://github.com/cockroachdb/cockroach/issues/7821) |\n| Integer division not supported | Client | Integer division (e.g. `data: { int: { divide: 10, }, }`) is currently [not supported in CockroachDB](https://github.com/cockroachdb/cockroach/issues/41448) |\n| Limited filtering on `Json` fields | Client | Currently CockroachDB [only supports](https://github.com/cockroachdb/cockroach/issues/49144) `equals` and `not` filtering on `Json` fields |\n\n## Type mapping between CockroachDB and the Prisma schema[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#type-mapping-between-cockroachdb-and-the-prisma-schema \"Direct link to Type mapping between CockroachDB and the Prisma schema\")\n\nThe CockroachDB connector maps the [scalar types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) from the Prisma ORM [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) as follows to native column types:\n\n> Alternatively, see the [Prisma schema reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) for type mappings organized by Prisma ORM type.\n\n### Native type mapping from Prisma ORM to CockroachDB[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#native-type-mapping-from-prisma-orm-to-cockroachdb \"Direct link to Native type mapping from Prisma ORM to CockroachDB\")\n\n| Prisma ORM | CockroachDB |\n| --- | --- |\n| `String` | `STRING` |\n| `Boolean` | `BOOL` |\n| `Int` | `INT4` |\n| `BigInt` | `INT8` |\n| `Float` | `FLOAT8` |\n| `Decimal` | `DECIMAL(65,30)` |\n| `DateTime` | `TIMESTAMP(3)` |\n| `Json` | `JSONB` |\n| `Bytes` | `BYTES` |\n\n### Mapping from CockroachDB to Prisma ORM types on Introspection[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#mapping-from-cockroachdb-to-prisma-orm-types-on-introspection \"Direct link to Mapping from CockroachDB to Prisma ORM types on Introspection\")\n\nWhen introspecting a CockroachDB database, the database types are mapped to Prisma ORM according to the following table:\n\n| CockroachDB (Type \\| Aliases) | Prisma ORM | Supported | Native database type attribute | Notes |\n| --- | --- | --- | --- | --- |\n| `INT` \\| `BIGINT`, `INTEGER` | `BigInt` | ✔️  | `@db.Int8` |     |\n| `BOOL` \\| `BOOLEAN` | `Bool` | ✔️  | `@db.Bool`\\* |     |\n| `TIMESTAMP` \\| `TIMESTAMP WITHOUT TIME ZONE` | `DateTime` | ✔️  | `@db.Timestamp(x)` |     |\n| `TIMESTAMPTZ` \\| `TIMESTAMP WITH TIME ZONE` | `DateTime` | ✔️  | `@db.Timestamptz(x)` |     |\n| `TIME` \\| `TIME WITHOUT TIME ZONE` | `DateTime` | ✔️  | `@db.Time(x)` |     |\n| `TIMETZ` \\| `TIME WITH TIME ZONE` | `DateTime` | ✔️  | `@db.Timetz(x)` |     |\n| `DECIMAL(p,s)` \\| `NUMERIC(p,s)`, `DEC(p,s)` | `Decimal` | ✔️  | `@db.Decimal(x, y)` |     |\n| `REAL` \\| `FLOAT4`, `FLOAT` | `Float` | ✔️  | `@db.Float4` |     |\n| `DOUBLE PRECISION` \\| `FLOAT8` | `Float` | ✔️  | `@db.Float8` |     |\n| `INT2` \\| `SMALLINT` | `Int` | ✔️  | `@db.Int2` |     |\n| `INT4` | `Int` | ✔️  | `@db.Int4` |     |\n| `CHAR(n)` \\| `CHARACTER(n)` | `String` | ✔️  | `@db.Char(x)` |     |\n| `\"char\"` | `String` | ✔️  | `@db.CatalogSingleChar` | Internal type for CockroachDB catalog tables, not meant for end users. |\n| `STRING` \\| `TEXT`, `VARCHAR` | `String` | ✔️  | `@db.String` |     |\n| `DATE` | `DateTime` | ✔️  | `@db.Date` |     |\n| `ENUM` | `enum` | ✔️  | N/A |     |\n| `INET` | `String` | ✔️  | `@db.Inet` |     |\n| `BIT(n)` | `String` | ✔️  | `@Bit(x)` |     |\n| `VARBIT(n)` \\| `BIT VARYING(n)` | `String` | ✔️  | `@VarBit` |     |\n| `OID` | `Int` | ✔️  | `@db.Oid` |     |\n| `UUID` | `String` | ✔️  | `@db.Uuid` |     |\n| `JSONB` \\| `JSON` | `Json` | ✔️  | `@db.JsonB` |     |\n| Array types | `[]` | ✔️  |     |     |\n\n[Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) adds native database types that are **not yet supported** as [`Unsupported`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unsupported) fields:\n\nschema.prisma\n\n```\nmodel Device {  id       BigInt                  @id @default(autoincrement())  interval Unsupported(\"INTERVAL\")}\n```\n\n## More on using CockroachDB with Prisma ORM[​](https://www.prisma.io/docs/orm/overview/databases/cockroachdb#more-on-using-cockroachdb-with-prisma-orm \"Direct link to More on using CockroachDB with Prisma ORM\")\n\nThe fastest way to start using CockroachDB with Prisma ORM is to refer to our Getting Started documentation:\n\n*   [Start from scratch](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-cockroachdb)\n*   [Add to existing project](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-cockroachdb)\n\nThese tutorials will take you through the process of connecting to CockroachDB, migrating your schema, and using Prisma Client.\n\nFurther reference information is available in the [CockroachDB connector documentation](https://www.prisma.io/docs/orm/overview/databases/cockroachdb).",
  "title": "CockroachDB | Prisma Documentation",
  "description": "Guide to CockroachDB",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse/what-is-pulse",
  "markdown": "# What is Pulse | Prisma Documentation\n\n## Overview[​](https://www.prisma.io/docs/pulse/what-is-pulse#overview \"Direct link to Overview\")\n\n[Prisma Pulse](https://www.prisma.io/data-platform/pulse) facilitates the implementation of event-driven workflows and architectures by providing managed infrastructure that captures databases events and distributes them to your applications.\n\nIt lets you subscribe to any changes happening in your database using [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) to power **real-time use cases** in your applications, such as:\n\n*   chat and messaging\n*   sending onboarding emails\n*   data syncing (e.g. into a search index)\n*   social collaboration\n*   notifying users\n*   updating inventories\n*   managing payments\n*   live games, quizzes and polls\n*   ... and many other functionalities that require real-time updates\n\nPrisma Pulse integrates with [Prisma ORM](https://www.prisma.io/docs/orm) and lets you subscribe to database changes easily _and_ in a type-safe way using Prisma Client.\n\nHere's the brief overview of how Pulse works:\n\n### 1\\. Stream database change events with Prisma Client[​](https://www.prisma.io/docs/pulse/what-is-pulse#1-stream-database-change-events-with-prisma-client \"Direct link to 1. Stream database change events with Prisma Client\")\n\nIn your application, use Prisma Client to stream _all_ changes that are happening on the `User` table from the database:\n\n```\n// stream all changes from the `User` tableconst stream = await prisma.user.stream();// wait for new events to arrivefor await (let event of stream) {  // log the details about an event to the terminal  console.log(`Something happened in the database: `);  console.log(event);}\n```\n\n### 2\\. A database event happens[​](https://www.prisma.io/docs/pulse/what-is-pulse#2-a-database-event-happens \"Direct link to 2. A database event happens\")\n\nA change is made to the table we've previously subscribed to. In this case, a new row is added to the `User` table.\n\n![](https://www.prisma.io/docs/assets/images/user-insert-6850514d6dc1fd0656a41c3874f8f762.png)\n\nThis change can happen from anywhere: the same app that uses Prisma Client to subscribe to changes, a different application or microservice, a database GUI, Prisma Studio, or any other SQL client (like `psql`).\n\n### 3\\. The database event is propagated to all subscribers[​](https://www.prisma.io/docs/pulse/what-is-pulse#3-the-database-event-is-propagated-to-all-subscribers \"Direct link to 3. The database event is propagated to all subscribers\")\n\nPrisma Pulse propagates the event to all subscribers. In this case, the application from step 1. receives the event and logs its value to the terminal:\n\n```\nSomething happened in the database:{  \"action\": \"create\",  \"created\": {    \"id\": 1,    \"email\": \"test@prisma.io\",    \"name\": \"test\"  }}\n```\n\n## Why Prisma Pulse?[​](https://www.prisma.io/docs/pulse/what-is-pulse#why-prisma-pulse \"Direct link to Why Prisma Pulse?\")\n\nBuilding real-time functionality based on changes that occur in your database can be very complicated. Common approaches like _polling_, implementing _application-level updates_ or using _additional infrastructure_ (like Apache Kafka or RabbitMQ) either don't scale, are very costly or come with substantial development and maintenance overhead.\n\nInstead, Prisma Pulse is based on the idea of _unidirectional data flow_ which is implemented via [Change Data Capture](https://en.wikipedia.org/wiki/Change_data_capture) (CDC). CDC gets rid of the deficiencies of the previously mentioned approaches and solves the problem of reacting to database events in a robust and elegant manner.\n\nHere is an overview of the main features Prisma Pulse provides:\n\n*   Reacting to database changes with type-safe model subscriptions\n*   Unidirectional data flow via Change Data Capture\n*   Great DX integrated with usage of Prisma ORM (easy setup, development and maintenance)\n*   Works with your existing database\n*   Insights dashboard lets you view and understand all database events captured by Pulse\n*   Enable, disable and manage Pulse via the [Platform CLI](https://www.prisma.io/docs/platform/platform-cli)\n\n## How does Prisma Pulse work?[​](https://www.prisma.io/docs/pulse/what-is-pulse#how-does-prisma-pulse-work \"Direct link to How does Prisma Pulse work?\")\n\nPrisma Pulse uses CDC to efficiently observe and capture database changes as they occur. By monitoring the database's transaction log (e.g. the Write-Ahead-Log in PostgreSQL), Prisma Pulse identifies database change events like _inserts_, _updates_, and _deletes_ without impacting the database's performance.\n\nThe captured events are processed, evaluated, and distributed to all Prisma Client instances that subscribed to them:\n\n![What is Pulse](https://www.prisma.io/docs/assets/images/unidirectional-data-flow-90de54896adf65182925e162fd655f62.png)\n\n## What can you build with Prisma Pulse?[​](https://www.prisma.io/docs/pulse/what-is-pulse#what-can-you-build-with-prisma-pulse \"Direct link to What can you build with Prisma Pulse?\")\n\nPrisma Pulse can power real-time functionality like chat, notifications, data broadcast, data synchronization, and more. It's ideal for ensuring data consistency in distributed systems, enhancing real-time user experiences.\n\n![Prisma Pulse use-cases](https://www.prisma.io/docs/assets/images/pulse-usecase-f57607aec3f738a0d235775f622f0af7.png)\n\n## Example projects[​](https://www.prisma.io/docs/pulse/what-is-pulse#example-projects \"Direct link to Example projects\")\n\nHere are a few example projects using Prisma Pulse:\n\n| Project | Description |\n| --- | --- |\n| [starter](https://github.com/prisma/prisma-examples/tree/latest/pulse/starter) | Minimal Pulse starter project |\n| [email-with-resend](https://github.com/prisma/prisma-examples/tree/latest/pulse/email-with-resend) | Send onboarding emails to new users via Resend |\n| [fullstack-leaderboard](https://github.com/prisma/prisma-examples/tree/latest/pulse/fullstack-leaderboard) | A live leaderboard (built with Next.js) |\n| [fullstack-simple-chat](https://github.com/prisma/prisma-examples/tree/latest/pulse/fullstack-simple-chat) | A simple chat app (built with Next.js & Express) |\n| [cron-job-data-sync-with-typesense](https://github.com/prisma/prisma-examples/tree/latest/pulse/product-search-with-typesense) | A cron job that syncs data into Typesense (built with Hono.js) |",
  "title": "What is Pulse | Prisma Documentation",
  "description": "Learn about Pulse, a managed Change Data Capture service that lets you build real-time applications with ease.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/mongodb",
  "markdown": "# MongoDB database connector | Prisma Documentation\n\nThis guide discusses the concepts behind using Prisma ORM and MongoDB, explains the commonalities and differences between MongoDB and other database providers, and leads you through the process for configuring your application to integrate with MongoDB using Prisma ORM.\n\n## What is MongoDB?[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#what-is-mongodb \"Direct link to What is MongoDB?\")\n\n[MongoDB](https://www.mongodb.com/) is a NoSQL database that stores data in [BSON](https://bsonspec.org/) format, a JSON-like document format designed for storing data in key-value pairs. It is commonly used in JavaScript application development because the document model maps easily to objects in application code, and there is built in support for high availability and horizontal scaling.\n\nMongoDB stores data in collections that do not need a schema to be defined in advance, as you would need to do with tables in a relational database. The structure of each collection can also be changed over time. This flexibility can allow rapid iteration of your data model, but it does mean that there are a number of differences when using Prisma ORM to work with your MongoDB database.\n\n## Commonalities with other database providers[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#commonalities-with-other-database-providers \"Direct link to Commonalities with other database providers\")\n\nSome aspects of using Prisma ORM with MongoDB are the same as when using Prisma ORM with a relational database. You can still:\n\n*   model your database with the [Prisma Schema Language](https://www.prisma.io/docs/orm/prisma-schema)\n*   connect to your database, using the [`mongodb` database connector](https://www.prisma.io/docs/orm/overview/databases)\n*   use [Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) for existing projects if you already have a MongoDB database\n*   use [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) to push changes in your schema to the database\n*   use [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) in your application to query your database in a type safe way based on your Prisma Schema\n\n## Differences to consider[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#differences-to-consider \"Direct link to Differences to consider\")\n\nMongoDB's document-based structure and flexible schema means that using Prisma ORM with MongoDB differs from using it with a relational database in a number of ways. These are some areas where there are differences that you need to be aware of:\n\n*   **Defining IDs**: MongoDB documents have an `_id` field (that often contains an [ObjectID](https://www.mongodb.com/docs/manual/reference/bson-types/#std-label-objectid)). Prisma ORM does not support fields starting with `_`, so this needs to be mapped to a Prisma ORM field using the `@map` attribute. For more information, see [Defining IDs in MongoDB](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-ids-in-mongodb).\n    \n*   **Migrating existing data to match your Prisma schema**: In relational databases, all your data must match your schema. If you change the type of a particular field in your schema when you migrate, all the data must also be updated to match. In contrast, MongoDB does not enforce any particular schema, so you need to take care when migrating. For more information, see [How to migrate old data to new schemas](https://www.prisma.io/docs/orm/overview/databases/mongodb#how-to-migrate-existing-data-to-match-your-prisma-schema).\n    \n*   **Introspection and Prisma ORM relations**: When you introspect an existing MongoDB database, you will get a schema with no relations and will need to add the missing relations in manually. For more information, see [How to add in missing relations after Introspection](https://www.prisma.io/docs/orm/overview/databases/mongodb#how-to-add-in-missing-relations-after-introspection).\n    \n*   **Filtering for `null` and missing fields**: MongoDB makes a distinction between setting a field to `null` and not setting it at all, which is not present in relational databases. Prisma ORM currently does not express this distinction, which means that you need to be careful when filtering for `null` and missing fields. For more information, see [How to filter for `null` and missing fields](https://www.prisma.io/docs/orm/overview/databases/mongodb#how-to-filter-for-null-and-missing-fields)\n    \n*   **Enabling replication**: Prisma ORM uses [MongoDB transactions](https://www.mongodb.com/docs/manual/core/transactions/) internally to avoid partial writes on nested queries. When using transactions, MongoDB requires replication of your data set to be enabled. To do this, you will need to configure a [replica set](https://www.mongodb.com/docs/manual/replication/) — this is a group of MongoDB processes that maintain the same data set. Note that it is still possible to use a single database, by creating a replica set with only one node in it. If you use MongoDB's [Atlas](https://www.mongodb.com/atlas/database) hosting service, the replica set is configured for you, but if you are running MongoDB locally you will need to set up a replica set yourself. For more information, see MongoDB's [guide to deploying a replica set](https://www.mongodb.com/docs/manual/tutorial/deploy-replica-set/).\n    \n\n## How to use Prisma ORM with MongoDB[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#how-to-use-prisma-orm-with-mongodb \"Direct link to How to use Prisma ORM with MongoDB\")\n\nThis section provides instructions for how to carry out tasks that require steps specific to MongoDB.\n\n### How to migrate existing data to match your Prisma schema[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#how-to-migrate-existing-data-to-match-your-prisma-schema \"Direct link to How to migrate existing data to match your Prisma schema\")\n\nMigrating your database over time is an important part of the development cycle. During development, you will need to update your Prisma schema (for example, to add new fields), then update the data in your development environment’s database, and eventually push both the updated schema and the new data to the production database.\n\ninfo\n\nWhen using MongoDB, be aware that the “coupling” between your schema and the database is purposefully designed to be less rigid than with SQL databases; MongoDB will not enforce the schema, so you have to verify data integrity.\n\nThese iterative tasks of updating the schema and the database can result in inconsistencies between your schema and the actual data in the database. Let’s look at one scenario where this can happen, and then examine several strategies for you and your team to consider for handling these inconsistencies.\n\n**Scenario**: you need to include a phone number for users, as well as an email. You currently have the following `User` model in your `schema.prisma` file:\n\nprisma/schema.prisma\n\n```\nmodel User {  id    String @id @default(auto()) @map(\"_id\") @db.ObjectId  email String}\n```\n\nThere are a number of strategies you could use for migrating this schema:\n\n*   **\"On-demand\" updates**: with this strategy, you and your team have agreed that updates can be made to the schema as needed. However, in order to avoid migration failures due to inconsistencies between the data and schema, there is agreement in the team that any new fields added are explicitly defined as optional.\n    \n    In our scenario above, you can add an optional `phoneNumber` field to the `User` model in your Prisma schema:\n    \n    prisma/schema.prisma\n    \n    ```\n    model User {  id          String  @id @default(auto()) @map(\"_id\") @db.ObjectId  email       String  phoneNumber String?}\n    ```\n    \n    Then regenerate your Prisma Client using the `npx prisma generate` command. Next, update your application to reflect the new field, and redeploy your app.\n    \n    As the `phoneNumber` field is optional, you can still query the old users where the phone number has not been defined. The records in the database will be updated \"on demand\" as the application's users begin to enter their phone number in the new field.\n    \n    Another option is to add a default value on a required field, for example:\n    \n    prisma/schema.prisma\n    \n    ```\n    model User {  id          String @id @default(auto()) @map(\"_id\") @db.ObjectId  email       String  phoneNumber String @default(\"000-000-0000\")}\n    ```\n    \n    Then when you encounter a missing `phoneNumber`, the value will be coerced into `000-000-0000`.\n    \n*   **\"No breaking changes\" updates**: this strategy builds on the first one, with further consensus amongst your team that you don't rename or delete fields, only add new fields, and always define the new fields as optional. This policy can be reinforced by adding checks in the CI/CD process to verify that there are no backwards-incompatible changes to the schema.\n    \n*   **\"All-at-once\" updates**: this strategy is similar to traditional migrations in relational databases, where all data is updated to reflect the new schema. In the scenario above, you would create a script to add a value for the phone number field to all existing users in your database. You can then make the field a required field in the application because the schema and the data are consistent.\n    \n\n### How to add in missing relations after Introspection[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#how-to-add-in-missing-relations-after-introspection \"Direct link to How to add in missing relations after Introspection\")\n\nAfter introspecting an existing MongoDB database, you will need to manually add in relations between models. MongoDB does not have the concept of defining relations via foreign keys, as you would in a relational database. However, if you have a collection in MongoDB with a \"foreign-key-like\" field that matches the ID field of another collection, Prisma ORM will allow you to emulate relations between the collections.\n\nAs an example, take a MongoDB database with two collections, `User` and `Post`. The data in these collections has the following format, with a `userId` field linking users to posts:\n\n`User` collection:\n\n*   `_id` field with a type of `objectId`\n*   `email` field with a type of `string`\n\n`Post` collection:\n\n*   `_id` field with a type of `objectId`\n*   `title` field with a type of `string`\n*   `userId` with a type of `objectID`\n\nOn introspection with `db pull`, this is pulled in to the Prisma Schema as follows:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id     String @id @default(auto()) @map(\"_id\") @db.ObjectId  title  String  userId String @db.ObjectId}model User {  id    String @id @default(auto()) @map(\"_id\") @db.ObjectId  email String}\n```\n\nThis is missing the relation between the `User` and `Post` models. To fix this, manually add a `user` field to the `Post` model with a `@relation` attribute using `userId` as the `fields` value, linking it to the `User` model, and a `posts` field to the `User` model as the back relation:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id     String @id @default(auto()) @map(\"_id\") @db.ObjectId  title  String  userId String @db.ObjectId  user   User   @relation(fields: [userId], references: [id])}model User {  id    String @id @default(auto()) @map(\"_id\") @db.ObjectId  email String  posts Post[]}\n```\n\nFor more information on how to use relations in Prisma ORM, see [our documentation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations).\n\n### How to filter for `null` and missing fields[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#how-to-filter-for-null-and-missing-fields \"Direct link to how-to-filter-for-null-and-missing-fields\")\n\nTo understand how MongoDB distinguishes between `null` and missing fields, consider the example of a `User` model with an optional `name` field:\n\n```\nmodel User {  id    String  @id @default(auto()) @map(\"_id\") @db.ObjectId  email String  name  String?}\n```\n\nFirst, try creating a record with the `name` field explicitly set to `null`. Prisma ORM will return `name: null` as expected:\n\n```\nconst createNull = await prisma.user.create({  data: {    email: 'user1@prisma.io',    name: null,  },})console.log(createNull)\n```\n\nIf you check your MongoDB database directly, you will also see a new record with `name` set to `null`:\n\n```\n{  \"_id\": \"6242c4af032bc76da250b207\",  \"email\": \"user1@prisma.io\",  \"name\": null}\n```\n\nNext, try creating a record without explicitly setting the `name` field:\n\n```\nconst createMissing = await prisma.user.create({  data: {    email: 'user2@prisma.io',  },})console.log(createMissing)\n```\n\nPrisma ORM still returns `name: null`, but if you look in the database directly you will see that the record has no `name` field defined at all:\n\n```\n{  \"_id\": \"6242c4af032bc76da250b208\",  \"email\": \"user2@prisma.io\"}\n```\n\nPrisma ORM returns the same result in both cases, because we currently don't have a way to specify this difference in MongoDB between fields that are `null` in the underlying database, and fields that are not defined at all — see [this Github issue](https://github.com/prisma/prisma/issues/12555) for more information.\n\nThis means that you currently have to be careful when filtering for `null` and missing fields. Filtering for records with `name: null` will only return the first record, with the `name` explicitly set to `null`:\n\n```\nconst findNulls = await prisma.user.findMany({  where: {    name: null,  },})console.log(findNulls)\n```\n\nThis is because `name: null` is checking for equality, and a non-existing field isn't equal to `null`.\n\nTo include missing fields as well, use the [`isSet` filter](https://www.prisma.io/docs/orm/reference/prisma-client-reference#isset) to explicitly search for fields which are either `null` or not set. This will return both records:\n\n```\nconst findNullOrMissing = await prisma.user.findMany({  where: {    OR: [      {        name: null,      },      {        name: {          isSet: false,        },      },    ],  },})console.log(findNullOrMissing)\n```\n\n## More on using MongoDB with Prisma ORM[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#more-on-using-mongodb-with-prisma-orm \"Direct link to More on using MongoDB with Prisma ORM\")\n\nThe fastest way to start using MongoDB with Prisma ORM is to refer to our Getting Started documentation:\n\n*   [Start from scratch](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb-typescript-mongodb)\n*   [Add to existing project](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-typescript-mongodb)\n\nThese tutorials will take you through the process of connecting to MongoDB, pushing schema changes, and using Prisma Client.\n\nFurther reference information is available in the [MongoDB connector documentation](https://www.prisma.io/docs/orm/overview/databases/mongodb).\n\nFor more information on how to set up and manage a MongoDB database, see the [Prisma Data Guide](https://www.prisma.io/dataguide#mongodb).\n\n## Example[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#example \"Direct link to Example\")\n\nTo connect to a MongoDB server, configure the [`datasource`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) block in your [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema):\n\nschema.prisma\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}\n```\n\nThe fields passed to the `datasource` block are:\n\n*   `provider`: Specifies the `mongodb` data source connector.\n*   `url`: Specifies the [connection URL](https://www.prisma.io/docs/orm/overview/databases/mongodb#connection-url) for the MongoDB server. In this case, an [environment variable is used](https://www.prisma.io/docs/orm/more/development-environment/environment-variables) to provide the connection URL.\n\nwarning\n\nThe MongoDB database connector uses transactions to support nested writes. Transactions **require** a [replica set](https://docs.mongodb.com/manual/tutorial/deploy-replica-set/) deployment. The easiest way to deploy a replica set is with [Atlas](https://docs.atlas.mongodb.com/getting-started/). It's free to get started.\n\n## Connection details[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#connection-details \"Direct link to Connection details\")\n\n### Connection URL[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#connection-url \"Direct link to Connection URL\")\n\nThe MongoDB connection URL can be configured in different ways depending on how you are hosting your database. The standard configuration is made up of the following components:\n\n![Structure of the MongoDB connection URL](https://www.prisma.io/docs/assets/images/mongodb-beadc3582d1870f7ba1b97d6835ec2b8.png)\n\n#### Base URL and path[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#base-url-and-path \"Direct link to Base URL and path\")\n\nThe base URL and path sections of the connection URL are made up of your authentication credentials followed by the host (and optionally, a port number) and database.\n\n```\nmongodb://USERNAME:PASSWORD@HOST/DATABASE\n```\n\nThe following components make up the _base URL_ of your database:\n\n| Name | Placeholder | Description |\n| --- | --- | --- |\n| User | `USERNAME` | Name of your database user, e.g. `janedoe` |\n| Password | `PASSWORD` | Password for your database user |\n| Host | `HOST` | The host where a [`mongod`](https://docs.mongodb.com/manual/reference/program/mongod/#mongodb-binary-bin.mongod) instance is running. If you are running a sharded cluster this will a [`mongos`](https://docs.mongodb.com/manual/reference/program/mongos/#mongodb-binary-bin.mongos) instance. This can be a hostname, IP address or UNIX domain socket. |\n| Port | `PORT` | Port on which your database server is running, e.g. `1234`. If none is provided the default `27017` is used. |\n| Database | `DATABASE` | Name of the database to use. If none is specified but the `authSource` option is set then the `authSource` database name is used. If neither the database in the connection string nor the `authSource` option is specified then it defaults to `admin` |\n\n#### Arguments[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#arguments \"Direct link to Arguments\")\n\nA connection URL can also take arguments. The following example sets three arguments:\n\n*   An `ssl` connection\n*   A `connectTimeoutMS`\n*   And the `maxPoolSize`\n\n```\nmongodb://USERNAME:PASSWORD@HOST/DATABASE?ssl=true&connectTimeoutMS=5000&maxPoolSize=50\n```\n\nRefer to the [MongoDB connection string documentation](https://docs.mongodb.com/manual/reference/connection-string/#connection-string-options) for a complete list of connection string arguments. There are no Prisma ORM-specific arguments.\n\n## Using `ObjectId`[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#using-objectid \"Direct link to using-objectid\")\n\nIt is common practice for the `_id` field of a MongoDB document to contain an [ObjectId](https://docs.mongodb.com/manual/reference/bson-types/#std-label-objectid):\n\n```\n{  \"_id\": { \"$oid\": \"60d599cb001ef98000f2cad2\" },  \"createdAt\": { \"$date\": { \"$numberLong\": \"1624611275577\" } },  \"email\": \"ella@prisma.io\",  \"name\": \"Ella\",  \"role\": \"ADMIN\"}\n```\n\nAny field (most commonly IDs and relation scalar fields) that maps to an `ObjectId` in the underlying database:\n\n*   Must be of type `String` or `Bytes`\n*   Must include the `@db.ObjectId` attribute\n*   Can optionally use `@default(auto())` to auto-generate a valid `ObjectId` on document creation\n\nHere is an example that uses `String`:\n\n```\nmodel User {  id String @id @default(auto()) @map(\"_id\") @db.ObjectId  // Other fields}\n```\n\nAnd here is another example that uses `Bytes`:\n\n```\nmodel User {  id Bytes @id @default(auto()) @map(\"_id\") @db.ObjectId  // Other fields}\n```\n\nSee also: [Defining ID fields in MongoDB](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-ids-in-mongodb)\n\n### Generating `ObjectId`[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#generating-objectid \"Direct link to generating-objectid\")\n\nTo generate a valid `ObjectId` (for testing purposes or to manually set an ID field value) in your application, use the [`bson`](https://www.npmjs.com/package/bson) package.\n\n```\nimport { ObjectId } from 'bson'const id = new ObjectId()\n```\n\n## Differences to connectors for relational databases[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#differences-to-connectors-for-relational-databases \"Direct link to Differences to connectors for relational databases\")\n\nThis section covers ways in which the MongoDB connector differs from Prisma ORM connectors for relational databases.\n\n### No support for Prisma Migrate[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#no-support-for-prisma-migrate \"Direct link to No support for Prisma Migrate\")\n\nCurrently, there are no plans to add support for [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) as MongoDB projects do not rely on internal schemas where changes need to be managed with an extra tool. Management of `@unique` indexes is realized through `db push`.\n\n### No support for `@@id` and `autoincrement()`[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#no-support-for-id-and-autoincrement \"Direct link to no-support-for-id-and-autoincrement\")\n\nThe [`@@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1) attribute (an ID for multiple fields) is not supported because primary keys in MongoDB are always on the `_id` field of a model.\n\nThe [`autoincrement()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generate-autoincrementing-integers-as-ids-relational-databases-only) function (which creates incrementing `@id` values) is not supported because `autoincrement()` does not work with the `ObjectID` type that the `_id` field has in MongoDB.\n\n### Cyclic references and referential actions[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#cyclic-references-and-referential-actions \"Direct link to Cyclic references and referential actions\")\n\nIf you have cyclic references in your models, either from self-relations or a cycle of relations between models, and you use [referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions), you must set a referential action of `NoAction` to prevent an infinite loop of actions.\n\nSee [Special rules for referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions) for more details.\n\n### Replica set configuration[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#replica-set-configuration \"Direct link to Replica set configuration\")\n\nMongoDB only allows you to start a transaction on a replica set. Prisma ORM uses transactions internally to avoid partial writes on nested queries. This means we inherit the requirement of needing a replica set configured.\n\nWhen you try to use Prisma ORM's MongoDB connector on a deployment that has no replica set configured, Prisma ORM shows the message `Error: Transactions are not supported by this deployment`. The full text of the error message is the following:\n\n```\nPrismaClientUnknownRequestError2 [PrismaClientUnknownRequestError]:Invalid `prisma.post.create()` invocation in/index.ts:9:21   6 await prisma.$connect()   7   8 // Create the first post→  9 await prisma.post.create(  Error in connector: Database error. error code: unknown, error message: Transactions are not supported by this deployment    at cb (/node_modules/@prisma/client/runtime/index.js:34804:17)    at processTicksAndRejections (internal/process/task_queues.js:97:5) {  clientVersion: '3.xx.0'}\n```\n\nTo resolve this, we suggest you change your deployment to one with a replica set configured.\n\nOne simple way for this is to use [MongoDB Atlas](https://www.mongodb.com/cloud/atlas) to launch a free instance that has replica set support out of the box.\n\nThere's also an option to run the replica set locally with this guide: [https://docs.mongodb.com/manual/tutorial/convert-standalone-to-replica-set](https://docs.mongodb.com/manual/tutorial/convert-standalone-to-replica-set)\n\n## Type mapping between MongoDB and the Prisma schema[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#type-mapping-between-mongodb-and-the-prisma-schema \"Direct link to Type mapping between MongoDB and the Prisma schema\")\n\nThe MongoDB connector maps the [scalar types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) from the Prisma ORM [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) to MongoDB's native column types as follows:\n\n> Alternatively, see [Prisma schema reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) for type mappings organized by Prisma type.\n\n### Native type mapping from Prisma ORM to MongoDB[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#native-type-mapping-from-prisma-orm-to-mongodb \"Direct link to Native type mapping from Prisma ORM to MongoDB\")\n\n| Prisma ORM | MongoDB |\n| --- | --- |\n| `String` | `string` |\n| `Boolean` | `bool` |\n| `Int` | `int` |\n| `BigInt` | `long` |\n| `Float` | `double` |\n| `Decimal` | [Currently unsupported](https://github.com/prisma/prisma/issues/12637) |\n| `DateTime` | `timestamp` |\n| `Bytes` | `binData` |\n| `Json` |     |\n\nMongoDB types that are currently unsupported:\n\n*   `Decimal128`\n*   `Undefined`\n*   `DBPointer`\n*   `Null`\n*   `Symbol`\n*   `MinKey`\n*   `MaxKey`\n*   `Object`\n*   `Javascript`\n*   `JavascriptWithScope`\n*   `Regex`\n\n### Mapping from MongoDB to Prisma ORM types on Introspection[​](https://www.prisma.io/docs/orm/overview/databases/mongodb#mapping-from-mongodb-to-prisma-orm-types-on-introspection \"Direct link to Mapping from MongoDB to Prisma ORM types on Introspection\")\n\nWhen introspecting a MongoDB database, Prisma ORM uses the relevant [scalar types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields). Some special types also get additional native type annotations:\n\n| MongoDB (Type \\| Aliases) | Prisma ORM | Supported | Native database type attribute | Notes |\n| --- | --- | --- | --- | --- |\n| `objectId` | `String` | ✔️  | `@db.ObjectId` |     |\n\n[Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) adds native database types that are **not yet supported** as [`Unsupported`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unsupported) fields:\n\nschema.prisma\n\n```\nmodel Example {  id    String                           @id @default(auto()) @map(\"_id\") @db.ObjectId  name  String  regex Unsupported(\"RegularExpression\")}\n```",
  "title": "MongoDB database connector | Prisma Documentation",
  "description": "How Prisma can connect to a MongoDB database using the MongoDB database connector.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/prisma-in-your-stack",
  "markdown": "# How Prisma ORM fits into your stack\n\nPrisma ORM provides a fully type-safe API and simplified database access. You can use Prisma ORM tools to build a GraphQL or REST API, or as part of a fullstack application - the extent to which you incorporate Prisma ORM is up to you.\n\n## In this section[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack#in-this-section \"Direct link to In this section\")\n\n[\n\n## REST\n\n](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest)\n\n[\n\n## GraphQL\n\n](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql)\n\n[\n\n## Fullstack\n\n](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack)\n\n[\n\n## Is Prisma ORM an ORM?\n\n](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm)",
  "title": "How Prisma ORM fits into your stack | Prisma Documentation",
  "description": "How Prisma ORM fits into your stack",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/planetscale",
  "markdown": "# PlanetScale | Prisma Documentation\n\nPrisma and [PlanetScale](https://planetscale.com/) together provide a development arena that optimizes rapid, type-safe development of data access applications, using Prisma's ORM and PlanetScale's highly scalable MySQL-based platform.\n\nThis document discusses the concepts behind using Prisma ORM and PlanetScale, explains the commonalities and differences between PlanetScale and other database providers, and leads you through the process for configuring your application to integrate with PlanetScale.\n\n## What is PlanetScale?[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#what-is-planetscale \"Direct link to What is PlanetScale?\")\n\nPlanetScale uses the [Vitess](https://vitess.io/) database clustering system to provide a MySQL-compatible database platform. Features include:\n\n*   **Enterprise scalability.** PlanetScale provides a highly available production database cluster that supports scaling across multiple database servers. This is particularly useful in a serverless context, as it avoids the problem of having to [manage connection limits](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas).\n*   **Database branches.** PlanetScale allows you to create [branches of your database schema](https://planetscale.com/docs/concepts/branching), so that you can test changes on a development branch before applying them to your production database.\n*   **Support for [non-blocking schema changes](https://planetscale.com/docs/concepts/nonblocking-schema-changes).** PlanetScale provides a workflow that allows users to update database schemas without locking the database or causing downtime.\n\n## Commonalities with other database providers[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#commonalities-with-other-database-providers \"Direct link to Commonalities with other database providers\")\n\nMany aspects of using Prisma ORM with PlanetScale are just like using Prisma ORM with any other relational database. You can still:\n\n*   model your database with the [Prisma Schema Language](https://www.prisma.io/docs/orm/prisma-schema)\n*   use Prisma ORM's existing [`mysql` database connector](https://www.prisma.io/docs/orm/overview/databases/mysql) in your schema, along with the [connection string PlanetScale provides you](https://planetscale.com/docs/concepts/connection-strings)\n*   use [Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) for existing projects if you already have a database schema in PlanetScale\n*   use [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) to push changes in your schema to the database\n*   use [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) in your application to talk to the database server at PlanetScale\n\n## Differences to consider[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#differences-to-consider \"Direct link to Differences to consider\")\n\nPlanetScale's branching model and design for scalability means that there are also a number of differences to consider. You should be aware of the following points when deciding to use PlanetScale with Prisma ORM:\n\n*   **Branching and deploy requests.** PlanetScale provides two types of database branches: _development branches_, which allow you to test out schema changes, and _production branches_, which are protected from direct schema changes. Instead, changes must be first created on a development branch and then deployed to production using a deploy request. Production branches are highly available and include automated daily backups. To learn more, see [How to use branches and deploy requests](https://www.prisma.io/docs/orm/overview/databases/planetscale#how-to-use-branches-and-deploy-requests).\n    \n*   **Referential actions and integrity.** To support scaling across multiple database servers, PlanetScale [by default does not use foreign key constraints](https://planetscale.com/docs/learn/operating-without-foreign-key-constraints), which are normally used in relational databases to enforce relationships between data in different tables, and asks users to handle this manually in their applications. However, you can explicitly [enable them in the PlanetScale database settings](https://planetscale.com/docs/concepts/foreign-key-constraints). If you don't enable these explicitly, you can still maintain these relationships in your data and allow the use of [referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) by using Prisma ORM's ability to [emulate relations in Prisma Client](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#emulate-relations-in-prisma-orm-with-the-prisma-relation-mode) with the `prisma` relation mode. For more information, see [How to emulate relations in Prisma Client](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client).\n    \n*   **Creating indexes on foreign keys.** When [emulating relations in Prisma ORM](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client) (i.e. when _not_ using foreign key constraints on the database-level), you will need to create dedicated indexes on foreign keys. In a standard MySQL database, if a table has a column with a foreign key constraint, an index is automatically created on that column. When PlanetScale is configured to not use foreign key constraints, these indexes are [currently](https://github.com/prisma/prisma/issues/10611) not created when Prisma Client emulates relations, which can lead to issues with queries not being well optimized. To avoid this, you can create indexes in Prisma ORM. For more information, see [How to create indexes on foreign keys](https://www.prisma.io/docs/orm/overview/databases/planetscale#2-create-indexes-on-foreign-keys).\n    \n*   **Making schema changes with `db push`.** When you merge a development branch into your production branch, PlanetScale will automatically compare the two schemas and generate its own schema diff. This means that Prisma ORM's [`prisma migrate`](https://www.prisma.io/docs/orm/prisma-migrate) workflow, which generates its own history of migration files, is not a natural fit when working with PlanetScale. These migration files may not reflect the actual schema changes run by PlanetScale when the branch is merged.\n    \n    warning\n    \n    We recommend not using `prisma migrate` when making schema changes with PlanetScale. Instead, we recommend that you use the `prisma db push` command.\n    \n    For an example of how this works, see [How to make schema changes with `db push`](https://www.prisma.io/docs/orm/overview/databases/planetscale#how-to-make-schema-changes-with-db-push)\n    \n*   **Introspection**. When you introspect on an existing database and you have _not_ enabled [foreign key constraints in your PlanetScale database](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-2-enable-foreign-key-constraints-in-the-planetscale-database-settings), you will get a schema with no relations, as they are usually defined based on foreign keys that connect tables. In that case, you will need to add the missing relations in manually. For more information, see [How to add in missing relations after Introspection](https://www.prisma.io/docs/orm/overview/databases/planetscale#how-to-add-in-missing-relations-after-introspection).\n    \n\n## How to use branches and deploy requests[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#how-to-use-branches-and-deploy-requests \"Direct link to How to use branches and deploy requests\")\n\nWhen connecting to PlanetScale with Prisma ORM, you will need to use the correct connection string for your branch. The connection URL for a given database branch can be found from your PlanetScale account by going to the overview page for the branch and selecting the 'Connect' dropdown. In the 'Passwords' section, generate a new password and select 'Prisma' from the dropdown to get the Prisma format for the connection URL. See Prisma ORM's [Getting Started guide](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-typescript-planetscale) for more details of how to connect to a PlanetScale database.\n\nEvery PlanetScale database is created with a branch called `main`, which is initially a development branch that you can use to test schema changes on. Once you are happy with the changes you make there, you can [promote it](https://planetscale.com/docs/concepts/branching#promote-a-branch-to-production) to become a production branch. Note that you can only push new changes to a development branch, so further changes will need to be created on a separate development branch and then later deployed to production using a [deploy request](https://planetscale.com/docs/concepts/branching#2.-create-a-deploy-request).\n\nIf you try to push to a production branch, you will get the [error message](https://www.prisma.io/docs/orm/reference/error-reference#p3022) `Direct execution of DDL (Data Definition Language) SQL statements is disabled on this database.`\n\n## How to use relations (and enable referential integrity) with PlanetScale[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#how-to-use-relations-and-enable-referential-integrity-with-planetscale \"Direct link to How to use relations (and enable referential integrity) with PlanetScale\")\n\n### Option 1: Emulate relations in Prisma Client[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client \"Direct link to Option 1: Emulate relations in Prisma Client\")\n\n#### 1\\. Set `relationMode = \"prisma\"`[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#1-set-relationmode--prisma \"Direct link to 1-set-relationmode--prisma\")\n\nPlanetScale does not use foreign key constraints in its database schema by default. However, Prisma ORM relies on foreign key constraints in the underlying database to enforce referential integrity between models in your Prisma schema.\n\nIn Prisma ORM versions 3.1.1 and later, you can [emulate relations in Prisma Client with the `prisma` relation mode](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#emulate-relations-in-prisma-orm-with-the-prisma-relation-mode), which avoids the need for foreign key constraints in the database.\n\nTo enable emulation of relations in Prisma Client, set the `relationMode` field to `\"prisma\"` in the `datasource` block:\n\nschema.prisma\n\n```\ndatasource db {  provider     = \"mysql\"  url          = env(\"DATABASE_URL\")  relationMode = \"prisma\"}\n```\n\ninfo\n\nThe ability to set the relation mode was introduced as part of the `referentialIntegrity` preview feature in Prisma ORM version 3.1.1, and is generally available in Prisma ORM versions 4.8.0 and later.\n\nThe `relationMode` field was renamed in Prisma ORM version 4.5.0, and was previously named `referentialIntegrity`.\n\nIf you use relations in your Prisma schema with the default `\"foreignKeys\"` option for the `relationMode` field, PlanetScale will error and Prisma ORM output the [P3021 error message](https://www.prisma.io/docs/orm/reference/error-reference#p3021) when it tries to create foreign keys. (In versions before 2.27.0 it will output a raw database error.)\n\n#### 2\\. Create indexes on foreign keys[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#2-create-indexes-on-foreign-keys \"Direct link to 2. Create indexes on foreign keys\")\n\nWhen [you emulate relations in Prisma Client](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client), you need to create your own indexes. As an example of a situation where you would want to add an index, take this schema for a blog with posts and comments:\n\nschema.prisma\n\n```\nmodel Post {  id       Int       @id @default(autoincrement())  title    String  content  String  likes    Int       @default(0)  comments Comment[]}model Comment {  id      Int    @id @default(autoincrement())  comment String  postId  Int  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)}\n```\n\nThe `postId` field in the `Comment` model refers to the corresponding `id` field in the `Post` model. However this is not implemented as a foreign key in PlanetScale, so the column doesn't have an automatic index. This means that some queries may not be well optimized. For example, if you query for all comments with a certain post `id`, PlanetScale may have to do a full table lookup. This could be slow, and also expensive because PlanetScale's billing model charges for the number of rows read.\n\nTo avoid this, you can define an index on the `postId` field using [Prisma ORM's `@@index` argument](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#index):\n\nschema.prisma\n\n```\nmodel Post {  id       Int       @id @default(autoincrement())  title    String  content  String  likes    Int       @default(0)  comments Comment[]}model Comment {  id      Int    @id @default(autoincrement())  comment String  postId  Int  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)  @@index([postId])}\n```\n\nYou can then add this change to your schema [using `db push`](https://www.prisma.io/docs/orm/overview/databases/planetscale#how-to-make-schema-changes-with-db-push).\n\nIn versions 4.7.0 and later, Prisma ORM warns you if you have a relation with no index on the relation scalar field. For more information, see [Index validation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#index-validation).\n\n### Option 2: Enable foreign key constraints in the PlanetScale database settings[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-2-enable-foreign-key-constraints-in-the-planetscale-database-settings \"Direct link to Option 2: Enable foreign key constraints in the PlanetScale database settings\")\n\nSupport for foreign key constraints in PlanetScale databases has been Generally Available since February 2024. Follow the instructions in the [PlanetScale documentation](https://planetscale.com/docs/concepts/foreign-key-constraints) to enable them in your database.\n\nYou can then use Prisma ORM and define relations in your Prisma schema without the need for extra configuration.\n\nIn that case, you can define a relation as with other database that supports foreign key constraints, for example:\n\nschema.prisma\n\n```\nmodel Post {  id       Int       @id @default(autoincrement())  title    String  content  String  likes    Int       @default(0)  comments Comment[]}model Comment {  id      Int    @id @default(autoincrement())  comment String  postId  Int  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)}\n```\n\nWith this approach, it is _not_ necessary to:\n\n*   set `relationMode = \"prisma\"` in your Prisma schema\n*   define additional indexes on foreign keys\n\nAlso, introspection will automatically create relation fields in your Prisma schema because it can detect the foreign key constraints in the database.\n\n## How to make schema changes with `db push`[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#how-to-make-schema-changes-with-db-push \"Direct link to how-to-make-schema-changes-with-db-push\")\n\nTo use `db push` with PlanetScale, you will first need to [enable emulation of relations in Prisma Client](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client). Pushing to your branch without referential emulation enabled will give the [error message](https://www.prisma.io/docs/orm/reference/error-reference#p3021) `Foreign keys cannot be created on this database.`\n\nAs an example, let's say you decide to decide to add a new `excerpt` field to the blog post schema above. You will first need to [create a new development branch and connect to it](https://www.prisma.io/docs/orm/overview/databases/planetscale#how-to-use-branches-and-deploy-requests).\n\nNext, add the following to your `schema.prisma` file:\n\nschema.prisma\n\n```\nmodel Post {  id       Int       @id @default(autoincrement())  title    String  content  String  excerpt  String?  likes    Int       @default(0)  comments Comment[]}model Comment {  id      Int    @id @default(autoincrement())  comment String  postId  Int  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)  @@index([postId])}\n```\n\nTo push these changes, navigate to your project directory in your terminal and run\n\nOnce you are happy with your changes on your development branch, you can open a deploy request to deploy these to your production branch.\n\nFor more examples, see PlanetScale's tutorial on [automatic migrations with Prisma ORM](https://planetscale.com/docs/prisma/automatic-prisma-migrations) using `db push`.\n\n## How to add in missing relations after Introspection[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#how-to-add-in-missing-relations-after-introspection \"Direct link to How to add in missing relations after Introspection\")\n\n> **Note**: This section is only relevant if you use `relationMode = \"prisma\"` to emulate foreign key constraints with Prisma ORM. If you enabled foreign key constraints in your PlanetScale database, you can ignore this section.\n\nAfter introspecting with `npx prisma db pull`, the schema you get may be missing some relations. For example, the following schema is missing a relation between the `User` and `Post` models:\n\nschema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  title     String   @db.VarChar(255)  content   String?  authorId  Int  @@index([authorId])}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?}\n```\n\nIn this case you need to add the relation in manually:\n\nschema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  title     String   @db.VarChar(255)  content   String?  author    User     @relation(fields: [authorId], references: [id])  authorId  Int  @@index([authorId])}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\nFor a more detailed example, see the [Getting Started guide for PlanetScale](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-typescript-planetscale).\n\n## How to use the PlanetScale serverless driver with Prisma ORM (Preview)[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#how-to-use-the-planetscale-serverless-driver-with-prisma-orm-preview \"Direct link to How to use the PlanetScale serverless driver with Prisma ORM (Preview)\")\n\nThe [PlanetScale serverless driver](https://planetscale.com/docs/tutorials/planetscale-serverless-driver) provides a way of communicating with your database and executing queries over HTTP.\n\nYou can use Prisma ORM along with the PlanetScale serverless driver using the [`@prisma/adapter-planetscale`](https://www.npmjs.com/package/@prisma/adapter-planetscale) driver adapter. The driver adapter allows you to communicate with your database over HTTP.\n\ninfo\n\nThis feature is available in Preview from Prisma ORM versions 5.4.2 and later.\n\nTo get started, enable the `driverAdapters` Preview feature flag:\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}\n```\n\nGenerate Prisma Client:\n\ninfo\n\nEnsure you update the host value in your connection string to `aws.connect.psdb.cloud`. You can learn more about this [here](https://planetscale.com/docs/tutorials/planetscale-serverless-driver#add-and-use-the-planetscale-serverless-driver-for-javascript-to-your-project).\n\n```\nDATABASE_URL='mysql://johndoe:strongpassword@aws.connect.psdb.cloud/clear_nightsky?sslaccept=strict'\n```\n\nInstall the Prisma ORM adapter for PlanetScale, PlanetScale serverless driver and `undici` packages:\n\n```\nnpm install @prisma/adapter-planetscale @planetscale/database undici\n```\n\ninfo\n\nWhen using a Node.js version below 18, you must provide a custom fetch function implementation. We recommend the `undici` package on which Node's built-in fetch is based. Node.js versions 18 and later include a built-in global `fetch` function, so you don't have to install an extra package.\n\nUpdate your Prisma Client instance to use the PlanetScale serverless driver:\n\n```\nimport { Client } from '@planetscale/database'import { PrismaPlanetScale } from '@prisma/adapter-planetscale'import { PrismaClient } from '@prisma/client'import dotenv from 'dotenv'import { fetch as undiciFetch } from 'undici'dotenv.config()const connectionString = `${process.env.DATABASE_URL}`const client = new Client({ url: connectionString, fetch: undiciFetch })const adapter = new PrismaPlanetScale(client)const prisma = new PrismaClient({ adapter })\n```\n\nYou can then use Prisma Client as you normally would with full type-safety. Prisma Migrate, introspection, and Prisma Studio will continue working as before using the connection string defined in the Prisma schema.\n\n## More on using PlanetScale with Prisma ORM[​](https://www.prisma.io/docs/orm/overview/databases/planetscale#more-on-using-planetscale-with-prisma-orm \"Direct link to More on using PlanetScale with Prisma ORM\")\n\nThe fastest way to start using PlanetScale with Prisma ORM is to refer to our Getting Started documentation:\n\n*   [Start from scratch](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-planetscale)\n*   [Add to existing project](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-planetscale)\n\nThese tutorials will take you through the process of connecting to PlanetScale, pushing schema changes, and using Prisma Client.\n\nFor further tips on best practices when using Prisma ORM and PlanetScale together, watch our video:",
  "title": "PlanetScale | Prisma Documentation",
  "description": "Guide to PlanetScale",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/crud",
  "markdown": "# CRUD (Reference) | Prisma Documentation\n\nThis page describes how to perform CRUD operations with your generated Prisma Client API. CRUD is an acronym that stands for:\n\n*   [Create](https://www.prisma.io/docs/orm/prisma-client/queries/crud#create)\n*   [Read](https://www.prisma.io/docs/orm/prisma-client/queries/crud#read)\n*   [Update](https://www.prisma.io/docs/orm/prisma-client/queries/crud#update)\n*   [Delete](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete)\n\nRefer to the [Prisma Client API reference documentation](https://www.prisma.io/docs/orm/reference/prisma-client-reference) for detailed explanations of each method.\n\n## Example schema[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#example-schema \"Direct link to Example schema\")\n\nAll examples are based on the following schema:\n\nExpand for sample schema\n\n*   Relational databases\n*   MongoDB\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model ExtendedProfile {  id        Int    @id @default(autoincrement())  biography String  user      User   @relation(fields: [userId], references: [id])  userId    Int    @unique}model User {  id           Int              @id @default(autoincrement())  name         String?  email        String           @unique  profileViews Int              @default(0)  role         Role             @default(USER)  coinflips    Boolean[]  posts        Post[]  profile      ExtendedProfile?}model Post {  id         Int        @id @default(autoincrement())  title      String  published  Boolean    @default(true)  author     User       @relation(fields: [authorId], references: [id])  authorId   Int  comments   Json?  views      Int        @default(0)  likes      Int        @default(0)  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String @unique  posts Post[]}enum Role {  USER  ADMIN}\n```\n\nFor **relational databases**, use `db push` command to push the example schema to your own database\n\nFor **MongoDB**, ensure your data is in a uniform shape and matches the model defined in the Prisma schema.\n\n## Create[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#create \"Direct link to Create\")\n\n### Create a single record[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#create-a-single-record \"Direct link to Create a single record\")\n\nThe following query creates ([`create()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create)) a single user with two fields:\n\n```\nconst user = await prisma.user.create({  data: {    email: 'elsa@prisma.io',    name: 'Elsa Prisma',  },})\n```\n\nThe user's `id` is auto-generated, and your schema determines [which fields are mandatory](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#optional-and-mandatory-fields).\n\n#### Create a single record using generated types[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#create-a-single-record-using-generated-types \"Direct link to Create a single record using generated types\")\n\nThe following example produces an identical result, but creates a `UserCreateInput` variable named `user` _outside_ the context of the `create()` query. After completing a simple check (\"Should posts be included in this `create()` query?\"), the `user` variable is passed into the query:\n\n```\nimport { PrismaClient, Prisma } from '@prisma/client'const prisma = new PrismaClient()async function main() {  let includePosts: boolean = false  let user: Prisma.UserCreateInput  // Check if posts should be included in the query  if (includePosts) {    user = {      email: 'elsa@prisma.io',      name: 'Elsa Prisma',      posts: {        create: {          title: 'Include this post!',        },      },    }  } else {    user = {      email: 'elsa@prisma.io',      name: 'Elsa Prisma',    }  }  // Pass 'user' object into query  const createUser = await prisma.user.create({ data: user })}main()\n```\n\nFor more information about working with generated types, see: [Generated types](https://www.prisma.io/docs/orm/prisma-client/type-safety).\n\n### Create multiple records[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#create-multiple-records \"Direct link to Create multiple records\")\n\nPrisma Client supports bulk inserts as a GA feature in [2.20.0](https://github.com/prisma/prisma/releases/2.20.0) and later.\n\nThe following [`createMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany) query creates multiple users and skips any duplicates (`email` must be unique):\n\n```\nconst createMany = await prisma.user.createMany({  data: [    { name: 'Bob', email: 'bob@prisma.io' },    { name: 'Bobo', email: 'bob@prisma.io' }, // Duplicate unique key!    { name: 'Yewande', email: 'yewande@prisma.io' },    { name: 'Angelique', email: 'angelique@prisma.io' },  ],  skipDuplicates: true, // Skip 'Bobo'})\n```\n\nwarning\n\nNote `skipDuplicates` is not supported when using MongoDB, SQLServer, or SQLite.\n\n`createMany()` uses a single `INSERT INTO` statement with multiple values, which is generally more efficient than a separate `INSERT` per row:\n\n```\nBEGININSERT INTO \"public\".\"User\" (\"id\",\"name\",\"email\",\"profileViews\",\"role\",\"coinflips\",\"testing\",\"city\",\"country\") VALUES (DEFAULT,$1,$2,$3,$4,DEFAULT,DEFAULT,DEFAULT,$5), (DEFAULT,$6,$7,$8,$9,DEFAULT,DEFAULT,DEFAULT,$10), (DEFAULT,$11,$12,$13,$14,DEFAULT,DEFAULT,DEFAULT,$15), (DEFAULT,$16,$17,$18,$19,DEFAULT,DEFAULT,DEFAULT,$20) ON CONFLICT DO NOTHINGCOMMITSELECT \"public\".\"User\".\"country\", \"public\".\"User\".\"city\", \"public\".\"User\".\"email\", SUM(\"public\".\"User\".\"profileViews\"), COUNT(*) FROM \"public\".\"User\" WHERE 1=1 GROUP BY \"public\".\"User\".\"country\", \"public\".\"User\".\"city\", \"public\".\"User\".\"email\" HAVING AVG(\"public\".\"User\".\"profileViews\") >= $1 ORDER BY \"public\".\"User\".\"country\" ASC OFFSET $2\n```\n\n> **Note**: Multiple `create()` statements inside a `$transaction` results in multiple `INSERT` statements.\n\nThe following video demonstrates how to use `createMany()` and [faker.js](https://github.com/faker-js/faker/) to seed a database with sample data:\n\n### Create records and connect or create related records[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#create-records-and-connect-or-create-related-records \"Direct link to Create records and connect or create related records\")\n\nSee [Working with relations > Nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) for information about creating a record and one or more related records at the same time.\n\n### Create and return multiple records[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#create-and-return-multiple-records \"Direct link to Create and return multiple records\")\n\ninfo\n\nThis feature is available in Prisma ORM version 5.14.0 and later for PostgreSQL, CockroachDB and SQLite.\n\nYou can use `createManyAndReturn()` in order to create many records and return the resulting objects.\n\n```\nconst users = await prisma.user.createManyAndReturn({  data: [    { name: 'Alice', email: 'alice@prisma.io' },    { name: 'Bob', email: 'bob@prisma.io' },  ],})\n```\n\nwarning\n\n`relationLoadStrategy: join` is not available when using `createManyAndReturn()`.\n\n## Read[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#read \"Direct link to Read\")\n\n### Get record by ID or unique identifier[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#get-record-by-id-or-unique-identifier \"Direct link to Get record by ID or unique identifier\")\n\nThe following queries return a single record ([`findUnique()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findunique)) by unique identifier or ID:\n\n```\n// By unique identifierconst user = await prisma.user.findUnique({  where: {    email: 'elsa@prisma.io',  },})// By IDconst user = await prisma.user.findUnique({  where: {    id: 99,  },})\n```\n\nIf you are using the MongoDB connector and your underlying ID type is `ObjectId`, you can use the string representation of that `ObjectId`:\n\n```\n// By IDconst user = await prisma.user.findUnique({  where: {    id: '60d5922d00581b8f0062e3a8',  },})\n```\n\n### Get all records[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#get-all-records \"Direct link to Get all records\")\n\nThe following [`findMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findmany) query returns _all_ `User` records:\n\n```\nconst users = await prisma.user.findMany()\n```\n\nYou can also [paginate your results](https://www.prisma.io/docs/orm/prisma-client/queries/pagination).\n\n### Get the first record that matches a specific criteria[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#get-the-first-record-that-matches-a-specific-criteria \"Direct link to Get the first record that matches a specific criteria\")\n\nThe following [`findFirst()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirst) query returns the _most recently created user_ with at least one post that has more than 100 likes:\n\n1.  Order users by descending ID (largest first) - the largest ID is the most recent\n2.  Return the first user in descending order with at least one post that has more than 100 likes\n\n```\nconst findUser = await prisma.user.findFirst({  where: {    posts: {      some: {        likes: {          gt: 100,        },      },    },  },  orderBy: {    id: 'desc',  },})\n```\n\n### Get a filtered list of records[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#get-a-filtered-list-of-records \"Direct link to Get a filtered list of records\")\n\nPrisma Client supports [filtering](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting) on record fields and related record fields.\n\n#### Filter by a single field value[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#filter-by-a-single-field-value \"Direct link to Filter by a single field value\")\n\nThe following query returns all `User` records with an email that ends in `\"prisma.io\"`:\n\n```\nconst users = await prisma.user.findMany({  where: {    email: {      endsWith: 'prisma.io',    },  },})\n```\n\n#### Filter by multiple field values[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#filter-by-multiple-field-values \"Direct link to Filter by multiple field values\")\n\nThe following query uses a combination of [operators](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions-and-operators) to return users whose name start with `E` _or_ administrators with at least 1 profile view:\n\n```\nconst users = await prisma.user.findMany({  where: {    OR: [      {        name: {          startsWith: 'E',        },      },      {        AND: {          profileViews: {            gt: 0,          },          role: {            equals: 'ADMIN',          },        },      },    ],  },})\n```\n\nThe following query returns users with an email that ends with `prisma.io` _and_ have at least _one_ post (`some`) that is not published:\n\n```\nconst users = await prisma.user.findMany({  where: {    email: {      endsWith: 'prisma.io',    },    posts: {      some: {        published: false,      },    },  },})\n```\n\nSee [Working with relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries) for more examples of filtering on related field values.\n\n### Select a subset of fields[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#select-a-subset-of-fields \"Direct link to Select a subset of fields\")\n\nThe following `findUnique()` query uses `select` to return the `email` and `name` fields of a specific `User` record:\n\n```\nconst user = await prisma.user.findUnique({  where: {    email: 'emma@prisma.io',  },  select: {    email: true,    name: true,  },})\n```\n\nFor more information about including relations, refer to:\n\n*   [Select fields](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields)\n*   [Relation queries](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries)\n\nThe following query uses a nested `select` to return:\n\n*   The user's `email`\n*   The `likes` field of each post\n\n```\nconst user = await prisma.user.findUnique({  where: {    email: 'emma@prisma.io',  },  select: {    email: true,    posts: {      select: {        likes: true,      },    },  },})\n```\n\nFor more information about including relations, see [Select fields and include relations](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields).\n\n### Select distinct field values[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#select-distinct-field-values \"Direct link to Select distinct field values\")\n\nSee [Select `distinct`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#select-distinct) for information about selecting distinct field values.\n\nThe following query returns all `ADMIN` users and includes each user's posts in the result:\n\n```\nconst users = await prisma.user.findMany({  where: {    role: 'ADMIN',  },  include: {    posts: true,  },})\n```\n\nFor more information about including relations, see [Select fields and include relations](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields).\n\n#### Include a filtered list of relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#include-a-filtered-list-of-relations \"Direct link to Include a filtered list of relations\")\n\nSee [Working with relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-a-list-of-relations) to find out how to combine [`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include) and `where` for a filtered list of relations - for example, only include a user's published posts.\n\n## Update[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#update \"Direct link to Update\")\n\n### Update a single record[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#update-a-single-record \"Direct link to Update a single record\")\n\nThe following query uses [`update()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update) to find and update a single `User` record by `email`:\n\n```\nconst updateUser = await prisma.user.update({  where: {    email: 'viola@prisma.io',  },  data: {    name: 'Viola the Magnificent',  },})\n```\n\n### Update multiple records[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#update-multiple-records \"Direct link to Update multiple records\")\n\nThe following query uses [`updateMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#updatemany) to update all `User` records that contain `prisma.io`:\n\n```\nconst updateUsers = await prisma.user.updateMany({  where: {    email: {      contains: 'prisma.io',    },  },  data: {    role: 'ADMIN',  },})\n```\n\n### Update _or_ create records[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#update-or-create-records \"Direct link to update-or-create-records\")\n\nThe following query uses [`upsert()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#upsert) to update a `User` record with a specific email address, or create that `User` record if it does not exist:\n\n```\nconst upsertUser = await prisma.user.upsert({  where: {    email: 'viola@prisma.io',  },  update: {    name: 'Viola the Magnificent',  },  create: {    email: 'viola@prisma.io',    name: 'Viola the Magnificent',  },})\n```\n\ninfo\n\nFrom version 4.6.0, Prisma Client carries out upserts with database native SQL commands where possible. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#database-upserts).\n\nPrisma Client does not have a `findOrCreate()` query. You can use `upsert()` as a workaround. To make `upsert()` behave like a `findOrCreate()` method, provide an empty `update` parameter to `upsert()`.\n\nwarning\n\nA limitation to using `upsert()` as a workaround for `findOrCreate()` is that `upsert()` will only accept unique model fields in the `where` condition. So it's not possible to use `upsert()` to emulate `findOrCreate()` if the `where` condition contains non-unique fields.\n\n### Update a number field[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#update-a-number-field \"Direct link to Update a number field\")\n\nUse [atomic number operations](https://www.prisma.io/docs/orm/reference/prisma-client-reference#atomic-number-operations) to update a number field **based on its current value** - for example, increment or multiply. The following query increments the `views` and `likes` fields by `1`:\n\n```\nconst updatePosts = await prisma.post.updateMany({  data: {    views: {      increment: 1,    },    likes: {      increment: 1,    },  },})\n```\n\n### Connect and disconnect related records[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#connect-and-disconnect-related-records \"Direct link to Connect and disconnect related records\")\n\nRefer to [Working with relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries) for information about disconnecting ([`disconnect`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#disconnect)) and connecting ([`connect`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect)) related records.\n\n## Delete[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete \"Direct link to Delete\")\n\n### Delete a single record[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete-a-single-record \"Direct link to Delete a single record\")\n\nThe following query uses [`delete()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#delete) to delete a single `User` record:\n\n```\nconst deleteUser = await prisma.user.delete({  where: {    email: 'bert@prisma.io',  },})\n```\n\nAttempting to delete a user with one or more posts result in an error, as every `Post` requires an author - see [cascading deletes](https://www.prisma.io/docs/orm/prisma-client/queries/crud#cascading-deletes-deleting-related-records).\n\n### Delete multiple records[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete-multiple-records \"Direct link to Delete multiple records\")\n\nThe following query uses [`deleteMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#deletemany) to delete all `User` records where `email` contains `prisma.io`:\n\n```\nconst deleteUsers = await prisma.user.deleteMany({  where: {    email: {      contains: 'prisma.io',    },  },})\n```\n\nAttempting to delete a user with one or more posts result in an error, as every `Post` requires an author - see [cascading deletes](https://www.prisma.io/docs/orm/prisma-client/queries/crud#cascading-deletes-deleting-related-records).\n\n### Delete all records[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete-all-records \"Direct link to Delete all records\")\n\nThe following query uses [`deleteMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#deletemany) to delete all `User` records:\n\n```\nconst deleteUsers = await prisma.user.deleteMany({})\n```\n\nBe aware that this query will fail if the user has any related records (such as posts). In this case, you need to [delete the related records first](https://www.prisma.io/docs/orm/prisma-client/queries/crud#cascading-deletes-deleting-related-records).\n\nThe following query uses [`delete()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#delete) to delete a single `User` record:\n\n```\nconst deleteUser = await prisma.user.delete({  where: {    email: 'bert@prisma.io',  },})\n```\n\nHowever, the example schema includes a **required relation** between `Post` and `User`, which means that you cannot delete a user with posts:\n\n```\nThe change you are trying to make would violate the required relation 'PostToUser' between the `Post` and `User` models.\n```\n\nTo resolve this error, you can:\n\n*   Make the relation optional:\n    \n    ```\n    model Post {  id       Int   @id @default(autoincrement())  author   User? @relation(fields: [authorId], references: [id])  authorId Int?  author   User  @relation(fields: [authorId], references: [id])  authorId Int}\n    ```\n    \n*   Change the author of the posts to another user before deleting the user.\n    \n*   Delete a user and all their posts with two separate queries in a transaction (all queries must succeed):\n    \n    ```\n    const deletePosts = prisma.post.deleteMany({  where: {    authorId: 7,  },})const deleteUser = prisma.user.delete({  where: {    id: 7,  },})const transaction = await prisma.$transaction([deletePosts, deleteUser])\n    ```\n    \n\n### Delete all records from all tables[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete-all-records-from-all-tables \"Direct link to Delete all records from all tables\")\n\nSometimes you want to remove all data from all tables but keep the actual tables. This can be particularly useful in a development environment and whilst testing.\n\nThe following shows how to delete all records from all tables with Prisma Client and with Prisma Migrate.\n\n#### Deleting all data with `deleteMany()`[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#deleting-all-data-with-deletemany \"Direct link to deleting-all-data-with-deletemany\")\n\nWhen you know the order in which your tables should be deleted, you can use the [`deleteMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#deletemany) function. This is executed synchronously in a [`$transaction`](https://www.prisma.io/docs/orm/prisma-client/queries/transactions) and can be used with all types of databases.\n\n```\nconst deletePosts = prisma.post.deleteMany()const deleteProfile = prisma.profile.deleteMany()const deleteUsers = prisma.user.deleteMany()// The transaction runs synchronously so deleteUsers must run last.await prisma.$transaction([deleteProfile, deletePosts, deleteUsers])\n```\n\n✅ **Pros**:\n\n*   Works well when you know the structure of your schema ahead of time\n*   Synchronously deletes each tables data\n\n❌ **Cons**:\n\n*   When working with relational databases, this function doesn't scale as well as having a more generic solution which looks up and `TRUNCATE`s your tables regardless of their relational constraints. Note that this scaling issue does not apply when using the MongoDB connector.\n\n> **Note**: The `$transaction` performs a cascading delete on each models table so they have to be called in order.\n\n#### Deleting all data with raw SQL / `TRUNCATE`[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#deleting-all-data-with-raw-sql--truncate \"Direct link to deleting-all-data-with-raw-sql--truncate\")\n\nIf you are comfortable working with raw SQL you can perform a `TRUNCATE` on a table by utilizing [`$executeRawUnsafe`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#executerawunsafe).\n\nIn the following examples, the first tab shows how to perform a `TRUNCATE` on a Postgres database by using a `$queryRaw` look up that maps over the table and `TRUNCATES` all tables in a single query.\n\nThe second tab shows performing the same function but with a MySQL database. In this instance the constraints must be removed before the `TRUNCATE` can be executed, before being reinstated once finished. The whole process is run as a `$transaction`\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst tablenames = await prisma.$queryRaw<  Array<{ tablename: string }>>`SELECT tablename FROM pg_tables WHERE schemaname='public'`const tables = tablenames  .map(({ tablename }) => tablename)  .filter((name) => name !== '_prisma_migrations')  .map((name) => `\"public\".\"${name}\"`)  .join(', ')try {  await prisma.$executeRawUnsafe(`TRUNCATE TABLE ${tables} CASCADE;`)} catch (error) {  console.log({ error })}\n```\n\n✅ **Pros**:\n\n*   Scalable\n*   Very fast\n\n❌ **Cons**:\n\n*   Can't undo the operation\n*   Using reserved SQL key words as tables names can cause issues when trying to run a raw query\n\n#### Deleting all records with Prisma Migrate[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#deleting-all-records-with-prisma-migrate \"Direct link to Deleting all records with Prisma Migrate\")\n\nIf you use Prisma Migrate, you can use `migrate reset`, this will:\n\n1.  Drop the database\n2.  Create a new database\n3.  Apply migrations\n4.  Seed the database with data\n\n## Advanced query examples[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#advanced-query-examples \"Direct link to Advanced query examples\")\n\n### Create a deeply nested tree of records[​](https://www.prisma.io/docs/orm/prisma-client/queries/crud#create-a-deeply-nested-tree-of-records \"Direct link to Create a deeply nested tree of records\")\n\n*   A single `User`\n*   Two new, related `Post` records\n*   Connect or create `Category` per post\n\n```\nconst u = await prisma.user.create({  include: {    posts: {      include: {        categories: true,      },    },  },  data: {    email: 'emma@prisma.io',    posts: {      create: [        {          title: 'My first post',          categories: {            connectOrCreate: [              {                create: { name: 'Introductions' },                where: {                  name: 'Introductions',                },              },              {                create: { name: 'Social' },                where: {                  name: 'Social',                },              },            ],          },        },        {          title: 'How to make cookies',          categories: {            connectOrCreate: [              {                create: { name: 'Social' },                where: {                  name: 'Social',                },              },              {                create: { name: 'Cooking' },                where: {                  name: 'Cooking',                },              },            ],          },        },      ],    },  },})\n```",
  "title": "CRUD (Reference) | Prisma Documentation",
  "description": "How to perform CRUD with Prisma Client.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/migrating-to-prisma",
  "markdown": "# Migrate to Prisma ORM from other ORMs\n\n## In this section[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma#in-this-section \"Direct link to In this section\")\n\n[\n\n## Migrate from TypeORM\n\n](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm)\n\n[\n\n## Migrate from Sequelize\n\n](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize)\n\n[\n\n## Migrate from Mongoose\n\n](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose)\n\n[\n\n## Migrate from Drizzle\n\n](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle)",
  "title": "Migrate to Prisma ORM from other ORMs | Prisma Documentation",
  "description": "How to migrate to Prisma ORM from other ORMs and query builders.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/deployment",
  "markdown": "# Deploy a Node.js application with Prisma\n\n## Deployment\n\nThis section describes how to deploy Node.js applications that use Prisma Client and TypeScript to various platforms.\n\n## In this section[​](https://www.prisma.io/docs/orm/prisma-client/deployment#in-this-section \"Direct link to In this section\")\n\n[](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma)\n\n[\n\n## Traditional servers\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional)\n\n[\n\n## Serverless functions\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless)\n\n[\n\n## Edge functions\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/edge)\n\n[\n\n## Module bundlers\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/module-bundlers)\n\n[\n\n## Deploying database changes\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-database-changes-with-prisma-migrate)\n\n[\n\n## Deploy migrations from a local environment\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-migrations-from-a-local-environment)\n\n[\n\n## Caveats when deploying to AWS platforms\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms)\n\n[\n\n## Deploy to a different OS\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-to-a-different-os)",
  "title": "Deploy a Node.js application with Prisma | Prisma Documentation",
  "description": "How to deploy a Node.js application that uses Prisma Client and TypeScript to various cloud platforms.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/accelerate/getting-started",
  "markdown": "# Getting started with Prisma Accelerate\n\n## Prerequisites[​](https://www.prisma.io/docs/accelerate/getting-started#prerequisites \"Direct link to Prerequisites\")\n\nTo get started with Accelerate, you will need the following:\n\n*   A [Prisma Data Platform workspace](https://console.prisma.io/).\n*   A project that uses [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) `4.16.1` or higher. If your project is using interactive transactions, you need to use `5.1.1` or higher. (We always recommend using the latest version of Prisma.)\n*   A hosted PostgreSQL, MySQL/MariaDB, PlanetScale, CockroachDB, or MongoDB database.\n\n## 1\\. Enable Accelerate[​](https://www.prisma.io/docs/accelerate/getting-started#1-enable-accelerate \"Direct link to 1. Enable Accelerate\")\n\nNavigate to your Prisma Data Platform project, choose an environment, and enable Accelerate by providing your database connection string and selecting the region nearest your database.\n\ninfo\n\nIf you require IP allowlisting or firewall configurations with trusted IP addresses, enable Static IP for enhanced security\n\n## 2\\. Add Accelerate to your application[​](https://www.prisma.io/docs/accelerate/getting-started#2-add-accelerate-to-your-application \"Direct link to 2. Add Accelerate to your application\")\n\n### 2.1. Update your database connection string[​](https://www.prisma.io/docs/accelerate/getting-started#21-update-your-database-connection-string \"Direct link to 2.1. Update your database connection string\")\n\nOnce enabled, you'll be prompted to generate an API key that you'll use in your new Accelerate connection string to authenticate requests.\n\nReplace your direct database url with your new Accelerate connection string.\n\n.env\n\n```\n# New Accelerate connection string with generated API_KEYDATABASE_URL=\"prisma://accelerate.prisma-data.net/?api_key=__API_KEY__\"# Previous (direct) database connection string# DATABASE_URL=\"postgresql://user:password@host:port/db_name?schema=public\"\n```\n\nYour updated connection string will be used as the datasource `url` in your Prisma schema file;\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nPrisma Migrate and Introspection do not work with a `prisma://` connection string. In order to continue using these features add a new variable to the `.env` file named `DIRECT_DATABASE_URL` whose value is the direct database connection string:\n\n.env\n\n```\nDATABASE_URL=\"prisma://accelerate.prisma-data.net/?api_key=__API_KEY__\"DIRECT_DATABASE_URL=\"postgresql://user:password@host:port/db_name?schema=public\"\n```\n\nThen in your Prisma schema's `datasource` block add a field named `directUrl` with the following:\n\n```\ndatasource db {  provider  = \"postgresql\"  url       = env(\"DATABASE_URL\")  directUrl = env(\"DIRECT_DATABASE_URL\")}\n```\n\nMigrations and introspections will use the `directUrl` connection string rather than the one defined in `url` when this configuration is provided.\n\n> `directUrl` is useful for you to carry out migrations and introspections. However, you don't need `directUrl` to use Accelerate in your application.\n\n### 2.2. Install the Accelerate Prisma Client extension[​](https://www.prisma.io/docs/accelerate/getting-started#22-install-the-accelerate-prisma-client-extension \"Direct link to 2.2. Install the Accelerate Prisma Client extension\")\n\nInstall the latest version of Prisma Client and Accelerate Prisma Client extension\n\n```\nnpm install @prisma/client@latest @prisma/extension-accelerate\n```\n\n### 2.3. Generate Prisma Client for Accelerate[​](https://www.prisma.io/docs/accelerate/getting-started#23-generate-prisma-client-for-accelerate \"Direct link to 2.3. Generate Prisma Client for Accelerate\")\n\nIf you're using Prisma version `5.2.0` or greater, Prisma Client will automatically determine how it should connect to the database depending on the protocol in the database connection string. If the connection string in the `DATABASE_URL` starts with `prisma://`, Prisma Client will try to connect to your database using Prisma Accelerate.\n\nWhen using Prisma Accelerate in long-running application servers, such as a server deployed on AWS EC2, you can generate the Prisma Client by executing the following command:\n\nWhen using Prisma Accelerate in a Serverless or an Edge application, we recommend you to run the following command to generate Prisma Client:\n\n```\nnpx prisma generate --no-engine\n```\n\ninfo\n\nThe `--no-engine` flag prevents a Query Engine file from being included in the generated Prisma Client, this ensures the bundle size of your application remains small.\n\nwarning\n\nIf your Prisma version is below `5.2.0`, generate Prisma Client with the `--accelerate` option:\n\n```\nnpx prisma generate --accelerate\n```\n\nIf your Prisma version is below `5.0.0`, generate Prisma Client with the `--data-proxy` option:\n\n### 2.4. Extend your Prisma Client instance with the Accelerate extension[​](https://www.prisma.io/docs/accelerate/getting-started#24-extend-your-prisma-client-instance-with-the-accelerate-extension \"Direct link to 2.4. Extend your Prisma Client instance with the Accelerate extension\")\n\nAdd the following to extend your existing Prisma Client instance with the Accelerate extension:\n\n```\nimport { PrismaClient } from '@prisma/client'import { withAccelerate } from '@prisma/extension-accelerate'const prisma = new PrismaClient().$extends(withAccelerate())\n```\n\nIf you are going to deploy to an edge runtime (like Cloudflare Workers, Vercel Edge Functions, Deno Deploy, or Supabase Edge Functions), use our edge client instead:\n\n```\nimport { PrismaClient } from '@prisma/client/edge'import { withAccelerate } from '@prisma/extension-accelerate'const prisma = new PrismaClient().$extends(withAccelerate())\n```\n\nIf VS Code does not recognize the `$extends` method, refer to [this section](https://www.prisma.io/docs/accelerate/faq#vs-code-does-not-recognize-the-extends-method) on how to resolve the issue.\n\ninfo\n\nIf you are using [Prisma Middleware](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware) in your application, make sure they are added before any Prisma Client extensions (like Accelerate). For example:\n\n```\nconst prisma = new PrismaClient().$use(middleware).$extends(withAccelerate())\n```\n\n### 2.5. Use Accelerate in your database queries[​](https://www.prisma.io/docs/accelerate/getting-started#25-use-accelerate-in-your-database-queries \"Direct link to 2.5. Use Accelerate in your database queries\")\n\nThe `withAccelerate` extension primarily does two things:\n\n*   Gives you access to the `cacheStrategy` field within each applicable model method that allows you to define a cache strategy per-query.\n*   Routes all of your queries through a connection pooler.\n\n#### No cache strategy to only use connection pool[​](https://www.prisma.io/docs/accelerate/getting-started#no-cache-strategy-to-only-use-connection-pool \"Direct link to No cache strategy to only use connection pool\")\n\nIf you simply want to take advantage of Accelerate's connection pooling feature without applying a cache strategy, you may run your query the same way you would have without Accelerate.\n\nBy enabling Accelerate and supplying the Accelerate connection string, your queries now use the connection pooler by default.\n\n#### Define a cache strategy[​](https://www.prisma.io/docs/accelerate/getting-started#define-a-cache-strategy \"Direct link to Define a cache strategy\")\n\nUpdate a query with the new `cacheStrategy` property which allows you to define a cache strategy for that specific query:\n\n```\nconst user = await prisma.user.findMany({  where: {    email: {      contains: 'alice@prisma.io',    },  },  cacheStrategy: { swr: 60, ttl: 60 },})\n```\n\nIn the example above, `swr: 60` and `ttl: 60` means Accelerate will serve cached data for 60 seconds and then another 60 seconds while Accelerate fetches fresh data in the background.\n\nYou should now see improved performance for your cached queries.\n\ninfo\n\nAs of Prisma version `5.2.0` you can use Prisma Studio with the Accelerate connection string.",
  "title": "Getting started with Prisma Accelerate | Prisma Documentation",
  "description": "Learn how to get up and running with Prisma Accelerate.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/platform/about",
  "markdown": "# Console: About | Prisma Documentation\n\n## Overview[​](https://www.prisma.io/docs/platform/about#overview \"Direct link to Overview\")\n\nThe [Console](http://console.prisma.io/) enables you to manage and configure your projects that use Prisma Data Platform (PDP) products, and helps you integrate them into your application:\n\n*   [Accelerate](https://www.prisma.io/docs/accelerate/what-is-accelerate): Global database cache with scalable connection pooling\n*   [Pulse](https://www.prisma.io/docs/pulse/what-is-pulse): A managed Change Data Capture (CDC) service that enables real-time database subscriptions\n\n## Concepts[​](https://www.prisma.io/docs/platform/about#concepts \"Direct link to Concepts\")\n\nThe Console workflows are based on four main concepts:\n\n*   [**User account**](https://www.prisma.io/docs/platform/about#user-account): In order to use PDP products, you need to have a PDP user account. A _user_ will typically create one user account to manage all their workspaces, projects and environments. The _user_ can also be invited to join other workspaces to collaborate on the projects in that workspace.\n*   [**Workspaces**](https://www.prisma.io/docs/platform/about#workspace): A user account can belong to multiple workspaces. A workspace typically represents a _team_ of individuals working together on one or more projects. **Billing is on a workspace level**, i.e. the invoice for a workspace at the end of the month captures all costs associated with the projects in a given workspace.\n*   [**Projects**](https://www.prisma.io/docs/platform/about#project): A project belongs to a workspace. It typically represents the _application_ or _service_ a team is working on.\n*   [**Environments**](https://www.prisma.io/docs/platform/about#environment): An environment belongs to a project. It typically maps to a _development stage_, like `Development`, `Staging` or `Production`. **API keys are provisioned on the environment level**, and products are configured per environment as well (e.g. the database connection string used for Accelerate).\n\nHere is a visual illustration of how these concepts relate to each other:\n\n![](https://www.prisma.io/docs/assets/images/pdp-concepts-e43bf8521cd94c56e296fc3851a92866.png)\n\n### User account[​](https://www.prisma.io/docs/platform/about#user-account \"Direct link to User account\")\n\nA user account is the prerequisite for any interactions with PDP products. You can use it to manage your workspaces (and their projects). A user account can be invited to collaborate on workspaces created by other users as well.\n\nIf you need to delete your user account, go [here](https://www.prisma.io/docs/platform/support#deleting-your-pdp-account).\n\n### Workspace[​](https://www.prisma.io/docs/platform/about#workspace \"Direct link to Workspace\")\n\nYou can create several workspaces. A workspace is an isolated space to host projects. A workspace can have multiple user accounts associated with it so that multiple users can collaborate on the the projects in the workspace.\n\nIn each workspace, you can:\n\n*   view and manage all projects (and their environments) in that workspace.\n*   manage billing, i.e. select a [subscription plan](https://prisma.io/pricing?utm_source=docs&utm_medium=platform-docs), configure payment methods, or view the invoice history.\n*   view the usage of your enabled PDP products across all projects in that workspace.\n*   invite other users to collaborate in the workspace.\n\n### Project[​](https://www.prisma.io/docs/platform/about#project \"Direct link to Project\")\n\nIn each workspace, you can create several projects. A project typically represents an application (a product or service). You typically have one [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) per project.\n\nIn each project, you can:\n\n*   view and manage all environments in that project.\n\nThe number of project you can create in a workspace depends on the [subscription plan](https://prisma.io/pricing?utm_source=docs&utm_medium=platform-docs) configured in that workspace.\n\n### Environment[​](https://www.prisma.io/docs/platform/about#environment \"Direct link to Environment\")\n\nAn environment is an isolated space to provision PDP products for a given project. Environments typically map to development stages, like `Development`, `Staging` or `Production`. When a new project is created, it will have a _default_ environment called `Production`.\n\nIn each environment, you can:\n\n*   enable, disable and configure PDP products (Pulse, Accelerate, ...).\n*   generate API keys.\n*   for **Accelerate**:\n    *   set your database connection string.\n    *   configure the _region_ where Accelerate's connection pool is running.\n    *   change the connection pool size.\n    *   enable static IP.\n*   for **Pulse**:\n    *   set your database connection string (of a [Pulse-compatible database](https://www.prisma.io/docs/pulse/database-setup)).\n    *   configure the _region_ where Pulse is running.\n    *   configure database replication.\n\nThe number of environments you can create in a project depends on the [subscription plan](https://prisma.io/pricing?utm_source=docs&utm_medium=platform-docs) configured in your workspace.\n\n## Billing[​](https://www.prisma.io/docs/platform/about#billing \"Direct link to Billing\")\n\nThe [subscription plan](https://prisma.io/pricing?utm_source=docs&utm_medium=platform-docs) you select in your workspace determines how many projects and environments you can create in that workspace:\n\n|     | **Starter** | **Pro** | **Business** | **Enterprise** |\n| --- | --- | --- | --- | --- |\n| **Projects** | 5   | 10  | 15  | Custom |\n| **Environments** | 2 / project | 6 / project | 12 / project | Custom |\n\n### Per-workspace billing[​](https://www.prisma.io/docs/platform/about#per-workspace-billing \"Direct link to Per-workspace billing\")\n\nBilling is set up on a per-workspace basis:\n\n*   A subscription plan is selected per workspace. That means, a user account can belong to multiple workspaces where each workspace uses a different plan.\n*   A payment method is selected per workspace. That means, a user account can belong to multiple workspaces where each workspace has a different payment method.\n\nAt the end of a billing period, your selected payment method will be charged with the incurred costs of products across _all_ projects (and their environments) in that workspace.\n\nYou can configure all billing details in the **Billing** section of your workspace.\n\n### Prorated billing[​](https://www.prisma.io/docs/platform/about#prorated-billing \"Direct link to Prorated billing\")\n\nAll base plan prices are prorated, which means you're only billed for the duration of your subscription to a specific plan. In addition, you're also billed for any usage costs you've incurred during your subscription.\n\nFor example:\n\n*   if you subscribe to our **Pro** plan on the 15th day of a month, you'll only be charged the base plan price for the days left in that month.\n*   if you downgrade your subscription plan (e.g. from **Business** to **Pro**) after 10 days of a 30-day month, you'll be charged for 10 days of the base price of the **Business** plan and 20 days for the base price of the **Pro** plan.\n\nVisit our [pricing page](https://prisma.io/pricing?utm_source=docs&utm_medium=platform-docs) for more details.\n\n### Downgrading a subscription plan[​](https://www.prisma.io/docs/platform/about#downgrading-a-subscription-plan \"Direct link to Downgrading a subscription plan\")\n\nIf you downgrade a subscription plan, you may need to delete some of your projects and/or their environments in order to adhere to the [limits](https://www.prisma.io/docs/platform/about#environment) of the newly selected plan.\n\nFor example, if your workspace is on a **Business** plan and currently has 14 (out of 15) projects, you will need to delete at least 4 projects to adhere to the project limit of the **Pro** plan. Additionally, you need to make sure that the remaining projects don't have more than 6 environments per project to adhere to the environment limit of the **Pro** plan.\n\n## Programmatic access via the Platform CLI[​](https://www.prisma.io/docs/platform/about#programmatic-access-via-the-platform-cli \"Direct link to Programmatic access via the Platform CLI\")\n\nIn addition to the web interface of the Console, the Prisma CLI provides another way to interact with your PDP account and manage PDP products.\n\nThis can be useful if you need programmatic access, e.g. for integrating it into CI workflows.\n\nRead more about the [Prisma CLI](https://www.prisma.io/docs/platform/platform-cli).\n\n## API keys[​](https://www.prisma.io/docs/platform/about#api-keys \"Direct link to API keys\")\n\nAn API key is required to authenticate requests from your Prisma Client to products such as Prisma Accelerate and Prisma Pulse.\n\nAPIs keys are _not_ product-specific, meaning you can use the same API key for both Accelerate and Pulse when used in the same environment.\n\nYou may generate multiple API keys per environment and manage those via the **API Keys** section in an environment.",
  "title": "Console: About | Prisma Documentation",
  "description": "Learn about the Console to integrate the Prisma Data Platform products.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse/getting-started",
  "markdown": "# Getting started with Prisma Pulse\n\n## Prerequisites[​](https://www.prisma.io/docs/pulse/getting-started#prerequisites \"Direct link to Prerequisites\")\n\ninfo\n\nPrisma Pulse currently supports PostgreSQL. We'd love to hear [which databases](https://tally.so/r/wLbb8G) you would like to see supported next.\n\nTo get started with Pulse, you will need the following:\n\n*   A [Prisma Data Platform](https://console.prisma.io/) account\n*   The **connection string** of a Pulse-ready database (if you don't have one yet, you can [configure your existing database](https://www.prisma.io/docs/pulse/database-setup) or [use a Railway template](https://railway.app/template/pulse-pg?referralCode=VQ09uv))\n\n## 1\\. Enable Pulse in the Platform Console[​](https://www.prisma.io/docs/pulse/getting-started#1-enable-pulse-in-the-platform-console \"Direct link to 1. Enable Pulse in the Platform Console\")\n\n### 1.1. Choose the environment you want to enable Pulse for[​](https://www.prisma.io/docs/pulse/getting-started#11-choose-the-environment-you-want-to-enable-pulse-for \"Direct link to 1.1. Choose the environment you want to enable Pulse for\")\n\nOpen the [Platform Console](https://console.prisma.io/), navigate to your workspace of choice, then select the project and choose the environment in which you want to enable Pulse.\n\nIf you don't have a project yet in your workspace, you can create a new one.\n\n### 1.2. Enable Pulse[​](https://www.prisma.io/docs/pulse/getting-started#12-enable-pulse \"Direct link to 1.2. Enable Pulse\")\n\nIn the project environment of your choice, click the **Enable Pulse** button.\n\n### 1.3. Configure Pulse[​](https://www.prisma.io/docs/pulse/getting-started#13-configure-pulse \"Direct link to 1.3. Configure Pulse\")\n\nThe Pulse **Setup** screen requires you to:\n\n1.  provide your **Database connection string**\n2.  select a **Region** where Pulse should be hosted\n3.  decide whether you want to use the **Automatic setup** for [**Database replication**](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#enable-logical-replication) (only available on paid plans)\n4.  make sure **Event persistence** is enabled to use delivery guarantees with [`.stream()`](https://www.prisma.io/docs/pulse/api-reference#stream) (or disable it if you want to use [`.subscribe()`](https://www.prisma.io/docs/pulse/api-reference#subscribe) for fully ephemeral events without delivery guarantees)\n\nWhen you're done with that, click the **Enable Pulse** button at the bottom of the screen. This will test the connectivity to your database.\n\n### 1.4. Generate an API key[​](https://www.prisma.io/docs/pulse/getting-started#14-generate-an-api-key \"Direct link to 1.4. Generate an API key\")\n\ninfo\n\nIf you already have an API key for your current environment, you can skip this step und use the existing API key for using Prisma Pulse.\n\nYou can generate an API key by clicking the **Generate API key** button. Store the API key in a secure location or add it to the `.env` file of your project:\n\n.env\n\n```\nPULSE_API_KEY=\"your_secure_pulse_api_key\"\n```\n\nYou won't be able to access the same API key again afterwards.\n\n## 2\\. Add Pulse to your application[​](https://www.prisma.io/docs/pulse/getting-started#2-add-pulse-to-your-application \"Direct link to 2. Add Pulse to your application\")\n\nWith Pulse enabled, proceed with these steps to integrate Pulse into your application. You can also utilize our [example repository](https://github.com/prisma/prisma-examples/tree/latest/pulse/starter) on GitHub as a reference guide.\n\n### 2.1. Install the Pulse Client extension[​](https://www.prisma.io/docs/pulse/getting-started#21-install-the-pulse-client-extension \"Direct link to 2.1. Install the Pulse Client extension\")\n\nInstall the Pulse extension:\n\n```\nnpm install @prisma/extension-pulse@latest\n```\n\n### 2.2. Extend your Prisma Client instance with the Pulse extension[​](https://www.prisma.io/docs/pulse/getting-started#22-extend-your-prisma-client-instance-with-the-pulse-extension \"Direct link to 2.2. Extend your Prisma Client instance with the Pulse extension\")\n\nAdd the following to extend your existing Prisma Client instance with the Prisma Pulse extension:\n\n```\nimport { PrismaClient } from '@prisma/client'import { withPulse } from '@prisma/extension-pulse'const prisma = new PrismaClient().$extends(  withPulse({ apiKey: process.env.PULSE_API_KEY }))\n```\n\nwarning\n\nYou may need to [configure your `tsconfig.json`](https://www.prisma.io/docs/pulse/faq#how-to-configure-tsconfigjson-with-the-pulse-extension) if you see the following error message:\n\n```\nCannot find module '@prisma/extension-pulse' or its corresponding type declarations.\n```\n\n### 2.3. Create your first Pulse stream[​](https://www.prisma.io/docs/pulse/getting-started#23-create-your-first-pulse-stream \"Direct link to 2.3. Create your first Pulse stream\")\n\nWith the Pulse extension applied, you can use Pulse's `.stream()` method on any model defined in your Prisma Schema to stream data change events.\n\nIn the below example, it is assumed that your Prisma schema has a `User` model. A stream is created for the `User` model that listens for _any_ change event on that table:\n\n*   Stream\n*   Prisma schema\n\n```\nimport { PrismaClient } from '@prisma/client'import { withPulse } from '@prisma/extension-pulse'const prisma = new PrismaClient().$extends(  withPulse({ apiKey: process.env.PULSE_API_KEY }))async function main() {  const stream = await prisma.user.stream()  for await (const event of stream) {    console.log('just received an event:', event)  }}main()\n```\n\n## 3\\. Test your stream[​](https://www.prisma.io/docs/pulse/getting-started#3-test-your-stream \"Direct link to 3. Test your stream\")\n\nAfter running the code snippet above, you can test the stream by _creating_, _updating_ or _deleting_ a `User` record in your database.\n\nYou can do that using Prisma Studio (by running `npx prisma studio`) or by using any other database client of your choice (like [Postico](https://eggerapps.at/postico2/) or `psql`).\n\nIf everything worked, you should see the event being logged to the terminal where you can the code snippet from above. 🎉\n\n## Next steps[​](https://www.prisma.io/docs/pulse/getting-started#next-steps \"Direct link to Next steps\")\n\nYou can try out more filters on your Pulse stream, for example:\n\n**Stream only `create` events**:\n\n```\nconst stream = await prisma.user.stream({  create: { },})\n```\n\n**Stream only `update` events**:\n\n```\nconst stream = await prisma.user.stream({  update: { },})\n```\n\n**Stream only `delete` events**:\n\n```\nconst stream = await prisma.user.stream({  delete: { },})\n```\n\nPulse offers even more fine-grained filters than these. You can explore these in the [API reference](https://www.prisma.io/docs/pulse/api-reference).\n\n## Need help?[​](https://www.prisma.io/docs/pulse/getting-started#need-help \"Direct link to Need help?\")\n\nReach out to us in the `#help-and-questions` channel on our [Discord](https://pris.ly/discord), or connect with our community to see how others are using Pulse.",
  "title": "Getting started with Prisma Pulse | Prisma Documentation",
  "description": "Learn how to get up and running with Prisma Pulse.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/platform/platform-cli/commands",
  "markdown": "# Platform CLI: Commands | Prisma Documentation\n\nThis document describes the Prisma Data Platform's integrated Prisma CLI commands, arguments, and options.\n\n## Getting started[​](https://www.prisma.io/docs/platform/platform-cli/commands#getting-started \"Direct link to Getting started\")\n\nTo get started, ensure you have the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli) updated to version `5.10.0` or later. This is necessary to access the Platform through the Prisma CLI.\n\ninfo\n\n💡 When using commands, always start with `prisma platform` and include the `--early-access` flag to enable the use of the Prisma Data Platform whilst still in early access.\n\n## Authentication[​](https://www.prisma.io/docs/platform/platform-cli/commands#authentication \"Direct link to Authentication\")\n\n### `platform`[​](https://www.prisma.io/docs/platform/platform-cli/commands#platform \"Direct link to platform\")\n\n#### `auth login`[​](https://www.prisma.io/docs/platform/platform-cli/commands#auth-login \"Direct link to auth-login\")\n\nOpens a browser window that allows you to log into your Prisma Data Platform account or create a new one.\n\n```\nnpx prisma platform auth login --early-access\n```\n\n#### `auth logout`[​](https://www.prisma.io/docs/platform/platform-cli/commands#auth-logout \"Direct link to auth-logout\")\n\nLogs out of your Prisma Data Platform account.\n\n```\nnpx prisma platform auth logout --early-access\n```\n\n#### `auth show`[​](https://www.prisma.io/docs/platform/platform-cli/commands#auth-show \"Direct link to auth-show\")\n\nDisplays information about the currently authenticated user.\n\n```\nnpx prisma platform auth show --early-access\n```\n\n### Workspace Management[​](https://www.prisma.io/docs/platform/platform-cli/commands#workspace-management \"Direct link to Workspace Management\")\n\n### `platform`[​](https://www.prisma.io/docs/platform/platform-cli/commands#platform-1 \"Direct link to platform-1\")\n\n#### `workspace show`[​](https://www.prisma.io/docs/platform/platform-cli/commands#workspace-show \"Direct link to workspace-show\")\n\nLists all workspaces available to your account.\n\n```\nnpx prisma platform workspace show --early-access\n```\n\n### Project Management[​](https://www.prisma.io/docs/platform/platform-cli/commands#project-management \"Direct link to Project Management\")\n\n### `platform`[​](https://www.prisma.io/docs/platform/platform-cli/commands#platform-2 \"Direct link to platform-2\")\n\n#### `project show`[​](https://www.prisma.io/docs/platform/platform-cli/commands#project-show \"Direct link to project-show\")\n\nLists all projects within the specified workspace.\n\n```\nnpx prisma platform project show \\--workspace $INSERT_WORKSPACE_ID \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments \"Direct link to Arguments\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--workspace` `-w` | `string` | yes | The workspace id.<br><br>**Hint:** You can view your workspace ids with the [`workspace show`](https://www.prisma.io/docs/platform/platform-cli/commands#workspace-show) command. |\n\n#### `project create`[​](https://www.prisma.io/docs/platform/platform-cli/commands#project-create \"Direct link to project-create\")\n\nCreates a new project within the specified workspace.\n\n```\nnpx prisma platform project create \\--workspace $INSERT_WORKSPACE_ID \\--name \"INSERT_PROJECT_NAME\" \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments-1 \"Direct link to arguments-1\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--workspace` `-w` | `string` | yes | The workspace `id`.<br><br>**Hint:** You can view your workspace ids with the [`workspace show`](https://www.prisma.io/docs/platform/platform-cli/commands#workspace-show) command. |\n| `--name` `-n` | `string` | no  | The display name for the project.<br><br>If omitted, a default project name will be generated for you. |\n\n#### `project delete`[​](https://www.prisma.io/docs/platform/platform-cli/commands#project-delete \"Direct link to project-delete\")\n\nDeletes the specified project.\n\n```\nnpx prisma platform project delete \\--project $INSERT_PROJECT_ID \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments-2 \"Direct link to arguments-2\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--project` `-p` | `string` | yes | The project `id`.<br><br>**Hint:** You can view your project ids with the [`project show`](https://www.prisma.io/docs/platform/platform-cli/commands#project-show) command. |\n\n### Environment Management[​](https://www.prisma.io/docs/platform/platform-cli/commands#environment-management \"Direct link to Environment Management\")\n\n### `platform`[​](https://www.prisma.io/docs/platform/platform-cli/commands#platform-3 \"Direct link to platform-3\")\n\n#### `environment show`[​](https://www.prisma.io/docs/platform/platform-cli/commands#environment-show \"Direct link to environment-show\")\n\nLists all environments within the specified project.\n\n```\nnpx prisma platform environment show \\--project $INSERT_PROJECT_ID \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments-3 \"Direct link to Arguments\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--project` `-p` | `string` | yes | The project `id`.<br><br>**Hint:** You can view your project ids with the [`project show`](https://www.prisma.io/docs/platform/platform-cli/commands#project-show) command. |\n\n#### `environment create`[​](https://www.prisma.io/docs/platform/platform-cli/commands#environment-create \"Direct link to environment-create\")\n\nCreates a new environment within the specified project.\n\n```\nnpx prisma platform environment create \\--project $INSERT_PROJECT_ID \\--name $INSERT_ENVIRONMENT_NAME \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments-4 \"Direct link to arguments-4\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--project` `-p` | `string` | yes | The project `id`.<br><br>**Hint:** You can view your project ids with the [`project show`](https://www.prisma.io/docs/platform/platform-cli/commands#project-show) command. |\n| `--name` `-n` | `string` | no  | The display name for the environment.<br><br>If omitted, a default environment name will be generated for you. |\n\n#### `environment delete`[​](https://www.prisma.io/docs/platform/platform-cli/commands#environment-delete \"Direct link to environment-delete\")\n\nDeletes the specified environment.\n\n```\nnpx prisma platform environment delete \\--environment $INSERT_ENVIRONMENT_ID \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments-5 \"Direct link to arguments-5\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--environment` `-e` | `string` | yes | The environment `id`.<br><br>**Hint:** You can view your environment ids with the [`environment show`](https://www.prisma.io/docs/platform/platform-cli/commands#environment-show) command. |\n\n### API Key Management[​](https://www.prisma.io/docs/platform/platform-cli/commands#api-key-management \"Direct link to API Key Management\")\n\n### `platform`[​](https://www.prisma.io/docs/platform/platform-cli/commands#platform-4 \"Direct link to platform-4\")\n\n#### `apikey show`[​](https://www.prisma.io/docs/platform/platform-cli/commands#apikey-show \"Direct link to apikey-show\")\n\nLists all API keys for the specified environment.\n\n```\nnpx prisma platform apikey show \\--environment $INSERT_ENVIRONMENT_ID \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments-6 \"Direct link to Arguments\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--environment` `-e` | `string` | yes | The environment `id`.<br><br>**Hint:** You can view your environment ids with the [`environment show`](https://www.prisma.io/docs/platform/platform-cli/commands#environment-show) command. |\n\n#### `apikey create`[​](https://www.prisma.io/docs/platform/platform-cli/commands#apikey-create \"Direct link to apikey-create\")\n\nCreates a new API key for the specified project.\n\n```\nnpx prisma platform apikey create \\--environment $INSERT_ENVIRONMENT_ID \\--name $INSERT_API_KEY_NAME \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments-7 \"Direct link to arguments-7\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--environment` `-e` | `string` | yes | The environment `id`.<br><br>**Hint:** You can view your environment ids with the [`environment show`](https://www.prisma.io/docs/platform/platform-cli/commands#environment-show) command. |\n| `--name` `-n` | `string` | no  | The display name for the API key.<br><br>If omitted, a default API key name will be generated for you. |\n\n#### `apikey delete`[​](https://www.prisma.io/docs/platform/platform-cli/commands#apikey-delete \"Direct link to apikey-delete\")\n\nDeletes the specified API Key.\n\n```\nnpx prisma platform apikey delete \\--apikey $INSERT_API_KEY_ID \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments-8 \"Direct link to arguments-8\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--apikey` | `string` | yes | The API key `id`.<br><br>**Hint**: You can view your API key ids with the [`apikey show`](https://www.prisma.io/docs/platform/platform-cli/commands#apikey-show) command. |\n\n### Prisma Accelerate[​](https://www.prisma.io/docs/platform/platform-cli/commands#prisma-accelerate \"Direct link to Prisma Accelerate\")\n\n### `platform`[​](https://www.prisma.io/docs/platform/platform-cli/commands#platform-5 \"Direct link to platform-5\")\n\n#### `accelerate enable`[​](https://www.prisma.io/docs/platform/platform-cli/commands#accelerate-enable \"Direct link to accelerate-enable\")\n\nEnables Prisma Accelerate for the specified environment.\n\n```\nnpx prisma platform accelerate enable \\--environment $INSERT_ENVIRONMENT_ID \\--url \"postgresql://username:password@host:port/database\" \\--region $INSERT_CONNECTION_POOL_REGION \\--apikey true \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments-9 \"Direct link to arguments-9\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--environment` `-e` | `string` | yes | The environment `id`.<br><br>**Hint:** You can view your environment ids with the [`environment show`](https://www.prisma.io/docs/platform/platform-cli/commands#environment-show) command. |\n| `--url` | `string` | yes | Your database connection string. |\n| `--region` | `string` | no  | The region for Prisma Accelerate’s managed connection pool.<br><br>View the list of available regions [here](https://www.prisma.io/docs/accelerate/faq#what-regions-is-accelerates-connection-pool-available-in).<br><br>**Hint**: Select the region _nearest_ your database for optimal latency. |\n| `--apikey` | `boolean` | no  | If yes, a new API key will be generated for the associated environment. |\n\n#### `accelerate disable`[​](https://www.prisma.io/docs/platform/platform-cli/commands#accelerate-disable \"Direct link to accelerate-disable\")\n\nDisables Prisma Accelerate for the specified environment.\n\n```\nnpx prisma platform accelerate disable \\--environment $INSERT_ENVIRONMENT_ID \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments-10 \"Direct link to arguments-10\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--environment` `-e` | `string` | yes | The environment `id`.<br><br>**Hint:** You can view your environment ids with the [`environment show`](https://www.prisma.io/docs/platform/platform-cli/commands#environment-show) command. |\n\n### Prisma Pulse[​](https://www.prisma.io/docs/platform/platform-cli/commands#prisma-pulse \"Direct link to Prisma Pulse\")\n\n### `platform`[​](https://www.prisma.io/docs/platform/platform-cli/commands#platform-6 \"Direct link to platform-6\")\n\n#### `pulse enable`[​](https://www.prisma.io/docs/platform/platform-cli/commands#pulse-enable \"Direct link to pulse-enable\")\n\nEnables Prisma Pulse for the specified environment.\n\n```\nnpx prisma platform pulse enable \\--environment $INSERT_ENVIRONMENT_ID \\--url \"postgresql://username:password@host:port/database\" \\--region $INSERT_REGION \\--apikey true \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments-11 \"Direct link to arguments-11\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--environment` `-e` | `string` | yes | The environment `id`.<br><br>**Hint:** You can view your environment ids with the [`environment show`](https://www.prisma.io/docs/platform/platform-cli/commands#environment-show) command. |\n| `--url` | `string` | yes | Your database connection string. |\n| `--region` | `string` | no  | The region for Prisma Pulse. |\n| `--apikey` | `boolean` | no  | If yes, a new API key will be generated for the associated environment. |\n\n#### `pulse disable`[​](https://www.prisma.io/docs/platform/platform-cli/commands#pulse-disable \"Direct link to pulse-disable\")\n\nDisables Prisma Pulse for the specified environment.\n\n```\nnpx prisma platform pulse disable \\--environment $INSERT_ENVIRONMENT_ID \\--early-access\n```\n\n##### Arguments[​](https://www.prisma.io/docs/platform/platform-cli/commands#arguments-12 \"Direct link to arguments-12\")\n\n| Argument | Type | Required | Description |\n| --- | --- | --- | --- |\n| `--environment` `-e` | `string` | yes | The environment `id`.<br><br>**Hint:** You can view your environment ids with the [`environment show`](https://www.prisma.io/docs/platform/platform-cli/commands#environment-show) command. |\n\n## Help[​](https://www.prisma.io/docs/platform/platform-cli/commands#help \"Direct link to Help\")\n\nHave a question? Let us know, we’re here to help. Reach out to us on [Discord](https://pris.ly/discord).",
  "title": "Platform CLI: Commands | Prisma Documentation",
  "description": "This document describes the Prisma Data Platform's integrated Prisma CLI commands, arguments, and options.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema",
  "markdown": "# Prisma schema | Prisma Documentation\n\n## In this section[​](https://www.prisma.io/docs/orm/prisma-schema#in-this-section \"Direct link to In this section\")\n\n[\n\n## Overview\n\n](https://www.prisma.io/docs/orm/prisma-schema/overview)\n\n[\n\n## Data model\n\n](https://www.prisma.io/docs/orm/prisma-schema/data-model)\n\n[\n\n## Introspection\n\n](https://www.prisma.io/docs/orm/prisma-schema/introspection)\n\n[\n\n## PostgreSQL extensions\n\n](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions)",
  "title": "Prisma schema | Prisma Documentation",
  "description": "Learn everything you need to know about the Prisma schema.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/tools/prisma-studio",
  "markdown": "# Prisma Studio | Prisma Documentation\n\nPrisma Studio is a visual editor for the data in your database. Note that Prisma Studio is not open source but you can still create issues in the [`prisma/studio`](https://github.com/prisma/studio) repo.\n\nRun `npx prisma studio` in your terminal.\n\n## Models (tables or collections)[​](https://www.prisma.io/docs/orm/tools/prisma-studio#models-tables-or-collections \"Direct link to Models (tables or collections)\")\n\nWhen you first open Prisma Studio, you see a list of all models defined in your Prisma schema file.\n\ninfo\n\nThe term **model** refers to the data model definitions that you add to the Prisma schema file. Depending on the database that you use, a model definition, such as `model User`, refers to a **table** in a relational database (PostgreSQL, MySQL, SQL Server, SQLite, CockroachDB) or a **collection** in MongoDB.\n\nFor more information, see [Defining models](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-models).\n\nYou can select a model and its data opens in a new tab.\n\n![Prisma Studio - Models view](https://www.prisma.io/docs/assets/images/01-models-view-0d645052848ae1fd491dbbfb4cdd3b51.png)\n\n### Open and close models[​](https://www.prisma.io/docs/orm/tools/prisma-studio#open-and-close-models \"Direct link to Open and close models\")\n\nTo open another model, click the **+** button.\n\nTo close a model, click the the **x** button in the model tab.\n\n![Prisma Studio - Open and close models](https://www.prisma.io/docs/assets/images/02-open-close-models-871ac0d74792848d4fa61278d4fc8186.png)\n\n### Icons of data types in models[​](https://www.prisma.io/docs/orm/tools/prisma-studio#icons-of-data-types-in-models \"Direct link to Icons of data types in models\")\n\nThe data type for each field is indicated with an icon in the header.\n\nThe table below lists all data types and their identifying icon.\n\n| Field data type | Description |\n| --- | --- |\n|     | Text |\n|     | Integer |\n|     | Date-time |\n|     | Boolean |\n|     | Pre-defined list of values (`enum` data type) |\n|     | List of related records from another model |\n|     | The `{}` symbol can refer to one of the two types of fields.<br><br>• Relation field  <br>• JSON field |\n\n### Keyboard shortcuts in models[​](https://www.prisma.io/docs/orm/tools/prisma-studio#keyboard-shortcuts-in-models \"Direct link to Keyboard shortcuts in models\")\n\nWhen you open a model, a number of keyboard shortcuts are available to browse and manipulate the data in the model.\n\ninfo\n\n**Note**\n\nWith Prisma Studio open, you can open the keyboard shortcuts modal by pressing Cmd ⌘+/ on macOS or Ctrl+/ on Windows.\n\n![Prisma Studio - Keyboard shortcuts](https://www.prisma.io/docs/assets/images/03-model-view-keyboard-shortcuts-cf3c1a80d976056949b574738cd5b13a.png)\n\n## Edit data[​](https://www.prisma.io/docs/orm/tools/prisma-studio#edit-data \"Direct link to Edit data\")\n\nIn the model view, you can edit data directly in the model cells. You can copy and paste values in cells. You can add new records as well as delete existing records.\n\nYou must confirm every edit operation (add, edit, or delete). You confirm added and edited records with the **Save change** button. When you select records and click **Delete records**, you confirm the deletion in a dialog box.\n\nYou can accumulate multiple added records and edited cells, which you can then finalize with the **Save changes** button.\n\nYou can select multiple records and delete them at once with the **Delete records** button. When you delete multiple records, the operation completes immediately (after you confirm it).\n\nIn addition, if you have any accumulated added or edited records and then decide to delete records, the deletion also force-saves the accumulated edits.\n\nYou can discard any accumulated changes with the **Discard changes** button.\n\n### Copy and paste[​](https://www.prisma.io/docs/orm/tools/prisma-studio#copy-and-paste \"Direct link to Copy and paste\")\n\nYou can copy the value of any table cell using:\n\n*   Cmd ⌘ + C   on macOS\n*   Ctrl + C     on Windows\n\nTo paste in another cell, first double-click the cell to enter edit mode, and then use:\n\n*   Cmd ⌘ + V   on macOS\n*   Ctrl + V     on Windows\n\n### Add a record[​](https://www.prisma.io/docs/orm/tools/prisma-studio#add-a-record \"Direct link to Add a record\")\n\n1.  In the model view, click **Add record**.\n    \n2.  Based on the data allowed in each field, type the data for the record.\n    \n    | Field data type | Description |\n    | --- | --- |\n    |     | Text |\n    |     | Integer<br><br>If such a field has `autoincrement()` pre-filled, do not edit the cell and do not add a number manually. |\n    |     | Date-time<br><br>Date-time fields contain a long string of numbers, letters, and others. As a best practice, copy the value of another date-time cell and modify it as necessary before pasting in the field. |\n    |     | Boolean<br><br>Select `true` or `false`. |\n    |     | Pre-defined list<br><br>Double-click a cell in the field and select one of the pre-defined options. |\n    |     | List of related records from another model<br><br>It typically refers to a list of records that exist in another model in the database. If you are adding a new record and records from the related model do not yet exist, you do not need to enter anything in the current model. |\n    |     | The `{}` symbol can refer to one of the two types of fields.<br><br>• Relation field  <br>• JSON field<br><br>**Relation with a model defined separately in the database**<br><br>Typically, you need to select the same value as any of the previous records  <br>Click the name of the model to see the list of values which you can then select for the related field.<br><br>**JSON field**<br><br>Double-click the field to edit the JSON data. As a best practice, validate the edited JSON data in a validator and paste it back in the cell. |\n    \n3.  (Optional) If you are unhappy with your changes, click **Discard changes** and start over.\n    \n4.  Click **Save 1 change**.\n    \n\n### Edit a record[​](https://www.prisma.io/docs/orm/tools/prisma-studio#edit-a-record \"Direct link to Edit a record\")\n\n1.  Double-click a cell with existing data to edit.\n2.  (Optional) If you are unhappy with your changes, click **Discard changes** and start over.\n3.  Click **Save 1 change**.\n\n### Delete a record[​](https://www.prisma.io/docs/orm/tools/prisma-studio#delete-a-record \"Direct link to Delete a record\")\n\n1.  From the left column, select the check box for the record you want to delete.\n2.  Click **Delete 1 record**.\n3.  Click **Delete** in the confirmation dialog.\n\n### Edit multiple records at once[​](https://www.prisma.io/docs/orm/tools/prisma-studio#edit-multiple-records-at-once \"Direct link to Edit multiple records at once\")\n\nYou can add multiple records, edit multiple cells and, thus, accumulate multiple edits.\n\nIn the end, click **Save changes** to finalize them.\n\nwarning\n\n**Warning**\n\nDeleting a record is a separate operation that cannot be accumulated. If you delete a record while having unsaved edits, the delete operation first force-saves the unsaved edits and then completes.\n\n![Prisma Studio - Save multiple data edits](https://www.prisma.io/docs/assets/images/04-save-multiple-changes-6e28e7ffbfa4552d64862559d0fa87e9.png)\n\n## Filters[​](https://www.prisma.io/docs/orm/tools/prisma-studio#filters \"Direct link to Filters\")\n\n### Filter data[​](https://www.prisma.io/docs/orm/tools/prisma-studio#filter-data \"Direct link to Filter data\")\n\nUse the **Filters** menu to filter data in the model by adding conditions.\n\nIn the **Filters** menu, the first condition that you add is the `where` clause.\n\nWhen you add multiple conditions, Prisma Studio filters the results so that all conditions apply in combination. Each new condition indicates this with the `and` operator, which appears in front.\n\n**Steps**\n\n1.  Click **Filters** to open the **Filters** menu.\n    \n    info\n    \n    **Note**  \n    Click **Filters** again if you want to hide the menu.\n    \n2.  Click **Add a new filter**.\n    \n3.  Configure the condition.\n    \n    1.  Select the field by which you want to filter.\n    2.  Select a comparison operator.\n        *   **equals**\n        *   **in**\n        *   **notin**\n        *   **lt**\n        *   **lte**\n        *   **gt**\n        *   **gte**\n        *   **not**\n    3.  Type the value you want to use for the condition.  \n        **Step result**: **Prisma Studio** updates the data in the model immediately, based on the condition.\n4.  To add a new filter, click **Add a new filter** and repeat the steps above.\n    \n5.  To remove a filter, click the **x** button on the right.\n    \n    ![Prisma Studio - add and remove filters](https://www.prisma.io/docs/assets/images/05-add-remove-filters-cd82f0d5197d01244ce09f115cd247eb.png)\n6.  To remove all filters, click **Clear all**.\n    \n\n**Result**\n\n*   The data in the model is filtered based on the combination of all conditions you add.\n*   In the **Filters** menu, the default value of **None** changes to display the number of filters you add.\n\n### Show and hide fields[​](https://www.prisma.io/docs/orm/tools/prisma-studio#show-and-hide-fields \"Direct link to Show and hide fields\")\n\nYou can select which fields to view or hide by using the **Fields** menu.\n\ninfo\n\n**What is a field?**  \n\nA **field** is a property of a model which you add in the data model definitions in the Prisma schema file. Depending on the database that you use, a field, such as the `title` field in `model User { title String }`, refers to a **column** in a relational database (PostgreSQL, MySQL, SQL Server, SQLite, CockroachDB) or a **document field** in MongoDB.  \nFor more information, see [Defining fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-fields).\n\n**Steps**\n\n1.  Click the **Fields** menu.\n2.  Select only the fields you want to see and deselect any fields you want to hide. ![Prisma Studio - show and hide fields](https://www.prisma.io/docs/assets/images/06-show-hide-fields-9a7acc7c9199d941005ba91e12950167.png)\n\n**Result**\n\nThe model is immediately filtered to hide the data from any fields you have deselected.\n\nAlso, the **Fields** menu shows the number of fields that are currently selected.\n\n### Show and hide records[​](https://www.prisma.io/docs/orm/tools/prisma-studio#show-and-hide-records \"Direct link to Show and hide records\")\n\nYou can also select to show or skip a specific number of records in the model view.\n\ninfo\n\n**What is a record?**  \n\nA **record** refers to a **row of data in a table** in a relational database (PostgreSQL, MySQL, SQL Server, SQLite, CockroachDB) or a **document** in MongoDB.\n\n**Steps**\n\n1.  Click the **Showing** menu.\n2.  In the **Take** box, specify the maximum number of records that you want the model view to show.\n3.  In the **Skip** box, specify how many of the first records you want to hide. ![Prisma Studio - Show and hide records](https://www.prisma.io/docs/assets/images/07-show-hide-records-80641d3c28949c3f85eb9718f293598b.png)\n\n**Result**\n\nThe model is immediately filtered to show or hide records based on your selection.\n\nThe **Showing** menu indicates how many records are shown out of how many available records are in the model.\n\n## Sort data[​](https://www.prisma.io/docs/orm/tools/prisma-studio#sort-data \"Direct link to Sort data\")\n\nClick a field title to sort by the field data.\n\nThe first click sorts the data in ascending order, the second - in descending order.\n\n![Prisma Studio - Sort data](https://www.prisma.io/docs/assets/images/08-model-sort-87dfdc2d0d4d7aaa265c90f80f503298.png)\n\n## Troubleshooting[​](https://www.prisma.io/docs/orm/tools/prisma-studio#troubleshooting \"Direct link to Troubleshooting\")\n\n### Terminal: Failed to run script / Error in Prisma Client request[​](https://www.prisma.io/docs/orm/tools/prisma-studio#terminal-failed-to-run-script--error-in-prisma-client-request \"Direct link to Terminal: Failed to run script / Error in Prisma Client request\")\n\nCaching issues may cause Prisma Studio to use an older version of the query engine. You may see the following error:\n\n```\nError in request:  PrismaClientKnownRequestError: Failed to validate the query Error occurred during query validation & transformation\n```\n\nTo resolve, delete the following folders:\n\n*   `~/.cache/prisma` on macOS and Linux\n*   `%AppData%/Prisma/Studio` on Windows",
  "title": "Prisma Studio | Prisma Documentation",
  "description": "Prisma Studio is a visual database editor.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/tools/prisma-cli",
  "markdown": "# Prisma CLI | Prisma Documentation\n\nThe Prisma command line interface (CLI) is the primary way to interact with your Prisma project from the command line. It can initialize new project assets, generate Prisma Client, and analyze existing database structures through introspection to automatically create your application models.\n\n## Command reference[​](https://www.prisma.io/docs/orm/tools/prisma-cli#command-reference \"Direct link to Command reference\")\n\nSee [Prisma CLI command reference](https://www.prisma.io/docs/orm/reference/prisma-cli-reference) for a complete list of commands.\n\n## Installation[​](https://www.prisma.io/docs/orm/tools/prisma-cli#installation \"Direct link to Installation\")\n\nThe Prisma CLI is typically installed locally as a **development dependency**, that's why the `--save-dev` (npm) and `--dev` (Yarn) options are used in the commands below.\n\ninfo\n\nWe **recommend that you install the Prisma CLI locally** in your project's `package.json` to avoid version conflicts that can happen with a global installation.\n\n### npm[​](https://www.prisma.io/docs/orm/tools/prisma-cli#npm \"Direct link to npm\")\n\nInstall with [npm](https://www.npmjs.com/):\n\n```\nnpm install prisma --save-dev\n```\n\n### Yarn[​](https://www.prisma.io/docs/orm/tools/prisma-cli#yarn \"Direct link to Yarn\")\n\nInstall with [yarn](https://yarnpkg.com/):\n\n### pnpm[​](https://www.prisma.io/docs/orm/tools/prisma-cli#pnpm \"Direct link to pnpm\")\n\nInstall with [pnpm](https://pnpm.io/):\n\n```\npnpm install prisma --save-dev\n```\n\n### Bun[​](https://www.prisma.io/docs/orm/tools/prisma-cli#bun \"Direct link to Bun\")\n\nInstall with [Bun](https://bun.sh/):\n\nGlobal installation (Not recommended)\n\n*   **npm**\n\nInstall with npm:\n\n*   **Yarn**\n\nInstall with Yarn:\n\n*   **pnpm**\n\nInstall with pnpm:\n\n```\npnpm install prisma --global\n```\n\n*   **Bun**\n\nInstall with [Bun](https://bun.sh/):\n\n## Usage[​](https://www.prisma.io/docs/orm/tools/prisma-cli#usage \"Direct link to Usage\")\n\nIf you installed Prisma as a development dependency, you need to prefix the `prisma` command with your package runner.\n\n### npm[​](https://www.prisma.io/docs/orm/tools/prisma-cli#npm-1 \"Direct link to npm\")\n\n### Yarn[​](https://www.prisma.io/docs/orm/tools/prisma-cli#yarn-1 \"Direct link to Yarn\")\n\n### pnpm[​](https://www.prisma.io/docs/orm/tools/prisma-cli#pnpm-1 \"Direct link to pnpm\")\n\n### Bun[​](https://www.prisma.io/docs/orm/tools/prisma-cli#bun-1 \"Direct link to Bun\")\n\n## Synopsis[​](https://www.prisma.io/docs/orm/tools/prisma-cli#synopsis \"Direct link to Synopsis\")\n\nThe `prisma` command can be called from command line once installed. When called without arguments, it will display its command usage and help document:\n\nYou can get additional help on any of the `prisma` commands by adding the `--help` flag after the command.\n\n## Exit codes[​](https://www.prisma.io/docs/orm/tools/prisma-cli#exit-codes \"Direct link to Exit codes\")\n\nAll `prisma` CLI commands return the following codes when they exit:\n\n*   exit code 0 when a command runs successfully\n*   exit code 1 when a command errors\n*   exit code 130 when the CLI receives a signal interrupt (SIGINT) message or if the user cancels a prompt. This exit code is available in Prisma ORM versions 4.3.0 and later.\n\n## Telemetry[​](https://www.prisma.io/docs/orm/tools/prisma-cli#telemetry \"Direct link to Telemetry\")\n\nThe term **telemetry** refers to the collection of certain usage data to help _improve the quality of a piece of software_. Prisma uses telemetry in two contexts:\n\n*   when it collects CLI usage data\n*   when it submits CLI error reports\n\nThis page describes the overall telemetry approach for Prisma, what kind of data is collected and how to opt-out of data collection.\n\n### Why does Prisma collect metrics?[​](https://www.prisma.io/docs/orm/tools/prisma-cli#why-does-prisma-collect-metrics \"Direct link to Why does Prisma collect metrics?\")\n\nTelemetry helps us better understand _how many users_ are using our products and _how often_ they are using our products. Unlike many telemetry services, our telemetry implementation is intentionally limited in scope and is actually useful for the developer:\n\n*   **Limited in scope**: We use telemetry to answer one question: how many monthly active developers are using Prisma CLI?\n*   **Provides value**: Our telemetry service also checks for version updates and offers security notices.\n\n### When is data collected?[​](https://www.prisma.io/docs/orm/tools/prisma-cli#when-is-data-collected \"Direct link to When is data collected?\")\n\nData is collected in two scenarios that are described below.\n\n#### Usage data[​](https://www.prisma.io/docs/orm/tools/prisma-cli#usage-data \"Direct link to Usage data\")\n\nInvocations of the `prisma` CLI and general usage of Studio results in data being sent to the telemetry server at [https://checkpoint.prisma.io](https://checkpoint.prisma.io/). Note that:\n\n*   The data does **not** include your schema or the data in your database\n*   Prisma only sends information after you execute a CLI command\n\nHere is an overview of the data that's being submitted:\n\n| Field | Attributes | Description |\n| --- | --- | --- |\n| `product` | _string_ | Name of the product (e.g. `prisma`) |\n| `version` | _string_ | Currently installed version of the product (e.g. `1.0.0-rc0`) |\n| `arch` | _string_ | Client's operating system architecture (e.g. `amd64`). |\n| `os` | _string_ | Client's operating system (e.g. `darwin`). |\n| `node_version` | _string_ | Client's node version (e.g. `v12.12.0`). |\n| `signature` | _string_ | Random, non-identifiable signature UUID (e.g. `91b014df3-9dda-4a27-a8a7-15474fd899f8`) |\n| `user_agent` | _string_ | User agent of the checkpoint client (e.g. `prisma/js-checkpoint`) |\n| `timestamp` | _string_ | When the request was made in RFC3339 format (e.g. `2019-12-12T17:45:56Z`) |\n\nYou can opt-out of this behavior by setting the `CHECKPOINT_DISABLE` environment variable to `1`, e.g.:\n\n```\nexport CHECKPOINT_DISABLE=1\n```\n\n#### Error reporting[​](https://www.prisma.io/docs/orm/tools/prisma-cli#error-reporting \"Direct link to Error reporting\")\n\nPrisma potentially collects error data when there is a crash in the CLI.\n\nBefore an error report is submitted, there will _always_ be a prompt asking you to confirm or deny the submission of the error report! Error reports are never submitted without your explicit consent!\n\n### How to opt-out of data collection?[​](https://www.prisma.io/docs/orm/tools/prisma-cli#how-to-opt-out-of-data-collection \"Direct link to How to opt-out of data collection?\")\n\n#### Usage data[​](https://www.prisma.io/docs/orm/tools/prisma-cli#usage-data-1 \"Direct link to Usage data\")\n\nYou can opt-out of usage data collection by setting the `CHECKPOINT_DISABLE` environment variable to `1`, e.g.:\n\n```\nexport CHECKPOINT_DISABLE=1\n```\n\n#### Error reporting[​](https://www.prisma.io/docs/orm/tools/prisma-cli#error-reporting-1 \"Direct link to Error reporting\")\n\nYou can opt-out of data collection by responding to the interactive prompt with _no_.",
  "title": "Prisma CLI | Prisma Documentation",
  "description": "The Prisma command line interface (CLI) is the primary way to interact with your Prisma project from the command line.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client",
  "markdown": "# Prisma Client | Prisma Documentation\n\n[\n\n## Debugging & troubleshooting\n\n](https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting)",
  "title": "Prisma Client | Prisma Documentation",
  "description": "Prisma Client is an auto-generated, type-safe query builder generated based on the models and attributes of your Prisma schema.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-migrate",
  "markdown": "# Prisma Migrate | Database, Schema, SQL Migration Tool\n\n[\n\n## Understanding Prisma Migrate\n\n](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate)",
  "title": "Prisma Migrate | Database, Schema, SQL Migration Tool | Prisma Documentation",
  "description": "Prisma Migrate is a database migration tool available via the Prisma CLI that integrates with Prisma schema for data modeling.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/accelerate/api-reference",
  "markdown": "# Accelerate: API Reference | Prisma Documentation\n\nThe Accelerate API reference documentation is based on the following schema:\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  name  String?  email String  @unique}\n```\n\nAll example are based on the `User` model.\n\n## `cacheStrategy`[​](https://www.prisma.io/docs/accelerate/api-reference#cachestrategy \"Direct link to cachestrategy\")\n\nWith the Accelerate extension for Prisma Client, you can use the `cacheStrategy` parameter for model queries and use the [`ttl`](https://www.prisma.io/docs/accelerate/caching#time-to-live-ttl) and [`swr`](https://www.prisma.io/docs/accelerate/caching#stale-while-revalidate-swr) parameters to define a cache strategy for Accelerate. The Accelerate extension requires that you install Prisma Client version `4.10.0`.\n\n### Options[​](https://www.prisma.io/docs/accelerate/api-reference#options \"Direct link to Options\")\n\nThe `cacheStrategy` parameter takes an option with the following keys:\n\n| Option | Example | Type | Required | Description |\n| --- | --- | --- | --- | --- |\n| `swr` | `60` | `Int` | No  | The stale-while-revalidate time in seconds. |\n| `ttl` | `60` | `Int` | No  | The time-to-live time in seconds. |\n\n### Examples[​](https://www.prisma.io/docs/accelerate/api-reference#examples \"Direct link to Examples\")\n\nAdd a caching strategy to a query that defines a 60-second stale-while-revalidate value and 60-second time-to-live value:\n\n```\nawait prisma.user.findMany({  where: {    email: {      contains: 'alice@prisma.io',    },  },  cacheStrategy: { swr: 60, ttl: 60 },})\n```\n\n### Supported Prisma Client operations[​](https://www.prisma.io/docs/accelerate/api-reference#supported-prisma-client-operations \"Direct link to Supported Prisma Client operations\")\n\nThe following is a list of all read query operations and support `cacheStrategy`:\n\n*   [`findUnique()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findunique)\n*   [`findUniqueOrThrow()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#finduniqueorthrow)\n*   [`findFirst()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirst)\n*   [`findFirstOrThrow()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirstorthrow)\n*   [`findMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findmany)\n*   [`count()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#count)\n*   [`aggregate()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#aggregate)\n*   [`groupBy()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#groupby)\n\ninfo\n\nThe `cacheStrategy` parameter is not supported on any write operations, such as `create()`.\n\n## `withAccelerateInfo`[​](https://www.prisma.io/docs/accelerate/api-reference#withaccelerateinfo \"Direct link to withaccelerateinfo\")\n\nAny query that supports the `cacheStrategy` can append `withAccelerateInfo()` to wrap the response data and include additional information about the Accelerate response.\n\nTo retrieve the status of the response, use:\n\n```\nconst { data, info } = await prisma.user  .count({    cacheStrategy: { ttl: 60, swr: 600 },    where: { myField: 'value' },  })  .withAccelerateInfo()console.dir(info)\n```\n\ninfo\n\nNotice the `info` property of the response object. This is where the request information is stored.\n\n### Return type[​](https://www.prisma.io/docs/accelerate/api-reference#return-type \"Direct link to Return type\")\n\nThe `info` object is of type `AccelerateInfo` and follows the interface below:\n\n```\ninterface AccelerateInfo {  cacheStatus: 'ttl' | 'swr' | 'miss' | 'none'  lastModified: Date  region: string  requestId: string  signature: string}\n```\n\n| Property | Type | Description |\n| --- | --- | --- |\n| `cacheStatus` | `\"ttl\" \\| \"swr\" \\| \"miss\" \\| \"none\"` | The cache status of the response.  <br><br>*   `ttl` indicates a cache hit within the `ttl` duration and no database query was executed<br>*   `swr` indicates a cache hit within the `swr` duration and the data is being refreshed by Accelerate in the background<br>*   `miss` indicates that both `ttl` and `swr` have expired and the database query was executed by the request<br>*   `none` indicates that no cache strategy was specified and the database query was executed by the request |\n| `lastModified` | `Date` | The date the response was last refreshed. |\n| `region` | `String` | The data center region that received the request. |\n| `requestId` | `String` | Unique identifier of the request. Useful for troubleshooting. |\n| `signature` | `String` | The unique signature of the Prisma operation. |\n\n## Errors[​](https://www.prisma.io/docs/accelerate/api-reference#errors \"Direct link to Errors\")\n\nPrisma Accelerate-related errors start with `P6xxx`.\n\nYou can find the full error code reference for Prisma Accelerate [here](https://www.prisma.io/docs/orm/reference/error-reference#prisma-accelerate).",
  "title": "Accelerate: API Reference | Prisma Documentation",
  "description": "API reference documentation for Accelerate.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference/prisma-cli-reference",
  "markdown": "# Prisma CLI reference | Prisma Documentation\n\nThis document describes the Prisma CLI commands, arguments, and options.\n\n## Commands[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#commands \"Direct link to Commands\")\n\n### `version` (`-v`)[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#version--v \"Direct link to version--v\")\n\nThe `version` command outputs information about your current `prisma` version, platform, and engine binaries.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options \"Direct link to Options\")\n\nThe `version` command recognizes the following options to modify its behavior:\n\n| Option | Required | Description |\n| --- | --- | --- |\n| `--json` | No  | Outputs version information in JSON format. |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples \"Direct link to Examples\")\n\n##### Output version information[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#output-version-information \"Direct link to Output version information\")\n\n##### Output version information (`-v`)[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#output-version-information--v \"Direct link to output-version-information--v\")\n\n##### Output version information as JSON[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#output-version-information-as-json \"Direct link to Output version information as JSON\")\n\n### `init`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#init \"Direct link to init\")\n\nBootstraps a fresh Prisma ORM project within the current directory.\n\nThe `init` command does not interpret any existing files. Instead, it creates a `prisma` directory containing a bare-bones `schema.prisma` file within your current directory.\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--datasource-provider` | No  | Specifies the value for the `provider` field in the `datasource` block. Options are `sqlite`, `postgresql`, `mysql`, `sqlserver`, `mongodb` and `cockroachdb`. | `postgresql` |\n| `--url` | No  | Define a custom datasource url. |     |\n| `--generator-provider` | No  | Define the generator provider to use. | `prisma-client-js` |\n| `--preview-feature` | No  | Define the [Preview features](https://www.prisma.io/docs/orm/reference/preview-features) to use. To define multiple Preview features, you have to provide the flag multiple times for each Preview feature. [See example](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#run-prisma-init---preview-feature) |     |\n| `--output` | No  | Specifies the [output location for the generated client](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#using-a-custom-output-path). | `node_modules/.prisma/client` |\n| `--with-model` | No  | Adds a simple `User` model to the initial Prisma schema. Available since version `5.14.0`. |     |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-1 \"Direct link to Examples\")\n\n##### Run `prisma init`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#run-prisma-init \"Direct link to run-prisma-init\")\n\n##### Run `prisma init --datasource-provider sqlite`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#run-prisma-init---datasource-provider-sqlite \"Direct link to run-prisma-init---datasource-provider-sqlite\")\n\n```\nprisma init --datasource-provider sqlite\n```\n\nThe command output contains helpful information on how to use the generated files and begin using Prisma ORM with your project.\n\n#### Run `prisma init --preview-feature`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#run-prisma-init---preview-feature \"Direct link to run-prisma-init---preview-feature\")\n\n```\nprisma init --preview-feature multiSchema\n```\n\nShow\n\nPrisma schema\n\nresults\n\n```\nprisma init --preview-feature multiSchema --preview-feature metrics\n```\n\nShow\n\nPrisma schema\n\nresults\n\n#### Generated Assets[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#generated-assets \"Direct link to Generated Assets\")\n\n**`prisma/schema.prisma`**\n\nAn initial `schema.prisma` file to define your schema in:\n\n```\n// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemadatasource db {  provider = \"sqlite\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\n**`.env`**\n\nA file to define environment variables for your project:\n\n```\n# Environment variables declared in this file are automatically made available to Prisma.# See the documentation for more detail: https://pris.ly/d/prisma-schema#using-environment-variables# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.# See the documentation for all the connection string options: https://pris.ly/d/connection-stringsDATABASE_URL=\"file:./dev.db\"\n```\n\n##### Run `prisma init --url mysql://user:password@localhost:3306/mydb`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#run-prisma-init---url-mysqluserpasswordlocalhost3306mydb \"Direct link to run-prisma-init---url-mysqluserpasswordlocalhost3306mydb\")\n\n```\nprisma init --url mysql://user:password@localhost:3306/mydb\n```\n\nThe command output contains helpful information on how to use the generated files and begin using Prisma with your project.\n\n#### Generated Assets[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#generated-assets-1 \"Direct link to Generated Assets\")\n\n**`prisma/schema.prisma`**\n\nA minimal `schema.prisma` file to define your schema in:\n\n```\n// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemadatasource db {  provider = \"mysql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\n**`.env`**\n\nA file to define environment variables for your project:\n\n```\n# Environment variables declared in this file are automatically made available to Prisma.# See the documentation for more detail: https://pris.ly/d/prisma-schema#using-environment-variables# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.# See the documentation for all the connection string options: https://pris.ly/d/connection-stringsDATABASE_URL=\"mysql://user:password@localhost:3306/mydb\"\n```\n\n### `generate`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#generate \"Direct link to generate\")\n\nThe `generate` command generates assets like Prisma Client based on the [`generator`](https://www.prisma.io/docs/orm/prisma-schema/overview/generators) and [`data model`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) blocks defined in your `prisma/schema.prisma` file.\n\nThe `generate` command is most often used to generate Prisma Client with the `prisma-client-js` generator. This does three things:\n\n1.  Searches the current directory and parent directories to find the applicable `npm` project. It will create a `package.json` file in the current directory if it cannot find one.\n2.  Installs the `@prisma/client` into the `npm` project if it is not already present.\n3.  Inspects the current directory to find a Prisma Schema to process. It will then generate a customized [Prisma Client](https://github.com/prisma/prisma-client-js) for your project.\n\n#### Prerequisites[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#prerequisites \"Direct link to Prerequisites\")\n\nTo use the `generate` command, you must add a generator definition in your `schema.prisma` file. The `prisma-client-js` generator, used to generate Prisma Client, can be added by including the following in your `schema.prisma` file:\n\n```\ngenerator client {  provider = \"prisma-client-js\"}\n```\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-1 \"Direct link to Options\")\n\n| Option | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--data-proxy` | No  | The `generate` command will generate Prisma Client for use with [Prisma Accelerate](https://www.prisma.io/docs/accelerate) prior to Prisma 5.0.0. Mutually exclusive with `--accelerate` and `--no-engine`. |     |\n| `--accelerate` | No  | The `generate` command will generate Prisma Client for use with [Prisma Accelerate](https://www.prisma.io/docs/accelerate). Mutually exclusive with `--data-proxy` and `--no-engine`. Available in Prisma 5.1.0 and later. |     |\n| `--no-engine` | No  | The `generate` command will generate Prisma Client without an accompanied engine for use with [Prisma Accelerate](https://www.prisma.io/docs/accelerate). Mutually exclusive with `--data-proxy` and `--accelerate`. Available in Prisma ORM 5.2.0 and later. |     |\n| `--no-hints` | No  | The `generate` command will generate Prisma Client without usage hints being printed to the terminal. Available in Prisma ORM 5.16.0 and later. |     |\n| `--allow-no-models` | No  | The `generate` command will generate Prisma Client without generating any models. |     |\n| `--watch` | No  | The `generate` command will continue to watch the `schema.prisma` file and re-generate Prisma Client on file changes. |     |\n\nwarning\n\n**Deprecation Warning**\n\nAs of Prisma 5.2.0, `--data-proxy` and `--accelerate` are deprecated in favor of `--no-engine` as Prisma Client no longer requires an option to work with Prisma Accelerate. All options are available and work similarly, but we recommend `--no-engine` as it prevents an engine from being downloaded which will greatly impact the size of apps deployed to serverless and edge functions.\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-1 \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |     |\n| --- | --- | --- | --- | --- |\n| `--schema` | No  | Specifies the path to the desired `schema.prisma` file to be processed instead of the default path. Both absolute and relative paths are supported. | `./schema.prisma`, `./prisma/schema.prisma` |     |\n| `--generator` | No  | Specifies which generator to use to generate assets. This option may be provided multiple times to include multiple generators. By default, all generators in the target schema will be run. |     |     |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-2 \"Direct link to Examples\")\n\n##### Generate Prisma Client using the default `schema.prisma` path[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#generate-prisma-client-using-the-default-schemaprisma-path \"Direct link to generate-prisma-client-using-the-default-schemaprisma-path\")\n\n##### Generate Prisma Client using a non-default `schema.prisma` path[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#generate-prisma-client-using-a-non-default-schemaprisma-path \"Direct link to generate-prisma-client-using-a-non-default-schemaprisma-path\")\n\n```\nprisma generate --schema=./alternative/schema.prisma\n```\n\n##### Continue watching the `schema.prisma` file for changes to automatically re-generate Prisma Client[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#continue-watching-the-schemaprisma-file-for-changes-to-automatically-re-generate-prisma-client \"Direct link to continue-watching-the-schemaprisma-file-for-changes-to-automatically-re-generate-prisma-client\")\n\n##### Run the `generate` command with only a specific generator[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#run-the-generate-command-with-only-a-specific-generator \"Direct link to run-the-generate-command-with-only-a-specific-generator\")\n\n```\nprisma generate --generator client\n```\n\n##### Run the `generate` command with multiple specific generators[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#run-the-generate-command-with-multiple-specific-generators \"Direct link to run-the-generate-command-with-multiple-specific-generators\")\n\n```\nprisma generate --generator client --generator zod_schemas\n```\n\n#### Generated Assets[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#generated-assets-2 \"Direct link to Generated Assets\")\n\nThe `prisma-client-js` generator creates a customized client for working with your database within the `./node_modules/.prisma/client` directory by default - you can [customize the output folder](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#using-a-custom-output-path).\n\n### `introspect`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#introspect \"Direct link to introspect\")\n\nwarning\n\n**Deprecation warning**  \nFrom Prisma ORM 3.0.0 onwards, the `prisma introspect` command is deprecated and replaced with the [`prisma db pull`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-pull) command.\n\n### `validate`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#validate \"Direct link to validate\")\n\nValidates the [Prisma Schema Language](https://www.prisma.io/docs/orm/prisma-schema) of the Prisma schema file.\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-2 \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--schema` | No  | Specifies the path to the desired `schema.prisma` file to be processed instead of the default path. Both absolute and relative paths are supported. | `./schema.prisma`, `./prisma/schema.prisma` |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-3 \"Direct link to Examples\")\n\n##### Validate a schema without errors[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#validate-a-schema-without-errors \"Direct link to Validate a schema without errors\")\n\n##### Validate a schema with validation errors[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#validate-a-schema-with-validation-errors \"Direct link to Validate a schema with validation errors\")\n\n### `format`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#format \"Direct link to format\")\n\nFormats the Prisma schema file, which includes validating, formatting, and persisting the schema.\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-3 \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--schema` | No  | Specifies the path to the desired `schema.prisma` file to be processed instead of the default path. Both absolute and relative paths are supported. | `./schema.prisma`, `./prisma/schema.prisma` |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-4 \"Direct link to Examples\")\n\n##### Validate a schema without errors[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#validate-a-schema-without-errors-1 \"Direct link to Validate a schema without errors\")\n\n##### Formatting a schema with validation errors[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#formatting-a-schema-with-validation-errors \"Direct link to Formatting a schema with validation errors\")\n\n### `debug`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#debug \"Direct link to debug\")\n\nPrints information for debugging and bug reports.\n\ninfo\n\nThis is available from version 5.6.0 and newer.\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-4 \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--schema` | No  | Specifies the path to the desired `schema.prisma` file to be processed instead of the default path. Both absolute and relative paths are supported. | `./schema.prisma`, `./prisma/schema.prisma` |\n| `--help` / `--h` | No  | Displays the help message |     |\n\n#### Example[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#example \"Direct link to Example\")\n\nIf you're using an older version of Prisma, you can use this command by running:\n\n## `db`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db \"Direct link to db\")\n\n### `db pull`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-pull \"Direct link to db-pull\")\n\nThe `db pull` command connects to your database and adds Prisma models to your Prisma schema that reflect the current database schema.\n\nwarning\n\n**Warning**: The command will overwrite the current `schema.prisma` file with the new schema. Some manual changes or customization can be lost. Be sure to back up your current `schema.prisma` file (or commit your current state to version control to be able to revert any changes) before running `db pull` if it contains important modifications.\n\ninfo\n\nIntrospection with the `db pull` command on the [MongoDB connector](https://www.prisma.io/docs/orm/overview/databases/mongodb) samples the data instead of reading a schema.\n\n#### Prerequisites[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#prerequisites-1 \"Direct link to Prerequisites\")\n\nBefore using the `db pull` command, you must define a valid [`datasource`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) within your `schema.prisma` file.\n\nFor example, the following `datasource` defines a SQLite database file within the current directory:\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:my-database.db\"}\n```\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-2 \"Direct link to Options\")\n\n| Option | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--force` | No  | Force overwrite of manual changes made to schema. The generated schema will be based on the introspected schema only. |     |\n| `--print` | No  | Prints the created `schema.prisma` to the screen instead of writing it to the filesystem. |     |\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-5 \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--schema` | No  | Specifies the path to the desired `schema.prisma` file to be processed instead of the default path. Both absolute and relative paths are supported. | `./schema.prisma`, `./prisma/schema.prisma` |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-5 \"Direct link to Examples\")\n\n##### Analyze the database and write its schema to the `schema.prisma` file[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#analyze-the-database-and-write-its-schema-to-the-schemaprisma-file \"Direct link to analyze-the-database-and-write-its-schema-to-the-schemaprisma-file\")\n\n##### Specify an alternative `schema.prisma` file to read and write to[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#specify-an-alternative-schemaprisma-file-to-read-and-write-to \"Direct link to specify-an-alternative-schemaprisma-file-to-read-and-write-to\")\n\n```\nprisma db pull --schema=./alternative/schema.prisma\n```\n\n##### Display the generated `schema.prisma` file instead of writing it to the filesystem[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#display-the-generated-schemaprisma-file-instead-of-writing-it-to-the-filesystem \"Direct link to display-the-generated-schemaprisma-file-instead-of-writing-it-to-the-filesystem\")\n\n### `db push`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-push \"Direct link to db-push\")\n\nThe `db push` command pushes the state of your Prisma schema to the database without using migrations. It creates the database if the database does not exist.\n\nThis command is a good choice when you do not need to version schema changes, such as during prototyping and local development.\n\nSee also:\n\n*   [Conceptual overview of `db push` and when to use it over Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema)\n*   [Schema prototyping with `db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema)\n\n#### Prerequisites[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#prerequisites-2 \"Direct link to Prerequisites\")\n\nBefore using the `db push` command, you must define a valid [datasource](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) within your `schema.prisma` file.\n\nFor example, the following `datasource` defines a SQLite database file within the current directory:\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:my-database.db\"}\n```\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-3 \"Direct link to Options\")\n\n| Options | Required | Description |\n| --- | --- | --- |\n| `--skip-generate` | No  | Skip generation of artifacts such as Prisma Client |\n| `--force-reset` | No  | Resets the database and then updates the schema - useful if you need to start from scratch due to unexecutable migrations. |\n| `--accept-data-loss` | No  | Ignore data loss warnings. This option is required if as a result of making the schema changes, data may be lost. |\n| `--help` / `--h` | No  | Displays the help message |\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-6 \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--schema` | No  | Specifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported. | `./schema.prisma`  <br>`./prisma/schema.prisma` |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-6 \"Direct link to Examples\")\n\nPush the schema:\n\nPush the schema, accepting data loss:\n\n```\nprisma db push --accept-data-loss\n```\n\nPush the schema with a custom schema location:\n\n```\nprisma db push --schema=/tmp/schema.prisma\n```\n\n### `db seed`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-seed \"Direct link to db-seed\")\n\n`db seed` changed from Preview to Generally Available (GA) in 3.0.1.\n\nSee [Seeding your database](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding)\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-4 \"Direct link to Options\")\n\n| Options | Required | Description |\n| --- | --- | --- |\n| `--help` / `--h` | No  | Displays the help message |\n| `--` | No  | Allows the use of custom arguments defined in a seed file |\n\nThe `--` argument/ [delimiter](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02)/ double-dash is available from version 4.15.0 or later.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-7 \"Direct link to Examples\")\n\n### `db execute`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-execute \"Direct link to db-execute\")\n\ninfo\n\nThe `db execute` command is Generally Available in versions 3.13.0 and later. If you're using a version between 3.9.0 and 3.13.0, it is available behind a `--preview-feature` CLI flag.\n\nwarning\n\nThis command is currently not supported on [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb).\n\nThis command applies a SQL script to the database without interacting with the Prisma migrations table. The script takes two inputs:\n\n*   the SQL script, which can be provided either on standard input or in a file\n*   the data source, which can either be the URL of the data source or the path to your Prisma schema file\n\nThe output of the command is connector-specific, and is not meant for returning data, but only to report success or failure.\n\nSee also:\n\n*   [Migration troubleshooting in production](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#fixing-failed-migrations-with-migrate-diff-and-db-execute)\n\n#### Prerequisites[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#prerequisites-3 \"Direct link to Prerequisites\")\n\nBefore using the `db execute` command, if you do not use the `--url` option you must define a valid [`datasource`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) within your `schema.prisma` file.\n\nFor example, the following `datasource` defines a SQLite database file within the current directory:\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:my-database.db\"}\n```\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-5 \"Direct link to Options\")\n\nOne of the following data source inputs is required:\n\n| Options | Description |\n| --- | --- |\n| `--url` | URL of the data source to run the command on |\n| `--schema` | Path to a Prisma schema file, uses the URL in the `datasource` block |\n\nOne of the following script inputs is required:\n\n| Options | Description |\n| --- | --- |\n| `--stdin` | Use the terminal standard input as the script to be executed |\n| `--file` | Path to a file. The content will be sent as the script to be executed |\n\nOther options:\n\n| Options | Required | Description |\n| --- | --- | --- |\n| `--help` | No  | Displays the help message. |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-8 \"Direct link to Examples\")\n\n*   Take the content of a SQL file located at `./script.sql` and execute it on the database specified by the URL in the `datasource` block of your `schema.prisma` file:\n    \n    ```\n    prisma db execute --file ./script.sql --schema schema.prisma\n    ```\n    \n*   Take the SQL script from standard input and execute it on the database specified by the data source URL given in the `DATABASE_URL` environment variable:\n    \n    ```\n    echo 'TRUNCATE TABLE dev;' | prisma db execute --stdin --url=\"$DATABASE_URL\"\n    ```\n    \n\n## Prisma Migrate[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#prisma-migrate \"Direct link to Prisma Migrate\")\n\nPrisma Migrate changed from Preview to Generally Available (GA) in 2.19.0.\n\ninfo\n\n**Does not apply for MongoDB**  \nInstead of `migrate dev` and related commands, [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) is used for [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb).\n\n### `migrate dev`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-dev \"Direct link to migrate-dev\")\n\n**For use in development environments only, requires shadow database**\n\nThe `migrate dev` command:\n\n1.  Reruns the existing migration history in the [shadow database](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database) in order to detect schema drift (edited or deleted migration file, or a manual changes to the database schema)\n2.  Applies pending migrations to the shadow database (for example, new migrations created by colleagues)\n3.  Generates a new migration from any changes you made to the Prisma schema before running `migrate dev`\n4.  Applies all unapplied migrations to the development database and updates the `_prisma_migrations` table\n5.  Triggers the generation of artifacts (for example, Prisma Client)\n\nSee also:\n\n*   [Conceptual overview of Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate)\n*   [Developing with Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate)\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-6 \"Direct link to Options\")\n\n| Option | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--create-only` | No  | Creates a new migration based on the changes in the schema but does not apply that migration. Run `migrate dev` to apply migration. |     |\n| `--skip-seed` | No  | Skip triggering seed |     |\n| `--skip-generate` | No  | Skip triggering generators (for example, Prisma Client) |     |\n| `--name` / `-n` | No  | Name the migration (e.g. `prisma migrate dev --name added_job_title`) |     |\n| `--help` / `-h` | No  | Displays the help message |     |\n\ninfo\n\nIf a [schema drift](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#detecting-schema-drift) is detected while running `prisma migrate dev` using `--create-only`, you will be prompted to reset your database.\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-7 \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--name` | No  | The name of the migration. If no name is provided, the CLI will prompt you. |     |\n| `--schema` | No  | Specifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported. | `./schema.prisma`  <br>`./prisma/schema.prisma` |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-9 \"Direct link to Examples\")\n\nApply all migrations, then create and apply any new migrations:\n\nApply all migrations and create a new migration if there are schema changes, but do not apply it:\n\n```\nprisma migrate dev --create-only\n```\n\n### `migrate reset`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-reset \"Direct link to migrate-reset\")\n\n**For use in development environments only**\n\nThis command:\n\n1.  Drops the database/schema if possible, or performs a soft reset if the environment does not allow deleting databases/schemas\n2.  Creates a new database/schema with the same name if the database/schema was dropped\n3.  Applies all migrations\n4.  Runs seed scripts\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-7 \"Direct link to Options\")\n\n| Option | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--force` | No  | Skip the confirmation prompt |     |\n| `--skip-generate` | No  | Skip triggering generators (for example, Prisma Client) |     |\n| `--skip-seed` | No  | Skip triggering seed |     |\n| `--help` / `--h` | No  | Displays the help message |     |\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-8 \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--schema` | No  | Specifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported. | `./schema.prisma`  <br>`./prisma/schema.prisma` |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-10 \"Direct link to Examples\")\n\n### `migrate deploy`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-deploy \"Direct link to migrate-deploy\")\n\nThe `migrate deploy` command applies all pending migrations, and creates the database if it does not exist. Primarily used in non-development environments. This command:\n\n*   Does **not** look for drift in the database or changes in the Prisma schema\n*   Does **not** reset the database or generate artifacts\n*   Does **not** rely on a shadow database\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-8 \"Direct link to Options\")\n\n| Option | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--help` / `--h` | No  | Displays the help message |     |\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-9 \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--schema` | No  | Specifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported. | `./schema.prisma`  <br>`./prisma/schema.prisma` |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-11 \"Direct link to Examples\")\n\n### `migrate resolve`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-resolve \"Direct link to migrate-resolve\")\n\nThe `migrate resolve` command allows you to solve migration history issues in production by marking a failed migration as already applied (supports baselining) or rolled back.\n\nNote that this command can only be used with a failed migration. If you try to use it with a successful migration you will receive an error.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-9 \"Direct link to Options\")\n\n| Option | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--help` / `--h` | No  | Displays the help message |     |\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-10 \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--applied` | No\\* | Record a specific migration as applied - for example `--applied \"20201231000000_add_users_table\"` |     |\n| `--rolled-back` | No\\* | Record a specific migration as rolled back - for example `--rolled-back \"20201231000000_add_users_table\"` | `./schema.prisma`  <br>`./prisma/schema.prisma` |\n| `--schema` | No  | Specifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported. | `./schema.prisma`  <br>`./prisma/schema.prisma` |\n\nYou must specify either `--rolled-back` _or_ `--applied`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-12 \"Direct link to Examples\")\n\n```\nprisma migrate resolve --applied 20201231000000_add_users_table\n```\n\n```\nprisma migrate resolve --rolled-back 20201231000000_add_users_table\n```\n\n### `migrate status`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-status \"Direct link to migrate-status\")\n\nThe `prisma migrate status` command looks up the migrations in `./prisma/migrations/*` folder and the entries in the `_prisma_migrations` table and compiles information about the state of the migrations in your database.\n\nFor example:\n\n```\nStatus3 migrations found in prisma/migrationsYour local migration history and the migrations table from your database are different:The last common migration is: 20201127134938_new_migrationThe migration have not yet been applied:20201208100950_test_migrationThe migrations from the database are not found locally in prisma/migrations:20201208100950_new_migration\n```\n\nIn versions 4.3.0 and later, `prisma migrate status` exits with exit code 1 in the following cases:\n\n*   a database connection error occurs\n*   there are migration files in the `migrations` directory that have not been applied to the database\n*   the migration history in the `migrations` directory has diverged from the state of the database\n*   no migration table is found\n*   failed migrations are found\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-10 \"Direct link to Options\")\n\n| Option | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--help` / `--h` | No  | Displays the help message |     |\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-11 \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--schema` | No  | Specifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported. | `./schema.prisma`  <br>`./prisma/schema.prisma` |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-13 \"Direct link to Examples\")\n\n### `migrate diff`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff \"Direct link to migrate-diff\")\n\ninfo\n\nThe `migrate diff` command is Generally Available in versions 3.13.0 and later. If you're using a version between 3.9.0 and 3.13.0, it is available behind a `--preview-feature` CLI flag.\n\nwarning\n\nThis command is only partially supported for [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb). See the command options below for details.\n\nThis command compares two database schema sources and outputs a description of a migration taking the first to the state of the second.\n\nThe output can be given either as a human-readable summary (the default) or an executable script.\n\nwarning\n\nThe `migrate diff` command can only compare database features that are [supported by Prisma](https://www.prisma.io/docs/orm/reference/database-features). If two databases differ only in unsupported features, such as views or triggers, then `migrate diff` will not show any difference between them.\n\nThe format of the command is:\n\n```\nprisma migrate diff --from-... <source1> --to-... <source2>\n```\n\nwhere the `--from-...` and `--to-...` options are selected based on the type of database schema source. The supported types of sources are:\n\n*   live databases\n*   migration histories\n*   Prisma schema data models\n*   an empty schema\n\nBoth schema sources must use the same database provider. For example, a diff comparing a PostgreSQL data source with a SQLite data source is not supported.\n\nSee also:\n\n*   [Migration troubleshooting in production](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#fixing-failed-migrations-with-migrate-diff-and-db-execute)\n\n#### Prerequisites[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#prerequisites-4 \"Direct link to Prerequisites\")\n\nBefore using the `migrate diff` command, if you are using the `--from-schema-datasource` or `--to-schema-datasource` you must define a valid [`datasource`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) within your `schema.prisma` file.\n\nFor example, the following `datasource` defines a SQLite database file within the current directory:\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:my-database.db\"}\n```\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-11 \"Direct link to Options\")\n\nOne of the following `--from-...` options is required:\n\n| Options | Description | Notes |\n| --- | --- | --- |\n| `--from-url` | A data source URL |     |\n| `--from-migrations` | Path to the Prisma Migrate migrations directory | Not supported in MongoDB |\n| `--from-schema-datamodel` | Path to a Prisma schema file, uses the data model for the diff |     |\n| `--from-schema-datasource` | Path to a Prisma schema file, uses the URL in the `datasource` block for the diff |     |\n| `--from-empty` | Assume that you the data model you are migrating from is empty |     |\n| `--from-local-d1` | Path to a local D1 instance ([learn more](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#migration-workflows)) | Available since [5.12.0](https://github.com/prisma/prisma/releases/tag/5.12.0) |\n\nOne of the following `--to-...` options is required:\n\n| Options | Description | Notes |\n| --- | --- | --- |\n| `--to-url` | A data source URL |     |\n| `--to-migrations` | Path to the Prisma Migrate migrations directory | Not supported in MongoDB |\n| `--to-schema-datamodel` | Path to a Prisma schema file, uses the data model for the diff |     |\n| `--to-schema-datasource` | Path to a Prisma schema file, uses the URL in the `datasource` block for the diff |     |\n| `--to-empty` | Assume that you the data model you are migrating to is empty |     |\n| `--to-local-d1` | Path to a local D1 instance ([learn more](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#migration-workflows)) | Available since [5.12.0](https://github.com/prisma/prisma/releases/tag/5.12.0) |\n\nOther options:\n\n| Options | Required | Description | Notes |\n| --- | --- | --- | --- |\n| `--shadow-database-url` | No  | URL for the shadow database | Only required if using `--to-migrations` or `--from-migrations` |\n| `--script` | No  | Outputs a SQL script instead of the default human-readable summary | Not supported in MongoDB |\n| `-o`, `--output` | No  | Writes to a file instead of stdout | Available since [5.12.1](https://github.com/prisma/prisma/releases/tag/5.12.1) |\n| `--exit-code` | No  | Change the exit code behavior to signal if the diff is empty or not (Empty: 0, Error: 1, Not empty: 2). Default behavior is Success: 0, Error: 1. |     |\n| `--help` | No  | Displays the help message. |     |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-14 \"Direct link to Examples\")\n\n*   Compare two databases specified by their data source URL, and output the default human-readable summary:\n    \n    ```\n    prisma migrate diff \\  --from-url \"$DATABASE_URL\" \\  --to-url \"postgresql://login:password@localhost:5432/db2\"\n    ```\n    \n*   Compare the state of a database with a URL of `$DATABASE_URL` to the schema defined by the migrations in the `./prisma/migrations` directory, and output the differences to a script `script.sql`:\n    \n    ```\n    prisma migrate diff \\ --from-url \"$DATABASE_URL\" \\ --to-migrations ./prisma/migrations \\ --shadow-database-url $SHADOW_DATABASE_URL \\ --script > script.sql\n    ```\n    \n\n## Prisma Data Platform[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#prisma-data-platform \"Direct link to Prisma Data Platform\")\n\n### `platform` ([Early Access](https://www.prisma.io/docs/platform/maturity-levels#early-access))[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#platform-early-access \"Direct link to platform-early-access\")\n\nThe `platform` command provides access to the Prisma Data Platform through the Prisma CLI starting in version `5.10.0` or later.\n\n*   **Authentication**:\n    \n    *   `platform auth login`: Opens a browser window for login or account creation.\n    *   `platform auth logout`: Logs out of the platform.\n    *   `platform auth show`: Displays information about the currently authenticated user.\n*   **Workspace Management**:\n    \n    *   `platform workspace show`: Lists all workspaces available to your account.\n*   **Project Management**:\n    \n    *   `platform project show`: Lists all projects within the specified workspace.\n    *   `platform project create`: Creates a new project within the specified workspace.\n    *   `platform project delete`: Deletes the specified project.\n*   **Environment Management**:\n    \n    *   `platform environment show`: Lists all environments for the specified project.\n    *   `platform environment create`: Creates a new environment within the specified project.\n    *   `platform environment delete`: Deletes the specified environment.\n*   **API Key Management**:\n    \n    *   `platform apikey show`: Lists all API keys for the specified environment.\n    *   `platform apikey create`: Creates a new API key for the specified environment.\n    *   `platform apikey delete`: Deletes the specified API key.\n*   **Prisma Accelerate**:\n    \n    *   `platform accelerate enable`: Enables Prisma Accelerate for the specified environment.\n    *   `platform accelerate disable`: Disables Prisma Accelerate for the specified environment.\n*   **Prisma Pulse**:\n    \n    *   `platform pulse enable`: Enables Prisma Pulse for the specified environment.\n    *   `platform pulse disable`: Disables Prisma Pulse for the specified environment.\n\nYou can find the complete list of available commands with the arguments [here](https://www.prisma.io/docs/platform/platform-cli/commands).\n\n## Studio[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#studio \"Direct link to Studio\")\n\n### `studio`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#studio-1 \"Direct link to studio-1\")\n\nThe `studio` command allows you to interact with and manage your data interactively. It does this by starting a local web server with a web app configured with your project's data schema and records.\n\n#### Prerequisites[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#prerequisites-5 \"Direct link to Prerequisites\")\n\nBefore using the `studio` command, you must define a valid [`datasource`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) within your `schema.prisma` file.\n\nFor example, the following `datasource` defines a SQLite database file within the current directory:\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:my-database.db\"}\n```\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-12 \"Direct link to Options\")\n\nThe `studio` command recognizes the following options:\n\n| Option | Required | Description | Default |\n| --- | --- | --- | --- |\n| `-b`, `--browser` | No  | The browser to auto-open Studio in. | `<your-default-browser>` |\n| `-h`, `--help` | No  | Show all available options and exit |     |\n| `-p`, `--port` | No  | The port number to start Studio on. | 5555 |\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-12 \"Direct link to Arguments\")\n\n| Argument | Required | Description | Default |\n| --- | --- | --- | --- |\n| `--schema` | No  | Specifies the path to the desired schema.prisma file to be processed instead of the default path. Both absolute and relative paths are supported. | `./schema.prisma`  <br>`./prisma/schema.prisma` |\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#examples-15 \"Direct link to Examples\")\n\n#### Start Studio on the default port and open a new browser tab to it[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#start-studio-on-the-default-port-and-open-a-new-browser-tab-to-it \"Direct link to Start Studio on the default port and open a new browser tab to it\")\n\n#### Start Studio on a different port and open a new browser tab to it[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#start-studio-on-a-different-port-and-open-a-new-browser-tab-to-it \"Direct link to Start Studio on a different port and open a new browser tab to it\")\n\n```\nprisma studio --port 7777\n```\n\n#### Start Studio and open a Firefox tab to it[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#start-studio-and-open-a-firefox-tab-to-it \"Direct link to Start Studio and open a Firefox tab to it\")\n\n```\nprisma studio --browser firefox\n```\n\n#### Start Studio without opening a new browser tab to it[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#start-studio-without-opening-a-new-browser-tab-to-it \"Direct link to Start Studio without opening a new browser tab to it\")\n\n```\nprisma studio --browser none\n```\n\n## `package.json` entry options[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#packagejson-entry-options \"Direct link to packagejson-entry-options\")\n\n### `schema`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#schema \"Direct link to schema\")\n\nThe path to the desired `schema.prisma` file can be specified with the `prisma.schema` entry in the `package.json` file. The path defines the file the Prisma CLI should use when you run any of the CLI commands. Both absolute and relative paths are supported.\n\n\"package.json\"\n\n```\n{  \"name\": \"my-project\",  \"version\": \"1.0.0\",  \"prisma\": {    \"schema\": \"./custom-path-to-schema/schema.prisma\"  }}\n```\n\nThis is available from version 2.7.0 and later.\n\n### `seed`[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#seed \"Direct link to seed\")\n\nThe command used to populate the datasource is specified in the `prisma.seed` entry in the `package.json` file. It is used when `prisma db seed` is invoked or triggered.\n\nSee [Seeding your database](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding)\n\n\"package.json\"\n\n```\n{  \"name\": \"my-project\",  \"version\": \"1.0.0\",  \"prisma\": {    \"seed\": \"node ./prisma/seed.js\"  }}\n```\n\nThis is available from version 3.0.1 and later.\n\n## Using a HTTP proxy for the CLI[​](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#using-a-http-proxy-for-the-cli \"Direct link to Using a HTTP proxy for the CLI\")\n\nPrisma CLI supports [custom HTTP proxies](https://github.com/prisma/prisma/issues/506). This is particularly relevant when being behind a corporate firewall.\n\nTo activate usage of the proxy, provide either of the following environment variables:\n\n*   [`HTTP_PROXY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#http_proxy) or `http_proxy`: Proxy URL for http traffic, for example `http://localhost:8080`\n*   [`HTTPS_PROXY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#https_proxy) or `https_proxy`: Proxy URL for https traffic, for example `https://localhost:8080`",
  "title": "Prisma CLI reference | Prisma Documentation",
  "description": "This page gives an overview of all available Prisma CLI commands, explains their options and shows numerous usage examples.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference/error-reference",
  "markdown": "# Errors | Prisma Documentation\n\n## Error message reference\n\nFor more information about how to work with exceptions and error codes, see [Handling exceptions and errors](https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/handling-exceptions-and-errors).\n\n## Prisma Client error types[​](https://www.prisma.io/docs/orm/reference/error-reference#prisma-client-error-types \"Direct link to Prisma Client error types\")\n\nPrisma Client throws different kinds of errors. The following lists the exception types, and their documented data fields:\n\n### `PrismaClientKnownRequestError`[​](https://www.prisma.io/docs/orm/reference/error-reference#prismaclientknownrequesterror \"Direct link to prismaclientknownrequesterror\")\n\nPrisma Client throws a `PrismaClientKnownRequestError` exception if the query engine returns a known error related to the request - for example, a unique constraint violation.\n\n| **Property** | **Description** |\n| --- | --- |\n| `code` | A Prisma-specific [error code](https://www.prisma.io/docs/orm/reference/error-reference#error-codes). |\n| `meta` | Additional information about the error - for example, the field that caused the error: `{ target: [ 'email' ] }` |\n| `message` | Error message associated with [error code](https://www.prisma.io/docs/orm/reference/error-reference#error-codes). |\n| `clientVersion` | Version of Prisma Client (for example, `2.19.0`) |\n\n### `PrismaClientUnknownRequestError`[​](https://www.prisma.io/docs/orm/reference/error-reference#prismaclientunknownrequesterror \"Direct link to prismaclientunknownrequesterror\")\n\nPrisma Client throws a `PrismaClientUnknownRequestError` exception if the query engine returns an error related to a request that does not have an error code.\n\n| **Property** | **Description** |\n| --- | --- |\n| `message` | Error message associated with [error code](https://www.prisma.io/docs/orm/reference/error-reference#error-codes). |\n| `clientVersion` | Version of Prisma Client (for example, `2.19.0`) |\n\n### `PrismaClientRustPanicError`[​](https://www.prisma.io/docs/orm/reference/error-reference#prismaclientrustpanicerror \"Direct link to prismaclientrustpanicerror\")\n\nPrisma Client throws a `PrismaClientRustPanicError` exception if the underlying engine crashes and exits with a non-zero exit code. In this case, Prisma Client or the whole Node process must be restarted.\n\n| **Property** | **Description** |\n| --- | --- |\n| `message` | Error message associated with [error code](https://www.prisma.io/docs/orm/reference/error-reference#error-codes). |\n| `clientVersion` | Version of Prisma Client (for example, `2.19.0`) |\n\n### `PrismaClientInitializationError`[​](https://www.prisma.io/docs/orm/reference/error-reference#prismaclientinitializationerror \"Direct link to prismaclientinitializationerror\")\n\nPrisma Client throws a `PrismaClientInitializationError` exception if something goes wrong when the query engine is started and the connection to the database is created. This happens either:\n\n*   When `prisma.$connect()` is called OR\n*   When the first query is executed\n\nErrors that can occur include:\n\n*   The provided credentials for the database are invalid\n*   There is no database server running under the provided hostname and port\n*   The port that the query engine HTTP server wants to bind to is already taken\n*   A missing or inaccessible environment variable\n*   The query engine binary for the current platform could not be found (`generator` block)\n\n| **Property** | **Description** |\n| --- | --- |\n| `errorCode` | A Prisma-specific error code. |\n| `message` | Error message associated with [error code](https://www.prisma.io/docs/orm/reference/error-reference#error-codes). |\n| `clientVersion` | Version of Prisma Client (for example, `2.19.0`) |\n\n### `PrismaClientValidationError`[​](https://www.prisma.io/docs/orm/reference/error-reference#prismaclientvalidationerror \"Direct link to prismaclientvalidationerror\")\n\nPrisma Client throws a `PrismaClientValidationError` exception if validation fails - for example:\n\n*   Missing field - for example, an empty `data: {}` property when creating a new record\n*   Incorrect field type provided (for example, setting a `Boolean` field to `\"Hello, I like cheese and gold!\"`)\n\n| **Property** | **Description** |\n| --- | --- |\n| `message` | Error message. |\n| `clientVersion` | Version of Prisma Client (for example, `2.19.0`) |\n\n## Error codes[​](https://www.prisma.io/docs/orm/reference/error-reference#error-codes \"Direct link to Error codes\")\n\n### Common[​](https://www.prisma.io/docs/orm/reference/error-reference#common \"Direct link to Common\")\n\n#### `P1000`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1000 \"Direct link to p1000\")\n\n\"Authentication failed against database server at `{database_host}`, the provided database credentials for `{database_user}` are not valid. Please make sure to provide valid database credentials for the database server at `{database_host}`.\"\n\n#### `P1001`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1001 \"Direct link to p1001\")\n\n\"Can't reach database server at `{database_host}`:`{database_port}` Please make sure your database server is running at `{database_host}`:`{database_port}`.\"\n\n#### `P1002`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1002 \"Direct link to p1002\")\n\n\"The database server at `{database_host}`:`{database_port}` was reached but timed out. Please try again. Please make sure your database server is running at `{database_host}`:`{database_port}`. \"\n\n#### `P1003`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1003 \"Direct link to p1003\")\n\n\"Database {database\\_file\\_name} does not exist at {database\\_file\\_path}\"\n\n\"Database `{database_name}.{database_schema_name}` does not exist on the database server at `{database_host}:{database_port}`.\"\n\n\"Database `{database_name}` does not exist on the database server at `{database_host}:{database_port}`.\"\n\n#### `P1008`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1008 \"Direct link to p1008\")\n\n\"Operations timed out after `{time}`\"\n\n#### `P1009`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1009 \"Direct link to p1009\")\n\n\"Database `{database_name}` already exists on the database server at `{database_host}:{database_port}`\"\n\n#### `P1010`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1010 \"Direct link to p1010\")\n\n\"User `{database_user}` was denied access on the database `{database_name}`\"\n\n#### `P1011`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1011 \"Direct link to p1011\")\n\n\"Error opening a TLS connection: {message}\"\n\n#### `P1012`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1012 \"Direct link to p1012\")\n\n**Note:** If you get error code P1012 after you upgrade Prisma ORM to version 4.0.0 or later, see the [version 4.0.0 upgrade guide](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-your-prisma-schema). A schema that was valid before version 4.0.0 might be invalid in version 4.0.0 and later. The upgrade guide explains how to update your schema to make it valid.\n\n\"{full\\_error}\"\n\nPossible P1012 error messages:\n\n*   \"Argument `{}` is missing.\"\n*   \"Function `{}` takes arguments, but received .\"\n*   \"Argument `{}` is missing in attribute `@{}`.\"\n*   \"Argument `{}` is missing in data source block `{}`.\"\n*   \"Argument `{}` is missing in generator block `{}`.\"\n*   \"Error parsing attribute `@{}`: \"\n*   \"Attribute `@{}` is defined twice.\"\n*   \"The model with database name `{}` could not be defined because another model with this name exists: `{}`\"\n*   \"`{}` is a reserved scalar type name and can not be used.\"\n*   \"The `{}` cannot be defined because a with that name already exists.\"\n*   \"Key `{}` is already defined in .\"\n*   \"Argument `{}` is already specified as unnamed argument.\"\n*   \"Argument `{}` is already specified.\"\n*   \"No such argument.\"\"\n*   \"Field `{}` is already defined on model `{}`.\"\n*   \"Field `{}` in model `{}` can't be a list. The current connector does not support lists of primitive types.\"\n*   \"The index name `{}` is declared multiple times. With the current connector index names have to be globally unique.\"\n*   \"Value `{}` is already defined on enum `{}`.\"\n*   \"Attribute not known: `@{}`.\"\n*   \"Function not known: `{}`.\"\n*   \"Datasource provider not known: `{}`.\"\n*   \"shadowDatabaseUrl is the same as url for datasource `{}`. Please specify a different database as shadow database.\"\n*   \"The preview feature `{}` is not known. Expected one of: \"\n*   \"`{}` is not a valid value for .\"\n*   \"Type `{}` is neither a built-in type, nor refers to another model, custom type, or enum.\"\n*   \"Type `{}` is not a built-in type.\"\n*   \"Unexpected token. Expected one of: \"\n*   \"Environment variable not found: .\"\n*   \"Expected a value, but received value `{}`.\"\n*   \"Expected a value, but failed while parsing `{}`: .\"\n*   \"Error validating model `{}`: \"\n*   \"Error validating field `{}` in model `{}`: \"\n*   \"Error validating datasource `{datasource}`: {message}\"\n*   \"Error validating enum `{}`: \"\n*   \"Error validating: \"\n\n#### `P1013`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1013 \"Direct link to p1013\")\n\n\"The provided database string is invalid. {details}\"\n\n#### `P1014`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1014 \"Direct link to p1014\")\n\n\"The underlying {kind} for model `{model}` does not exist.\"\n\n#### `P1015`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1015 \"Direct link to p1015\")\n\n\"Your Prisma schema is using features that are not supported for the version of the database.  \nDatabase version: {database\\_version}  \nErrors:  \n{errors}\"\n\n#### `P1016`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1016 \"Direct link to p1016\")\n\n\"Your raw query had an incorrect number of parameters. Expected: `{expected}`, actual: `{actual}`.\"\n\n#### `P1017`[​](https://www.prisma.io/docs/orm/reference/error-reference#p1017 \"Direct link to p1017\")\n\n\"Server has closed the connection.\"\n\n### Prisma Client (Query Engine)[​](https://www.prisma.io/docs/orm/reference/error-reference#prisma-client-query-engine \"Direct link to Prisma Client (Query Engine)\")\n\n#### `P2000`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2000 \"Direct link to p2000\")\n\n\"The provided value for the column is too long for the column's type. Column: {column\\_name}\"\n\n#### `P2001`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2001 \"Direct link to p2001\")\n\n\"The record searched for in the where condition (`{model_name}.{argument_name} = {argument_value}`) does not exist\"\n\n#### `P2002`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2002 \"Direct link to p2002\")\n\n\"Unique constraint failed on the {constraint}\"\n\n#### `P2003`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2003 \"Direct link to p2003\")\n\n\"Foreign key constraint failed on the field: `{field_name}`\"\n\n#### `P2004`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2004 \"Direct link to p2004\")\n\n\"A constraint failed on the database: `{database_error}`\"\n\n#### `P2005`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2005 \"Direct link to p2005\")\n\n\"The value `{field_value}` stored in the database for the field `{field_name}` is invalid for the field's type\"\n\n#### `P2006`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2006 \"Direct link to p2006\")\n\n\"The provided value `{field_value}` for `{model_name}` field `{field_name}` is not valid\"\n\n#### `P2007`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2007 \"Direct link to p2007\")\n\n\"Data validation error `{database_error}`\"\n\n#### `P2008`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2008 \"Direct link to p2008\")\n\n\"Failed to parse the query `{query_parsing_error}` at `{query_position}`\"\n\n#### `P2009`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2009 \"Direct link to p2009\")\n\n\"Failed to validate the query: `{query_validation_error}` at `{query_position}`\"\n\n#### `P2010`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2010 \"Direct link to p2010\")\n\n\"Raw query failed. Code: `{code}`. Message: `{message}`\"\n\n#### `P2011`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2011 \"Direct link to p2011\")\n\n\"Null constraint violation on the {constraint}\"\n\n#### `P2012`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2012 \"Direct link to p2012\")\n\n\"Missing a required value at `{path}`\"\n\n#### `P2013`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2013 \"Direct link to p2013\")\n\n\"Missing the required argument `{argument_name}` for field `{field_name}` on `{object_name}`.\"\n\n#### `P2014`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2014 \"Direct link to p2014\")\n\n\"The change you are trying to make would violate the required relation '{relation\\_name}' between the `{model_a_name}` and `{model_b_name}` models.\"\n\n#### `P2015`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2015 \"Direct link to p2015\")\n\n\"A related record could not be found. {details}\"\n\n#### `P2016`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2016 \"Direct link to p2016\")\n\n\"Query interpretation error. {details}\"\n\n#### `P2017`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2017 \"Direct link to p2017\")\n\n\"The records for relation `{relation_name}` between the `{parent_name}` and `{child_name}` models are not connected.\"\n\n#### `P2018`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2018 \"Direct link to p2018\")\n\n\"The required connected records were not found. {details}\"\n\n#### `P2019`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2019 \"Direct link to p2019\")\n\n\"Input error. {details}\"\n\n#### `P2020`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2020 \"Direct link to p2020\")\n\n\"Value out of range for the type. {details}\"\n\n#### `P2021`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2021 \"Direct link to p2021\")\n\n\"The table `{table}` does not exist in the current database.\"\n\n#### `P2022`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2022 \"Direct link to p2022\")\n\n\"The column `{column}` does not exist in the current database.\"\n\n#### `P2023`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2023 \"Direct link to p2023\")\n\n\"Inconsistent column data: {message}\"\n\n#### `P2024`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2024 \"Direct link to p2024\")\n\n\"Timed out fetching a new connection from the connection pool. (More info: [http://pris.ly/d/connection-pool](http://pris.ly/d/connection-pool) (Current connection pool timeout: {timeout}, connection limit: {connection\\_limit})\"\n\n#### `P2025`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2025 \"Direct link to p2025\")\n\n\"An operation failed because it depends on one or more records that were required but not found. {cause}\"\n\n#### `P2026`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2026 \"Direct link to p2026\")\n\n\"The current database provider doesn't support a feature that the query used: {feature}\"\n\n#### `P2027`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2027 \"Direct link to p2027\")\n\n\"Multiple errors occurred on the database during query execution: {errors}\"\n\n#### `P2028`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2028 \"Direct link to p2028\")\n\n\"Transaction API error: {error}\"\n\n#### `P2029`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2029 \"Direct link to p2029\")\n\n\"Query parameter limit exceeded error: {message}\"\n\n#### `P2030`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2030 \"Direct link to p2030\")\n\n\"Cannot find a fulltext index to use for the search, try adding a @@fulltext(\\[Fields...\\]) to your schema\"\n\n#### `P2031`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2031 \"Direct link to p2031\")\n\n\"Prisma needs to perform transactions, which requires your MongoDB server to be run as a replica set. See details: [https://pris.ly/d/mongodb-replica-set](https://pris.ly/d/mongodb-replica-set)\"\n\n#### `P2033`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2033 \"Direct link to p2033\")\n\n\"A number used in the query does not fit into a 64 bit signed integer. Consider using `BigInt` as field type if you're trying to store large integers\"\n\n#### `P2034`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2034 \"Direct link to p2034\")\n\n\"Transaction failed due to a write conflict or a deadlock. Please retry your transaction\"\n\n#### `P2035`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2035 \"Direct link to p2035\")\n\n\"Assertion violation on the database: {database\\_error}\"\n\n#### `P2036`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2036 \"Direct link to p2036\")\n\n\"Error in external connector (id {id})\"\n\n#### `P2037`[​](https://www.prisma.io/docs/orm/reference/error-reference#p2037 \"Direct link to p2037\")\n\n\"Too many database connections opened: {message}\"\n\n### Prisma Migrate (Schema Engine)[​](https://www.prisma.io/docs/orm/reference/error-reference#prisma-migrate-schema-engine \"Direct link to Prisma Migrate (Schema Engine)\")\n\nwarning\n\nThe Schema Engine was previously called Migration Engine. This change was introduced in version [5.0.0](https://github.com/prisma/prisma/releases/tag/5.0.0).\n\n#### `P3000`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3000 \"Direct link to p3000\")\n\n\"Failed to create database: {database\\_error}\"\n\n#### `P3001`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3001 \"Direct link to p3001\")\n\n\"Migration possible with destructive changes and possible data loss: {migration\\_engine\\_destructive\\_details}\"\n\n#### `P3002`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3002 \"Direct link to p3002\")\n\n\"The attempted migration was rolled back: {database\\_error}\"\n\n#### `P3003`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3003 \"Direct link to p3003\")\n\n\"The format of migrations changed, the saved migrations are no longer valid. To solve this problem, please follow the steps at: [https://pris.ly/d/migrate](https://pris.ly/d/migrate)\"\n\n#### `P3004`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3004 \"Direct link to p3004\")\n\n\"The `{database_name}` database is a system database, it should not be altered with prisma migrate. Please connect to another database.\"\n\n#### `P3005`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3005 \"Direct link to p3005\")\n\n\"The database schema is not empty. Read more about how to baseline an existing production database: [https://pris.ly/d/migrate-baseline](https://pris.ly/d/migrate-baseline)\"\n\n#### `P3006`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3006 \"Direct link to p3006\")\n\n\"Migration `{migration_name}` failed to apply cleanly to the shadow database.  \n{error\\_code}Error:  \n{inner\\_error}\"\n\n#### `P3007`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3007 \"Direct link to p3007\")\n\n\"Some of the requested preview features are not yet allowed in schema engine. Please remove them from your data model before using migrations. (blocked: {list\\_of\\_blocked\\_features})\"\n\n#### `P3008`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3008 \"Direct link to p3008\")\n\n\"The migration `{migration_name}` is already recorded as applied in the database.\"\n\n#### `P3009`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3009 \"Direct link to p3009\")\n\n\"migrate found failed migrations in the target database, new migrations will not be applied. Read more about how to resolve migration issues in a production database: [https://pris.ly/d/migrate-resolve](https://pris.ly/d/migrate-resolve)  \n{details}\"\n\n#### `P3010`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3010 \"Direct link to p3010\")\n\n\"The name of the migration is too long. It must not be longer than 200 characters (bytes).\"\n\n#### `P3011`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3011 \"Direct link to p3011\")\n\n\"Migration `{migration_name}` cannot be rolled back because it was never applied to the database. Hint: did you pass in the whole migration name? (example: \"20201207184859\\_initial\\_migration\")\"\n\n#### `P3012`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3012 \"Direct link to p3012\")\n\n\"Migration `{migration_name}` cannot be rolled back because it is not in a failed state.\"\n\n#### `P3013`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3013 \"Direct link to p3013\")\n\n\"Datasource provider arrays are no longer supported in migrate. Please change your datasource to use a single provider. Read more at [https://pris.ly/multi-provider-deprecation](https://pris.ly/multi-provider-deprecation)\"\n\n#### `P3014`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3014 \"Direct link to p3014\")\n\n\"Prisma Migrate could not create the shadow database. Please make sure the database user has permission to create databases. Read more about the shadow database (and workarounds) at [https://pris.ly/d/migrate-shadow](https://pris.ly/d/migrate-shadow).\n\nOriginal error: {error\\_code}  \n{inner\\_error}\"\n\n#### `P3015`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3015 \"Direct link to p3015\")\n\n\"Could not find the migration file at {migration\\_file\\_path}. Please delete the directory or restore the migration file.\"\n\n#### `P3016`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3016 \"Direct link to p3016\")\n\n\"The fallback method for database resets failed, meaning Migrate could not clean up the database entirely. Original error: {error\\_code}  \n{inner\\_error}\"\n\n#### `P3017`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3017 \"Direct link to p3017\")\n\n\"The migration {migration\\_name} could not be found. Please make sure that the migration exists, and that you included the whole name of the directory. (example: \"20201207184859\\_initial\\_migration\")\"\n\n#### `P3018`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3018 \"Direct link to p3018\")\n\n\"A migration failed to apply. New migrations cannot be applied before the error is recovered from. Read more about how to resolve migration issues in a production database: [https://pris.ly/d/migrate-resolve](https://pris.ly/d/migrate-resolve)\n\nMigration name: {migration\\_name}\n\nDatabase error code: {database\\_error\\_code}\n\nDatabase error:  \n{database\\_error} \"\n\n#### `P3019`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3019 \"Direct link to p3019\")\n\n\"The datasource provider `{provider}` specified in your schema does not match the one specified in the migration\\_lock.toml, `{expected_provider}`. Please remove your current migration directory and start a new migration history with prisma migrate dev. Read more: [https://pris.ly/d/migrate-provider-switch](https://pris.ly/d/migrate-provider-switch)\"\n\n#### `P3020`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3020 \"Direct link to p3020\")\n\n\"The automatic creation of shadow databases is disabled on Azure SQL. Please set up a shadow database using the `shadowDatabaseUrl` datasource attribute.  \nRead the docs page for more details: [https://pris.ly/d/migrate-shadow](https://pris.ly/d/migrate-shadow)\"\n\n#### `P3021`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3021 \"Direct link to p3021\")\n\n\"Foreign keys cannot be created on this database. Learn more how to handle this: [https://pris.ly/d/migrate-no-foreign-keys](https://pris.ly/d/migrate-no-foreign-keys)\"\n\n#### `P3022`[​](https://www.prisma.io/docs/orm/reference/error-reference#p3022 \"Direct link to p3022\")\n\n\"Direct execution of DDL (Data Definition Language) SQL statements is disabled on this database. Please read more here about how to handle this: [https://pris.ly/d/migrate-no-direct-ddl](https://pris.ly/d/migrate-no-direct-ddl)\"\n\n### `prisma db pull`[​](https://www.prisma.io/docs/orm/reference/error-reference#prisma-db-pull \"Direct link to prisma-db-pull\")\n\n#### `P4000`[​](https://www.prisma.io/docs/orm/reference/error-reference#p4000 \"Direct link to p4000\")\n\n\"Introspection operation failed to produce a schema file: {introspection\\_error}\"\n\n#### `P4001`[​](https://www.prisma.io/docs/orm/reference/error-reference#p4001 \"Direct link to p4001\")\n\n\"The introspected database was empty.\"\n\n#### `P4002`[​](https://www.prisma.io/docs/orm/reference/error-reference#p4002 \"Direct link to p4002\")\n\n\"The schema of the introspected database was inconsistent: {explanation}\"\n\n### Prisma Accelerate[​](https://www.prisma.io/docs/orm/reference/error-reference#prisma-accelerate \"Direct link to Prisma Accelerate\")\n\nPrisma Accelerate-related errors start with `P6xxx`.\n\n#### `P6000` (`ServerError`)[​](https://www.prisma.io/docs/orm/reference/error-reference#p6000-servererror \"Direct link to p6000-servererror\")\n\nGeneric error to catch all other errors.\n\n#### `P6001` (`InvalidDataSource`)[​](https://www.prisma.io/docs/orm/reference/error-reference#p6001-invaliddatasource \"Direct link to p6001-invaliddatasource\")\n\nThe URL is malformed; for instance, it does not use the `prisma://` protocol.\n\nThe API Key in the connection string is invalid.\n\n#### `P6003` (`PlanLimitReached`)[​](https://www.prisma.io/docs/orm/reference/error-reference#p6003-planlimitreached \"Direct link to p6003-planlimitreached\")\n\nThe included usage of the current plan has been exceeded. This can only occur on the [free plan](https://www.prisma.io/pricing).\n\n#### `P6004` (`QueryTimeout`)[​](https://www.prisma.io/docs/orm/reference/error-reference#p6004-querytimeout \"Direct link to p6004-querytimeout\")\n\nThe global timeout of Accelerate has been exceeded. You can find the limit [here](https://www.prisma.io/docs/accelerate/limitations#query-timeout-limit).\n\n> Also see the [troubleshooting guide](https://www.prisma.io/docs/accelerate/troubleshoot#p6004-querytimeout) for more information.\n\n#### `P6005` (`InvalidParameters`)[​](https://www.prisma.io/docs/orm/reference/error-reference#p6005-invalidparameters \"Direct link to p6005-invalidparameters\")\n\nThe user supplied invalid parameters. Currently only relevant for transaction methods. For example, setting a timeout that is too high. You can find the limit [here](https://www.prisma.io/docs/accelerate/limitations#interactive-transactions-query-timeout-limit).\n\n#### `P6006` (`VersionNotSupported`)[​](https://www.prisma.io/docs/orm/reference/error-reference#p6006-versionnotsupported \"Direct link to p6006-versionnotsupported\")\n\nThe chosen Prisma version is not compatible with Accelerate. This may occur when a user uses an unstable development version that we occasionally prune.\n\n#### `P6008` (`ConnectionError|EngineStartError`)[​](https://www.prisma.io/docs/orm/reference/error-reference#p6008-connectionerrorenginestarterror \"Direct link to p6008-connectionerrorenginestarterror\")\n\nThe engine failed to start. For example, it couldn't establish a connection to the database.\n\n> Also see the [troubleshooting guide](https://www.prisma.io/docs/accelerate/troubleshoot#p6008-connectionerrorenginestarterror) for more information.\n\nThe global response size limit of Accelerate has been exceeded. You can find the limit [here](https://www.prisma.io/docs/accelerate/limitations#response-size-limit).\n\n#### `P6009` (`ResponseSizeLimitExceeded`)[​](https://www.prisma.io/docs/orm/reference/error-reference#p6009-responsesizelimitexceeded \"Direct link to p6009-responsesizelimitexceeded\")\n\nThe global response size limit of Accelerate has been exceeded. You can find the limit [here](https://www.prisma.io/docs/accelerate/limitations#response-size-limit).\n\n> Also see the [troubleshooting guide](https://www.prisma.io/docs/accelerate/troubleshoot#p6009-responsesizelimitexceeded) for more information.\n\n#### `P6010` (`ProjectDisabledError`)[​](https://www.prisma.io/docs/orm/reference/error-reference#p6010-projectdisablederror \"Direct link to p6010-projectdisablederror\")\n\nYour accelerate project is disabled. Please [enable](https://www.prisma.io/docs/accelerate/getting-started#1-enable-accelerate) it again to use it.\n\n### Prisma Pulse[​](https://www.prisma.io/docs/orm/reference/error-reference#prisma-pulse \"Direct link to Prisma Pulse\")\n\nPrisma Pulse-related errors start with `P61xx`.\n\n#### `P6100` (`ServerError`) – HTTP Status `500`[​](https://www.prisma.io/docs/orm/reference/error-reference#p6100-servererror--http-status-500 \"Direct link to p6100-servererror--http-status-500\")\n\nAn unexpected server error occurred. This can happen due to a technical issue within the Prisma Pulse or its infrastructure. For any incidents related to Prisma Pulse, you can refer to our status page [here](https://www.prisma-status.com/) and reach out to our support team through one of our available [channels](https://www.prisma.io/docs/platform/support) to report your issue.\n\n#### `P6101` (`DatasourceError`) – HTTP Status `400`[​](https://www.prisma.io/docs/orm/reference/error-reference#p6101-datasourceerror--http-status-400 \"Direct link to p6101-datasourceerror--http-status-400\")\n\nReasons:\n\n1.  The datasource is not reachable by Prisma Pulse. The Console will validate the connection when enabling Pulse to reduce the likelihood of this error. However, the datasource may become unavailable after the configuration step, resulting in this error.\n2.  The datasource is reachable, but did not meet the requirements for Prisma Pulse. The Console will validate the configuration when enabling Pulse to reduce the likelihood of this error. However, the datasource may change after the configuration step, resulting in this error.\n\n#### `P6102` (`Unauthorized`) – HTTP Status `400`[​](https://www.prisma.io/docs/orm/reference/error-reference#p6102-unauthorized--http-status-400 \"Direct link to p6102-unauthorized--http-status-400\")\n\nThe API key is invalid.\n\n#### `P6103` (`ProjectDisabledError`) – HTTP Status `400`[​](https://www.prisma.io/docs/orm/reference/error-reference#p6103-projectdisablederror--http-status-400 \"Direct link to p6103-projectdisablederror--http-status-400\")\n\nPrisma Pulse is not enabled for the configured API key.\n\n#### `P6104` (`AccountHoldError`) – HTTP Status `400`[​](https://www.prisma.io/docs/orm/reference/error-reference#p6104-accountholderror--http-status-400 \"Direct link to p6104-accountholderror--http-status-400\")\n\nYour Prisma Data Platform account has been blocked, potentially due to exceeding the usage limit included in your current plan. Please review the error message for further information.\n\nIf you require further assistance, please get in touch with us via one of our support [channels](https://www.prisma.io/docs/platform/support).\n\n#### `P6105` (`VersionNotSupported`) – HTTP Status `400`[​](https://www.prisma.io/docs/orm/reference/error-reference#p6105-versionnotsupported--http-status-400 \"Direct link to p6105-versionnotsupported--http-status-400\")\n\nThe Prisma version of the project is not compatible with Prisma Pulse.",
  "title": "Errors | Prisma Documentation",
  "description": "Prisma Client, Migrate, Introspection error message reference",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference/prisma-schema-reference",
  "markdown": "# Prisma Schema API | Prisma Documentation\n\n## Prisma schema reference\n\n## `datasource`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource \"Direct link to datasource\")\n\nDefines a [data source](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) in the Prisma schema.\n\n### Fields[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fields \"Direct link to Fields\")\n\nA `datasource` block accepts the following fields:\n\nName\n\nRequired\n\nType\n\nDescription\n\n`provider`\n\n**Yes**\n\nString (`postgresql`, `mysql`, `sqlite`, `sqlserver`, `mongodb`, `cockroachdb`)\n\nDescribes which data source connectors to use.\n\n`url`\n\n**Yes**\n\nString (URL)\n\nConnection URL including authentication info. Most connectors use [the syntax provided by the database](https://www.prisma.io/docs/orm/reference/connection-urls#format).\n\n`shadowDatabaseUrl`\n\nNo\n\nString (URL)\n\nConnection URL to the shadow database used by Prisma Migrate. Allows you to use a cloud-hosted database as the shadow database.\n\n`directUrl`\n\nNo\n\nString (URL)\n\nConnection URL for direct connection to the database.\n\nIf you use a connection pooler URL in the `url` argument (for example, if you use [Prisma Accelerate](https://www.prisma.io/docs/accelerate) or pgBouncer), Prisma CLI commands that require a direct connection to the database use the URL in the `directUrl` argument.\n\nThe `directUrl` property is supported by Prisma Studio from version 5.1.0 upwards.\n\n`relationMode`\n\nNo\n\nString (`foreignKeys`, `prisma`)\n\nSets whether [referential integrity](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode) is enforced by foreign keys in the database or emulated in the Prisma Client.\n\nIn preview in versions 3.1.1 and later. The field is named `relationMode` in versions 4.5.0 and later, and was previously named `referentialIntegrity`.\n\n`extensions`\n\nNo\n\nList of strings (PostgreSQL extension names)\n\nAllows you to [represent PostgreSQL extensions in your schema](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions#how-to-represent-postgresql-extensions-in-your-prisma-schema). Available in preview for PostgreSQL only in Prisma ORM versions 4.5.0 and later.\n\nThe following providers are available:\n\n*   [`sqlite`](https://www.prisma.io/docs/orm/overview/databases/sqlite)\n*   [`postgresql`](https://www.prisma.io/docs/orm/overview/databases/postgresql)\n*   [`mysql`](https://www.prisma.io/docs/orm/overview/databases/mysql)\n*   [`sqlserver`](https://www.prisma.io/docs/orm/overview/databases/sql-server)\n*   [`mongodb`](https://www.prisma.io/docs/orm/overview/databases/mongodb)\n*   [`cockroachdb`](https://www.prisma.io/docs/orm/overview/databases/cockroachdb)\n\n*   You can only have **one** `datasource` block in a schema.\n*   `datasource db` is convention - however, you can give your data source any name - for example, `datasource mysql` or `datasource data`.\n\n### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples \"Direct link to Examples\")\n\n#### Specify a PostgreSQL data source[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-postgresql-data-source \"Direct link to Specify a PostgreSQL data source\")\n\nIn this example, the target database is available with the following credentials:\n\n*   User: `johndoe`\n*   Password: `mypassword`\n*   Host: `localhost`\n*   Port: `5432`\n*   Database name: `mydb`\n*   Schema name: `public`\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public\"}\n```\n\nLearn more about PostgreSQL connection strings [here](https://www.prisma.io/docs/orm/overview/databases/postgresql).\n\n#### Specify a PostgreSQL data source via an environment variable[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-postgresql-data-source-via-an-environment-variable \"Direct link to Specify a PostgreSQL data source via an environment variable\")\n\nIn this example, the target database is available with the following credentials:\n\n*   User: `johndoe`\n*   Password: `mypassword`\n*   Host: `localhost`\n*   Port: `5432`\n*   Database name: `mydb`\n*   Schema name: `public`\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nWhen running a Prisma CLI command that needs the database connection URL (e.g. `prisma generate`), you need to make sure that the `DATABASE_URL` environment variable is set.\n\nOne way to do so is by creating a [`.env`](https://github.com/motdotla/dotenv) file with the following contents. Note that the file must be in the same directory as your `schema.prisma` file to automatically picked up the Prisma CLI.\n\n```\nDATABASE_URL=postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public\n```\n\n#### Specify a MySQL data source[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-mysql-data-source \"Direct link to Specify a MySQL data source\")\n\nIn this example, the target database is available with the following credentials:\n\n*   User: `johndoe`\n*   Password: `mypassword`\n*   Host: `localhost`\n*   Port: `3306`\n*   Database name: `mydb`\n\n```\ndatasource db {  provider = \"mysql\"  url      = \"mysql://johndoe:mypassword@localhost:3306/mydb\"}\n```\n\nLearn more about MySQL connection strings [here](https://www.prisma.io/docs/orm/overview/databases/mysql).\n\n#### Specify a MongoDB data source[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-mongodb-data-source \"Direct link to Specify a MongoDB data source\")\n\n*   User: `root`\n*   Password: `password`\n*   Host: `cluster1.test1.mongodb.net`\n*   Port: N/A\n*   Database name: `testing`\n\n```\ndatasource db {  provider = \"mongodb\"  url      = \"mongodb+srv://root:password@cluster1.test1.mongodb.net/testing?retryWrites=true&w=majority\"}\n```\n\nLearn more about MongoDB connection strings [here](https://www.prisma.io/docs/orm/overview/databases/mongodb).\n\n#### Specify a SQLite data source[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-sqlite-data-source \"Direct link to Specify a SQLite data source\")\n\nIn this example, the target database is located in a file called `dev.db`:\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:./dev.db\"}\n```\n\nLearn more about SQLite connection strings [here](https://www.prisma.io/docs/orm/overview/databases/sqlite).\n\n#### Specify a CockroachDB data source[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-cockroachdb-data-source \"Direct link to Specify a CockroachDB data source\")\n\nIn this example, the target database is available with the following credentials:\n\n*   User: `johndoe`\n*   Password: `mypassword`\n*   Host: `localhost`\n*   Port: `26257`\n*   Database name: `mydb`\n*   Schema name: `public`\n\n```\ndatasource db {  provider = \"cockroachdb\"  url      = \"postgresql://johndoe:mypassword@localhost:26257/mydb?schema=public\"}\n```\n\nThe format for connection strings is the same as for PostgreSQL. Learn more about PostgreSQL connection strings [here](https://www.prisma.io/docs/orm/overview/databases/postgresql).\n\n## `generator`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generator \"Direct link to generator\")\n\nDefines a [generator](https://www.prisma.io/docs/orm/prisma-schema/overview/generators) in the Prisma schema.\n\n### Fields[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fields-1 \"Direct link to Fields\")\n\nA `generator` block accepts the following fields:\n\nName\n\nRequired\n\nType\n\nDescription\n\n`provider`\n\n**Yes**\n\nString (file path) or Enum (`prisma-client-js`)\n\nDescribes which [generator](https://www.prisma.io/docs/orm/prisma-schema/overview/generators) to use. This can point to a file that implements a generator or specify a built-in generator directly.\n\n`output`\n\nNo\n\nString (file path)\n\nDetermines the location for the generated client, [learn more](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#using-a-custom-output-path). **Default**: `node_modules/.prisma/client`\n\n`previewFeatures`\n\nNo\n\nList of Enums\n\nUse intellisense to see list of currently available Preview features (`Ctrl+Space` in Visual Studio Code) **Default**: none\n\n`engineType`\n\nNo\n\nEnum (`library` or `binary`)\n\nDefines the [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines) type to download and use. **Default**: `library`\n\n`binaryTargets`\n\nNo\n\nList of Enums (see below)\n\nSpecify the OS on which the Prisma Client will run to ensure compatibility of the [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines). **Default**: `native`\n\n#### `binaryTargets` options[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#binarytargets-options \"Direct link to binarytargets-options\")\n\nThe following tables list all supported operating systems with the name of platform to specify in [`binaryTargets`](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#binary-targets).\n\nUnless specified otherwise, the default supported CPU architecture is x86\\_64.\n\n##### macOS[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#macos \"Direct link to macOS\")\n\nBuild OS\n\nPrisma engine build name\n\nmacOS Intel x86\\_64\n\n`darwin`\n\nmacOS ARM64\n\n`darwin-arm64`\n\n##### Windows[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#windows \"Direct link to Windows\")\n\nBuild OS\n\nPrisma engine build name\n\nWindows\n\n`windows`\n\n##### Linux (Alpine on x86\\_64 architectures)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#linux-alpine-on-x86_64-architectures \"Direct link to Linux (Alpine on x86_64 architectures)\")\n\nBuild OS\n\nPrisma engine build name\n\nOpenSSL\n\nAlpine (3.17 and newer)\n\n`linux-musl-openssl-3.0.x`\\*\n\n3.0.x\n\nAlpine (3.16 and older)\n\n`linux-musl`\n\n1.1.x\n\n\\* Available in Prisma ORM versions 4.8.0 and later.\n\n##### Linux (Alpine on ARM64 architectures)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#linux-alpine-on-arm64-architectures \"Direct link to Linux (Alpine on ARM64 architectures)\")\n\nBuild OS\n\nPrisma engine build name\n\nOpenSSL\n\nAlpine (3.17 and newer)\n\n`linux-musl-arm64-openssl-3.0.x`\\*\n\n3.0.x\n\nAlpine (3.16 and older)\n\n`linux-musl-arm64-openssl-1.1.x`\\*\n\n1.1.x\n\n\\* Available in Prisma ORM versions 4.10.0 and later.\n\n##### Linux (Debian), x86\\_64[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#linux-debian-x86_64 \"Direct link to Linux (Debian), x86_64\")\n\nBuild OS\n\nPrisma engine build name\n\nOpenSSL\n\nDebian 8 (Jessie)\n\n`debian-openssl-1.0.x`\n\n1.0.x\n\nDebian 9 (Stretch)\n\n`debian-openssl-1.1.x`\n\n1.1.x\n\nDebian 10 (Buster)\n\n`debian-openssl-1.1.x`\n\n1.1.x\n\nDebian 11 (Bullseye)\n\n`debian-openssl-1.1.x`\n\n1.1.x\n\nDebian 12 (Bookworm)\n\n`debian-openssl-3.0.x`\n\n3.0.x\n\n##### Linux (Ubuntu), x86\\_64[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#linux-ubuntu-x86_64 \"Direct link to Linux (Ubuntu), x86_64\")\n\nBuild OS\n\nPrisma engine build name\n\nOpenSSL\n\nUbuntu 14.04 (trusty)\n\n`debian-openssl-1.0.x`\n\n1.0.x\n\nUbuntu 16.04 (xenial)\n\n`debian-openssl-1.0.x`\n\n1.0.x\n\nUbuntu 18.04 (bionic)\n\n`debian-openssl-1.1.x`\n\n1.1.x\n\nUbuntu 19.04 (disco)\n\n`debian-openssl-1.1.x`\n\n1.1.x\n\nUbuntu 20.04 (focal)\n\n`debian-openssl-1.1.x`\n\n1.1.x\n\nUbuntu 21.04 (hirsute)\n\n`debian-openssl-1.1.x`\n\n1.1.x\n\nUbuntu 22.04 (jammy)\n\n`debian-openssl-3.0.x`\n\n3.0.x\n\nUbuntu 23.04 (lunar)\n\n`debian-openssl-3.0.x`\n\n3.0.x\n\n##### Linux (CentOS), x86\\_64[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#linux-centos-x86_64 \"Direct link to Linux (CentOS), x86_64\")\n\nBuild OS\n\nPrisma engine build name\n\nOpenSSL\n\nCentOS 7\n\n`rhel-openssl-1.0.x`\n\n1.0.x\n\nCentOS 8\n\n`rhel-openssl-1.1.x`\n\n1.1.x\n\n##### Linux (Fedora), x86\\_64[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#linux-fedora-x86_64 \"Direct link to Linux (Fedora), x86_64\")\n\nBuild OS\n\nPrisma engine build name\n\nOpenSSL\n\nFedora 28\n\n`rhel-openssl-1.1.x`\n\n1.1.x\n\nFedora 29\n\n`rhel-openssl-1.1.x`\n\n1.1.x\n\nFedora 30\n\n`rhel-openssl-1.1.x`\n\n1.1.x\n\nFedora 36\n\n`rhel-openssl-3.0.x`\n\n3.0.x\n\nFedora 37\n\n`rhel-openssl-3.0.x`\n\n3.0.x\n\nFedora 38\n\n`rhel-openssl-3.0.x`\n\n3.0.x\n\n##### Linux (Linux Mint), x86\\_64[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#linux-linux-mint-x86_64 \"Direct link to Linux (Linux Mint), x86_64\")\n\nBuild OS\n\nPrisma engine build name\n\nOpenSSL\n\nLinux Mint 18\n\n`debian-openssl-1.0.x`\n\n1.0.x\n\nLinux Mint 19\n\n`debian-openssl-1.1.x`\n\n1.1.x\n\nLinux Mint 20\n\n`debian-openssl-1.1.x`\n\n1.1.x\n\nLinux Mint 21\n\n`debian-openssl-3.0.x`\n\n3.0.x\n\n##### Linux (Arch Linux), x86\\_64[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#linux-arch-linux-x86_64 \"Direct link to Linux (Arch Linux), x86_64\")\n\nBuild OS\n\nPrisma engine build name\n\nOpenSSL\n\nArch Linux 2019.09.01\n\n`debian-openssl-1.1.x`\n\n1.1.x\n\nArch Linux 2023.04.23\n\n`debian-openssl-3.0.x`\n\n3.0.x\n\n##### Linux ARM64 (all major distros but Alpine)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#linux-arm64-all-major-distros-but-alpine \"Direct link to Linux ARM64 (all major distros but Alpine)\")\n\nBuild OS\n\nPrisma engine build name\n\nOpenSSL\n\nLinux ARM64 glibc-based distro\n\n`linux-arm64-openssl-1.0.x`\n\n1.0.x\n\nLinux ARM64 glibc-based distro\n\n`linux-arm64-openssl-1.1.x`\n\n1.1.x\n\nLinux ARM64 glibc-based distro\n\n`linux-arm64-openssl-3.0.x`\n\n3.0.x\n\n### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-1 \"Direct link to Examples\")\n\n#### Specify the `prisma-client-js` generator with the default `output`, `previewFeatures`, `engineType` and `binaryTargets`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-the-prisma-client-js-generator-with-the-default-output-previewfeatures-enginetype-and-binarytargets \"Direct link to specify-the-prisma-client-js-generator-with-the-default-output-previewfeatures-enginetype-and-binarytargets\")\n\n```\ngenerator client {  provider = \"prisma-client-js\"}\n```\n\nNote that the above `generator` definition is **equivalent** to the following because it uses the default values for `output`, `engineType` and `binaryTargets` (and implicitly `previewFeatures`):\n\n```\ngenerator client {  provider      = \"prisma-client-js\"  output        = \"node_modules/.prisma/client\"  engineType    = \"library\"  binaryTargets = [\"native\"]}\n```\n\n#### Specify a custom `output` location for Prisma Client[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-custom-output-location-for-prisma-client \"Direct link to specify-a-custom-output-location-for-prisma-client\")\n\nThis example shows how to define a custom `output` location of the generated asset to override the default one.\n\n```\ngenerator client {  provider = \"prisma-client-js\"  output   = \"../src/generated/client\"}\n```\n\n#### Specify custom `binaryTargets` to ensure compatibility with the OS[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-custom-binarytargets-to-ensure-compatibility-with-the-os \"Direct link to specify-custom-binarytargets-to-ensure-compatibility-with-the-os\")\n\nThis example shows how to configure Prisma Client to run on `Ubuntu 19.04 (disco)` based on the table [above](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#linux-ubuntu-x86_64).\n\n```\ngenerator client {  provider      = \"prisma-client-js\"  binaryTargets = [\"debian-openssl-1.1.x\"]}\n```\n\n#### Specify a `provider` pointing to some custom generator implementation[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-provider-pointing-to-some-custom-generator-implementation \"Direct link to specify-a-provider-pointing-to-some-custom-generator-implementation\")\n\nThis example shows how to use a custom generator that's located in a directory called `my-generator`.\n\n```\ngenerator client {  provider = \"./my-generator\"}\n```\n\n## `model`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model \"Direct link to model\")\n\nDefines a Prisma [model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-models) .\n\n*   Every record of a model must be _uniquely_ identifiable. You must define _at least_ one of the following attributes per model:\n    *   [`@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique)\n    *   [`@@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique-1)\n    *   [`@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id)\n    *   [`@@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1)\n\n#### Naming conventions[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions \"Direct link to Naming conventions\")\n\n*   Model names must adhere to the following regular expression: `[A-Za-z][A-Za-z0-9_]*`\n*   Model names must start with a letter and are typically spelled in [PascalCase](https://wiki.c2.com/?PascalCase)\n*   Model names should use the singular form (for example, `User` instead of `user`, `users` or `Users`)\n*   Prisma ORM has a number of **reserved words** that are being used by Prisma ORM internally and therefore cannot be used as a model name. You can find the reserved words [here](https://github.com/prisma/prisma/blob/main/packages/client/src/generation/generateClient.ts#L376) and [here](https://github.com/prisma/prisma-engines/blob/main/psl/parser-database/src/names/reserved_model_names.rs#L44).\n\n> **Note**: You can use the [`@@map` attribute](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map-1) to map a model (for example, `User`) to a table with a different name that does not match model naming conventions (for example, `users`).\n\n#### Order of fields[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#order-of-fields \"Direct link to Order of fields\")\n\n*   In version 2.3.0 and later, introspection lists model fields in the same order as the corresponding columns in the database. Relation fields are listed after scalar fields.\n\n### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-2 \"Direct link to Examples\")\n\n#### A model named `User` with two scalar fields[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#a-model-named-user-with-two-scalar-fields \"Direct link to a-model-named-user-with-two-scalar-fields\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  email String  @unique // `email` can not be optional because it's the only unique field on the model  name  String?}\n```\n\n## `model` fields[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-fields \"Direct link to model-fields\")\n\n[Fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-fields) are properties of models.\n\n#### Naming conventions[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1 \"Direct link to Naming conventions\")\n\n*   Must start with a letter\n*   Typically spelled in camelCase\n*   Must adhere to the following regular expression: `[A-Za-z][A-Za-z0-9_]*`\n\n> **Note**: You can use the [`@map` attribute](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map) to [map a field name to a column](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) with a different name that does not match field naming conventions: e.g. `myField @map(\"my_field\")`.\n\n## `model` field scalar types[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types \"Direct link to model-field-scalar-types\")\n\nThe _data source connector_ determines what _native database type_ each of Prisma ORM scalar type maps to. Similarly, the _generator_ determines what _type in the target programming language_ each of these types map to.\n\nPrisma models also have [model field types](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) that define relations between models.\n\n### `String`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#string \"Direct link to string\")\n\nVariable length text.\n\n#### Default type mappings[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-type-mappings \"Direct link to Default type mappings\")\n\nConnector\n\nDefault mapping\n\nPostgreSQL\n\n`text`\n\nSQL Server\n\n`nvarchar(1000)`\n\nMySQL\n\n`varchar(191)`\n\nMongoDB\n\n`String`\n\nSQLite\n\n`TEXT`\n\nCockroachDB\n\n`STRING`\n\n#### PostgreSQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#postgresql \"Direct link to PostgreSQL\")\n\nNative database type\n\nNative database type attribute\n\nNotes\n\n`text`\n\n`@db.Text`\n\n`char(x)`\n\n`@db.Char(x)`\n\n`varchar(x)`\n\n`@db.VarChar(x)`\n\n`bit(x)`\n\n`@db.Bit(x)`\n\n`varbit`\n\n`@db.VarBit`\n\n`uuid`\n\n`@db.Uuid`\n\n`xml`\n\n`@db.Xml`\n\n`inet`\n\n`@db.Inet`\n\n`citext`\n\n`@db.Citext`\n\nOnly available if [Citext extension is enabled](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#enable-postgresql-extensions-for-native-database-functions).\n\n#### MySQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mysql \"Direct link to MySQL\")\n\nNative database type\n\nNative database type attribute\n\n`VARCHAR(x)`\n\n`@db.VarChar(x)`\n\n`TEXT`\n\n`@db.Text`\n\n`CHAR(x)`\n\n`@db.Char(x)`\n\n`TINYTEXT`\n\n`@db.TinyText`\n\n`MEDIUMTEXT`\n\n`@db.MediumText`\n\n`LONGTEXT`\n\n`@db.LongText`\n\nYou can use Prisma Migrate to map `@db.Bit(1)` to `String`:\n\n```\nmodel Model {  /* ... */  myField String @db.Bit(1)}\n```\n\n#### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb \"Direct link to MongoDB\")\n\n`String`\n\nNative database type attribute\n\nNotes\n\n`@db.String`\n\n`@db.ObjectId`\n\nRequired if the underlying BSON type is `OBJECT_ID` (ID fields, relation scalars)\n\n#### Microsoft SQL Server[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#microsoft-sql-server \"Direct link to Microsoft SQL Server\")\n\nNative database type\n\nNative database type attribute\n\n`char(x)`\n\n`@db.Char(x)`\n\n`nchar(x)`\n\n`@db.NChar(x)`\n\n`varchar(x)`\n\n`@db.VarChar(x)`\n\n`nvarchar(x)`\n\n`@db.NVarChar(x)`\n\n`text`\n\n`@db.Text`\n\n`ntext`\n\n`@db.NText`\n\n`xml`\n\n`@db.Xml`\n\n`uniqueidentifier`\n\n`@db.UniqueIdentifier`\n\n#### SQLite[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sqlite \"Direct link to SQLite\")\n\n`TEXT`\n\n#### CockroachDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cockroachdb \"Direct link to CockroachDB\")\n\nNative database type\n\nNative database type attribute\n\nNotes\n\n`STRING(x)` | `TEXT(x)` | `VARCHAR(x)`\n\n`@db.String(x)`\n\n`CHAR(x)`\n\n`@db.Char(x)`\n\n`\"char\"`\n\n`@db.CatalogSingleChar`\n\n`BIT(x)`\n\n`@db.Bit(x)`\n\n`VARBIT`\n\n`@db.VarBit`\n\n`UUID`\n\n`@db.Uuid`\n\n`INET`\n\n`@db.Inet`\n\nNote that the `xml` and `citext` types supported in PostgreSQL are not currently supported in CockroachDB.\n\n#### Clients[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#clients \"Direct link to Clients\")\n\nPrisma Client JS\n\n`string`\n\n### `Boolean`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#boolean \"Direct link to boolean\")\n\nTrue or false value.\n\n#### Default type mappings[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-type-mappings-1 \"Direct link to Default type mappings\")\n\nConnector\n\nDefault mapping\n\nPostgreSQL\n\n`boolean`\n\nSQL Server\n\n`tinyint`\n\nMySQL\n\n`TINYINT(1)`\n\nMongoDB\n\n`Bool`\n\nSQLite\n\n`INTEGER`\n\nCockroachDB\n\n`BOOL`\n\n#### PostgreSQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#postgresql-1 \"Direct link to PostgreSQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`boolean`\n\n`@db.Boolean`\n\n#### MySQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mysql-1 \"Direct link to MySQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`TINYINT(1)`\n\n`@db.TinyInt(1)`\n\n`TINYINT` maps to `Int` if the max length is greater than 1 (for example, `TINYINT(2)`) _or_ the default value is anything other than `1`, `0`, or `NULL`\n\n`BIT(1)`\n\n`@db.Bit`\n\n#### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-1 \"Direct link to MongoDB\")\n\n`Bool`\n\n#### Microsoft SQL Server[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#microsoft-sql-server-1 \"Direct link to Microsoft SQL Server\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`bit`\n\n`@db.Bit`\n\n#### SQLite[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sqlite-1 \"Direct link to SQLite\")\n\n`INTEGER`\n\n#### CockroachDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cockroachdb-1 \"Direct link to CockroachDB\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`BOOL`\n\n`@db.Bool`\n\n#### Clients[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#clients-1 \"Direct link to Clients\")\n\nPrisma Client JS\n\n`boolean`\n\n### `Int`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#int \"Direct link to int\")\n\n#### Default type mappings[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-type-mappings-2 \"Direct link to Default type mappings\")\n\nConnector\n\nDefault mapping\n\nPostgreSQL\n\n`integer`\n\nSQL Server\n\n`int`\n\nMySQL\n\n`INT`\n\nMongoDB\n\n`Int`\n\nSQLite\n\n`INTEGER`\n\nCockroachDB\n\n`INT`\n\n#### PostgreSQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#postgresql-2 \"Direct link to PostgreSQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`integer` | `int`, `int4`\n\n`@db.Integer`\n\n`smallint` | `int2`\n\n`@db.SmallInt`\n\n`smallserial` | `serial2`\n\n`@db.SmallInt @default(autoincrement())`\n\n`serial` | `serial4`\n\n`@db.Int @default(autoincrement())`\n\n`oid`\n\n`@db.Oid`\n\n#### MySQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mysql-2 \"Direct link to MySQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`INT`\n\n`@db.Int`\n\n`INT UNSIGNED`\n\n`@db.UnsignedInt`\n\n`SMALLINT`\n\n`@db.SmallInt`\n\n`SMALLINT UNSIGNED`\n\n`@db.UnsignedSmallInt`\n\n`MEDIUMINT`\n\n`@db.MediumInt`\n\n`MEDIUMINT UNSIGNED`\n\n`@db.UnsignedMediumInt`\n\n`TINYINT`\n\n`@db.TinyInt`\n\n`TINYINT` maps to `Int` if the max length is greater than 1 (for example, `TINYINT(2)`) _or_ the default value is anything other than `1`, `0`, or `NULL`. `TINYINT(1)` maps to `Boolean`.\n\n`TINYINT UNSIGNED`\n\n`@db.UnsignedTinyInt`\n\n`TINYINT(1) UNSIGNED` maps to `Int`, not `Boolean`\n\n`YEAR`\n\n`@db.Year`\n\n#### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-2 \"Direct link to MongoDB\")\n\n`Int`\n\nNative database type attribute\n\nNotes\n\n`@db.Int`\n\n`@db.Long`\n\n#### Microsoft SQL Server[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#microsoft-sql-server-2 \"Direct link to Microsoft SQL Server\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`int`\n\n`@db.Int`\n\n`smallint`\n\n`@db.SmallInt`\n\n`tinyint`\n\n`@db.TinyInt`\n\n`bit`\n\n`@db.Bit`\n\n#### SQLite[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sqlite-2 \"Direct link to SQLite\")\n\n`INTEGER`\n\n#### CockroachDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cockroachdb-2 \"Direct link to CockroachDB\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`INTEGER` | `INT` | `INT8`\n\n`@db.Int8`\n\nNote that this differs from PostgreSQL, where `integer` and `int` are aliases for `int4` and map to `@db.Integer`\n\n`INT4`\n\n`@db.Int4`\n\n`INT2` | `SMALLINT`\n\n`@db.Int2`\n\n`SMALLSERIAL` | `SERIAL2`\n\n`@db.Int2 @default(autoincrement())`\n\n`SERIAL` | `SERIAL4`\n\n`@db.Int4 @default(autoincrement())`\n\n`SERIAL8` | `BIGSERIAL`\n\n`@db.Int8 @default(autoincrement())`\n\n#### Clients[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#clients-2 \"Direct link to Clients\")\n\nPrisma Client JS\n\n`number`\n\n### `BigInt`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#bigint \"Direct link to bigint\")\n\n`BigInt` is available in version [2.17.0](https://github.com/prisma/prisma/releases/tag/2.17.0) and later.\n\n#### Default type mappings[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-type-mappings-3 \"Direct link to Default type mappings\")\n\nConnector\n\nDefault mapping\n\nPostgreSQL\n\n`bigint`\n\nSQL Server\n\n`int`\n\nMySQL\n\n`BIGINT`\n\nMongoDB\n\n`Long`\n\nSQLite\n\n`INTEGER`\n\nCockroachDB\n\n`INTEGER`\n\n#### PostgreSQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#postgresql-3 \"Direct link to PostgreSQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`bigint` | `int8`\n\n`@db.BigInt`\n\n`bigserial` | `serial8`\n\n`@db.BigInt @default(autoincrement())`\n\n#### MySQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mysql-3 \"Direct link to MySQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`BIGINT`\n\n`@db.BigInt`\n\n`SERIAL`\n\n`@db.UnsignedBigInt @default(autoincrement())`\n\n#### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-3 \"Direct link to MongoDB\")\n\n`Long`\n\n#### Microsoft SQL Server[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#microsoft-sql-server-3 \"Direct link to Microsoft SQL Server\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`bigint`\n\n`@db.BigInt`\n\n#### SQLite[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sqlite-3 \"Direct link to SQLite\")\n\n`INTEGER`\n\n#### CockroachDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cockroachdb-3 \"Direct link to CockroachDB\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`BIGINT` | `INT` | `INT8`\n\n`@db.Int8`\n\nNote that this differs from PostgreSQL, where `int` is an alias for `int4`\n\n`bigserial` | `serial8`\n\n`@db.Int8 @default(autoincrement())`\n\n#### Clients[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#clients-3 \"Direct link to Clients\")\n\nClient\n\nType\n\nDescription\n\nPrisma Client JS\n\n[`BigInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)\n\nSee [examples of working with `BigInt`](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types#working-with-bigint)\n\n### `Float`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#float \"Direct link to float\")\n\nFloating point number.\n\n> `Float` maps to `Double` in [2.17.0](https://github.com/prisma/prisma/releases/tag/2.17.0) and later - see [release notes](https://github.com/prisma/prisma/releases/tag/2.17.0) and [Video: Changes to the default mapping of Float in Prisma ORM 2.17.0](https://www.youtube.com/watch?v=OsuGP_xNHco&amp%3Bab_channel=Prisma) for more information about this change.\n\n#### Default type mappings[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-type-mappings-4 \"Direct link to Default type mappings\")\n\nConnector\n\nDefault mapping\n\nPostgreSQL\n\n`double precision`\n\nSQL Server\n\n`float(53)`\n\nMySQL\n\n`DOUBLE`\n\nMongoDB\n\n`Double`\n\nSQLite\n\n`REAL`\n\nCockroachDB\n\n`DOUBLE PRECISION`\n\n#### PostgreSQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#postgresql-4 \"Direct link to PostgreSQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`double precision`\n\n`@db.DoublePrecision`\n\n`real`\n\n`@db.Real`\n\n#### MySQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mysql-4 \"Direct link to MySQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`FLOAT`\n\n`@db.Float`\n\n`DOUBLE`\n\n`@db.Double`\n\n#### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-4 \"Direct link to MongoDB\")\n\n`Double`\n\n#### Microsoft SQL Server[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#microsoft-sql-server-4 \"Direct link to Microsoft SQL Server\")\n\nNative database types\n\nNative database type attribute\n\n`float`\n\n`@db.Float`\n\n`money`\n\n`@db.Money`\n\n`smallmoney`\n\n`@db.SmallMoney`\n\n`real`\n\n`@db.Real`\n\n#### SQLite connector[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sqlite-connector \"Direct link to SQLite connector\")\n\n`REAL`\n\n#### CockroachDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cockroachdb-4 \"Direct link to CockroachDB\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`DOUBLE PRECISION` | `FLOAT8`\n\n`@db.Float8`\n\n`REAL` | `FLOAT4` | `FLOAT`\n\n`@db.Float4`\n\n#### Clients[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#clients-4 \"Direct link to Clients\")\n\nPrisma Client JS\n\n`number`\n\n### `Decimal`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#decimal \"Direct link to decimal\")\n\n#### Default type mappings[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-type-mappings-5 \"Direct link to Default type mappings\")\n\nConnector\n\nDefault mapping\n\nPostgreSQL\n\n`decimal(65,30)`\n\nSQL Server\n\n`decimal(32,16)`\n\nMySQL\n\n`DECIMAL(65,30)`\n\nMongoDB\n\n[Not supported](https://github.com/prisma/prisma/issues/12637)\n\nSQLite\n\n`DECIMAL`\n\nCockroachDB\n\n`DECIMAL`\n\n#### PostgreSQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#postgresql-5 \"Direct link to PostgreSQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`decimal` | `numeric`\n\n`@db.Decimal(p, s)`†\n\n`money`\n\n`@db.Money`\n\n*   † `p` (precision), the maximum total number of decimal digits to be stored. `s` (scale), the number of decimal digits that are stored to the right of the decimal point.\n\n#### MySQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mysql-5 \"Direct link to MySQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`DECIMAL` | `NUMERIC`\n\n`@db.Decimal(p, s)`†\n\n*   † `p` (precision), the maximum total number of decimal digits to be stored. `s` (scale), the number of decimal digits that are stored to the right of the decimal point.\n\n#### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-5 \"Direct link to MongoDB\")\n\n[Not supported](https://github.com/prisma/prisma/issues/12637).\n\n#### Microsoft SQL Server[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#microsoft-sql-server-5 \"Direct link to Microsoft SQL Server\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`decimal` | `numeric`\n\n`@db.Decimal(p, s)`†\n\n*   † `p` (precision), the maximum total number of decimal digits to be stored. `s` (scale), the number of decimal digits that are stored to the right of the decimal point.\n\n#### SQLite[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sqlite-4 \"Direct link to SQLite\")\n\n`DECIMAL` (changed from `REAL` in 2.17.0)\n\n#### CockroachDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cockroachdb-5 \"Direct link to CockroachDB\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`DECIMAL` | `DEC` | `NUMERIC`\n\n`@db.Decimal(p, s)`†\n\n`money`\n\nNot yet\n\nPostgreSQL's `money` type is not yet supported by CockroachDB\n\n*   † `p` (precision), the maximum total number of decimal digits to be stored. `s` (scale), the number of decimal digits that are stored to the right of the decimal point.\n\n#### Clients[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#clients-5 \"Direct link to Clients\")\n\nClient\n\nType\n\nDescription\n\nPrisma Client JS\n\n[`Decimal`](https://mikemcl.github.io/decimal.js/)\n\nSee [examples of working with `Decimal`](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types#working-with-decimal)\n\n### `DateTime`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datetime \"Direct link to datetime\")\n\n*   Prisma Client returns all `DateTime` as native [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) objects.\n*   Currently, Prisma ORM [does not support](https://github.com/prisma/prisma/issues/5006) [zero dates](https://dev.mysql.com/doc/refman/8.3/en/date-and-time-types.html#:~:text=The%20following%20table%20shows%20the%20format%20of%20the%20%E2%80%9Czero%E2%80%9D%20value%20for%20each%20type) (`0000-00-00 00:00:00`, `0000-00-00`, `00:00:00`) in MySQL.\n\n#### Default type mappings[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-type-mappings-6 \"Direct link to Default type mappings\")\n\nConnector\n\nDefault mapping\n\nPostgreSQL\n\n`timestamp(3)`\n\nSQL Server\n\n`datetime2`\n\nMySQL\n\n`DATETIME(3)`\n\nMongoDB\n\n`Timestamp`\n\nSQLite\n\n`NUMERIC`\n\nCockroachDB\n\n`TIMESTAMP`\n\n#### PostgreSQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#postgresql-6 \"Direct link to PostgreSQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`timestamp(x)`\n\n`@db.Timestamp(x)`\n\n`timestamptz(x)`\n\n`@db.Timestamptz(x)`\n\n`date`\n\n`@db.Date`\n\n`time(x)`\n\n`@db.Time(x)`\n\n`timetz(x)`\n\n`@db.Timetz(x)`\n\n#### MySQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mysql-6 \"Direct link to MySQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`DATETIME(x)`\n\n`@db.DateTime(x)`\n\n`DATE(x)`\n\n`@db.Date(x)`\n\n`TIME(x)`\n\n`@db.Time(x)`\n\n`TIMESTAMP(x)`\n\n`@db.Timestamp(x)`\n\nYou can also use MySQL's `YEAR` type with `Int`:\n\n#### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-6 \"Direct link to MongoDB\")\n\n`Timestamp`\n\n#### Microsoft SQL Server[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#microsoft-sql-server-6 \"Direct link to Microsoft SQL Server\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`date`\n\n`@db.Date`\n\n`time`\n\n`@db.Time`\n\n`datetime`\n\n`@db.DateTime`\n\n`datetime2`\n\n`@db.DateTime2`\n\n`smalldatetime`\n\n`@db.SmallDateTime`\n\n`datetimeoffset`\n\n`@db.DateTimeOffset`\n\n#### SQLite[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sqlite-5 \"Direct link to SQLite\")\n\n`NUMERIC` or `STRING`. If the underlying data type is `STRING`, you must use one of the following formats:\n\n*   [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) (`1996-12-19T16:39:57-08:00`)\n*   [RFC 2822](https://tools.ietf.org/html/rfc2822#section-3.3) (`Tue, 1 Jul 2003 10:52:37 +0200`)\n\n#### CockroachDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cockroachdb-6 \"Direct link to CockroachDB\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`TIMESTAMP(x)`\n\n`@db.Timestamp(x)`\n\n`TIMESTAMPTZ(x)`\n\n`@db.Timestamptz(x)`\n\n`DATE`\n\n`@db.Date`\n\n`TIME(x)`\n\n`@db.Time(x)`\n\n`TIMETZ(x)`\n\n`@db.Timetz(x)`\n\n#### Clients[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#clients-6 \"Direct link to Clients\")\n\nPrisma Client JS\n\n`Date`\n\n### `Json`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#json \"Direct link to json\")\n\nA JSON object.\n\n#### Default type mappings[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-type-mappings-7 \"Direct link to Default type mappings\")\n\nConnector\n\nDefault mapping\n\nPostgreSQL\n\n`jsonb`\n\nSQL Server\n\n[Not supported](https://github.com/prisma/prisma/issues/7417)\n\nMySQL\n\n`JSON`\n\nMongoDB\n\n[A valid `BSON` object (Relaxed mode)](https://docs.mongodb.com/manual/reference/mongodb-extended-json/)\n\nSQLite\n\nNot supported\n\nCockroachDB\n\n`JSONB`\n\n#### PostgreSQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#postgresql-7 \"Direct link to PostgreSQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`json`\n\n`@db.Json`\n\n`jsonb`\n\n`@db.JsonB`\n\n#### MySQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mysql-7 \"Direct link to MySQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`JSON`\n\n`@db.Json`\n\n#### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-7 \"Direct link to MongoDB\")\n\n[A valid `BSON` object (Relaxed mode)](https://docs.mongodb.com/manual/reference/mongodb-extended-json/)\n\n#### Microsoft SQL Server[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#microsoft-sql-server-7 \"Direct link to Microsoft SQL Server\")\n\nMicrosoft SQL Server does not have a specific data type for JSON - however, there are a number of [built-in functions for reading and modifying JSON](https://docs.microsoft.com/en-us/sql/relational-databases/json/json-data-sql-server?view=sql-server-ver15#extract-values-from-json-text-and-use-them-in-queries).\n\nNative database types\n\nNative database type attribute\n\n`JSON`\n\n`@db.NVarChar`\n\n#### SQLite[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sqlite-6 \"Direct link to SQLite\")\n\nNot supported\n\n#### CockroachDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cockroachdb-7 \"Direct link to CockroachDB\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`JSON` | `JSONB`\n\n`@db.JsonB`\n\n#### Clients[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#clients-7 \"Direct link to Clients\")\n\nPrisma Client JS\n\n`object`\n\n### `Bytes`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#bytes \"Direct link to bytes\")\n\n`Bytes` is available in version [2.17.0](https://github.com/prisma/prisma/releases/tag/2.17.0) and later.\n\n#### Default type mappings[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-type-mappings-8 \"Direct link to Default type mappings\")\n\nConnector\n\nDefault mapping\n\nPostgreSQL\n\n`bytea`\n\nSQL Server\n\n`varbinary`\n\nMySQL\n\n`LONGBLOB`\n\nMongoDB\n\n`BinData`\n\nSQLite\n\n`BLOB`\n\nCockroachDB\n\n`BYTES`\n\n#### PostgreSQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#postgresql-8 \"Direct link to PostgreSQL\")\n\nNative database types\n\nNative database type attribute\n\n`bytea`\n\n`@db.ByteA`\n\n#### MySQL[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mysql-8 \"Direct link to MySQL\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`LONGBLOB`\n\n`@db.LongBlob`\n\n`BINARY`\n\n`@db.Binary`\n\n`VARBINARY`\n\n`@db.VarBinary`\n\n`TINYBLOB`\n\n`@db.TinyBlob`\n\n`BLOB`\n\n`@db.Blob`\n\n`MEDIUMBLOB`\n\n`@db.MediumBlob`\n\n`BIT`\n\n`@db.Bit`\n\n#### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-8 \"Direct link to MongoDB\")\n\n`BinData`\n\nNative database type attribute\n\nNotes\n\n`@db.ObjectId`\n\nRequired if the underlying BSON type is `OBJECT_ID` (ID fields, relation scalars)\n\n`@db.BinData`\n\n#### Microsoft SQL Server[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#microsoft-sql-server-8 \"Direct link to Microsoft SQL Server\")\n\nNative database types\n\nNative database type attribute\n\nNotes\n\n`binary`\n\n`@db.Binary`\n\n`varbinary`\n\n`@db.VarBinary`\n\n`image`\n\n`@db.Image`\n\n#### SQLite[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sqlite-7 \"Direct link to SQLite\")\n\n`BLOB`\n\n#### CockroachDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cockroachdb-8 \"Direct link to CockroachDB\")\n\nNative database types\n\nNative database type attribute\n\n`BYTES` | `BYTEA` | `BLOB`\n\n`@db.Bytes`\n\n#### Clients[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#clients-8 \"Direct link to Clients\")\n\nClient\n\nType\n\nDescription\n\nPrisma Client JS\n\n[`Buffer`](https://nodejs.org/api/buffer.html)\n\nSee [examples of working with `Buffer`](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types#working-with-bytes)\n\n### `Unsupported`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unsupported \"Direct link to unsupported\")\n\nwarning\n\n**Not supported by MongoDB**  \nThe [MongoDB connector](https://www.prisma.io/docs/orm/overview/databases/mongodb) does not support the `Unsupported` type.\n\nThe `Unsupported` type was introduced in [2.17.0](https://github.com/prisma/prisma/releases/tag/2.17.0) and allows you to represent data types in the Prisma schema that are not supported by Prisma Client. Fields of type `Unsupported` can be created during Introspection with `prisma db pull` or written by hand, and created in the database with Prisma Migrate or `db push`.\n\n*   Fields with `Unsupported` types are not available in the generated client.\n    \n*   If a model contains a **required** `Unsupported` type, `prisma.model.create(..)`, `prisma.model.update(...)` and `prisma.model.upsert(...)` are not available in Prisma Client.\n    \n*   When you introspect a database that contains unsupported types, Prisma ORM will provide the following warning:\n    \n    ```\n    *** WARNING ***These fields are not supported by Prisma Client, because Prisma does not currently support their types.* Model \"Post\", field: \"circle\", original data type: \"circle\"\n    ```\n    \n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-3 \"Direct link to Examples\")\n\n```\nmodel Star {  id       Int                    @id @default(autoincrement())  position Unsupported(\"circle\")?  example1 Unsupported(\"circle\")  circle   Unsupported(\"circle\")? @default(dbgenerated(\"'<(10,4),11>'::circle\"))}\n```\n\n## `model` field type modifiers[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-type-modifiers \"Direct link to model-field-type-modifiers\")\n\n### `[]` modifier[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#-modifier \"Direct link to -modifier\")\n\nMakes a field a list.\n\n*   Cannot be optional (for example `Post[]?`).\n\n##### Relational databases[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relational-databases \"Direct link to Relational databases\")\n\n*   Scalar lists (arrays) are only supported in the data model if your database natively supports them. Currently, scalar lists are therefore only supported when using PostgreSQL or CockroachDB (since MySQL and SQLite don't natively support scalar lists).\n\n##### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-9 \"Direct link to MongoDB\")\n\n*   Scalar lists are supported\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-4 \"Direct link to Examples\")\n\n##### Define a scalar list[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#define-a-scalar-list \"Direct link to Define a scalar list\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id             Int      @id @default(autoincrement())  favoriteColors String[]}\n```\n\n##### Define a scalar list with a default value[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#define-a-scalar-list-with-a-default-value \"Direct link to Define a scalar list with a default value\")\n\nAvailable in version 4.0.0 and later.\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id             Int      @id @default(autoincrement())  favoriteColors String[] @default([\"red\", \"blue\", \"green\"])}\n```\n\n### `?` modifier[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#-modifier-1 \"Direct link to -modifier-1\")\n\nMakes a field optional.\n\n*   Cannot be used with a list field (for example, `Posts[]`)\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-5 \"Direct link to Examples\")\n\n##### Optional `name` field[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#optional-name-field \"Direct link to optional-name-field\")\n\n```\nmodel User {  id   Int     @id @default(autoincrement())  name String?}\n```\n\n## Attributes[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attributes \"Direct link to Attributes\")\n\nAttributes modify the behavior of a [field](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-fields) or block (e.g. [models](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model)). There are two ways to add attributes to your data model:\n\n*   _Field_ attributes are prefixed with `@`\n*   _Block_ attributes are prefixed with `@@`\n\nSome attributes take arguments. Arguments in attributes are always named, but in most cases the argument _name_ can be omitted.\n\n> **Note**: The leading underscore in a signature means the _argument name_ can be omitted.\n\n### `@id`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id \"Direct link to id\")\n\nDefines a single-field ID on the model.\n\n##### General[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#general \"Direct link to General\")\n\n*   Cannot be defined on a relation field\n*   Cannot be optional\n\n##### Relational databases[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relational-databases-1 \"Direct link to Relational databases\")\n\n*   Corresponding database construct: `PRIMARY KEY`\n    \n*   Can be annotated with a [`@default`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default) attribute that uses [functions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attribute-functions) to auto-generate an ID:\n    \n    *   [`autoincrement()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#autoincrement)\n    *   [`cuid()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cuid)\n    *   [`uuid()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#uuid)\n*   Can be defined on any scalar field (`String`, `Int`, `enum`)\n    \n\n##### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-10 \"Direct link to MongoDB\")\n\n*   Corresponding database construct: [Any valid BSON type, except arrays](https://docs.mongodb.com/manual/core/document/#the-_id-field)\n    \n*   Every model must define an `@id` field\n    \n*   The [underlying ID field name is always `_id`](https://docs.mongodb.com/manual/core/document/#the-_id-field), and must be mapped with `@map(\"_id\")`\n    \n*   Can be defined on any scalar field (`String`, `Int`, `enum`) unless you want to use `ObjectId` in your database\n    \n*   To use an [`ObjectId`](https://docs.mongodb.com/manual/reference/method/ObjectId/) as your ID, you must:\n    \n    *   Use the `String` or `Bytes` field type\n        \n    *   Annotate your field with `@db.ObjectId`:\n        \n        ```\n        id   String  @db.ObjectId  @map(\"_id\")\n        ```\n        \n    *   Optionally, annotate your field with a [`@default`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default) attribute that uses [the `auto()` function](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#auto) to auto-generate an `ObjectId`\n        \n        ```\n        id   String  @db.ObjectId  @map(\"_id\") @default(auto())\n        ```\n        \n*   [`cuid()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cuid) and [`uuid()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#uuid) are supported but do not generate a valid `ObjectId` - use `auto()` instead for `@id`\n    \n*   `autoincrement()` is **not supported**\n    \n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#arguments \"Direct link to Arguments\")\n\nName\n\nRequired\n\nType\n\nDescription\n\n`map`\n\n**No**\n\n`String`\n\nThe name of the underlying primary key constraint in the database.\n\nNot supported for MySQL or MongoDB.\n\n`length`\n\n**No**\n\n`number`\n\nAllows you to specify a maximum length for the subpart of the value to be indexed.\n\nMySQL only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\n\n`sort`\n\n**No**\n\n`String`\n\nAllows you to specify in what order the entries of the ID are stored in the database. The available options are `Asc` and `Desc`.\n\nSQL Server only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\n\n`clustered`\n\n**No**\n\n`Boolean`\n\nDefines whether the ID is clustered or non-clustered. Defaults to `true`.\n\nSQL Server only. In preview in versions 3.13.0 and later, and in general availability in versions 4.0.0 and later.\n\n#### Signature[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#signature \"Direct link to Signature\")\n\n```\n@id(map: String?, length: number?, sort: String?, clustered: Boolean?)\n```\n\n> **Note**: Before version 4.0.0, or 3.5.0 with the `extendedIndexes` Preview feature enabled, the signature was:\n\n> **Note**: Before version 3.0.0, the signature was:\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-6 \"Direct link to Examples\")\n\nIn most cases, you want your database to create the ID. To do this, annotate the ID field with the `@default` attribute and initialize the field with a [function](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attribute-functions).\n\n##### Generate autoincrementing integers as IDs (Relational databases only)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generate-autoincrementing-integers-as-ids-relational-databases-only \"Direct link to Generate autoincrementing integers as IDs (Relational databases only)\")\n\n```\nmodel User {  id   Int    @id @default(autoincrement())  name String}\n```\n\n##### Generate `ObjectId` as IDs (MongoDB only)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generate-objectid-as-ids-mongodb-only \"Direct link to generate-objectid-as-ids-mongodb-only\")\n\n```\nmodel User {  id   String @id @default(auto()) @map(\"_id\") @db.ObjectId  name String}\n```\n\n##### Generate `cuid()` values as IDs[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generate-cuid-values-as-ids \"Direct link to generate-cuid-values-as-ids\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id   String @id @default(cuid())  name String}\n```\n\n##### Generate `uuid()` values as IDs[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generate-uuid-values-as-ids \"Direct link to generate-uuid-values-as-ids\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id   String @id @default(uuid())  name String}\n```\n\n##### Single-field IDs _without_ default values[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#single-field-ids-without-default-values \"Direct link to single-field-ids-without-default-values\")\n\nIn the following example, `id` does not have a default value:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id   String @id  name String}\n```\n\nNote that in the above case, you _must_ provide your own ID values when creating new records for the `User` model using Prisma Client, e.g.:\n\n```\nconst newUser = await prisma.user.create({  data: {    id: 1,    name: 'Alice',  },})\n```\n\n###### Specify an ID on relation scalar field without a default value[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-an-id-on-relation-scalar-field-without-a-default-value \"Direct link to Specify an ID on relation scalar field without a default value\")\n\nIn the following example, `authorId` is a both a relation scalar and the ID of `Profile`:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Profile {  authorId Int    @id  author   User   @relation(fields: [authorId], references: [id])  bio      String}model User {  id      Int      @id  email   String   @unique  name    String?  profile Profile?}\n```\n\nIn this scenario, you cannot create a `Profile` only - you must use Prisma Client's [nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) create a `User` **or** connect the profile to an existing user.\n\nThe following example creates a user and a profile:\n\n```\nconst userWithProfile = await prisma.user.create({  data: {    id: 3,    email: 'bob@prisma.io',    name: 'Bob Prismo',    profile: {      create: {        bio: \"Hello, I'm Bob Prismo and I love apples, blue nail varnish, and the sound of buzzing mosquitoes.\",      },    },  },})\n```\n\nThe following example connects a new profile to a user:\n\n```\nconst profileWithUser = await prisma.profile.create({  data: {    bio: \"Hello, I'm Bob and I like nothing at all. Just nothing.\",    author: {      connect: {        id: 22,      },    },  },})\n```\n\n### `@@id`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1 \"Direct link to id-1\")\n\nwarning\n\n**Not supported by MongoDB**  \nThe [MongoDB connector](https://www.prisma.io/docs/orm/overview/databases/mongodb) does not support composite IDs.\n\nDefines a multi-field ID (composite ID) on the model.\n\n*   Corresponding database type: `PRIMARY KEY`\n*   Can be annotated with a [`@default`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default) attribute that uses [functions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attribute-functions) to auto-generate an ID\n*   Cannot be optional\n*   Can be defined on any scalar field (`String`, `Int`, `enum`)\n*   Cannot be defined on a relation field\n*   The name of the composite ID field in Prisma Client has the following pattern: `field1_field2_field3`\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#arguments-1 \"Direct link to Arguments\")\n\nName\n\nRequired\n\nType\n\nDescription\n\n`fields`\n\n**Yes**\n\n`FieldReference[]`\n\nA list of field names - for example, `[\"firstname\", \"lastname\"]`\n\n`name`\n\n**No**\n\n`String`\n\nThe name that Prisma Client will expose for the argument covering all fields, e.g. `fullName` in `fullName: { firstName: \"First\", lastName: \"Last\"}`\n\n`map`\n\n**No**\n\n`String`\n\nThe name of the underlying primary key constraint in the database.\n\nNot supported for MySQL.\n\n`length`\n\n**No**\n\n`number`\n\nAllows you to specify a maximum length for the subpart of the value to be indexed.\n\nMySQL only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\n\n`sort`\n\n**No**\n\n`String`\n\nAllows you to specify in what order the entries of the ID are stored in the database. The available options are `Asc` and `Desc`.\n\nSQL Server only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\n\n`clustered`\n\n**No**\n\n`Boolean`\n\nDefines whether the ID is clustered or non-clustered. Defaults to `true`.\n\nSQL Server only. In preview in versions 3.13.0 and later, and in general availability in versions 4.0.0 and later.\n\nThe name of the `fields` argument on the `@@id` attribute can be omitted:\n\n```\n@@id(fields: [title, author])@@id([title, author])\n```\n\n#### Signature[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#signature-1 \"Direct link to Signature\")\n\n```\n@@id(_ fields: FieldReference[], name: String?, map: String?)\n```\n\n> **Note**: Until version 3.0.0, the signature was:\n> \n> ```\n> @@id(_ fields: FieldReference[])\n> ```\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-7 \"Direct link to Examples\")\n\n##### Specify a multi-field ID on two `String` fields (Relational databases only)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-multi-field-id-on-two-string-fields-relational-databases-only \"Direct link to specify-a-multi-field-id-on-two-string-fields-relational-databases-only\")\n\n```\nmodel User {  firstName String  lastName  String  email     String  @unique  isAdmin   Boolean @default(false)  @@id([firstName, lastName])}\n```\n\nWhen you create a user, you must provide a unique combination of `firstName` and `lastName`:\n\n```\nconst user = await prisma.user.create({  data: {    firstName: 'Alice',    lastName: 'Smith',  },})\n```\n\nTo retrieve a user, use the generated composite ID field (`firstName_lastName`):\n\n```\nconst user = await prisma.user.findUnique({  where: {    firstName_lastName: {      firstName: 'Alice',      lastName: 'Smith',    },  },})\n```\n\n##### Specify a multi-field ID on two `String` fields and one `Boolean` field (Relational databases only)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-multi-field-id-on-two-string-fields-and-one-boolean-field-relational-databases-only \"Direct link to specify-a-multi-field-id-on-two-string-fields-and-one-boolean-field-relational-databases-only\")\n\n```\nmodel User {  firstName String  lastName  String  email     String  @unique  isAdmin   Boolean @default(false)  @@id([firstName, lastName, isAdmin])}\n```\n\nWhen creating new `User` records, you now must provide a unique combination of values for `firstName`, `lastName` and `isAdmin`:\n\n```\nconst user = await prisma.user.create({  data: {    firstName: 'Alice',    lastName: 'Smith',    isAdmin: true,  },})\n```\n\n##### Specify a multi-field ID that includes a relation field (Relational databases only)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-multi-field-id-that-includes-a-relation-field-relational-databases-only \"Direct link to Specify a multi-field ID that includes a relation field (Relational databases only)\")\n\n```\nmodel Post {  title     String  published Boolean @default(false)  author    User    @relation(fields: [authorId], references: [id])  authorId  Int  @@id([authorId, title])}model User {  id    Int     @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\nWhen creating new `Post` records, you now must provide a unique combination of values for `authorId` (foreign key) and `title`:\n\n```\nconst post = await prisma.post.create({  data: {    title: 'Hello World',    author: {      connect: {        email: 'alice@prisma.io',      },    },  },})\n```\n\n### `@default`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default \"Direct link to default\")\n\nDefines a [default value for a field](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-a-default-value).\n\n*   Default values that cannot yet be represented in the Prisma schema are represented by the [`dbgenerated()` function](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#dbgenerated) when you use [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n*   Default values are not allowed on relation fields in the Prisma schema. Note however that you can still define default values on the fields backing a relation (the ones listed in the `fields` argument in the `@relation` attribute). A default value on the field backing a relation will mean that relation is populated automatically for you.\n*   Default values can be used with [scalar lists](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays) in databases that natively support them.\n\n##### Relational databases[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relational-databases-2 \"Direct link to Relational databases\")\n\n*   Corresponding database construct: `DEFAULT`\n*   Default values can be a static value (`4`, `\"hello\"`) or one of the following [functions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attribute-functions):\n    *   [`autoincrement()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#autoincrement)\n    *   [`sequence()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sequence) (CockroachDB only)\n    *   [`dbgenerated(...)`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#dbgenerated)\n    *   [`cuid()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cuid)\n    *   [`uuid()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#uuid)\n    *   [`now()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#now)\n*   Default values that cannot yet be represented in the Prisma schema are represented by the [`dbgenerated(...)` function](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#dbgenerated) when you use [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n*   Default values are not allowed on relation fields in the Prisma schema. Note however that you can still define default values on the fields backing a relation (the ones listed in the `fields` argument in the `@relation` attribute). A default value on the field backing a relation will mean that relation is populated automatically for you.\n*   Default values can be used with [scalar lists](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays) in databases that natively support them.\n*   JSON data. Note that JSON needs to be enclosed with double-quotes inside the `@default` attribute, e.g.: `@default(\"[]\")`. If you want to provide a JSON object, you need to enclose it with double-quotes and then escape any internal double quotes using a backslash, e.g.: `@default(\"{ \\\"hello\\\": \\\"world\\\" }\")`.\n\n##### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-11 \"Direct link to MongoDB\")\n\n*   Default values can be a static value (`4`, `\"hello\"`) or one of the following [functions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attribute-functions):\n    *   [`auto()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#auto) (can only be used with `@db.ObjectId` to generate an `ObjectId` in MongoDB)\n    *   [`cuid()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cuid)\n    *   [`uuid()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#uuid)\n    *   [`now()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#now)\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#arguments-2 \"Direct link to Arguments\")\n\nName\n\nRequired\n\nType\n\nDescription\n\n`value`\n\n**Yes**\n\nAn expression (e.g. `5`, `true`, `now()`)\n\n`map`\n\n**No**\n\nString\n\n**SQL Server only.**\n\nThe name of the `value` argument on the `@default` attribute can be omitted:\n\n```\nid Int @id @default(value: autoincrement())id Int @id @default(autoincrement())\n```\n\n#### Signature[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#signature-2 \"Direct link to Signature\")\n\n```\n@default(_ value: Expression, map: String?)\n```\n\n> **Note**: Until version 3.0.0, the signature was:\n> \n> ```\n> @default(_ value: Expression)\n> ```\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-8 \"Direct link to Examples\")\n\n##### Default value for an `Int`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-value-for-an-int \"Direct link to default-value-for-an-int\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  email        String @unique  profileViews Int    @default(0)}\n```\n\n##### Default value for a `Float`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-value-for-a-float \"Direct link to default-value-for-a-float\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  email  String @unique  number Float  @default(1.1)}\n```\n\n##### Default value for `Decimal`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-value-for-decimal \"Direct link to default-value-for-decimal\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  email  String  @unique  number Decimal @default(22.99)}\n```\n\n##### Default value for `BigInt`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-value-for-bigint \"Direct link to default-value-for-bigint\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  email  String @unique  number BigInt @default(34534535435353)}\n```\n\n##### Default value for a `String`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-value-for-a-string \"Direct link to default-value-for-a-string\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  email String @unique  name  String @default(\"\")}\n```\n\n##### Default value for a `Boolean`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-value-for-a-boolean \"Direct link to default-value-for-a-boolean\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  email   String  @unique  isAdmin Boolean @default(false)}\n```\n\n##### Default value for a `DateTime`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-value-for-a-datetime \"Direct link to default-value-for-a-datetime\")\n\nNote that static default values for `DateTime` are based on the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard.\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  email String   @unique  data  DateTime @default(\"2020-03-19T14:21:00+02:00\")}\n```\n\n##### Default value for a `Bytes`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-value-for-a-bytes \"Direct link to default-value-for-a-bytes\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  email  String @unique  secret Bytes  @default(\"SGVsbG8gd29ybGQ=\")}\n```\n\n##### Default value for an `enum`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-value-for-an-enum \"Direct link to default-value-for-an-enum\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  role    Role     @default(USER)  posts   Post[]  profile Profile?}\n```\n\n##### Default values for scalar lists[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default-values-for-scalar-lists \"Direct link to Default values for scalar lists\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id             Int      @id @default(autoincrement())  posts          Post[]  favoriteColors String[] @default([\"red\", \"yellow\", \"purple\"])  roles          Role[]   @default([USER, DEVELOPER])}enum Role {  USER  DEVELOPER  ADMIN}\n```\n\n### `@unique`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique \"Direct link to unique\")\n\nDefines a unique constraint for this field.\n\n##### General[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#general-1 \"Direct link to General\")\n\n*   A field annotated with `@unique` can be optional or required\n*   A field annotated with `@unique` _must_ be required if it represents the only unique constraint on a model without an `@id` / `@@id`\n*   A model can have any number of unique constraints\n*   Can be defined on any scalar field\n*   **Cannot** be defined on a relation field\n\n##### Relational databases[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relational-databases-3 \"Direct link to Relational databases\")\n\n*   Corresponding database construct: `UNIQUE`\n*   `NULL` values are considered to be distinct (multiple rows with `NULL` values in the same column are allowed)\n*   Adding a unique constraint automatically adds a corresponding _unique index_ to the specified column(s).\n\n##### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-12 \"Direct link to MongoDB\")\n\n*   Enforced by a [unique index in MongoDB](https://docs.mongodb.com/manual/core/index-unique/)\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#arguments-3 \"Direct link to Arguments\")\n\nName\n\nRequired\n\nType\n\nDescription\n\n`map`\n\n**No**\n\n`String`\n\n`length`\n\n**No**\n\n`number`\n\nAllows you to specify a maximum length for the subpart of the value to be indexed.\n\nMySQL only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\n\n`sort`\n\n**No**\n\n`String`\n\nAllows you to specify in what order the entries of the constraint are stored in the database. The available options are `Asc` and `Desc`.\n\nIn preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\n\n`clustered`\n\n**No**\n\n`Boolean`\n\nDefines whether the constraint is clustered or non-clustered. Defaults to `false`.\n\nSQL Server only. In preview in versions 3.13.0 and later, and in general availability in versions 4.0.0 and later.\n\n*   ¹ Can be required by some of the index and field types.\n\n#### Signature[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#signature-3 \"Direct link to Signature\")\n\n```\n@unique(map: String?, length: number?, sort: String?)\n```\n\n> **Note**: Before version 4.0.0, or 3.5.0 with the `extendedIndexes` Preview feature enabled, the signature was:\n\n> **Note**: Before version 3.0.0, the signature was:\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-9 \"Direct link to Examples\")\n\n##### Specify a unique attribute on a required `String` field[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-unique-attribute-on-a-required-string-field \"Direct link to specify-a-unique-attribute-on-a-required-string-field\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  email String @unique  name  String}\n```\n\n##### Specify a unique attribute on an optional `String` field[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-unique-attribute-on-an-optional-string-field \"Direct link to specify-a-unique-attribute-on-an-optional-string-field\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  email String? @unique  name  String}\n```\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Post {  author    User    @relation(fields: [authorId], references: [id])  authorId  Int     @unique  title     String  published Boolean @default(false)}model User {  id    Int     @id @default(autoincrement())  email String? @unique  name  String  Post  Post[]}\n```\n\n##### Specify a unique attribute with `cuid()` values as default values[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-unique-attribute-with-cuid-values-as-default-values \"Direct link to specify-a-unique-attribute-with-cuid-values-as-default-values\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  token String @unique @default(cuid())  name  String}\n```\n\n### `@@unique`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique-1 \"Direct link to unique-1\")\n\nDefines a compound [unique constraint](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-a-unique-field) for the specified fields.\n\n##### General[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#general-2 \"Direct link to General\")\n\n*   All fields that make up the unique constraint **must** be mandatory fields. The following model is **not** valid because `id` could be `null`:\n    \n    ```\n    model User {  firstname Int  lastname  Int  id        Int?  @@unique([firstname, lastname, id])}\n    ```\n    \n    The reason for this behavior is that all connectors consider `null` values to be distinct, which means that two rows that _look_ identical are considered unique:\n    \n    ```\n     firstname  | lastname | id -----------+----------+------ John       | Smith    | null John       | Smith    | null\n    ```\n    \n*   A model can have any number of `@@unique` blocks\n    \n\n##### Relational databases[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relational-databases-4 \"Direct link to Relational databases\")\n\n*   Corresponding database construct: `UNIQUE`\n*   A `@@unique` block is required if it represents the only unique constraint on a model without an `@id` / `@@id`\n*   Adding a unique constraint automatically adds a corresponding _unique index_ to the specified column(s)\n\n##### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-13 \"Direct link to MongoDB\")\n\n*   Enforced by a [compound index in MongoDB](https://docs.mongodb.com/manual/core/index-compound/) - you must create this index yourself\n*   A `@@unique` block cannot be used as the only unique identifier for a model - MongoDB requires an `@id` field\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#arguments-4 \"Direct link to Arguments\")\n\nName\n\nRequired\n\nType\n\nDescription\n\n`fields`\n\n**Yes**\n\n`FieldReference[]`\n\nA list of field names - for example, `[\"firstname\", \"lastname\"]`. Fields must be mandatory - see remarks.\n\n`name`\n\n**No**\n\n`String`\n\nThe name of the unique combination of fields - defaults to `fieldName1_fieldName2_fieldName3`\n\n`map`\n\n**No**\n\n`String`\n\n`length`\n\n**No**\n\n`number`\n\nAllows you to specify a maximum length for the subpart of the value to be indexed.\n\nMySQL only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\n\n`sort`\n\n**No**\n\n`String`\n\nAllows you to specify in what order the entries of the constraint are stored in the database. The available options are `Asc` and `Desc`.\n\nIn preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\n\n`clustered`\n\n**No**\n\n`Boolean`\n\nDefines whether the constraint is clustered or non-clustered. Defaults to `false`.\n\nSQL Server only. In preview in versions 3.13.0 and later, and in general availability in versions 4.0.0 and later.\n\nThe name of the `fields` argument on the `@@unique` attribute can be omitted:\n\n```\n@@unique(fields: [title, author])@@unique([title, author])@@unique(fields: [title, author], name: \"titleAuthor\")\n```\n\nThe `length` and `sort` arguments are added to the relevant field names:\n\n```\n@@unique(fields: [title(length:10), author])@@unique([title(sort: Desc), author(sort: Asc)])\n```\n\n#### Signature[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#signature-4 \"Direct link to Signature\")\n\n> ```\n> @@unique(_ fields: FieldReference[], name: String?, map: String?)\n> ```\n\n> **Note**: Before version 4.0.0, or before version 3.5.0 with the `extendedIndexes` Preview feature enabled, the signature was:\n> \n> ```\n> @@unique(_ fields: FieldReference[], name: String?, map: String?)\n> ```\n\n> **Note**: Before version 3.0.0, the signature was:\n> \n> ```\n> @@unique(_ fields: FieldReference[], name: String?)\n> ```\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-10 \"Direct link to Examples\")\n\n##### Specify a multi-field unique attribute on two `String` fields[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-multi-field-unique-attribute-on-two-string-fields \"Direct link to specify-a-multi-field-unique-attribute-on-two-string-fields\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        Int     @default(autoincrement())  firstName String  lastName  String  isAdmin   Boolean @default(false)  @@unique([firstName, lastName])}\n```\n\nTo retrieve a user, use the generated field name (`firstname_lastname`):\n\n```\nconst user = await prisma.user.findUnique({  where: {    firstName_lastName: {      firstName: 'Alice',      lastName: 'Smith',      isAdmin: true,    },  },})\n```\n\n##### Specify a multi-field unique attribute on two `String` fields and one `Boolean` field[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-multi-field-unique-attribute-on-two-string-fields-and-one-boolean-field \"Direct link to specify-a-multi-field-unique-attribute-on-two-string-fields-and-one-boolean-field\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        Int     @default(autoincrement())  firstName String  lastName  String  isAdmin   Boolean @default(false)  @@unique([firstName, lastName, isAdmin])}\n```\n\n##### Specify a multi-field unique attribute that includes a relation field[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-multi-field-unique-attribute-that-includes-a-relation-field \"Direct link to Specify a multi-field unique attribute that includes a relation field\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Post {  id        Int     @default(autoincrement())  author    User    @relation(fields: [authorId], references: [id])  authorId  Int  title     String  published Boolean @default(false)  @@unique([authorId, title])}model User {  id    Int    @id @default(autoincrement())  email String @unique  posts Post[]}\n```\n\n##### Specify a custom `name` for a multi-field unique attribute[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-a-custom-name-for-a-multi-field-unique-attribute \"Direct link to specify-a-custom-name-for-a-multi-field-unique-attribute\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        Int     @default(autoincrement())  firstName String  lastName  String  isAdmin   Boolean @default(false)  @@unique(fields: [firstName, lastName, isAdmin], name: \"admin_identifier\")}\n```\n\nTo retrieve a user, use the custom field name (`admin_identifier`):\n\n```\nconst user = await prisma.user.findUnique({  where: {    admin_identifier: {      firstName: 'Alice',      lastName: 'Smith',      isAdmin: true,    },  },})\n```\n\n### `@@index`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#index \"Direct link to index\")\n\nDefines an index in the database.\n\n##### Relational databases[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relational-databases-5 \"Direct link to Relational databases\")\n\n*   Corresponding database construct: `INDEX`\n*   There are some additional index configuration options that cannot be provided via the Prisma schema yet. These include:\n    *   PostgreSQL and CockroachDB:\n        *   Define index fields as expressions (e.g. `CREATE INDEX title ON public.\"Post\"((lower(title)) text_ops);`)\n        *   Define partial indexes with `WHERE`\n        *   Create indexes concurrently with `CONCURRENTLY`\n\ninfo\n\nWhile you cannot configure these option in your Prisma schema, you can still configure them on the database-level directly.\n\n##### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-14 \"Direct link to MongoDB\")\n\n*   In version `3.12.0` and later, you can define an index on a field of a [composite type](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types) using the syntax `@@index([compositeType.field])`. See [Defining composite type indexes](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-type-indexes) for more details.\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#arguments-5 \"Direct link to Arguments\")\n\nName\n\nRequired\n\nType\n\nDescription\n\n`fields`\n\n**Yes**\n\n`FieldReference[]`\n\nA list of field names - for example, `[\"firstname\", \"lastname\"]`\n\n`name`\n\n**No**\n\n`String`\n\nThe name that Prisma Client will expose for the argument covering all fields, e.g. `fullName` in `fullName: { firstName: \"First\", lastName: \"Last\"}`\n\n`map`\n\n**No**\n\n`map`\n\nThe name of the index in the underlying database (Prisma generates an index name that respects identifier length limits if you do not specify a name. Prisma uses the following naming convention: `tablename.field1_field2_field3_unique`)\n\n`length`\n\n**No**\n\n`number`\n\nAllows you to specify a maximum length for the subpart of the value to be indexed.\n\nMySQL only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\n\n`sort`\n\n**No**\n\n`String`\n\nAllows you to specify in what order the entries of the index or constraint are stored in the database. The available options are `asc` and `desc`.\n\nIn preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\n\n`clustered`\n\n**No**\n\n`Boolean`\n\nDefines whether the index is clustered or non-clustered. Defaults to `false`.\n\nSQL Server only. In preview in versions 3.5.0 and later, and in general availability in versions 4.0.0 and later.\n\n`type`\n\n**No**\n\n`identifier`\n\nAllows you to specify an index access method. Defaults to `BTree`.\n\nPostgreSQL and CockroachDB only. In preview with the `Hash` index access method in versions 3.6.0 and later, and with the `Gist`, `Gin`, `SpGist` and `Brin` methods added in 3.14.0. In general availability in versions 4.0.0 and later.\n\n`ops`\n\n**No**\n\n`identifier` or a `function`\n\nAllows you to define the index operators for certain index types.\n\nPostgreSQL only. In preview in versions 3.14.0 and later, and in general availability in versions 4.0.0 and later.\n\nThe _name_ of the `fields` argument on the `@@index` attribute can be omitted:\n\n```\n@@index(fields: [title, author])@@index([title, author])\n```\n\nThe `length` and `sort` arguments are added to the relevant field names:\n\n```\n@@index(fields: [title(length:10), author])@@index([title(sort: Asc), author(sort: Desc)])\n```\n\n#### Signature[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#signature-5 \"Direct link to Signature\")\n\n```\n@@index(_ fields: FieldReference[], map: String?)\n```\n\n> **Note**: Until version 3.0.0, the signature was:\n> \n> ```\n> @@index(_ fields: FieldReference[], name: String?)\n> ```\n> \n> The old `name` argument will still be accepted to avoid a breaking change.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-11 \"Direct link to Examples\")\n\nAssume you want to add an index for the `title` field of the `Post` model\n\n##### Define a single-column index (Relational databases only)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#define-a-single-column-index-relational-databases-only \"Direct link to Define a single-column index (Relational databases only)\")\n\n```\nmodel Post {  id      Int     @id @default(autoincrement())  title   String  content String?  @@index([title])}\n```\n\n##### Define a multi-column index (Relational databases only)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#define-a-multi-column-index-relational-databases-only \"Direct link to Define a multi-column index (Relational databases only)\")\n\n```\nmodel Post {  id      Int     @id @default(autoincrement())  title   String  content String?  @@index([title, content])}\n```\n\n##### Define an index with a name (Relational databases only)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#define-an-index-with-a-name-relational-databases-only \"Direct link to Define an index with a name (Relational databases only)\")\n\n```\nmodel Post {  id      Int     @id @default(autoincrement())  title   String  content String?  @@index(fields: [title, content], name: \"main_index\")}\n```\n\n##### Define an index on a composite type field (Relational databases only)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#define-an-index-on-a-composite-type-field-relational-databases-only \"Direct link to Define an index on a composite type field (Relational databases only)\")\n\n```\ntype Address {  street String  number Int}model User {  id      Int     @id  email   String  address Address  @@index([address.number])}\n```\n\n### `@relation`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relation \"Direct link to relation\")\n\nDefines meta information about the relation. [Learn more](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#the-relation-attribute).\n\n##### Relational databases[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relational-databases-6 \"Direct link to Relational databases\")\n\n*   Corresponding database constructs: `FOREIGN KEY` / `REFERENCES`\n\n##### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-15 \"Direct link to MongoDB\")\n\n*   If your model's primary key is of type `ObjectId` in the underlying database, both the primary key _and_ the foreign key must have the `@db.ObjectId` attribute\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#arguments-6 \"Direct link to Arguments\")\n\nName\n\nType\n\nRequired\n\nDescription\n\nExample\n\n`name`\n\n`String`\n\nSometimes (e.g. to disambiguate a relation)\n\nDefines the name of the relationship. In an m-n-relation, it also determines the name of the underlying relation table.\n\n`\"CategoryOnPost\"`, `\"MyRelation\"`\n\n`fields`\n\n`FieldReference[]`\n\nOn [annotated](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) relation fields\n\nA list of [fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-fields) of the _current_ model\n\n`[\"authorId\"]`, `[\"authorFirstName, authorLastName\"]`\n\n`references`\n\n`FieldReference[]`\n\nOn [annotated](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) relation fields\n\nA list of [fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-fields) of the model on _the other side of the relation_\n\n`[\"id\"]`, `[\"firstName, lastName\"]`\n\n`map`\n\n`String`\n\nNo\n\nDefines a [custom name](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#constraint-and-index-names) for the foreign key in the database.\n\n`[\"id\"]`, `[\"firstName, lastName\"]`\n\n`onUpdate`\n\nEnum. See [Types of referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#types-of-referential-actions) for values.\n\nNo\n\nDefines the [referential action](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) to perform when a referenced entry in the referenced model is being updated.\n\n`Cascade`, `NoAction`\n\n`onDelete`\n\nEnum. See [Types of referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#types-of-referential-actions) for values.\n\nNo\n\nDefines the [referential action](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) to perform when a referenced entry in the referenced model is being deleted.\n\n`Cascade`, `NoAction`\n\nThe name of the `name` argument on the `@relation` attribute can be omitted (`references` is required):\n\n```\n@relation(name: \"UserOnPost\", references: [id])@relation(\"UserOnPost\", references: [id])// or@relation(name: \"UserOnPost\")@relation(\"UserOnPost\")\n```\n\n#### Signature[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#signature-6 \"Direct link to Signature\")\n\n```\n@relation(_ name: String?, fields: FieldReference[]?, references: FieldReference[]?, onDelete: ReferentialAction?, onUpdate: ReferentialAction?, map: String?)\n```\n\nWith SQLite, the signature changes to:\n\n```\n@relation(_ name: String?, fields: FieldReference[]?, references: FieldReference[]?, onDelete: ReferentialAction?, onUpdate: ReferentialAction?)\n```\n\n> **Note**: Until version 3.0.0, the signature was:\n> \n> ```\n> @relation(_ name: String?, fields: FieldReference[]?, references: FieldReference[]?)\n> ```\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-12 \"Direct link to Examples\")\n\nSee: [The `@relation` attribute](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#the-relation-attribute).\n\n### `@map`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map \"Direct link to map\")\n\nMaps a field name or enum value from the Prisma schema to a column or document field with a different name in the database. If you do not use `@map`, the Prisma field name matches the column name or document field name exactly.\n\n> See [Using custom model and field names](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) to see how `@map` and `@@map` changes the generated Prisma Client.\n\n##### General[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#general-3 \"Direct link to General\")\n\n*   `@map` **does not** rename the columns / fields in the database\n*   `@map` **does** [change the field names in the generated client](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map-the-firstname-field-to-a-column-called-first_name)\n\n##### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-16 \"Direct link to MongoDB\")\n\nYour `@id` field must include `@map(\"_id\")`. For example:\n\n```\nmodel User {  id String @default(auto()) @map(\"_id\") @db.ObjectId}\n```\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#arguments-7 \"Direct link to Arguments\")\n\nName\n\nType\n\nRequired\n\nDescription\n\nExample\n\n`name`\n\n`String`\n\n**Yes**\n\nThe database column (relational databases) or document field (MongoDB) name.\n\n`\"comments\"`, `\"someFieldName\"`\n\nThe name of the `name` argument on the `@map` attribute can be omitted:\n\n```\n@map(name: \"is_admin\")@map(\"users\")\n```\n\n#### Signature[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#signature-7 \"Direct link to Signature\")\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-13 \"Direct link to Examples\")\n\n##### Map the `firstName` field to a column called `first_name`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map-the-firstname-field-to-a-column-called-first_name \"Direct link to map-the-firstname-field-to-a-column-called-first_name\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        Int    @id @default(autoincrement())  firstName String @map(\"first_name\")}\n```\n\nThe generated client:\n\n```\nawait prisma.user.create({  data: {    firstName: 'Yewande', // first_name --> firstName  },})\n```\n\n##### Map an enum named `ADMIN` to a database enum named `admin`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map-an-enum-named-admin-to-a-database-enum-named-admin \"Direct link to map-an-enum-named-admin-to-a-database-enum-named-admin\")\n\n```\nenum Role {  ADMIN    @map(\"admin\")  CUSTOMER}\n```\n\n### `@@map`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map-1 \"Direct link to map-1\")\n\nMaps the Prisma schema model name to a table (relational databases) or collection (MongoDB) with a different name, or an enum name to a different underlying enum in the database. If you do not use `@@map`, the model name matches the table (relational databases) or collection (MongoDB) name exactly.\n\n> See [Using custom model and field names](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) to see how `@map` and `@@map` changes the generated Prisma Client.\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#arguments-8 \"Direct link to Arguments\")\n\nName\n\nType\n\nRequired\n\nDescription\n\nExample\n\n`name`\n\n`String`\n\n**Yes**\n\nThe database table (relational databases) or collection (MongoDB) name.\n\n`\"comments\"`, `\"someTableOrCollectionName\"`\n\nThe name of the `name` argument on the `@@map` attribute can be omitted\n\n```\n@@map(name: \"users\")@@map(\"users\")\n```\n\n#### Signature[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#signature-8 \"Direct link to Signature\")\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-14 \"Direct link to Examples\")\n\n##### Map the `User` model to a database table/collection named `users`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map-the-user-model-to-a-database-tablecollection-named-users \"Direct link to map-the-user-model-to-a-database-tablecollection-named-users\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id   Int    @id @default(autoincrement())  name String  @@map(\"users\")}\n```\n\nThe generated client:\n\n```\nawait prisma.user.create({  // users --> user  data: {    name: 'Yewande',  },})\n```\n\n##### Map the `Role` enum to a native enum in the database named `_Role` its values to lowercase values in the database[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map-the-role-enum-to-a-native-enum-in-the-database-named-_role-its-values-to-lowercase-values-in-the-database \"Direct link to map-the-role-enum-to-a-native-enum-in-the-database-named-_role-its-values-to-lowercase-values-in-the-database\")\n\n```\nenum Role {  ADMIN    @map(\"admin\")  CUSTOMER @map(\"customer\")  @@map(\"_Role\")}\n```\n\n### `@updatedAt`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#updatedat \"Direct link to updatedat\")\n\nAutomatically stores the time when a record was last updated. If you do not supply a time yourself, Prisma Client will automatically set the value for fields with this attribute.\n\n*   Compatible with [`DateTime`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datetime) fields\n*   Implemented at Prisma ORM level\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#arguments-9 \"Direct link to Arguments\")\n\nN/A\n\n#### Signature[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#signature-9 \"Direct link to Signature\")\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-15 \"Direct link to Examples\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Post {  id        String   @id  updatedAt DateTime @updatedAt}\n```\n\n### `@ignore`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#ignore \"Direct link to ignore\")\n\nAdd `@ignore` to a field that you want to exclude from Prisma Client (for example, a field that you do not want Prisma Client users to update). Ignored fields are excluded from the generated Prisma Client. The model's `create` method is disabled when doing this for _required_ fields with no `@default` (because the database cannot create an entry without that data).\n\n*   In [2.17.0](https://github.com/prisma/prisma/releases/tag/2.17.0) and later, Prisma ORM automatically adds `@ignore` to fields that _refer to_ invalid models when you introspect.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-16 \"Direct link to Examples\")\n\nThe following example demonstrates manually adding `@ignore` to exclude the `email` field from Prisma Client:\n\nschema.prisma\n\n```\nmodel User {  id    Int    @id  name  String  email String @ignore // this field will be excluded}\n```\n\n### `@@ignore`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#ignore-1 \"Direct link to ignore-1\")\n\nAdd `@@ignore` to a model that you want to exclude from Prisma Client (for example, a model that you do not want Prisma users to update). Ignored models are excluded from the generated Prisma Client.\n\n*   In [2.17.0](https://github.com/prisma/prisma/releases/tag/2.17.0) and later, Prisma ORM adds `@@ignore` to an invalid model. (It also adds [`@ignore`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#ignore) to relations pointing to such a model)\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-17 \"Direct link to Examples\")\n\nIn the following example, the `Post` model is invalid because it does not have a unique identifier. Use `@@ignore` to exclude it from the generated Prisma Client API:\n\nschema.prisma\n\n```\n/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.model Post {  id       Int  @default(autoincrement()) // no unique identifier  author   User @relation(fields: [authorId], references: [id])  authorId Int  @@ignore}\n```\n\nIn the following example, the `Post` model is invalid because it does not have a unique identifier, and the `posts` relation field on `User` is invalid because it refers to the invalid `Post` model. Use `@@ignore` on the `Post` model and `@ignore` on the `posts` relation field in `User` to exclude both the model and the relation field from the generated Prisma Client API:\n\nschema.prisma\n\n```\n/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.model Post {  id       Int  @default(autoincrement()) // no unique identifier  author   User @relation(fields: [authorId], references: [id])  authorId Int  @@ignore}model User {  id    Int     @id @default(autoincrement())  name  String?  posts Post[]  @ignore}\n```\n\n### `@@schema`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#schema \"Direct link to schema\")\n\nwarning\n\nTo use this attribute, you must have the [`multiSchema`](https://github.com/prisma/prisma/issues/1122#issuecomment-1231773471) preview feature enabled. Multiple database schema support is currently available with the PostgreSQL, CockroachDB, and SQL Server connectors.\n\nAdd `@@schema` to a model to specify which schema in your database should contain the table associated with that model.\n\n#### Arguments[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#arguments-10 \"Direct link to Arguments\")\n\nName\n\nType\n\nRequired\n\nDescription\n\nExample\n\n`name`\n\n`String`\n\n**Yes**\n\nThe name of the database schema.\n\n`\"base\"`, `\"auth\"`\n\nThe name of the `name` argument on the `@@schema` attribute can be omitted\n\n```\n@@schema(name: \"auth\")@@schema(\"auth\")\n```\n\n#### Signature[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#signature-10 \"Direct link to Signature\")\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-18 \"Direct link to Examples\")\n\n##### Map the `User` model to a database schema named `auth`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map-the-user-model-to-a-database-schema-named-auth \"Direct link to map-the-user-model-to-a-database-schema-named-auth\")\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"multiSchema\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")  schemas  = [\"auth\"]}model User {  id   Int    @id @default(autoincrement())  name String  @@schema(\"auth\")}\n```\n\ninfo\n\nFor more information about using the `multiSchema` feature, refer to [this guide](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema).\n\n## Attribute functions[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attribute-functions \"Direct link to Attribute functions\")\n\n### `auto()`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#auto \"Direct link to auto\")\n\nwarning\n\nThis function is available on MongoDB only.\n\nRepresents **default values** that are automatically generated by the database.\n\n##### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-17 \"Direct link to MongoDB\")\n\nUsed to generate an `ObjectId` for `@id` fields:\n\n```\nid  String  @map(\"_id\") @db.ObjectId @default(auto())\n```\n\n##### Relational databases[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relational-databases-7 \"Direct link to Relational databases\")\n\nThe `auto()` function is not available on relational databases.\n\n#### Example[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#example \"Direct link to Example\")\n\n##### Generate `ObjectId` (MongoDB only)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generate-objectid-mongodb-only \"Direct link to generate-objectid-mongodb-only\")\n\n```\nmodel User {  id   String  @id @default(auto()) @map(\"_id\") @db.ObjectId  name String?}\n```\n\n### `autoincrement()`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#autoincrement \"Direct link to autoincrement\")\n\nwarning\n\n**Not supported by MongoDB**  \nThe [MongoDB connector](https://www.prisma.io/docs/orm/overview/databases/mongodb) does not support the `autoincrement()` function.\n\nCreate a sequence of integers in the underlying database and assign the incremented values to the ID values of the created records based on the sequence.\n\n*   Compatible with `Int` on most databases (`BigInt` on CockroachDB)\n    \n*   Implemented on the database-level, meaning that it manifests in the database schema and can be recognized through introspection. Database implementations:\n    \n    Database\n    \n    Implementation\n    \n    PostgreSQL\n    \n    [`SERIAL`](https://www.postgresql.org/docs/9.1/datatype-numeric.html#DATATYPE-SERIAL) type\n    \n    MySQL\n    \n    [`AUTO_INCREMENT`](https://dev.mysql.com/doc/refman/8.0/en/example-auto-increment.html) attribute\n    \n    SQLite\n    \n    [`AUTOINCREMENT`](https://www.sqlite.org/autoinc.html) keyword\n    \n    CockroachDB\n    \n    [`SERIAL`](https://www.postgresql.org/docs/9.1/datatype-numeric.html#DATATYPE-SERIAL) type\n    \n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-19 \"Direct link to Examples\")\n\n##### Generate autoincrementing integers as IDs (Relational databases only)[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generate-autoincrementing-integers-as-ids-relational-databases-only-1 \"Direct link to Generate autoincrementing integers as IDs (Relational databases only)\")\n\n```\nmodel User {  id   Int    @id @default(autoincrement())  name String}\n```\n\n### `sequence()`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#sequence \"Direct link to sequence\")\n\nCreate a sequence of integers in the underlying database and assign the incremented values to the values of the created records based on the sequence.\n\n#### Optional arguments[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#optional-arguments \"Direct link to Optional arguments\")\n\nArgument\n\nExample\n\n`virtual`\n\n`@default(sequence(virtual))`  \nVirtual sequences are sequences that do not generate monotonically increasing values and instead produce values like those generated by the built-in function `unique_rowid()`.\n\n`cache`\n\n`@default(sequence(cache: 20))`  \nThe number of sequence values to cache in memory for reuse in the session. A cache size of `1` means that there is no cache, and cache sizes of less than `1` are not valid.\n\n`increment`\n\n`@default(sequence(increment: 4))`  \nThe new value by which the sequence is incremented. A negative number creates a descending sequence. A positive number creates an ascending sequence.\n\n`minValue`\n\n`@default(sequence(minValue: 10))`  \nThe new minimum value of the sequence.\n\n`maxValue`\n\n`@default(sequence(maxValue: 3030303))`  \nThe new maximum value of the sequence.\n\n`start`\n\n`@default(sequence(start: 2))`  \nThe value the sequence starts at, if it's restarted or if the sequence hits the `maxValue`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-20 \"Direct link to Examples\")\n\n##### Generate sequencing integers as IDs[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generate-sequencing-integers-as-ids \"Direct link to Generate sequencing integers as IDs\")\n\n```\nmodel User {  id   Int    @id @default(sequence(maxValue: 4294967295))  name String}\n```\n\n### `cuid()`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cuid \"Direct link to cuid\")\n\nGenerate a globally unique identifier based on the [`cuid`](https://github.com/ericelliott/cuid) spec.\n\n*   Compatible with `String`\n*   Implemented by Prisma ORM and therefore not \"visible\" in the underlying database schema. You can still use `cuid()` when using [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) by [manually changing your Prisma schema](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) and [generating Prisma Client](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client), in that case the values will be generated by Prisma's [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines).\n*   Since the length of `cuid()` output is undefined per the cuid creator, a safe field size is 30 characters, in order to allow for enough characters for very large values. If you set the field size as less than 30, and then a larger value is generated by `cuid()`, you might see Prisma Client errors such as `Error: The provided value for the column is too long for the column's type.`\n\n##### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-18 \"Direct link to MongoDB\")\n\n*   `cuid()` does not generate a valid `ObjectId` - [use the `@db.ObjectId` syntax](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generate-objectid-as-ids-mongodb-only) if you want to use `ObjectId` in the underlying database. However, you can still use `cuid()` if your `_id` field is not of type `ObjectId`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-21 \"Direct link to Examples\")\n\n##### Generate `cuid()` values as IDs[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generate-cuid-values-as-ids-1 \"Direct link to generate-cuid-values-as-ids-1\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id   String @id @default(cuid())  name String}\n```\n\n### `uuid()`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#uuid \"Direct link to uuid\")\n\nGenerate a globally unique identifier based on the [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) spec, version 4 (random).\n\n*   Compatible with `String`\n*   Implemented by Prisma ORM and therefore not \"visible\" in the underlying database schema. You can still use `uuid()` when using [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) by [manually changing your Prisma schema](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) and [generating Prisma Client](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client), in that case the values will be generated by Prisma ORM's [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines).\n\n##### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-19 \"Direct link to MongoDB\")\n\n*   `uuid()` does not generate a valid `ObjectId` - [use the `@db.ObjectId` syntax](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generate-objectid-as-ids-mongodb-only) if you want to use `ObjectId` in the underlying database. However, you can still use `uuid()` if your `_id` field is not of type `ObjectId`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-22 \"Direct link to Examples\")\n\n##### Generate `uuid()` values as IDs[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generate-uuid-values-as-ids-1 \"Direct link to generate-uuid-values-as-ids-1\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id   String @id @default(uuid())  name String}\n```\n\n### `now()`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#now \"Direct link to now\")\n\nSet a timestamp of the time when a record is created.\n\n##### General[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#general-4 \"Direct link to General\")\n\n*   Compatible with [`DateTime`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datetime)\n\n##### Relational databases[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relational-databases-8 \"Direct link to Relational databases\")\n\n*   Implemented on the database-level, meaning that it manifests in the database schema and can be recognized through introspection. Database implementations:\n    \n    Database\n    \n    Implementation\n    \n    PostgreSQL\n    \n    [`CURRENT_TIMESTAMP`](https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT) and aliases like `now()`\n    \n    MySQL\n    \n    [`CURRENT_TIMESTAMP`](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp) and aliases like `now()`\n    \n    SQLite\n    \n    `CURRENT_TIMESTAMP` and aliases like `date('now')`\n    \n    CockroachDB\n    \n    [`CURRENT_TIMESTAMP`](https://www.cockroachlabs.com/docs/stable/functions-and-operators#special-syntax-forms) and aliases like `now()`\n    \n\n##### MongoDB[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb-20 \"Direct link to MongoDB\")\n\n*   Implemented at Prisma ORM level\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-23 \"Direct link to Examples\")\n\n##### Set current timestamp value when a record is created[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#set-current-timestamp-value-when-a-record-is-created \"Direct link to Set current timestamp value when a record is created\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        String   @id  createdAt DateTime @default(now())}\n```\n\n### `dbgenerated(...)`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#dbgenerated \"Direct link to dbgenerated\")\n\nRepresents **default values** that cannot be expressed in the Prisma schema (such as `random()`).\n\n##### Relational databases[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relational-databases-9 \"Direct link to Relational databases\")\n\n*   Compatible with any scalar type\n    \n*   Can not be an empty string `dbgenerated(\"\")` in [2.21.0](https://github.com/prisma/prisma/releases/tag/2.21.0) and later\n    \n*   Accepts a `String` value in [2.17.0](https://github.com/prisma/prisma/releases/tag/2.17.0) and later, which allows you to:\n    \n    *   [Set default values for `Unsupported` types](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#set-default-value-for-unsupported-type)\n    *   [Override default value behavior for supported types](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#override-default-value-behavior-for-supported-types)\n*   String values in `dbgenerated(...)` might not match what the DB returns as the default value, because values such as strings may be explicitly cast (e.g. `'hello'::STRING`). When a mismatch is present, Prisma Migrate indicates a migration is still needed. You can use `prisma db pull` to infer the correct value to resolve the discrepancy. ([Related issue](https://github.com/prisma/prisma/issues/14917))\n    \n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-24 \"Direct link to Examples\")\n\n##### Set default value for `Unsupported` type[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#set-default-value-for-unsupported-type \"Direct link to set-default-value-for-unsupported-type\")\n\n```\ncircle     Unsupported(\"circle\")?   @default(dbgenerated(\"'<(10,4),11>'::circle\"))\n```\n\n##### Override default value behavior for supported types[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#override-default-value-behavior-for-supported-types \"Direct link to Override default value behavior for supported types\")\n\nYou can also use `dbgenerated(...)` to set the default value for supported types. For example, in PostgreSQL you can generate UUIDs at the database level rather than rely on Prisma ORM's `uuid()`:\n\n```\nmodel User {  id   String  @id @default(dbgenerated(\"gen_random_uuid()\")) @db.Uuid  id   String  @id @default(uuid()) @db.Uuid  test String?}\n```\n\n## Attribute argument types[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attribute-argument-types \"Direct link to Attribute argument types\")\n\n### `FieldReference[]`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fieldreference \"Direct link to fieldreference\")\n\nAn array of [field](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-fields) names: `[id]`, `[firstName, lastName]`\n\n### `String`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#string-1 \"Direct link to string-1\")\n\nA variable length text in double quotes: `\"\"`, `\"Hello World\"`, `\"Alice\"`\n\n### `Expression`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#expression \"Direct link to expression\")\n\nAn expression that can be evaluated by Prisma ORM: `42.0`, `\"\"`, `Bob`, `now()`, `cuid()`\n\n## `enum`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#enum \"Direct link to enum\")\n\nDefines an [enum](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-enums) .\n\n*   Enums are natively supported by [PostgreSQL](https://www.postgresql.org/docs/current/datatype-enum.html) and [MySQL](https://dev.mysql.com/doc/refman/8.0/en/enum.html)\n*   Enums are implemented and enforced at Prisma ORM level in MongoDB\n\n### Naming conventions[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-2 \"Direct link to Naming conventions\")\n\n*   Enum names must start with a letter (they are typically spelled in [PascalCase](http://wiki.c2.com/?PascalCase))\n*   Enums must use the singular form (e.g. `Role` instead of `role`, `roles` or `Roles`).\n*   Must adhere to the following regular expression: `[A-Za-z][A-Za-z0-9_]*`\n\n### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-25 \"Direct link to Examples\")\n\n#### Specify an `enum` with two possible values[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-an-enum-with-two-possible-values \"Direct link to specify-an-enum-with-two-possible-values\")\n\n*   Relational databases\n*   MongoDB\n\n```\nenum Role {  USER  ADMIN}model User {  id   Int  @id @default(autoincrement())  role Role}\n```\n\n#### Specify an `enum` with two possible values and set a default value[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#specify-an-enum-with-two-possible-values-and-set-a-default-value \"Direct link to specify-an-enum-with-two-possible-values-and-set-a-default-value\")\n\n*   Relational databases\n*   MongoDB\n\n```\nenum Role {  USER  ADMIN}model User {  id   Int  @id @default(autoincrement())  role Role @default(USER)}\n```\n\n## `type`[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#type \"Direct link to type\")\n\nwarning\n\nComposite types are available **for MongoDB only**.\n\ninfo\n\nComposite types are available in versions 3.12.0 and later, and in versions 3.10.0 and later if you enable the `mongodb` Preview feature flag.\n\nDefines a [composite type](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types) .\n\n### Naming conventions[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-3 \"Direct link to Naming conventions\")\n\nType names must:\n\n*   start with a letter (they are typically spelled in [PascalCase](http://wiki.c2.com/?PascalCase))\n*   adhere to the following regular expression: `[A-Za-z][A-Za-z0-9_]*`\n\n### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#examples-26 \"Direct link to Examples\")\n\n#### Define a `Product` model with a list of `Photo` composite types[​](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#define-a-product-model-with-a-list-of-photo-composite-types \"Direct link to define-a-product-model-with-a-list-of-photo-composite-types\")\n\n```\nmodel Product {  id     String  @id @default(auto()) @map(\"_id\") @db.ObjectId  name   String  photos Photo[]}type Photo {  height Int  width  Int  url    String}\n```",
  "title": "Prisma Schema API | Prisma Documentation",
  "description": "API reference documentation for the Prisma Schema Language (PSL).",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference/prisma-client-reference",
  "markdown": "# Prisma Client API | Prisma Documentation\n\n## Prisma Client API reference\n\nThe Prisma Client API reference documentation is based on the following schema:\n\n```\nmodel User {  id           Int              @id @default(autoincrement())  name         String?  email        String           @unique  profileViews Int              @default(0)  role         Role             @default(USER)  coinflips    Boolean[]  posts        Post[]  city         String  country      String  profile      ExtendedProfile?  pets         Json}model ExtendedProfile {  id     Int     @id @default(autoincrement())  userId Int?    @unique  bio    String?  User   User?   @relation(fields: [userId], references: [id])}model Post {  id        Int     @id @default(autoincrement())  title     String  published Boolean @default(true)  author    User    @relation(fields: [authorId], references: [id])  authorId  Int  comments  Json  views     Int     @default(0)  likes     Int     @default(0)}enum Role {  USER  ADMIN}\n```\n\nAll example generated types (such as `UserSelect` and `UserWhereUniqueInput`) are based on the `User` model.\n\n## `PrismaClient`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#prismaclient \"Direct link to prismaclient\")\n\nThis section describes the `PrismaClient` constructor and its parameters.\n\n*   Parameters are validated at runtime.\n\n### `datasources`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#datasources \"Direct link to datasources\")\n\nProgrammatically overrides properties of the `datasource` block in the `schema.prisma` file - for example, as part of an integration test. See also: [Data sources](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources)\n\nFrom version 5.2.0 and upwards, you can also use the [`datasourceUrl`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#datasourceurl) property to programmatically override the database connection string.\n\n#### Properties[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#properties \"Direct link to Properties\")\n\nExample property\n\nExample value\n\nDescription\n\n`db`\n\n`{ url: 'file:./dev_qa.db' }`\n\nThe database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls).\n\n*   You must re-generate Prisma Client each time you add or rename a data source. Datasource names are included in the generated client.\n*   If you named your `datasource` block something else in the schema, replace `db` with the name of your `datasource` block.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples \"Direct link to Examples\")\n\n##### Programmatically override a datasource `url`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#programmatically-override-a-datasource-url \"Direct link to programmatically-override-a-datasource-url\")\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient({  datasources: {    db: {      url: 'file:./dev_qa.db',    },  },})\n```\n\nBased on the following `datasource` block:\n\n```\ndatasource db {  provider = \"sqlite\"  url      = env(\"DATABASE_URL\")}\n```\n\n### `datasourceUrl`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#datasourceurl \"Direct link to datasourceurl\")\n\nProgrammatically overrides the [`datasource`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#datasources) block in the `schema.prisma` file.\n\n#### Property[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#property \"Direct link to Property\")\n\nOption\n\nExample value\n\nDescription\n\nDatabase connection string\n\n`'file:./dev_qa.db'`\n\nThe database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls).\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-1 \"Direct link to Examples\")\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient({  datasourceUrl: 'postgresql://johndoe:randompassword@localhost:5432/mydb',})\n```\n\n### `log`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#log \"Direct link to log\")\n\nDetermines the type and level of logging. See also: [Logging](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging)\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options \"Direct link to Options\")\n\nOption\n\nExample\n\nArray of log levels\n\n`[ \"info\", \"query\" ]`\n\nArray of log definitions\n\n`[ { level: \"info\", emit: \"event\" }, { level: \"warn\", emit: \"stdout\" }]`\n\n##### Log levels[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#log-levels \"Direct link to Log levels\")\n\nName\n\nExample\n\n`query`\n\nLogs all queries run by Prisma.\n\nFor relational databases this logs all SQL queries. Example:  \n`prisma:query SELECT \"public\".\"User\".\"id\", \"public\".\"User\".\"email\" FROM \"public\".\"User\" WHERE (\"public\".\"User\".\"id\") IN (SELECT \"t0\".\"id\" FROM \"public\".\"User\" AS \"t0\" INNER JOIN \"public\".\"Post\" AS \"j0\" ON (\"j0\".\"authorId\") = (\"t0\".\"id\") WHERE (\"j0\".\"views\" > $1 AND \"t0\".\"id\" IS NOT NULL)) OFFSET $2`\n\nFor MongoDB this logs queries using the [`mongosh` shell](https://docs.mongodb.com/mongodb-shell/#mongodb-binary-bin.mongosh) format. Example:  \n`prisma:query db.User.deleteMany({ _id: ( $in: [ “6221ce49f756b0721fc00542”, ], }, })`\n\n`info`\n\nExample:  \n`prisma:info Started http server on http://127.0.0.1:58471`\n\n`warn`\n\nWarnings.\n\n`error`\n\nErrors.\n\n##### Emit formats[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#emit-formats \"Direct link to Emit formats\")\n\nName\n\nDescription\n\n`stdout`\n\nSee: [stdout](https://en.wikipedia.org/wiki/Standard_streams)\n\n`event`\n\nRaises an event that you can subscribe to.\n\n##### Event types[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#event-types \"Direct link to Event types\")\n\nThe `query` event type:\n\nindex.d.ts\n\n```\nexport type QueryEvent = {  timestamp: Date  query: string // Query sent to the database  params: string // Query parameters  duration: number // Time elapsed (in milliseconds) between client issuing query and database responding - not only time taken to run query  target: string}\n```\n\nNote that for MongoDB, the `params` and `duration` fields will be undefined.\n\nAll other log level event types:\n\nindex.d.ts\n\n```\nexport type LogEvent = {  timestamp: Date  message: string  target: string}\n```\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-2 \"Direct link to Examples\")\n\n##### Log `query` and `info` to `stdout`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#log-query-and-info-to-stdout \"Direct link to log-query-and-info-to-stdout\")\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient({ log: ['query', 'info'] })async function main() {  const countUsers = await prisma.user.count({})}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\n##### Log a `query` event to console[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#log-a-query-event-to-console \"Direct link to log-a-query-event-to-console\")\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient({  log: [{ level: 'query', emit: 'event' }],})prisma.$on('query', (e) => {  console.log(e)})async function main() {  const countUsers = await prisma.user.count({})}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\n##### Log `info`, `warn`, and `error` events to console[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#log-info-warn-and-error-events-to-console \"Direct link to log-info-warn-and-error-events-to-console\")\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient({  log: [    { level: 'warn', emit: 'event' },    { level: 'info', emit: 'event' },    { level: 'error', emit: 'event' },  ],})prisma.$on('warn', (e) => {  console.log(e)})prisma.$on('info', (e) => {  console.log(e)})prisma.$on('error', (e) => {  console.log(e)})async function main() {  const countUsers = await prisma.user.count({})}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\n### `errorFormat`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#errorformat \"Direct link to errorformat\")\n\nDetermines the level and formatting of errors returned by Prisma Client.\n\n#### Error formats[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#error-formats \"Direct link to Error formats\")\n\nName\n\nDescription\n\n`undefined`\n\nIf it's not defined, the default is colorless.\n\n`pretty`\n\nEnables pretty error formatting.\n\n`colorless` (default)\n\nEnables colorless error formatting.\n\n`minimal`\n\nEnables minimal error formatting.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-3 \"Direct link to Examples\")\n\n##### No error formatting[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#no-error-formatting \"Direct link to No error formatting\")\n\n```\nconst prisma = new PrismaClient({  // Defaults to colorless})\n```\n\n##### `pretty` error formatting[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#pretty-error-formatting \"Direct link to pretty-error-formatting\")\n\n```\nconst prisma = new PrismaClient({  errorFormat: 'pretty',})\n```\n\n##### `colorless` error formatting[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#colorless-error-formatting \"Direct link to colorless-error-formatting\")\n\n```\nconst prisma = new PrismaClient({  errorFormat: 'colorless',})\n```\n\n##### `minimal` error formatting[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#minimal-error-formatting \"Direct link to minimal-error-formatting\")\n\n```\nconst prisma = new PrismaClient({  errorFormat: 'minimal',})\n```\n\n### `adapter`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#adapter \"Direct link to adapter\")\n\nDefines an instance of a [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters). See also [Database drivers](https://www.prisma.io/docs/orm/overview/databases/database-drivers) .\n\ninfo\n\nThis is available from version 5.4.0 and newer behind the `driverAdapters` feature flag.\n\n#### Example[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#example \"Direct link to Example\")\n\nThe example below uses the [Neon driver adapter](https://www.prisma.io/docs/orm/overview/databases/neon#how-to-use-neons-serverless-driver-with-prisma-orm-preview)\n\n```\nimport { Pool, neonConfig } from '@neondatabase/serverless'import { PrismaNeon } from '@prisma/adapter-neon'import { PrismaClient } from '@prisma/client'import dotenv from 'dotenv'import ws from 'ws'dotenv.config()neonConfig.webSocketConstructor = wsconst connectionString = `${process.env.DATABASE_URL}`const pool = new Pool({ connectionString })const adapter = new PrismaNeon(pool)const prisma = new PrismaClient({ adapter })\n```\n\n### `rejectOnNotFound`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#rejectonnotfound \"Direct link to rejectonnotfound\")\n\ninfo\n\n**Note**: `rejectOnNotFound` was removed in v5.0.0.\n\n**Deprecated:** `rejectOnNotFound` is deprecated in v4.0.0. From v4.0.0, use the queries [`findUniqueOrThrow`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#finduniqueorthrow) or [`findFirstOrThrow`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirstorthrow).\n\nUse the `rejectOnNotFound` parameter to configure `findUnique()` and/or `findFirst` to throw an error if the record was not found. By default, both operations return `null` if the record is not found.\n\n*   You can configure `rejectOnNotFound` on a per-request level for both [`findUnique()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findunique) and [`findFirst`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirst)\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-1 \"Direct link to Options\")\n\nOption\n\nDescription\n\n`RejectOnNotFound`\n\nEnable globally (`true` / `false`) _or_ throw a custom error.\n\n`RejectPerOperation`\n\nEnable per operation (`true` / `false`) _or_ throw a custom error per operation, per model.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-4 \"Direct link to Examples\")\n\n##### Enable globally for `findUnique()` and `findFirst`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#enable-globally-for-findunique-and-findfirst \"Direct link to enable-globally-for-findunique-and-findfirst\")\n\n```\nconst prisma = new PrismaClient({  rejectOnNotFound: true,})\n```\n\n##### Enable globally for a specific operation[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#enable-globally-for-a-specific-operation \"Direct link to Enable globally for a specific operation\")\n\n```\nconst prisma = new PrismaClient({  rejectOnNotFound: {    findUnique: true,  },})\n```\n\n##### Throw a custom error per model and operation if record is not found[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#throw-a-custom-error-per-model-and-operation-if-record-is-not-found \"Direct link to Throw a custom error per model and operation if record is not found\")\n\n```\nconst prisma = new PrismaClient({  rejectOnNotFound: {    findFirst: {      User: (err) => new Error('User error'),      Post: (err) => new Error('Post error!'),    },    findUnique: {      User: (err) => new Error('User error'),      Post: (err) => new Error('Post error!'),    },  },})\n```\n\n### `transactionOptions`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#transactionoptions \"Direct link to transactionoptions\")\n\ninfo\n\n**Note**: `transactionOptions` was introduced in v5.10.0.\n\nAllows to set [transaction options](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-options) globally on the constructor level.\n\n*   The transaction levels can be overridden on a per-transaction level.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-2 \"Direct link to Options\")\n\nOption\n\nDescription\n\n`maxWait`\n\nThe maximum amount of time Prisma Client will wait to acquire a transaction from the database. The default value is 2 seconds.\n\n`timeout`\n\nThe maximum amount of time the interactive transaction can run before being canceled and rolled back. The default value is 5 seconds.\n\n`isolationLevel`\n\nSets the [transaction isolation level](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-isolation-level). By default this is set to the value currently configured in your database. The available can vary depending on the database you use.\n\n#### Example[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#example-1 \"Direct link to Example\")\n\n```\nconst prisma = new PrismaClient({  transactionOptions: {    isolationLevel: Prisma.TransactionIsolationLevel.Serializable,    maxWait: 5000, // default: 2000    timeout: 10000, // default: 5000  },})\n```\n\n## Model queries[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#model-queries \"Direct link to Model queries\")\n\nUse model queries to perform CRUD operations on your models. See also: [CRUD](https://www.prisma.io/docs/orm/prisma-client/queries/crud)\n\n### `findUnique()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findunique \"Direct link to findunique\")\n\n`findUnique()` query lets you retrieve a single database record:\n\n*   By _ID_\n*   By a _unique_ attribute\n\n`findUnique()` replaced `findOne` in version [2.12.0](https://github.com/prisma/prisma/releases/tag/2.12.0).\n\n*   Prisma Client's dataloader [automatically batches `findUnique()` queries](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-n1-in-graphql-with-findunique-and-prisma-clients-dataloader) with the same `select` and `where` parameters.\n*   If you want the query to throw an error if the record is not found, then consider using [`findUniqueOrThrow`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#finduniqueorthrow) instead.\n*   You cannot use [filter conditions](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions-and-operators) (e.g. `equals`, `contains`, `not`) to filter fields of the [JSON](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#json) data type. Using filter conditions will likely result in a `null` response for that field.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-3 \"Direct link to Options\")\n\nName\n\nExample type (`User`)\n\nRequired\n\nDescription\n\n`where`\n\n`UserWhereUniqueInput`\n\n**Yes**\n\nWraps all _unique_ fields of a model so that individual records can be selected.  \nFrom version 4.5.0, this type wraps all fields of a model. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-on-non-unique-fields-with-userwhereuniqueinput)\n\n`select`\n\n`XOR<UserSelect, null>`\n\nNo\n\n[Specifies which properties to include](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields) on the returned object.\n\n`include`\n\n`XOR<UserInclude, null>`\n\nNo\n\n[Specifies which relations should be eagerly loaded](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries) on the returned object.\n\n`omit`\n\n`XOR<UserOmit, null>`\n\nNo\n\nSpecifies which properties to exclude on the returned object. In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.13.0\n\n`relationLoadStrategy`\n\n`'join'` or `'query'`\n\nNo\n\n**Default: `join`**. Specifies the [load strategy](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-load-strategies-preview) for a relation query. Only available in combination with `include` (or `select` on a relation field). In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.9.0.\n\n`rejectOnNotFound` (deprecated)\n\n`RejectOnNotFound`\n\nNo\n\nIf true, throw a `NotFoundError: No User found error`. You can also [configure `rejectOnNotFound` globally](https://www.prisma.io/docs/orm/reference/prisma-client-reference#rejectonnotfound).  \n**Note:** `rejectOnNotFound`is deprecated in v4.0.0. From v4.0.0, use [`findUniqueOrThrow`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#finduniqueorthrow) instead.\n\n#### Return type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-type \"Direct link to Return type\")\n\nReturn type\n\nExample\n\nDescription\n\nJavaScript object (typed)\n\n`User`\n\nJavaScript object (plain)\n\n`{ title: \"Hello world\" }`\n\nUse `select` and `include` to determine which fields to return.\n\n`null`\n\n`null`\n\nRecord not found\n\nError\n\nIf `rejectOnNotFound` is true, `findUnique()` throws an error (`NotFoundError` by default, [customizable globally](https://www.prisma.io/docs/orm/reference/prisma-client-reference#rejectonnotfound)) instead of returning `null`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-5 \"Direct link to Examples\")\n\n##### Get the `User` record with an `id` of `42`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-the-user-record-with-an-id-of-42 \"Direct link to get-the-user-record-with-an-id-of-42\")\n\n```\nconst result = await prisma.user.findUnique({  where: {    id: 42,  },})\n```\n\n##### Get the `User` record with an `email` of `alice@prisma.io`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-the-user-record-with-an-email-of-aliceprismaio \"Direct link to get-the-user-record-with-an-email-of-aliceprismaio\")\n\n```\nconst result = await prisma.user.findUnique({  where: {    email: 'alice@prisma.io',  },})\n```\n\n##### Get the `User` record with `firstName` of `Alice` and `lastName` of `Smith` (`@@unique`)[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-the-user-record-with-firstname-of-alice-and-lastname-of-smith-unique \"Direct link to get-the-user-record-with-firstname-of-alice-and-lastname-of-smith-unique\")\n\nExpand for example User model with a @@unique block\n\n```\nmodel User {  firstName String  lastName  String  @@unique(fields: [firstName, lastName], name: \"fullname\")}\n```\n\n```\nconst result = await prisma.user.findUnique({  where: {    fullname: {      // name property of @@unique attribute - default is firstname_lastname      firstName: 'Alice',      lastName: 'Smith',    },  },})\n```\n\n##### Get the `User` record with `firstName` of `Alice` and `lastName` of `Smith` (`@@id`)[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-the-user-record-with-firstname-of-alice-and-lastname-of-smith-id \"Direct link to get-the-user-record-with-firstname-of-alice-and-lastname-of-smith-id\")\n\nExpand for example User model with an @@id block\n\n```\nmodel User {  firstName String  lastName  String  @@id([firstName, lastName])}\n```\n\n```\nconst result = await prisma.user.findUnique({  where: {    firstName_lastName: {      firstName: 'Alice',      lastName: 'Smith',    },  },})\n```\n\n### `findUniqueOrThrow()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#finduniqueorthrow \"Direct link to finduniqueorthrow\")\n\ninfo\n\nWe introduced `findUniqueOrThrow` in v4.0.0. It replaces the [`rejectOnNotFound`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#rejectonnotfound) option. `rejectOnNotFound` is deprecated in v4.0.0.\n\n`findUniqueOrThrow` retrieves a single data record in the same way as [`findUnique()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findunique). However, if the query does not find a record, it returns `NotFoundError: No User found error`.\n\n`findUniqueOrThrow` differs from `findUnique()` as follows:\n\n*   Its return type is non-nullable. For example, `post.findUnique()` can return `post` or `null`, but `post.findUniqueOrThrow()` always returns `post`.\n    \n*   It is not compatible with sequential operations in the [`$transaction` API](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#the-transaction-api). If the query returns `NotFoundError`, then the API will not roll back any operations in the array of calls. As a workaround, you can use interactive transactions with the `$transaction` API, as follows:\n    \n    ```\n     $transaction(async (prisma) => {   await prisma.model.create({ data: { ... });   await prisma.model.findUniqueOrThrow(); })\n    ```\n    \n\n### `findFirst()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirst \"Direct link to findfirst\")\n\n`findFirst` returns the first record in a list that matches your criteria.\n\n*   If you want the query to throw an error if the record is not found, then consider using [`findFirstOrThrow`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirstorthrow) instead.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-4 \"Direct link to Options\")\n\nName\n\nExample type (`User`)\n\nRequired\n\nDescription\n\n`select`\n\n`XOR<UserSelect, null>`\n\nNo\n\n[Specifies which properties to include](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields) on the returned object.\n\n`include`\n\n`XOR<UserInclude, null>`\n\nNo\n\n[Specifies which relations should be eagerly loaded](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries) on the returned object.\n\n`omit`\n\n`XOR<UserOmit, null>`\n\nNo\n\nSpecifies which properties to exclude on the returned object. In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.13.0.\n\n`relationLoadStrategy`\n\n`'join'` or `'query'`\n\nNo\n\n**Default: `join`**. Specifies the [load strategy](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-load-strategies-preview) for a relation query. Only available in combination with `include` (or `select` on a relation field). In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.9.0.\n\n`where`\n\n`UserWhereInput`\n\nNo\n\nWraps _all_ model fields in a type so that the list can be filtered by any property.\n\n`orderBy`\n\n`XOR<Enumerable<User`  \n`OrderByInput>,UserOrderByInput>`\n\nNo\n\nLets you order the returned list by any property.\n\n`cursor`\n\n`UserWhereUniqueInput`\n\nNo\n\nSpecifies the position for the list (the value typically specifies an `id` or another unique value).\n\n`take`\n\n`number`\n\nNo\n\nSpecifies how many objects should be returned in the list. When used with `findFirst`, `take` is implicitly `1` or `-1`. `findFirst` is only affected by whether the value is positive or negative - any negative value reverses the list.\n\n`skip`\n\n`number`\n\nNo\n\nSpecifies how many of the returned objects in the list should be skipped.\n\n`distinct`\n\n`Enumerable<UserDistinct`  \n`FieldEnum>`\n\nNo\n\nLets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.\n\n`rejectOnNotFound` (deprecated)\n\n`RejectOnNotFound`\n\nNo\n\nIf true, throw a `NotFoundError: No User found error`. You can also [configure `rejectOnNotFound` globally](https://www.prisma.io/docs/orm/reference/prisma-client-reference#rejectonnotfound).  \n**Note:** `rejectOnNotFound`is deprecated in v4.0.0. From v4.0.0, use [`findFirstOrThrow`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirstorthrow) instead.\n\n#### Return type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-type-1 \"Direct link to Return type\")\n\nReturn type\n\nExample\n\nDescription\n\nJavaScript object (typed)\n\n`User`\n\nSpecifies which properties to include on the returned object.\n\nJavaScript object (plain)\n\n`{ title: \"Hello world\" }`\n\nUse `select` and `include` to determine which fields to return.\n\n`null`\n\n`null`\n\nRecord not found\n\nError\n\nIf `rejectOnNotFound` is true, `findUnique()` throws an error (`NotFoundError` by default, [customizable globally](https://www.prisma.io/docs/orm/reference/prisma-client-reference#rejectonnotfound)) instead of returning `null`.\n\n*   `findFirst` calls `findMany` behind the scenes and accepts the same query options.\n*   Passing in a negative `take` value when you use a `findFirst` query reverses the order of the list.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-6 \"Direct link to Examples\")\n\nSee [Filter conditions and operators](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions-and-operators) for examples of how to filter results.\n\n##### Get the first `User` record where the `name` is `Alice`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-the-first-user-record-where-the-name-is-alice \"Direct link to get-the-first-user-record-where-the-name-is-alice\")\n\n```\nconst user = await prisma.user.findFirst({  where: { name: 'Alice' },})\n```\n\n##### Get the first `Post` record where the `title` starts with `A test`, reverse the list with `take`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-the-first-post-record-where-the-title-starts-with-a-test-reverse-the-list-with-take \"Direct link to get-the-first-post-record-where-the-title-starts-with-a-test-reverse-the-list-with-take\")\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient({})async function main() {  const a = await prisma.post.create({    data: {      title: 'A test 1',    },  })  const b = await prisma.post.create({    data: {      title: 'A test 2',    },  })  const c = await prisma.post.findFirst({    where: {      title: {        startsWith: 'A test',      },    },    orderBy: {      title: 'asc',    },    take: -1, // Reverse the list  })}main()\n```\n\n### `findFirstOrThrow()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirstorthrow \"Direct link to findfirstorthrow\")\n\ninfo\n\nWe introduced `findFirstOrThrow` in v4.0.0. It replaces the [`rejectOnNotFound`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#rejectonnotfound) option. `rejectOnNotFound` is deprecated in v4.0.0.\n\n`findFirstOrThrow` retrieves the first record in a list in the same way as [`findFirst`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirst). However, if the query does not find a record, it returns `NotFoundError: No User found error`.\n\n`findFirstOrThrow` differs from `findFirst` as follows:\n\n*   Its return type is non-nullable. For example, `post.findFirst()` can return `post` or `null`, but `post.findFirstOrThrow` always returns `post`.\n    \n*   It is not compatible with sequential operations in the [`$transaction` API](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#the-transaction-api). If the query returns `NotFoundError`, then the API will not roll back any operations in the array of calls. As a workaround, you can use interactive transactions with the `$transaction` API, as follows:\n    \n    ```\n    prisma.$transaction(async (tx) => {  await tx.model.create({ data: { ... });  await tx.model.findFirstOrThrow();})\n    ```\n    \n\n### `findMany()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findmany \"Direct link to findmany\")\n\n`findMany` returns a list of records.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-5 \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`select`\n\n`XOR<PostSelect, null>`\n\nNo\n\n[Specifies which properties to include](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields) on the returned object.\n\n`include`\n\n`XOR<PostInclude, null>`\n\nNo\n\n[Specifies which relations should be eagerly loaded](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries) on the returned object.\n\n`omit`\n\n`XOR<PostOmit, null>`\n\nNo\n\nSpecifies which properties to exclude on the returned object. In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.13.0\n\n`relationLoadStrategy`\n\n`'join'` or `'query'`\n\nNo\n\n**Default: `join`**. Specifies the [load strategy](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-load-strategies-preview) for a relation query. Only available in combination with `include` (or `select` on a relation field). In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.9.0.\n\n`where`\n\n`UserWhereInput`\n\nNo\n\nWraps _all_ model fields in a type so that the list can be filtered by any property.\n\n`orderBy`\n\n`XOR<Enumerable<PostOrder`  \n`ByInput>, PostOrderByInput>`\n\nNo\n\nLets you order the returned list by any property.\n\n`cursor`\n\n`UserWhereUniqueInput`\n\nNo\n\nSpecifies the position for the list (the value typically specifies an `id` or another unique value).\n\n`take`\n\n`number`\n\nNo\n\nSpecifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned)\n\n`skip`\n\n`number`\n\nNo\n\nSpecifies how many of the returned objects in the list should be skipped.\n\n`distinct`\n\n`Enumerable<UserDistinctFieldEnum>`\n\nNo\n\nLets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.\n\n#### Return type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-type-2 \"Direct link to Return type\")\n\nReturn type\n\nExample\n\nDescription\n\nJavaScript array object (typed)\n\n`User[]`\n\nJavaScript array object (plain)\n\n`[{ title: \"Hello world\" }]`\n\nUse `select` and `include` to determine which fields to return.\n\nEmpty array\n\n`[]`\n\nNo matching records found.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-7 \"Direct link to Examples\")\n\nSee [Filter conditions and operators](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions-and-operators) for examples of how to filter results.\n\n##### Get all `User` records where the `name` is `Alice`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-user-records-where-the-name-is-alice \"Direct link to get-all-user-records-where-the-name-is-alice\")\n\n```\nconst user = await prisma.user.findMany({  where: { name: 'Alice' },})\n```\n\n### `create()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create \"Direct link to create\")\n\n`create` creates a new database record.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-6 \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`data`\n\n`XOR<UserCreateInput,`  \n`UserUncheckedCreateInput>`\n\n**Yes**\n\nWraps all the model fields in a type so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional.\n\n[`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select)\n\n`XOR<UserSelect, null>`\n\nNo\n\n[Specifies which properties to include](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields) on the returned object.\n\n[`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include)\n\n`XOR<UserInclude, null>`\n\nNo\n\n[Specifies which relations should be eagerly loaded](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries) on the returned object.\n\n[`omit`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#omit-preview)\n\n`XOR<UserOmit, null>`\n\nNo\n\nSpecifies which properties to exclude on the returned object. In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.13.0\n\n`relationLoadStrategy`\n\n`'join'` or `'query'`\n\nNo\n\n**Default: `join`**. Specifies the [load strategy](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-load-strategies-preview) for a relation query. Only available in combination with `include` (or `select` on a relation field). In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.9.0.\n\n#### Return type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-type-3 \"Direct link to Return type\")\n\nReturn type\n\nExample\n\nDescription\n\nJavaScript object (typed)\n\n`User`\n\nJavaScript object (plain)\n\n`{ name: \"Alice Wonderland\" }`\n\nUse `select` and `include` to determine which fields to return.\n\n*   You can also perform a nested [`create`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-1) - for example, add a `User` and two `Post` records at the same time.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-8 \"Direct link to Examples\")\n\n##### Create a single new record with the only required field `email`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-a-single-new-record-with-the-only-required-field-email \"Direct link to create-a-single-new-record-with-the-only-required-field-email\")\n\n```\nconst user = await prisma.user.create({  data: { email: 'alice@prisma.io' },})\n```\n\n##### Create multiple new records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-multiple-new-records \"Direct link to Create multiple new records\")\n\nIn most cases, you can carry out batch inserts with the [`createMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany) or [`createManyAndReturn()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmanyandreturn) queries. However, [there are scenarios where `create()` is the best option to insert multiple records](https://www.prisma.io/docs/orm/reference/prisma-client-reference#remarks-10).\n\nThe following example results in **two** `INSERT` statements:\n\n```\nimport { Prisma, PrismaClient } from '@prisma/client'const prisma = new PrismaClient({ log: ['query'] })async function main() {  let users: Prisma.UserCreateInput[] = [    {      email: 'ariana@prisma.io',      name: 'Ari',      profileViews: 20,      coinflips: [true, false, false],      role: 'ADMIN',    },    {      email: 'elsa@prisma.io',      name: 'Elsa',      profileViews: 20,      coinflips: [true, false, false],      role: 'ADMIN',    },  ]  await Promise.all(    users.map(async (user) => {      await prisma.user.create({        data: user,      })    })  )}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\n### `update()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update \"Direct link to update\")\n\n`update` updates an existing database record.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-7 \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`data`\n\n`XOR<UserUpdateInput`  \n`UserUncheckedUpdateInput>`\n\n**Yes**\n\nWraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional.\n\n`where`\n\n`UserWhereUniqueInput`\n\n**Yes**\n\nWraps all _unique_ fields of a model so that individual records can be selected.  \nFrom version 4.5.0, this type wraps all fields of a model. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-on-non-unique-fields-with-userwhereuniqueinput)\n\n[`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select)\n\n`XOR<UserSelect, null>`\n\nNo\n\n[Specifies which properties to include](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields) on the returned object.\n\n[`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include)\n\n`XOR<UserInclude, null>`\n\nNo\n\n[Specifies which relations should be eagerly loaded](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries) on the returned object.\n\n[`omit`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#omit-preview)\n\n`XOR<UserOmit, null>`\n\nNo\n\nSpecifies which properties to exclude on the returned object. In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.13.0.\n\n`relationLoadStrategy`\n\n`'join'` or `'query'`\n\nNo\n\n**Default: `join`**. Specifies the [load strategy](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-load-strategies-preview) for a relation query. Only available in combination with `include` (or `select` on a relation field). In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.9.0.\n\n#### Return type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-type-4 \"Direct link to Return type\")\n\nReturn type\n\nExample\n\nDescription\n\nJavaScript object (typed)\n\n`User`\n\nJavaScript object (plain)\n\n`{ name: \"Alice Wonderland\" }`\n\nUse `select` and `include` to determine which fields to return.\n\n`RecordNotFound` exception\n\nException is thrown if record does not exist.\n\n*   To perform arithmetic operations on update (add, subtract, multiply, divide), use [atomic updates](https://www.prisma.io/docs/orm/reference/prisma-client-reference#atomic-number-operations) to prevent race conditions.\n*   You can also perform a nested [`update`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-1) - for example, update a user and that user's posts at the same time.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-9 \"Direct link to Examples\")\n\n##### Update the `email` of the `User` record with `id` of `1` to `alice@prisma.io`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-the-email-of-the-user-record-with-id-of-1-to-aliceprismaio \"Direct link to update-the-email-of-the-user-record-with-id-of-1-to-aliceprismaio\")\n\n```\nconst user = await prisma.user.update({  where: { id: 1 },  data: { email: 'alice@prisma.io' },})\n```\n\n### `upsert()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#upsert \"Direct link to upsert\")\n\ninfo\n\nThis section covers the usage of the `upsert()` operation. To learn about using [nested upsert queries](https://www.prisma.io/docs/orm/reference/prisma-client-reference#upsert-1) within `update()`, reference the linked documentation.\n\n`upsert` does the following:\n\n*   If an existing database record satisfies the `where` condition, it updates that record\n*   If no database record satisfies the `where` condition, it creates a new database record\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-8 \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`create`\n\n`XOR<UserCreateInput,`  \n`UserUncheckedCreateInput>`\n\n**Yes**\n\nWraps all the fields of the model so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional.\n\n`update`\n\n`XOR<UserUpdateInput,`  \n`UserUncheckedUpdateInput>`\n\n**Yes**\n\nWraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional.\n\n`where`\n\n`UserWhereUniqueInput`\n\n**Yes**\n\nWraps all _unique_ fields of a model so that individual records can be selected.  \nFrom version 4.5.0, this type wraps all fields of a model. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-on-non-unique-fields-with-userwhereuniqueinput)\n\n[`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select)\n\n`XOR<UserSelect, null>`\n\nNo\n\n[Specifies which properties to include](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields) on the returned object.\n\n[`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include)\n\n`XOR<UserInclude, null>`\n\nNo\n\n[Specifies which relations should be eagerly loaded](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries) on the returned object.\n\n[`omit`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#omit-preview)\n\n`XOR<UserOmit, null>`\n\nNo\n\nSpecifies which properties to exclude on the returned object. In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.13.0\n\n`relationLoadStrategy`\n\n`'join'` or `'query'`\n\nNo\n\n**Default: `join`**. Specifies the [load strategy](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-load-strategies-preview) for a relation query. Only available in combination with `include` (or `select` on a relation field). In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.9.0.\n\n#### Return type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-type-5 \"Direct link to Return type\")\n\nReturn type\n\nExample\n\nDescription\n\nJavaScript object (typed)\n\n`User`\n\nJavaScript object (plain)\n\n`{ name: \"Alice Wonderland\" }`\n\nUse `select` and `include` to determine which fields to return.\n\n*   To perform arithmetic operations on update (add, subtract, multiply, divide), use [atomic updates](https://www.prisma.io/docs/orm/reference/prisma-client-reference#atomic-number-operations) to prevent race conditions.\n*   If two or more upsert operations happen at the same time and the record doesn't already exist, then a race condition might happen. As a result, one or more of the upsert operations might throw a unique key constraint error. Your application code can catch this error and retry the operation. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#unique-key-constraint-errors-on-upserts).\n*   From version 4.6.0, Prisma ORM hands over upsert queries to the database where possible. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#database-upserts).\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-10 \"Direct link to Examples\")\n\n##### Update (if exists) or create a new `User` record with an `email` of `alice@prisma.io`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-if-exists-or-create-a-new-user-record-with-an-email-of-aliceprismaio \"Direct link to update-if-exists-or-create-a-new-user-record-with-an-email-of-aliceprismaio\")\n\n```\nconst user = await prisma.user.upsert({  where: { id: 1 },  update: { email: 'alice@prisma.io' },  create: { email: 'alice@prisma.io' },})\n```\n\n#### Unique key constraint errors on upserts[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#unique-key-constraint-errors-on-upserts \"Direct link to Unique key constraint errors on upserts\")\n\n##### Problem[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#problem \"Direct link to Problem\")\n\nIf multiple upsert operations happen at the same time and the record doesn't already exist, then one or more of the operations might return a [unique key constraint error](https://www.prisma.io/docs/orm/reference/error-reference#p2002).\n\n##### Cause[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#cause \"Direct link to Cause\")\n\nWhen Prisma Client does an upsert, it first checks whether that record already exists in the database. To make this check, Prisma Client performs a read operation with the `where` clause from the upsert operation. This has two possible outcomes, as follows:\n\n*   If the record does not exist, then Prisma Client creates that record.\n*   If the record exists, then Prisma Client updates it.\n\nWhen your application tries to perform two or more concurrent upsert operations, then a race condition might happen where two or more operations do not find the record and therefore try to create that record. In this situation, one of the operations successfully creates the new record but the other operations fail and return a unique key constraint error.\n\n##### Solution[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#solution \"Direct link to Solution\")\n\nHandle the P2002 error in your application code. When it occurs, retry the upsert operation to update the row.\n\n#### Database upserts[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#database-upserts \"Direct link to Database upserts\")\n\nWhere possible, Prisma Client hands over an `upsert` query to the database. This is called a _database upsert_.\n\nDatabase upserts have the following advantages:\n\n*   They are faster than upserts handled by Prisma Client\n*   [Unique key constraint errors](https://www.prisma.io/docs/orm/reference/prisma-client-reference#unique-key-constraint-errors-on-upserts) cannot happen\n\nPrisma Client uses a database upsert automatically when [specific criteria](https://www.prisma.io/docs/orm/reference/prisma-client-reference#database-upsert-query-criteria) are met. When these criteria are not met, Prisma Client handles the `upsert`.\n\nTo use a database upsert, Prisma Client sends the SQL construction [`INSERT ... ON CONFLICT SET .. WHERE`](https://www.prisma.io/dataguide/postgresql/inserting-and-modifying-data/insert-on-conflict) to the database.\n\n##### Database upsert prerequisites[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#database-upsert-prerequisites \"Direct link to Database upsert prerequisites\")\n\nPrisma Client can use database upserts if your stack meets the following criteria:\n\n*   You use Prisma ORM version 4.6.0 or later\n*   Your application uses a CockroachDB, PostgreSQL, or SQLite data source\n\n##### Database upsert query criteria[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#database-upsert-query-criteria \"Direct link to Database upsert query criteria\")\n\nPrisma Client uses a database upsert for an `upsert` query when the query meets the following criteria:\n\n*   There are no nested queries in the `upsert`'s `create` and `update` [options](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-7)\n*   The query does _not_ include a selection that uses a [nested read](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads)\n*   The query modifies only one model\n*   There is only one unique field in the `upsert`'s `where` option\n*   The unique field in the `where` option and the unique field in the `create` option have the same value\n\nIf your query does not meet these criteria, then Prisma Client handles the upsert itself.\n\n##### Database upsert examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#database-upsert-examples \"Direct link to Database upsert examples\")\n\nThe following examples use this schema:\n\n```\nmodel User {  id           Int    @id  profileViews Int  userName     String @unique  email        String  @@unique([id, profileViews])}\n```\n\nThe following `upsert` query meets all of the criteria, so Prisma Client uses a database upsert.\n\n```\nprisma.user.upsert({  where: {    userName: 'Alice',  },  create: {    id: 1,    profileViews: 1,    userName: 'Alice',    email: 'alice@prisma.io',  },  update: {    email: 'updated@example.com',  },})\n```\n\nIn this situation, Prisma uses the following SQL query:\n\n```\nINSERT INTO \"public\".\"User\" (\"id\",\"profileViews\",\"userName\",\"email\") VALUES ($1,$2,$3,$4)ON CONFLICT (\"userName\") DO UPDATESET \"email\" = $5 WHERE (\"public\".\"User\".\"userName\" = $6 AND 1=1) RETURNING \"public\".\"User\".\"id\", \"public\".\"User\".\"profileViews\", \"public\".\"User\".\"userName\", \"public\".\"User\".\"email\"\n```\n\nThe following query has multiple unique values in the `where` clause, so Prisma Client does _not_ use a database upsert:\n\n```\nprisma.User.upsert({  where: {    userName: 'Alice',    profileViews: 1,    id: 1,  },  create: {    id: 1,    profileViews: 1,    userName: 'Alice',    email: 'alice@prisma.io',  },  update: {    email: 'updated@example.com',  },})\n```\n\nIn the following query, the values for `userName` in the `where` and `create` options are different, so Prisma Client does _not_ use a database upsert.\n\n```\nprisma.User.upsert({  where: {    userName: 'Alice',  },  create: {    id: 1,    profileViews: 1,    userName: 'AliceS',    email: 'alice@prisma.io',  },  update: {    email: 'updated@example.com',  },})\n```\n\nIn the following query, the selection on the `title` field in `posts` is a nested read, so Prisma Client does _not_ use a database upsert.\n\n```\nprisma.user.upsert({  select: {    email: true,    id: true,    posts: {      select: {        title: true,      },    },  },  where: {    userName: 'Alice',  },  create: {    id: 1,    profileViews: 1,    userName: 'Alice',    email: 'alice@prisma.io',  },  update: {    email: 'updated@example.com',  },})\n```\n\n### `delete()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#delete \"Direct link to delete\")\n\n`delete` deletes an existing database record. You can delete a record:\n\n*   By _ID_\n*   By a _unique_ attribute\n\nTo delete records that match a certain criteria, use [`deleteMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#deletemany) with a filter.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-9 \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`where`\n\n`UserWhereUniqueInput`\n\n**Yes**\n\nWraps all _unique_ fields of a model so that individual records can be selected.  \nFrom version 4.5.0, this type wraps all fields of a model. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-on-non-unique-fields-with-userwhereuniqueinput)\n\n[`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select)\n\n`XOR<UserSelect, null>`\n\nNo\n\n[Specifies which properties to include](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields) on the returned object.\n\n[`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include)\n\n`XOR<UserInclude, null>`\n\nNo\n\n[Specifies which relations should be eagerly loaded](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries) on the returned object.\n\n[`omit`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#omit-preview)\n\n`XOR<UserOmit, null>`\n\nNo\n\nSpecifies which properties to exclude on the returned object. In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.13.0\n\n`relationLoadStrategy`\n\n`'join'` or `'query'`\n\nNo\n\n**Default: `join`**. Specifies the [load strategy](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-load-strategies-preview) for a relation query. Only available in combination with `include` (or `select` on a relation field). In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.9.0.\n\n#### Return type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-type-6 \"Direct link to Return type\")\n\nReturn type\n\nExample\n\nDescription\n\nJavaScript object (typed)\n\n`User`\n\nThe `User` record that was deleted.\n\nJavaScript object (plain)\n\n`{ name: \"Alice Wonderland\" }`\n\nData from the `User` record that was deleted. Use `select` and `include` to determine which fields to return.\n\n`RecordNotFound` exception\n\nThrows an exception if record does not exist.\n\n*   To delete multiple records based on some criteria (for example, all `User` records with a `prisma.io` email address, use `deleteMany`)\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-11 \"Direct link to Examples\")\n\n##### Delete the `User` record with an `id` of `1`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#delete-the-user-record-with-an-id-of-1 \"Direct link to delete-the-user-record-with-an-id-of-1\")\n\n```\nconst user = await prisma.user.delete({  where: { id: 1 },})\n```\n\n##### Delete the `User` record where `email` equals `else@prisma.io`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#delete-the-user-record-where-email-equals-elseprismaio \"Direct link to delete-the-user-record-where-email-equals-elseprismaio\")\n\nThe following query deletes a specific user record and uses `select` to return the `name` and `email` of the deleted user:\n\n```\nconst deleteUser = await prisma.user.delete({  where: {    email: 'elsa@prisma.io',  },  select: {    email: true,    name: true,  },})\n```\n\n### `createMany()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany \"Direct link to createmany\")\n\n`createMany` creates multiple records in a transaction.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-10 \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`data`\n\n`Enumerable<UserCreateManyInput>`\n\n**Yes**\n\nWraps all the model fields in a type so that they can be provided when creating new records. Fields that are marked as optional or have default values in the datamodel are optional.\n\n`skipDuplicates?`\n\n`boolean`\n\nNo\n\nDo not insert records with unique fields or ID fields that already exist. Only supported by databases that support [`ON CONFLICT DO NOTHING`](https://www.postgresql.org/docs/9.5/sql-insert.html#SQL-ON-CONFLICT). This excludes MongoDB and SQLServer\n\n#### Return type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-type-7 \"Direct link to Return type\")\n\nReturn type\n\nExample\n\nDescription\n\n`BatchPayload`\n\n`{ count: 3 }`\n\nA count of the number of records created.\n\n*   As of Prisma ORM version 5.12.0, `createMany()` is now supported by SQLite.\n*   The `skipDuplicates` option is not supported by MongoDB, SQLServer, or SQLite.\n*   You **cannot** create or connect relations by using nested `create`, `createMany`, `connect`, `connectOrCreate` queries inside a top-level `createMany()` query.\n*   You can use a nested [`createMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany-1) query inside an [`update()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update) or [`create()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create) query - for example, add a `User` and two `Post` records with a nested `createMany` at the same time.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-12 \"Direct link to Examples\")\n\n##### Create several new users[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-several-new-users \"Direct link to Create several new users\")\n\n```\nconst users = await prisma.user.createMany({  data: [    { name: 'Sonali', email: 'sonali@prisma.io' },    { name: 'Alex', email: 'alex@prisma.io' },  ],})\n```\n\n### `createManyAndReturn()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmanyandreturn \"Direct link to createmanyandreturn\")\n\n`createManyAndReturn` creates multiple records and returns the resulting objects.\n\ninfo\n\n`createManyAndReturn()` is only available in Prisma ORM version 5.14.0 and up. `createManyAndReturn()` is only available for PostgreSQL, CockroachDB, and SQLite.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-11 \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`data`\n\n`Enumerable<UserCreateManyInput>`\n\n**Yes**\n\nWraps all the model fields in a type so that they can be provided when creating new records. Fields that are marked as optional or have default values in the datamodel are optional.\n\n[`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select)\n\n`XOR<UserSelect, null>`\n\nNo\n\n[Specifies which properties to include](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields) on the returned objects.\n\n[`omit`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#omit-preview)\n\n`XOR<UserOmit, null>`\n\nNo\n\nSpecifies which properties to exclude on the returned objects. In [Preview](https://www.prisma.io/docs/orm/more/releases#preview) since 5.13.0. Mutually exclusive with `select`.\n\n[`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include)\n\n`XOR<UserInclude, null>`\n\nNo\n\n[Specifies which relations should be eagerly loaded](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries) on the returned objects.\n\n`skipDuplicates?`\n\n`boolean`\n\nNo\n\nDo not insert records with unique fields or ID fields that already exist. Only supported by databases that support [`ON CONFLICT DO NOTHING`](https://www.postgresql.org/docs/9.5/sql-insert.html#SQL-ON-CONFLICT). This excludes MongoDB and SQLServer\n\n*   The `skipDuplicates` option is not supported by SQLite.\n*   You **cannot** create or connect relations by using nested `create`, `createMany`, `connect`, `connectOrCreate` queries inside a top-level `createManyAndReturn()` query.\n*   When relations are included via `include`, a separate query is generated per relation.\n*   `relationLoadStrategy: join` is not supported.\n\n#### Return type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-type-8 \"Direct link to Return type\")\n\nReturn type\n\nExample\n\nDescription\n\nJavaScript array object (typed)\n\n`User[]`\n\nJavaScript array object (plain)\n\n`[{ name: \"Sonali\" }]`\n\nUse `select`, `omit` and `include` to determine which fields to return.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-13 \"Direct link to Examples\")\n\n##### Create and return several new users[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-and-return-several-new-users \"Direct link to Create and return several new users\")\n\n```\nconst users = await prisma.user.createManyAndReturn({  data: [    { name: 'Sonali', email: 'sonali@prisma.io' },    { name: 'Alex', email: 'alex@prisma.io' },  ],})\n```\n\n### `updateMany()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#updatemany \"Direct link to updatemany\")\n\n`updateMany` updates a batch of existing database records in bulk and returns the number of updated records.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-12 \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`data`\n\n`XOR<UserUpdateManyMutationInput,`  \n`UserUncheckedUpdateManyInput>`\n\n**Yes**\n\nWraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional on `data`.\n\n`where`\n\n`UserWhereInput`\n\nNo\n\nWraps _all_ fields of a model so that the list can be filtered by any property. If you do not filter the list, all records will be updated.\n\n#### Return type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-type-9 \"Direct link to Return type\")\n\nReturn type\n\nExample\n\nDescription\n\n`BatchPayload`\n\n`{ count: 4 }`\n\nThe count of updated records.\n\n```\nexport type BatchPayload = {  count: number}\n```\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-14 \"Direct link to Examples\")\n\n##### Update all `User` records where the `name` is `Alice` to `ALICE`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-all-user-records-where-the-name-is-alice-to-alice \"Direct link to update-all-user-records-where-the-name-is-alice-to-alice\")\n\n```\nconst updatedUserCount = await prisma.user.updateMany({  where: { name: 'Alice' },  data: { name: 'ALICE' },})\n```\n\n##### Update all `User` records where the `email` contains `prisma.io` and at least one related `Post` has more than 10 likes[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-all-user-records-where-the-email-contains-prismaio-and-at-least-one-related-post-has-more-than-10-likes \"Direct link to update-all-user-records-where-the-email-contains-prismaio-and-at-least-one-related-post-has-more-than-10-likes\")\n\n```\nconst updatedUserCount = await prisma.user.updateMany({  where: {    email: {      contains: 'prisma.io',    },    posts: {      some: {        likes: {          gt: 10,        },      },    },  },  data: {    role: 'USER',  },})\n```\n\n### `deleteMany()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#deletemany \"Direct link to deletemany\")\n\n`deleteMany` deletes multiple records in a transaction.\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-13 \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`where`\n\n`UserWhereInput`\n\nNo\n\nWraps _all_ fields of a model so that the list can be filtered by any field.\n\n#### Return type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-type-10 \"Direct link to Return type\")\n\nReturn type\n\nExample\n\nDescription\n\n`BatchPayload`\n\n`{ count: 4 }`\n\nThe count of deleted records.\n\n```\nexport type BatchPayload = {  count: number}\n```\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-15 \"Direct link to Examples\")\n\n##### Delete all `User` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#delete-all-user-records \"Direct link to delete-all-user-records\")\n\n```\nconst deletedUserCount = await prisma.user.deleteMany({})\n```\n\n##### Delete all `User` records where the `name` is `Alice`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#delete-all-user-records-where-the-name-is-alice \"Direct link to delete-all-user-records-where-the-name-is-alice\")\n\n```\nconst deletedUserCount = await prisma.user.deleteMany({  where: { name: 'Alice' },})\n```\n\nSee [Filter conditions and operators](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions-and-operators) for examples of how to filter the records to delete.\n\n### `count()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#count \"Direct link to count\")\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-14 \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`where`\n\n`UserWhereInput`\n\nNo\n\nWraps _all_ model fields in a type so that the list can be filtered by any property.\n\n`orderBy`\n\n`XOR<Enumerable<PostOrder`  \n`ByInput>, PostOrderByInput>`\n\nNo\n\nLets you order the returned list by any property.\n\n`cursor`\n\n`UserWhereUniqueInput`\n\nNo\n\nSpecifies the position for the list (the value typically specifies an `id` or another unique value).\n\n`take`\n\n`number`\n\nNo\n\nSpecifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned)\n\n`skip`\n\n`number`\n\nNo\n\nSpecifies how many of the returned objects in the list should be skipped.\n\n#### Return type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-type-11 \"Direct link to Return type\")\n\nReturn type\n\nExample\n\nDescription\n\n`number`\n\n`29`\n\nThe count of records.\n\n`UserCountAggregateOutputType`\n\n`{ _all: 27, name: 10 }`\n\nReturned if `select` is used.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-16 \"Direct link to Examples\")\n\n##### Count all `User` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#count-all-user-records \"Direct link to count-all-user-records\")\n\n```\nconst result = await prisma.user.count()\n```\n\n##### Count all `User` records with at least one published `Post`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#count-all-user-records-with-at-least-one-published-post \"Direct link to count-all-user-records-with-at-least-one-published-post\")\n\n```\nconst result = await prisma.user.count({  where: {    post: {      some: {        published: true,      },    },  },})\n```\n\n##### Use `select` to perform three separate counts[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#use-select-to-perform-three-separate-counts \"Direct link to use-select-to-perform-three-separate-counts\")\n\nThe following query returns:\n\n*   A count of all records (`_all`)\n*   A count of all records with non-`null` `name` fields\n*   A count of all records with non-`null` `city` fields\n\n```\nconst c = await prisma.user.count({  select: {    _all: true,    city: true,    name: true,  },})\n```\n\n### `aggregate()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#aggregate \"Direct link to aggregate\")\n\nSee also: [Aggregation, grouping, and summarizing](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#aggregate)\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-15 \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`where`\n\n`UserWhereInput`\n\nNo\n\nWraps _all_ model fields in a type so that the list can be filtered by any property.\n\n`orderBy`\n\n`XOR<Enumerable<UserOrderByInput>,`  \n`UserOrderByInput>`\n\nNo\n\nLets you order the returned list by any property.\n\n`cursor`\n\n`UserWhereUniqueInput`\n\nNo\n\nSpecifies the position for the list (the value typically specifies an `id` or another unique value).\n\n`take`\n\n`number`\n\nNo\n\nSpecifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned)\n\n`skip`\n\n`number`\n\nNo\n\nSpecifies how many of the returned objects in the list should be skipped.\n\n`_count`\n\n`true`\n\nNo\n\nReturns a count of matching records or non-`null` fields.\n\n`_avg`\n\n`UserAvgAggregateInputType`\n\nNo\n\nReturns an average of all values of the specified field.\n\n`_sum`\n\n`UserSumAggregateInputType`\n\nNo\n\nReturns the sum of all values of the specified field.\n\n`_min`\n\n`UserMinAggregateInputType`\n\nNo\n\nReturns the smallest available value of the specified field.\n\n`_max`\n\n`UserMaxAggregateInputType`\n\nNo\n\nReturns the largest available value of the specified field.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-17 \"Direct link to Examples\")\n\n##### Return `_min`, `_max`, and `_count` of `profileViews` of all `User` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-_min-_max-and-_count-of-profileviews-of-all-user-records \"Direct link to return-_min-_max-and-_count-of-profileviews-of-all-user-records\")\n\n```\nconst minMaxAge = await prisma.user.aggregate({  _count: {    _all: true,  },  _max: {    profileViews: true,  },  _min: {    profileViews: true,  },})\n```\n\n##### Return `_sum` of all `profileViews` for all `User` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-_sum-of-all-profileviews-for-all-user-records \"Direct link to return-_sum-of-all-profileviews-for-all-user-records\")\n\n```\nconst setValue = await prisma.user.aggregate({  _sum: {    profileViews: true,  },})\n```\n\n### `groupBy()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#groupby \"Direct link to groupby\")\n\nSee also: [Aggregation, grouping, and summarizing](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#group-by)\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#options-16 \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`where`\n\n`UserWhereInput`\n\nNo\n\nWraps _all_ model fields in a type so that the list can be filtered by any property.\n\n`orderBy`\n\n`XOR<Enumerable<UserOrderByInput>,`  \n`UserOrderByInput>`\n\nNo\n\nLets you order the returned list by any property that is also present in `by`.\n\n`by`\n\n`Array<UserScalarFieldEnum>` | `string`\n\nNo\n\nSpecifies the field or combination of fields to group records by.\n\n`having`\n\n`UserScalarWhereWithAggregatesInput`\n\nNo\n\nAllows you to filter groups by an aggregate value - for example, only return groups _having_ an average age less than 50.\n\n`take`\n\n`number`\n\nNo\n\nSpecifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned)\n\n`skip`\n\n`number`\n\nNo\n\nSpecifies how many of the returned objects in the list should be skipped.\n\n`_count`\n\n`true` | `UserCountAggregateInputType`\n\nNo\n\nReturns a count of matching records or non-`null` fields.\n\n`_avg`\n\n`UserAvgAggregateInputType`\n\nNo\n\nReturns an average of all values of the specified field.\n\n`_sum`\n\n`UserSumAggregateInputType`\n\nNo\n\nReturns the sum of all values of the specified field.\n\n`_min`\n\n`UserMinAggregateInputType`\n\nNo\n\nReturns the smallest available value of the specified field.\n\n`_max`\n\n`UserMaxAggregateInputType`\n\nNo\n\nReturns the largest available value of the specified field.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-18 \"Direct link to Examples\")\n\n##### Group by `country`/`city` where the average `profileViews` is greater than `200`, and return the `_sum` of `profileViews` for each group[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#group-by-countrycity-where-the-average-profileviews-is-greater-than-200-and-return-the-_sum-of-profileviews-for-each-group \"Direct link to group-by-countrycity-where-the-average-profileviews-is-greater-than-200-and-return-the-_sum-of-profileviews-for-each-group\")\n\nThe query also returns a count of `_all` records in each group, and all records with non-`null` `city` field values in each group.\n\n```\nconst groupUsers = await prisma.user.groupBy({  by: ['country', 'city'],  _count: {    _all: true,    city: true,  },  _sum: {    profileViews: true,  },  orderBy: {    country: 'desc',  },  having: {    profileViews: {      _avg: {        gt: 200,      },    },  },})\n```\n\n### `findRaw()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findraw \"Direct link to findraw\")\n\nSee: [Raw database access (`findRaw()`)](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#findraw).\n\n### `aggreagateRaw()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#aggreagateraw \"Direct link to aggreagateraw\")\n\nSee: [Raw database access (`aggreagateRaw()`)](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#aggregateraw).\n\n## Model query options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#model-query-options \"Direct link to Model query options\")\n\n### `select`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select \"Direct link to select\")\n\n`select` defines which fields are included in the object that Prisma Client returns. See: [Select fields and include relations](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields) .\n\n*   You cannot combine `select` and `include` on the same level.\n*   In [3.0.1](https://github.com/prisma/prisma/releases/3.0.1) and later, you can [select a `_count` of relations](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select-a-_count-of-relations).\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-19 \"Direct link to Examples\")\n\n##### Select the `name` and `profileViews` fields of a single `User` record[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select-the-name-and-profileviews-fields-of-a-single-user-record \"Direct link to select-the-name-and-profileviews-fields-of-a-single-user-record\")\n\n```\nconst result = await prisma.user.findUnique({  where: { id: 1 },  select: {    name: true,    profileViews: true,  },})\n```\n\n##### Select the `email` and `role` fields of a multiple `User` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select-the-email-and-role-fields-of-a-multiple-user-records \"Direct link to select-the-email-and-role-fields-of-a-multiple-user-records\")\n\n```\nconst result = await prisma.user.findMany({  select: {    email: true,    role: true,  },})\n```\n\n##### Select a `_count` of relations[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select-a-_count-of-relations \"Direct link to select-a-_count-of-relations\")\n\n```\nconst usersWithCount = await prisma.user.findMany({  select: {    _count: {      select: { posts: true },    },  },})\n```\n\n##### Select the 'id' and 'title' fields of related `Post` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select-the-id-and-title-fields-of-related-post-records \"Direct link to select-the-id-and-title-fields-of-related-post-records\")\n\n```\nconst result = await prisma.user.findMany({  select: {    id: true,    name: true,    posts: {      select: {        id: true,        title: true,      },    },  },})\n```\n\n##### `include` inside `select`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include-inside-select \"Direct link to include-inside-select\")\n\n```\nconst result = await prisma.user.findMany({  select: {    id: true,    name: true,    posts: {      include: {        author: true,      },    },  },})\n```\n\n#### Generated types for `select`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#generated-types-for-select \"Direct link to generated-types-for-select\")\n\nThe following example demonstrates how to use the [`validator`](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator) with `select`:\n\n```\nconst selectNameEmailNotPosts = Prisma.validator<Prisma.UserSelect>()({  name: true,  email: true,  posts: false,})\n```\n\n### `include`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include \"Direct link to include\")\n\n`include` defines which relations are included in the result that Prisma Client returns. See: [Select fields and include relations](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields) .\n\n*   In [3.0.1](https://github.com/prisma/prisma/releases/3.0.1) and later, you can [`include` a `_count` of relations](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include-a-_count-of-relations)\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-20 \"Direct link to Examples\")\n\n##### Include the `posts` and `profile` relation when loading `User` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include-the-posts-and-profile-relation-when-loading-user-records \"Direct link to include-the-posts-and-profile-relation-when-loading-user-records\")\n\n```\nconst users = await prisma.user.findMany({  include: {    posts: true, // Returns all fields for all posts    profile: true, // Returns all Profile fields  },})\n```\n\n##### Include the `posts` relation on the returned objects when creating a new `User` record with two `Post` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include-the-posts-relation-on-the-returned-objects-when-creating-a-new-user-record-with-two-post-records \"Direct link to include-the-posts-relation-on-the-returned-objects-when-creating-a-new-user-record-with-two-post-records\")\n\n```\nconst user = await prisma.user.create({  data: {    email: 'alice@prisma.io',    posts: {      create: [        { title: 'This is my first post' },        { title: 'Here comes a second post' },      ],    },  },  include: { posts: true }, // Returns all fields for all posts})\n```\n\n#### Generated types for `include`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#generated-types-for-include \"Direct link to generated-types-for-include\")\n\nThe following example demonstrates how to use the [`validator`](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator) with `include`:\n\n```\nconst includePosts = Prisma.validator<Prisma.UserInclude>()({  posts: true,})\n```\n\n##### Include a `_count` of relations[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include-a-_count-of-relations \"Direct link to include-a-_count-of-relations\")\n\n```\nconst usersWithCount = await prisma.user.findMany({  include: {    _count: {      select: { posts: true },    },  },})\n```\n\n### `omit` (Preview)[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#omit-preview \"Direct link to omit-preview\")\n\n`omit` defines which fields are excluded in the object that Prisma Client returns.\n\nBecause the `omit` option is currently in Preview, you need to enable it via the `omitApi` preview feature flag in your Prisma schema file:\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"omitApi\"]}\n```\n\nAfter adding this flag, you need to run `prisma generate` again to re-generate Prisma Client.\n\n*   You cannot combine `omit` and `select` since they serve opposite purposes\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-21 \"Direct link to Examples\")\n\n##### Omit the `password` field from all `User` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#omit-the-password-field-from-all-user-records \"Direct link to omit-the-password-field-from-all-user-records\")\n\n```\nconst result = await prisma.user.findMany({  omit: {    password: true,  },})\n```\n\n##### Omit the `title` fields from all `User`'s `posts` relation[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#omit-the-title-fields-from-all-users-posts-relation \"Direct link to omit-the-title-fields-from-all-users-posts-relation\")\n\n```\nconst results = await prisma.user.findMany({  omit: {    password: true,  },  include: {    posts: {      omit: {        title: true,      },    },  },})\n```\n\n#### Generated types for `omit`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#generated-types-for-omit \"Direct link to generated-types-for-omit\")\n\nThe following example demonstrates how to use the [`validator`](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator) with `omit`:\n\n```\nconst omitPassword = Prisma.validator<Prisma.UserOmit>()({  password: true,})\n```\n\n### `relationLoadStrategy` (Preview)[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#relationloadstrategy-preview \"Direct link to relationloadstrategy-preview\")\n\n`relationLoadStrategy` specifies how a relation should be loaded from the database. It has two possible values:\n\n*   `join` (default): Uses a database-level `LATERAL JOIN` (PostgreSQL) or correlated subqueries (MySQL) and fetches all data with a single query to the database.\n*   `query`: Sends multiple queries to the database (one per table) and joins them on the application level.\n\n> **Note**: Once `relationLoadStrategy` moves from [Preview](https://www.prisma.io/docs/orm/more/releases#preview) into [General Availability](https://www.prisma.io/docs/orm/more/releases#generally-available-ga), `join` will universally become the default for all relation queries.\n\nYou can learn more about join strategies [here](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-load-strategies-preview).\n\nBecause the `relationLoadStrategy` option is currently in Preview, you need to enable it via the `relationJoins` preview feature flag in your Prisma schema file:\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"relationJoins\"]}\n```\n\nAfter adding this flag, you need to run `prisma generate` again to re-generate Prisma Client. This feature is currently available on PostgreSQL, CockroachDB and MySQL.\n\n*   In most situations, the default `join` strategy will be more effective. Use `query` if you want to save resources on your database server or if you profiling shows that the application-level join is more performant.\n*   You can only specify the `relationLoadStrategy` on the top-level in your query. The top-level choice will affect all nested sub-queries.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-22 \"Direct link to Examples\")\n\n##### Load the `posts` relation via a database-level JOIN when using `include`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#load-the-posts-relation-via-a-database-level-join-when-using-include \"Direct link to load-the-posts-relation-via-a-database-level-join-when-using-include\")\n\n```\nconst users = await prisma.user.findMany({  relationLoadStrategy: 'join',  include: {    posts: true,  },})\n```\n\n##### Load the `posts` relation via a database-level JOIN when using `select`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#load-the-posts-relation-via-a-database-level-join-when-using-select \"Direct link to load-the-posts-relation-via-a-database-level-join-when-using-select\")\n\n```\nconst users = await prisma.user.findMany({  relationLoadStrategy: 'join',  select: {    posts: true,  },})\n```\n\n### `where`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#where \"Direct link to where\")\n\n`where` defines one or more [filters](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions-and-operators), and can be used to filter on record properties (like a user's email address) or related record properties (like a user's top 10 most recent post titles).\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-23 \"Direct link to Examples\")\n\n```\nconst results = await prisma.user.findMany({  where: {    email: {      endsWith: 'prisma.io',    },  },})\n```\n\n#### Generated types for `where`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#generated-types-for-where \"Direct link to generated-types-for-where\")\n\nThe following examples demonstrate how to use the [`validator`](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator) with `where`:\n\n*   `UserWhereInput`\n    \n    ```\n    // UserWhereInputconst whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({  name: 'Rich',})// It can be combined with conditional operators tooconst whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({  name: 'Rich',  AND: [    {      email: {        contains: 'rich@boop.com',      },    },  ],})\n    ```\n    \n*   `UserWhereUniqueInput` This type works by exposing any unique fields on the model. A field assigned `@id` is considered unique, as is one assigned `@unique`.\n    \n    From version 4.5.0, this type exposes all fields on the model. This means that when you filter for a single record based on a unique field, you can check additional non-unique and unique fields at the same time. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-on-non-unique-fields-with-userwhereuniqueinput).\n    \n    ```\n    // UserWhereUniqueInputconst whereEmailIsUnique = Prisma.validator<Prisma.UserWhereUniqueInput>()({  email: 'rich@boop.com',})\n    ```\n    \n*   `PostScalarWhereInput`\n    \n    ```\n    const whereScalarTitleIs = Prisma.validator<Prisma.PostScalarWhereInput>()({  title: 'boop',})\n    ```\n    \n*   `PostUpdateWithWhereUniqueWithoutAuthorInput` - This type accepts a unique `where` field (an `@id` or another assigned `@unique`) and updates any field on the `Post` model except the `Author`. The `Author` is the scalar field on the `Post` model.\n    \n    ```\n    const updatePostByIdWithoutAuthor =  Prisma.validator<Prisma.PostUpdateWithWhereUniqueWithoutAuthorInput>()({    where: {      id: 1,    },    data: {      content: 'This is some updated content',      published: true,      title: 'This is a new title',    },  })\n    ```\n    \n*   `PostUpsertWithWhereUniqueWithoutAuthorInput` - This type will update the `Post` records title field where the id matches, if it doesn't exist it will create it instead.\n    \n    ```\n    const updatePostTitleOrCreateIfNotExist =  Prisma.validator<Prisma.PostUpsertWithWhereUniqueWithoutAuthorInput>()({    where: {      id: 1,    },    update: {      title: 'This is a new title',    },    create: {      id: 1,      title: 'If the title doesnt exist, then create one with this text',    },  })\n    ```\n    \n*   `PostUpdateManyWithWhereWithoutAuthorInput` - This type will update all `Post` records where published is set to false.\n    \n    ```\n    const publishAllPosts =  Prisma.validator<Prisma.PostUpdateManyWithWhereWithoutAuthorInput>()({    where: {      published: {        equals: false,      },    },    data: {      published: true,    },  })\n    ```\n    \n\n### `orderBy`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#orderby \"Direct link to orderby\")\n\nSorts a list of records. See also: [Sorting](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting)\n\n*   In [2.16.0](https://github.com/prisma/prisma/releases/2.16.0) and later, you can [order by relation fields](https://www.prisma.io/docs/orm/reference/prisma-client-reference#sort-post-by-the-related-user-records-name) - for example, order posts by the author's name.\n    \n*   In [3.5.0](https://github.com/prisma/prisma/releases/3.5.0) and later, in PostgreSQL you can [order by relevance](https://www.prisma.io/docs/orm/reference/prisma-client-reference#sort-post-by-relevance-of-the-title). For details, see [Sort by relevance](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-by-relevance-postgresql-and-mysql).\n    \n*   In [4.1.0](https://github.com/prisma/prisma/releases/4.1.0) and later, you can [sort `null` records first or last](https://www.prisma.io/docs/orm/reference/prisma-client-reference#sort-post-by-the-related-user-records-name-with-null-records-first). For details, see [Sort with nulls first or last](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-with-null-records-first-or-last).\n    \n\n#### Inputs for `sort` argument[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#inputs-for-sort-argument \"Direct link to inputs-for-sort-argument\")\n\nName\n\nDescription\n\n`asc`\n\nSort ascending (A → Z)\n\n`desc`\n\nSort descending (Z → A)\n\n#### Inputs for `nulls` argument[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#inputs-for-nulls-argument \"Direct link to inputs-for-nulls-argument\")\n\nNote:\n\n*   This argument is optional.\n*   It is for use on optional [scalar](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) fields only. If you try to sort by nulls on a required or [relation](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#relation-fields) field, Prisma Client throws a [P2009 error](https://www.prisma.io/docs/orm/reference/error-reference#p2009).\n*   It is available in version 4.1.0 and later, as a preview feature. See [sort with nulls first or last](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-with-null-records-first-or-last) for details of how to enable the feature.\n\nName\n\nDescription\n\n`first`\n\nSort with `null` values first.\n\n`last`\n\nSort with `null` values last.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-24 \"Direct link to Examples\")\n\n##### Sort `User` by `email` field[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#sort-user-by-email-field \"Direct link to sort-user-by-email-field\")\n\nThe following example returns all `User` records sorted by `email` ascending:\n\n```\nconst users = await prisma.user.findMany({  orderBy: {    email: 'asc',  },})\n```\n\nThe following example returns all `User` records sorted by `email` descending:\n\n```\nconst users = await prisma.user.findMany({  orderBy: {    email: 'desc',  },})\n```\n\nThe following query orders posts by user name:\n\n```\nconst posts = await prisma.post.findMany({  orderBy: {    author: {      name: 'asc',    },  },})\n```\n\nThe following query orders posts by user name, with `null` records first:\n\n```\nconst posts = await prisma.post.findMany({  orderBy: {    author: {      name: { sort: 'asc', nulls: 'first' },    },  },})\n```\n\n#### Sort `Post` by relevance of the title[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#sort-post-by-relevance-of-the-title \"Direct link to sort-post-by-relevance-of-the-title\")\n\nwarning\n\nThis feature is available from version 3.5.0 onwards in PostgreSQL and MySQL only. You'll need to use the `fullTextSearch` preview flag to enable this feature.\n\nThe following query orders posts by relevance of the search term `'database'` to the title:\n\n```\nconst posts = await prisma.post.findMany({  orderBy: {    _relevance: {      fields: ['title'],      search: 'database',      sort: 'asc'    },})\n```\n\n#### Sort `User` by the `posts` count[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#sort-user-by-the-posts-count \"Direct link to sort-user-by-the-posts-count\")\n\nThe following query orders users by post count:\n\n```\nconst getActiveusers = await prisma.user.findMany({  orderBy: {    posts: {      count: 'desc',    },  },})\n```\n\n##### Sort `User` by multiple fields - `email` _and_ `role`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#sort-user-by-multiple-fields---email-and-role \"Direct link to sort-user-by-multiple-fields---email-and-role\")\n\nThe following example sorts users by two fields - first `email`, then `role`:\n\n```\nconst users = await prisma.user.findMany({  select: {    email: true,    role: true,  },  orderBy: [    {      email: 'desc',    },    {      role: 'desc',    },  ],})\n```\n\nThe order of sorting parameters matters - the following query sorts by `role`, then `email`. Not the difference in the results:\n\n```\nconst users = await prisma.user.findMany({  select: {    email: true,    role: true,  },  orderBy: [    {      role: 'desc',    },    {      email: 'desc',    },  ],})\n```\n\n##### Sort `User` by `email`, select `name` and `email`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#sort-user-by-email-select-name-and-email \"Direct link to sort-user-by-email-select-name-and-email\")\n\nThe following example returns all the `name` and `email` fields of all `User` records, sorted by `email`:\n\n```\nconst users3 = await prisma.user.findMany({  orderBy: {    email: 'asc',  },  select: {    name: true,    email: true,  },})\n```\n\n##### Sort `User` records by `email` and sort nested `Post` records by `title`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#sort-user-records-by-email-and-sort-nested-post-records-by-title \"Direct link to sort-user-records-by-email-and-sort-nested-post-records-by-title\")\n\nThe following example:\n\n*   Returns all `User` records sorted by `email`\n*   For each `User` record, returns the `title` field of all nested `Post` records sorted by `title`\n\n```\nconst usersWithPosts = await prisma.user.findMany({  orderBy: {    email: 'asc',  },  include: {    posts: {      select: {        title: true,      },      orderBy: {        title: 'asc',      },    },  },})\n```\n\n##### Sort one user's nested list of `Post` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#sort-one-users-nested-list-of-post-records \"Direct link to sort-one-users-nested-list-of-post-records\")\n\nThe following example retrieves a single `User` record by ID, as well as a list of nested `Post` records sorted by `title`:\n\n```\nconst userWithPosts = await prisma.user.findUnique({  where: {    id: 1,  },  include: {    posts: {      orderBy: {        title: 'desc',      },      select: {        title: true,        published: true,      },    },  },})\n```\n\n##### Sort by `enum`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#sort-by-enum \"Direct link to sort-by-enum\")\n\nThe following sorts all `User` records by `role` (an `enum`):\n\n```\nconst sort = await prisma.user.findMany({  orderBy: {    role: 'desc',  },  select: {    email: true,    role: true,  },})\n```\n\n#### Generated types for `orderBy`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#generated-types-for-orderby \"Direct link to generated-types-for-orderby\")\n\nThe following examples demonstrate how to use the [`validator`](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator) with `orderBy`:\n\n*   `UserOrderByInput`\n    \n    ```\n    const orderEmailsByDescending = Prisma.validator<Prisma.UserOrderByInput>()({  email: 'desc',})\n    ```\n    \n\n### `distinct`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#distinct \"Direct link to distinct\")\n\nDeduplicate a list of records from [`findMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findmany) or [`findFirst`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirst). See also: [Aggregation, grouping, and summarizing](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#select-distinct)\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-25 \"Direct link to Examples\")\n\n##### Select distinct on a single field[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select-distinct-on-a-single-field \"Direct link to Select distinct on a single field\")\n\nThe following example returns all distinct `city` fields, and selects only the `city` and `country` fields:\n\n```\nconst distinctCities = await prisma.user.findMany({  select: {    city: true,    country: true,  },  distinct: ['city'],})\n```\n\n##### Select distinct on multiple fields[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select-distinct-on-multiple-fields \"Direct link to Select distinct on multiple fields\")\n\nThe following example returns all distinct `city` _and_ `country` field combinations, and selects only the `city` and `country` fields:\n\n```\nconst distinctCitiesAndCountries = await prisma.user.findMany({  select: {    city: true,    country: true,  },  distinct: ['city', 'country'],})\n```\n\nNote that there is now a \"Paris, Denmark\" in addition to \"Paris, France\":\n\n##### Select distinct in combination with a filter[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select-distinct-in-combination-with-a-filter \"Direct link to Select distinct in combination with a filter\")\n\nThe following example returns all distinct `city` _and_ `country` field combinations where the user's email contains `\"prisma.io\"`, and selects only the `city` and `country` fields:\n\n```\nconst distinctCitiesAndCountries = await prisma.user.findMany({  where: {    email: {      contains: 'prisma.io',    },  },  select: {    city: true,    country: true,  },  distinct: ['city', 'country'],})\n```\n\n## Nested queries[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#nested-queries \"Direct link to Nested queries\")\n\n### `create`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-1 \"Direct link to create-1\")\n\nA nested `create` query adds a new related record or set of records to a parent record. See: [Working with relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries)\n\n*   `create` is available as a nested query when you `create()` (`prisma.user.create(...)`) a new parent record or `update()` (`prisma.user.update(...)`) an existing parent record.\n*   You can use a nested `create` _or_ a nested [`createMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany-1) to create multiple related records. If you require the [`skipDuplicates` query option](https://www.prisma.io/docs/orm/reference/prisma-client-reference#nested-createmany-options) you should use `createMany`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-26 \"Direct link to Examples\")\n\n##### Create a new `User` record with a new `Profile` record[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-a-new-user-record-with-a-new-profile-record \"Direct link to create-a-new-user-record-with-a-new-profile-record\")\n\n```\nconst user = await prisma.user.create({  data: {    email: 'alice@prisma.io',    profile: {      create: { bio: 'Hello World' },    },  },})\n```\n\n##### Create a new `Profile` record with a new `User` record[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-a-new-profile-record-with-a-new-user-record \"Direct link to create-a-new-profile-record-with-a-new-user-record\")\n\n```\nconst user = await prisma.profile.create({  data: {    bio: 'Hello World',    user: {      create: { email: 'alice@prisma.io' },    },  },})\n```\n\n##### Create a new `User` record with a new `Post` record[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-a-new-user-record-with-a-new-post-record \"Direct link to create-a-new-user-record-with-a-new-post-record\")\n\n```\nconst user = await prisma.user.create({  data: {    email: 'alice@prisma.io',    posts: {      create: { title: 'Hello World' },    },  },})\n```\n\n##### Create a new `User` record with two new `Post` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-a-new-user-record-with-two-new-post-records \"Direct link to create-a-new-user-record-with-two-new-post-records\")\n\nBecause it's a one-to-many relation, you can also create multiple `Post` records at once by passing an array to `create`:\n\n```\nconst user = await prisma.user.create({  data: {    email: 'alice@prisma.io',    posts: {      create: [        {          title: 'This is my first post',        },        {          title: 'Here comes a second post',        },      ],    },  },})\n```\n\nNote: You can also use a nested [`createMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany-1) to achieve the same result.\n\n##### Update an existing `User` record by creating a new `Profile` record[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-creating-a-new-profile-record \"Direct link to update-an-existing-user-record-by-creating-a-new-profile-record\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    profile: {      create: { bio: 'Hello World' },    },  },})\n```\n\n##### Update an existing `User` record by creating a new `Post` record[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-creating-a-new-post-record \"Direct link to update-an-existing-user-record-by-creating-a-new-post-record\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    posts: {      create: { title: 'Hello World' },    },  },})\n```\n\n### `createMany`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany-1 \"Direct link to createmany-1\")\n\nA nested `createMany` query adds a new set of records to a parent record. See: [Working with relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries)\n\n*   `createMany` is available as a nested query when you `create()` (`prisma.user.create(...)`) a new parent record or `update()` (`prisma.user.update(...)`) an existing parent record.\n    *   Available in the context of a one-to-many relation — for example, you can `prisma.user.create(...)` a user and use a nested `createMany` to create multiple posts (posts have one user).\n    *   **Not** available in the context of a many-to-many relation — for example, you **cannot** `prisma.post.create(...)` a post and use a nested `createMany` to create categories (many posts have many categories).\n*   You cannot nest an additional `create` or `createMany`.\n*   Allows setting foreign keys directly — for example, setting the `categoryId` on a post.\n*   As of Prisma ORM version 5.12.0, nested `createMany` is supported by SQLite.\n*   You can use a nested `create` _or_ a nested `createMany` to create multiple related records - [if you do not need the `skipDuplicates` query option, you should probably use `create`](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#create-a-single-record-and-multiple-related-records).\n\n#### Options[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#nested-createmany-options \"Direct link to Options\")\n\nName\n\nType\n\nRequired\n\nDescription\n\n`data`\n\n`Enumerable<UserCreateManyInput>`\n\n**Yes**\n\nWraps all the model fields in a type so that they can be provided when creating new records. Fields that are marked as optional or have default values in the datamodel are optional.\n\n`skipDuplicates?`\n\n`boolean`\n\nNo\n\nDo not insert records with unique fields or ID fields that already exist. Only supported by databases that support [`ON CONFLICT DO NOTHING`](https://www.postgresql.org/docs/9.5/sql-insert.html#SQL-ON-CONFLICT). This excludes MongoDB and SQLServer\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-27 \"Direct link to Examples\")\n\n##### Update a `User` and multiple new related `Post` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-a-user-and-multiple-new-related-post-records \"Direct link to update-a-user-and-multiple-new-related-post-records\")\n\n```\nconst user = await prisma.user.update({  where: {    id: 9,  },  data: {    name: 'Elliott',    posts: {      createMany: {        data: [{ title: 'My first post' }, { title: 'My second post' }],      },    },  },})\n```\n\n### `set`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#set \"Direct link to set\")\n\n`set` overwrites the value of a relation - for example, replacing a list of `Post` records with a different list. See: [Working with relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries)\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-28 \"Direct link to Examples\")\n\n##### Update an existing `User` record by disconnecting any previous `Post` records and connecting two other existing ones[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-disconnecting-any-previous-post-records-and-connecting-two-other-existing-ones \"Direct link to update-an-existing-user-record-by-disconnecting-any-previous-post-records-and-connecting-two-other-existing-ones\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    posts: {      set: [{ id: 32 }, { id: 42 }],    },  },})\n```\n\n### `connect`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect \"Direct link to connect\")\n\nA nested `connect` query connects a record to an existing related record by specifying an ID or unique identifier. See: [Working with relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries)\n\n*   `connect` is available as a nested query when you create a new parent record or update an existing parent record.\n    \n*   If the related record does not exist, Prisma Client throws an exception:\n    \n    ```\n    The required connected records were not found. Expected 1 records to be connected, found 0.\n    ```\n    \n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-29 \"Direct link to Examples\")\n\n##### Create a new `Profile` record and connect it to an existing `User` record via unique field[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-a-new-profile-record-and-connect-it-to-an-existing-user-record-via-unique-field \"Direct link to create-a-new-profile-record-and-connect-it-to-an-existing-user-record-via-unique-field\")\n\n```\nconst user = await prisma.profile.create({  data: {    bio: 'Hello World',    user: {      connect: { email: 'alice@prisma.io' },    },  },})\n```\n\n##### Create a new `Profile` record and connect it to an existing `User` record via an ID field[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-a-new-profile-record-and-connect-it-to-an-existing-user-record-via-an-id-field \"Direct link to create-a-new-profile-record-and-connect-it-to-an-existing-user-record-via-an-id-field\")\n\n```\nconst user = await prisma.profile.create({  data: {    bio: 'Hello World',    user: {      connect: { id: 42 }, // sets userId of Profile record    },  },})\n```\n\nIn [2.11.0](https://github.com/prisma/prisma/releases/2.11.0) and later, you can set the foreign key directly:\n\n```\nconst user = await prisma.profile.create({  data: {    bio: 'Hello World',    userId: 42,  },})\n```\n\n##### Create a new `Post` record and connect it to an existing `User` record[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-a-new-post-record-and-connect-it-to-an-existing-user-record \"Direct link to create-a-new-post-record-and-connect-it-to-an-existing-user-record\")\n\n```\nconst user = await prisma.post.create({  data: {    title: 'Hello World',    author: {      connect: { email: 'alice@prisma.io' },    },  },})\n```\n\n##### Update an existing `User` record by connecting it to an existing `Profile` record[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-connecting-it-to-an-existing-profile-record \"Direct link to update-an-existing-user-record-by-connecting-it-to-an-existing-profile-record\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    profile: {      connect: { id: 24 },    },  },})\n```\n\n##### Update an existing `User` record by connecting it to two existing `Post` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-connecting-it-to-two-existing-post-records \"Direct link to update-an-existing-user-record-by-connecting-it-to-two-existing-post-records\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    posts: {      connect: [{ id: 24 }, { id: 42 }],    },  },})\n```\n\n### `connectOrCreate`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connectorcreate \"Direct link to connectorcreate\")\n\n`connectOrCreate` _either_ connects a record to an existing related record by ID or unique identifier _or_ creates a new related record if the record does not exist. See: [Working with relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries)\n\n*   Multiple `connectOrCreate` queries that run _as concurrent transactions_ can result in a **race condition**. Consider the following example, where two queries attempt to `connectOrCreate` a blog post tag named `computing` at the same time (tag names must be unique):\n    \n    *   Query A\n    *   Query B\n    \n    ```\n    const createPost = await prisma.post.create({  data: {    title: 'How to create a compiler',    content: '...',    author: {      connect: {        id: 9,      },    },    tags: {      connectOrCreate: {        create: {          name: 'computing',        },        where: {          name: 'computing',        },      },    },  },})\n    ```\n    \n    If query A and query B overlap in the following way, query A results in an exception:\n    \n    Query A (Fail ❌)\n    \n    Query B (Success ✅)\n    \n    Query hits server, starts transaction A\n    \n    Query hits server, starts transaction B\n    \n    Find record where `tagName` equals `computing`, record not found\n    \n    Find record where `tagName` equals `computing`, record not found\n    \n    Create record where `tagName` equals `computing` and connect\n    \n    Create record where `tagName` equals `computing`\n    \n    Unique violation, record already created by transaction B\n    \n    To work around this scenario, we recommend catching the unique violation exception (`PrismaClientKnownRequestError`, error `P2002`) and retrying failed queries.\n    \n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-30 \"Direct link to Examples\")\n\n##### Create a new `Profile` record, then connect it to an existing `User` record _or_ create a new `User`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-a-new-profile-record-then-connect-it-to-an-existing-user-record-or-create-a-new-user \"Direct link to create-a-new-profile-record-then-connect-it-to-an-existing-user-record-or-create-a-new-user\")\n\nThe following example:\n\n1.  Creates a `Profile`\n2.  Attempts to connect the profile to a `User` where the email address is `alice@prisma.io`\n3.  Creates a new user if a matching user does not exist\n\n```\nconst user = await prisma.profile.create({  data: {    bio: 'The coolest Alice on the planet',    user: {      connectOrCreate: {        where:  { email: 'alice@prisma.io' },        create: { email: 'alice@prisma.io'}    },  },})\n```\n\n##### Create a new `Post` record and connect it to an existing `User` record, _or_ create a new `User`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-a-new-post-record-and-connect-it-to-an-existing-user-record-or-create-a-new-user \"Direct link to create-a-new-post-record-and-connect-it-to-an-existing-user-record-or-create-a-new-user\")\n\n```\nconst user = await prisma.post.create({  data: {    title: 'Hello World',    author: {      connectOrCreate: {        where: { email: 'alice@prisma.io' },        create: { email: 'alice@prisma.io' },      },    },  },})\n```\n\n##### Update an existing `User` record by connecting it to an existing `Profile` record, _or_ creating a new `Profile` record[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-connecting-it-to-an-existing-profile-record-or-creating-a-new-profile-record \"Direct link to update-an-existing-user-record-by-connecting-it-to-an-existing-profile-record-or-creating-a-new-profile-record\")\n\nThe following example:\n\n1.  Attempts to connect the user to a `Profile` with an `id` of `20`\n2.  Creates a new profile if a matching profile does not exist\n\n```\nconst updateUser = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    profile: {      connectOrCreate: {        where: { id: 20 },        create: {          bio: 'The coolest Alice in town',        },      },    },  },})\n```\n\n##### Update an existing `User` record by connect it to two existing `Post` records, or creating two new `Post` records[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-connect-it-to-two-existing-post-records-or-creating-two-new-post-records \"Direct link to update-an-existing-user-record-by-connect-it-to-two-existing-post-records-or-creating-two-new-post-records\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    posts: {      connectOrCreate: [        {          where: { id: 32 },          create: { title: 'This is my first post' },        },        {          where: { id: 19 },          create: { title: 'This is my second post' },        },      ],    },  },})\n```\n\n### `disconnect`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#disconnect \"Direct link to disconnect\")\n\nA nested `disconnect` query breaks the connection between a parent record and a related record, but does not delete either record. See: [Working with relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries)\n\n*   `disconnect` is only available if the relation is optional.\n    \n*   If the relationship you are attempting to disconnect does not exist:\n    \n    *   ([In 2.21.0 and later](https://github.com/prisma/prisma/releases/tag/2.21.0)), the operation does nothing\n        \n    *   (Before [2.21.0](https://github.com/prisma/prisma/releases/tag/2.21.0)) Prisma Client throws an exception if the provided ID or unique identifier is not connected:\n        \n        ```\n        The records for relation `PostToUser` between the `User` and `Post` models are not connected.\n        ```\n        \n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-31 \"Direct link to Examples\")\n\n##### Update an existing `User` record by disconnecting the `Profile` record it's connected to[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-disconnecting-the-profile-record-its-connected-to \"Direct link to update-an-existing-user-record-by-disconnecting-the-profile-record-its-connected-to\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'bob@prisma.io' },  data: {    profile: {      disconnect: true,    },  },})\n```\n\n##### Update an existing `User` record by disconnecting two `Post` records it's connected to[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-disconnecting-two-post-records-its-connected-to \"Direct link to update-an-existing-user-record-by-disconnecting-two-post-records-its-connected-to\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    posts: {      disconnect: [{ id: 44 }, { id: 46 }],    },  },})\n```\n\n### `update`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-1 \"Direct link to update-1\")\n\nA nested `update` query updates one or more related records where the parent record's ID is `n`. See: [Working with relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#update-a-specific-related-record)\n\n*   Nested `update` queries are only available in the context of a top-level `update` query (for example, `prisma.user.update(...)`).\n    \n*   If the parent record does not exist, Prisma Client throws an exception:\n    \n    ```\n    AssertionError(\"Expected a valid parent ID to be present for nested update to-one case.\")\n    ```\n    \n*   If the related record that you want to update does not exist, Prisma Client throws an exception:\n    \n    ```\n    AssertionError(\"Expected a valid parent ID to be present for nested update to-one case.\")\n    ```\n    \n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-32 \"Direct link to Examples\")\n\n##### Update an existing `User` record by updating the `Profile` record it's connected to[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-updating-the-profile-record-its-connected-to \"Direct link to update-an-existing-user-record-by-updating-the-profile-record-its-connected-to\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    profile: {      update: { bio: 'Hello World' },    },  },})\n```\n\n##### Update an existing `User` record by updating two `Post` records it's connected to[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-updating-two-post-records-its-connected-to \"Direct link to update-an-existing-user-record-by-updating-two-post-records-its-connected-to\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    posts: {      update: [        {          data: { published: true },          where: { id: 32 },        },        {          data: { published: true },          where: { id: 23 },        },      ],    },  },})\n```\n\n### `upsert`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#upsert-1 \"Direct link to upsert-1\")\n\ninfo\n\nThis section covers the usage of nested upsert within `update()`. To learn about the [`upsert()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#upsert) operation, reference the linked documentation.\n\nA nested `upsert` query updates a related record if it exists, or creates a new related record.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-33 \"Direct link to Examples\")\n\n##### Update an existing `User` record by updating the `Profile` record it's connected to or creating a new one (_upsert_)[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-updating-the-profile-record-its-connected-to-or-creating-a-new-one-upsert \"Direct link to update-an-existing-user-record-by-updating-the-profile-record-its-connected-to-or-creating-a-new-one-upsert\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    profile: {      upsert: {        create: { bio: 'Hello World' },        update: { bio: 'Hello World' },      },    },  },})\n```\n\n##### Update an existing `User` record by updating two `Post` record it's connected to or creating new ones (_upsert_)[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-updating-two-post-record-its-connected-to-or-creating-new-ones-upsert \"Direct link to update-an-existing-user-record-by-updating-two-post-record-its-connected-to-or-creating-new-ones-upsert\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    posts: {      upsert: [        {          create: { title: 'This is my first post' },          update: { title: 'This is my first post' },          where: { id: 32 },        },        {          create: { title: 'This is my second post' },          update: { title: 'This is my second post' },          where: { id: 23 },        },      ],    },  },})\n```\n\n### `delete`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#delete-1 \"Direct link to delete-1\")\n\nA nested `delete` query deletes a related record. The parent record is not deleted.\n\n*   `delete` is only available if the relation is optional.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-34 \"Direct link to Examples\")\n\n##### Update an existing `User` record by deleting the `Profile` record it's connected to[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-deleting-the-profile-record-its-connected-to \"Direct link to update-an-existing-user-record-by-deleting-the-profile-record-its-connected-to\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    profile: {      delete: true,    },  },})\n```\n\n##### Update an existing `User` record by deleting two `Post` records it's connected to[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-an-existing-user-record-by-deleting-two-post-records-its-connected-to \"Direct link to update-an-existing-user-record-by-deleting-two-post-records-its-connected-to\")\n\n```\nconst user = await prisma.user.update({  where: { email: 'alice@prisma.io' },  data: {    posts: {      delete: [{ id: 34 }, { id: 36 }],    },  },})\n```\n\n### `updateMany`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#updatemany-1 \"Direct link to updatemany-1\")\n\nA nested `updateMany` updates a list of related records and supports filtering - for example, you can update a user's unpublished posts.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-35 \"Direct link to Examples\")\n\n##### Update all unpublished posts belonging to a specific user[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-all-unpublished-posts-belonging-to-a-specific-user \"Direct link to Update all unpublished posts belonging to a specific user\")\n\n```\nconst result = await prisma.user.update({  where: {    id: 2,  },  data: {    posts: {      updateMany: {        where: {          published: false,        },        data: {          likes: 0,        },      },    },  },})\n```\n\n### `deleteMany`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#deletemany-1 \"Direct link to deletemany-1\")\n\nA nested `deleteMany` deletes related records and supports filtering. For example, you can delete a user's posts while updating other properties of that user.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-36 \"Direct link to Examples\")\n\n##### Delete all posts belonging to a specific user as part of an update[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#delete-all-posts-belonging-to-a-specific-user-as-part-of-an-update \"Direct link to Delete all posts belonging to a specific user as part of an update\")\n\n```\nconst result = await prisma.user.update({  where: {    id: 2,  },  data: {    name: 'Updated name',    posts: {      deleteMany: {},    },  },})\n```\n\n## Filter conditions and operators[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions-and-operators \"Direct link to Filter conditions and operators\")\n\ninfo\n\n*   From version 4.3.0, you can also use these operators to compare _fields_ in the same model [with the `<model>.fields` property](https://www.prisma.io/docs/orm/reference/prisma-client-reference#compare-columns-in-the-same-table).\n*   In versions before 4.3.0, you can compare fields in the same model [with raw queries](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries).\n\n### `equals`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#equals \"Direct link to equals\")\n\nValue equals `n`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-37 \"Direct link to Examples\")\n\n##### Return all users where `name` equals `\"Eleanor\"`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-all-users-where-name-equals-eleanor \"Direct link to return-all-users-where-name-equals-eleanor\")\n\n```\nconst result = await prisma.user.findMany({  where: {    name: {      equals: 'Eleanor',    },  },})\n```\n\nYou can also exclude the `equals`:\n\n```\nconst result = await prisma.user.findMany({  where: {    name: 'Eleanor',  },})\n```\n\n### `not`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#not \"Direct link to not\")\n\nValue does not equal `n`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-38 \"Direct link to Examples\")\n\n##### Return all users where `name` does **not** equal `\"Eleanor\"`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-all-users-where-name-does-not-equal-eleanor \"Direct link to return-all-users-where-name-does-not-equal-eleanor\")\n\n```\nconst result = await prisma.user.findMany({  where: {    name: {      not: 'Eleanor',    },  },})\n```\n\nwarning\n\n`not` will return all items that do not match a given value. However, if the column is nullable, `NULL` values will not be returned. If you require null values to be returned, use an [`OR`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#or) operator to include `NULL` values.\n\n##### Return all users where `name` does **not** equal `\"Eleanor\"` **including** users where `name` is `NULL`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#return-all-users-where-name-does-not-equal-eleanor-including-users-where-name-is-null \"Direct link to return-all-users-where-name-does-not-equal-eleanor-including-users-where-name-is-null\")\n\n```\nawait prisma.user.findMany({  where: {    OR: [      { name: { not: 'Eleanor' } },      { name: null }    ]  }})\n```\n\n### `in`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#in \"Direct link to in\")\n\nValue `n` exists in list.\n\nnote\n\n`null` values are not returned. For example, if you combine `in` and `NOT` to return a user whose name is _not_ in the list, users with `null` value names are not returned.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-39 \"Direct link to Examples\")\n\n##### Get `User` records where the `id` can be found in the following list: `[22, 91, 14, 2, 5]`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-user-records-where-the-id-can-be-found-in-the-following-list-22-91-14-2-5 \"Direct link to get-user-records-where-the-id-can-be-found-in-the-following-list-22-91-14-2-5\")\n\n```\nconst getUser = await prisma.user.findMany({  where: {    id: { in: [22, 91, 14, 2, 5] },  },})\n```\n\n##### Get `User` records where the `name` can be found in the following list: `['Saqui', 'Clementine', 'Bob']`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-user-records-where-the-name-can-be-found-in-the-following-list-saqui-clementine-bob \"Direct link to get-user-records-where-the-name-can-be-found-in-the-following-list-saqui-clementine-bob\")\n\n```\nconst getUser = await prisma.user.findMany({  where: {    name: { in: ['Saqui', 'Clementine', 'Bob'] },  },})\n```\n\n##### Get `User` records where `name` is **not** present in the list[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-user-records-where-name-is-not-present-in-the-list \"Direct link to get-user-records-where-name-is-not-present-in-the-list\")\n\nThe following example combines `in` and [`NOT`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#not). You can also use [`notIn`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#notin).\n\n```\nconst getUser = await prisma.user.findMany({  where: {    NOT: {      name: { in: ['Saqui', 'Clementine', 'Bob'] },    },  },})\n```\n\n##### Get a `User` record where at least one `Post` has at least one specified `Category`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-a-user-record-where-at-least-one-post-has-at-least-one-specified-category \"Direct link to get-a-user-record-where-at-least-one-post-has-at-least-one-specified-category\")\n\n```\nconst getUser = await prisma.user.findMany({  where: {    // Find users where..    posts: {      some: {        // ..at least one (some) posts..        categories: {          some: {            // .. have at least one category ..            name: {              in: ['Food', 'Introductions'], // .. with a name that matches one of the following.            },          },        },      },    },  },})\n```\n\n### `notIn`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#notin \"Direct link to notin\")\n\nValue `n` does not exist in list.\n\n*   `null` values are not returned.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-40 \"Direct link to Examples\")\n\n##### Get `User` records where the `id` can **not** be found in the following list: `[22, 91, 14, 2, 5]`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-user-records-where-the-id-can-not-be-found-in-the-following-list-22-91-14-2-5 \"Direct link to get-user-records-where-the-id-can-not-be-found-in-the-following-list-22-91-14-2-5\")\n\n```\nconst getUser = await prisma.user.findMany({  where: {    id: { notIn: [22, 91, 14, 2, 5] },  },})\n```\n\n### `lt`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#lt \"Direct link to lt\")\n\nValue `n` is less than `x`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-41 \"Direct link to Examples\")\n\n##### Get all `Post` records where `likes` is less than `9`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-likes-is-less-than-9 \"Direct link to get-all-post-records-where-likes-is-less-than-9\")\n\n```\nconst getPosts = await prisma.post.findMany({  where: {    likes: {      lt: 9,    },  },})\n```\n\n### `lte`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#lte \"Direct link to lte\")\n\nValue `n` is less than _or_ equal to `x`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-42 \"Direct link to Examples\")\n\n##### Get all `Post` records where `likes` is less or equal to `9`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-likes-is-less-or-equal-to-9 \"Direct link to get-all-post-records-where-likes-is-less-or-equal-to-9\")\n\n```\nconst getPosts = await prisma.post.findMany({  where: {    likes: {      lte: 9,    },  },})\n```\n\n### `gt`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#gt \"Direct link to gt\")\n\nValue `n` is greater than `x`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-43 \"Direct link to Examples\")\n\n##### Get all `Post` records where `likes` is greater than `9`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-likes-is-greater-than-9 \"Direct link to get-all-post-records-where-likes-is-greater-than-9\")\n\n```\nconst getPosts = await prisma.post.findMany({  where: {    likes: {      gt: 9,    },  },})\n```\n\n### `gte`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#gte \"Direct link to gte\")\n\nValue `n` is greater than _or_ equal to `x`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-44 \"Direct link to Examples\")\n\n##### Get all `Post` records where `likes` is greater than or equal to `9`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-likes-is-greater-than-or-equal-to-9 \"Direct link to get-all-post-records-where-likes-is-greater-than-or-equal-to-9\")\n\n```\nconst getPosts = await prisma.post.findMany({  where: {    likes: {      gte: 9,    },  },})\n```\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-45 \"Direct link to Examples\")\n\n##### Get all `Post` records where `date_created` is greater than March 19th, 2020[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-date_created-is-greater-than-march-19th-2020 \"Direct link to get-all-post-records-where-date_created-is-greater-than-march-19th-2020\")\n\n```\nconst result = await prisma.post.findMany({  where: {    date_created: {      gte: new Date(        '2020-03-19T14:21:00+0200'      ) /* Includes time offset for UTC */,    },  },})\n```\n\n### `contains`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#contains \"Direct link to contains\")\n\nValue `n` contains `x`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-46 \"Direct link to Examples\")\n\n##### Count all `Post` records where `content` contains `databases`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#count-all-post-records-where-content-contains-databases \"Direct link to count-all-post-records-where-content-contains-databases\")\n\n```\nconst result = await prisma.post.count({  where: {    content: {      contains: 'databases',    },  },})\n```\n\n##### Count all `Post` records where `content` **does not** contain `databases`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#count-all-post-records-where-content-does-not-contain-databases \"Direct link to count-all-post-records-where-content-does-not-contain-databases\")\n\n```\nconst result = await prisma.post.count({  where: {    NOT: {      content: {        contains: 'databases',      },    },  },})\n```\n\n### `search`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#search \"Direct link to search\")\n\nUse [Full-Text Search](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search) to search within a `String` field.\n\nFull-Text Search is currently in **Preview** and only available for **PostgreSQL** and **MySQL**. To use `search`, you'll need to enable the `fullTextSearch` preview feature.\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextSearch\"]}\n```\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-47 \"Direct link to Examples\")\n\n##### Find all posts with a title that contains `cat` or `dog`.[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#find-all-posts-with-a-title-that-contains-cat-or-dog \"Direct link to find-all-posts-with-a-title-that-contains-cat-or-dog\")\n\n```\nconst result = await prisma.post.findMany({  where: {    title: {      search: 'cat | dog',    },  },})\n```\n\n##### Find all posts with a title that contains `cat` and `dog`.[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#find-all-posts-with-a-title-that-contains-cat-and-dog \"Direct link to find-all-posts-with-a-title-that-contains-cat-and-dog\")\n\n```\nconst result = await prisma.post.findMany({  where: {    title: {      search: 'cat & dog',    },  },})\n```\n\n##### Find all posts with a title that doesn't contain `cat`.[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#find-all-posts-with-a-title-that-doesnt-contain-cat \"Direct link to find-all-posts-with-a-title-that-doesnt-contain-cat\")\n\n```\nconst result = await prisma.post.findMany({  where: {    title: {      search: '!cat',    },  },})\n```\n\n### `mode`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#mode \"Direct link to mode\")\n\n*   Supported by the PostgreSQL and MongoDB connectors only\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-48 \"Direct link to Examples\")\n\n##### Get all `Post` records where `title` contains `prisma`, in a case insensitive way[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-title-contains-prisma-in-a-case-insensitive-way \"Direct link to get-all-post-records-where-title-contains-prisma-in-a-case-insensitive-way\")\n\n```\nconst result = await prisma.post.findMany({  where: {    title: {      contains: 'prisma',      mode: 'insensitive',    },  },})\n```\n\n### `startsWith`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#startswith \"Direct link to startswith\")\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-49 \"Direct link to Examples\")\n\n##### Get all `Post` records where `title` starts with `Pr` (such as `Prisma`)[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-title-starts-with-pr-such-as-prisma \"Direct link to get-all-post-records-where-title-starts-with-pr-such-as-prisma\")\n\n```\nconst result = await prisma.post.findMany({  where: {    title: {      startsWith: 'Pr',    },  },})\n```\n\n### `endsWith`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#endswith \"Direct link to endswith\")\n\n#### Get all `User` records where `email` ends with `prisma.io`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-user-records-where-email-ends-with-prismaio \"Direct link to get-all-user-records-where-email-ends-with-prismaio\")\n\n```\nconst result = await prisma.user.findMany({  where: {    email: {      endsWith: 'prisma.io',    },  },})\n```\n\n### `AND`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#and \"Direct link to and\")\n\nAll conditions must return `true`. Alternatively, pass a list of objects into the `where` clause - the [`AND` operator is not required](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-content-field-contains-prisma-and-published-is-false-no-and).\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-50 \"Direct link to Examples\")\n\n##### Get all `Post` records where the `content` field contains `Prisma` and `published` is `false`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-content-field-contains-prisma-and-published-is-false \"Direct link to get-all-post-records-where-the-content-field-contains-prisma-and-published-is-false\")\n\n```\nconst result = await prisma.post.findMany({  where: {    AND: [      {        content: {          contains: 'Prisma',        },      },      {        published: {          equals: false,        },      },    ],  },})\n```\n\n##### Get all `Post` records where the `content` field contains `Prisma` and `published` is `false` (no `AND`)[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-content-field-contains-prisma-and-published-is-false-no-and \"Direct link to get-all-post-records-where-the-content-field-contains-prisma-and-published-is-false-no-and\")\n\nThe following format returns the same results as the previous example **without** the `AND` operator:\n\n```\nconst result = await prisma.post.findMany({  where: {    content: {      contains: 'Prisma',    },    published: {      equals: false,    },  },})\n```\n\n##### Get all `Post` records where the `title` field contains `Prisma` or `databases`, and `published` is `false`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-title-field-contains-prisma-or-databases-and-published-is-false \"Direct link to get-all-post-records-where-the-title-field-contains-prisma-or-databases-and-published-is-false\")\n\nThe following example combines `OR` and `AND`:\n\n```\nconst result = await prisma.post.findMany({  where: {    OR: [      {        title: {          contains: 'Prisma',        },      },      {        title: {          contains: 'databases',        },      },    ],    AND: {      published: false,    },  },})\n```\n\n### `OR`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#or \"Direct link to or\")\n\nOne or more conditions must return `true`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-51 \"Direct link to Examples\")\n\n##### Get all `Post` records where the `title` field contains `Prisma` or `databases`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-title-field-contains-prisma-or-databases \"Direct link to get-all-post-records-where-the-title-field-contains-prisma-or-databases\")\n\n```\nconst result = await prisma.post.findMany({  where: {    OR: [      {        title: {          contains: 'Prisma',        },      },      {        title: {          contains: 'databases',        },      },    ],  },})\n```\n\n##### Get all `Post` records where the `title` field contains `Prisma` or `databases`, but not `SQL`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-title-field-contains-prisma-or-databases-but-not-sql \"Direct link to get-all-post-records-where-the-title-field-contains-prisma-or-databases-but-not-sql\")\n\nThe following example combines `OR` and `NOT`:\n\n```\nconst result = await prisma.post.findMany({  where: {    OR: [      {        title: {          contains: 'Prisma',        },      },      {        title: {          contains: 'databases',        },      },    ],    NOT: {      title: {        contains: 'SQL',      },    },  },})\n```\n\n##### Get all `Post` records where the `title` field contains `Prisma` or `databases`, and `published` is `false`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-title-field-contains-prisma-or-databases-and-published-is-false-1 \"Direct link to get-all-post-records-where-the-title-field-contains-prisma-or-databases-and-published-is-false-1\")\n\nThe following example combines `OR` and `AND`:\n\n```\nconst result = await prisma.post.findMany({  where: {    OR: [      {        title: {          contains: 'Prisma',        },      },      {        title: {          contains: 'databases',        },      },    ],    AND: {      published: false,    },  },})\n```\n\n### `NOT`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#not-1 \"Direct link to not-1\")\n\nAll conditions must return `false`.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-52 \"Direct link to Examples\")\n\n##### Get all `Post` records where the `title` field contains `Prisma` or `databases`, but not `SQL`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-title-field-contains-prisma-or-databases-but-not-sql-1 \"Direct link to get-all-post-records-where-the-title-field-contains-prisma-or-databases-but-not-sql-1\")\n\n```\nconst result = await prisma.post.findMany({  where: {    OR: [      {        title: {          contains: 'Prisma',        },      },      {        title: {          contains: 'databases',        },      },    ],    NOT: {      title: {        contains: 'SQL',      },    },  },})\n```\n\n##### Get all `Post` records where the `title` field contains `Prisma` or `databases`, but not `SQL`, and the related `User` record' email address does not contain `sarah`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-title-field-contains-prisma-or-databases-but-not-sql-and-the-related-user-record-email-address-does-not-contain-sarah \"Direct link to get-all-post-records-where-the-title-field-contains-prisma-or-databases-but-not-sql-and-the-related-user-record-email-address-does-not-contain-sarah\")\n\n```\nconst result = await prisma.post.findMany({  where: {    OR: [      {        title: {          contains: 'Prisma',        },      },      {        title: {          contains: 'databases',        },      },    ],    NOT: {      title: {        contains: 'SQL',      },    },    user: {      NOT: {        email: {          contains: 'sarah',        },      },    },  },  include: {    user: true,  },})\n```\n\n## Relation filters[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#relation-filters \"Direct link to Relation filters\")\n\n### `some`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#some \"Direct link to some\")\n\nReturns all records where **one or more** (\"some\") _related_ records match filtering criteria.\n\n*   You can use `some` without parameters to return all records with at least one relation\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-53 \"Direct link to Examples\")\n\n##### Get all `User` records where _some_ posts mention `Prisma`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-user-records-where-some-posts-mention-prisma \"Direct link to get-all-user-records-where-some-posts-mention-prisma\")\n\n```\nconst result = await prisma.user.findMany({  where: {    post: {      some: {        content: {          contains: \"Prisma\"        }      }    }  }}\n```\n\n### `every`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#every \"Direct link to every\")\n\nReturns all records where **all** (\"every\") _related_ records match filtering criteria.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-54 \"Direct link to Examples\")\n\n##### Get all `User` records where _all_ posts are published[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-user-records-where-all-posts-are-published \"Direct link to get-all-user-records-where-all-posts-are-published\")\n\n```\nconst result = await prisma.user.findMany({  where: {    post: {      every: {        published: true      },    }  }}\n```\n\n### `none`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#none \"Direct link to none\")\n\nReturns all records where **zero** _related_ records match filtering criteria.\n\n*   You can use `none` without parameters to [return all records with no relations](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-user-records-with-zero-posts)\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-55 \"Direct link to Examples\")\n\n##### Get all `User` records with zero posts[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-user-records-with-zero-posts \"Direct link to get-all-user-records-with-zero-posts\")\n\n```\nconst result = await prisma.user.findMany({  where: {    post: {        none: {} // User has no posts    }  }}\n```\n\n##### Get all `User` records with zero published posts[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-user-records-with-zero-published-posts \"Direct link to get-all-user-records-with-zero-published-posts\")\n\n```\nconst result = await prisma.user.findMany({  where: {    post: {        none: {          published: true        }    }  }}\n```\n\n### `is`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#is \"Direct link to is\")\n\nReturns all records where related record matches filtering criteria (for example, user's name `is` Bob).\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-56 \"Direct link to Examples\")\n\n##### Get all `Post` records where user's name is `\"Bob\"`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-users-name-is-bob \"Direct link to get-all-post-records-where-users-name-is-bob\")\n\n```\nconst result = await prisma.post.findMany({  where: {    user: {        is: {          name: \"Bob\"        },    }  }}\n```\n\n### `isNot`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#isnot \"Direct link to isnot\")\n\nReturns all records where related record matches filtering criteria (for example, user's name `isNot` Bob).\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-57 \"Direct link to Examples\")\n\n##### Get all `Post` records where user's name is NOT `\"Bob\"`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-users-name-is-not-bob \"Direct link to get-all-post-records-where-users-name-is-not-bob\")\n\n```\nconst result = await prisma.post.findMany({  where: {    user: {        isNot: {          name: \"Bob\"        },    }  }}\n```\n\n## Scalar list methods[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#scalar-list-methods \"Direct link to Scalar list methods\")\n\n### `set`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#set-1 \"Direct link to set-1\")\n\nUse `set` to overwrite the value of a scalar list field.\n\n*   `set` is optional - you can set the value directly:\n    \n    ```\n    tags: ['computers', 'books']\n    ```\n    \n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-58 \"Direct link to Examples\")\n\n##### Set the value of `tags` to a list of string values[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#set-the-value-of-tags-to-a-list-of-string-values \"Direct link to set-the-value-of-tags-to-a-list-of-string-values\")\n\n```\nconst setTags = await prisma.post.update({  where: {    id: 9,  },  data: {    tags: {      set: ['computing', 'books'],    },  },})\n```\n\n##### Set `tags` to a list of values _without_ using the `set` keyword[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#set-tags-to-a-list-of-values-without-using-the-set-keyword \"Direct link to set-tags-to-a-list-of-values-without-using-the-set-keyword\")\n\n```\nconst setTags = await prisma.post.update({  where: {    id: 9,  },  data: {    tags: ['computing', 'books'],  },})\n```\n\n#### Set the value of `tags` to a single string value[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#set-the-value-of-tags-to-a-single-string-value \"Direct link to set-the-value-of-tags-to-a-single-string-value\")\n\n```\nconst setTags = await prisma.post.update({  where: {    id: 9,  },  data: {    tags: {      set: 'computing',    },  },})\n```\n\n### `push`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#push \"Direct link to push\")\n\n`push` is available in version [2.20.0](https://github.com/prisma/prisma/releases/2.20.0) and later. Use `push` to add _one_ value or _multiple_ values to a scalar list field.\n\n*   Available for PostgreSQL and MongoDB only.\n*   You can push a list of values or only a single value.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-59 \"Direct link to Examples\")\n\n##### Add a `computing` item to the `tags` list[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#add-a-computing-item-to-the-tags-list \"Direct link to add-a-computing-item-to-the-tags-list\")\n\n```\nconst addTag = await prisma.post.update({  where: {    id: 9,  },  data: {    tags: {      push: 'computing',    },  },})\n```\n\n```\nconst addTag = await prisma.post.update({  where: {    id: 9,  },  data: {    tags: {      push: ['computing', 'genetics'],    },  },})\n```\n\n### `unset`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#unset \"Direct link to unset\")\n\nwarning\n\nThis method is available on MongoDB only in versions [3.11.1](https://github.com/prisma/prisma/releases/tag/3.11.1) and later.\n\nUse `unset` to unset the value of a scalar list. Unlike `set: null`, `unset` removes the list entirely.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-60 \"Direct link to Examples\")\n\n##### Unset the value of `tags`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#unset-the-value-of-tags \"Direct link to unset-the-value-of-tags\")\n\n```\nconst setTags = await prisma.post.update({  where: {    id: 9,  },  data: {    tags: {      unset: true,    },  },})\n```\n\n## Scalar list filters[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#scalar-list-filters \"Direct link to Scalar list filters\")\n\nScalar list filters allow you to filter by the contents of a list / array field.\n\nwarning\n\nAvailable for:\n\n*   PostgreSQL in versions [2.15.0](https://github.com/prisma/prisma/releases/tag/2.15.0) and later\n*   CockroachDB in versions [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0) and later\n*   MongoDB in versions [3.11.0](https://github.com/prisma/prisma/releases/tag/3.11.0) and later\n\n*   Scalar list / array filters [ignore `NULL` values](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays#null-values-in-arrays) . Using `isEmpty` or `NOT` does not return records with `NULL` value lists / arrays, and `{ equals: null }` results in an error.\n\n### `has`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#has \"Direct link to has\")\n\nThe given value exists in the list.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-61 \"Direct link to Examples\")\n\nThe following query returns all `Post` records where the `tags` list includes `\"databases\"`:\n\n```\nconst posts = await client.post.findMany({  where: {    tags: {      has: 'databases',    },  },})\n```\n\nThe following query returns all `Post` records where the `tags` list **does not** include `\"databases\"`:\n\n```\nconst posts = await client.post.findMany({  where: {    NOT: {      tags: {        has: 'databases',      },    },  },})\n```\n\n### `hasEvery`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#hasevery \"Direct link to hasevery\")\n\nEvery value exists in the list.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-62 \"Direct link to Examples\")\n\nThe following query returns all `Post` records where the `tags` list includes _at least_ `\"databases\"` _and_ `\"typescript\"`:\n\n```\nconst posts = await prisma.post.findMany({  where: {    tags: {      hasEvery: ['databases', 'typescript'],    },  },})\n```\n\n### `hasSome`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#hassome \"Direct link to hassome\")\n\nAt least one value exists in the list.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-63 \"Direct link to Examples\")\n\nThe following query returns all `Post` records where the `tags` list includes `\"databases\"` _or_ `\"typescript\"`:\n\n```\nconst posts = await prisma.post.findMany({  where: {    tags: {      hasSome: ['databases', 'typescript'],    },  },})\n```\n\n### `isEmpty`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#isempty \"Direct link to isempty\")\n\nThe list is empty.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-64 \"Direct link to Examples\")\n\nThe following query returns all `Post` records that have no tags:\n\n```\nconst posts = await prisma.post.findMany({  where: {    tags: {      isEmpty: true,    },  },})\n```\n\n### `isSet`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#isset \"Direct link to isset\")\n\nwarning\n\nThis filter is available on MongoDB only in versions [3.11.1](https://github.com/prisma/prisma/releases/tag/3.11.1) and later.\n\nFilter lists to include only results that have been set (either set to a value, or explicitly set to `null`). Setting this filter to `true` will exclude undefined results that are not set at all.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-65 \"Direct link to Examples\")\n\nThe following query returns all `Post` records where the `tags` have been set to either `null` or a value:\n\n```\nconst posts = await prisma.post.findMany({  where: {    tags: {      isSet: true,    },  },})\n```\n\n### `equals`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#equals-1 \"Direct link to equals-1\")\n\nThe list matches the given value exactly.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-66 \"Direct link to Examples\")\n\nThe following query returns all `Post` records where the `tags` list includes `\"databases\"` and `\"typescript\"` only:\n\n```\nconst posts = await prisma.post.findMany({  where: {    tags: {      equals: ['databases', 'typescript'],    },  },})\n```\n\n## Composite type methods[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#composite-type-methods \"Direct link to Composite type methods\")\n\nwarning\n\nAvailable for MongoDB only in Prisma `3.10.0` and later.\n\nComposite type methods allow you to create, update and delete [composite types](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types).\n\n### `set`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#set-2 \"Direct link to set-2\")\n\nUse `set` to overwrite the value of a composite type.\n\n*   The `set` keyword is optional - you can set the value directly:\n    \n    ```\n    photos: [  { height: 100, width: 200, url: '1.jpg' },  { height: 100, width: 200, url: '2.jpg' },]\n    ```\n    \n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-67 \"Direct link to Examples\")\n\n##### Set the `shippingAddress` composite type within a new `order`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#set-the-shippingaddress-composite-type-within-a-new-order \"Direct link to set-the-shippingaddress-composite-type-within-a-new-order\")\n\n```\nconst order = await prisma.order.create({  data: {    // Normal relation    product: { connect: { id: 'some-object-id' } },    color: 'Red',    size: 'Large',    // Composite type    shippingAddress: {      set: {        street: '1084 Candycane Lane',        city: 'Silverlake',        zip: '84323',      },    },  },})\n```\n\n##### Set an optional composite type to `null`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#set-an-optional-composite-type-to-null \"Direct link to set-an-optional-composite-type-to-null\")\n\n```\nconst order = await prisma.order.create({  data: {    // Embedded optional type, set to null    billingAddress: {      set: null,    },  },})\n```\n\n### `unset`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#unset-1 \"Direct link to unset-1\")\n\nUse `unset` to unset the value of a composite type. Unlike `set: null`, this removes the field entirely from the MongoDB document.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-68 \"Direct link to Examples\")\n\n##### Remove the `billingAddress` from an `order`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#remove-the-billingaddress-from-an-order \"Direct link to remove-the-billingaddress-from-an-order\")\n\n```\nconst order = await prisma.order.update({  where: {    id: 'some-object-id',  },  data: {    billingAddress: {      // Unset the billing address      // Removes \"billingAddress\" field from order      unset: true,    },  },})\n```\n\n### `update`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-2 \"Direct link to update-2\")\n\nUse `update` to update fields within a required composite type.\n\nThe `update` method cannot be used on optional types. Instead, use [upsert](https://www.prisma.io/docs/orm/reference/prisma-client-reference#upsert-2)\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-69 \"Direct link to Examples\")\n\n##### Update the zip field of a `shippingAddress` composite type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-the-zip-field-of-a-shippingaddress-composite-type \"Direct link to update-the-zip-field-of-a-shippingaddress-composite-type\")\n\n```\nconst order = await prisma.order.update({  where: {    id: 'some-object-id',  },  data: {    shippingAddress: {      // Update just the zip field      update: {        zip: '41232',      },    },  },})\n```\n\n### `upsert`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#upsert-2 \"Direct link to upsert-2\")\n\nUse `upsert` to update an existing optional composite type if it exists, and otherwise set the composite type.\n\nThe `upsert` method cannot be used on required types. Instead, use [update](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-2)\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-70 \"Direct link to Examples\")\n\n##### Create a new `billingAddress` if it doesn't exist, and otherwise update it[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-a-new-billingaddress-if-it-doesnt-exist-and-otherwise-update-it \"Direct link to create-a-new-billingaddress-if-it-doesnt-exist-and-otherwise-update-it\")\n\n```\nconst order = await prisma.order.update({  where: {    id: 'some-object-id',  },  data: {    billingAddress: {      // Create the address if it doesn't exist,      // otherwise update it      upsert: {        set: {          street: '1084 Candycane Lane',          city: 'Silverlake',          zip: '84323',        },        update: {          zip: '84323',        },      },    },  },})\n```\n\n### `push`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#push-1 \"Direct link to push-1\")\n\nUse `push` to push values to the end of a list of composite types.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-71 \"Direct link to Examples\")\n\n##### Add a new photo to the `photos` list[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#add-a-new-photo-to-the-photos-list \"Direct link to add-a-new-photo-to-the-photos-list\")\n\n```\nconst product = prisma.product.update({  where: {    id: 10,  },  data: {    photos: {      // Push a photo to the end of the photos list      push: [{ height: 100, width: 200, url: '1.jpg' }],    },  },})\n```\n\n## Composite type filters[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#composite-type-filters \"Direct link to Composite type filters\")\n\nwarning\n\nAvailable for MongoDB only in Prisma `3.11.0` and later.\n\nComposite type filters allow you to filter the contents of [composite types](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types).\n\n### `equals`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#equals-2 \"Direct link to equals-2\")\n\nUse `equals` to filter results by matching a composite type or a list of composite types. Requires all required fields of the composite type to match.\n\nWhen matching optional fields, you need to distinguish between undefined (missing) fields of the document, and fields that have been explicitly set to `null`:\n\n*   If you omit an optional field, it will match undefined fields, but not fields that have been set to `null`\n*   If you filter for `null` values of an optional field with `equals: { ... exampleField: null ... }`, then it will match only documents where the field has been set to `null`, and not undefined fields\n\nThe ordering of fields and lists matters when using `equals`:\n\n*   For fields, `{ \"a\": \"1\", \"b\": \"2\" }` and `{ \"b\": \"2\", \"a\": \"1\" }` are not considered equal\n*   For lists, `[ { \"a\": 1 }, { \"a\": 2 } ]` and `[ { \"a\": 2 }, { \"a\": 1 } ]` are not considered equal\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-72 \"Direct link to Examples\")\n\n##### Find orders that exactly match the given `shippingAddress`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#find-orders-that-exactly-match-the-given-shippingaddress \"Direct link to find-orders-that-exactly-match-the-given-shippingaddress\")\n\n```\nconst orders = await prisma.order.findMany({  where: {    shippingAddress: {      equals: {        street: '555 Candy Cane Lane',        city: 'Wonderland',        zip: '52337',      },    },  },})\n```\n\n##### Find products with photos that match all of a list of `url`s[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#find-products-with-photos-that-match-all-of-a-list-of-urls \"Direct link to find-products-with-photos-that-match-all-of-a-list-of-urls\")\n\n```\nconst product = prisma.product.findMany({  where: {    equals: {      photos: [{ url: '1.jpg' }, { url: '2.jpg' }],    },  },})\n```\n\n### `is`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#is-1 \"Direct link to is-1\")\n\nUse `is` to filter results by matching specific fields within composite types.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-73 \"Direct link to Examples\")\n\n##### Find orders with a `shippingAddress` that matches the given street name[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#find-orders-with-a-shippingaddress-that-matches-the-given-street-name \"Direct link to find-orders-with-a-shippingaddress-that-matches-the-given-street-name\")\n\n```\nconst orders = await prisma.order.findMany({  where: {    shippingAddress: {      is: {        street: '555 Candy Cane Lane',      },    },  },})\n```\n\n### `isNot`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#isnot-1 \"Direct link to isnot-1\")\n\nUse `isNot` to filter results for composite type fields that do not match.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-74 \"Direct link to Examples\")\n\n##### Find orders with a `shippingAddress` that does not match the given zip code[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#find-orders-with-a-shippingaddress-that-does-not-match-the-given-zip-code \"Direct link to find-orders-with-a-shippingaddress-that-does-not-match-the-given-zip-code\")\n\n```\nconst orders = await prisma.order.findMany({  where: {    shippingAddress: {      isNot: {        zip: '52337',      },    },  },})\n```\n\n### `isEmpty`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#isempty-1 \"Direct link to isempty-1\")\n\nUse `isEmpty` to filter results for an empty list of composite types.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-75 \"Direct link to Examples\")\n\n##### Find products with no photos[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#find-products-with-no-photos \"Direct link to Find products with no photos\")\n\n```\nconst product = prisma.product.findMany({  where: {    photos: {      isEmpty: true,    },  },})\n```\n\n### `every`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#every-1 \"Direct link to every-1\")\n\nUse `every` to filter for lists of composite types where every item in the list matches the condition\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-76 \"Direct link to Examples\")\n\n##### Find the first product where every photo has a `height` of `200`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#find-the-first-product-where-every-photo-has-a-height-of-200 \"Direct link to find-the-first-product-where-every-photo-has-a-height-of-200\")\n\n```\nconst product = prisma.product.findFirst({  where: {    photos: {      every: {        { height: 200 },      }    }  },})\n```\n\n### `some`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#some-1 \"Direct link to some-1\")\n\nUse `some` to filter for lists of composite types where one or more items in the list match the condition.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-77 \"Direct link to Examples\")\n\n##### Find the first product where one or more photos have a `url` of `2.jpg`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#find-the-first-product-where-one-or-more-photos-have-a-url-of-2jpg \"Direct link to find-the-first-product-where-one-or-more-photos-have-a-url-of-2jpg\")\n\n```\nconst product = prisma.product.findFirst({  where: {    photos: {      some: {        { url: \"2.jpg\" },      }    }  },})\n```\n\n### `none`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#none-1 \"Direct link to none-1\")\n\nUse `none` to filter for lists of composite types where no items in the list match the condition.\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-78 \"Direct link to Examples\")\n\n##### Find the first product where no photos have a `url` of `2.jpg`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#find-the-first-product-where-no-photos-have-a-url-of-2jpg \"Direct link to find-the-first-product-where-no-photos-have-a-url-of-2jpg\")\n\n```\nconst product = prisma.product.findFirst({  where: {    photos: {      none: {        { url: \"2.jpg\" },      }    }  },})\n```\n\n## Atomic number operations[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#atomic-number-operations \"Direct link to Atomic number operations\")\n\nAtomic operations on update is available for number field types (`Float` and `Int`). This feature allows you to update a field based on its **current** value (such as _subtracting_ or _dividing_) without risking a race condition.\n\nOverview: Race conditions\n\nA race conditions occurs when two or more operations must be done in sequence in order to complete a task. In the following example, two clients try to increase the same field (`postCount`) by one:\n\nClient\n\nOperation\n\nValue\n\nClient 1\n\n**Get** field value\n\n`21`\n\nClient 2\n\n**Get** field value\n\n`21`\n\nClient 2\n\n**Set** field value\n\n`22`\n\nClient 1\n\n**Set** field value\n\n`22` ✘\n\nThe value _should_ be `23`, but the two clients did not read and write to the `postCount` field in sequence. Atomic operations on update combine read and write into a single operation, which prevents a race condition:\n\nClient\n\nOperation\n\nValue\n\nClient 1\n\n**Get and set** field value\n\n`21` → `22`\n\nClient 2\n\n**Get and set** field value\n\n`22` → `23` ✔\n\n### Operators[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#operators \"Direct link to Operators\")\n\nOption\n\nDescription\n\n`increment`\n\nAdds `n` to the current value.\n\n`decrement`\n\nSubtacts `n` from the current value.\n\n`multiply`\n\nMultiplies the current value by `n`.\n\n`divide`\n\nDivides the current value by `n`.\n\n`set`\n\nSets the current field value. Identical to `{ myField : n }`.\n\n*   You can only perform **one** atomic update per field, per query.\n*   If a field is `null`, it will not be updated by `increment`, `decrement`, `multiply`, or `divide`.\n\n### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-79 \"Direct link to Examples\")\n\n#### Increment all `view` and `likes` fields of all `Post` records by `1`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#increment-all-view-and-likes-fields-of-all-post-records-by-1 \"Direct link to increment-all-view-and-likes-fields-of-all-post-records-by-1\")\n\n```\nconst updatePosts = await prisma.post.updateMany({  data: {    views: {      increment: 1,    },    likes: {      increment: 1,    },  },})\n```\n\n#### Set all `views` fields of all `Post` records to `0`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#set-all-views-fields-of-all-post-records-to-0 \"Direct link to set-all-views-fields-of-all-post-records-to-0\")\n\n```\nconst updatePosts = await prisma.post.updateMany({  data: {    views: {      set: 0,    },  },})\n```\n\nCan also be written as:\n\n```\nconst updatePosts = await prisma.post.updateMany({  data: {    views: 0,  },})\n```\n\n## `Json` filters[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#json-filters \"Direct link to json-filters\")\n\nFor use cases and advanced examples, see: [Working with `Json` fields](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields).\n\nwarning\n\nSupported by [PostgreSQL](https://www.prisma.io/docs/orm/overview/databases/postgresql) and [MySQL](https://www.prisma.io/docs/orm/overview/databases/mysql) with different syntaxes for the `path` option. PostgreSQL does not support filtering on object key values in arrays.\n\nThe examples in this section assumes that the value of the `pet` field is:\n\n```\n{  \"favorites\": {    \"catBreed\": \"Turkish van\",    \"dogBreed\": \"Rottweiler\",    \"sanctuaries\": [\"RSPCA\", \"Alley Cat Allies\"],    \"treats\": [      { \"name\": \"Dreamies\", \"manufacturer\": \"Mars Inc\" },      { \"name\": \"Treatos\", \"manufacturer\": \"The Dog People\" }    ]  },  \"fostered\": {    \"cats\": [\"Bob\", \"Alice\", \"Svetlana the Magnificent\", \"Queenie\"]  },  \"owned\": {    \"cats\": [\"Elliott\"]  }}\n```\n\n*   The implementation of `Json` filtering [differs between database connectors](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields)\n*   Filtering is case sensitive in PostgreSQL and does not yet support `mode`\n\n### `path`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#path \"Direct link to path\")\n\n`path` represents the location of a specific key. The following query returns all users where the nested `favourites` > `dogBreed` key equals `\"Rottweiler\"`.\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    pets: {      path: ['favorites', 'dogBreed'],      equals: 'Rottweiler',    },  },})\n```\n\nThe following query returns all users where the nested `owned` > `cats` array contains `\"Elliott\"`.\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    pets: {      path: ['owned', 'cats'],      array_contains: ['Elliott'],    },  },})\n```\n\nwarning\n\nFiltering by the key values of objects inside an array (below) is only supported by the MySQL connector.\n\nThe following query returns all users where the nested `favorites` > `treats` array contains an object where the `name` value is `\"Dreamies\"`:\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    pets: {      path: '$.favorites.treats[*].name',      array_contains: 'Dreamies',    },  },})\n```\n\n### `string_contains`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#string_contains \"Direct link to string_contains\")\n\nThe following query returns all users where the nested `favorites` > `catBreed` key value contains `\"Van\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    pets: {      path: ['favorites', 'catBreed'],      string_contains: 'Van',    },  },})\n```\n\n### `string_starts_with`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#string_starts_with \"Direct link to string_starts_with\")\n\nThe following query returns all users where the nested `favorites` > `catBreed` key value starts with `\"Turkish\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    pets: {      path: ['favorites', 'catBreed'],      string_starts_with: 'Turkish',    },  },})\n```\n\n### `string_ends_with`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#string_ends_with \"Direct link to string_ends_with\")\n\nThe following query returns all users where the nested `favorites` > `catBreed` key value ends with `\"Van\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    pets: {      path: ['favorites', 'catBreed'],      string_ends_with: 'Van',    },  },})\n```\n\n### `array_contains`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#array_contains \"Direct link to array_contains\")\n\nThe following query returns all users where the `sanctuaries` array contains the value `\"RSPCA\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    pets: {      path: ['sanctuaries'],      array_contains: ['RSPCA'],    },  },})\n```\n\ninfo\n\n**Note**: In PostgreSQL, the value of `array_contains` must be an array and not a string, even if the array only contains a single value.\n\nThe following query returns all users where the `sanctuaries` array contains _all_ the values in the given array:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    pets: {      path: ['sanctuaries'],      array_contains: ['RSPCA', 'Alley Cat Allies'],    },  },})\n```\n\n### `array_starts_with`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#array_starts_with \"Direct link to array_starts_with\")\n\nThe following query returns all users where the `sanctuaries` array starts with the value `\"RSPCA\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    pets: {      path: ['sanctuaries'],      array_starts_with: 'RSPCA',    },  },})\n```\n\n### `array_ends_with`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#array_ends_with \"Direct link to array_ends_with\")\n\nThe following query returns all users where the `sanctuaries` array ends with the value `\"Alley Cat Allies\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    pets: {      path: ['sanctuaries'],      array_ends_with: 'Alley Cat Allies',    },  },})\n```\n\n## Client methods[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#client-methods \"Direct link to Client methods\")\n\n**Note:** Client-level methods are prefixed by `$`.\n\n*   `$on` and `$use` client methods do not exist on extended client instances which are extended using [`$extends`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#extends)\n\nwarning\n\nIn [extended clients](https://www.prisma.io/docs/orm/prisma-client/client-extensions), Client methods do not necessarily exist. If you are extending your client, make sure to check for existence before using Client methods like `$transaction` or `$connect`.\n\nIn addition, if you are using `$on` or `$use`, you will need to use these client methods before extending your client as these methods do not exist on extended clients. For `$use` specifically we recommend transitioning [to use query extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query).\n\n### `$disconnect()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#disconnect-1 \"Direct link to disconnect-1\")\n\nThe `$disconnect()` method closes the database connections that were established when `$connect` was called and stops the process that was running Prisma ORM's query engine. See [Connection management](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management) for an overview of `$connect()` and `$disconnect()`.\n\n*   `$disconnect()` returns a `Promise`, so you should call it inside an `async` function with the `await` keyword.\n\n### `$connect()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect-1 \"Direct link to connect-1\")\n\nThe `$connect()` method establishes a physical connection to the database via Prisma ORM's query engine. See [Connection management](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management) for an overview of `$connect()` and `$disconnect()`.\n\n*   `$connect()` returns a `Promise`, so you should call it inside an `async` function with the `await` keyword.\n\n### `$on()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#on \"Direct link to on\")\n\nwarning\n\n`$on` is not available in [extended clients](https://www.prisma.io/docs/orm/prisma-client/client-extensions). Please either migrate to client extensions or use the `$on` method prior to extending your client.\n\nThe `$on()` method allows you to subscribe to [logging events](https://www.prisma.io/docs/orm/reference/prisma-client-reference#log) or the [exit hook](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#exit-hooks).\n\n### `$use()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#use \"Direct link to use\")\n\nThe `$use()` method adds [middleware](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware) :\n\n```\nprisma.$use(async (params, next) => {  console.log('This is middleware!')  // Modify or interrogate params here  return next(params)})\n```\n\n#### `next`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#next \"Direct link to next\")\n\n`next` represents the \"next level\" in the middleware stack, which could be the next middleware or the Prisma Query, depending on [where in the stack you are](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware#running-order-and-the-middleware-stack).\n\n#### `params`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#params \"Direct link to params\")\n\n`params` is an object with information to use in your middleware.\n\nParameter\n\nDescription\n\n`action`\n\nThe query type - for example, `create` or `findMany`.\n\n`args`\n\nArguments that were passed into the query - for example, `where`, `data`, or `orderBy`\n\n`dataPath`\n\nPopulated if you use the [fluent API](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api).\n\n`model`\n\nThe model type - for example, `Post` or `User`.\n\n`runInTransaction`\n\nReturns `true` if the query ran in the context of a [transaction](https://www.prisma.io/docs/orm/reference/prisma-client-reference#transaction).\n\ntip\n\nIf you need the `model` property as a string, use: `String(params.model)`\n\nExample parameter values:\n\n```\n{  args: { where: { id: 15 } },  dataPath: [ 'select', 'author', 'select', 'posts' ],  runInTransaction: false,  action: 'findMany',  model: 'Post'}\n```\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-80 \"Direct link to Examples\")\n\nSee [middleware examples](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware#samples) .\n\n### `$queryRaw`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#queryraw \"Direct link to queryraw\")\n\nSee: [Raw database access (`$queryRaw`)](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#queryraw).\n\n### `$queryRawUnsafe()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#queryrawunsafe \"Direct link to queryrawunsafe\")\n\nSee: [Raw database access (`$queryRawUnsafe()`)](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#queryrawunsafe).\n\n### `$executeRaw`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#executeraw \"Direct link to executeraw\")\n\nSee: [Raw database access (`$executeRaw`)](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#executeraw).\n\n### `$executeRawUnsafe()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#executerawunsafe \"Direct link to executerawunsafe\")\n\nSee: [Raw database access (`$executeRawUnsafe()`)](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#executerawunsafe).\n\n### `$runCommandRaw()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#runcommandraw \"Direct link to runcommandraw\")\n\nSee: [Raw database access (`$runCommandRaw()`)](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#runcommandraw).\n\n### `$transaction()`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#transaction \"Direct link to transaction\")\n\nSee: [Transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions).\n\n### `$metrics`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#metrics \"Direct link to metrics\")\n\nPrisma Client metrics give you a detailed insight into how Prisma Client interacts with your database. You can use this insight to help diagnose performance issues with your application. Learn more: [Metrics](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics).\n\nPrisma Client metrics has the following methods:\n\n*   `$metrics.json()`: [Retrieves Prisma Client metrics in JSON format](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics#retrieve-metrics-in-json-format).\n*   `$metrics.prometheus()`: [Retrieves Prisma Client metrics in Prometheus format](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics#retrieve-metrics-in-prometheus-format).\n\n### `$extends`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#extends \"Direct link to extends\")\n\nWith `$extends`, you can create and use Prisma Client extensions to add functionality to Prisma Client in the following ways:\n\n*   `model`: add custom methods to your models\n*   `client`: add custom methods to your client\n*   `query`: create custom Prisma Client queries\n*   `result`: add custom fields to your query results\n\nLearn more: [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions).\n\n## Utility types[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#utility-types \"Direct link to Utility types\")\n\nUtility types are helper functions and types that live on the `Prisma` namespace. They are useful for keeping your application type safe.\n\n### `Prisma.validator`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#prismavalidator \"Direct link to prismavalidator\")\n\nThe `validator` helps you create re-usable query parameters based on your schema models while making sure that the objects you create are valid. See also: [Using `Prisma.validator`](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator)\n\nThere are two ways you can use the `validator`:\n\n#### Using generated Prisma Client types[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#using-generated-prisma-client-types \"Direct link to Using generated Prisma Client types\")\n\nUsing types provides a type-level approach to validate data:\n\n```\nPrisma.validator<GeneratedType>({ args })\n```\n\n#### Using a \"selector\"[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#using-a-selector \"Direct link to Using a \"selector\"\")\n\nWhen using the selector pattern, you use an existing Prisma Client instance to create a validator. This pattern allows you to select the model, operation, and query option to validate against.\n\nYou can also use an instance of Prisma Client that has been extended using a [Prisma Client extension](https://www.prisma.io/docs/orm/prisma-client/client-extensions).\n\n```\nPrisma.validator(  PrismaClientInstance,  '<model>',  '<operation>',  '<query option>')({ args })\n```\n\n#### Examples[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#examples-81 \"Direct link to Examples\")\n\nThe following example shows how you can extract and validate the input for the `create` operation you can reuse within your app:\n\n```\nimport { Prisma } from '@prisma/client'const validateUserAndPostInput = (name, email, postTitle) => {  return Prisma.validator<Prisma.UserCreateInput>()({    name,    email,    posts: {      create: {        title: postTitle,      },    },  })}\n```\n\nHere is an alternative syntax for the same operation:\n\n```\nimport { Prisma } from '@prisma/client'import prisma from './prisma'const validateUserAndPostInput = (name, email, postTitle) => {  return Prisma.validator(    prisma,    'user',    'create',    'data'  )({    name,    email,    posts: {      create: {        title: postTitle,      },    },  })}\n```\n\n## Compare columns in the same table[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#compare-columns-in-the-same-table \"Direct link to Compare columns in the same table\")\n\nYou can compare columns in the same table directly, for non-unique filters.\n\nThis feature was moved to general availability in version 5.0.0 and was available via the `fieldReference` Preview feature from Prisma ORM versions 4.3.0 to 4.16.2.\n\nTo compare columns in the same table, use the `<model>.fields` property. In the following example, the query returns all records where the value in the `prisma.product.quantity` field is less than or equal to the value in the `prisma.product.warnQuantity` field.\n\n```\nprisma.product.findMany({  where: { quantity: { lte: prisma.product.fields.warnQuantity } },})\n```\n\ninfo\n\n`fields` is a special property of every model. It contains the list of fields for that model.\n\n### Considerations[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#considerations \"Direct link to Considerations\")\n\n#### Fields must be of the same type[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#fields-must-be-of-the-same-type \"Direct link to Fields must be of the same type\")\n\nYou can only make comparisons on fields of the same type. For example, the following causes an error:\n\n```\nawait prisma.order.findMany({  where: {    id: { equals: prisma.order.fields.due },    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    // Type error: id is a string, while amountDue is an integer  },})\n```\n\n#### Fields must be in the same model[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#fields-must-be-in-the-same-model \"Direct link to Fields must be in the same model\")\n\nYou can only make comparisons with the `fields` property on fields in the same model. The following example does not work:\n\n```\nawait prisma.order.findMany({  where: {    id: { equals: prisma.user.fields.name },    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    // Type error: name is a field on the User model, not Order  },})\n```\n\nHowever, you can compare fields in separate models with [standard queries](https://www.prisma.io/docs/orm/reference/prisma-client-reference#model-queries).\n\n#### In `groupBy` model queries, put your referenced fields in the `by` argument[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#in-groupby-model-queries-put-your-referenced-fields-in-the-by-argument \"Direct link to in-groupby-model-queries-put-your-referenced-fields-in-the-by-argument\")\n\nIf you use the [groupBy](https://www.prisma.io/docs/orm/reference/prisma-client-reference#groupby) model query with the `having` option, then you must put your referenced fields in the `by` argument.\n\nThe following example works:\n\n```\nprisma.user.groupBy({  by: ['id', 'name'],  having: { id: { equals: prisma.user.fields.name } },})\n```\n\nThe following example does not work, because `name` is not in the `by` argument:\n\n```\nprisma.user.groupBy({  by: ['id'],  having: { id: { equals: prisma.user.fields.name } },  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  // name is not in the 'by' argument})\n```\n\n#### Search for fields in scalar lists[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#search-for-fields-in-scalar-lists \"Direct link to Search for fields in scalar lists\")\n\nIf your data source supports scalar lists (for example in PostgreSQL), then you can search for all records where a specific field is in a list of fields. To do so, reference the scalar list with the [`in`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#in) and [`notIn`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#notin) filters. For example:\n\n```\nawait prisma.user.findMany({  where: {    // find all users where 'name' is in a list of tags    name: { in: prisma.user.fields.tags },  },})\n```\n\n## Filter on non-unique fields with `UserWhereUniqueInput`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-on-non-unique-fields-with-userwhereuniqueinput \"Direct link to filter-on-non-unique-fields-with-userwhereuniqueinput\")\n\nFrom version 5.0.0, the generated type `UserWhereUniqueInput` on [`where`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#where) exposes all fields on the model, not just unique fields. This was available under the [`extendedWhereUnique` Preview flag](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#preview-features-promoted-to-general-availability) between versions 4.5.0 to 4.16.2\n\nYou must specify at least one unique field in your `where` statement [outside of boolean operators](https://www.prisma.io/docs/orm/reference/prisma-client-reference#boolean-operators-with-userwhereuniqueinput), and you can specify any number of additional unique and non-unique fields. You can use this to add filters to any operation that returns a single record. For example, you can use this feature for the following:\n\n*   [Optimistic concurrency control on updates](https://www.prisma.io/docs/orm/reference/prisma-client-reference#optimistic-concurrency-control-on-updates)\n*   [Permission checks](https://www.prisma.io/docs/orm/reference/prisma-client-reference#permission-checks)\n*   [Soft deletes](https://www.prisma.io/docs/orm/reference/prisma-client-reference#soft-deletes)\n\nFrom version 4.6.0, you can use this feature to filter on optional [one-to-one nested reads](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads).\n\n### Optimistic concurrency control on updates[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#optimistic-concurrency-control-on-updates \"Direct link to Optimistic concurrency control on updates\")\n\nYou can filter on non-unique fields to perform [optimistic concurrency control](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#optimistic-concurrency-control) on `update` operations.\n\nTo perform optimistic concurrency control, we recommend that you use a `version` field to check whether the data in a record or related record has changed while your code executes. Before version 4.5.0, you could not evaluate the `version` field in an `update` operation, because the field is non-unique. From version 4.5.0, you can evaluate the `version` field.\n\nIn the following example, `updateOne` and `updateTwo` first read the same record and then attempt to update it. The database only executes these updates if the value in `version` is the same as the value when it did the initial read. When the database executes the first of these updates (which might be `updateOne` or `updateTwo`, depending on timing), it increments the value in `version`. This means that the database does not execute the second update because the value in `version` has changed.\n\n```\nmodel User {  id      Int    @id @default(autoincrement())  email   String @unique  city    String  version Int}\n```\n\n```\nfunction updateOne() {  const user = await prisma.user.findUnique({ id: 1 })  await prisma.user.update({    where: { id: user.id, version: user.version },    data: { city: 'Berlin', version: { increment: 1 } },  })}function updateTwo() {  const user = await prisma.user.findUnique({ id: 1 })  await prisma.user.update({    where: { id: user.id, version: user.version },    data: { city: 'New York', version: { increment: 1 } },  })}function main() {  await Promise.allSettled([updateOne(), updateTwo()])}\n```\n\n### Permission checks[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#permission-checks \"Direct link to Permission checks\")\n\nYou can filter on non-unique fields to check permissions during an update.\n\nIn the following example, a user wants to update a post title. The `where` statement checks the value in `authorId` to confirm that the user is the author of the post. The application only updates the post title if the user is the post author.\n\n```\nawait prisma.post.update({  where: { id: 1, authorId: 1 },  data: { title: 'Updated post title' },})\n```\n\n### Soft deletes[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#soft-deletes \"Direct link to Soft deletes\")\n\nYou can filter on non-unique fields to handle soft deletes.\n\nIn the following example, we do not want to return a post if it is soft-deleted. The operation only returns the post if the value in `isDeleted` is `false`.\n\n```\nprisma.Post.findUnique({ where: { id: postId, isDeleted: false } })\n```\n\n### `UserWhereUniqueInput` considerations[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#userwhereuniqueinput-considerations \"Direct link to userwhereuniqueinput-considerations\")\n\n#### Boolean operators with `UserWhereUniqueInput`[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#boolean-operators-with-userwhereuniqueinput \"Direct link to boolean-operators-with-userwhereuniqueinput\")\n\nWith `UserWhereUniqueInput`, you must specify at least one unique field outside of the boolean operators `AND`, `OR`, `NOT`. You can still use these boolean operators in conjunction with any other unique fields or non-unique fields in your filter.\n\nIn the following example, we test `id`, a unique field, in conjunction with `email`. This is valid.\n\n```\nawait prisma.user.update({  where: { id: 1, OR: [{ email: \"bob@prisma.io\" }, { email: \"alice@prisma.io\" }] },        // ^^^ Valid: the expression specifies a unique field (`id`) outside of any boolean operators  data: { ... }})// SQL equivalent:// WHERE id = 1 AND (email = \"bob@prisma.io\" OR email = \"alice@prisma.io\")\n```\n\nThe following example is not valid, because there is no unique field outside of any boolean operators:\n\n```\nawait prisma.user.update({  where: { OR: [{ email: \"bob@prisma.io\" }, { email: \"alice@prisma.io\" }] },        // ^^^ Invalid: the expressions does not contain a unique field outside of boolean operators  data: { ... }})\n```\n\n#### One-to-one relations[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#one-to-one-relations \"Direct link to One-to-one relations\")\n\nFrom version 4.5.0, you can filter on non-unique fields in the following operations on [one-to-one relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations):\n\n*   Nested update\n*   Nested upsert\n*   Nested disconnect\n*   Nested delete\n\nPrisma Client automatically uses a unique filter to select the appropriate related record. As a result, you do not need to specify a unique filter in your `where` statement with a `WhereUniqueInput` [generated type](https://www.prisma.io/docs/orm/reference/prisma-client-reference#generated-types-for-where). Instead, the `where` statement has a `WhereInput` generated type. You can use this to filter without the restrictions of `WhereUniqueInput`.\n\n##### Nested update example[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#nested-update-example \"Direct link to Nested update example\")\n\n```\nawait prisma.user.update({  where: { id: 1, },  data: {    to_one: {      // Before Prisma version 4.5.0      update: { field: \"updated\" }      // From Prisma version 4.5.0, you can also do the following:      update: { where: { /*WhereInput*/ }, data: { field: \"updated\" } } }    }  }})\n```\n\n##### Nested upsert example[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#nested-upsert-example \"Direct link to Nested upsert example\")\n\n```\nawait prisma.user.update({  where: { id: 1, },  data: {    to_one: {      upsert: {        where: { /* WhereInput */ } // new argument from Prisma 4.5.0        create: { /* CreateInput */ },        update: { /* CreateInput */ },      }    }  }})\n```\n\n##### Nested disconnect example[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#nested-disconnect-example \"Direct link to Nested disconnect example\")\n\n```\nawait prisma.user.update({  where: { id: 1, },  data: {    to_one: {      // Before Prisma version 4.5.0      disconnect: true      // From Prisma version 4.5.0, you can also do the following:      disconnect: { /* WhereInput */ }    }  }})\n```\n\n##### Nested delete example[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#nested-delete-example \"Direct link to Nested delete example\")\n\n```\nawait prisma.user.update({  where: { id: 1, },  data: {    to_one: {      // Before Prisma version 4.5.0      delete: true      // From Prisma version 4.5.0, you can also do the following:      delete: { /* WhereInput */ }    }  }})\n```\n\n## `PrismaPromise` behavior[​](https://www.prisma.io/docs/orm/reference/prisma-client-reference#prismapromise-behavior \"Direct link to prismapromise-behavior\")\n\nAll Prisma Client queries return an instance of `PrismaPromise`. This is a [\"thenable\"](https://masteringjs.io/tutorials/fundamentals/thenable), meaning a `PrismaPromise` only executes when you call `await` or `.then()` or `.catch()`. This behavior is different from a regular JavaScript [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), which starts executing immediately.\n\nFor example:\n\n```\nconst findPostOperation = prisma.post.findMany({}) // Query not yet executedfindPostOperation.then() // Prisma Client now executes the query// orawait findPostOperation // Prisma Client now executes the query\n```\n\nWhen using the [`$transaction` API](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#the-transaction-api), this behavior makes it possible for Prisma Client to pass all the queries on to the query engine as a single transaction.",
  "title": "Prisma Client API | Prisma Documentation",
  "description": "API reference documentation for Prisma Client.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more",
  "markdown": "# More | Prisma Documentation\n\n[\n\n## ORM releases and maturity levels\n\n](https://www.prisma.io/docs/orm/more/releases)",
  "title": "More | Prisma Documentation",
  "description": "Learn more about Prisma ORM.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/under-the-hood",
  "markdown": "# Under the hood | Prisma Documentation\n\nThis page gives an overview of the Prisma ORM internals and how it works \"under the hood\".\n\nNote that **this page does not contain any practical information that is relevant for _using_ Prisma ORM**. It rather aims at providing a _mental model_ for what the Prisma ORM toolkit _actually_ is and how the different tools that are available to developers are structured.\n\nIf you're new to using Prisma ORM, be sure to check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart) and [Introduction](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma) pages first.\n\n## In this section[​](https://www.prisma.io/docs/orm/more/under-the-hood#in-this-section \"Direct link to In this section\")\n\n[\n\n## Engines\n\n](https://www.prisma.io/docs/orm/more/under-the-hood/engines)",
  "title": "Under the hood | Prisma Documentation",
  "description": "Learn about Prisma ORM internals and how it works \"under the hood\". Prisma ORM tools are based on an engine-layer which manages the communication with the database.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/upgrade-guides",
  "markdown": "# Upgrade guides | Prisma Documentation\n\n[\n\n## Upgrading to use Preview features\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-to-use-preview-features)",
  "title": "Upgrade guides | Prisma Documentation",
  "description": "Learn how to upgrade Prisma ORM versions.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting",
  "markdown": "# Help & troubleshooting | Prisma Documentation\n\n## In this section[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting#in-this-section \"Direct link to In this section\")\n\n[\n\n## Creating bug reports\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports)\n\n[\n\n## Help articles\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles)",
  "title": "Help & troubleshooting | Prisma Documentation",
  "description": "Help & troubleshooting in Prisma ORM projects.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/development-environment",
  "markdown": "# Development environment | Prisma Documentation\n\nThis section describes using `env` variables, editors, and workspaces in your development environment.\n\n## In this section[​](https://www.prisma.io/docs/orm/more/development-environment#in-this-section \"Direct link to In this section\")\n\n[\n\n## Environment variables\n\n](https://www.prisma.io/docs/orm/more/development-environment/environment-variables)\n\n[\n\n## Editor setup\n\n](https://www.prisma.io/docs/orm/more/development-environment/editor-setup)",
  "title": "Development environment | Prisma Documentation",
  "description": "Using env vars, editors and workspaces in your development environment",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/comparisons",
  "markdown": "# Comparing Prisma ORM to other ORMs and ODMs.\n\nFind out how Prisma ORM compares to ORMs and ODMs in the Node.js and TypeScript ecosystem.\n\nFor a comprehensive overview of the most popular database libraries, read this article: [Top Node.js ORMs, Query Builders & Database Libraries in 2022](https://www.prisma.io/dataguide/database-tools/top-nodejs-orms-query-builders-and-database-libraries).\n\n## In this section[​](https://www.prisma.io/docs/orm/more/comparisons#in-this-section \"Direct link to In this section\")\n\n[\n\n## TypeORM\n\n](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm)\n\n[\n\n## Sequelize\n\n](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize)\n\n[\n\n## Mongoose\n\n](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose)\n\n[\n\n## Drizzle\n\n](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle)",
  "title": "Comparing Prisma ORM to other ORMs and ODMs. | Prisma Documentation",
  "description": "Learn how Prisma ORM compares to other ORMs, ODMs, and database libraries, like TypeORM, Sequelize and Mongoose.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/releases",
  "markdown": "# ORM releases and maturity levels\n\nThis page explains the release process of Prisma ORM, how it's versioned and how to deal with breaking changes that might happen throughout releases.\n\n## Releases[​](https://www.prisma.io/docs/orm/more/releases#releases \"Direct link to Releases\")\n\nPrisma ORM releases typically happen every three weeks. Note that this is _not_ a hard rule – releases might be postponed for internal reasons.\n\n[Check out all the releases notes in GitHub](https://github.com/prisma/prisma/releases).\n\n## Product maturity levels[​](https://www.prisma.io/docs/orm/more/releases#product-maturity-levels \"Direct link to Product maturity levels\")\n\nA release can include products or features at different maturity levels. Maturity level describes a product or feature's completeness and what users can expect in terms of breaking changes.\n\n> **Note**: As of version [2.13.0](https://github.com/prisma/prisma/releases/2.13.0), 'Experimental' is no longer part of the product maturity scale.\n\n### Early Access[​](https://www.prisma.io/docs/orm/more/releases#early-access \"Direct link to Early Access\")\n\nIf a feature or product is **Early Access**:\n\n*   We have validated a problem and are considering a solution to it but are not certain whether that solution is complete or a perfect fit.\n*   We want to gather more feedback and adjust the solution as necessary, knowing that users are prepared for significant breaking changes\n\nWe don't recommend using Early Access features or products in production.\n\n### Preview[​](https://www.prisma.io/docs/orm/more/releases#preview \"Direct link to Preview\")\n\nIf a feature or product is a **Preview**:\n\n*   We have validated the feature or product in terms of direction and surface.\n*   Users can count on the feature or product and associated API to be mostly stable unless stated otherwise in the release notes and documentation.\n*   There are no significant known issues, although minor bugs may exist.\n*   We welcome feedback on these to make the solution stable as quickly as possible.\n\nPreviews are typically available behind a feature flag or require some form of opt-in (for example, by providing a `--preview-feature` flag in the CLI or [adding them to a `previewFeatures` property in the `generator` block](https://www.prisma.io/docs/orm/reference/preview-features/cli-preview-features) for Prisma Client in your Prisma schema).\n\nWe don't recommend using Preview features or products in production.\n\nSee also: [All currently available Preview features](https://www.prisma.io/docs/orm/reference/preview-features).\n\n### Generally Available (GA)[​](https://www.prisma.io/docs/orm/more/releases#generally-available-ga \"Direct link to Generally Available (GA)\")\n\nIf a feature or product is **Generally Available**:\n\n*   The solution has been tested for some time and we received enough feedback to consider it stable and ready for production use.\n*   There should be no bugs in 99% of cases (completely bug-free software cannot be guaranteed)\n\n## Roadmap[​](https://www.prisma.io/docs/orm/more/releases#roadmap \"Direct link to Roadmap\")\n\nOur roadmap helps us share our current priorities: what we are currently working on and what we are planning to work on in the near term. This reflects our _current plans_ today, and the content is subject to change at any time. Actual results and plans may differ as a result of changing our product strategy or reacting to demands from our user base.\n\nYou can [check out the full roadmap here](https://pris.ly/roadmap).\n\n## Versioning[​](https://www.prisma.io/docs/orm/more/releases#versioning \"Direct link to Versioning\")\n\nPrisma ORM's release scheme adheres to Semantic Versioning ([SemVer](https://semver.org/)) starting with version `3.x.x`.\n\n### Prisma ORM and Semantic Versioning (SemVer)[​](https://www.prisma.io/docs/orm/more/releases#prisma-orm-and-semantic-versioning-semver \"Direct link to Prisma ORM and Semantic Versioning (SemVer)\")\n\n#### How does SemVer versioning work?[​](https://www.prisma.io/docs/orm/more/releases#how-does-semver-versioning-work \"Direct link to How does SemVer versioning work?\")\n\nSemantic Versioning (SemVer) uses the following rules for version upgrade (quoted from the [SemVer](https://semver.org/) spec):\n\n_Given a version number `MAJOR.MINOR.PATCH`, increment the:_\n\n1.  _`MAJOR` version when you make incompatible API changes,_\n2.  _`MINOR` version when you add functionality in a backward compatible manner, and_\n3.  _`PATCH` version when you make backward compatible bug fixes._\n\n#### How does Prisma ORM versioning follow SemVer?[​](https://www.prisma.io/docs/orm/more/releases#how-does-prisma-orm-versioning-follow-semver \"Direct link to How does Prisma ORM versioning follow SemVer?\")\n\nBeginning with version `3.x.x`, Prisma ORM adheres strictly to the [SemVer](https://semver.org/) versioning scheme.\n\nHere is a brief overview of how Prisma ORM's follows SemVer:\n\n*   Breaking changes in stable surface (i.e. [General Availability](https://www.prisma.io/docs/orm/more/releases#generally-available-ga)) will only be introduced in new `MAJOR` releases.\n*   Breaking changes can still be rolled out in `MINOR` but only for opt-in Preview and Early Access features that are not active by default (e.g. via a Preview feature flag or a specific opt-in option or new CLI command).\n*   Opt-in breaking changes, i.e. Preview and Early Access, released in `MINOR`, will only be promoted to General Availability (no requirement for opt-in) in new `MAJOR` releases.\n\nGiven a version number `MAJOR.MINOR.PATCH`, Prisma ORM's version number is incremented as follows:\n\n1.  `MAJOR` version is incremented when major product updates **with breaking changes** are released to General Availability.\n2.  `MINOR` version is incremented when product updates adding backward compatible new functionality are released. Features with breaking changes may only be introduced if they are **opt-in**, i.e. Early Access and Preview.\n3.  `PATCH` version is incremented when functionality bugs are fixed and are always **backward compatible**.\n\n> **Note:** Up until version `2.28.0`, Prisma ORM did not follow SemVer versioning strictly. This means that releases in the `2.MINOR.PATCH` range, `MINOR` versions may have included breaking changes. To learn more about Prisma ORM's adoption of SemVer, check out the [blog post](https://www.prisma.io/blog/prisma-adopts-semver-strictly).",
  "title": "ORM releases and maturity levels | Prisma Documentation",
  "description": "Learn about the release process, versioning, and maturity of Prisma ORM components and how to deal with breaking changes that might happen throughout releases.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations",
  "markdown": "# Relations (Reference) | Prisma Documentation\n\nA relation is a _connection_ between two models in the Prisma schema. For example, there is a one-to-many relation between `User` and `Post` because one user can have many blog posts.\n\nThe following Prisma schema defines a one-to-many relation between the `User` and `Post` models. The fields involved in defining the relation are highlighted:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  posts Post[]}model Post {  id       Int  @id @default(autoincrement())  author   User @relation(fields: [authorId], references: [id])  authorId Int // relation scalar field  (used in the `@relation` attribute above)}\n```\n\nAt a Prisma ORM level, the `User` / `Post` relation is made up of:\n\n*   Two [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields): `author` and `posts`. Relation fields define connections between models at the Prisma ORM level and **do not exist in the database**. These fields are used to generate Prisma Client.\n*   The scalar `authorId` field, which is referenced by the `@relation` attribute. This field **does exist in the database** - it is the foreign key that connects `Post` and `User`.\n\nAt a Prisma ORM level, a connection between two models is **always** represented by a [relation field](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) on **each side** of the relation.\n\n## Relations in the database[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relations-in-the-database \"Direct link to Relations in the database\")\n\n### Relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relational-databases \"Direct link to Relational databases\")\n\nThe following entity relationship diagram defines the same one-to-many relation between the `User` and `Post` tables in a **relational database**:\n\n![A one-to-many relationship between a user and posts table.](https://www.prisma.io/docs/assets/images/one-to-many-9fd7879c7dbeeb3a0409b55ba7f8ccd9.png)\n\nIn SQL, you use a _foreign key_ to create a relation between two tables. Foreign keys are stored on **one side** of the relation. Our example is made up of:\n\n*   A foreign key column in the `Post` table named `authorId`.\n*   A primary key column in the `User` table named `id`. The `authorId` column in the `Post` table references the `id` column in the `User` table.\n\nIn the Prisma schema, the foreign key / primary key relationship is represented by the `@relation` attribute on the `author` field:\n\n```\nauthor     User        @relation(fields: [authorId], references: [id])\n```\n\n> **Note**: Relations in the Prisma schema represent relationships that exist between tables in the database. If the relationship does not exist in the database, it does not exist in the Prisma schema.\n\n### MongoDB[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#mongodb \"Direct link to MongoDB\")\n\nFor MongoDB, Prisma ORM currently uses a [normalized data model design](https://docs.mongodb.com/manual/core/data-model-design/), which means that documents reference each other by ID in a similar way to relational databases.\n\nThe following document represents a `User` (in the `User` collection):\n\n```\n{ \"_id\": { \"$oid\": \"60d5922d00581b8f0062e3a8\" }, \"name\": \"Ella\" }\n```\n\nThe following list of `Post` documents (in the `Post` collection) each have a `authorId` field which reference the same user:\n\n```\n[  {    \"_id\": { \"$oid\": \"60d5922e00581b8f0062e3a9\" },    \"title\": \"How to make sushi\",    \"authorId\": { \"$oid\": \"60d5922d00581b8f0062e3a8\" }  },  {    \"_id\": { \"$oid\": \"60d5922e00581b8f0062e3aa\" },    \"title\": \"How to re-install Windows\",    \"authorId\": { \"$oid\": \"60d5922d00581b8f0062e3a8\" }  }]\n```\n\nThis data structure represents a one-to-many relation because multiple `Post` documents refer to the same `User` document.\n\n#### `@db.ObjectId` on IDs and relation scalar fields[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#dbobjectid-on-ids-and-relation-scalar-fields \"Direct link to dbobjectid-on-ids-and-relation-scalar-fields\")\n\nIf your model's ID is an `ObjectId` (represented by a `String` field), you must add `@db.ObjectId` to the model's ID _and_ the relation scalar field on the other side of the relation:\n\n```\nmodel User {  id    String @id @default(auto()) @map(\"_id\") @db.ObjectId  posts Post[]}model Post {  id       String @id @default(auto()) @map(\"_id\") @db.ObjectId  author   User   @relation(fields: [authorId], references: [id])  authorId String @db.ObjectId // relation scalar field  (used in the `@relation` attribute above)}\n```\n\n## Relations in Prisma Client[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relations-in-prisma-client \"Direct link to Relations in Prisma Client\")\n\nPrisma Client is generated from the Prisma schema. The following examples demonstrate how relations manifest when you use Prisma Client to get, create, and update records.\n\n### Create a record and nested records[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#create-a-record-and-nested-records \"Direct link to Create a record and nested records\")\n\nThe following query creates a `User` record and two connected `Post` records:\n\n```\nconst userAndPosts = await prisma.user.create({  data: {    posts: {      create: [        { title: 'Prisma Day 2020' }, // Populates authorId with user's id        { title: 'How to write a Prisma schema' }, // Populates authorId with user's id      ],    },  },})\n```\n\nIn the underlying database, this query:\n\n1.  Creates a `User` with an auto-generated `id` (for example, `20`)\n2.  Creates two new `Post` records and sets the `authorId` of both records to `20`\n\n### Retrieve a record and include related records[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#retrieve-a-record-and-include-related-records \"Direct link to Retrieve a record and include related records\")\n\nThe following query retrieves a `User` by `id` and includes any related `Post` records:\n\n```\nconst getAuthor = await prisma.user.findUnique({  where: {    id: \"20\",  },  include: {    posts: true, // All posts where authorId == 20  },});\n```\n\nIn the underlying database, this query:\n\n1.  Retrieves the `User` record with an `id` of `20`\n2.  Retrieves all `Post` records with an `authorId` of `20`\n\n### Associate an existing record to another existing record[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#associate-an-existing-record-to-another-existing-record \"Direct link to Associate an existing record to another existing record\")\n\nThe following query associates an existing `Post` record with an existing `User` record:\n\n```\nconst updateAuthor = await prisma.user.update({  where: {    id: 20,  },  data: {    posts: {      connect: {        id: 4,      },    },  },})\n```\n\nIn the underlying database, this query uses a [nested `connect` query](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect) to link the post with an `id` of 4 to the user with an `id` of 20. The query does this with the following steps:\n\n*   The query first looks for the user with an `id` of `20`.\n*   The query then sets the `authorID` foreign key to `20`. This links the post with an `id` of `4` to the user with an `id` of `20`.\n\nIn this query, the current value of `authorID` does not matter. The query changes `authorID` to `20`, no matter its current value.\n\n## Types of relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#types-of-relations \"Direct link to Types of relations\")\n\nThere are three different types (or [cardinalities](https://en.wikipedia.org/wiki/Cardinality_(data_modeling))) of relations in Prisma ORM:\n\n*   [One-to-one](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations) (also called 1-1 relations)\n*   [One-to-many](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations) (also called 1-n relations)\n*   [Many-to-many](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations) (also called m-n relations)\n\nThe following Prisma schema includes every type of relation:\n\n*   one-to-one: `User` ↔ `Profile`\n*   one-to-many: `User` ↔ `Post`\n*   many-to-many: `Post` ↔ `Category`\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  posts   Post[]  profile Profile?}model Profile {  id     Int  @id @default(autoincrement())  user   User @relation(fields: [userId], references: [id])  userId Int  @unique // relation scalar field (used in the `@relation` attribute above)}model Post {  id         Int        @id @default(autoincrement())  author     User       @relation(fields: [authorId], references: [id])  authorId   Int // relation scalar field  (used in the `@relation` attribute above)  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\nNotice that the syntax is slightly different between relational databases and MongoDB - particularly for [many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations).\n\nFor relational databases, the following entity relationship diagram represents the database that corresponds to the sample Prisma schema:\n\n![The sample schema as an entity relationship diagram](https://www.prisma.io/docs/assets/images/sample-schema-bb495abfe60492352874c8d62ceb36bc.png)\n\nFor MongoDB, Prisma ORM uses a [normalized data model design](https://docs.mongodb.com/manual/core/data-model-design/), which means that documents reference each other by ID in a similar way to relational databases. See [the MongoDB section](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#mongodb) for more details.\n\n### Implicit and explicit many-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#implicit-and-explicit-many-to-many-relations \"Direct link to Implicit and explicit many-to-many relations\")\n\nMany-to-many relations in relational databases can be modelled in two ways:\n\n*   [explicit many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations), where the relation table is represented as an explicit model in your Prisma schema\n*   [implicit many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations), where Prisma ORM manages the relation table and it does not appear in the Prisma schema.\n\nImplicit many-to-many relations require both models to have a single `@id`. Be aware of the following:\n\n*   You cannot use a [multi-field ID](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1)\n*   You cannot use a `@unique` in place of an `@id`\n\nTo use either of these features, you must set up an explicit many-to-many instead.\n\nThe implicit many-to-many relation still manifests in a relation table in the underlying database. However, Prisma ORM manages this relation table.\n\nIf you use an implicit many-to-many relation instead of an explicit one, it makes the [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client) simpler (because, for example, you have one fewer level of nesting inside of [nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes)).\n\nIf you're not using Prisma Migrate but obtain your data model from [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection), you can still make use of implicit many-to-many relations by following Prisma ORM's [conventions for relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations).\n\n## Relation fields[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields \"Direct link to Relation fields\")\n\nRelation [fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-fields) are fields on a Prisma [model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-models) that do _not_ have a [scalar type](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields). Instead, their type is another model.\n\nEvery relation must have exactly two relation fields, one on each model. In the case of one-to-one and one-to-many relations, an additional _relation scalar field_ is required which gets linked by one of the two relation fields in the `@relation` attribute. This relation scalar field is the direct representation of the _foreign key_ in the underlying database.\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  email String @unique  role  Role   @default(USER)  posts Post[] // relation field (defined only at the Prisma ORM level)}model Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id]) // relation field (uses the relation scalar field `authorId` below)  authorId Int // relation scalar field (used in the `@relation` attribute above)}\n```\n\nBoth `posts` and `author` are relation fields because their types are not scalar types but other models.\n\nAlso note that the [annotated relation field](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#annotated-relation-fields) `author` needs to link the relation scalar field `authorId` on the `Post` model inside the `@relation` attribute. The relation scalar field represents the foreign key in the underlying database.\n\nThe other relation field called `posts` is defined purely on a Prisma ORM-level, it doesn't manifest in the database.\n\n### Annotated relation fields[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#annotated-relation-fields \"Direct link to Annotated relation fields\")\n\nRelations that require one side of the relation to be _annotated_ with the `@relation` attribute are referred to as _annotated relation fields_. This includes:\n\n*   one-to-one relations\n*   one-to-many relations\n*   many-to-many relations for MongoDB only\n\nThe side of the relation which is annotated with the `@relation` attribute represents the side that **stores the foreign key in the underlying database**. The \"actual\" field that represents the foreign key is required on that side of the relation as well, it's called _relation scalar field_, and is referenced inside `@relation` attribute:\n\n*   Relational databases\n*   MongoDB\n\n```\nauthor     User    @relation(fields: [authorId], references: [id])authorId   Int\n```\n\nA scalar field _becomes_ a relation scalar field when it's used in the `fields` of a `@relation` attribute.\n\n### Relation scalar fields[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-scalar-fields \"Direct link to Relation scalar fields\")\n\n#### Relation scalar field naming conventions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-scalar-field-naming-conventions \"Direct link to Relation scalar field naming conventions\")\n\nBecause a relation scalar field always _belongs_ to a relation field, the following naming convention is common:\n\n*   Relation field: `author`\n*   Relation scalar field: `authorId` (relation field name + `Id`)\n\n## The `@relation` attribute[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#the-relation-attribute \"Direct link to the-relation-attribute\")\n\nThe [`@relation`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relation) attribute can only be applied to the [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields), not to [scalar fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields).\n\nThe `@relation` attribute is required when:\n\n*   you define a one-to-one or one-to-many relation, it is required on _one side_ of the relation (with the corresponding relation scalar field)\n*   you need to disambiguate a relation (that's e.g. the case when you have two relations between the same models)\n*   you define a [self-relation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations)\n*   you define [a many-to-many relation for MongoDB](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#mongodb)\n*   you need to control how the relation table is represented in the underlying database (e.g. use a specific name for a relation table)\n\n> **Note**: [Implicit many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) in relational databases do not require the `@relation` attribute.\n\n## Disambiguating relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#disambiguating-relations \"Direct link to Disambiguating relations\")\n\nWhen you define two relations between the same two models, you need to add the `name` argument in the `@relation` attribute to disambiguate them. As an example for why that's needed, consider the following models:\n\n*   Relational databases\n*   MongoDB\n\n```\n// NOTE: This schema is intentionally incorrect. See below for a working solution.model User {  id           Int     @id @default(autoincrement())  name         String?  writtenPosts Post[]  pinnedPost   Post?}model Post {  id         Int     @id @default(autoincrement())  title      String?  author     User    @relation(fields: [authorId], references: [id])  authorId   Int  pinnedBy   User?   @relation(fields: [pinnedById], references: [id])  pinnedById Int?}\n```\n\nIn that case, the relations are ambiguous, there are four different ways to interpret them:\n\n*   `User.writtenPosts` ↔ `Post.author` + `Post.authorId`\n*   `User.writtenPosts` ↔ `Post.pinnedBy` + `Post.pinnedById`\n*   `User.pinnedPost` ↔ `Post.author` + `Post.authorId`\n*   `User.pinnedPost` ↔ `Post.pinnedBy` + `Post.pinnedById`\n\nTo disambiguate these relations, you need to annotate the relation fields with the `@relation` attribute and provide the `name` argument. You can set any `name` (except for the empty string `\"\"`), but it must be the same on both sides of the relation:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id           Int     @id @default(autoincrement())  name         String?  writtenPosts Post[]  @relation(\"WrittenPosts\")  pinnedPost   Post?   @relation(\"PinnedPost\")}model Post {  id         Int     @id @default(autoincrement())  title      String?  author     User    @relation(\"WrittenPosts\", fields: [authorId], references: [id])  authorId   Int  pinnedBy   User?   @relation(\"PinnedPost\", fields: [pinnedById], references: [id])  pinnedById Int?    @unique}\n```",
  "title": "Relations (Reference) | Prisma Documentation",
  "description": "A relation is a connection between two models in the Prisma schema. This page explains how you can define one-to-one, one-to-many and many-to-many relations in Prisma.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/models",
  "markdown": "# Models | Prisma Documentation\n\nThe data model definition part of the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) defines your application models (also called **Prisma models**). Models:\n\n*   Represent the **entities** of your application domain\n*   Map to the **tables** (relational databases like PostgreSQL) or **collections** (MongoDB) in your database\n*   Form the foundation of the **queries** available in the generated [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client)\n*   When used with TypeScript, Prisma Client provides generated **type definitions** for your models and any [variations](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types) of them to make database access entirely type safe.\n\nThe following schema describes a blogging platform - the data model definition is highlighted:\n\n*   Relational databases\n*   MongoDB\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  role    Role     @default(USER)  posts   Post[]  profile Profile?}model Profile {  id     Int    @id @default(autoincrement())  bio    String  user   User   @relation(fields: [userId], references: [id])  userId Int    @unique}model Post {  id         Int        @id @default(autoincrement())  createdAt  DateTime   @default(now())  updatedAt  DateTime   @updatedAt  title      String  published  Boolean    @default(false)  author     User       @relation(fields: [authorId], references: [id])  authorId   Int  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String  posts Post[]}enum Role {  USER  ADMIN}\n```\n\nThe data model definition is made up of:\n\n*   [Models](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-models) ([`model`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model) primitives) that define a number of fields, including [relations between models](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#relation-fields)\n*   [Enums](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-enums) ([`enum`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#enum) primitives) (if your connector supports Enums)\n*   [Attributes](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-attributes) and [functions](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#using-functions) that change the behavior of fields and models\n\nThe corresponding database looks like this:\n\n![](https://www.prisma.io/docs/assets/images/sample-database-413397970cd797641de019f57d6abd06.png)\n\nA model maps to the underlying structures of the data source.\n\n*   In relational databases like PostgreSQL and MySQL, a `model` maps to a **table**\n*   In MongoDB, a `model` maps to a **collection**\n\n> **Note**: In the future there might be connectors for non-relational databases and other data sources. For example, for a REST API it would map to a _resource_.\n\nThe following query uses Prisma Client that's generated from this data model to create:\n\n*   A `User` record\n*   Two nested `Post` records\n*   Three nested `Category` records\n\n*   Query Example\n*   Copy-Paste Example\n\n```\nconst user = await prisma.user.create({  data: {    email: 'ariadne@prisma.io',    name: 'Ariadne',    posts: {      create: [        {          title: 'My first day at Prisma',          categories: {            create: {              name: 'Office',            },          },        },        {          title: 'How to connect to a SQLite database',          categories: {            create: [{ name: 'Databases' }, { name: 'Tutorials' }],          },        },      ],    },  },})\n```\n\nYour data model reflects _your_ application domain. For example:\n\n*   In an **ecommerce** application you probably have models like `Customer`, `Order`, `Item` and `Invoice`.\n*   In a **social media** application you probably have models like `User`, `Post`, `Photo` and `Message`.\n\n## Introspection and migration[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#introspection-and-migration \"Direct link to Introspection and migration\")\n\nThere are two ways to define a data model:\n\n*   **Write the data model manually and use Prisma Migrate**: You can write your data model manually and map it to your database using [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate). In this case, the data model is the single source of truth for the models of your application.\n*   **Generate the data model via introspection**: When you have an existing database or prefer migrating your database schema with SQL, you generate the data model by [introspecting](https://www.prisma.io/docs/orm/prisma-schema/introspection) your database. In this case, the database schema is the single source of truth for the models of your application.\n\n## Defining models[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-models \"Direct link to Defining models\")\n\nModels represent the entities of your application domain. Models are represented by [`model`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model) blocks and define a number of [fields](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-fields). In the example data model above, `User`, `Profile`, `Post` and `Category` are models.\n\nA blogging platform can be extended with the following models:\n\n```\nmodel Comment {  // Fields}model Tag {  // Fields}\n```\n\n### Mapping model names to tables or collections[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections \"Direct link to Mapping model names to tables or collections\")\n\nPrisma model [naming conventions (singular form, PascalCase)](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions) do not always match table names in the database. A common approach for naming tables/collections in databases is to use plural form and [snake\\_case](https://en.wikipedia.org/wiki/Snake_case) notation - for example: `comments`. When you introspect a database with a table named `comments`, the result Prisma model will look like this:\n\n```\nmodel comments {  // Fields}\n```\n\nHowever, you can still adhere to the naming convention without renaming the underlying `comments` table in the database by using the [`@@map`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map-1) attribute:\n\n```\nmodel Comment {  // Fields  @@map(\"comments\")}\n```\n\nWith this model definition, Prisma ORM automatically maps the `Comment` model to the `comments` table in the underlying database.\n\n> **Note**: You can also [`@map`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map) a column name or enum value, and `@@map` an enum name.\n\n`@map` and `@@map` allow you to [tune the shape of your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names#using-map-and-map-to-rename-fields-and-models-in-the-prisma-client-api) by decoupling model and field names from table and column names in the underlying database.\n\n## Defining fields[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-fields \"Direct link to Defining fields\")\n\nThe properties of a model are called _fields_, which consist of:\n\n*   A **[field name](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-fields)**\n*   A **[field type](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-fields)**\n*   Optional **[type modifiers](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers)**\n*   Optional **[attributes](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-attributes)**, including [native database type attributes](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#native-types-mapping)\n\nA field's type determines its _structure_, and fits into one of two categories:\n\n*   [Scalar types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) (includes [enums](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-enums)) that map to columns (relational databases) or document fields (MongoDB) in the database - for example, [`String`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#string) or [`Int`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#int)\n*   Model types (the field is then called [relation field](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields)) - for example `Post` or `Comment[]`.\n\nThe following table describes `User` model's fields from the sample schema:\n\nExpand to see table\n\n| Name | Type | Scalar vs Relation | Type modifier | Attributes |\n| --- | --- | --- | --- | --- |\n| `id` | `Int` | Scalar | \\-  | `@id` and `@default(autoincrement())` |\n| `email` | `String` | Scalar | \\-  | `@unique` |\n| `name` | `String` | Scalar | `?` | \\-  |\n| `role` | `Role` | Scalar (`enum`) | \\-  | `@default(USER)` |\n| `posts` | `Post` | Relation (Prisma-level field) | `[]` | \\-  |\n| `profile` | `Profile` | Relation (Prisma-level field) | `?` | \\-  |\n\n### Scalar fields[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields \"Direct link to Scalar fields\")\n\nThe following example extends the `Comment` and `Tag` models with several scalar types. Some fields include [attributes](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-attributes):\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Comment {  id      Int    @id @default(autoincrement())  title   String  content String}model Tag {  name String @id}\n```\n\nSee [complete list of scalar field types](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) .\n\n### Relation fields[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#relation-fields \"Direct link to Relation fields\")\n\nA relation field's type is another model - for example, a post (`Post`) can have multiple comments (`Comment[]`):\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Post {  id       Int       @id @default(autoincrement())  // Other fields  comments Comment[] // A post can have many comments}model Comment {  id     Int  // Other fields  post   Post? @relation(fields: [postId], references: [id]) // A comment can have one post  postId Int?}\n```\n\nRefer to the [relations documentation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) for more examples and information about relationships between models.\n\n### Native types mapping[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#native-types-mapping \"Direct link to Native types mapping\")\n\nVersion [2.17.0](https://github.com/prisma/prisma/releases/tag/2.17.0) and later support **native database type attributes** (type attributes) that describe the underlying database type:\n\n```\nmodel Post {  id      Int    @id  title   String @db.VarChar(200)  content String}\n```\n\nType attributes are:\n\n*   Specific to the underlying provider - for example, PostgreSQL uses `@db.Boolean` for `Boolean` whereas MySQL uses `@db.TinyInt(1)`\n*   Written in PascalCase (for example, `VarChar` or `Text`)\n*   Prefixed by `@db`, where `db` is the name of the `datasource` block in your schema\n\nFurthermore, during [Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) type attributes are _only_ added to the schema if the underlying native type is **not the default type**. For example, if you are using the PostgreSQL provider, `String` fields where the underlying native type is `text` will not have a type attribute.\n\nSee [complete list of native database type attributes per scalar type and provider](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) .\n\n#### Benefits and workflows[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#benefits-and-workflows \"Direct link to Benefits and workflows\")\n\n*   Control **the exact native type** that [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) creates in the database - for example, a `String` can be `@db.VarChar(200)` or `@db.Char(50)`\n*   See an **enriched schema** when you introspect\n\n### Type modifiers[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers \"Direct link to Type modifiers\")\n\nThe type of a field can be modified by appending either of two modifiers:\n\n*   [`[]`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#-modifier) Make a field a list\n*   [`?`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#-modifier-1) Make a field optional\n\n> **Note**: You **cannot** combine type modifiers - optional lists are not supported.\n\n#### Lists[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#lists \"Direct link to Lists\")\n\nThe following example includes a scalar list and a list of related models:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Post {  id       Int       @id @default(autoincrement())  // Other fields  comments Comment[] // A list of comments  keywords String[] // A scalar list}\n```\n\n> **Note**: Scalar lists are **only** supported if the database connector supports scalar lists, either natively or at a Prisma ORM level.\n\n#### Optional and mandatory fields[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#optional-and-mandatory-fields \"Direct link to Optional and mandatory fields\")\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Comment {  id      Int     @id @default(autoincrement())  title   String  content String?}model Tag {  name String @id}\n```\n\nWhen **not** annotating a field with the `?` type modifier, the field will be _required_ on every record of the model. This has effects on two levels:\n\n*   **Databases**\n    *   **Relational databases**: Required fields are represented via `NOT NULL` constraints in the underlying database.\n    *   **MongoDB**: Required fields are not a concept on a MongoDB database level.\n*   **Prisma Client**: Prisma Client's generated [TypeScript types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-definitions) that represent the models in your application code will also define these fields as required to ensure they always carry values at runtime.\n\n> **Note**: The default value of an optional field is `null`.\n\n### Unsupported types[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#unsupported-types \"Direct link to Unsupported types\")\n\nWhen you introspect a relational database, unsupported data types are added as [`Unsupported`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unsupported) :\n\n```\nlocation    Unsupported(\"POLYGON\")?\n```\n\nThe `Unsupported` type allows you to define fields in the Prisma schema for database types that are not yet supported by Prisma ORM. For example, MySQL's `POLYGON` type is not currently supported by Prisma ORM, but can now be added to the Prisma schema using the `Unsupported(\"POLYGON\")` type.\n\nFields of type `Unsupported` are not available in the generated Prisma Client API, but you can still use Prisma ORM's [raw database access](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries) feature to query these fields.\n\n> **Note**: If a model has **mandatory `Unsupported` fields**, the generated client will not include `create` or `update` methods for that model.\n\n> **Note**: The MongoDB connector does not support nor require the `Unsupported` type because it supports all scalar types.\n\n## Defining attributes[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-attributes \"Direct link to Defining attributes\")\n\nAttributes modify the behavior of fields or model blocks. The following example includes three field attributes ([`@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id) , [`@default`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default) , and [`@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique) ) and one block attribute ([`@@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique-1)):\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        Int     @id @default(autoincrement())  firstName String  lastName  String  email     String  @unique  isAdmin   Boolean @default(false)  @@unique([firstName, lastName])}\n```\n\nSome attributes accept [arguments](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attribute-argument-types) - for example, `@default` accepts `true` or `false`:\n\n```\nisAdmin   Boolean @default(false) // short form of @default(value: false)\n```\n\nSee [complete list of field and block attributes](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attributes)\n\n### Defining an ID field[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-an-id-field \"Direct link to Defining an ID field\")\n\nAn ID uniquely identifies individual records of a model. A model can only have _one_ ID:\n\n*   In **relational databases**, the ID can be a single field or based on multiple fields. If a model does not have an `@id` or an `@@id`, you must define a mandatory `@unique` field or `@@unique` block instead.\n*   In **MongoDB**, an ID must be a single field that defines an `@id` attribute and a `@map(\"_id\")` attribute.\n\n#### Defining IDs in relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-ids-in-relational-databases \"Direct link to Defining IDs in relational databases\")\n\nIn relational databases, an ID can be defined by a single field using the [`@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id) attribute, or multiple fields using the [`@@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1) attribute.\n\n##### Single field IDs[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#single-field-ids \"Direct link to Single field IDs\")\n\nIn the following example, the `User` ID is represented by the `id` integer field:\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  role    Role     @default(USER)  posts   Post[]  profile Profile?}\n```\n\n##### Composite IDs[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#composite-ids \"Direct link to Composite IDs\")\n\nIn the following example, the `User` ID is represented by a combination of the `firstName` and `lastName` fields:\n\n```\nmodel User {  firstName String  lastName  String  email     String  @unique  isAdmin   Boolean @default(false)  @@id([firstName, lastName])}\n```\n\nBy default, the name of this field in Prisma Client queries will be `firstName_lastName`.\n\nYou can also provide your own name for the composite ID using the [`@@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1) attribute's `name` field:\n\n```\nmodel User {  firstName String  lastName  String  email     String  @unique  isAdmin   Boolean @default(false)  @@id(name: \"fullName\", fields: [firstName, lastName])}\n```\n\nThe `firstName_lastName` field will now be named `fullName` instead.\n\n##### `@unique` fields as unique identifiers[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#unique-fields-as-unique-identifiers \"Direct link to unique-fields-as-unique-identifiers\")\n\nIn the following example, users are uniquely identified by a `@unique` field. Because the `email` field functions as a unique identifier for the model (which is required), it must be mandatory:\n\n```\nmodel User {  email   String   @unique  name    String?  role    Role     @default(USER)  posts   Post[]  profile Profile?}\n```\n\n#### Defining IDs in MongoDB[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-ids-in-mongodb \"Direct link to Defining IDs in MongoDB\")\n\nThe MongoDB connector has [specific rules for defining an ID field](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#mongodb) that differs from relational databases. An ID must be defined by a single field using the [`@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id) attribute and must include `@map(\"_id\")`.\n\nIn the following example, the `User` ID is represented by the `id` string field that accepts an auto-generated `ObjectId`:\n\n```\nmodel User {  id      String   @id @default(auto()) @map(\"_id\") @db.ObjectId  email   String   @unique  name    String?  role    Role     @default(USER)  posts   Post[]  profile Profile?}\n```\n\nIn the following example, the `User` ID is represented by the `id` string field that accepts something other than an `ObjectId` - for example, a unique username:\n\n```\nmodel User {  id      String   @id @map(\"_id\")  email   String   @unique  name    String?  role    Role     @default(USER)  posts   Post[]  profile Profile?}\n```\n\nwarning\n\n**MongoDB does not support `@@id`**  \nMongoDB does not support composite IDs, which means you cannot identify a model with a `@@id` block.\n\n### Defining a default value[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-a-default-value \"Direct link to Defining a default value\")\n\nYou can define default values for scalar fields of your models using the [`@default`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default) attribute:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  createdAt  DateTime   @default(now())  title      String  published  Boolean    @default(false)  data       Json       @default(\"{ \\\"hello\\\": \\\"world\\\" }\")  author     User       @relation(fields: [authorId], references: [id])  authorId   Int  categories Category[] @relation(references: [id])}\n```\n\n`@default` attributes either:\n\n*   Represent `DEFAULT` values in the underlying database (relational databases only) _or_\n*   Use a Prisma ORM-level function. For example, `cuid()` and `uuid()` are provided by Prisma Client's [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines) for all connectors.\n\nDefault values can be:\n\n*   Static values that correspond to the field type, such as `5` (`Int`), `Hello` (`String`), or `false` (`Boolean`)\n*   [Lists](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#-modifier) of static values, such as `[5, 6, 8]` (`Int[]`) or `[\"Hello\", \"Goodbye\"]` (`String`\\[\\]). These are available in Prisma ORM versions `4.0.0` and later, when using supported databases (PostgreSQL, CockroachDB and MongoDB)\n*   [Functions](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#using-functions), such as [`now()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#now) or [`uuid()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#uuid)\n*   JSON data. Note that JSON needs to be enclosed with double-quotes inside the `@default` attribute, e.g.: `@default(\"[]\")`. If you want to provide a JSON object, you need to enclose it with double-quotes and then escape any internal double quotes using a backslash, e.g.: `@default(\"{ \\\"hello\\\": \\\"world\\\" }\")`.\n\n### Defining a unique field[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-a-unique-field \"Direct link to Defining a unique field\")\n\nYou can add unique attributes to your models to be able to uniquely identify individual records of that model. Unique attributes can be defined on a single field using [`@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique) attribute, or on multiple fields (also called composite or compound unique constraints) using the [`@@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique-1) attribute.\n\nIn the following example, the value of the `email` field must be unique:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?}\n```\n\nIn the following example, a combination of `authorId` and `title` must be unique:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  createdAt  DateTime   @default(now())  title      String  published  Boolean    @default(false)  author     User       @relation(fields: [authorId], references: [id])  authorId   Int  categories Category[] @relation(references: [id])  @@unique([authorId, title])}\n```\n\nBy default, the name of this field in Prisma Client queries will be `authorId_title`.\n\nYou can also provide your own name for the composite unique constraint using the [`@@unique`](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#constraint-and-index-names) attribute's `name` field:\n\n```\nmodel Post {  id         String     @id @default(auto()) @map(\"_id\") @db.ObjectId  createdAt  DateTime   @default(now())  title      String  published  Boolean    @default(false)  author     User       @relation(fields: [authorId], references: [id])  authorId   String     @db.ObjectId  categories Category[] @relation(references: [id])  @@unique(name: \"authorTitle\", [authorId, title])}\n```\n\nThe `authorId_title` field will now be named `authorTitle` instead.\n\n#### Composite type unique constraints[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#composite-type-unique-constraints \"Direct link to Composite type unique constraints\")\n\nWhen using the MongoDB provider in version `3.12.0` and later, you can define a unique constraint on a field of a [composite type](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types) using the syntax `@@unique([compositeType.field])`. As with other fields, composite type fields can be used as part of a multi-column unique constraint.\n\nThe following example defines a multi-column unique constraint based on the `email` field of the `User` model and the `number` field of the `Address` composite type which is used in `User.address`:\n\nschema.prisma\n\n```\ntype Address {  street String  number Int}model User {  id      Int     @id  email   String  address Address  @@unique([email, address.number])}\n```\n\nThis notation can be chained if there is more than one nested composite type:\n\nschema.prisma\n\n```\ntype City {  name String}type Address {  number Int  city   City}model User {  id      Int       @id  address Address[]  @@unique([address.city.name])}\n```\n\n### Defining an index[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-an-index \"Direct link to Defining an index\")\n\nYou can define indexes on one or multiple fields of your models via the [`@@index`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#index) on a model. The following example defines a multi-column index based on the `title` and `content` field:\n\n```\nmodel Post {  id      Int     @id @default(autoincrement())  title   String  content String?  @@index([title, content])}\n```\n\ninfo\n\n**Index names in relational databases**  \nYou can optionally define a [custom index name](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#constraint-and-index-names) in the underlying database.\n\n#### Defining composite type indexes[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-type-indexes \"Direct link to Defining composite type indexes\")\n\nWhen using the MongoDB provider in version `3.12.0` and later, you can define an index on a field of a [composite type](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types) using the syntax `@@index([compositeType.field])`. As with other fields, composite type fields can be used as part of a multi-column index.\n\nThe following example defines a multi-column index based on the `email` field of the `User` model and the `number` field of the `Address` composite type:\n\nschema.prisma\n\n```\ntype Address {  street String  number Int}model User {  id      Int     @id  email   String  address Address  @@index([email, address.number])}\n```\n\nThis notation can be chained if there is more than one nested composite type:\n\nschema.prisma\n\n```\ntype City {  name String}type Address {  number Int  city   City}model User {  id      Int       @id  address Address[]  @@index([address.city.name])}\n```\n\n## Defining enums[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-enums \"Direct link to Defining enums\")\n\nYou can define enums in your data model [if enums are supported for your database connector](https://www.prisma.io/docs/orm/reference/database-features#misc), either natively or at Prisma ORM level.\n\nEnums are considered [scalar](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) types in the Prisma schema data model. They're therefore [by default](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#return-the-default-selection-set) included as return values in [Prisma Client queries](https://www.prisma.io/docs/orm/prisma-client/queries/crud).\n\nEnums are defined via the [`enum`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#enum) block. For example, a `User` has a `Role`:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  role  Role    @default(USER)}enum Role {  USER  ADMIN}\n```\n\n## Defining composite types[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types \"Direct link to Defining composite types\")\n\ninfo\n\nComposite types were added in version `3.10.0` under the `mongodb` Preview feature flag and are in General Availability since version `3.12.0`.\n\nwarning\n\nComposite types are currently only available on MongoDB.\n\nComposite types (known as [embedded documents](https://docs.mongodb.com/manual/core/data-model-design/#std-label-data-modeling-embedding) in MongoDB) provide support for embedding records inside other records, by allowing you to define new object types. Composite types are structured and typed in a similar way to [models](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-models).\n\nTo define a composite type, use the `type` block. As an example, take the following schema:\n\nschema.prisma\n\n```\nmodel Product {  id     String  @id @default(auto()) @map(\"_id\") @db.ObjectId  name   String  photos Photo[]}type Photo {  height Int  width  Int  url    String}\n```\n\nIn this case, the `Product` model has a list of `Photo` composite types stored in `photos`.\n\n### Considerations when using composite types[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#considerations-when-using-composite-types \"Direct link to Considerations when using composite types\")\n\nComposite types only support a limited set of [attributes](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attributes). The following attributes are supported:\n\n*   `@default`\n*   `@map`\n*   [Native types](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types), such as `@db.ObjectId`\n\nThe following attributes are not supported inside composite types:\n\n*   `@unique`\n*   `@id`\n*   `@relation`\n*   `@ignore`\n*   `@updatedAt`\n\nHowever, unique constraints can still be defined by using the `@@unique` attribute on the level of the model that uses the composite type. For more details, see [Composite type unique constraints](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#composite-type-unique-constraints).\n\nIndexes can be defined by using the `@@index` attribute on the level of the model that uses the composite type. For more details, see [Composite type indexes](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-type-indexes).\n\n## Using functions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#using-functions \"Direct link to Using functions\")\n\nThe Prisma schema supports a number of [functions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attribute-functions) . These can be used to specify [default values](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default) on fields of a model.\n\nFor example, the default value of `createdAt` is [`now()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#now) :\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())}\n```\n\n[`cuid()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cuid) and [`uuid()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#uuid) are implemented by Prisma ORM and therefore are not \"visible\" in the underlying database schema. You can still use them when using [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) by [manually changing your Prisma schema](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) and [generating Prisma Client](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client), in that case the values will be generated by Prisma Client's [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines)\n\nSupport for [`autoincrement()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#autoincrement), [`now()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#now), and [`dbgenerated(...)`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#dbgenerated) differ between databases.\n\n**Relational database connectors** implement `autoincrement()`, `dbgenerated(...)`, and `now()` at database level. The **MongoDB connector** does not support `autoincrement()` or `dbgenerated(...)`, and `now()` is implemented at the Prisma ORM level. The [`auto()`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#auto) function is used to generate an `ObjectId`.\n\n## Relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#relations \"Direct link to Relations\")\n\nRefer to the [relations documentation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) for more examples and information about relationships between models.\n\n## Models in Prisma Client[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#models-in-prisma-client \"Direct link to Models in Prisma Client\")\n\n### Queries (CRUD)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#queries-crud \"Direct link to Queries (CRUD)\")\n\nEvery model in the data model definition will result in a number of CRUD queries in the generated [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client):\n\n*   [`findMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findmany)\n*   [`findFirst()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirst)\n*   [`findFirstOrThrow()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findfirstorthrow)\n*   [`findUnique()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findunique)\n*   [`findUniqueOrThrow()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#finduniqueorthrow)\n*   [`create()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create)\n*   [`update()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update)\n*   [`upsert()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#upsert)\n*   [`delete()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#delete)\n*   [`createMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany)\n*   [`createManyAndReturn()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmanyandreturn)\n*   [`updateMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#updatemany)\n*   [`deleteMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#deletemany)\n\nThe operations are accessible via a generated property on the Prisma Client instance. By default the name of the property is the lowercase form of the model name, e.g. `user` for a `User` model or `post` for a `Post` model.\n\nHere is an example illustrating the use of a `user` property from the Prisma Client API:\n\n```\nconst newUser = await prisma.user.create({  data: {    name: 'Alice',  },})const allUsers = await prisma.user.findMany()\n```\n\n### Type definitions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-definitions \"Direct link to Type definitions\")\n\nPrisma Client also generates **type definitions** that reflect your model structures. These are part of the generated [`@prisma/client`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) node module.\n\nWhen using TypeScript, these type definitions ensure that all your database queries are entirely type safe and validated at compile-time (even partial queries using [`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select) or [`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include) ).\n\nEven when using plain JavaScript, the type definitions are still included in the `@prisma/client` node module, enabling features like [IntelliSense](https://code.visualstudio.com/docs/editor/intellisense)/autocompletion in your editor.\n\n> **Note**: The actual types are stored in the `.prisma/client` folder. `@prisma/client/index.d.ts` exports the contents of this folder.\n\nFor example, the type definition for the `User` model from above would look as follows:\n\n```\nexport type User = {  id: number  email: string  name: string | null  role: string}\n```\n\nNote that the relation fields `posts` and `profile` are not included in the type definition by default. However, if you need variations of the `User` type you can still define them using some of [Prisma Client's generated helper types](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client) (in this case, these helper types would be called `UserGetIncludePayload` and `UserGetSelectPayload`).\n\n## Limitations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#limitations \"Direct link to Limitations\")\n\n### Records must be uniquely identifiable[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#records-must-be-uniquely-identifiable \"Direct link to Records must be uniquely identifiable\")\n\nPrisma ORM currently only supports models that have at least one unique field or combination of fields. In practice, this means that every Prisma model must have either at least one of the following attributes:\n\n*   `@id` or `@@id` for a single- or multi-field primary key constraint (max one per model)\n*   `@unique` or `@@unique` for a single- or multi-field unique constraint",
  "title": "Models | Prisma Documentation",
  "description": "Learn about the concepts for building your data model with Prisma: Models, scalar types, enums, attributes, functions, IDs, default values and more.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions",
  "markdown": "# Referential actions | Prisma Documentation\n\nReferential actions determine what happens to a record when your application deletes or updates a related record.\n\nFrom version 2.26.0, you can define referential actions on the relation fields in your Prisma schema. This allows you to define referential actions like cascading deletes and cascading updates at a Prisma ORM level.\n\ninfo\n\n**Version differences**\n\n*   If you use version 3.0.1 or later, you can use referential actions as described on this page.\n*   If you use a version between 2.26.0 and 3.0.0, you can use referential actions as described on this page, but you must [enable the preview feature flag](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature) `referentialActions`.\n*   If you use version 2.25.0 or earlier, you can configure cascading deletes manually in your database.\n\nIn the following example, adding `onDelete: Cascade` to the `author` field on the `Post` model means that deleting the `User` record will also delete all related `Post` records.\n\nschema.prisma\n\n```\nmodel Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)  authorId Int}model User {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\nIf you do not specify a referential action, Prisma ORM [uses a default](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#referential-action-defaults).\n\ndanger\n\nIf you upgrade from a version earlier than 2.26.0: It is extremely important that you check the [upgrade paths for referential actions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions) section. Prisma ORM's support of referential actions **removes the safety net in Prisma Client that prevents cascading deletes at runtime**. If you use the feature _without upgrading your database_, the [old default action](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions#prisma-orm-2x-default-referential-actions) - `ON DELETE CASCADE` - becomes active. This might result in cascading deletes that you did not expect.\n\n## What are referential actions?[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#what-are-referential-actions \"Direct link to What are referential actions?\")\n\nReferential actions are policies that define how a referenced record is handled by the database when you run an [`update`](https://www.prisma.io/docs/orm/prisma-client/queries/crud#update) or [`delete`](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete) query.\n\nReferential actions on the database level\n\nReferential actions are features of foreign key constraints that exist to preserve referential integrity in your database.\n\nWhen you define relationships between data models in your Prisma schema, you use [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields), **which do not exist on the database**, and [scalar fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields), **which do exist on the database**. These foreign keys connect the models on the database level.\n\nReferential integrity states that these foreign keys must reference an existing primary key value in the related database table. In your Prisma schema, this is generally represented by the `id` field on the related model.\n\nBy default a database will reject any operation that violates the referential integrity, for example, by deleting referenced records.\n\n### How to use referential actions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#how-to-use-referential-actions \"Direct link to How to use referential actions\")\n\nReferential actions are defined in the [`@relation`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relation) attribute and map to the actions on the **foreign key constraint** in the underlying database. If you do not specify a referential action, [Prisma ORM falls back to a default](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#referential-action-defaults).\n\nThe following model defines a one-to-many relation between `User` and `Post` and a many-to-many relation between `Post` and `Tag`, with explicitly defined referential actions:\n\nschema.prisma\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  posts Post[]}model Post {  id     Int          @id @default(autoincrement())  title  String  tags   TagOnPosts[]  User   User?        @relation(fields: [userId], references: [id], onDelete: SetNull, onUpdate: Cascade)  userId Int?}model TagOnPosts {  id     Int   @id @default(autoincrement())  post   Post? @relation(fields: [postId], references: [id], onUpdate: Cascade, onDelete: Cascade)  tag    Tag?  @relation(fields: [tagId], references: [id], onUpdate: Cascade, onDelete: Cascade)  postId Int?  tagId  Int?}model Tag {  id    Int          @id @default(autoincrement())  name  String       @unique  posts TagOnPosts[]}\n```\n\nThis model explicitly defines the following referential actions:\n\n*   If you delete a `Tag`, the corresponding tag assignment is also deleted in `TagOnPosts`, using the `Cascade` referential action\n*   If you delete a `User`, the author is removed from all posts by setting the field value to `Null`, because of the `SetNull` referential action. To allow this, `User` and `userId` must be optional fields in `Post`.\n\nPrisma ORM supports the following referential actions:\n\n*   [`Cascade`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#cascade)\n*   [`Restrict`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#restrict)\n*   [`NoAction`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#noaction)\n*   [`SetNull`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#setnull)\n*   [`SetDefault`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#setdefault)\n\n### Referential action defaults[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#referential-action-defaults \"Direct link to Referential action defaults\")\n\nIf you do not specify a referential action, Prisma ORM uses the following defaults:\n\n| Clause | Optional relations | Mandatory relations |\n| --- | --- | --- |\n| `onDelete` | `SetNull` | `Restrict` |\n| `onUpdate` | `Cascade` | `Cascade` |\n\nFor example, in the following schema all `Post` records must be connected to a `User` via the `author` relation:\n\n```\nmodel Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id])  authorId Int}model User {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\nThe schema does not explicitly define referential actions on the mandatory `author` relation field, which means that the default referential actions of `Restrict` for `onDelete` and `Cascade` for `onUpdate` apply.\n\n## Caveats[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#caveats \"Direct link to Caveats\")\n\nThe following caveats apply:\n\n*   Referential actions are **not** supported on [implicit many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations). To use referential actions, you must define an explicit many-to-many relation and define your referential actions on the [join table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/troubleshooting-relations#how-to-use-a-relation-table-with-a-many-to-many-relationship).\n*   Certain combinations of referential actions and required/optional relations are incompatible. For example, using `SetNull` on a required relation will lead to database errors when deleting referenced records because the non-nullable constraint would be violated. See [this GitHub issue](https://github.com/prisma/prisma/issues/7909) for more information.\n\n## Types of referential actions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#types-of-referential-actions \"Direct link to Types of referential actions\")\n\nThe following table shows which referential action each database supports.\n\n| Database | Cascade | Restrict | NoAction | SetNull | SetDefault |\n| --- | --- | --- | --- | --- | --- |\n| PostgreSQL | ✔️  | ✔️  | ✔️  | ✔️⌘ | ✔️  |\n| MySQL/MariaDB | ✔️  | ✔️  | ✔️  | ✔️  | ❌ (✔️†) |\n| SQLite | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  |\n| SQL Server | ✔️  | ❌‡  | ✔️  | ✔️  | ✔️  |\n| CockroachDB | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  |\n| MongoDB†† | ✔️  | ✔️  | ✔️  | ✔️  | ❌   |\n\n*   † See [special cases for MySQL](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#mysqlmariadb).\n*   ⌘ See [special cases for PostgreSQL](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#postgresql).\n*   ‡ See [special cases for SQL Server](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#sql-server).\n*   †† Referential actions for MongoDB are available in Prisma ORM versions 3.7.0 and later.\n\n### Special cases for referential actions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#special-cases-for-referential-actions \"Direct link to Special cases for referential actions\")\n\nReferential actions are part of the ANSI SQL standard. However, there are special cases where some relational databases diverge from the standard.\n\n#### MySQL/MariaDB[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#mysqlmariadb \"Direct link to MySQL/MariaDB\")\n\nMySQL/MariaDB, and the underlying InnoDB storage engine, does not support `SetDefault`. The exact behavior depends on the database version:\n\n*   In MySQL versions 8 and later, and MariaDB versions 10.5 and later, `SetDefault` effectively acts as an alias for `NoAction`. You can define tables using the `SET DEFAULT` referential action, but a foreign key constraint error is triggered at runtime.\n*   In MySQL versions 5.6 and later, and MariaDB versions before 10.5, attempting to create a table definition with the `SET DEFAULT` referential action fails with a syntax error.\n\nFor this reason, when you set `mysql` as the database provider, Prisma ORM warns users to replace `SetDefault` referential actions in the Prisma schema with another action.\n\n#### PostgreSQL[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#postgresql \"Direct link to PostgreSQL\")\n\nPostgreSQL is the only database supported by Prisma ORM that allows you to define a `SetNull` referential action that refers to a non-nullable field. However, this raises a foreign key constraint error when the action is triggered at runtime.\n\nFor this reason, when you set `postgres` as the database provider in the (default) `foreignKeys` relation mode, Prisma ORM warns users to mark as optional any fields that are included in a `@relation` attribute with a `SetNull` referential action. For all other database providers, Prisma ORM rejects the schema with a validation error.\n\n#### SQL Server[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#sql-server \"Direct link to SQL Server\")\n\n[`Restrict`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#restrict) is not available for SQL Server databases, but you can use [`NoAction`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#noaction) instead.\n\n### `Cascade`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#cascade \"Direct link to cascade\")\n\n*   `onDelete: Cascade` Deleting a referenced record will trigger the deletion of referencing record.\n*   `onUpdate: Cascade` Updates the relation scalar fields if the referenced scalar fields of the dependent record are updated.\n\n#### Example usage[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#example-usage \"Direct link to Example usage\")\n\nschema.prisma\n\n```\nmodel Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)  authorId Int}model User {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\n##### Result of using `Cascade`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#result-of-using-cascade \"Direct link to result-of-using-cascade\")\n\nIf a `User` record is deleted, then their posts are deleted too. If the user's `id` is updated, then the corresponding `authorId` is also updated.\n\n##### How to use cascading deletes[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#how-to-use-cascading-deletes \"Direct link to How to use cascading deletes\")\n\n### `Restrict`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#restrict \"Direct link to restrict\")\n\n*   `onDelete: Restrict` Prevents the deletion if any referencing records exist.\n*   `onUpdate: Restrict` Prevents the identifier of a referenced record from being changed.\n\n#### Example usage[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#example-usage-1 \"Direct link to Example usage\")\n\nschema.prisma\n\n```\nmodel Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id], onDelete: Restrict, onUpdate: Restrict)  authorId Int}model User {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\n##### Result of using `Restrict`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#result-of-using-restrict \"Direct link to result-of-using-restrict\")\n\n`User`s with posts **cannot** be deleted. The `User`'s `id` **cannot** be changed.\n\nwarning\n\nThe `Restrict` action is **not** available on [Microsoft SQL Server](https://www.prisma.io/docs/orm/overview/databases/sql-server) and triggers a schema validation error. Instead, you can use [`NoAction`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#noaction), which produces the same result and is compatible with SQL Server.\n\n### `NoAction`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#noaction \"Direct link to noaction\")\n\nThe `NoAction` action is similar to `Restrict`, the difference between the two is dependent on the database being used:\n\n*   **PostgreSQL**: `NoAction` allows the check (if a referenced row on the table exists) to be deferred until later in the transaction. See [the PostgreSQL docs](https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-FK) for more information.\n*   **MySQL**: `NoAction` behaves exactly the same as `Restrict`. See [the MySQL docs](https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html#foreign-key-referential-actions) for more information.\n*   **SQLite**: When a related primary key is modified or deleted, no action is taken. See [the SQLite docs](https://www.sqlite.org/foreignkeys.html#fk_actions) for more information.\n*   **SQL Server**: When a referenced record is deleted or modified, an error is raised. See [the SQL Server docs](https://docs.microsoft.com/en-us/sql/relational-databases/tables/graph-edge-constraints?view=sql-server-ver15#on-delete-referential-actions-on-edge-constraints) for more information.\n*   **MongoDB** (in preview from version 3.6.0): When a record is modified or deleted, nothing is done to any related records.\n\nwarning\n\nIf you are [managing relations in Prisma Client](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#emulate-relations-in-prisma-orm-with-the-prisma-relation-mode) rather than using foreign keys in the database, you should be aware that currently Prisma ORM only implements the referential actions. Foreign keys also create constraints, which make it impossible to manipulate data in a way that would violate these constraints: instead of executing the query, the database responds with an error. These constraints will not be created if you emulate referential integrity in Prisma Client, so if you set the referential action to `NoAction` there will be no checks to prevent you from breaking the referential integrity.\n\n#### Example usage[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#example-usage-2 \"Direct link to Example usage\")\n\nschema.prisma\n\n```\nmodel Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)  authorId Int}model User {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\n##### Result of using `NoAction`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#result-of-using-noaction \"Direct link to result-of-using-noaction\")\n\n`User`'s with posts **cannot** be deleted. The `User`'s `id` **cannot** be changed.\n\n### `SetNull`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#setnull \"Direct link to setnull\")\n\n*   `onDelete: SetNull` The scalar field of the referencing object will be set to `NULL`.\n    \n*   `onUpdate: SetNull` When updating the identifier of a referenced object, the scalar fields of the referencing objects will be set to `NULL`.\n    \n\n`SetNull` will only work on optional relations. On required relations, a runtime error will be thrown since the scalar fields cannot be null.\n\nschema.prisma\n\n```\nmodel Post {  id       Int    @id @default(autoincrement())  title    String  author   User?  @relation(fields: [authorId], references: [id], onDelete: SetNull, onUpdate: SetNull)  authorId Int?}model User {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\n##### Result of using `SetNull`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#result-of-using-setnull \"Direct link to result-of-using-setnull\")\n\nWhen deleting a `User`, the `authorId` will be set to `NULL` for all its authored posts.\n\nWhen changing a `User`'s `id`, the `authorId` will be set to `NULL` for all its authored posts.\n\n### `SetDefault`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#setdefault \"Direct link to setdefault\")\n\n*   `onDelete: SetDefault` The scalar field of the referencing object will be set to the fields default value.\n    \n*   `onUpdate: SetDefault` The scalar field of the referencing object will be set to the fields default value.\n    \n\nThese require setting a default for the relation scalar field with [`@default`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default). If no defaults are provided for any of the scalar fields, a runtime error will be thrown.\n\nschema.prisma\n\n```\nmodel Post {  id             Int     @id @default(autoincrement())  title          String  authorUsername String? @default(\"anonymous\")  author         User?   @relation(fields: [authorUsername], references: [username], onDelete: SetDefault, onUpdate: SetDefault)}model User {  username String @id  posts    Post[]}\n```\n\n##### Result of using `SetDefault`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#result-of-using-setdefault \"Direct link to result-of-using-setdefault\")\n\nWhen deleting a `User`, its existing posts' `authorUsername` field values will be set to 'anonymous'.\n\nWhen the `username` of a `User` changes, its existing posts' `authorUsername` field values will be set to 'anonymous'.\n\n### Database-specific requirements[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#database-specific-requirements \"Direct link to Database-specific requirements\")\n\nMongoDB and SQL Server have specific requirements for referential actions if you have [self-relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions#self-relation-sql-server-and-mongodb) or [cyclic relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions#cyclic-relation-between-three-tables-sql-server-and-mongodb) in your data model. SQL Server also has specific requirements if you have relations with [multiple cascade paths](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions#multiple-cascade-paths-between-two-models-sql-server-only).\n\n## Upgrade paths from versions 2.25.0 and earlier[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#upgrade-paths-from-versions-2250-and-earlier \"Direct link to Upgrade paths from versions 2.25.0 and earlier\")\n\nThere are a couple of paths you can take when upgrading which will give different results depending on the desired outcome.\n\nIf you currently use the migration workflow, you can run an introspection to check how the defaults are reflected in your schema. You can then manually update your database if you need to.\n\nYou can also decide to skip checking the defaults and run a migration to update your database with the [new default values](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#referential-action-defaults).\n\nThe following assumes you have upgraded to 2.26.0 or newer and enabled the preview feature flag, or upgraded to 3.0.0 or newer:\n\n### Using Introspection[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#using-introspection \"Direct link to Using Introspection\")\n\nIf you [Introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) your database, the referential actions configured at the database level will be reflected in your Prisma Schema. If you have been using Prisma Migrate or `prisma db push` to manage the database schema, these are likely to be the [default values](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#referential-action-defaults) from 2.25.0 and earlier.\n\nWhen you run an Introspection, Prisma ORM compares all the foreign keys in the database with the schema, if the SQL statements `ON DELETE` and `ON UPDATE` do **not** match the default values, they will be explicitly set in the schema file.\n\nAfter introspecting, you can review the non-default clauses in your schema. The most important clause to review is `onDelete`, which defaults to `Cascade` in 2.25.0 and earlier.\n\nwarning\n\nIf you are using either the [`delete()`](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete-a-single-record) or [`deleteMany()`](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete-all-records) methods, **[cascading deletes](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#how-to-use-cascading-deletes) will now be performed** as the `referentialActions` preview feature **removed the safety net in Prisma Client that previously prevented cascading deletes at runtime**. Be sure to check your code and make any adjustments accordingly.\n\nMake sure you are happy with every case of `onDelete: Cascade` in your schema. If not, either:\n\n*   Modify your Prisma schema and `db push` or `dev migrate` to change the database\n\n_or_\n\n*   Manually update the underlying database if you use an introspection-only workflow\n\nThe following example would result in a cascading delete, if the `User` is deleted then all of their `Post`'s will be deleted too.\n\n#### A blog schema example[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#a-blog-schema-example \"Direct link to A blog schema example\")\n\n```\nmodel Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)  authorId Int}model User {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\n### Using Migration[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#using-migration \"Direct link to Using Migration\")\n\nWhen running a [Migration](https://www.prisma.io/docs/orm/prisma-migrate) (or the [`prisma db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) command) the [new defaults](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#referential-action-defaults) will be applied to your database.\n\ninfo\n\nUnlike when you run an Introspect for the first time, the new referential actions clause and property, will **not** automatically be added to your prisma schema by the Prisma VSCode extension. You will have to manually add them if you wish to use anything other than the new defaults.\n\nExplicitly defining referential actions in your Prisma schema is optional. If you do not explicitly define a referential action for a relation, Prisma ORM uses the [new defaults](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#referential-action-defaults).\n\nNote that referential actions can be added on a case by case basis. This means that you can add them to one single relation and leave the rest set to the defaults by not manually specifying anything.\n\n### Checking for errors[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#checking-for-errors \"Direct link to Checking for errors\")\n\n**Before** upgrading to 2.26.0 and enabling the referential actions **preview feature**, Prisma ORM prevented the deletion of records while using `delete()` or `deleteMany()` to preserve referential integrity. A custom runtime error would be thrown by Prisma Client with the error code `P2014`.\n\n**After** upgrading and enabling the referential actions **preview feature**, Prisma ORM no longer performs runtime checks. You can instead specify a custom referential action to preserve the referential integrity between relations.\n\nWhen you use [`NoAction`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#noaction) or [`Restrict`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#restrict) to prevent the deletion of records, the error messages will be different post 2.26.0 compared to pre 2.26.0. This is because they are now triggered by the database and **not** Prisma Client. The new error code that can be expected is `P2003`.\n\nTo make sure you catch these new errors you can adjust your code accordingly.\n\n#### Example of catching errors[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#example-of-catching-errors \"Direct link to Example of catching errors\")\n\nThe following example uses the below blog schema with a one-to-many relationship between `Post` and `User` and sets a [`Restrict`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#restrict) referential actions on the `author` field.\n\nThis means that if a user has a post, that user (and their posts) **cannot** be deleted.\n\nschema.prisma\n\n```\nmodel Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id], onDelete: Restrict)  authorId String}model User {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\nPrior to upgrading and enabling the referential actions **preview feature**, the error code you would receive when trying to delete a user which has posts would be `P2014` and it's message:\n\n> \"The change you are trying to make would violate the required relation '{relation\\_name}' between the {model\\_a\\_name} and {model\\_b\\_name} models.\"\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  try {    await prisma.user.delete({      where: {        id: 'some-long-id',      },    })  } catch (error) {    if (error instanceof Prisma.PrismaClientKnownRequestError) {      if (error.code === 'P2014') {        console.log(error.message)      }    }  }}main()\n```\n\nTo make sure you are checking for the correct errors in your code, modify your check to look for `P2003`, which will deliver the message:\n\n> \"Foreign key constraint failed on the field: {field\\_name}\"\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  try {    await prisma.user.delete({      where: {        id: 'some-long-id'      }    })  } catch (error) {    if (error instanceof Prisma.PrismaClientKnownRequestError) {      if (error.code === 'P2014') {      if (error.code === 'P2003') {        console.log(error.message)      }    }  }}main()\n```",
  "title": "Referential actions | Prisma Documentation",
  "description": "Referential actions let you define the update and delete behavior of related models on the database level",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes",
  "markdown": "# Indexes | Prisma Documentation\n\nPrisma ORM allows configuration of database indexes, unique constraints and primary key constraints. This is in General Availability in versions `4.0.0` and later. You can enable this with the `extendedIndexes` Preview feature in versions `3.5.0` and later.\n\nVersion `3.6.0` also introduces support for introspection and migration of full text indexes in MySQL and MongoDB through a new `@@fulltext` attribute, available through the `fullTextIndex` Preview feature.\n\nwarning\n\nIf you are upgrading from a version earlier than 4.0.0, these changes to index configuration and full text indexes might be **breaking changes** if you have a database that already uses these features. See [Upgrading from previous versions](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#upgrading-from-previous-versions) for more information on how to upgrade.\n\n## Index configuration[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#index-configuration \"Direct link to Index configuration\")\n\nYou can configure indexes, unique constraints, and primary key constraints with the following attribute arguments:\n\n*   The [`length` argument](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#configuring-the-length-of-indexes-with-length-mysql) allows you to specify a maximum length for the subpart of the value to be indexed on `String` and `Bytes` types\n    \n    *   Available on the `@id`, `@@id`, `@unique`, `@@unique` and `@@index` attributes\n    *   MySQL only\n*   The [`sort` argument](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#configuring-the-index-sort-order-with-sort) allows you to specify the order that the entries of the constraint or index are stored in the database\n    \n    *   Available on the `@unique`, `@@unique` and `@@index` attributes in all databases, and on the `@id` and `@@id` attributes in SQL Server\n*   The [`type` argument](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#configuring-the-access-type-of-indexes-with-type-postgresql) allows you to support index access methods other than PostgreSQL's default `BTree` access method\n    \n    *   Available on the `@@index` attribute\n    *   PostgreSQL only\n    *   Supported index access methods: `Hash`, `Gist`, `Gin`, `SpGist` and `Brin`\n*   The [`clustered` argument](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#configuring-if-indexes-are-clustered-or-non-clustered-with-clustered-sql-server) allows you to configure whether a constraint or index is clustered or non-clustered\n    \n    *   Available on the `@id`, `@@id`, `@unique`, `@@unique` and `@@index` attributes\n    *   SQL Server only\n\nSee the linked sections for details of which version each feature was first introduced in.\n\n### Configuring the length of indexes with `length` (MySQL)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#configuring-the-length-of-indexes-with-length-mysql \"Direct link to configuring-the-length-of-indexes-with-length-mysql\")\n\nThe `length` argument is specific to MySQL and allows you to define indexes and constraints on columns of `String` and `Byte` types. For these types, MySQL requires you to specify a maximum length for the subpart of the value to be indexed in cases where the full value would exceed MySQL's limits for index sizes. See [the MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/innodb-limits.html) for more details.\n\nThe `length` argument is available on the `@id`, `@@id`, `@unique`, `@@unique` and `@@index` attributes. It is generally available in versions 4.0.0 and later, and available as part of the `extendedIndexes` preview feature in versions 3.5.0 and later.\n\nAs an example, the following data model declares an `id` field with a maximum length of 3000 characters:\n\nschema.prisma\n\n```\nmodel Id {  id String @id @db.VarChar(3000)}\n```\n\nThis is not valid in MySQL because it exceeds MySQL's index storage limit and therefore Prisma ORM rejects the data model. The generated SQL would be rejected by the database.\n\n```\nCREATE TABLE `Id` (  `id` VARCHAR(3000) PRIMARY KEY)\n```\n\nThe `length` argument allows you to specify that only a subpart of the `id` value represents the primary key. In the example below, the first 100 characters are used:\n\nschema.prisma\n\n```\nmodel Id {  id String @id(length: 100) @db.VarChar(3000)}\n```\n\nPrisma Migrate is able to create constraints and indexes with the `length` argument if specified in your data model. This means that you can create indexes and constraints on values of Prisma schema type `Byte` and `String`. If you don't specify the argument the index is treated as covering the full value as before.\n\nIntrospection will fetch these limits where they are present in your existing database. This allows Prisma ORM to support indexes and constraints that were previously suppressed and results in better support of MySQL databases utilizing this feature.\n\nThe `length` argument can also be used on compound primary keys, using the `@@id` attribute, as in the example below:\n\nschema.prisma\n\n```\nmodel CompoundId {  id_1 String @db.VarChar(3000)  id_2 String @db.VarChar(3000)  @@id([id_1(length: 100), id_2(length: 10)])}\n```\n\nA similar syntax can be used for the `@@unique` and `@@index` attributes.\n\n### Configuring the index sort order with `sort`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#configuring-the-index-sort-order-with-sort \"Direct link to configuring-the-index-sort-order-with-sort\")\n\nThe `sort` argument is available for all databases supported by Prisma ORM. It allows you to specify the order that the entries of the index or constraint are stored in the database. This can have an effect on whether the database is able to use an index for specific queries.\n\nThe `sort` argument is available for all databases on `@unique`, `@@unique` and `@@index`. Additionally, SQL Server also allows it on `@id` and `@@id`. It is generally available in versions 4.0.0 and later, and available as part of the `extendedIndexes` preview feature in versions 3.5.0 and later.\n\nAs an example, the following table\n\n```\nCREATE TABLE `Unique` (  `unique` INT,  CONSTRAINT `Unique_unique_key` UNIQUE (`unique` DESC))\n```\n\nis now introspected as\n\nschema.prisma\n\n```\nmodel Unique {  unique Int @unique(sort: Desc)}\n```\n\nThe `sort` argument can also be used on compound indexes:\n\nschema.prisma\n\n```\nmodel CompoundUnique {  unique_1 Int  unique_2 Int  @@unique([unique_1(sort: Desc), unique_2])}\n```\n\n### Example: using `sort` and `length` together[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#example-using-sort-and-length-together \"Direct link to example-using-sort-and-length-together\")\n\nThe following example demonstrates the use of the `sort` and `length` arguments to configure indexes and constraints for a `Post` model:\n\nschema.prisma\n\n```\nmodel Post {  title      String   @db.VarChar(300)  abstract   String   @db.VarChar(3000)  slug       String   @unique(sort: Desc, length: 42) @db.VarChar(3000)  author     String  created_at DateTime  @@id([title(length: 100, sort: Desc), abstract(length: 10)])  @@index([author, created_at(sort: Desc)])}\n```\n\n### Configuring the access type of indexes with `type` (PostgreSQL)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#configuring-the-access-type-of-indexes-with-type-postgresql \"Direct link to configuring-the-access-type-of-indexes-with-type-postgresql\")\n\nThe `type` argument is available for configuring the index type in PostgreSQL with the `@@index` attribute. The index access methods available are `Hash`, `Gist`, `Gin`, `SpGist` and `Brin`, as well as the default `BTree` index access method. The `type` argument is generally available in versions 4.0.0 and later. The `Hash` index access method is available as part of the `extendedIndexes` preview feature in versions 3.6.0 and later, and the `Gist`, `Gin`, `SpGist` and `Brin` index access methods are available in preview in versions 3.14.0 and later.\n\n#### Hash[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#hash \"Direct link to Hash\")\n\nThe `Hash` type will store the index data in a format that is much faster to search and insert, and that will use less disk space. However, only the `=` and `<>` comparisons can use the index, so other comparison operators such as `<` and `>` will be much slower with `Hash` than when using the default `BTree` type.\n\nAs an example, the following model adds an index with a `type` of `Hash` to the `value` field:\n\nschema.prisma\n\n```\nmodel Example {  id    Int @id  value Int  @@index([value], type: Hash)}\n```\n\nThis translates to the following SQL commands:\n\n```\nCREATE TABLE \"Example\" (  id INT PRIMARY KEY,  value INT NOT NULL);CREATE INDEX \"Example_value_idx\" ON \"Example\" USING HASH (value);\n```\n\n#### Generalized Inverted Index (GIN)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#generalized-inverted-index-gin \"Direct link to Generalized Inverted Index (GIN)\")\n\nThe GIN index stores composite values, such as arrays or `JsonB` data. This is useful for speeding up querying whether one object is part of another object. It is commonly used for full-text searches.\n\nAn indexed field can define the operator class, which defines the operators handled by the index.\n\nwarning\n\nIndexes using a function (such as `to_tsvector`) to determine the indexed value are not yet supported by Prisma ORM. Indexes defined in this way will not be visible with `prisma db pull`.\n\nAs an example, the following model adds a `Gin` index to the `value` field, with `JsonbPathOps` as the class of operators allowed to use the index:\n\nschema.prisma\n\n```\nmodel Example {  id    Int  @id  value Json  //    ^ field type matching the operator class  //                  ^ operator class      ^ index type  @@index([value(ops: JsonbPathOps)], type: Gin)}\n```\n\nThis translates to the following SQL commands:\n\n```\nCREATE TABLE \"Example\" (  id INT PRIMARY KEY,  value JSONB NOT NULL);CREATE INDEX \"Example_value_idx\" ON \"Example\" USING GIN (value jsonb_path_ops);\n```\n\nAs part of the `JsonbPathOps` the `@>` operator is handled by the index, speeding up queries such as `value @> '{\"foo\": 2}'`.\n\n##### Supported Operator Classes for GIN[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#supported-operator-classes-for-gin \"Direct link to Supported Operator Classes for GIN\")\n\nPrisma ORM generally supports operator classes provided by PostgreSQL in versions 10 and later. If the operator class requires the field type to be of a type Prisma ORM does not yet support, using the `raw` function with a string input allows you to use these operator classes without validation.\n\nThe default operator class (marked with ✅) can be omitted from the index definition.\n\n| Operator class | Allowed field type (native types) | Default | Other |\n| --- | --- | --- | --- |\n| `ArrayOps` | Any array | ✅   | Also available in CockroachDB |\n| `JsonbOps` | `Json` (`@db.JsonB`) | ✅   | Also available in CockroachDB |\n| `JsonbPathOps` | `Json` (`@db.JsonB`) |     |     |\n| `raw(\"other\")` |     |     |     |\n\nRead more about built-in operator classes in the [official PostgreSQL documentation](https://www.postgresql.org/docs/14/gin-builtin-opclasses.html).\n\n##### CockroachDB[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#cockroachdb \"Direct link to CockroachDB\")\n\nGIN and BTree are the only index types supported by CockroachDB. The operator classes marked to work with CockroachDB are the only ones allowed on that database and supported by Prisma ORM. The operator class cannot be defined in the Prisma Schema Language: the `ops` argument is not necessary or allowed on CockroachDB.\n\n#### Generalized Search Tree (GiST)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#generalized-search-tree-gist \"Direct link to Generalized Search Tree (GiST)\")\n\nThe GiST index type is used for implementing indexing schemes for user-defined types. By default there are not many direct uses for GiST indexes, but for example the B-Tree index type is built using a GiST index.\n\nAs an example, the following model adds a `Gist` index to the `value` field with `InetOps` as the operators that will be using the index:\n\nschema.prisma\n\n```\nmodel Example {  id    Int    @id  value String @db.Inet  //           ^ native type matching the operator class  //                                   ^ index type  //                  ^ operator class  @@index([value(ops: InetOps)], type: Gist)}\n```\n\nThis translates to the following SQL commands:\n\n```\nCREATE TABLE \"Example\" (  id INT PRIMARY KEY,  value INET NOT NULL);CREATE INDEX \"Example_value_idx\" ON \"Example\" USING GIST (value inet_ops);\n```\n\nQueries comparing IP addresses, such as `value > '10.0.0.2'`, will use the index.\n\n##### Supported Operator Classes for GiST[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#supported-operator-classes-for-gist \"Direct link to Supported Operator Classes for GiST\")\n\nPrisma ORM generally supports operator classes provided by PostgreSQL in versions 10 and later. If the operator class requires the field type to be of a type Prisma ORM does not yet support, using the `raw` function with a string input allows you to use these operator classes without validation.\n\n| Operator class | Allowed field type (allowed native types) |\n| --- | --- |\n| `InetOps` | `String` (`@db.Inet`) |\n| `raw(\"other\")` |     |\n\nRead more about built-in operator classes in the [official PostgreSQL documentation](https://www.postgresql.org/docs/14/gist-builtin-opclasses.html).\n\n#### Space-Partitioned GiST (SP-GiST)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#space-partitioned-gist-sp-gist \"Direct link to Space-Partitioned GiST (SP-GiST)\")\n\nThe SP-GiST index is a good choice for many different non-balanced data structures. If the query matches the partitioning rule, it can be very fast.\n\nAs with GiST, SP-GiST is important as a building block for user-defined types, allowing implementation of custom search operators directly with the database.\n\nAs an example, the following model adds a `SpGist` index to the `value` field with `TextOps` as the operators using the index:\n\nschema.prisma\n\n```\nmodel Example {  id    Int    @id  value String  //    ^ field type matching the operator class  @@index([value], type: SpGist)  //                     ^ index type  //       ^ using the default ops: TextOps}\n```\n\nThis translates to the following SQL commands:\n\n```\nCREATE TABLE \"Example\" (  id INT PRIMARY KEY,  value TEXT NOT NULL);CREATE INDEX \"Example_value_idx\" ON \"Example\" USING SPGIST (value);\n```\n\nQueries such as `value LIKE 'something%'` will be sped up by the index.\n\n##### Supported Operator Classes for SP-GiST[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#supported-operator-classes-for-sp-gist \"Direct link to Supported Operator Classes for SP-GiST\")\n\nPrisma ORM generally supports operator classes provided by PostgreSQL in versions 10 and later. If the operator class requires the field type to be of a type Prisma ORM does not yet support, using the `raw` function with a string input allows you to use these operator classes without validation.\n\nThe default operator class (marked with ✅) can be omitted from the index definition.\n\n| Operator class | Allowed field type (native types) | Default | Supported PostgreSQL versions |\n| --- | --- | --- | --- |\n| `InetOps` | `String` (`@db.Inet`) | ✅   | 10+ |\n| `TextOps` | `String` (`@db.Text`, `@db.VarChar`) | ✅   |     |\n| `raw(\"other\")` |     |     |     |\n\nRead more about built-in operator classes from [official PostgreSQL documentation](https://www.postgresql.org/docs/14/spgist-builtin-opclasses.html).\n\n#### Block Range Index (BRIN)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#block-range-index-brin \"Direct link to Block Range Index (BRIN)\")\n\nThe BRIN index type is useful if you have lots of data that does not change after it is inserted, such as date and time values. If your data is a good fit for the index, it can store large datasets in a minimal space.\n\nAs an example, the following model adds a `Brin` index to the `value` field with `Int4BloomOps` as the operators that will be using the index:\n\nschema.prisma\n\n```\nmodel Example {  id    Int @id  value Int  //    ^ field type matching the operator class  //                  ^ operator class      ^ index type  @@index([value(ops: Int4BloomOps)], type: Brin)}\n```\n\nThis translates to the following SQL commands:\n\n```\nCREATE TABLE \"Example\" (  id INT PRIMARY KEY,  value INT4 NOT NULL);CREATE INDEX \"Example_value_idx\" ON \"Example\" USING BRIN (value int4_bloom_ops);\n```\n\nQueries like `value = 2` will now use the index, which uses a fraction of the space used by the `BTree` or `Hash` indexes.\n\n##### Supported Operator Classes for BRIN[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#supported-operator-classes-for-brin \"Direct link to Supported Operator Classes for BRIN\")\n\nPrisma ORM generally supports operator classes provided by PostgreSQL in versions 10 and later, and some supported operators are only available from PostgreSQL versions 14 and later. If the operator class requires the field type to be of a type Prisma ORM does not yet support, using the `raw` function with a string input allows you to use these operator classes without validation.\n\nThe default operator class (marked with ✅) can be omitted from the index definition.\n\n| Operator class | Allowed field type (native types) | Default | Supported PostgreSQL versions |\n| --- | --- | --- | --- |\n| `BitMinMaxOps` | `String` (`@db.Bit`) | ✅   |     |\n| `VarBitMinMaxOps` | `String` (`@db.VarBit`) | ✅   |     |\n| `BpcharBloomOps` | `String` (`@db.Char`) |     | 14+ |\n| `BpcharMinMaxOps` | `String` (`@db.Char`) | ✅   |     |\n| `ByteaBloomOps` | `Bytes` (`@db.Bytea`) |     | 14+ |\n| `ByteaMinMaxOps` | `Bytes` (`@db.Bytea`) | ✅   |     |\n| `DateBloomOps` | `DateTime` (`@db.Date`) |     | 14+ |\n| `DateMinMaxOps` | `DateTime` (`@db.Date`) | ✅   |     |\n| `DateMinMaxMultiOps` | `DateTime` (`@db.Date`) |     | 14+ |\n| `Float4BloomOps` | `Float` (`@db.Real`) |     | 14+ |\n| `Float4MinMaxOps` | `Float` (`@db.Real`) | ✅   |     |\n| `Float4MinMaxMultiOps` | `Float` (`@db.Real`) |     | 14+ |\n| `Float8BloomOps` | `Float` (`@db.DoublePrecision`) |     | 14+ |\n| `Float8MinMaxOps` | `Float` (`@db.DoublePrecision`) | ✅   |     |\n| `Float8MinMaxMultiOps` | `Float` (`@db.DoublePrecision`) |     | 14+ |\n| `InetInclusionOps` | `String` (`@db.Inet`) | ✅   | 14+ |\n| `InetBloomOps` | `String` (`@db.Inet`) |     | 14+ |\n| `InetMinMaxOps` | `String` (`@db.Inet`) |     |     |\n| `InetMinMaxMultiOps` | `String` (`@db.Inet`) |     | 14+ |\n| `Int2BloomOps` | `Int` (`@db.SmallInt`) |     | 14+ |\n| `Int2MinMaxOps` | `Int` (`@db.SmallInt`) | ✅   |     |\n| `Int2MinMaxMultiOps` | `Int` (`@db.SmallInt`) |     | 14+ |\n| `Int4BloomOps` | `Int` (`@db.Integer`) |     | 14+ |\n| `Int4MinMaxOps` | `Int` (`@db.Integer`) | ✅   |     |\n| `Int4MinMaxMultiOps` | `Int` (`@db.Integer`) |     | 14+ |\n| `Int8BloomOps` | `BigInt` (`@db.BigInt`) |     | 14+ |\n| `Int8MinMaxOps` | `BigInt` (`@db.BigInt`) | ✅   |     |\n| `Int8MinMaxMultiOps` | `BigInt` (`@db.BigInt`) |     | 14+ |\n| `NumericBloomOps` | `Decimal` (`@db.Decimal`) |     | 14+ |\n| `NumericMinMaxOps` | `Decimal` (`@db.Decimal`) | ✅   |     |\n| `NumericMinMaxMultiOps` | `Decimal` (`@db.Decimal`) |     | 14+ |\n| `OidBloomOps` | `Int` (`@db.Oid`) |     | 14+ |\n| `OidMinMaxOps` | `Int` (`@db.Oid`) | ✅   |     |\n| `OidMinMaxMultiOps` | `Int` (`@db.Oid`) |     | 14+ |\n| `TextBloomOps` | `String` (`@db.Text`, `@db.VarChar`) |     | 14+ |\n| `TextMinMaxOps` | `String` (`@db.Text`, `@db.VarChar`) | ✅   |     |\n| `TextMinMaxMultiOps` | `String` (`@db.Text`, `@db.VarChar`) |     | 14+ |\n| `TimestampBloomOps` | `DateTime` (`@db.Timestamp`) |     | 14+ |\n| `TimestampMinMaxOps` | `DateTime` (`@db.Timestamp`) | ✅   |     |\n| `TimestampMinMaxMultiOps` | `DateTime` (`@db.Timestamp`) |     | 14+ |\n| `TimestampTzBloomOps` | `DateTime` (`@db.Timestamptz`) |     | 14+ |\n| `TimestampTzMinMaxOps` | `DateTime` (`@db.Timestamptz`) | ✅   |     |\n| `TimestampTzMinMaxMultiOps` | `DateTime` (`@db.Timestamptz`) |     | 14+ |\n| `TimeBloomOps` | `DateTime` (`@db.Time`) |     | 14+ |\n| `TimeMinMaxOps` | `DateTime` (`@db.Time`) | ✅   |     |\n| `TimeMinMaxMultiOps` | `DateTime` (`@db.Time`) |     | 14+ |\n| `TimeTzBloomOps` | `DateTime` (`@db.Timetz`) |     | 14+ |\n| `TimeTzMinMaxOps` | `DateTime` (`@db.Timetz`) | ✅   |     |\n| `TimeTzMinMaxMultiOps` | `DateTime` (`@db.Timetz`) |     | 14+ |\n| `UuidBloomOps` | `String` (`@db.Uuid`) |     | 14+ |\n| `UuidMinMaxOps` | `String` (`@db.Uuid`) | ✅   |     |\n| `UuidMinMaxMultiOps` | `String` (`@db.Uuid`) |     | 14+ |\n| `raw(\"other\")` |     |     |     |\n\nRead more about built-in operator classes in the [official PostgreSQL documentation](https://www.postgresql.org/docs/14/brin-builtin-opclasses.html).\n\n### Configuring if indexes are clustered or non-clustered with `clustered` (SQL Server)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#configuring-if-indexes-are-clustered-or-non-clustered-with-clustered-sql-server \"Direct link to configuring-if-indexes-are-clustered-or-non-clustered-with-clustered-sql-server\")\n\nThe `clustered` argument is available to configure (non)clustered indexes in SQL Server. It can be used on the `@id`, `@@id`, `@unique`, `@@unique` and `@@index` attributes. It is generally available in versions 4.0.0 and later, and available as part of the `extendedIndexes` preview feature in versions 3.13.0 and later.\n\nAs an example, the following model configures the `@id` to be non-clustered (instead of the clustered default):\n\nschema.prisma\n\n```\nmodel Example {  id    Int @id(clustered: false)  value Int}\n```\n\nThis translates to the following SQL commands:\n\n```\nCREATE TABLE [Example] (  id INT NOT NULL,  value INT,  CONSTRAINT [Example_pkey] PRIMARY KEY NONCLUSTERED (id))\n```\n\nThe default value of `clustered` for each attribute is as follows:\n\n| Attribute | Value |\n| --- | --- |\n| `@id` | `true` |\n| `@@id` | `true` |\n| `@unique` | `false` |\n| `@@unique` | `false` |\n| `@@index` | `false` |\n\nA table can have at most one clustered index.\n\n### Upgrading from previous versions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#upgrading-from-previous-versions \"Direct link to Upgrading from previous versions\")\n\nwarning\n\nThese index configuration changes can be **breaking changes** when activating the functionality for certain, existing Prisma schemas for existing databases. After enabling the preview features required to use them, run `prisma db pull` to introspect the existing database to update your Prisma schema before using Prisma Migrate again.\n\nA breaking change can occur in the following situations:\n\n*   **Existing sort constraints and indexes:** earlier versions of Prisma ORM will assume that the desired sort order is _ascending_ if no order is specified explicitly. This means that this is a breaking change if you have existing constraints or indexes that are using descending sort order and migrate your database without first specifying this in your data model.\n*   **Existing length constraints and indexes:** in earlier versions of Prisma ORM, indexes and constraints that were length constrained in MySQL could not be represented in the Prisma schema. Therefore `prisma db pull` was not fetching these and you could not manually specify them. When you ran `prisma db push` or `prisma migrate dev` they were ignored if already present in your database. Since you are now able to specify these, migrate commands will now drop them if they are missing from your data model but present in the database.\n*   **Existing indexes other than `BTree` (PostgreSQL):** earlier versions of Prisma ORM only supported the default `BTree` index type. Other supported indexes (`Hash`, `Gist`, `Gin`, `SpGist` and `Brin`) need to be added before migrating your database.\n*   **Existing (non-)clustered indexes (SQL Server):** earlier versions of Prisma ORM did not support configuring an index as clustered or non-clustered. For indexes that do not use the default, these need to be added before migrating your database.\n\nIn each of the cases above unwanted changes to your database can be prevented by properly specifying these properties in your data model where necessary. **The easiest way to do this is to use `prisma db pull` to retrieve any existing constraints or configuration.** Alternatively, you could also add these arguments manually. This should be done before using `prisma db push` or `prisma migrate dev` the first time after the upgrade.\n\n## Full text indexes (MySQL and MongoDB)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#full-text-indexes-mysql-and-mongodb \"Direct link to Full text indexes (MySQL and MongoDB)\")\n\nThe `fullTextIndex` preview feature provides support for introspection and migration of full text indexes in MySQL and MongoDB in version 3.6.0 and later. This can be configured using the `@@fulltext` attribute. Existing full text indexes in the database are added to your Prisma schema after introspecting with `db pull`, and new full text indexes added in the Prisma schema are created in the database when using Prisma Migrate. This also prevents validation errors in some database schemas that were not working before.\n\nwarning\n\nFor now we do not enable the full text search commands in Prisma Client for MongoDB; the progress can be followed in the [MongoDB](https://github.com/prisma/prisma/issues/9413) issue.\n\n### Enabling the `fullTextIndex` preview feature[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#enabling-the-fulltextindex-preview-feature \"Direct link to enabling-the-fulltextindex-preview-feature\")\n\nTo enable the `fullTextIndex` preview feature, add the `fullTextIndex` feature flag to the `generator` block of the `schema.prisma` file:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextIndex\"]}\n```\n\n### Examples[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#examples \"Direct link to Examples\")\n\nThe following example demonstrates adding a `@@fulltext` index to the `title` and `content` fields of a `Post` model:\n\nschema.prisma\n\n```\nmodel Post {  id      Int    @id  title   String @db.VarChar(255)  content String @db.Text  @@fulltext([title, content])}\n```\n\nOn MongoDB, you can use the `@@fulltext` index attribute (via the `fullTextIndex` preview feature) with the `sort` argument to add fields to your full-text index in ascending or descending order. The following example adds a `@@fulltext` index to the `title` and `content` fields of the `Post` model, and sorts the `title` field in descending order:\n\nschema.prisma\n\n```\ngenerator js {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextIndex\"]}datasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}model Post {  id      String @id @map(\"_id\") @db.ObjectId  title   String  content String  @@fulltext([title(sort: Desc), content])}\n```\n\n### Upgrading from previous versions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#upgrading-from-previous-versions-1 \"Direct link to Upgrading from previous versions\")\n\nwarning\n\nThis can be a **breaking change** when activating the functionality for certain, existing Prisma schemas for existing databases. After enabling the preview features required to use them, run `prisma db pull` to introspect the existing database to update your Prisma schema before using Prisma Migrate again.\n\nEarlier versions of Prisma ORM converted full text indexes using the `@@index` attribute rather than the `@@fulltext` attribute. After enabling the `fullTextIndex` preview feature, run `prisma db pull` to convert these indexes to `@@fulltext` before migrating again with Prisma Migrate. If you do not do this, the existing indexes will be dropped instead and normal indexes will be created in their place.",
  "title": "Indexes | Prisma Documentation",
  "description": "How to configure index functionality and add full text indexes",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview",
  "markdown": "# Overview | Prisma Documentation\n\n## In this section[​](https://www.prisma.io/docs/orm/overview#in-this-section \"Direct link to In this section\")\n\n[\n\n## Introduction\n\n](https://www.prisma.io/docs/orm/overview/introduction)\n\n[\n\n## Prisma ORM in your stack\n\n](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack)\n\n[\n\n## Databases\n\n](https://www.prisma.io/docs/orm/overview/databases)",
  "title": "Overview | Prisma Documentation",
  "description": "Overview",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases",
  "markdown": "# Databases | Prisma Documentation\n\nLearn about the different databases Prisma ORM supports.\n\n## In this section[​](https://www.prisma.io/docs/orm/overview/databases#in-this-section \"Direct link to In this section\")\n\n[\n\n## Database drivers\n\n](https://www.prisma.io/docs/orm/overview/databases/database-drivers)\n\n[\n\n## PostgreSQL\n\n](https://www.prisma.io/docs/orm/overview/databases/postgresql)\n\n[\n\n## MySQL/MariaDB\n\n](https://www.prisma.io/docs/orm/overview/databases/mysql)\n\n[\n\n## SQLite\n\n](https://www.prisma.io/docs/orm/overview/databases/sqlite)\n\n[\n\n## MongoDB\n\n](https://www.prisma.io/docs/orm/overview/databases/mongodb)\n\n[\n\n## Microsoft SQL Server\n\n](https://www.prisma.io/docs/orm/overview/databases/sql-server)\n\n[\n\n## CockroachDB\n\n](https://www.prisma.io/docs/orm/overview/databases/cockroachdb)\n\n[\n\n## PlanetScale\n\n](https://www.prisma.io/docs/orm/overview/databases/planetscale)\n\n[\n\n## Supabase\n\n](https://www.prisma.io/docs/orm/overview/databases/supabase)\n\n[\n\n## Neon\n\n](https://www.prisma.io/docs/orm/overview/databases/neon)\n\n[\n\n## Turso\n\n](https://www.prisma.io/docs/orm/overview/databases/turso)\n\n[\n\n## Cloudflare D1\n\n](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1)",
  "title": "Databases | Prisma Documentation",
  "description": "Databases",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/introduction",
  "markdown": "# Introduction (Overview) | Prisma Documentation\n\nThis page gives a high-level overview of what Prisma ORM is and how it works.\n\nIf you want to get started with a _practical introduction_ and learn about the Prisma Client API, head over to the [**Getting Started**](https://www.prisma.io/docs/getting-started) documentation.\n\nTo learn more about the _motivation_ for Prisma ORM, check out the [**Why Prisma ORM?**](https://www.prisma.io/docs/orm/overview/introduction/why-prisma) page.\n\n## In this section[​](https://www.prisma.io/docs/orm/overview/introduction#in-this-section \"Direct link to In this section\")\n\n[\n\n## What is Prisma ORM?\n\n](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma)\n\n[\n\n## Why Prisma ORM?\n\n](https://www.prisma.io/docs/orm/overview/introduction/why-prisma)\n\n[\n\n## Should you use Prisma ORM?\n\n](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma)\n\n[\n\n## Data modeling\n\n](https://www.prisma.io/docs/orm/overview/introduction/data-modeling)",
  "title": "Introduction (Overview) | Prisma Documentation",
  "description": "This section gives a high-level overview of what Prisma is and how it works. It's a great starting point for Prisma newcomers!",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/overview",
  "markdown": "# Prisma Schema Overview | Prisma Documentation\n\nThe Prisma Schema (or _schema_ for short) is the main method of configuration for your Prisma ORM setup. It consists of the following parts:\n\n*   [**Data sources**](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources): Specify the details of the data sources Prisma ORM should connect to (e.g. a PostgreSQL database)\n*   [**Generators**](https://www.prisma.io/docs/orm/prisma-schema/overview/generators): Specifies what clients should be generated based on the data model (e.g. Prisma Client)\n*   [**Data model definition**](https://www.prisma.io/docs/orm/prisma-schema/data-model): Specifies your application [models](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-models) (the shape of the data per data source) and their [relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations)\n\nIt is typically a single file called `schema.prisma` (or multiple files with `.prisma` file extension) that is stored in a defined but customizable [location](https://www.prisma.io/docs/orm/prisma-schema/overview/location).\n\nSee the [Prisma schema API reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference) for detailed information about each section of the schema.\n\nWhenever a `prisma` command is invoked, the CLI typically reads some information from the schema, e.g.:\n\n*   `prisma generate`: Reads _all_ above mentioned information from the Prisma schema to generate the correct data source client code (e.g. Prisma Client).\n*   `prisma migrate dev`: Reads the data sources and data model definition to create a new migration.\n\nYou can also [use environment variables](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) inside the schema to provide configuration options when a CLI command is invoked.\n\n## Example[​](https://www.prisma.io/docs/orm/prisma-schema/overview#example \"Direct link to Example\")\n\nThe following is an example of a Prisma Schema that specifies:\n\n*   A data source (PostgreSQL or MongoDB)\n*   A generator (Prisma Client)\n*   A data model definition with two models (with one relation) and one `enum`\n*   Several [native data type attributes](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#native-types-mapping) (`@db.VarChar(255)`, `@db.ObjectId`)\n\n*   Relational databases\n*   MongoDB\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model User {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  email     String   @unique  name      String?  role      Role     @default(USER)  posts     Post[]}model Post {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  published Boolean  @default(false)  title     String   @db.VarChar(255)  author    User?    @relation(fields: [authorId], references: [id])  authorId  Int?}enum Role {  USER  ADMIN}\n```\n\n## Syntax[​](https://www.prisma.io/docs/orm/prisma-schema/overview#syntax \"Direct link to Syntax\")\n\nPrisma Schema files are written in Prisma Schema Language (PSL). See the [data sources](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources), [generators](https://www.prisma.io/docs/orm/prisma-schema/overview/generators), [data model definition](https://www.prisma.io/docs/orm/prisma-schema/data-model) and of course [Prisma Schema API reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference) pages for details and examples.\n\n### VS Code[​](https://www.prisma.io/docs/orm/prisma-schema/overview#vs-code \"Direct link to VS Code\")\n\nSyntax highlighting for PSL is available via a [VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) (which also lets you auto-format the contents of your Prisma schema and indicates syntax errors with red squiggly lines). Learn more about [setting up Prisma ORM in your editor](https://www.prisma.io/docs/orm/more/development-environment/editor-setup).\n\n### GitHub[​](https://www.prisma.io/docs/orm/prisma-schema/overview#github \"Direct link to GitHub\")\n\nPSL code snippets on GitHub can be rendered with syntax highlighting as well by using the `.prisma` file extension or annotating fenced code blocks in Markdown with `prisma`:\n\n````\n```prismamodel User {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  email     String   @unique  name      String?}```\n````\n\n## Accessing environment variables from the schema[​](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema \"Direct link to Accessing environment variables from the schema\")\n\nYou can use environment variables to provide configuration options when a CLI command is invoked, or a Prisma Client query is run.\n\nHardcoding URLs directly in your schema is possible but is discouraged because it poses a security risk. Using environment variables in the schema allows you to **keep secrets out of the schema** which in turn **improves the portability of the schema** by allowing you to use it in different environments.\n\nEnvironment variables can be accessed using the `env()` function:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nYou can use the `env()` function in the following places:\n\n*   A datasource url\n*   Generator binary targets\n\nSee [Environment variables](https://www.prisma.io/docs/orm/more/development-environment/environment-variables) for more information about how to use an `.env` file during development.\n\nThere are two types of comments that are supported in Prisma Schema Language:\n\n*   `// comment`: This comment is for the reader's clarity and is not present in the abstract syntax tree (AST) of the schema.\n*   `/// comment`: These comments will show up in the abstract syntax tree (AST) of the schema as descriptions to AST nodes. Tools can then use these comments to provide additional information. All comments are attached to the next available node - [free-floating comments](https://github.com/prisma/prisma/issues/3544) are not supported and are not included in the AST.\n\nHere are some different examples:\n\n```\n/// This comment will get attached to the `User` node in the ASTmodel User {  /// This comment will get attached to the `id` node in the AST  id     Int   @default(autoincrement())  // This comment is just for you  weight Float /// This comment gets attached to the `weight` node}// This comment is just for you. It will not// show up in the AST./// This comment will get attached to the/// Customer node.model Customer {}\n```\n\n## Auto formatting[​](https://www.prisma.io/docs/orm/prisma-schema/overview#auto-formatting \"Direct link to Auto formatting\")\n\nPrisma ORM supports formatting `.prisma` files automatically. There are two ways to format `.prisma` files:\n\n*   Run the [`prisma format`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#format) command.\n*   Install the [Prisma VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) and invoke the [VS Code format action](https://code.visualstudio.com/docs/editor/codebasics#_formatting) - manually or on save.\n\nThere are no configuration options - [formatting rules](https://www.prisma.io/docs/orm/prisma-schema/overview#formatting-rules) are fixed (similar to Golang's `gofmt` but unlike Javascript's `prettier`):\n\n### Formatting rules[​](https://www.prisma.io/docs/orm/prisma-schema/overview#formatting-rules \"Direct link to Formatting rules\")\n\n#### Configuration blocks are aligned by their `=` sign.[​](https://www.prisma.io/docs/orm/prisma-schema/overview#configuration-blocks-are-aligned-by-theirsign \"Direct link to configuration-blocks-are-aligned-by-theirsign\")\n\n```\nblock _ {  key      = \"value\"  key2     = 1  long_key = true}\n```\n\nA newline resets block alignment:\n\n```\nblock _ {  key   = \"value\"  key2  = 1  key10 = true  long_key   = true  long_key_2 = true}\n```\n\n#### Field definitions are aligned into columns separated by 2 or more spaces[​](https://www.prisma.io/docs/orm/prisma-schema/overview#field-definitions-are-aligned-into-columns-separated-by-2-or-more-spaces \"Direct link to Field definitions are aligned into columns separated by 2 or more spaces\")\n\n```\nblock _ {  id          String       @id  first_name  LongNumeric  @default}\n```\n\n#### Multiline field attributes are properly aligned with the rest of the field attributes[​](https://www.prisma.io/docs/orm/prisma-schema/overview#multiline-field-attributes-are-properly-aligned-with-the-rest-of-the-field-attributes \"Direct link to Multiline field attributes are properly aligned with the rest of the field attributes\")\n\n```\nblock _ {  id          String       @id                           @default  first_name  LongNumeric  @default}\n```\n\nA newline resets formatting rules:\n\n```\nblock _ {  id  String  @id              @default  first_name  LongNumeric  @default}\n```\n\n#### Block attributes are sorted to the end of the block[​](https://www.prisma.io/docs/orm/prisma-schema/overview#block-attributes-are-sorted-to-the-end-of-the-block \"Direct link to Block attributes are sorted to the end of the block\")\n\n```\nblock _ {  key   = \"value\"  @@attribute}\n```",
  "title": "Prisma Schema Overview | Prisma Documentation",
  "description": "The Prisma schema is the main method of configuration when using Prisma. It is typically called schema.prisma and contains your database connection and data model.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model",
  "markdown": "# Data model | Prisma Documentation\n\n[\n\n## How to use Prisma ORM with multiple database schemas\n\n](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema)",
  "title": "Data model | Prisma Documentation",
  "description": "Learn everything you need about the Prisma schema data model.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/introspection",
  "markdown": "# What is introspection? (Reference) | Prisma Documentation\n\nYou can introspect your database using the Prisma CLI in order to generate the [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model) in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema). The data model is needed to [generate Prisma Client](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).\n\nIntrospection is often used to generate an _initial_ version of the data model when [adding Prisma ORM to an existing project](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-postgresql).\n\nHowever, it can also be [used _repeatedly_ in an application](https://www.prisma.io/docs/orm/prisma-schema/introspection#introspection-with-an-existing-schema). This is most commonly the case when you're _not_ using [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) but perform schema migrations using plain SQL or another migration tool. In that case, you also need to re-introspect your database and subsequently re-generate Prisma Client to reflect the schema changes in your [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client).\n\n## What does introspection do?[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#what-does-introspection-do \"Direct link to What does introspection do?\")\n\nIntrospection has one main function: Populate your Prisma schema with a data model that reflects the current database schema.\n\n![Introspect your database with Prisma](https://www.prisma.io/docs/assets/images/prisma-db-pull-generate-schema-8c7216308f1aa7f7117827cba2c96620.png)\n\nHere's an overview of its main functions on SQL databases:\n\n*   Map _tables_ in the database to [Prisma models](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-models)\n*   Map _columns_ in the database to the [fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-fields) of Prisma models\n*   Map _indexes_ in the database to [indexes](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-an-index) in the Prisma schema\n*   Map _database constraints_ to [attributes](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-attributes) or [type modifiers](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) in the Prisma schema\n\nOn MongoDB, the main functions are the following:\n\n*   Map _collections_ in the database to [Prisma models](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-models). Because a _collection_ in MongoDB doesn't have a predefined structure, Prisma ORM _samples_ the _documents_ in the collection and derives the model structure accordingly (i.e. it maps the fields of the _document_ to the [fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-fields) of the Prisma model). If _embedded types_ are detected in a collection, these will be mapped to [composite types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types) in the Prisma schema.\n*   Map _indexes_ in the database to [indexes](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-an-index) in the Prisma schema, if the collection contains at least one document contains a field included in the index\n\nYou can learn more about how Prisma ORM maps types from the database to the types available in the Prisma schema on the respective docs page for the data source connector:\n\n*   [PostgreSQL](https://www.prisma.io/docs/orm/overview/databases/postgresql#type-mapping-between-postgresql-and-prisma-schema)\n*   [MySQL](https://www.prisma.io/docs/orm/overview/databases/mysql#type-mapping-between-mysql-to-prisma-schema)\n*   [SQLite](https://www.prisma.io/docs/orm/overview/databases/sqlite#type-mapping-between-sqlite-to-prisma-schema)\n*   [Microsoft SQL Server](https://www.prisma.io/docs/orm/overview/databases/sql-server#type-mapping-between-microsoft-sql-server-to-prisma-schema)\n\n## The `prisma db pull` command[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#the-prisma-db-pull-command \"Direct link to the-prisma-db-pull-command\")\n\nYou can introspect your database using the `prisma db pull` command of the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli#installation). Note that using this command requires your [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) to be set in your Prisma schema [`datasource`](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources).\n\nHere's a high-level overview of the steps that `prisma db pull` performs internally:\n\n1.  Read the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) from the `datasource` configuration in the Prisma schema\n2.  Open a connection to the database\n3.  Introspect database schema (i.e. read tables, columns and other structures ...)\n4.  Transform database schema into Prisma schema data model\n5.  Write data model into Prisma schema or [update existing schema](https://www.prisma.io/docs/orm/prisma-schema/introspection#introspection-with-an-existing-schema)\n\n## Introspection workflow[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#introspection-workflow \"Direct link to Introspection workflow\")\n\nThe typical workflow for projects that are not using Prisma Migrate, but instead use plain SQL or another migration tool looks as follows:\n\n1.  Change the database schema (e.g. using plain SQL)\n2.  Run `prisma db pull` to update the Prisma schema\n3.  Run `prisma generate` to update Prisma Client\n4.  Use the updated Prisma Client in your application\n\nNote that as you evolve the application, [this process can be repeated for an indefinite number of times](https://www.prisma.io/docs/orm/prisma-schema/introspection#introspection-with-an-existing-schema).\n\n![Introspect workflow](https://www.prisma.io/docs/assets/images/prisma-evolve-app-workflow-ef3834a9ab4af0633eb1e1ee32d2fde7.png)\n\n## Rules and conventions[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#rules-and-conventions \"Direct link to Rules and conventions\")\n\nPrisma ORM employs a number of conventions for translating a database schema into a data model in the Prisma schema:\n\n### Model, field and enum names[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#model-field-and-enum-names \"Direct link to Model, field and enum names\")\n\nField, model and enum names (identifiers) must start with a letter and generally must only contain underscores, letters and digits. You can find the naming rules and conventions for each of these identifiers on the respective docs page:\n\n*   [Naming models](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions)\n*   [Naming fields](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1)\n*   [Naming enums](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-2)\n\nThe general rule for identifiers is that they need to adhere to this regular expression:\n\n#### Sanitization of invalid characters[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#sanitization-of-invalid-characters \"Direct link to Sanitization of invalid characters\")\n\n**Invalid characters** are being sanitized during introspection:\n\n*   If they appear _before_ a letter in an identifier, they get dropped.\n*   If they appear _after_ the first letter, they get replaced by an underscore.\n\nAdditionally, the transformed name is mapped to the database using `@map` or `@@map` to retain the original name.\n\nConsider the following table as an example:\n\n```\nCREATE TABLE \"42User\" (  _id SERIAL PRIMARY KEY,  _name VARCHAR(255),  two$two INTEGER);\n```\n\nBecause the leading `42` in the table name as well as the leading underscores and the `$` on the columns are forbidden in Prisma ORM, introspection adds the `@map` and `@@map` attributes so that these names adhere to Prisma ORM's naming conventions:\n\n```\nmodel User {  id      Int     @id @default(autoincrement()) @map(\"_id\")  name    String? @map(\"_name\")  two_two Int?    @map(\"two$two\")  @@map(\"42User\")}\n```\n\n#### Duplicate Identifiers after Sanitization[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#duplicate-identifiers-after-sanitization \"Direct link to Duplicate Identifiers after Sanitization\")\n\nIf sanitization results in duplicate identifiers, no immediate error handling is in place. You get the error later and can manually fix it.\n\nConsider the case of the following two tables:\n\n```\nCREATE TABLE \"42User\" (  _id SERIAL PRIMARY KEY);CREATE TABLE \"24User\" (  _id SERIAL PRIMARY KEY);\n```\n\nThis would result in the following introspection result:\n\n```\nmodel User {  id Int @id @default(autoincrement()) @map(\"_id\")  @@map(\"42User\")}model User {  id Int @id @default(autoincrement()) @map(\"_id\")  @@map(\"24User\")}\n```\n\nTrying to generate your Prisma Client with `prisma generate` you would get the following error:\n\nIn this case, you must manually change the name of one of the two generated `User` models because duplicate model names are not allowed in the Prisma schema.\n\n### Order of fields[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#order-of-fields \"Direct link to Order of fields\")\n\nIntrospection lists model fields in the same order as the corresponding table columns in the database.\n\n### Order of attributes[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#order-of-attributes \"Direct link to Order of attributes\")\n\nIntrospection adds attributes in the following order (this order is mirrored by `prisma format`):\n\n*   Block level: `@@id`, `@@unique`, `@@index`, `@@map`\n*   Field level : `@id`, `@unique`, `@default`, `@updatedAt`, `@map`, `@relation`\n\n### Relations[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#relations \"Direct link to Relations\")\n\nPrisma ORM translates foreign keys that are defined on your database tables into [relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations).\n\n#### One-to-one relations[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#one-to-one-relations \"Direct link to One-to-one relations\")\n\nPrisma ORM adds a [one-to-one](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations) relation to your data model when the foreign key on a table has a `UNIQUE` constraint, e.g.:\n\n```\nCREATE TABLE \"User\" (    id SERIAL PRIMARY KEY);CREATE TABLE \"Profile\" (    id SERIAL PRIMARY KEY,    \"user\" integer NOT NULL UNIQUE,    FOREIGN KEY (\"user\") REFERENCES \"User\"(id));\n```\n\nPrisma ORM translates this into the following data model:\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  Profile Profile?}model Profile {  id   Int  @id @default(autoincrement())  user Int  @unique  User User @relation(fields: [user], references: [id])}\n```\n\n#### One-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#one-to-many-relations \"Direct link to One-to-many relations\")\n\nBy default, Prisma ORM adds a [one-to-many](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations) relation to your data model for a foreign key it finds in your database schema:\n\n```\nCREATE TABLE \"User\" (    id SERIAL PRIMARY KEY);CREATE TABLE \"Post\" (    id SERIAL PRIMARY KEY,    \"author\" integer NOT NULL,    FOREIGN KEY (\"author\") REFERENCES \"User\"(id));\n```\n\nThese tables are transformed into the following models:\n\n```\nmodel User {  id   Int    @id @default(autoincrement())  Post Post[]}model Post {  id     Int  @id @default(autoincrement())  author Int  User   User @relation(fields: [author], references: [id])}\n```\n\n#### Many-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#many-to-many-relations \"Direct link to Many-to-many relations\")\n\n[Many-to-many](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations) relations are commonly represented as [relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables) in relational databases.\n\nPrisma ORM supports two ways for defining many-to-many relations in the Prisma schema:\n\n*   [Implicit many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) (Prisma ORM manages the relation table under the hood)\n*   [Explicit many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations) (the relation table is present as a [model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-models))\n\n_Implicit_ many-to-many relations are recognized if they adhere to Prisma ORM's [conventions for relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations). Otherwise the relation table is rendered in the Prisma schema as a model (therefore making it an _explicit_ many-to-many relation).\n\nThis topic is covered extensively on the docs page about [Relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations).\n\n#### Disambiguating relations[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#disambiguating-relations \"Direct link to Disambiguating relations\")\n\nPrisma ORM generally omits the `name` argument on the [`@relation`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#the-relation-attribute) attribute if it's not needed. Consider the `User` ↔ `Post` example from the previous section. The `@relation` attribute only has the `references` argument, `name` is omitted because it's not needed in this case:\n\n```\nmodel Post {  id     Int  @id @default(autoincrement())  author Int  User   User @relation(fields: [author], references: [id])}\n```\n\nIt would be needed if there were _two_ foreign keys defined on the `Post` table:\n\n```\nCREATE TABLE \"User\" (    id SERIAL PRIMARY KEY);CREATE TABLE \"Post\" (    id SERIAL PRIMARY KEY,    \"author\" integer NOT NULL,    \"favoritedBy\" INTEGER,    FOREIGN KEY (\"author\") REFERENCES \"User\"(id),    FOREIGN KEY (\"favoritedBy\") REFERENCES \"User\"(id));\n```\n\nIn this case, Prisma ORM needs to [disambiguate the relation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#disambiguating-relations) using a dedicated relation name:\n\n```\nmodel Post {  id                          Int   @id @default(autoincrement())  author                      Int  favoritedBy                 Int?  User_Post_authorToUser      User  @relation(\"Post_authorToUser\", fields: [author], references: [id])  User_Post_favoritedByToUser User? @relation(\"Post_favoritedByToUser\", fields: [favoritedBy], references: [id])}model User {  id                          Int    @id @default(autoincrement())  Post_Post_authorToUser      Post[] @relation(\"Post_authorToUser\")  Post_Post_favoritedByToUser Post[] @relation(\"Post_favoritedByToUser\")}\n```\n\nNote that you can rename the [Prisma-ORM level](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) relation field to anything you like so that it looks friendlier in the generated Prisma Client API.\n\n## Introspection with an existing schema[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#introspection-with-an-existing-schema \"Direct link to Introspection with an existing schema\")\n\nRunning `prisma db pull` for relational databases with an existing Prisma Schema merges manual changes made to the schema, with changes made in the database. (This functionality has been added for the first time with version 2.6.0.) For MongoDB, Introspection for now is meant to be done only once for the initial data model. Running it repeatedly will lead to loss of custom changes, as the ones listed below.\n\nIntrospection for relational databases maintains the following manual changes:\n\n*   Order of `model` blocks\n*   Order of `enum` blocks\n*   Comments\n*   `@map` and `@@map` attributes\n*   `@updatedAt`\n*   `@default(cuid())` (`cuid()` is a Prisma-ORM level function)\n*   `@default(uuid())` (`uuid()` is a Prisma-ORM level function)\n*   Custom `@relation` names\n\n> **Note**: Only relations between models on the database level will be picked up. This means that there **must be a foreign key set**.\n\nThe following properties of the schema are determined by the database:\n\n*   Order of fields within `model` blocks\n*   Order of values within `enum` blocks\n\n> **Note**: All `enum` blocks are listed below `model` blocks.\n\n### Force overwrite[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#force-overwrite \"Direct link to Force overwrite\")\n\nTo overwrite manual changes, and generate a schema based solely on the introspected database and ignore any existing Prisma Schema, add the `--force` flag to the `db pull` command:\n\n```\nnpx prisma db pull --force\n```\n\nUse cases include:\n\n*   You want to start from scratch with a schema generated from the underlying database\n*   You have an invalid schema and must use `--force` to make introspection succeed\n\n## Introspecting only a subset of your database schema[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#introspecting-only-a-subset-of-your-database-schema \"Direct link to Introspecting only a subset of your database schema\")\n\nIntrospecting only a subset of your database schema is [not yet officially supported](https://github.com/prisma/prisma/issues/807) by Prisma ORM.\n\nHowever, you can achieve this by creating a new database user that only has access to the tables which you'd like to see represented in your Prisma schema, and then perform the introspection using that user. The introspection will then only include the tables the new user has access to.\n\nIf your goal is to exclude certain models from the [Prisma Client generation](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client), you can add the [`@@ignore` attribute](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#ignore-1) to the model definition in your Prisma schema. Ignored models are excluded from the generated Prisma Client.\n\n## Introspection warnings for unsupported features[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#introspection-warnings-for-unsupported-features \"Direct link to Introspection warnings for unsupported features\")\n\nThe Prisma Schema Language (PSL) can express a majority of the database features of the [target databases](https://www.prisma.io/docs/orm/reference/supported-databases) Prisma ORM supports. However, there are features and functionality the Prisma Schema Language still needs to express.\n\nFor these features, the Prisma CLI will surface detect usage of the feature in your database and return a warning. The Prisma CLI will also add a comment in the models and fields the features are in use in the Prisma schema. The warnings will also contain a workaround suggestion.\n\nThe `prisma db pull` command will surface the following unsupported features:\n\n*   From version [4.13.0](https://github.com/prisma/prisma/releases/tag/4.13.0):\n    *   [Partitioned tables](https://github.com/prisma/prisma/issues/1708)\n    *   [PostgreSQL Row Level Security](https://github.com/prisma/prisma/issues/12735)\n    *   [Index sort order, `NULLS FIRST` / `NULLS LAST`](https://github.com/prisma/prisma/issues/15466)\n    *   [CockroachDB row-level TTL](https://github.com/prisma/prisma/issues/13982)\n    *   [Comments](https://github.com/prisma/prisma/issues/8703)\n    *   [PostgreSQL deferred constraints](https://github.com/prisma/prisma/issues/8807)\n*   From version [4.14.0](https://github.com/prisma/prisma/releases/tag/4.14.0):\n    *   [Check Constraints](https://github.com/prisma/prisma/issues/3388) (MySQL + PostgreSQL)\n    *   [Exclusion Constraints](https://github.com/prisma/prisma/issues/17514)\n    *   [MongoDB $jsonSchema](https://github.com/prisma/prisma/issues/8135)\n*   From version [4.16.0](https://github.com/prisma/prisma/releases/tag/4.16.0):\n    *   [Expression indexes](https://github.com/prisma/prisma/issues/2504)\n\nYou can find the list of features we intend to support on [GitHub (labeled with `topic:database-functionality`)](https://github.com/prisma/prisma/issues?q=is%3Aopen+label%3A%22topic%3A+database-functionality%22+label%3Ateam%2Fschema+sort%3Aupdated-desc+).\n\n### Workaround for introspection warnings for unsupported features[​](https://www.prisma.io/docs/orm/prisma-schema/introspection#workaround-for-introspection-warnings-for-unsupported-features \"Direct link to Workaround for introspection warnings for unsupported features\")\n\nIf you are using a relational database and either one of the above features listed in the previous section:\n\n1.  Create a draft migration:\n    \n    ```\n    npx prisma migrate dev --create-only\n    ```\n    \n2.  Add the SQL that adds the feature surfaced in the warnings.\n3.  Apply the draft migration to your database:",
  "title": "What is introspection? (Reference) | Prisma Documentation",
  "description": "Learn how you can introspect your database to generate a data model into your Prisma schema.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions",
  "markdown": "# How to represent PostgreSQL extensions in your Prisma schema\n\nThis page introduces PostgreSQL extensions and describes how to represent extensions in your Prisma schema, how to introspect existing extensions in your database, and how to apply changes to your extensions to your database with Prisma Migrate.\n\nwarning\n\nSupport for declaring PostgreSQL extensions in your schema is available in preview for the PostgreSQL connector only in Prisma versions 4.5.0 and later.\n\n## What are PostgreSQL extensions?[​](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions#what-are-postgresql-extensions \"Direct link to What are PostgreSQL extensions?\")\n\nPostgreSQL allows you to extend your database functionality by installing and activating packages known as _extensions_. For example, the `citext` extension adds a case-insensitive string data type. Some extensions, such as `citext`, are supplied directly by PostgreSQL, while other extensions are developed externally. For more information on extensions, see [the PostgreSQL documentation](https://www.postgresql.org/docs/current/sql-createextension.html).\n\nTo use an extension, it must first be _installed_ on the local file system of your database server. You then need to _activate_ the extension, which runs a script file that adds the new functionality.\n\ninfo\n\nNote that PostgreSQL's documentation uses the term 'install' to refer to what we call activating an extension. We have used separate terms here to make it clear that these are two different steps.\n\nPrisma's `postgresqlExtensions` preview feature allows you to represent PostgreSQL extensions in your Prisma schema. Note that specific extensions may add functionality that is not currently supported by Prisma. For example, an extension may add a type or index that is not supported by Prisma. This functionality must be implemented on a case-by-case basis and is not provided by this preview feature.\n\n## How to enable the `postgresqlExtensions` preview feature[​](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions#how-to-enable-the-postgresqlextensions-preview-feature \"Direct link to how-to-enable-the-postgresqlextensions-preview-feature\")\n\nRepresenting PostgreSQL extensions in your Prisma Schema is currently a preview feature. To enable the `postgresqlExtensions` preview feature, you will need to add the `postgresqlExtensions` feature flag to the `previewFeatures` field of the `generator` block in your Prisma schema:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"postgresqlExtensions\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\n## How to represent PostgreSQL extensions in your Prisma schema[​](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions#how-to-represent-postgresql-extensions-in-your-prisma-schema \"Direct link to How to represent PostgreSQL extensions in your Prisma schema\")\n\nTo represent PostgreSQL extensions in your Prisma schema, add the `extensions` field to the `datasource` block of your `schema.prisma` file with an array of the extensions that you require. For example, the following schema lists the `hstore`, `pg_trgm` and `postgis` extensions:\n\nschema.prisma\n\n```\ndatasource db {  provider   = \"postgresql\"  url        = env(\"DATABASE_URL\")  extensions = [hstore(schema: \"myHstoreSchema\"), pg_trgm, postgis(version: \"2.1\")]}\n```\n\nEach extension name in the Prisma schema can take the following optional arguments:\n\n*   `schema`: the name of the schema in which to activate the extension's objects. If this argument is not specified, the current default object creation schema is used.\n*   `version`: the version of the extension to activate. If this argument is not specified, the value given in the extension's control file is used.\n*   `map`: the database name of the extension. If this argument is not specified, the name of the extension in the Prisma schema must match the database name.\n\nIn the example above, the `hstore` extension uses the `myHstoreSchema` schema, and the `postgis` extension is activated with version 2.1 of the extension.\n\nThe `map` argument is useful when the PostgreSQL extension that you want to activate has a name that is not a valid identifier in the Prisma schema. For example, the `uuid-ossp` PostgreSQL extension name is an invalid identifier because it contains a hyphen. In the following example, the extension is mapped to the valid name `uuidOssp` in the Prisma schema:\n\nschema.prisma\n\n```\ndatasource db {  provider   = \"postgresql\"  url        = env(\"DATABASE_URL\")  extensions = [uuidOssp(map: \"uuid-ossp\")]}\n```\n\n## How to introspect PostgreSQL extensions[​](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions#how-to-introspect-postgresql-extensions \"Direct link to How to introspect PostgreSQL extensions\")\n\nTo [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) PostgreSQL extensions currently activated in your database and add relevant extensions to your Prisma schema, run `npx prisma db pull`.\n\nMany PostgreSQL extensions are not relevant to the Prisma schema. For example, some extensions are intended for database administration tasks that do not change the schema. If all these extensions were included, the list of extensions would be very long. To avoid this, Prisma maintains an allowlist of known relevant extensions. The current allowlist is the following:\n\n*   [`citext`](https://www.postgresql.org/docs/current/citext.html): provides a case-insensitive character string type, `citext`\n*   [`pgcrypto`](https://www.postgresql.org/docs/current/pgcrypto.html): provides cryptographic functions, like `gen_random_uuid()`, to generate universally unique identifiers (UUIDs v4)\n*   [`uuid-ossp`](https://www.postgresql.org/docs/current/uuid-ossp.html): provides functions, like `uuid_generate_v4()`, to generate universally unique identifiers (UUIDs v4)\n*   [`postgis`](https://postgis.net/): adds GIS (Geographic Information Systems) support\n\n**Note**: Since PostgreSQL v13, `gen_random_uuid()` can be used without an extension to generate universally unique identifiers (UUIDs v4).\n\nExtensions are introspected as follows:\n\n*   The first time you introspect, all database extensions that are on the allowlist are added to your Prisma schema\n*   When you re-introspect, the behavior depends on whether the extension is on the allowlist or not.\n    *   Extensions on the allowlist:\n        *   are **added** to your Prisma schema if they are in the database but not in the Prisma schema\n        *   are **kept** in your Prisma schema if they are in the Prisma schema and in the database\n        *   are **removed** from your Prisma schema if they are in the Prisma schema but not the database\n    *   Extensions not on the allowlist:\n        *   are **kept** in your Prisma schema if they are in the Prisma schema and in the database\n        *   are **removed** from your Prisma schema if they are in the Prisma schema but not the database\n\nThe `version` argument will not be added to the Prisma schema when you introspect.\n\n## How to migrate PostgreSQL extensions[​](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions#how-to-migrate-postgresql-extensions \"Direct link to How to migrate PostgreSQL extensions\")\n\nYou can update your list of PostgreSQL extensions in your Prisma schema and apply the changes to your database with [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\nThis works in a similar way to migration of other elements of your Prisma schema, such as models or fields. However, there are the following differences:\n\n*   If you remove an extension from your schema but it is still activated on your database, Prisma Migrate will not deactivate it from the database.\n*   If you add a new extension to your schema, it will only be activated if it does not already exist in the database, because the extension may already have been created manually.\n*   If you remove the `version` or `schema` arguments from the extension definition, it has no effect to the extensions in the database in the following migrations.",
  "title": "How to represent PostgreSQL extensions in your Prisma schema | Prisma Documentation",
  "description": "How to represent PostgreSQL extensions in your Prisma scheme, introspect extensions in your database, and apply changes to extensions with Prisma Migrate",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration",
  "markdown": "# Setup & configuration | Prisma Documentation\n\nThis section describes how to set up, generate, configure, and instantiate `PrismaClient` , as well as when and how to actively [manage connections](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management).\n\n## In this section[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration#in-this-section \"Direct link to In this section\")\n\n[\n\n## Introduction\n\n](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/introduction)\n\n[\n\n## Generating Prisma Client\n\n](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client)\n\n[\n\n## Instantiating Prisma Client\n\n](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/instantiate-prisma-client)\n\n[\n\n## Database connections\n\n](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections)\n\n[\n\n## Custom model and field names\n\n](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names)\n\n[\n\n## Configuring error formatting\n\n](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/error-formatting)\n\n[\n\n## Read replicas\n\n](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/read-replicas)\n\n[\n\n## Database polyfills\n\n](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/database-polyfills)",
  "title": "Setup & configuration | Prisma Documentation",
  "description": "This section explains how to generate, configure, and instantiate Prisma Client, as well as when and how to manage database connections.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries",
  "markdown": "# Prisma Client Queries | Prisma Documentation\n\n[\n\n## Aggregation, grouping, and summarizing\n\n](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing)",
  "title": "Prisma Client Queries | Prisma Documentation",
  "description": "Learn about the database queries you can send with Prisma Client.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types",
  "markdown": "# Fields & types | Prisma Documentation\n\nThis section covers various special fields and types you can use with Prisma Client.\n\n## Working with `Decimal`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types#working-with-decimal \"Direct link to working-with-decimal\")\n\n`Decimal` fields are represented by the [`Decimal.js` library](https://mikemcl.github.io/decimal.js/). The following example demonstrates how to import and use `Prisma.Decimal`:\n\n```\nimport { PrismaClient, Prisma } from '@prisma/client'const newTypes = await prisma.sample.create({  data: {    cost: new Prisma.Decimal(24.454545),  },})\n```\n\n  \n\n## Working with `BigInt`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types#working-with-bigint \"Direct link to working-with-bigint\")\n\n`BigInt` fields are represented by the [`BigInt` type](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) (Node.js 10.4.0+ required). The following example demonstrates how to use the `BigInt` type:\n\n```\nimport { PrismaClient, Prisma } from '@prisma/client'const newTypes = await prisma.sample.create({  data: {    revenue: BigInt(534543543534),  },})\n```\n\n### Serializing BigInt[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types#serializing-bigint \"Direct link to Serializing BigInt\")\n\nPrisma Client returns records as plain JavaScript objects. If you attempt to use `JSON.stringify` on an object that includes a `BigInt` field, you will see the following error:\n\n```\nDo not know how to serialize a BigInt\n```\n\nTo work around this issue, use a customized implementation of `JSON.stringify`:\n\n```\nJSON.stringify(  this,  (key, value) => (typeof value === 'bigint' ? value.toString() : value) // return everything else unchanged)\n```\n\n## Working with `Bytes`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types#working-with-bytes \"Direct link to working-with-bytes\")\n\n`Bytes` fields are represented by the [`Buffer`](https://nodejs.org/api/buffer.html) type. The following example demonstrates how to use the `Buffer` type:\n\n```\nimport { PrismaClient, Prisma } from '@prisma/client'const newTypes = await prisma.sample.create({  data: {    myField: Buffer.from([1, 2, 3, 4]),  },})\n```\n\n## Working with `Json`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types#working-with-json \"Direct link to working-with-json\")\n\nSee: [Working with `Json` fields](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields)\n\n## Working with scalar lists / scalar arrays[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types#working-with-scalar-lists--scalar-arrays \"Direct link to Working with scalar lists / scalar arrays\")\n\nSee: [Working with scalar lists / arrays](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays)\n\n## Working with composite IDs and compound unique constraints[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types#working-with-composite-ids-and-compound-unique-constraints \"Direct link to Working with composite IDs and compound unique constraints\")\n\nSee: [Working with composite IDs and compound unique constraints](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-composite-ids-and-constraints)",
  "title": "Fields & types | Prisma Documentation",
  "description": "Learn how to use about special fields and types with Prisma Client.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions",
  "markdown": "# Prisma Client extensions | Prisma Documentation\n\ninfo\n\nPrisma Client extensions are Generally Available from versions 4.16.0 and later. They were introduced in Preview in version 4.7.0. Make sure you enable the `clientExtensions` Preview feature flag if you are running on a version earlier than 4.16.0.\n\nYou can use Prisma Client extensions to add functionality to your models, result objects, and queries, or to add client-level methods.\n\nYou can create an extension with one or more of the following component types:\n\n*   `model`: [add custom methods or fields to your models](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model)\n*   `client`: [add client-level methods to Prisma Client](https://www.prisma.io/docs/orm/prisma-client/client-extensions/client)\n*   `query`: [create custom Prisma Client queries](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query)\n*   `result`: [add custom fields to your query results](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result)\n\nFor example, you might create an extension that uses the `model` and `client` component types.\n\n## About Prisma Client extensions[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#about-prisma-client-extensions \"Direct link to About Prisma Client extensions\")\n\nWhen you use a Prisma Client extension, you create an _extended client_. An extended client is a lightweight variant of the standard Prisma Client that is wrapped by one or more extensions. The standard client is not mutated. You can add as many extended clients as you want to your project. [Learn more about extended clients](https://www.prisma.io/docs/orm/prisma-client/client-extensions#extended-clients).\n\nYou can associate a single extension, or multiple extensions, with an extended client. [Learn more about multiple extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions#multiple-extensions).\n\nYou can [share your Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions/shared-extensions) with other Prisma ORM users, and [import Prisma Client extensions developed by other users](https://www.prisma.io/docs/orm/prisma-client/client-extensions/shared-extensions#install-a-shared-packaged-extension) into your Prisma ORM project.\n\n### Extended clients[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#extended-clients \"Direct link to Extended clients\")\n\nExtended clients interact with each other, and with the standard client, as follows:\n\n*   Each extended client operates independently in an isolated instance.\n*   Extended clients cannot conflict with each other, or with the standard client.\n*   All extended clients and the standard client communicate with the same [Prisma ORM query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines).\n*   All extended clients and the standard client share the same connection pool.\n\n> **Note**: The author of an extension can modify this behavior since they're able to run arbitrary code as part of an extension. For example, an extension might actually create an entirely new `PrismaClient` instance (including its own query engine and connection pool). Be sure to check the documentation of the extension you're using to learn about any specific behavior it might implement.\n\n### Example use cases for extended clients[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#example-use-cases-for-extended-clients \"Direct link to Example use cases for extended clients\")\n\nBecause extended clients operate in isolated instances, they can be a good way to do the following, for example:\n\n*   Implement row-level security (RLS), where each HTTP request has its own client with its own RLS extension, customized with session data. This can keep each user entirely separate, each in a separate client.\n*   Add a `user.current()` method for the `User` model to get the currently logged-in user.\n*   Enable more verbose logging for requests if a debug cookie is set.\n*   Attach a unique request id to all logs so that you can correlate them later, for example to help you analyze the operations that Prisma Client carries out.\n*   Remove a `delete` method from models unless the application calls the admin endpoint and the user has the necessary privileges.\n\n## Add an extension to Prisma Client[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#add-an-extension-to-prisma-client \"Direct link to Add an extension to Prisma Client\")\n\nYou can create an extension using two primary ways:\n\n*   Use the client-level [`$extends`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#client-methods) method\n    \n    ```\n    const xprisma = prisma.$extends({  name: 'signUp', // Optional: name appears in error logs  model: {        // This is a `model` component    user: { ... } // The extension logic for the `user` model goes inside the curly braces  },})\n    ```\n    \n*   Use the `Prisma.defineExtension` method to define an extension and assign it to a variable, and then pass the extension to the client-level `$extends` method\n    \n    ```\n    import { Prisma } from '@prisma/client'// Define the extensionconst myExtension = Prisma.defineExtension({  name: 'signUp', // Optional: name appears in error logs  model: {        // This is a `model` component    user: { ... } // The extension logic for the `user` model goes inside the curly braces  },})// Pass the extension to a Prisma Client instanceconst xprisma = prisma.$extends(myExtension)\n    ```\n    \n    tip\n    \n    This pattern is useful for when you would like to separate extensions into multiple files or directories within a project.\n    \n\nThe above examples use the [`model` extension component](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model) to extend the `User` model.\n\nIn your `$extends` method, use the appropriate extension component or components ([`model`](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model), [`client`](https://www.prisma.io/docs/orm/prisma-client/client-extensions/client), [`result`](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result) or [`query`](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query)).\n\n## Name an extension for error logs[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#name-an-extension-for-error-logs \"Direct link to Name an extension for error logs\")\n\nYou can name your extensions to help identify them in error logs. To do so, use the optional field `name`. For example:\n\n```\nconst prisma = new PrismaClient().$extends({  name: `signUp`,  // (Optional) Extension name  model: {    user: { ... } },})\n```\n\n## Multiple extensions[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#multiple-extensions \"Direct link to Multiple extensions\")\n\nYou can associate an extension with an [extended client](https://www.prisma.io/docs/orm/prisma-client/client-extensions#about-prisma-client-extensions) in one of two ways:\n\n*   You can associate it with an extended client on its own, or\n*   You can combine the extension with other extensions and associate all of these extensions with an extended client. The functionality from these combined extensions applies to the same extended client. Note: [Combined extensions can conflict](https://www.prisma.io/docs/orm/prisma-client/client-extensions#conflicts-in-combined-extensions).\n\nYou can combine the two approaches above. For example, you might associate one extension with its own extended client and associate two other extensions with another extended client. [Learn more about how client instances interact](https://www.prisma.io/docs/orm/prisma-client/client-extensions#extended-clients).\n\n### Apply multiple extensions to an extended client[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#apply-multiple-extensions-to-an-extended-client \"Direct link to Apply multiple extensions to an extended client\")\n\nIn the following example, suppose that you have two extensions, `extensionA` and `extensionB`. There are two ways to combine these.\n\n#### Option 1: Declare the new client in one line[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#option-1-declare-the-new-client-in-one-line \"Direct link to Option 1: Declare the new client in one line\")\n\nWith this option, you apply both extensions to a new client in one line of code.\n\n```\n// First of all, store your original Prisma Client in a variable as usualconst prisma = new PrismaClient()// Declare an extended client that has an extensionA and extensionBconst prismaAB = prisma.$extends(extensionA).$extends(extensionB)\n```\n\nYou can then refer to `prismaAB` in your code, for example `prismaAB.myExtensionMethod()`.\n\n#### Option 2: Declare multiple extended clients[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#option-2-declare-multiple-extended-clients \"Direct link to Option 2: Declare multiple extended clients\")\n\nThe advantage of this option is that you can call any of the extended clients separately.\n\n```\n// First of all, store your original Prisma Client in a variable as usualconst prisma = new PrismaClient()// Declare an extended client that has extensionA appliedconst prismaA = prisma.$extends(extensionA)// Declare an extended client that has extensionB appliedconst prismaB = prisma.$extends(extensionB)// Declare an extended client that is a combination of clientA and clientBconst prismaAB = prismaA.$extends(extensionB)\n```\n\nIn your code, you can call any of these clients separately, for example `prismaA.myExtensionMethod()`, `prismaB.myExtensionMethod()`, or `prismaAB.myExtensionMethod()`.\n\n### Conflicts in combined extensions[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#conflicts-in-combined-extensions \"Direct link to Conflicts in combined extensions\")\n\nWhen you combine two or more extensions into a single extended client, then the _last_ extension that you declare takes precedence in any conflict. In the example in option 1 above, suppose there is a method called `myExtensionMethod()` defined in `extensionA` and a method called `myExtensionMethod()` in `extensionB`. When you call `prismaAB.myExtensionMethod()`, then Prisma Client uses `myExtensionMethod()` as defined in `extensionB`.\n\n## Type of an extended client[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#type-of-an-extended-client \"Direct link to Type of an extended client\")\n\nYou can infer the type of an extended Prisma Client instance using the [`typeof`](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html) utility as follows:\n\n```\nconst extendedPrismaClient = new PrismaClient().$extends({  /** extension */})type ExtendedPrismaClient = typeof extendedPrismaClient\n```\n\nIf you're using Prisma Client as a singleton, you can get the type of the extended Prisma Client instance using the `typeof` and [`ReturnType`](https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype) utilities as follows:\n\n```\nfunction getExtendedClient() {  return new PrismaClient().$extends({    /* extension */  })}type ExtendedPrismaClient = ReturnType<typeof getExtendedClient>\n```\n\n## Limitations[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#limitations \"Direct link to Limitations\")\n\n### Usage of `$on` and `$use` with extended clients[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#usage-of-on-and-use-with-extended-clients \"Direct link to usage-of-on-and-use-with-extended-clients\")\n\n`$on` and `$use` are not available in extended clients. If you would like to continue using these [client-level methods](https://www.prisma.io/docs/orm/reference/prisma-client-reference#client-methods) with an extended client, you will need to hook them up before extending the client.\n\n```\nconst prisma = new PrismaClient()prisma.$use(async (params, next) => {  console.log('This is middleware!')  return next(params)})const xPrisma = prisma.$extends({  name: 'myExtension',  model: {    user: {      async signUp(email: string) {        await prisma.user.create({ data: { email } })      },    },  },})\n```\n\nTo learn more, see our documentation on [`$on`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#on) and [`$use`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#use)\n\n### Usage of client-level methods in extended clients[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#usage-of-client-level-methods-in-extended-clients \"Direct link to Usage of client-level methods in extended clients\")\n\n[Client-level methods](https://www.prisma.io/docs/orm/reference/prisma-client-reference#client-methods) do not necessarily exist on extended clients. For these clients you will need to first check for existence before using.\n\n```\nconst xPrisma = prisma.$extends(...);if (xPrisma.$connect) {  xPrisma.$connect()}\n```\n\n### Usage with nested operations[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions#usage-with-nested-operations \"Direct link to Usage with nested operations\")\n\nThe `query` extension type does not support nested read and write operations.",
  "title": "Prisma Client extensions | Prisma Documentation",
  "description": "Extend the functionality of Prisma Client",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/type-safety",
  "markdown": "# Type safety | Prisma Documentation\n\nThe generated code for Prisma Client contains several helpful types and utilities that you can use to make your application more type-safe. This page describes patterns for leveraging them.\n\n> **Note**: If you're interested in advanced type safety topics with Prisma ORM, be sure to check out this [blog post](https://www.prisma.io/blog/satisfies-operator-ur8ys8ccq7zb) about improving your Prisma Client workflows with the new TypeScript `satisfies` keyword.\n\n## Importing generated types[​](https://www.prisma.io/docs/orm/prisma-client/type-safety#importing-generated-types \"Direct link to Importing generated types\")\n\nYou can import the `Prisma` namespace and use dot notation to access types and utilities. The following example shows how to import the `Prisma` namespace and use it to access and use the `Prisma.UserSelect` [generated type](https://www.prisma.io/docs/orm/prisma-client/type-safety#what-are-generated-types):\n\n```\nimport { Prisma } from '@prisma/client'// Build 'select' objectconst userEmail: Prisma.UserSelect = {  email: true,}// Use select objectconst createUser = await prisma.user.create({  data: {    email: 'bob@prisma.io',  },  select: userEmail,})\n```\n\nSee also: [Using the `Prisma.UserCreateInput` generated type](https://www.prisma.io/docs/orm/prisma-client/queries/crud#create-a-single-record-using-generated-types)\n\n## What are generated types?[​](https://www.prisma.io/docs/orm/prisma-client/type-safety#what-are-generated-types \"Direct link to What are generated types?\")\n\nGenerated types are TypeScript types that are derived from your models. You can use them to create typed objects that you pass into top-level methods like `prisma.user.create(...)` or `prisma.user.update(...)`, or options such as `select` or `include`.\n\nFor example, `select` accepts an object of type `UserSelect`. Its object properties match those that are supported by `select` statements according to the model.\n\nThe first tab below shows the `UserSelect` generated type and how each property on the object has a type annotation. The second tab shows the resulting schema model.\n\n*   Generated type\n*   Model\n\n```\ntype Prisma.UserSelect = {    id?: boolean | undefined;    email?: boolean | undefined;    name?: boolean | undefined;    posts?: boolean | Prisma.PostFindManyArgs | undefined;    profile?: boolean | Prisma.ProfileArgs | undefined;}\n```\n\nIn TypeScript the concept of [type annotations](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-annotations-on-variables) is when you declare a variable and add a type annotation to describe the type of the variable. See the below example.\n\n```\nconst myAge: number = 37const myName: string = 'Rich'\n```\n\nBoth of these variable declarations have been given a type annotation to specify what primitive type they are, `number` and `string` respectively. Most of the time this kind of annotation is not needed as TypeScript will infer the type of the variable based on how its initialized. In the above example `myAge` was initialized with a number so TypeScript guesses that it should be typed as a number.\n\nGoing back to the `UserSelect` type, if you were to use dot notation on the created object `userEmail`, you would have access to all of the fields on the `User` model that can be interacted with using a `select` statement.\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  posts   Post[]  profile Profile?}\n```\n\n```\nimport { Prisma } from '@prisma/client'const userEmail: Prisma.UserSelect = {  email: true,}// properties available on the typed objectuserEmail.iduserEmail.emailuserEmail.nameuserEmail.postsuserEmail.profile\n```\n\nIn the same mould, you can type an object with an `include` generated type then your object would have access to those properties on which you can use an `include` statement.\n\n```\nimport { Prisma } from '@prisma/client'const userPosts: Prisma.UserInclude = {  posts: true,}// properties available on the typed objectuserPosts.postsuserPosts.profile\n```\n\n> See the [model query options](https://www.prisma.io/docs/orm/reference/prisma-client-reference#model-query-options) reference for more information about the different types available.\n\n### Generated `UncheckedInput` types[​](https://www.prisma.io/docs/orm/prisma-client/type-safety#generated-uncheckedinput-types \"Direct link to generated-uncheckedinput-types\")\n\nThe `UncheckedInput` types are a special set of generated types that allow you to perform some operations that Prisma Client considers \"unsafe\", like directly writing [relation scalar fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations). You can choose either the \"safe\" `Input` types or the \"unsafe\" `UncheckedInput` type when doing operations like `create`, `update`, or `upsert`.\n\nFor example, this Prisma schema has a one-to-many relation between `User` and `Post`:\n\n```\nmodel Post {  id       Int     @id @default(autoincrement())  title    String  @db.VarChar(255)  content  String?  author   User    @relation(fields: [authorId], references: [id])  authorId Int}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\nThe first tab shows the `PostUncheckedCreateInput` generated type. It contains the `authorId` property, which is a relation scalar field. The second tab shows an example query that uses the `PostUncheckedCreateInput` type. This query will result in an error if a user with an `id` of `1` does not exist.\n\n*   Generated type\n*   Example query\n\n```\ntype PostUncheckedCreateInput = {  id?: number  title: string  content?: string | null  authorId: number}\n```\n\nThe same query can be rewritten using the \"safer\" `PostCreateInput` type. This type does not contain the `authorId` field but instead contains the `author` relation field.\n\n*   Generated type\n*   Example query\n\n```\ntype PostCreateInput = {  title: string  content?: string | null  author: UserCreateNestedOneWithoutPostsInput}type UserCreateNestedOneWithoutPostsInput = {  create?: XOR<    UserCreateWithoutPostsInput,    UserUncheckedCreateWithoutPostsInput  >  connectOrCreate?: UserCreateOrConnectWithoutPostsInput  connect?: UserWhereUniqueInput}\n```\n\nThis query will also result in an error if an author with an `id` of `1` does not exist. In this case, Prisma Client will give a more descriptive error message. You can also use the [`connectOrCreate`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connectorcreate) API to safely create a new user if one does not already exist with the given `id`.\n\nWe recommend using the \"safe\" `Input` types whenever possible.\n\n## Type utilities[​](https://www.prisma.io/docs/orm/prisma-client/type-safety#type-utilities \"Direct link to Type utilities\")\n\ninfo\n\nThis feature is available from Prisma ORM version 4.9.0 upwards.\n\nTo help you create highly type-safe applications, Prisma Client provides a set of type utilities that tap into input and output types. These types are fully dynamic, which means that they adapt to any given model and schema. You can use them to improve the auto-completion and developer experience of your projects.\n\nThis is especially useful in [validating inputs](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator) and [shared Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions/shared-extensions).\n\nThe following type utilities are available in Prisma Client:\n\n*   `Exact<Input, Shape>`: Enforces strict type safety on `Input`. `Exact` makes sure that a generic type `Input` strictly complies with the type that you specify in `Shape`. It [narrows](https://www.typescriptlang.org/docs/handbook/2/narrowing.html) `Input` down to the most precise types.\n*   `Args<Type, Operation>`: Retrieves the input arguments for any given model and operation. This is particularly useful for extension authors who want to do the following:\n    *   Re-use existing types to extend or modify them.\n    *   Benefit from the same auto-completion experience as on existing operations.\n*   `Result<Type, Arguments, Operation>`: Takes the input arguments and provides the result for a given model and operation. You would usually use this in conjunction with `Args`. As with `Args`, `Result` helps you to re-use existing types to extend or modify them.\n*   `Payload<Type, Operation>`: Retrieves the entire structure of the result, as scalars and relations objects for a given model and operation. For example, you can use this to determine which keys are scalars or objects at a type level.\n\nAs an example, here's a quick way you can enforce that the arguments to a function matches what you will pass to a `post.create`:\n\n```\ntype PostCreateBody = Prisma.Args<typeof prisma.post, 'create'>['data']const addPost = async (postBody: PostCreateBody) => {  const post = await prisma.post.create({ data: postBody })  return post}await addPost(myData)//              ^ guaranteed to match the input of `post.create`\n```",
  "title": "Type safety | Prisma Documentation",
  "description": "Prisma Client provides full type safety for queries, even for partial queries or included relations. This page explains how to leverage the generated types and utilities.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/observability-and-logging",
  "markdown": "# Observability & logging | Prisma Documentation\n\n## In this section[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging#in-this-section \"Direct link to In this section\")\n\n[\n\n## Logging\n\n](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging)\n\n[\n\n## Metrics\n\n](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics)\n\n[\n\n## OpenTelemetry tracing\n\n](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing)",
  "title": "Observability & logging | Prisma Documentation",
  "description": "Observability & logging",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting",
  "markdown": "# Debugging & troubleshooting | Prisma Documentation\n\nDebugging & troubleshooting\n\n## In this section[​](https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting#in-this-section \"Direct link to In this section\")\n\n[\n\n## Debugging\n\n](https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/debugging)\n\n[\n\n## Handling exceptions and errors\n\n](https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/handling-exceptions-and-errors)",
  "title": "Debugging & troubleshooting | Prisma Documentation",
  "description": "Debugging & troubleshooting",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/testing",
  "markdown": "# Testing with Prisma ORM | Prisma Documentation\n\nThis section describes how to approach testing an application that uses Prisma Client.\n\n[\n\n## Unit testing\n\n](https://www.prisma.io/docs/orm/prisma-client/testing/unit-testing)\n\n[\n\n## Integration testing\n\n](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing)",
  "title": "Testing with Prisma ORM | Prisma Documentation",
  "description": "How to implement unit and integration testing with Prisma ORM",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-migrate/getting-started",
  "markdown": "# Getting started | Prisma Documentation\n\nThis page explains how to get started with migrating your schema in a development environment using Prisma Migrate. See [Developing with Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) for a more in-depth development workflow.\n\n## Get started with Prisma Migrate from scratch[​](https://www.prisma.io/docs/orm/prisma-migrate/getting-started#get-started-with-prisma-migrate-from-scratch \"Direct link to Get started with Prisma Migrate from scratch\")\n\nTo get started with Prisma Migrate in a development environment:\n\n1.  Create a Prisma schema:\n    \n    schema.prisma\n    \n    ```\n    datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model User {  id    Int    @id @default(autoincrement())  name  String  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  published Boolean @default(true)  authorId  Int  author    User    @relation(fields: [authorId], references: [id])}\n    ```\n    \n    tip\n    \n    You can use [native type mapping attributes](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-types) in your schema to decide which exact database type to create (for example, `String` can map to `varchar(100)` or `text`).\n    \n    1.  Create the first migration:\n    \n    ```\n    prisma migrate dev --name init\n    ```\n    \n    Your Prisma schema is now in sync with your database schema and you have initialized a migration history:\n    \n    ```\n    migrations/  └─ 20210313140442_init/    └─ migration.sql\n    ```\n    \n2.  Add additional fields to your schema:\n    \n    ```\n    model User {  id       Int    @id @default(autoincrement())  jobTitle String  name     String  posts    Post[]}\n    ```\n    \n3.  Create the second migration:\n    \n    ```\n    prisma migrate dev --name added_job_title\n    ```\n    \n    Your Prisma schema is once again in sync with your database schema, and your migration history contains two migrations:\n    \n    ```\n    migrations/  └─ 20210313140442_init/    └─ migration.sql  └─ 20210313140442_added_job_title/    └─ migration.sql\n    ```\n    \n\nYou now have a migration history that you can [source control](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/migration-histories#committing-the-migration-history-to-source-control) and use to [deploy changes to test environments and production](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#production-and-testing-environments).\n\n## Adding Prisma Migrate to an existing project[​](https://www.prisma.io/docs/orm/prisma-migrate/getting-started#adding-prisma-migrate-to-an-existing-project \"Direct link to Adding Prisma Migrate to an existing project\")\n\nThe steps involved in **adding Prisma Migrate to your existing project** are:\n\n1.  Introspect your database to update your Prisma schema\n2.  Create a baseline migration\n3.  Update your schema or migration to workaround features not supported by Prisma Schema Language\n4.  Apply the baseline migration\n5.  Commit the migration history and Prisma schema\n\n### Introspect to create or update your Prisma schema[​](https://www.prisma.io/docs/orm/prisma-migrate/getting-started#introspect-to-create-or-update-your-prisma-schema \"Direct link to Introspect to create or update your Prisma schema\")\n\nMake sure your Prisma schema is in sync with your database schema. This should already be true if you are using a previous version of Prisma Migrate.\n\n1.  Introspect the database to make sure that your Prisma schema is up-to-date:\n    \n\n### Create a baseline migration[​](https://www.prisma.io/docs/orm/prisma-migrate/getting-started#create-a-baseline-migration \"Direct link to Create a baseline migration\")\n\nBaselining is the process of initializing a migration history for a database that:\n\n*   ✔ Existed before you started using Prisma Migrate\n*   ✔ Contains data that must be maintained (like production), which means that the database cannot be reset\n\nBaselining tells Prisma Migrate to assume that one or more migrations have **already been applied**. This prevents generated migrations from failing when they try to create tables and fields that already exist.\n\nTo create a baseline migration:\n\n1.  If you have a `prisma/migrations` folder, delete, move, rename, or archive this folder.\n    \n2.  Run the following command to create a `migrations` directory inside with your preferred name. This example will use `0_init` for the migration name:\n    \n    ```\n    mkdir -p prisma/migrations/0_init\n    ```\n    \n    info\n    \n    The `0_` is important because Prisma Migrate applies migrations in a [lexicographic order](https://en.wikipedia.org/wiki/Lexicographic_order). You can use a different value such as the current timestamp.\n    \n3.  Generate a migration and save it to a file using `prisma migrate diff`\n    \n    ```\n    npx prisma migrate diff \\--from-empty \\--to-schema-datamodel prisma/schema.prisma \\--script > prisma/migrations/0_init/migration.sql\n    ```\n    \n4.  Review the generated migration\n    \n\n### Work around features not supported by Prisma Schema Language[​](https://www.prisma.io/docs/orm/prisma-migrate/getting-started#work-around-features-not-supported-by-prisma-schema-language \"Direct link to Work around features not supported by Prisma Schema Language\")\n\nTo include [unsupported database features](https://www.prisma.io/docs/orm/prisma-migrate/workflows/unsupported-database-features) that already exist in the database, you must replace or modify the initial migration SQL:\n\n1.  Open the `migration.sql` file generated in the [Create a baseline migration](https://www.prisma.io/docs/orm/prisma-migrate/getting-started#create-a-baseline-migration) section.\n    \n2.  Modify the generated SQL. For example:\n    \n\n*   If the changes are minor, you can append additional custom SQL to the generated migration - the following example creates a partial index:\n    \n    ```\n    /* Generated migration SQL */CREATE UNIQUE INDEX tests_success_constraint ON posts (subject, target)  WHERE success;\n    ```\n    \n*   If the changes are significant, it can be easier to replace the entire migration file with the result of a database dump ([`mysqldump`](https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html), [`pg_dump`](https://www.postgresql.org/docs/12/app-pgdump.html))\n    \n\ninfo\n\nNote that the order of the tables matters when creating all of them at once, since foreign keys are created at the same step. Therefore, either re-order them or move constraint creation to the last step after all tables are created, so you won't face `can't create constraint` errors\n\n### Apply the initial migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/getting-started#apply-the-initial-migrations \"Direct link to Apply the initial migrations\")\n\nTo apply your initial migration(s):\n\n1.  Run the following command against your database:\n    \n    ```\n    npx prisma migrate resolve --applied 0_init\n    ```\n    \n2.  Review the database schema to ensure the migration leads to the desired end-state (for example, by comparing the schema to the production database).\n    \n\nThe new migration history and the database schema should now be in sync with your Prisma schema.\n\n### Commit the migration history and Prisma schema[​](https://www.prisma.io/docs/orm/prisma-migrate/getting-started#commit-the-migration-history-and-prisma-schema \"Direct link to Commit the migration history and Prisma schema\")\n\nCommit the following to source control:\n\n*   The entire migration history folder\n*   The `schema.prisma` file\n\n## Going further[​](https://www.prisma.io/docs/orm/prisma-migrate/getting-started#going-further \"Direct link to Going further\")\n\n*   Refer to the [Deploying database changes with Prisma Migrate](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-database-changes-with-prisma-migrate) guide for more on deploying migrations to production.\n*   Refer to the [Production Troubleshooting](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#fixing-failed-migrations-with-migrate-diff-and-db-execute) guide to learn how to debug and resolve failed migrations in production using `prisma migrate diff`, `prisma db execute` and/ or `prisma migrate resolve`.",
  "title": "Getting started | Prisma Documentation",
  "description": "Getting started",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate",
  "markdown": "# Understanding Prisma Migrate | Prisma Documentation\n\n[\n\n## About migration histories\n\n](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/migration-histories)",
  "title": "Understanding Prisma Migrate | Prisma Documentation",
  "description": "Learn about the mental model and basic building blocks of Prisma Migrate.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows",
  "markdown": "# Workflows | Prisma Documentation\n\n## In this section[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows#in-this-section \"Direct link to In this section\")\n\n[\n\n## Seeding\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding)\n\n[\n\n## Prototyping your schema\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema)\n\n[\n\n## Baselining a database\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/baselining)\n\n[\n\n## Customizing migrations\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations)\n\n[\n\n## Data migrations\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/data-migration)\n\n[\n\n## Squashing migrations\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations)\n\n[\n\n## Generating down migrations\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/generating-down-migrations)\n\n[\n\n## Patching & hotfixing\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing)\n\n[\n\n## Unsupported database features\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/unsupported-database-features)\n\n[\n\n## Development and production\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production)\n\n[\n\n## Team development\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/team-development)\n\n[\n\n## Native database types\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-types)\n\n[\n\n## Native database functions\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-functions)\n\n[\n\n## Troubleshooting\n\n](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting)",
  "title": "Workflows | Prisma Documentation",
  "description": "Learn about important Prisma Migrate workflows, like seeding, prototyping, baselining, & more.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/tools",
  "markdown": "# Tools | Prisma Documentation\n\n## In this section[​](https://www.prisma.io/docs/orm/tools#in-this-section \"Direct link to In this section\")\n\n[\n\n## Prisma CLI\n\n](https://www.prisma.io/docs/orm/tools/prisma-cli)\n\n[\n\n## Prisma Studio\n\n](https://www.prisma.io/docs/orm/tools/prisma-studio)",
  "title": "Tools | Prisma Documentation",
  "description": "Learn about important Prisma tools.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference",
  "markdown": "# Reference | Prisma Documentation\n\nThe reference section of the documentation is a collection of reference pages that describe the Prisma ORM APIs and database implementations.\n\n## In this section[​](https://www.prisma.io/docs/orm/reference#in-this-section \"Direct link to In this section\")\n\n[\n\n## Prisma Client API\n\n](https://www.prisma.io/docs/orm/reference/prisma-client-reference)\n\n[\n\n## Prisma Schema\n\n](https://www.prisma.io/docs/orm/reference/prisma-schema-reference)\n\n[\n\n## Prisma CLI\n\n](https://www.prisma.io/docs/orm/reference/prisma-cli-reference)\n\n[\n\n## Errors\n\n](https://www.prisma.io/docs/orm/reference/error-reference)\n\n[\n\n## Environment variables\n\n](https://www.prisma.io/docs/orm/reference/environment-variables-reference)\n\n[\n\n## Database features matrix\n\n](https://www.prisma.io/docs/orm/reference/database-features)\n\n[\n\n## Supported databases\n\n](https://www.prisma.io/docs/orm/reference/supported-databases)\n\n[\n\n## Connection URLs\n\n](https://www.prisma.io/docs/orm/reference/connection-urls)\n\n[\n\n## System requirements\n\n](https://www.prisma.io/docs/orm/reference/system-requirements)\n\n[\n\n## Preview features\n\n](https://www.prisma.io/docs/orm/reference/preview-features)",
  "title": "Reference | Prisma Documentation",
  "description": "Reference for Prisma Client API, Prisma CLI, errors & more.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference/environment-variables-reference",
  "markdown": "# Prisma environment variables | Prisma Documentation\n\n## Environment variables reference\n\nThis document describes different environment variables and their use cases.\n\n## Prisma Client[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma-client \"Direct link to Prisma Client\")\n\n### `DEBUG`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#debug \"Direct link to debug\")\n\n`DEBUG` is used to enable debugging output in Prisma Client.\n\nExample setting Prisma Client level debugging output:\n\n```\n# enable only `prisma:client`-level debugging outputexport DEBUG=\"prisma:client\"\n```\n\nSee [Debugging](https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/debugging) for more information.\n\n### `NO_COLOR`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#no_color \"Direct link to no_color\")\n\n`NO_COLOR` if [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) will activate the `colorless` setting for error formatting and strip colors from error messages.\n\nSee [Formatting via environment variables](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/error-formatting#formatting-via-environment-variables) for more information.\n\n## Prisma Studio[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma-studio \"Direct link to Prisma Studio\")\n\n### `BROWSER`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#browser \"Direct link to browser\")\n\n`BROWSER` is for Prisma Studio to force which browser it should be open in, if not set it will open in the default browser.\n\n```\nBROWSER=firefox prisma studio --port 5555\n```\n\nAlternatively you can set this when starting Studio from the CLI as well:\n\n```\nprisma studio --browser firefox\n```\n\nSee [Studio](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#studio) documentation for more information.\n\n## Prisma CLI[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma-cli \"Direct link to Prisma CLI\")\n\n### `PRISMA_HIDE_PREVIEW_FLAG_WARNINGS`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_hide_preview_flag_warnings \"Direct link to prisma_hide_preview_flag_warnings\")\n\n`PRISMA_HIDE_PREVIEW_FLAG_WARNINGS` hides the warning message that states that a preview feature flag can be removed. It is a truthy value.\n\n### `PRISMA_HIDE_UPDATE_MESSAGE`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_hide_update_message \"Direct link to prisma_hide_update_message\")\n\n`PRISMA_HIDE_UPDATE_MESSAGE` is used to hide the update notification message that is shown when a newer Prisma CLI version is available. It's a truthy value.\n\n### `PRISMA_GENERATE_SKIP_AUTOINSTALL`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_generate_skip_autoinstall \"Direct link to prisma_generate_skip_autoinstall\")\n\n`PRISMA_GENERATE_SKIP_AUTOINSTALL` can be set to a truthy value to skip the auto-install of `prisma` CLI and `@prisma/client` dependencies (if they are missing), if the `prisma-client-js` generator is defined in the Prisma Schema, when using the `prisma generate` command.\n\n### `PRISMA_SKIP_POSTINSTALL_GENERATE`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_skip_postinstall_generate \"Direct link to prisma_skip_postinstall_generate\")\n\n`PRISMA_SKIP_POSTINSTALL_GENERATE` can be set to a truthy value to skip the auto-generation of Prisma Client when its `postinstall` hook is triggered by a package manager. The `postinstall` hook of the `@prisma/client` package is triggered when the package is installed, or its version is updated.\n\n### `PRISMA_DISABLE_WARNINGS`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_disable_warnings \"Direct link to prisma_disable_warnings\")\n\nDisables all CLI warnings generated by `logger.warn`.\n\n### `PRISMA_GENERATE_NO_ENGINE`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_generate_no_engine \"Direct link to prisma_generate_no_engine\")\n\ninfo\n\nThis environment variable is available since version `5.2.0`\n\n`PRISMA_GENERATE_NO_ENGINE` can be set to a truthy value to generate a Prisma Client without an included [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines) in order to reduce deployed application size when paired with [Prisma Accelerate](https://www.prisma.io/docs/accelerate).\n\n### `PRISMA_SCHEMA_DISABLE_ADVISORY_LOCK`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_schema_disable_advisory_lock \"Direct link to prisma_schema_disable_advisory_lock\")\n\ninfo\n\nThis environment variable is available since version `5.3.0`\n\n`PRISMA_SCHEMA_DISABLE_ADVISORY_LOCK` can be set to a truthy value to disable the [advisory locking](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#advisory-locking) used by Prisma Migrate. This might be needed, depending on the database configuration, for example, for a Percona-XtraDB-Cluster or MariaDB Galera Cluster.\n\nThe Prisma CLI supports custom HTTP(S) proxies to download the Prisma engines. These can be helpful to use when working behind a corporate firewall. See [Using a HTTP proxy for the CLI](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#using-a-http-proxy-for-the-cli) for more information.\n\n### `NO_PROXY`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#no_proxy \"Direct link to no_proxy\")\n\n`NO_PROXY` is a comma-separated list of hostnames or IP addresses that do not require a proxy.\n\n```\nNO_PROXY=myhostname.com,10.11.12.0/16,172.30.0.0/16\n```\n\n### `HTTP_PROXY`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#http_proxy \"Direct link to http_proxy\")\n\n`HTTP_PROXY` is set with the hostname or IP address of a proxy server.\n\n```\nHTTP_PROXY=http://proxy.example.com\n```\n\n### `HTTPS_PROXY`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#https_proxy \"Direct link to https_proxy\")\n\n`HTTPS_PROXY` is set with the hostname or IP address of a proxy server.\n\n```\nHTTPS_PROXY=https://proxy.example.com\n```\n\n## Engine environment variables[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#engine-environment-variables \"Direct link to Engine environment variables\")\n\n### Configuring Query Engine Type[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#configuring-query-engine-type \"Direct link to Configuring Query Engine Type\")\n\n#### `PRISMA_CLI_QUERY_ENGINE_TYPE`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_cli_query_engine_type \"Direct link to prisma_cli_query_engine_type\")\n\n`PRISMA_CLI_QUERY_ENGINE_TYPE` is used to [define the query engine type Prisma CLI downloads and uses](https://www.prisma.io/docs/orm/more/under-the-hood/engines#configuring-the-query-engine). Defaults to `library`, but can be set to `binary`:\n\n```\nPRISMA_CLI_QUERY_ENGINE_TYPE=binary\n```\n\n#### `PRISMA_CLIENT_ENGINE_TYPE`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_client_engine_type \"Direct link to prisma_client_engine_type\")\n\n`PRISMA_CLIENT_ENGINE_TYPE` is used to [define the query engine type Prisma Client downloads and uses](https://www.prisma.io/docs/orm/more/under-the-hood/engines#configuring-the-query-engine). Defaults to `library`, but can be set to `binary`:\n\n```\nPRISMA_CLIENT_ENGINE_TYPE=binary\n```\n\nNote: You need to generate your Prisma Client after setting this variable for the configuration to take effect and the libraries to be downloaded. Otherwise, Prisma Client will be missing the appropriate query engine library and you will _have to_ define their location using [`PRISMA_QUERY_ENGINE_LIBRARY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_query_engine_library).\n\nIt is the environment variable equivalent for the [`engineType` property of the `generator` block](https://www.prisma.io/docs/orm/more/under-the-hood/engines#configuring-the-query-engine) which enables you to define the same setting in your Prisma Schema.\n\n### Downloading Engines[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#downloading-engines \"Direct link to Downloading Engines\")\n\n#### `PRISMA_ENGINES_MIRROR`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_engines_mirror \"Direct link to prisma_engines_mirror\")\n\n`PRISMA_ENGINES_MIRROR` can be used to specify a custom CDN (or server) endpoint to download the engines files for the CLI/Client. The default value is `https://binaries.prisma.sh`, where Prisma hosts the engine files.\n\n```\nPRISMA_ENGINES_MIRROR=https://example.org/custom-engines/\n```\n\nSee [Prisma engines](https://www.prisma.io/docs/orm/more/under-the-hood/engines#hosting-engines) for a conceptual overview of how to use this environment variable.\n\nNote: This environment variable used to be available as `PRISMA_BINARIES_MIRROR`, which was deprecated in Prisma ORM 3.0.1. It is discouraged to use anymore and will be removed in the future.\n\n#### `PRISMA_ENGINES_CHECKSUM_IGNORE_MISSING`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_engines_checksum_ignore_missing \"Direct link to prisma_engines_checksum_ignore_missing\")\n\ninfo\n\nThis environment variable is available since version `4.16.0`\n\n`PRISMA_ENGINES_CHECKSUM_IGNORE_MISSING` can be can be set to a truthy value to ignore problems around downloading & verifying the integrity (via a checksum file) of the Prisma ORM engines. This is particularly useful when deploying to an offline system environment where the checksum file cannot be downloaded.\n\n```\nPRISMA_ENGINES_CHECKSUM_IGNORE_MISSING=1\n```\n\nNote: we might change the overall download behavior in a future release in a way that this environment variable will not be needed anymore in a offline environment case.\n\n### Custom engine file locations[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#custom-engine-file-locations \"Direct link to Custom engine file locations\")\n\nBy default, all engine files are downloaded when you install Prisma CLI, copied when generating Prisma Client, and put into known locations. There are however situations where you may want to use a custom engine file from custom locations:\n\n#### `PRISMA_QUERY_ENGINE_BINARY`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_query_engine_binary \"Direct link to prisma_query_engine_binary\")\n\n`PRISMA_QUERY_ENGINE_BINARY` is used to set a custom location for your own query engine binary.\n\n```\nPRISMA_QUERY_ENGINE_BINARY=custom/query-engine-<target># Example: ./prisma/binaries/query-engine-linux-arm64-openssl-1.0.x\n```\n\nFor Prisma CLI it allows you to define the query engine file to be used.  \nFor Prisma Client, on build time (during `prisma generate`), it defines where the query engine file will be copied from into Prisma Client. At run time (when using the generated Client) it can be used to define the specific query engine file to be used instead of the included one.\n\nNote: This can only have an effect if the engine type of CLI or Client are set to `binary`. If the engine type is `library` (the default), use PRISMA\\_QUERY\\_ENGINE\\_LIBARY instead.\n\n#### `PRISMA_QUERY_ENGINE_LIBRARY`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_query_engine_library \"Direct link to prisma_query_engine_library\")\n\n`PRISMA_QUERY_ENGINE_LIBRARY` is used to set a custom location for your own query engine library.\n\n```\nPRISMA_QUERY_ENGINE_LIBRARY=custom/libquery_engine-<target>.so.node# Example: ./prisma/binaries/libquery_engine-linux-arm64-openssl-1.0.x.so.node\n```\n\nFor Prisma CLI it allows you to define the query engine file to be used.  \nFor Prisma Client, on build time (during `prisma generate`), it defines where the query engine file will be copied from into Prisma Client. At run time (when using the generated Client) it can be used to define the specific query engine file to be used instead of the included one.\n\nNote: This can only have an effect if the engine type of CLI or Client are set to `library` (the default)\n\n#### `PRISMA_SCHEMA_ENGINE_BINARY`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_schema_engine_binary \"Direct link to prisma_schema_engine_binary\")\n\n`PRISMA_SCHEMA_ENGINE_BINARY` is used to set a custom location for your Schema engine binary.\n\n```\nPRISMA_SCHEMA_ENGINE_BINARY=custom/my-schema-engine-unix\n```\n\n#### `PRISMA_MIGRATION_ENGINE_BINARY`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_migration_engine_binary \"Direct link to prisma_migration_engine_binary\")\n\nwarning\n\n**Deprecated**: `PRISMA_MIGRATION_ENGINE_BINARY` variable is deprecated in [5.0.0](https://github.com/prisma/prisma/releases/tag/5.0.0) because Migration engine was renamed to Schema Engine.\n\n`PRISMA_MIGRATION_ENGINE_BINARY` is used to set a custom location for your own migration engine binary.\n\n```\nPRISMA_MIGRATION_ENGINE_BINARY=custom/my-migration-engine-unix\n```\n\n#### `PRISMA_INTROSPECTION_ENGINE_BINARY`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_introspection_engine_binary \"Direct link to prisma_introspection_engine_binary\")\n\n`PRISMA_INTROSPECTION_ENGINE_BINARY` is used to set a custom location for your own introspection engine binary.\n\n```\nPRISMA_INTROSPECTION_ENGINE_BINARY=custom/my-introspection-engine-unix\n```\n\nwarning\n\nThe Introspection Engine is served by the Migration Engine from [4.9.0](https://github.com/prisma/prisma/releases/tag/4.9.0). Therefore, the `PRISMA_INTROSPECTION_ENGINE` environment variable will not be used.\n\n#### `PRISMA_FMT_BINARY`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_fmt_binary \"Direct link to prisma_fmt_binary\")\n\ndanger\n\nThis functionality has been removed in Prisma CLI version 4.10.0. It only works in earlier versions.\n\n`PRISMA_FMT_BINARY` is used to set a custom location for your own format engine binary.\n\n```\nPRISMA_FMT_BINARY=custom/my-custom-format-engine-unix\n```\n\nwarning\n\nThe `PRISMA_FMT_BINARY` variable is used in versions [4.2.0](https://github.com/prisma/prisma/releases/tag/4.2.0) or lower.\n\n### CLI Binary Targets[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#cli-binary-targets \"Direct link to CLI Binary Targets\")\n\n#### `PRISMA_CLI_BINARY_TARGETS`[​](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_cli_binary_targets \"Direct link to prisma_cli_binary_targets\")\n\n`PRISMA_CLI_BINARY_TARGETS` can be used to specify one or more binary targets that Prisma CLI will download during installation (so it must be provided during `npm install` of Prisma CLI and does not affect runtime of Prisma CLI or Prisma Client).\n\nUse `PRISMA_CLI_BINARY_TARGETS` if you 1) deploy to a specific platform via an upload of a local project that includes dependencies, and 2) your local environment is different from the target (e.g. AWS Lambda with Node.js 20+ is `rhel-openssl-3.0.x`, and your local environment might be macOS arm64 `darwin-arm64`). Using the `PRISMA_CLI_BINARY_TARGETS` environment variable ensures that the target engine files are also downloaded.\n\n```\nPRISMA_CLI_BINARY_TARGETS=darwin-arm64,rhel-openssl-3.0.x npm install\n```\n\nThis is the Prisma CLI equivalent for the [`binaryTargets` property of the `generator` block](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#binary-targets), which enables you to define the same setting for Prisma Client.\n\n> **Note**: For Node.js versions earlier than 20, the openssl version was 1.0.x instead of 3.0.x. This is most obvious in AWS Lambda deployments, where the binary target would be `rhel-openssl-1.0.x` instead of `rhel-openssl-3.0.x`.",
  "title": "Prisma environment variables | Prisma Documentation",
  "description": "This page gives an overview of all environment variables available for use.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference/supported-databases",
  "markdown": "# Databases supported by Prisma ORM\n\nPrisma ORM currently supports the following databases.\n\n> See also: [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements).\n\nAn asterisk (\\*) indicates that the version number is not relevant; either all versions are supported, there is not a public version number, etc.\n\n## Self-hosted databases[​](https://www.prisma.io/docs/orm/reference/supported-databases#self-hosted-databases \"Direct link to Self-hosted databases\")\n\n| Database | Version |\n| --- | --- |\n| CockroachDB | 21.2.4+ |\n| MariaDB | 10.0+ |\n| MariaDB | 11.0+ |\n| Microsoft SQL Server | 2017 |\n| Microsoft SQL Server | 2019 |\n| Microsoft SQL Server | 2022 |\n| MongoDB | 4.2+ |\n| MySQL | 5.6 |\n| MySQL | 5.7 |\n| MySQL | 8.0 |\n| PostgreSQL | 9.6 |\n| PostgreSQL | 10  |\n| PostgreSQL | 11  |\n| PostgreSQL | 12  |\n| PostgreSQL | 13  |\n| PostgreSQL | 14  |\n| PostgreSQL | 15  |\n| PostgreSQL | 16  |\n| SQLite | \\*  |\n\nNote that a fixed version of SQLite is shipped with every Prisma ORM release.\n\n## Managed databases[​](https://www.prisma.io/docs/orm/reference/supported-databases#managed-databases \"Direct link to Managed databases\")\n\n| Database | Version |\n| --- | --- |\n| AWS Aurora | \\*  |\n| AWS Aurora Serverless ¹ | \\*  |\n| Azure SQL | \\*  |\n| CockroachDB-as-a-Service | \\*  |\n| MongoDB Atlas | \\*  |\n| Neon Serverless Postgres | \\*  |\n| PlanetScale | \\*  |\n| Cloudflare D1 (Preview) | \\*  |\n\n¹ This does not include support for [Data API for Aurora Serverless](https://github.com/prisma/prisma/issues/1964).",
  "title": "Databases supported by Prisma ORM | Prisma Documentation",
  "description": "This page lists all the databases and their versions that are supported by Prisma ORM.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference/connection-urls",
  "markdown": "# Connection URLs (Reference) | Prisma Documentation\n\nPrisma ORM needs a connection URL to be able to connect to your database, e.g. when sending queries with [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) or when changing the database schema with [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\nThe connection URL is provided via the `url` field of a `datasource` block in your Prisma schema. It generally consists of the following components (except for SQLite):\n\n*   **User**: The name of your database user\n*   **Password**: The password for your database user\n*   **Host**: The IP or domain name of the machine where your database server is running\n*   **Port**: The port on which your database server is running\n*   **Database name**: The name of the database you want to use\n\nMake sure you have this information at hand when getting started with Prisma ORM. If you don't have a database server running yet, you can either use a local SQLite database file (see the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart)) or [setup a free PostgreSQL database on Supabase](https://dev.to/prisma/set-up-a-free-postgresql-database-on-supabase-to-use-with-prisma-3pk6).\n\n## Format[​](https://www.prisma.io/docs/orm/reference/connection-urls#format \"Direct link to Format\")\n\nThe format of the connection URL depends on the _database connector_ you're using. Prisma ORM generally supports the standard formats for each database. You can find out more about the connection URL of your database on the dedicated docs page:\n\n*   [PostgreSQL](https://www.prisma.io/docs/orm/overview/databases/postgresql)\n*   [MySQL](https://www.prisma.io/docs/orm/overview/databases/mysql)\n*   [SQLite](https://www.prisma.io/docs/orm/overview/databases/sqlite)\n*   [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb)\n*   [Microsoft SQL Server](https://www.prisma.io/docs/orm/overview/databases/sql-server)\n*   [CockroachDB](https://www.prisma.io/docs/orm/overview/databases/cockroachdb)\n\n### Special characters[​](https://www.prisma.io/docs/orm/reference/connection-urls#special-characters \"Direct link to Special characters\")\n\nFor MySQL, PostgreSQL and CockroachDB you must [percentage-encode special characters](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding) in any part of your connection URL - including passwords. For example, `p@$$w0rd` becomes `p%40%24%24w0rd`.\n\nFor Microsoft SQL Server, you must [escape special characters](https://www.prisma.io/docs/orm/overview/databases/sql-server#connection-details) in any part of your connection string.\n\n## Examples[​](https://www.prisma.io/docs/orm/reference/connection-urls#examples \"Direct link to Examples\")\n\nHere are examples for the connection URLs of the databases Prisma ORM supports:\n\n### PostgreSQL[​](https://www.prisma.io/docs/orm/reference/connection-urls#postgresql \"Direct link to PostgreSQL\")\n\nschema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://janedoe:mypassword@localhost:5432/mydb?schema=sample\"}\n```\n\n### MySQL[​](https://www.prisma.io/docs/orm/reference/connection-urls#mysql \"Direct link to MySQL\")\n\nschema.prisma\n\n```\ndatasource db {  provider = \"mysql\"  url      = \"mysql://janedoe:mypassword@localhost:3306/mydb\"}\n```\n\n### Microsoft SQL Server[​](https://www.prisma.io/docs/orm/reference/connection-urls#microsoft-sql-server \"Direct link to Microsoft SQL Server\")\n\nschema.prisma\n\n```\ndatasource db {  provider = \"sqlserver\"  url      = \"sqlserver://localhost:1433;initial catalog=sample;user=sa;password=mypassword;\"}\n```\n\n### SQLite[​](https://www.prisma.io/docs/orm/reference/connection-urls#sqlite \"Direct link to SQLite\")\n\nschema.prisma\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:./dev.db\"}\n```\n\n### CockroachDB[​](https://www.prisma.io/docs/orm/reference/connection-urls#cockroachdb \"Direct link to CockroachDB\")\n\nschema.prisma\n\n```\ndatasource db {  provider = \"cockroachdb\"  url      = \"postgresql://janedoe:mypassword@localhost:26257/mydb?schema=public\"}\n```\n\n### MongoDB[​](https://www.prisma.io/docs/orm/reference/connection-urls#mongodb \"Direct link to MongoDB\")\n\nschema.prisma\n\n```\ndatasource db {  provider = \"mongodb\"  url      = \"mongodb+srv://root:<password>@cluster0.ab1cd.mongodb.net/myDatabase?retryWrites=true&w=majority\"}\n```\n\n## .env[​](https://www.prisma.io/docs/orm/reference/connection-urls#env \"Direct link to .env\")\n\nYou can also provide the connection URL as an environment variable:\n\nschema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nYou can then either set the environment variable in your terminal or by providing a [dotenv](https://github.com/motdotla/dotenv) file named `.env`. This will automatically be picked up by the Prisma CLI.\n\nPrisma ORM reads the connection URL from the dotenv file in the following situations:\n\n*   When it updates the schema during build time\n*   When it connects to the database during run time\n\n```\nDATABASE_URL=postgresql://janedoe:mypassword@localhost:5432/mydb\n```",
  "title": "Connection URLs (Reference) | Prisma Documentation",
  "description": "Learn about the format and syntax Prisma ORM uses for defining database connection URLs for PostgreSQL, MySQL and SQLite.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference/system-requirements",
  "markdown": "# System requirements (Reference) | Prisma Documentation\n\nThis page provides an overview of the system requirements for Prisma ORM.\n\n## System requirements[​](https://www.prisma.io/docs/orm/reference/system-requirements#system-requirements \"Direct link to System requirements\")\n\nThis section lists the software that Prisma ORM requires and the supported operating systems, along with runtime dependency requirements for specific operating systems.\n\n### Software requirements[​](https://www.prisma.io/docs/orm/reference/system-requirements#software-requirements \"Direct link to Software requirements\")\n\nThe latest version of Prisma ORM requires the following software:\n\n|     | Minimum required version |\n| --- | --- |\n| Node.js | 16.13 / 18.X / 20.X |\n| TypeScript (optional) | 4.7.X |\n| Yarn (optional) | 1.19.2 |\n\nNotes:\n\n*   Prisma ORM supports and tests all _Active LTS_ and _Maintenance LTS_ **Node.js** releases. [Releases that are not in these states like _Current_, and also odd-numbered versions](https://nodejs.org/en/about/releases/) probably also work, but are not recommended for production use.\n*   **TypeScript** is only required for TypeScript users.\n*   When using **Yarn 1**, `1.19.2` is the minimum version compatible with Prisma Client.\n\nSee also: [Supported database versions](https://www.prisma.io/docs/orm/reference/supported-databases)\n\n### Operating systems[​](https://www.prisma.io/docs/orm/reference/system-requirements#operating-systems \"Direct link to Operating systems\")\n\nPrisma ORM is supported on MacOS, Windows and most Linux distributions.\n\n#### Linux runtime dependencies[​](https://www.prisma.io/docs/orm/reference/system-requirements#linux-runtime-dependencies \"Direct link to Linux runtime dependencies\")\n\nPrisma ORM requires the following system libraries to be installed to work:\n\n*   OpenSSL 1.0.x, 1.1.x or 3.x\n*   zlib (`libz.so.1`)\n*   libgcc (`libgcc_s.so.1`)\n*   C standard library (glibc on most Linux distributions or musl libc on Alpine Linux)\n\nThe following two tables show the supported Linux distro families, OpenSSL versions and C standard libraries for each CPU architecture.\n\nOn `AMD64` (`x86_64`) architecture:\n\n| Distro family | OpenSSL version | libc version |\n| --- | --- | --- |\n| Alpine | 1.1.x, 3.x | musl 1.2.x |\n| RHEL | 1.0.x, 1.1.x, 3.x | glibc 2.17+ |\n| Debian or others | 1.0.x | glibc 2.19+ |\n| Debian or others | 1.1.x, 3.x | glibc 2.24+ |\n\nOn `ARM64` (`aarch64`) architecture:\n\n| Distro family | OpenSSL version | libc version |\n| --- | --- | --- |\n| Alpine | 1.1.x, 3.x | musl 1.2.x |\n| RHEL | 1.0.x, 1.1.x, 3.x | glibc 2.24+ |\n| Debian or others | 1.0.x, 1.1.x, 3.x | glibc 2.24+ |\n\nWhen Prisma ORM can not resolve the OpenSSL version on a system (e.g. because it is not installed), it will default to OpenSSL 1.1.x.\n\nSystems that can run the supported Node.js versions will most likely have zlib and libgcc available. One notable exception is Google's Distroless images, where `libz.so.1` needs to be copied from a compatible Debian system.\n\n#### Windows runtime dependencies[​](https://www.prisma.io/docs/orm/reference/system-requirements#windows-runtime-dependencies \"Direct link to Windows runtime dependencies\")\n\nOn Windows [Microsoft Visual C++ Redistributable 2015](https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x64.exe) or newer must be installed (which is by default the case on most modern installations).\n\n#### macOS runtime dependencies[​](https://www.prisma.io/docs/orm/reference/system-requirements#macos-runtime-dependencies \"Direct link to macOS runtime dependencies\")\n\nPrisma ORM supports macOS 10.15 or newer. There are no additional platform-specific requirements on macOS other than what is listed for all platforms in the [Software requirements](https://www.prisma.io/docs/orm/reference/system-requirements#software-requirements) section.\n\n## Troubleshooting[​](https://www.prisma.io/docs/orm/reference/system-requirements#troubleshooting \"Direct link to Troubleshooting\")\n\nThere are some common problems caused by using outdated versions of the system requirements:\n\n### Unable to build a TypeScript project with `@prisma/client`[​](https://www.prisma.io/docs/orm/reference/system-requirements#unable-to-build-a-typescript-project-with-prismaclient \"Direct link to unable-to-build-a-typescript-project-with-prismaclient\")\n\n#### Problem[​](https://www.prisma.io/docs/orm/reference/system-requirements#problem \"Direct link to Problem\")\n\nYou see the following error when you try type-checking a project after you run `prisma generate`.\n\n```\n./node_modules/.prisma/client/index.d.ts:10:33Type error: Type expected.   8 | export type PrismaPromise<A> = Promise<A> & {[prisma]: true}   9 | type UnwrapTuple<Tuple extends readonly unknown[]> = {> 10 |   [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : never : never     |                                 ^  11 | };  12 |  13 |\n```\n\n#### Solution[​](https://www.prisma.io/docs/orm/reference/system-requirements#solution \"Direct link to Solution\")\n\nUpgrade the TypeScript dependency in your project to a [version supported by Prisma ORM](https://www.prisma.io/docs/orm/reference/system-requirements#software-requirements). `npm install -D typescript`.\n\n### Unable to use `groupBy` preview feature[​](https://www.prisma.io/docs/orm/reference/system-requirements#unable-to-use-groupby-preview-feature \"Direct link to unable-to-use-groupby-preview-feature\")\n\n#### Problem[​](https://www.prisma.io/docs/orm/reference/system-requirements#problem-1 \"Direct link to Problem\")\n\nYou see the following console error when you attempt to run an app that uses the `groupBy` preview feature:\n\n```\nserver.ts:6:25 - error TS2615: Type of property 'OR' circularly references itself in mapped type '{ [K in keyof { AND?: Enumerable<ProductScalarWhereWithAggregatesInput>; OR?: Enumerable<ProductScalarWhereWithAggregatesInput>; ... 4 more ...; category?: string | StringWithAggregatesFilter; }]: Or<...> extends 1 ? { ...; }[K] extends infer TK ? GetHavingFields<...> : never : {} extends FieldPaths<...> ? never : K...'.6   const grouped = await prisma.product.groupBy({                          ~~~~~~~~~~~~~~~~~~~~~~~~7     by: ['category']  ~~~~~~~~~~~~~~~~~~~~8   });  ~~~~server.ts:6:48 - error TS2554: Expected 0 arguments, but got 1.6   const grouped = await prisma.product.groupBy({                                                 ~7     by: ['category']  ~~~~~~~~~~~~~~~~~~~~8   });  ~~~\n```\n\n#### Solution[​](https://www.prisma.io/docs/orm/reference/system-requirements#solution-1 \"Direct link to Solution\")\n\nUpgrade the TypeScript dependency in your project to a [version supported by Prisma ORM](https://www.prisma.io/docs/orm/reference/system-requirements#software-requirements). `npm install -D typescript`.",
  "title": "System requirements (Reference) | Prisma Documentation",
  "description": "System requirements for running Prisma ORM",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse/database-setup/general-database-instructions",
  "markdown": "# Prisma Pulse: General instructions | Prisma Documentation\n\ninfo\n\nPrisma Pulse requires a publicly accessible PostgreSQL (**version 12+**) database with logical replication enabled. To configure specific database providers for Prisma Pulse, visit [here](https://www.prisma.io/docs/pulse/database-setup#provider-specific-instructions).\n\nDatabase replication is the process of creating copies of a database and storing them across various on-premises or cloud destinations. Prisma Pulse uses logical replication to monitor your database for changes.\n\n## Enable logical replication[​](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#enable-logical-replication \"Direct link to Enable logical replication\")\n\n### Required settings[​](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#required-settings \"Direct link to Required settings\")\n\nYou can enable logical replication by setting [`wal_level`](https://www.postgresql.org/docs/current/runtime-config-wal.html) to `logical` in your database.\n\n```\nALTER SYSTEM SET wal_level = logical;\n```\n\nYou will need to restart the database after changing this setting.\n\n> **Note**: Some providers may not allow direct access to this setting. If you are unable to change this setting via the SQL command above, please refer to the provider-specific guides for further assistance.\n\n### Optional settings[​](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#optional-settings \"Direct link to Optional settings\")\n\n#### [`wal_keep_size`](https://www.postgresql.org/docs/current/runtime-config-replication.html)[​](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#wal_keep_size \"Direct link to wal_keep_size\")\n\nSetting `wal_keep_size` increases the memory usage of the [write-ahead log](https://www.postgresql.org/docs/current/wal-intro.html) on your PostgreSQL database.\n\nWe recommend setting a value for `wal_keep_size` tailored to your database's storage capacity. This ensures smooth operation of both your database and Prisma Pulse.\n\n```\nALTER SYSTEM SET wal_keep_size = 2048;\n```\n\n#### [`max_replication_slots`](https://www.postgresql.org/docs/current/runtime-config-replication.html)[​](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#max_replication_slots \"Direct link to max_replication_slots\")\n\nPrisma Pulse only needs one replication slot available. You can set the `max_replication_slots` if you have other replications in use.\n\n```\nALTER SYSTEM SET max_replication_slots = 20;\n```\n\n#### [`REPLICA IDENTITY`](https://www.postgresql.org/docs/current/sql-altertable.html#SQL-ALTERTABLE-REPLICA-IDENTITY)[​](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#replica-identity \"Direct link to replica-identity\")\n\nFor update and delete events, you have the option to include in the event the values of the record _before_ the operation was performed:\n\n*   For `update`: Include the values of the updated record before the update was performed in a field called `before`\n*   For `delete`: Include the values of the deleted record.\n\nIf you enable this, you will also be able to filter on these fields.\n\nTo include this data, you must set `REPLICA IDENTITY` to `FULL` on the table(s) you want to get field values for.\n\nFor example, running the following SQL command will set the `REPLICA IDENTITY` to `FULL` on a table named `User`:\n\n```\nALTER TABLE public.\"User\" REPLICA IDENTITY FULL;\n```\n\n## Manage your own publication slot[​](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#manage-your-own-publication-slot \"Direct link to Manage your own publication slot\")\n\nIf you want to enable replication for _specific models_ or use a database provider that restricts superuser access for Prisma Pulse you can configure your own publication slot and use it to enable Pulse.\n\n### Creating a publication slot[​](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#creating-a-publication-slot \"Direct link to Creating a publication slot\")\n\nYou can create publications in the following ways below depending on the version of your PostgreSQL database.\n\nPublication for all models.\n\n  \n\n```\nCREATE PUBLICATION all_models FOR ALL TABLES;\n```\n\nPublication for specific fields.\n\nFor example, create a publication that publishes all changes for table `users`, but replicates only columns `user_id` and `firstname`:\n\n```\n   CREATE PUBLICATION users_filtered FOR TABLE users (user_id, firstname);\n```\n\nPublication for specific models.\n\nFor example, create a publication that publishes all changes in two tables:\n\n```\nCREATE PUBLICATION user_and_department_publication FOR TABLE users, departments;\n```\n\nPublication for a model with a `WHERE` clause on it’s fields.\n\nFor example, create a publication that publishes all changes from active `departments`:\n\n```\nCREATE PUBLICATION active_departments FOR TABLE departments WHERE (active IS TRUE);\n```\n\nPublication based on DML operations.\n\nFor example, create a publication that only publishes `INSERT` operations in one table:\n\n```\nCREATE PUBLICATION insert_only FOR TABLE departmentsWITH (publish = 'insert');\n```\n\n> `publish` (`string`)\n> \n> This parameter determines which DML operations will be published by the new publication to the subscribers. The value is comma-separated list of operations. The allowed operations are `insert`, `update`, `delete`, and `truncate`. The default is to publish all actions, and so the default value for this option is `'insert, update, delete, truncate'`.\n\nYou can learn more about the PostgreSQL's `CREATE PUBLICATION`, supported versions and see more examples [here](https://www.postgresql.org/docs/current/sql-createpublication.html).\n\n### Submit your publication slot[​](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#submit-your-publication-slot \"Direct link to Submit your publication slot\")\n\nYou can submit the publication name in the [Console](https://console.prisma.io/), before enabling Prisma Pulse:\n\n1.  To view your [publications](https://www.postgresql.org/docs/current/view-pg-publication-tables.html), execute:\n    \n    ```\n    SELECT * FROM pg_publication_tables;\n    ```\n    \n2.  Then you can submit the desired publication name in the Console:\n    \n    ![](https://www.prisma.io/docs/assets/images/replication-slot-submission-d9aff33c6d4319db93577f289d654210.png)\n    \n\n### Removing publications[​](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#removing-publications \"Direct link to Removing publications\")\n\nIf you are managing your replications independently and choose to disable Prisma Pulse for a particular environment, you can refer to the following SQL queries to remove your publications.\n\n1.  To delete a publication:\n    \n    ```\n    DROP PUBLICATION IF EXISTS \"my_publication\";\n    ```\n    \n2.  View your [publications](https://www.postgresql.org/docs/current/view-pg-publication-tables.html):\n    \n    ```\n    SELECT * FROM pg_publication_tables;\n    ```\n    \n\n## Provider-specific instructions[​](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#provider-specific-instructions \"Direct link to Provider-specific instructions\")\n\nIf you want to see the specific instructions for your database, select your database provider:\n\n*   [AWS RDS](https://www.prisma.io/docs/pulse/database-setup/aws-rds)\n*   [Railway](https://www.prisma.io/docs/pulse/database-setup/railway)\n*   [Neon](https://www.prisma.io/docs/pulse/database-setup/neon)\n*   [Supabase](https://www.prisma.io/docs/pulse/database-setup/supabase)",
  "title": "Prisma Pulse: General instructions | Prisma Documentation",
  "description": "Instructions to use your database with Prisma Pulse",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference/preview-features",
  "markdown": "# Preview features (Reference) | Prisma Documentation\n\nSome Prisma ORM features are released as [Previews](https://www.prisma.io/docs/orm/more/releases#preview). [Share your feedback on all Preview features on GitHub](https://github.com/prisma/prisma/issues/3108). For information about available preview features and how to enable them, see:\n\n*   [Prisma Client and Prisma schema preview features](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features)\n*   [Prisma CLI preview features](https://www.prisma.io/docs/orm/reference/preview-features/cli-preview-features)\n\nFor information regarding upgrading Prisma ORM and enabling Preview features see [Upgrading to use Preview features](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-to-use-preview-features).",
  "title": "Preview features (Reference) | Prisma Documentation",
  "description": "Previews are typically available behind a feature flag or require some form of opt-in.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse/database-setup/aws-rds",
  "markdown": "# Prisma Pulse: AWS RDS | Prisma Documentation\n\nYou have to enable logical replication on AWS RDS to make it compatible with Prisma Pulse.\n\n## Enable logical replication on AWS RDS[​](https://www.prisma.io/docs/pulse/database-setup/aws-rds#enable-logical-replication-on-aws-rds \"Direct link to Enable logical replication on AWS RDS\")\n\nThe following instructions show how to create a parameter group, enable logical replication, and add the parameter group to your AWS RDS PostgreSQL database.\n\n1.  Create a parameter group for your RDS database (`RDS` > `Parameter groups` > `Create a parameter group`). In the **Parameter group family**, select your Postgres version. Select the type **DB Parameter group** option and assign a descriptive group name and description:\n    \n    ![Create a parameter group in AWS RDS](https://www.prisma.io/docs/assets/images/aws-rds-create-parameter-group-547be646ecdc4627ac0631103c38003d.png)\n    \n2.  Set the `rds.logical_replication` parameter to `1`(`true`) in the parameter group.\n    \n    ![Set logical replication parameter group](https://www.prisma.io/docs/assets/images/set-logical-replication-parameter-88329e63e06b185328187e93c1fabbb0.png)\n    \n3.  Modify **Database options** (`RDS` > `Databases` > `Modify`) to use the new DB parameter group:\n    \n    ![Add Parameter group to AWS RDS](https://www.prisma.io/docs/assets/images/add-group-44db12f6ed626c7df56b44549d37c54c.png)\n    \n    To reflect the configuration change into `wal_level`, select the **Apply immediately** option.\n    \n4.  Go to `RDS` > `Databases` > `[database name]`, then click on **Actions**, and then click on **Reboot** to restart your database.",
  "title": "Prisma Pulse: AWS RDS | Prisma Documentation",
  "description": "Instructions to use AWS RDS with Prisma Pulse",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse/database-setup/railway",
  "markdown": "# Prisma Pulse: Railway | Prisma Documentation\n\nRailway provides a useful feature known as [templates](https://railway.app/templates) to facilitate quick project setup. These templates allow users to package a service or a group of services into a format that can be easily reused and shared. We have two templates for Prisma Pulse that you can use:\n\n*   [Prisma Pulse DB Only](https://railway.app/template/pulse-pg): Provides a fresh, pre-configured PostgreSQL database which you can use with Prisma Pulse.\n*   [Prisma Pulse DB & App](https://railway.app/template/pulse-starter): Provides a pre-configured PostgreSQL database and a [Prisma Pulse starter app](https://github.com/prisma/prisma-examples/tree/latest/pulse/starter).\n\n## Setup with template: \"Prisma Pulse DB Only\"[​](https://www.prisma.io/docs/pulse/database-setup/railway#setup-with-template-prisma-pulse-db-only \"Direct link to Setup with template: \"Prisma Pulse DB Only\"\")\n\n### Overview[​](https://www.prisma.io/docs/pulse/database-setup/railway#overview \"Direct link to Overview\")\n\nThis section provides step-by-step instructions for setting up a Pulse-ready PostgreSQL database using the Railway template called: [Prisma Pulse DB Only](https://railway.app/template/pulse-pg).\n\nThe template consists of two [services](https://docs.railway.app/reference/services):\n\n*   **Postgres**: A PostgreSQL database that you'll be able to use with Prisma Pulse after going through the setup instructions.\n*   **restart-and-delete-me**: This service contains a [script](https://github.com/prisma/pulse-railway-pg-config/blob/main/config-db.ts) that's executed once and configures the PostgreSQL database to make it usable with Prisma Pulse. Once the script has been executed, the instructions will tell you to delete this service since it won't be needed any more.\n\n### Instructions[​](https://www.prisma.io/docs/pulse/database-setup/railway#instructions \"Direct link to Instructions\")\n\n1.  Deploy the [template](https://railway.app/template/pulse-pg) on Railway.\n2.  Once the deployment has finished, click on the service called **restart-db-then-delete-me**.\n3.  You will see a list of deployments under the **Deployments** tab.\n4.  Click the most recent deployment's **View Logs** button.\n5.  Click on the **Deploy Logs** tab. If the service ran correctly, you should see a message in the logs that says:\n    \n    ```\n    All done please restart the database and delete this service.Here is the DATABASE_URLpostgresql://postgres:password@roundhouse.proxy.rlwy.net:28606/railway\n    ```\n    \n    > **Note**: The `DATABASE_URL` can also be found by clicking on the **Postgres** Service and navigating to the **Variables** tab, then clicking the copy icon next to `DATABASE_URL` environment variable value. ![](https://www.prisma.io/docs/assets/images/railway-database-url-a392cdd6beffd089a9021a57e4572dba.png)\n    \n6.  Copy the `DATABASE_URL` connection string and save it for later. Then restart your Railway database for the changes to be reflected:\n    1.  Click on the **Postgres** service that represents your deployed database.\n    2.  Navigate to the **Deployments** tab.\n    3.  Click on the three-dots menu on the latest deployment and click the **Restart** option.\n7.  After restarting your database, click on the **restart-db-then-delete-me** service and navigate to the **Settings** tab.\n8.  Scroll down to the bottom and click the red **Delete service** button.\n9.  You now have a Pulse-compatible PostgreSQL database running on Railway. You can now follow the instructions on the [Getting started](https://www.prisma.io/docs/pulse/getting-started) page.\n\n## Setup with template: \"Prisma Pulse DB & App\"[​](https://www.prisma.io/docs/pulse/database-setup/railway#setup-with-template-prisma-pulse-db--app \"Direct link to Setup with template: \"Prisma Pulse DB & App\"\")\n\n### Overview[​](https://www.prisma.io/docs/pulse/database-setup/railway#overview-1 \"Direct link to Overview\")\n\nThis section provides step-by-step instructions for setting up a Pulse starter project with a Pulse-ready PostgreSQL database using the Railway template called: [Prisma Pulse DB & App](https://railway.app/template/pulse-starter). The template consists of three [services](https://docs.railway.app/reference/services):\n\n*   **Pulse-Starter**: A Typescript app with a basic setup for using Prisma Pulse. You can find the repo for it [on GitHub](https://github.com/prisma/prisma-examples/tree/latest/pulse/starter).\n*   **Postgres**: A PostgreSQL database that you'll be able to use with Prisma Pulse after going through the setup instructions.\n*   **restart-and-delete-me**: This service contains a [script](https://github.com/prisma/pulse-railway-pg-config/blob/main/config-db.ts) that's executed once and configures the PostgreSQL database to make it usable with Prisma Pulse. Once the script has been executed, the instructions will tell you to delete this service since it won't be needed any more.\n\n### Instructions[​](https://www.prisma.io/docs/pulse/database-setup/railway#instructions-1 \"Direct link to Instructions\")\n\n1.  Deploy the [template](https://railway.app/template/pulse-starter) on Railway.\n2.  You'll be navigated to a page prompting configuration for both the **restart-db-then-delete-me** and **pulse-starter** service: ![Configure Railway template](https://www.prisma.io/docs/assets/images/railway-template-configure-87cae2f7d3e286d243cd1caaf6bfd1a2.png)\n    1.  For the **restart-db-then-delete-me** service, click on the **Configure** button and then save the configuration by clicking on **Save Config**.\n    2.  On the **pulse-starter** service, locate and click the **Configure** button. Within the **Environment variables** section, you'll find an option to include the `PULSE_API_KEY` environment variable. Keep the `PULSE_API_KEY` field blank for the time being. Once you've set up the database and obtained the database URL from the [Prisma Data Platform](https://console.prisma.io/), you can then add the `PULSE_API_KEY` to the **pulse-starter** service. With the empty field for the Pulse API key, click **Save Config**.\n    3.  Click on the **Deploy** button.\n3.  To set up the database and make it Pulse-ready, complete the steps outlined in the [previous section](https://www.prisma.io/docs/pulse/database-setup/railway#setup-with-template-prisma-pulse-db-only), starting from **step 2.** till **step 8.**, then follow the instructions below.\n4.  Go to the [Console](https://console.prisma.io/) and select the project in which you want to activate Pulse. If you don't have a project yet, create a new project via the **New project** button.\n5.  Navigate to the project's environment in which Pulse should be activated. If you just created a new project, the only available environment is the **Production** environment.\n6.  Click **Enable Pulse** on the environment's page.\n7.  Paste the `DATABASE_URL` that you acquired before into the **Database connection string** field. Then, finish the process by clicking **Enable Pulse**.\n8.  Pulse is now enabled in your project's environment. Click **Generate API key** to obtain the API key that you need in order to use Pulse in your TypeScript starter app.\n9.  Save the `PULSE_API_KEY` for later and click **I've securely stored my connection string**.\n10.  Back in the Railway UI, click on the **pulse-starter** service.\n    \n    > **Note**: You'll likely find that the build failed for the **pulse-starter** service. This is because the Prisma Pulse API key wasn't provided. Do not worry, this is to be expected and not a problem for the next steps.\n    \n11.  Click on the **Variables** tab.\n12.  Create your `PULSE_API_KEY` environment variable: Click the **New Variable** button, create the `PULSE_API_KEY` environment variable, and then paste the value of the `PULSE_API_KEY` that you obtained in the Console. Then save the changes by clicking the **Add** button.\n13.  With the `PULSE_API_KEY` environment variable in place, you need to rebuild the **pulse-starter** service for the environment variable to take effect:\n14.  Click on the **Deployments** tab.\n15.  Click on the three-dots menu on the deployment that failed. Then click **Redeploy**.\n16.  When the deployment starts, click the **View Logs** button.\n17.  Then click on the **Deploy Logs** tab to follow the deployment of the Pulse starter app.\n\nOnce the deployment is finished, your Pulse starter app should be running and any database events events will be logged under the **Deploy Logs** tab of the **pulse-starter** service.\n\nTo see an event in action, you need to make changes to the `User` table. You can follow the steps below to do that from the Railway UI:\n\n1.  Click on the **Postgres** service on your Railway project.\n2.  Click on the **Data** tab.\n3.  Select the **User** table and click **Add Row**.\n4.  Fill out an **email** and a **name**, then click **Insert**.\n5.  Return to the **Deploy Logs** of your **pulse-starter** service.\n6.  You should be able to see an output from Prisma Pulse for the user being created:\n    \n    ```\n    just received an event: {  action: \"create\",  created: { id: 1, email: \"test\", name: \"test@test.io\" },  id: 03/34334,  modelName: \"User\"}\n    ```\n    \n\n## Setup without using a template[​](https://www.prisma.io/docs/pulse/database-setup/railway#setup-without-using-a-template \"Direct link to Setup without using a template\")\n\n1.  Change the PostgreSQL database settings\n    \n    You can run these queries using a tool such as [pgAdmin](https://www.pgadmin.org/), [dbeaver](https://dbeaver.io/), or any other way you might run queries on your database.\n    \n    *   Set the [`wal_level`](https://www.postgresql.org/docs/current/runtime-config-wal.html) to `logical`:\n        \n        ```\n        ALTER SYSTEM SET wal_level = logical;\n        ```\n        \n    *   Set the [`max_replication_slots`](https://www.postgresql.org/docs/current/runtime-config-replication.html) to `20`:\n        \n        ```\n        ALTER SYSTEM SET max_replication_slots = 20;\n        ```\n        \n    *   Set the [`wal_keep_size`](https://www.postgresql.org/docs/current/runtime-config-replication.html) to `2048`:\n        \n        ```\n        ALTER SYSTEM SET wal_keep_size = 2048;\n        ```\n        \n    *   Reload the PostgreSQL configuration:\n2.  You have to restart your database for the changes to be reflected. To restart your database using the Railway UI:\n    \n    1.  Click on your database.\n    2.  Navigate to the **Deployments** tab.\n    3.  Click on the three-dots menu on the latest deployment and click the **Restart** option.\n3.  After setting up your Railway database, you have to use the [connection string](https://docs.railway.app/guides/postgresql#tcp-proxy-connection) provided by Railway that allows public access to your PostgreSQL database.\n    \n4.  You now have a Pulse-compatible PostgreSQL database running on Railway. You can now follow the instructions on the [Getting started](https://www.prisma.io/docs/pulse/getting-started) page.",
  "title": "Prisma Pulse: Railway | Prisma Documentation",
  "description": "Instructions to use Railway with Prisma Pulse",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse/database-setup/neon",
  "markdown": "# Prisma Pulse: Neon | Prisma Documentation\n\nCreate a publication to listen to database events from your Neon database. Use the **SQL Editor** in your Neon project to execute the SQL query to create a publication to listen to database change events from all tables:\n\n```\nCREATE Publication $PUBLICATION_NAME FOR ALL TABLES;\n```",
  "title": "Prisma Pulse: Neon | Prisma Documentation",
  "description": "Instructions to use Neon for PostgreSQL with Prisma Pulse",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse/database-setup/supabase",
  "markdown": "# Prisma Pulse: Supabase | Prisma Documentation\n\nYou have to use a direct database connection from Supabase to use it with Prisma Pulse.\n\n## Using a direct connection in Supabase[​](https://www.prisma.io/docs/pulse/database-setup/supabase#using-a-direct-connection-in-supabase \"Direct link to Using a direct connection in Supabase\")\n\nTo use a direct database connection string in Supabase:\n\n1.  Navigate to your Project settings (**Settings** > **Configurations** > **Database**).\n    \n2.  Disable the **Use connection pooling** option. ![Supabase direct database connection](https://www.prisma.io/docs/assets/images/supabase-direct-database-connection-845d6828f6ceaf50bcd67ae2b2111ceb.png)\n    \n3.  Copy the direct database connection string.\n    \n    info\n    \n    ℹ️ Prisma Pulse is currently incompatible with Supabase's connection pooler. This results from the connection pooler intercepting the connection between your database and Prisma Pulse and removing the [Streaming Replication Protocol](https://www.postgresql.org/docs/current/protocol-replication.html#PROTOCOL-REPLICATION) which is used by Prisma Pulse to transmit replication commands to the database.",
  "title": "Prisma Pulse: Supabase | Prisma Documentation",
  "description": "Instructions to use Supabase with Prisma Pulse",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse/known-limitations",
  "markdown": "# Pulse: Known limitations | Prisma Documentation\n\nBelow are descriptions of known limitations when using Prisma Pulse. If you are aware of any limitations that are missing, please let us know on the `#help-and-questions` channel in our community [Discord](https://pris.ly/discord).\n\n## Superuser role required for starter plan[​](https://www.prisma.io/docs/pulse/known-limitations#superuser-role-required-for-starter-plan \"Direct link to Superuser role required for starter plan\")\n\nOur [Starter plan](https://www.prisma.io/pricing) requires a database role with superuser access.\n\n## Prisma Pulse is server-side[​](https://www.prisma.io/docs/pulse/known-limitations#prisma-pulse-is-server-side \"Direct link to Prisma Pulse is server-side\")\n\nPrisma Pulse streams cannot be initiated directly within client-side code. To receive events in real-time, Prisma Client needs to open a stream on a long-running server.\n\nTo propagate events to the frontend, you can use a WebSocket library like [socket.io](https://socket.io/).\n\n## Limited to Postgres versions 12 or higher[​](https://www.prisma.io/docs/pulse/known-limitations#limited-to-postgres-versions-12-or-higher \"Direct link to Limited to Postgres versions 12 or higher\")\n\nPrisma Pulse is currently supported with Postgres versions 12 or higher. It should work with most Postgres providers that expose Postgres’ native logical replication feature.\n\n## Subscription type limitation with custom publication slots[​](https://www.prisma.io/docs/pulse/known-limitations#subscription-type-limitation-with-custom-publication-slots \"Direct link to Subscription type limitation with custom publication slots\")\n\nThe onboarding flow in the Console enables you to provide a [custom publication slot](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#manage-your-own-publication-slot). Should that custom publication slot only contain a subset of your database tables, the Prisma Client instance generated with the Pulse extension will continue to permit streams to all models based on the entirety of your Prisma Schema definitions.\n\nFor example, if you have two models in your schema, the `User` and `Post` model. And you opt to create a publication to monitor changes in the `User` model exclusively:\n\n```\nCREATE PUBLICATION user_publication FOR TABLE users;\n```\n\n> To learn more about creating custom publication slots, see [managing your publication slot](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#manage-your-own-publication-slot).\n\nYour resulting code would be:\n\n```\nconst userStream = prisma.user.stream()\n```\n\nHowever, despite the absence of publication coverage, the generated Prisma Client permits streams for all models, such as the `Post` model:\n\n```\nconst postStream = prisma.post.stream()\n```\n\n> We are actively working on enhancing type generation for custom publications as part of our ongoing efforts to further refine Prisma Pulse.\n\n## Size limit for database events[​](https://www.prisma.io/docs/pulse/known-limitations#size-limit-for-database-events \"Direct link to Size limit for database events\")\n\nThe size limit of [database events](https://www.prisma.io/docs/pulse/database-events) depends on your [subscription plan](https://www.prisma.io/pricing).\n\nNote that database events are base64 encoded for transmission. The size limit applies to the _encoded_ not the _original_ size of the event.\n\nIf your events exceed the size limit, they will be rejected by Prisma Pulse and won't arrive on the receiver side. You can see how many events have been rejected by Prisma Pulse in the Pulse Dashboard in the [Console](https://console.prisma.io/).",
  "title": "Pulse: Known limitations | Prisma Documentation",
  "description": "Learn about known limitations of Pulse.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse/database-events",
  "markdown": "# Database events with Prisma Pulse\n\n## Structure[​](https://www.prisma.io/docs/pulse/database-events#structure \"Direct link to Structure\")\n\nThe structure of a database change event depends on the model and the kind of operation that was performed. You can learn more in the [API reference](https://www.prisma.io/docs/pulse/api-reference).\n\nThe examples below are based on this `User` model:\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  name  String?  email String  @unique}\n```\n\nAll events have the following fields in common:\n\n*   `id`: Unique identifier\n*   `modelName`: The model on which this was performed, e.g. `User` or `Post`\n*   `action`: The kind of event that was performed, either of the following: `create`, `update`, `delete`\n\nDepending on the kind of event, there may be additional fields in the event objects received via Prisma Pulse. See the following sections for a few sample events.\n\n### Create events[​](https://www.prisma.io/docs/pulse/database-events#create-events \"Direct link to Create events\")\n\nHere is an example of an event object you may receive when a new record is _created_:\n\n```\n{  action: 'create',  created: { id: 3, email: 'jane@prisma.io', name: 'Jane Doe' },  id: '0/2A5A590',  modelName: 'User'}\n```\n\n### Update events[​](https://www.prisma.io/docs/pulse/database-events#update-events \"Direct link to Update events\")\n\nHere is an example of an event object you may receive when a record is _updated_:\n\n```\n{  action: 'update',  after: { id: 2, email: 'jane@prisma.io', name: 'Jane Doe' },  before: null,  id: '0/2A5A248',  modelName: 'User'}\n```\n\nIf you want the `before` field to carry the values of the record _before_ it was updated, you need to set `REPLICA IDENTITY` to `FULL` as explained [here](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#replica-identity). In that case, the event object may look as follows:\n\n```\n{  action: 'update',  after: { id: 2, email: 'jane@prisma.io', name: 'Jane Doe' },  before: { id: 2, email: 'jane@prisma.io', name: 'Jane' },  id: '0/2A5A248',  modelName: 'User'}\n```\n\n### Delete events[​](https://www.prisma.io/docs/pulse/database-events#delete-events \"Direct link to Delete events\")\n\nHere is an example of an event object you may receive when a record is _deleted_:\n\n```\n {  action: 'delete',  deleted: { id: 1 },  id: '0/2A5A398',  modelName: 'User'}\n```\n\nIf you want the `deleted` field to carry the values of the record that was deleted, you need to set `REPLICA IDENTITY` to `FULL` as explained [here](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#replica-identity). Otherwise it will only carry the `id` value of the record. In that case, the event object may look as follows:\n\n```\n {  action: 'delete',  deleted: { id: 21, email: 'jane@prisma.io', name: 'Jane Doe' },  id: '0/2A5A398',  modelName: 'User'}\n```\n\n## Delivery semantics[​](https://www.prisma.io/docs/pulse/database-events#delivery-semantics \"Direct link to Delivery semantics\")\n\nThis section gives an overview of the event delivery semantics of Prisma Pulse.\n\n### What are event delivery semantics?[​](https://www.prisma.io/docs/pulse/database-events#what-are-event-delivery-semantics \"Direct link to What are event delivery semantics?\")\n\nEvent delivery semantics describe the _guarantees_ an event producer can provide about the delivery of events in an event-driven architecture.\n\nThere generally are three kinds of delivery guarantees:\n\n*   **At most once**: The event is delivered either once or not at all.\n*   **At least once**: The event is delivered one or more times, ensuring it never goes undelivered.\n*   **Exactly once**: The event is delivered exactly once, avoiding duplicates.\n\n### Event delivery semantics in Prisma Pulse[​](https://www.prisma.io/docs/pulse/database-events#event-delivery-semantics-in-prisma-pulse \"Direct link to Event delivery semantics in Prisma Pulse\")\n\nHere is a summary of the event delivery semantics in Prisma Pulse:\n\n|     | `stream()` | `subscribe()` |\n| --- | --- | --- |\n| **Requires event persistence** | Yes | No  |\n| **Delivery guarantees** | At least once | At most once |\n| **Event order** | Same order as events were produced | Maybe different order than events were produced |\n| **Can \"replay\" missed events** | Yes | No  |\n\nwarning\n\nNote that if an events exceeds the [size limit](https://www.prisma.io/docs/pulse/known-limitations#size-limit-for-database-events) for your [subscription plan](https://www.prisma.io/pricing), the event will be rejected and won't make it to your application..\n\n#### `stream()`[​](https://www.prisma.io/docs/pulse/database-events#stream \"Direct link to stream\")\n\nWhen using `stream()`, Prisma Pulse provides the following delivery guarantees:\n\n##### At least once delivery[​](https://www.prisma.io/docs/pulse/database-events#at-least-once-delivery \"Direct link to At least once delivery\")\n\nWhen streaming database change events with `stream()`, database change events are guaranteed to be delivered with _at least once_ semantics, meaning that Prisma Pulse can guarantee that any event happening in the database will be delivered one or more times.\n\n##### Delivery of events in the right order[​](https://www.prisma.io/docs/pulse/database-events#delivery-of-events-in-the-right-order \"Direct link to Delivery of events in the right order\")\n\nPrisma Pulse further guarantees to deliver the database change events in the order they were produced.\n\n##### Exactly once delivery[​](https://www.prisma.io/docs/pulse/database-events#exactly-once-delivery \"Direct link to Exactly once delivery\")\n\nWhile Pulse by default offers _at least once_ semantics, it also provides the _primitives_ for you to implement _exactly once_ delivery guarantees yourself!\n\nEach event produced by Prisma Pulse carries an identifier/idempotency key that you can use to deduplicate during downstream processing of the event. This is best implemented by passing the identifier along to external services that support idempotency or using concepts like upsert when working with a database.\n\nThe `id` field in this event payload for a `User` model represent the identifier/idempotency key:\n\n```\n{  action: 'update',  after: { id: 1, name: 'Jane', email: \"doe@prisma.io\" },  before: null,  id: '01HYBEER1JPSBVPG2NQADNQTA6',  modelName: 'User'}\n```\n\n#### `subscribe()`[​](https://www.prisma.io/docs/pulse/database-events#subscribe \"Direct link to subscribe\")\n\n##### At most once delivery[​](https://www.prisma.io/docs/pulse/database-events#at-most-once-delivery \"Direct link to At most once delivery\")\n\nWhen streaming database change events with `.subscribe()`, database change events are guaranteed to be delivered with _at most once_ semantics, meaning that some of the database events may get lost.\n\n##### No guarantees about the order of the events[​](https://www.prisma.io/docs/pulse/database-events#no-guarantees-about-the-order-of-the-events \"Direct link to No guarantees about the order of the events\")\n\n`subscribe()` doesn't provide any guarantees about the order in which events will arrive.\n\n## Event persistence[​](https://www.prisma.io/docs/pulse/database-events#event-persistence \"Direct link to Event persistence\")\n\nYou can configure **Event persistence** for Pulse in your Console [project](https://www.prisma.io/docs/platform/about#project). Only with **Event persistence** enabled, you will be able to take advantage of _at least once_ and _right order_ delivery guarantees by Prisma Pulse via the `stream()` API.\n\n### What events are persisted?[​](https://www.prisma.io/docs/pulse/database-events#what-events-are-persisted \"Direct link to What events are persisted?\")\n\nAs soon as you enable **Event persistence** for Pulse in your Console [project](https://www.prisma.io/docs/platform/about#project), Pulse will store _all database_ events from _all tables_.\n\n### In what shape are events being persisted?[​](https://www.prisma.io/docs/pulse/database-events#in-what-shape-are-events-being-persisted \"Direct link to In what shape are events being persisted?\")\n\nEvents are being persisted in the same [structure](https://www.prisma.io/docs/pulse/database-events#structure) that they're delivered.\n\n### How does event persistence impact pricing?[​](https://www.prisma.io/docs/pulse/database-events#how-does-event-persistence-impact-pricing \"Direct link to How does event persistence impact pricing?\")\n\nWith event persistence enabled, pricing is impacted as follows:\n\n*   **Database events**: The number of database events _captured_ by Pulse\n*   **Events reads**: The number of database events _read_ and _delivered_ by Pulse via `.stream()`\n*   **Event storage**: The amount of disk space the stored events consume (in GiB)\n\nSee the [subscription plans](https://www.prisma.io/pricing) for more details. Pricing applies regardless of whether you use `subscribe()` or `stream()`.\n\n## Resuming event streams[​](https://www.prisma.io/docs/pulse/database-events#resuming-event-streams \"Direct link to Resuming event streams\")\n\nThe `stream()` API offers the option to provide a [`name`](https://www.prisma.io/docs/pulse/api-reference#options) argument which makes a stream _resumable_:\n\n```\nconst stream = await prisma.user.stream({  name: \"all-user-events\"})\n```\n\nIf a `name` is provided, Pulse tracks the delivery of events with a _cursor_. Only if the event is acknowledged on the receiver side, the cursor associated with that `name` will move.\n\nIn case a stream is unavailable for some reason, e.g. because your server was down, the receiver can't acknowledge any events. Once the stream is available again, the stream will pick up at the last cursor position and deliver any events that haven't been acknowledged in the meantime:\n\n![](https://www.prisma.io/docs/assets/images/with-name-19bbbc994eb998432603000870466be0.png)\n\nIf the `name` option is omitted, no cursor will be associated with the stream and events that happen while a stream is down will not be delivered:\\`\n\n![](https://www.prisma.io/docs/assets/images/without-name-5504e23e5245cae558137222b608070f.png)",
  "title": "Database events with Prisma Pulse | Prisma Documentation",
  "description": "Learn about database change events in Prisma Pulse, their structure, delivery semantics, and more.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse/faq",
  "markdown": "# Prisma Pulse: FAQ | Prisma Documentation\n\n## What databases are supported with Prisma Pulse?[​](https://www.prisma.io/docs/pulse/faq#what-databases-are-supported-with-prisma-pulse \"Direct link to What databases are supported with Prisma Pulse?\")\n\nPrisma Pulse currently supports PostgreSQL v12 and higher. We'd love to hear [which databases](https://tally.so/r/wLbb8G) you would like to see supported next.\n\n### What database providers are supported with Prisma Pulse?[​](https://www.prisma.io/docs/pulse/faq#what-database-providers-are-supported-with-prisma-pulse \"Direct link to What database providers are supported with Prisma Pulse?\")\n\nAny PostgreSQL provider that enables you to [enable logical replication](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#enable-logical-replication) is supported:\n\n| Provider | Starter | Pro | Business | Enterprise |\n| --- | --- | --- | --- | --- |\n| **Railway** | ✅   | ✅   | ✅   | ✅   |\n| **Supabase** | ✅   | ✅   | ✅   | ✅   |\n| **Neon** | ❌   | ✅   | ✅   | ✅   |\n| **AWS RDS** | ✅   | ✅   | ✅   | ✅   |\n\nNote that because Neon doesn't provide [superuser](https://www.postgresql.org/docs/current/role-attributes.html) access to the database, you can't use Neon-hosted databases on the Starter plan.\n\n## Does Pulse store my database events?[​](https://www.prisma.io/docs/pulse/faq#does-pulse-store-my-database-events \"Direct link to Does Pulse store my database events?\")\n\nPulse persists database events if you enable the **Event persistence** feature in your [project](https://www.prisma.io/docs/platform/about#project) via the Console. This lets you use the `stream()` API and take advantage of [delivery guarantees](https://www.prisma.io/docs/pulse/database-events#event-delivery-semantics-in-prisma-pulse).\n\n## How does persisting events impact pricing?[​](https://www.prisma.io/docs/pulse/faq#how-does-persisting-events-impact-pricing \"Direct link to How does persisting events impact pricing?\")\n\nIf you enable **Event persistence** for your project, Pulse will store the events that happen in your database in the same [shape](https://www.prisma.io/docs/pulse/database-events#structure) that they're delivered.\n\nUsage of the API is billed according to these factors:\n\n*   **Database events**: The number of database events _captured_ by Pulse\n*   **Events reads**: The number of database events _read_ and _delivered_ by Pulse via `.stream()`\n*   **Event storage**: The amount of disk space the stored events consume (in GiB)\n\n## How many Prisma Client instances can subscribe to a database event?[​](https://www.prisma.io/docs/pulse/faq#how-many-prisma-client-instances-can-subscribe-to-a-database-event \"Direct link to How many Prisma Client instances can subscribe to a database event?\")\n\nThe number of Prisma Client instances that can subscribe to via Prisma Pulse has the following limits:\n\n*   1000 subscribers for `stream()`\n*   20 subscribers for `subscribe()`\n\n## How can I increase the throughput for Prisma Pulse?[​](https://www.prisma.io/docs/pulse/faq#how-can-i-increase-the-throughput-for-prisma-pulse \"Direct link to How can I increase the throughput for Prisma Pulse?\")\n\nThroughput for Prisma Pulse will increase as the database event size and the number of concurrent listeners decrease.\n\nWhile limiting database event size can be tricky, we recommend some best practices, such as:\n\n*   Avoid large fields in your model, such as storing base64 image strings in the database. Instead, consider storing them in popular file storage options such as AWS S3 or Cloudflare.\n*   Creating publication slots for specific models rather than all the models in the database. You can learn more about managing your replication slots [here](https://www.prisma.io/docs/pulse/database-setup/general-database-instructions#max_replication_slots).\n*   Upgrading to use modern versions of PostgreSQL due to performance optimizations. Modern versions of PostgreSQL (`v15`+) allow you to create a publication slot for specific fields of a particular model.\n\n## Can I use Pulse in my front-end code?[​](https://www.prisma.io/docs/pulse/faq#can-i-use-pulse-in-my-front-end-code \"Direct link to Can I use Pulse in my front-end code?\")\n\nNo, Pulse is server-side and subscriptions cannot be initiated directly within client-side code. If you would find this feature valuable, please share your thoughts on the `#help-and-questions` channel in our community [Discord](https://pris.ly/discord).\n\nTo propagate events to the frontend, you can use a WebSocket library like [socket.io](https://socket.io/).\n\n## How to configure `tsconfig.json` with the Pulse extension?[​](https://www.prisma.io/docs/pulse/faq#how-to-configure-tsconfigjson-with-the-pulse-extension \"Direct link to how-to-configure-tsconfigjson-with-the-pulse-extension\")\n\nIf you're using [`\"moduleResolution\": \"bundler\"`](https://www.typescriptlang.org/docs/handbook/modules/reference.html#bundler) in your `tsconfig.json` file, you need to explicitly set [`customConditions`](https://www.typescriptlang.org/tsconfig/#customConditions) to either `node` or `workerd` depending on your target runtime. This will instruct TypeScript to match the correct type definitions of the Prisma Pulse extension, as well as any other packages that expose multiple entrypoints:\n\n```\n// tsconfig.json{  \"compilerOptions\": {    // ...other options    \"target\": \"es2022\",    \"moduleResolution\": \"bundler\",    \"customConditions\": [\"workerd\"] // or \"node\"  }}\n```\n\nThis is needed because Prisma Pulse extension offers separate implementations tailored for various runtimes, such as Node.js and Cloudflare Workers.\n\nIf you don't add this, you may run into the following error when using the `@prisma/extension-pulse` in your application code:\n\n```\nCannot find module '@prisma/extension-pulse' or its corresponding type declarations.\n```",
  "title": "Prisma Pulse: FAQ | Prisma Documentation",
  "description": "Frequently asked questions about Prisma Pulse.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/pulse/feedback",
  "markdown": "# Prisma Pulse: Feedback | Prisma Documentation\n\nYou can submit any feedback about Prisma Pulse in the `#help-and-questions` channel in our community [Discord](https://pris.ly/discord).",
  "title": "Prisma Pulse: Feedback | Prisma Documentation",
  "description": "Learn where to submit feedback about Prisma Pulse.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/platform/maturity-levels",
  "markdown": "# Console: Maturity levels | Prisma Documentation\n\nPrisma releases updates to Prisma Data Platform multiple times per week, as opposed to the Prisma ORM that we release on a set schedule every few weeks. This is why we consider the lifecycle and process for maturing features in Prisma Data Platform differently.\n\nYou can [check out the releases and maturity process for the Prisma ORM](https://www.prisma.io/docs/orm/more/releases) for further details.\n\nYou can find information about releases across _all_ Prisma tools and products in the [changelog](https://www.prisma.io/changelog).\n\n### Early Access[​](https://www.prisma.io/docs/platform/maturity-levels#early-access \"Direct link to Early Access\")\n\nIf a feature on the Prisma Data Platform is labeled as **Early Access**:\n\n*   We have validated a problem and are considering a solution to it but are not certain whether that solution is complete or a perfect fit.\n*   We want to gather more feedback and adjust the solution as necessary, knowing that users are prepared for significant breaking changes\n*   We reserve ourselves the right to throttle or remove access to a feature in Early Access to preserve the stability of the platform, or enforcing its use to stay within the scope defined in our [Terms of Service](https://pris.ly/terms).\n\nAs always, your feedback in our [Discord](https://pris.ly/discord) is invaluable to shape the design of the features. This will help us ensure that they can solve your problems in the best way possible.\n\n### Preview[​](https://www.prisma.io/docs/platform/maturity-levels#preview \"Direct link to Preview\")\n\nIf a feature on the Prisma Data Platform is labeled as **Preview**:\n\n*   We have refined the software based on the valuable feedback we obtained during the Early Access phase.\n*   We developed the feature further, bringing it closer to the final version, though it's not completely ready for production usage.\n*   We have lifted the invite gate, so users no longer need an invitation to access the feature. Users just need to sign up to gain access.\n*   We have increased the stability of the software compared to the Early Access phase. While there might still be some issues, they should be less frequent and less critical.\n*   We use the Preview phase as a final stress test to ensure the product is ready for heavy production workloads.\n\nWe recommend testing the product in a staging environment and welcome any feedback in our [Discord](https://pris.ly/discord). This will assist us in improving the product for its final release.\n\n### General Availability[​](https://www.prisma.io/docs/platform/maturity-levels#general-availability \"Direct link to General Availability\")\n\nIf a feature in the Prisma Data Platform is Generally Available:\n\n*   The solution has undergone extensive testing and, based on significant feedback, is deemed stable and ready for production use cases.",
  "title": "Console: Maturity levels | Prisma Documentation",
  "description": "Understand the maturity levels for features in Prisma Data Platform",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/platform",
  "markdown": "# Platform | Prisma Documentation\n\nLearn about the main concepts and workflows of the [Prisma Data Platform](https://prisma.io/data-platform/).\n\n## In this section[​](https://www.prisma.io/docs/platform#in-this-section \"Direct link to In this section\")\n\n[\n\n## Platform\n\n](https://www.prisma.io/docs/platform)\n\n[\n\n## About\n\n](https://www.prisma.io/docs/platform/about)\n\n[\n\n## Maturity levels\n\n](https://www.prisma.io/docs/platform/maturity-levels)\n\n[\n\n## Limits\n\n](https://www.prisma.io/docs/platform/limits)\n\n[\n\n## Support\n\n](https://www.prisma.io/docs/platform/support)\n\n[\n\n## Platform CLI\n\n](https://www.prisma.io/docs/platform/platform-cli)",
  "title": "Platform | Prisma Documentation",
  "description": "Get started with the Prisma Data Platform with its official documentation, and learn more about its features with reference documentation, guides, and more.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/platform/limits",
  "markdown": "# Console: Limits | Prisma Documentation\n\nMore details on limits will be available soon.",
  "title": "Console: Limits | Prisma Documentation",
  "description": "More details on limits will be available soon.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/platform/support",
  "markdown": "# Console: Support | Prisma Documentation\n\nYour feedback is invaluable, and we encourage you to share your experiences with us on [Discord](https://pris.ly/discord).\n\n## Support[​](https://www.prisma.io/docs/platform/support#support \"Direct link to Support\")\n\nReach out to us in our [Discord](https://pris.ly/discord).\n\n### Standard support[​](https://www.prisma.io/docs/platform/support#standard-support \"Direct link to Standard support\")\n\n*   Email support, [](mailto:support@prisma.io)[support@prisma.io](mailto:support@prisma.io)\n*   Mon-Fri, 9am-5pm CET\n\n### Premium support[​](https://www.prisma.io/docs/platform/support#premium-support \"Direct link to Premium support\")\n\n*   Email support, [](mailto:support@prisma.io)[support@prisma.io](mailto:support@prisma.io)\n*   24/7\n\n### Dedicated support[​](https://www.prisma.io/docs/platform/support#dedicated-support \"Direct link to Dedicated support\")\n\nDedicated contact person.\n\n## Deleting your PDP account[​](https://www.prisma.io/docs/platform/support#deleting-your-pdp-account \"Direct link to Deleting your PDP account\")\n\nIf you want to delete your PDP account, **email us at [](mailto:support@prisma.io)[support@prisma.io](mailto:support@prisma.io)**.\n\nTo ensure that you're not accidentally disabling any infrastructure powering one of your applications, we require that you **disable Accelerate and Pulse in _all_ environments of _all_ your projects** that live in the account to be deleted.",
  "title": "Console: Support | Prisma Documentation",
  "description": "Find the right support for any Console question.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/platform/platform-cli",
  "markdown": "# Platform CLI | Prisma Documentation\n\n## In this section[​](https://www.prisma.io/docs/platform/platform-cli#in-this-section \"Direct link to In this section\")\n\n[\n\n## About\n\n](https://www.prisma.io/docs/platform/platform-cli/about)\n\n[\n\n## Commands\n\n](https://www.prisma.io/docs/platform/platform-cli/commands)\n\n*   [In this section](https://www.prisma.io/docs/platform/platform-cli#in-this-section)",
  "title": "Platform CLI | Prisma Documentation",
  "description": "Learn about the CLI for Prisma Data Platform",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/platform/platform-cli/about",
  "markdown": "# Platform CLI: About | Prisma Documentation\n\nThis guide demonstrates how to access the Prisma Data Platform using the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli). Get started by ensuring you have the Prisma CLI installed, following our setup [instructions](https://www.prisma.io/docs/orm/tools/prisma-cli#installation).\n\nThis integration, now in Early Access, expands the capabilities of the Prisma CLI, enabling management of your Platform projects directly from the command line. For a detailed overview of all the commands, please refer to the [Commands page](https://www.prisma.io/docs/platform/platform-cli/commands).",
  "title": "Platform CLI: About | Prisma Documentation",
  "description": "This guide demonstrates how to access the Prisma Data Platform using the Prisma CLI. Get started by ensuring you have the Prisma CLI installed, following our setup instructions.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/quickstart",
  "markdown": "# Quickstart with TypeScript & SQLite\n\nIn this Quickstart guide, you'll learn how to get started with Prisma ORM from scratch using a plain **TypeScript** project and a local **SQLite** database file. It covers **data modeling**, **migrations** and **querying** a database.\n\nIf you want to use Prisma ORM with your own PostgreSQL, MySQL, MongoDB or any other supported database, go here instead:\n\n*   [Start with Prisma ORM from scratch](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-postgresql)\n*   [Add Prisma ORM to an existing project](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-postgresql)\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/quickstart#prerequisites \"Direct link to Prerequisites\")\n\nYou need Node.js v16.13.0 or higher for this guide (learn more about [system requirements](https://www.prisma.io/docs/orm/reference/system-requirements)).\n\n## 1\\. Create TypeScript project and set up Prisma ORM[​](https://www.prisma.io/docs/getting-started/quickstart#1-create-typescript-project-and-set-up-prisma-orm \"Direct link to 1. Create TypeScript project and set up Prisma ORM\")\n\nAs a first step, create a project directory and navigate into it:\n\n```\nmkdir hello-prismacd hello-prisma\n```\n\nNext, initialize a TypeScript project using npm:\n\n```\nnpm init -ynpm install typescript ts-node @types/node --save-dev\n```\n\nThis creates a `package.json` with an initial setup for your TypeScript app.\n\nNow, initialize TypeScript:\n\nThen, install the Prisma CLI as a development dependency in the project:\n\n```\nnpm install prisma --save-dev\n```\n\nFinally, set up Prisma ORM with the `init` command of the Prisma CLI:\n\n```\nnpx prisma init --datasource-provider sqlite\n```\n\nThis creates a new `prisma` directory with a `prisma.schema` file and configures SQLite as your database. You're now ready to model your data and create your database with some tables.\n\n## 2\\. Model your data in the Prisma schema[​](https://www.prisma.io/docs/getting-started/quickstart#2-model-your-data-in-the-prisma-schema \"Direct link to 2. Model your data in the Prisma schema\")\n\nThe Prisma schema provides an intuitive way to model data. Add the following models to your `schema.prisma` file:\n\nprisma/schema.prisma\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  author    User    @relation(fields: [authorId], references: [id])  authorId  Int}\n```\n\nModels in the Prisma schema have two main purposes:\n\n*   Represent the tables in the underlying database\n*   Serve as foundation for the generated Prisma Client API\n\nIn the next section, you will map these models to database tables using Prisma Migrate.\n\n## 3\\. Run a migration to create your database tables with Prisma Migrate[​](https://www.prisma.io/docs/getting-started/quickstart#3-run-a-migration-to-create-your-database-tables-with-prisma-migrate \"Direct link to 3. Run a migration to create your database tables with Prisma Migrate\")\n\nAt this point, you have a Prisma schema but no database yet. Run the following command in your terminal to create the SQLite database and the `User` and `Post` tables represented by your models:\n\n```\nnpx prisma migrate dev --name init\n```\n\nThis command did three things:\n\n1.  It created a new SQL migration file for this migration in the `prisma/migrations` directory.\n2.  It executed the SQL migration file against the database.\n3.  It ran `prisma generate` under the hood (which installed the `@prisma/client` package and generated a tailored Prisma Client API based on your models).\n\nBecause the SQLite database file didn't exist before, the command also created it inside the `prisma` directory with the name `dev.db` as defined via the environment variable in the `.env` file.\n\nCongratulations, you now have your database and tables ready. Let's go and learn how you can send some queries to read and write data!\n\n## 4\\. Explore how to send queries to your database with Prisma Client[​](https://www.prisma.io/docs/getting-started/quickstart#4-explore-how-to-send-queries-to-your-database-with-prisma-client \"Direct link to 4. Explore how to send queries to your database with Prisma Client\")\n\nTo send queries to the database, you will need a TypeScript file to execute your Prisma Client queries. Create a new file called `script.ts` for this purpose:\n\nThen, paste the following boilerplate into it:\n\nscript.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nThis code contains a `main` function that's invoked at the end of the script. It also instantiates `PrismaClient` which represents the query interface to your database.\n\n### 4.1. Create a new `User` record[​](https://www.prisma.io/docs/getting-started/quickstart#41-create-a-new-user-record \"Direct link to 41-create-a-new-user-record\")\n\nLet's start with a small query to create a new `User` record in the database and log the resulting object to the console. Add the following code to your `script.ts` file:\n\nscript.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  const user = await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',    },  })  console.log(user)}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nInstead of copying the code, you can type it out in your editor to experience the autocompletion Prisma Client provides. You can also actively invoke the autocompletion by pressing the CTRL+SPACE keys on your keyboard.\n\nNext, execute the script with the following command:\n\nGreat job, you just created your first database record with Prisma Client! 🎉\n\nIn the next section, you'll learn how to read data from the database.\n\n### 4.2. Retrieve all `User` records[​](https://www.prisma.io/docs/getting-started/quickstart#42-retrieve-all-user-records \"Direct link to 42-retrieve-all-user-records\")\n\nPrisma Client offers various queries to read data from your database. In this section, you'll use the `findMany` query that returns _all_ the records in the database for a given model.\n\nDelete the previous Prisma Client query and add the new `findMany` query instead:\n\nscript.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  const users = await prisma.user.findMany()  console.log(users)}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nExecute the script again:\n\nNotice how the single `User` object is now enclosed with square brackets in the console. That's because the `findMany` returned an array with a single object inside.\n\n### 4.3. Explore relation queries with Prisma Client[​](https://www.prisma.io/docs/getting-started/quickstart#43-explore-relation-queries-with-prisma-client \"Direct link to 4.3. Explore relation queries with Prisma Client\")\n\nOne of the main features of Prisma Client is the ease of working with [relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations). In this section, you'll learn how to create a `User` and a `Post` record in a nested write query. Afterwards, you'll see how you can retrieve the relation from the database using the `include` option.\n\nFirst, adjust your script to include the nested query:\n\nscript.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  const user = await prisma.user.create({    data: {      name: 'Bob',      email: 'bob@prisma.io',      posts: {        create: [          {            title: 'Hello World',            published: true          },          {            title: 'My second post',            content: 'This is still a draft'          }        ],      },    },  })  console.log(user)}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nRun the query by executing the script again:\n\nBy default, Prisma Client only returns _scalar_ fields in the result objects of a query. That's why, even though you also created a new `Post` record for the new `User` record, the console only printed an object with three scalar fields: `id`, `email` and `name`.\n\nIn order to also retrieve the `Post` records that belong to a `User`, you can use the `include` option via the `posts` relation field:\n\nscript.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  const usersWithPosts = await prisma.user.findMany({    include: {      posts: true,    },  })  console.dir(usersWithPosts, { depth: null })}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nRun the script again to see the results of the nested read query:\n\nThis time, you're seeing two `User` objects being printed. Both of them have a `posts` field (which is empty for `\"Alice\"` and populated with a single `Post` object for `\"Bob\"`) that represents the `Post` records associated with them.\n\nNotice that the objects in the `usersWithPosts` array are fully typed as well. This means you will get autocompletion and the TypeScript compiler will prevent you from accidentally typing them.\n\n## 5\\. Next steps[​](https://www.prisma.io/docs/getting-started/quickstart#5-next-steps \"Direct link to 5. Next steps\")\n\nIn this Quickstart guide, you have learned how to get started with Prisma ORM in a plain TypeScript project. Feel free to explore the Prisma Client API a bit more on your own, e.g. by including filtering, sorting, and pagination options in the `findMany` query or exploring more operations like `update` and `delete` queries.\n\n### Explore the data in Prisma Studio[​](https://www.prisma.io/docs/getting-started/quickstart#explore-the-data-in-prisma-studio \"Direct link to Explore the data in Prisma Studio\")\n\nPrisma ORM comes with a built-in GUI to view and edit the data in your database. You can open it using the following command:\n\n### Set up Prisma ORM with your own database[​](https://www.prisma.io/docs/getting-started/quickstart#set-up-prisma-orm-with-your-own-database \"Direct link to Set up Prisma ORM with your own database\")\n\nIf you want to move forward with Prisma ORM using your own PostgreSQL, MySQL, MongoDB or any other supported database, follow the Set Up Prisma ORM guides:\n\n*   [Start with Prisma ORM from scratch](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-postgresql)\n*   [Add Prisma ORM to an existing project](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project)\n\n### Explore ready-to-run Prisma ORM examples[​](https://www.prisma.io/docs/getting-started/quickstart#explore-ready-to-run-prisma-orm-examples \"Direct link to Explore ready-to-run Prisma ORM examples\")\n\nCheck out the [`prisma-examples`](https://github.com/prisma/prisma-examples/) repository on GitHub to see how Prisma ORM can be used with your favorite library. The repo contains examples with Express, NestJS, GraphQL as well as fullstack examples with Next.js and Vue.js, and a lot more.\n\n### Build an app with Prisma ORM[​](https://www.prisma.io/docs/getting-started/quickstart#build-an-app-with-prisma-orm \"Direct link to Build an app with Prisma ORM\")\n\nThe Prisma blog features comprehensive tutorials about Prisma ORM, check out our latest ones:\n\n*   [Build a fullstack app with Next.js](https://www.youtube.com/watch?v=QXxy8Uv1LnQ&ab_channel=ByteGrad)\n*   [Build a fullstack app with Remix](https://www.prisma.io/blog/fullstack-remix-prisma-mongodb-1-7D0BfTXBmB6r) (5 parts, including videos)\n*   [Build a REST API with NestJS](https://www.prisma.io/blog/nestjs-prisma-rest-api-7D056s1BmOL0)\n\nPrisma has a huge [community](https://www.prisma.io/community) of developers. Join us on [Discord](https://discord.gg/KQyTW2H5ca) or ask questions using [GitHub Discussions](https://github.com/prisma/prisma/discussions).",
  "title": "Quickstart with TypeScript & SQLite | Prisma Documentation",
  "description": "Get started with Prisma ORM in 5 minutes. You will learn how to send queries to a SQLite database in a plain TypeScript script using Prisma Client.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma",
  "markdown": "# Set up Prisma ORM | Prisma Documentation\n\nStart from scratch or add Prisma ORM to an existing project. The following tutorials introduce you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\n## In this section[​](https://www.prisma.io/docs/getting-started/setup-prisma#in-this-section \"Direct link to In this section\")\n\n[\n\n## Start from scratch\n\n](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch)\n\n[\n\n## Add to existing project\n\n](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project)",
  "title": "Set up Prisma ORM | Prisma Documentation",
  "description": "Get started with Prisma ORM and your favorite database. Learn about data modeling, migrations and querying.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch",
  "markdown": "# Start from scratch with Prisma ORM\n\nStart a fresh project from scratch with the following tutorials as they introduce you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\n## In this section[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch#in-this-section \"Direct link to In this section\")\n\n[\n\n## Relational databases\n\n](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-postgresql)\n\n[\n\n## MongoDB\n\n](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb-typescript-mongodb)",
  "title": "Start from scratch with Prisma ORM | Prisma Documentation",
  "description": "Learn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your database of choice and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project",
  "markdown": "# Add Prisma ORM to an existing project\n\nInclude Prisma ORM in an existing project with the following documentation, which explains some core concepts as it guides you through integrating Prisma ORM into your workflow.\n\n## In this section[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project#in-this-section \"Direct link to In this section\")\n\n[\n\n## Relational databases\n\n](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-postgresql)\n\n[\n\n## MongoDB\n\n](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-typescript-mongodb)",
  "title": "Add Prisma ORM to an existing project | Prisma Documentation",
  "description": "Learn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database of choice and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-postgresql",
  "markdown": "# Start from scratch with Prisma ORM using TypeScript and PostgreSQL (15 min)\n\n## Relational databases\n\nLearn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-postgresql#prerequisites \"Direct link to Prerequisites\")\n\nIn order to successfully complete this guide, you need:\n\n*   [Node.js](https://nodejs.org/en/) installed on your machine\n*   a [PostgreSQL](https://www.postgresql.org/) database server running\n\n> See [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for exact version requirements.\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) at hand. If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n## Create project setup[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-postgresql#create-project-setup \"Direct link to Create project setup\")\n\nAs a first step, create a project directory and navigate into it:\n\n```\nmkdir hello-prismacd hello-prisma\n```\n\nNext, initialize a TypeScript project and add the Prisma CLI as a development dependency to it:\n\n```\nnpm init -ynpm install prisma typescript ts-node @types/node --save-dev\n```\n\nThis creates a `package.json` with an initial setup for your TypeScript app.\n\nNext, initialize TypeScript:\n\nYou can now invoke the Prisma CLI by prefixing it with `npx`:\n\nNext, set up your Prisma ORM project by creating your [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file with the following command:\n\nThis command does two things:\n\n*   creates a new directory called `prisma` that contains a file called `schema.prisma`, which contains the Prisma schema with your database connection variable and schema models\n*   creates the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) in the root directory of the project, which is used for defining environment variables (such as your database connection)",
  "title": "Start from scratch with Prisma ORM using TypeScript and PostgreSQL (15 min) | Prisma Documentation",
  "description": "Learn how to create a new TypeScript project from scratch by connecting Prisma ORM to your PostgreSQL database and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-mysql",
  "markdown": "# Start from scratch with Prisma ORM using TypeScript and MySQL (15 min)\n\n## Relational databases\n\nLearn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-mysql#prerequisites \"Direct link to Prerequisites\")\n\nIn order to successfully complete this guide, you need:\n\n*   [Node.js](https://nodejs.org/en/) installed on your machine\n*   a [MySQL](https://www.mysql.com/) database server running\n\n> See [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for exact version requirements.\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) at hand. If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n## Create project setup[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-mysql#create-project-setup \"Direct link to Create project setup\")\n\nAs a first step, create a project directory and navigate into it:\n\n```\nmkdir hello-prismacd hello-prisma\n```\n\nNext, initialize a TypeScript project and add the Prisma CLI as a development dependency to it:\n\n```\nnpm init -ynpm install prisma typescript ts-node @types/node --save-dev\n```\n\nThis creates a `package.json` with an initial setup for your TypeScript app.\n\nNext, initialize TypeScript:\n\nYou can now invoke the Prisma CLI by prefixing it with `npx`:\n\nNext, set up your Prisma ORM project by creating your [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file with the following command:\n\nThis command does two things:\n\n*   creates a new directory called `prisma` that contains a file called `schema.prisma`, which contains the Prisma schema with your database connection variable and schema models\n*   creates the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) in the root directory of the project, which is used for defining environment variables (such as your database connection)",
  "title": "Start from scratch with Prisma ORM using TypeScript and MySQL (15 min) | Prisma Documentation",
  "description": "Learn how to create a new TypeScript project from scratch by connecting Prisma ORM to your MySQL database and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-sqlserver",
  "markdown": "# Start from scratch with Prisma ORM using TypeScript and SQL Server (15 min)\n\n## Relational databases\n\nLearn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-sqlserver#prerequisites \"Direct link to Prerequisites\")\n\nIn order to successfully complete this guide, you need:\n\n*   [Node.js](https://nodejs.org/en/) installed on your machine\n*   A [Microsoft SQL Server](https://docs.microsoft.com/en-us/sql/?view=sql-server-ver15) database\n    *   [Microsoft SQL Server on Linux for Docker](https://www.prisma.io/docs/orm/overview/databases/sql-server/sql-server-docker)\n    *   [Microsoft SQL Server on Windows (local)](https://www.prisma.io/docs/orm/overview/databases/sql-server/sql-server-local)\n\n> See [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for exact version requirements.\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) at hand. If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n## Create project setup[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-sqlserver#create-project-setup \"Direct link to Create project setup\")\n\nAs a first step, create a project directory and navigate into it:\n\n```\nmkdir hello-prismacd hello-prisma\n```\n\nNext, initialize a TypeScript project and add the Prisma CLI as a development dependency to it:\n\n```\nnpm init -ynpm install prisma typescript ts-node @types/node --save-dev\n```\n\nThis creates a `package.json` with an initial setup for your TypeScript app.\n\nNext, initialize TypeScript:\n\nYou can now invoke the Prisma CLI by prefixing it with `npx`:\n\nNext, set up your Prisma ORM project by creating your [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file with the following command:\n\nThis command does two things:\n\n*   creates a new directory called `prisma` that contains a file called `schema.prisma`, which contains the Prisma schema with your database connection variable and schema models\n*   creates the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) in the root directory of the project, which is used for defining environment variables (such as your database connection)",
  "title": "Start from scratch with Prisma ORM using TypeScript and SQL Server (15 min) | Prisma Documentation",
  "description": "Learn how to create a new TypeScript project from scratch by connecting Prisma ORM to your SQL Server database and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-cockroachdb",
  "markdown": "# Start from scratch with Prisma ORM using TypeScript and CockroachDB (15 min)\n\n## Relational databases\n\nLearn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-cockroachdb#prerequisites \"Direct link to Prerequisites\")\n\nIn order to successfully complete this guide, you need:\n\n*   [Node.js](https://nodejs.org/en/) installed on your machine\n*   a [CockroachDB](https://www.cockroachlabs.com/) database server running\n\n> See [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for exact version requirements.\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) at hand. If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n## Create project setup[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-cockroachdb#create-project-setup \"Direct link to Create project setup\")\n\nAs a first step, create a project directory and navigate into it:\n\n```\nmkdir hello-prismacd hello-prisma\n```\n\nNext, initialize a TypeScript project and add the Prisma CLI as a development dependency to it:\n\n```\nnpm init -ynpm install prisma typescript ts-node @types/node --save-dev\n```\n\nThis creates a `package.json` with an initial setup for your TypeScript app.\n\nNext, initialize TypeScript:\n\nYou can now invoke the Prisma CLI by prefixing it with `npx`:\n\nNext, set up your Prisma ORM project by creating your [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file with the following command:\n\nThis command does two things:\n\n*   creates a new directory called `prisma` that contains a file called `schema.prisma`, which contains the Prisma schema with your database connection variable and schema models\n*   creates the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) in the root directory of the project, which is used for defining environment variables (such as your database connection)",
  "title": "Start from scratch with Prisma ORM using TypeScript and CockroachDB (15 min) | Prisma Documentation",
  "description": "Learn how to create a new TypeScript project from scratch by connecting Prisma ORM to your CockroachDB database and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-planetscale",
  "markdown": "# Start from scratch with Prisma ORM using TypeScript and PlanetScale (15 min)\n\n## Relational databases\n\nLearn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-planetscale#prerequisites \"Direct link to Prerequisites\")\n\nIn order to successfully complete this guide, you need:\n\n*   [Node.js](https://nodejs.org/en/) installed on your machine\n*   a [PlanetScale](https://www.planetscale.com/) database server running\n\nwarning\n\nThis tutorial will also assume that you can push to the `main` branch of your database. Do not do this if your `main` branch has been promoted to production.\n\n> See [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for exact version requirements.\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) at hand. If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n## Create project setup[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-planetscale#create-project-setup \"Direct link to Create project setup\")\n\nAs a first step, create a project directory and navigate into it:\n\n```\nmkdir hello-prismacd hello-prisma\n```\n\nNext, initialize a TypeScript project and add the Prisma CLI as a development dependency to it:\n\n```\nnpm init -ynpm install prisma typescript ts-node @types/node --save-dev\n```\n\nThis creates a `package.json` with an initial setup for your TypeScript app.\n\nNext, initialize TypeScript:\n\nYou can now invoke the Prisma CLI by prefixing it with `npx`:\n\nNext, set up your Prisma ORM project by creating your [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file with the following command:\n\nThis command does two things:\n\n*   creates a new directory called `prisma` that contains a file called `schema.prisma`, which contains the Prisma schema with your database connection variable and schema models\n*   creates the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) in the root directory of the project, which is used for defining environment variables (such as your database connection)",
  "title": "Start from scratch with Prisma ORM using TypeScript and PlanetScale (15 min) | Prisma Documentation",
  "description": "Learn how to create a new TypeScript project from scratch by connecting Prisma ORM to your PlanetScale database and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma",
  "markdown": "# What is Prisma ORM? (Overview)\n\nPrisma ORM is an [open-source](https://github.com/prisma/prisma) next-generation ORM. It consists of the following parts:\n\n*   **Prisma Client**: Auto-generated and type-safe query builder for Node.js & TypeScript\n    \n*   **Prisma Migrate**: Migration system\n    \n*   **Prisma Studio**: GUI to view and edit data in your database.\n    \n    info\n    \n    **Prisma Studio** is the only part of Prisma ORM that is not open source. You can only run Prisma Studio locally.\n    \n\nPrisma Client can be used in _any_ Node.js (supported versions) or TypeScript backend application (including serverless applications and microservices). This can be a [REST API](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest), a [GraphQL API](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql), a gRPC API, or anything else that needs a database.\n\n## How does Prisma ORM work?[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#how-does-prisma-orm-work \"Direct link to How does Prisma ORM work?\")\n\n### The Prisma schema[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#the-prisma-schema \"Direct link to The Prisma schema\")\n\nEvery project that uses a tool from the Prisma ORM toolkit starts with a [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema). The Prisma schema allows developers to define their _application models_ in an intuitive data modeling language. It also contains the connection to a database and defines a _generator_:\n\n*   Relational databases\n*   MongoDB\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  author    User?   @relation(fields: [authorId], references: [id])  authorId  Int?}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\n> **Note**: The Prisma schema has powerful data modeling features. For example, it allows you to define \"Prisma-level\" [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) which will make it easier to work with [relations in the Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries). In the case above, the `posts` field on `User` is defined only on \"Prisma-level\", meaning it does not manifest as a foreign key in the underlying database.\n\nIn this schema, you configure three things:\n\n*   **Data source**: Specifies your database connection (via an environment variable)\n*   **Generator**: Indicates that you want to generate Prisma Client\n*   **Data model**: Defines your application models\n\n### The Prisma schema data model[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#the-prisma-schema-data-model \"Direct link to The Prisma schema data model\")\n\nOn this page, the focus is on the data model. You can learn more about [Data sources](https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources) and [Generators](https://www.prisma.io/docs/orm/prisma-schema/overview/generators) on the respective docs pages.\n\n#### Functions of Prisma schema data models[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#functions-of-prisma-schema-data-models \"Direct link to Functions of Prisma schema data models\")\n\nThe data model is a collection of [models](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-models). A model has two major functions:\n\n*   Represent a table in relational databases or a collection in MongoDB\n*   Provide the foundation for the queries in the Prisma Client API\n\n#### Getting a data model[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#getting-a-data-model \"Direct link to Getting a data model\")\n\nThere are two major workflows for \"getting\" a data model into your Prisma schema:\n\n*   Manually writing the data model and mapping it to the database with [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate)\n*   Generating the data model by [introspecting](https://www.prisma.io/docs/orm/prisma-schema/introspection) a database\n\nOnce the data model is defined, you can [generate Prisma Client](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client) which will expose CRUD and more queries for the defined models. If you're using TypeScript, you'll get full type-safety for all queries (even when only retrieving the subsets of a model's fields).\n\n### Accessing your database with Prisma Client[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#accessing-your-database-with-prisma-client \"Direct link to Accessing your database with Prisma Client\")\n\n#### Generating Prisma Client[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#generating-prisma-client \"Direct link to Generating Prisma Client\")\n\nThe first step when using Prisma Client is installing the `@prisma/client` npm package:\n\n```\nnpm install @prisma/client\n```\n\nInstalling the `@prisma/client` package invokes the `prisma generate` command, which reads your Prisma schema and _generates_ Prisma Client code. The code is [generated into the `node_modules/.prisma/client` folder by default](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package).\n\nAfter you change your data model, you'll need to manually re-generate Prisma Client to ensure the code inside `node_modules/.prisma/client` gets updated:\n\n#### Using Prisma Client to send queries to your database[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#using-prisma-client-to-send-queries-to-your-database \"Direct link to Using Prisma Client to send queries to your database\")\n\nOnce Prisma Client has been generated, you can import it in your code and send queries to your database. This is what the setup code looks like.\n\n##### Import and instantiate Prisma Client[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#import-and-instantiate-prisma-client \"Direct link to Import and instantiate Prisma Client\")\n\n*   import\n*   require\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()\n```\n\nNow you can start sending queries via the generated Prisma Client API, here are a few sample queries. Note that all Prisma Client queries return _plain old JavaScript objects_.\n\nLearn more about the available operations in the [Prisma Client API reference](https://www.prisma.io/docs/orm/prisma-client).\n\n##### Retrieve all `User` records from the database[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#retrieve-all-user-records-from-the-database \"Direct link to retrieve-all-user-records-from-the-database\")\n\n```\n// Run inside `async` functionconst allUsers = await prisma.user.findMany()\n```\n\n##### Include the `posts` relation on each returned `User` object[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#include-the-posts-relation-on-each-returned-user-object \"Direct link to include-the-posts-relation-on-each-returned-user-object\")\n\n```\n// Run inside `async` functionconst allUsers = await prisma.user.findMany({  include: { posts: true },})\n```\n\n##### Filter all `Post` records that contain `\"prisma\"`[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#filter-all-post-records-that-contain-prisma \"Direct link to filter-all-post-records-that-contain-prisma\")\n\n```\n// Run inside `async` functionconst filteredPosts = await prisma.post.findMany({  where: {    OR: [      { title: { contains: 'prisma' } },      { content: { contains: 'prisma' } },    ],  },})\n```\n\n##### Create a new `User` and a new `Post` record in the same query[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#create-a-new-user-and-a-new-post-record-in-the-same-query \"Direct link to create-a-new-user-and-a-new-post-record-in-the-same-query\")\n\n```\n// Run inside `async` functionconst user = await prisma.user.create({  data: {    name: 'Alice',    email: 'alice@prisma.io',    posts: {      create: { title: 'Join us for Prisma Day 2020' },    },  },})\n```\n\n##### Update an existing `Post` record[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#update-an-existing-post-record \"Direct link to update-an-existing-post-record\")\n\n```\n// Run inside `async` functionconst post = await prisma.post.update({  where: { id: 42 },  data: { published: true },})\n```\n\n#### Usage with TypeScript[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#usage-with-typescript \"Direct link to Usage with TypeScript\")\n\nNote that when using TypeScript, the result of this query will be _statically typed_ so that you can't accidentally access a property that doesn't exist (and any typos are caught at compile-time). Learn more about leveraging Prisma Client's generated types on the [Advanced usage of generated types](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types) page in the docs.\n\n## Typical Prisma ORM workflows[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#typical-prisma-orm-workflows \"Direct link to Typical Prisma ORM workflows\")\n\nAs mentioned above, there are two ways for \"getting\" your data model into the Prisma schema. Depending on which approach you choose, your main Prisma ORM workflow might look different.\n\n### Prisma Migrate[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#prisma-migrate \"Direct link to Prisma Migrate\")\n\nWith **Prisma Migrate**, Prisma ORM's integrated database migration tool, the workflow looks as follows:\n\n1.  Manually adjust your [Prisma schema data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models)\n2.  Migrate your development database using the `prisma migrate dev` CLI command\n3.  Use Prisma Client in your application code to access your database\n\n![Typical workflow with Prisma Migrate](https://www.prisma.io/docs/assets/images/prisma-migrate-development-workflow-ef472d5e074a57e32dbd65f101f68a70.png)\n\nTo learn more about the Prisma Migrate workflow, see:\n\n*   [Deploying database changes with Prisma Migrate](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-database-changes-with-prisma-migrate)\n\n*   [Developing with Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate)\n\n### SQL migrations and introspection[​](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma#sql-migrations-and-introspection \"Direct link to SQL migrations and introspection\")\n\nIf for some reason, you can not or do not want to use Prisma Migrate, you can still use introspection to update your Prisma schema from your database schema. The typical workflow when using **SQL migrations and introspection** is slightly different:\n\n1.  Manually adjust your database schema using SQL or a third-party migration tool\n2.  (Re-)introspect your database\n3.  Optionally [(re-)configure your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names))\n4.  (Re-)generate Prisma Client\n5.  Use Prisma Client in your application code to access your database\n\n![Introspect workflow](https://www.prisma.io/docs/assets/images/prisma-evolve-app-workflow-ef3834a9ab4af0633eb1e1ee32d2fde7.png)\n\nTo learn more about the introspection workflow, please refer the [introspection section](https://www.prisma.io/docs/orm/prisma-schema/introspection).",
  "title": "What is Prisma ORM? (Overview) | Prisma Documentation",
  "description": "This page gives a high-level overview of what Prisma ORM is and how it works. It's a great starting point for Prisma newcomers!",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb-typescript-mongodb",
  "markdown": "# Start from scratch with Prisma ORM using MongoDB and TypeScript (15 min)\n\nLearn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your MongoDB database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli) and [Prisma Client](https://www.prisma.io/docs/orm/prisma-client).\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb-typescript-mongodb#prerequisites \"Direct link to Prerequisites\")\n\nIn order to successfully complete this guide, you need:\n\n*   [Node.js](https://nodejs.org/en/) installed on your machine\n    \n*   Access to a MongoDB 4.2+ server with a replica set deployment. We recommend using [MongoDB Atlas](https://www.mongodb.com/cloud/atlas).\n    \n    warning\n    \n    The MongoDB database connector uses transactions to support nested writes. Transactions **require** a [replica set](https://docs.mongodb.com/manual/tutorial/deploy-replica-set/) deployment. The easiest way to deploy a replica set is with [Atlas](https://docs.atlas.mongodb.com/getting-started/). It's free to get started.\n    \n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) at hand. If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n> See [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for exact version requirements.\n\n## Create project setup[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb-typescript-mongodb#create-project-setup \"Direct link to Create project setup\")\n\nAs a first step, create a project directory and navigate into it:\n\n```\nmkdir hello-prismacd hello-prisma\n```\n\nNext, initialize a TypeScript project and add the Prisma CLI as a development dependency to it:\n\n```\nnpm init -ynpm install prisma typescript ts-node @types/node --save-dev\n```\n\nThis creates a `package.json` with an initial setup for your TypeScript app.\n\nNext, initialize TypeScript:\n\nYou can now invoke the Prisma CLI by prefixing it with `npx`:\n\nNext, set up your Prisma ORM project by creating your [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file with the following command:\n\nThis command does two things:\n\n*   creates a new directory called `prisma` that contains a file called `schema.prisma`, which contains the Prisma schema with your database connection variable and schema models\n*   creates the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) in the root directory of the project, which is used for defining environment variables (such as your database connection)",
  "title": "Start from scratch with Prisma ORM using MongoDB and TypeScript (15 min) | Prisma Documentation",
  "description": "Learn how to create a new TypeScript project from scratch by connecting Prisma ORM to your MongoDB database and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-postgresql",
  "markdown": "# Add Prisma ORM to an existing project using TypeScript and PostgreSQL (15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\nAs a first step, navigate into your project directory that contains the `package.json` file.\n\n```\nnpm install prisma --save-dev\n```\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:",
  "title": "Add Prisma ORM to an existing project using TypeScript and PostgreSQL (15 min) | Prisma Documentation",
  "description": "Learn how to add Prisma ORM to an existing TypeScript project by connecting it to your PostgreSQL database and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-mysql",
  "markdown": "# Add Prisma to an existing project using TypeScript and MySQL (15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\nAs a first step, navigate into your project directory that contains the `package.json` file.\n\n```\nnpm install prisma --save-dev\n```\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:",
  "title": "Add Prisma to an existing project using TypeScript and MySQL (15 min) | Prisma Documentation",
  "description": "Learn how to add Prisma to an existing TypeScript project by connecting it to your MySQL database and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-planetscale",
  "markdown": "# Add Prisma ORM to an existing project using TypeScript and PlanetScale (15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\nAs a first step, navigate into your project directory that contains the `package.json` file.\n\n```\nnpm install prisma --save-dev\n```\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:",
  "title": "Add Prisma ORM to an existing project using TypeScript and PlanetScale (15 min) | Prisma Documentation",
  "description": "Learn how to add Prisma ORM to an existing TypeScript project by connecting it to your PlanetScale database and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-sqlserver",
  "markdown": "# Add Prisma ORM to an existing project using TypeScript and SQL Server (15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\nAs a first step, navigate into your project directory that contains the `package.json` file.\n\n```\nnpm install prisma --save-dev\n```\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:",
  "title": "Add Prisma ORM to an existing project using TypeScript and SQL Server (15 min) | Prisma Documentation",
  "description": "Learn how to add Prisma ORM to an existing TypeScript project by connecting it to your SQL Server database and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/database-drivers",
  "markdown": "# Database drivers | Prisma Documentation\n\n## Default built-in drivers[​](https://www.prisma.io/docs/orm/overview/databases/database-drivers#default-built-in-drivers \"Direct link to Default built-in drivers\")\n\nOne of Prisma Client's components is the [Query Engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines). The Query Engine is responsible for transforming Prisma Client queries into SQL statements. It connects to your database via TCP using built-in drivers that don't require additional setup.\n\n![Query flow from the user application to the database with Prisma Client](https://www.prisma.io/docs/assets/images/qe-query-execution-flow-768c044bfaa528bf309224ff4f38633a.png)\n\n## Driver adapters[​](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters \"Direct link to Driver adapters\")\n\nPrisma Client can connect and run queries against your database using JavaScript database drivers using **driver adapters**. Adapters act as _translators_ between Prisma Client and the JavaScript database driver.\n\nPrisma Client will use the Query Engine to transform the Prisma Client query to SQL and run the generated SQL queries via the JavaScript database driver.\n\n![Query flow from the user application to the database using Prisma Client and driver adapters](https://www.prisma.io/docs/assets/images/qe-query-engine-adapter-b187bf5d6ea0859f728411aa7c04e96c.png)\n\nThere are two different types of driver adapters:\n\n*   [Database driver adapters](https://www.prisma.io/docs/orm/overview/databases/database-drivers#database-driver-adapters)\n*   [Serverless driver adapters](https://www.prisma.io/docs/orm/overview/databases/database-drivers#serverless-driver-adapters)\n\n> **Note**: Driver adapters enable [edge deployments](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview) of applications that use Prisma ORM.\n\n### Database driver adapters[​](https://www.prisma.io/docs/orm/overview/databases/database-drivers#database-driver-adapters \"Direct link to Database driver adapters\")\n\nYou can connect to your database using a Node.js-based driver from Prisma Client using a database driver adapter. Prisma maintains the following database driver adapters:\n\n*   [PostgreSQL](https://www.prisma.io/docs/orm/overview/databases/postgresql#using-the-node-postgres-driver)\n*   [Turso](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-connect-and-query-a-turso-database)\n\n### Serverless driver adapters[​](https://www.prisma.io/docs/orm/overview/databases/database-drivers#serverless-driver-adapters \"Direct link to Serverless driver adapters\")\n\nDatabase providers, such as Neon and PlanetScale, allow you to connect to your database using other protocols besides TCP, such as HTTP and WebSockets. These database drivers are optimized for connecting to your database in serverless and edge environments.\n\nPrisma ORM maintains the following serverless driver adapters:\n\n*   [Neon](https://www.prisma.io/docs/orm/overview/databases/neon#how-to-use-neons-serverless-driver-with-prisma-orm-preview) (and Vercel Postgres)\n*   [PlanetScale](https://www.prisma.io/docs/orm/overview/databases/planetscale#how-to-use-the-planetscale-serverless-driver-with-prisma-orm-preview)\n*   [Cloudflare D1](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1)\n\n### Community-maintained database driver adapters[​](https://www.prisma.io/docs/orm/overview/databases/database-drivers#community-maintained-database-driver-adapters \"Direct link to Community-maintained database driver adapters\")\n\nYou can also build your own driver adapter for the database you're using. The following is a list of community-maintained driver adapters:\n\n*   [TiDB Cloud Serverless Driver](https://github.com/tidbcloud/prisma-adapter)\n*   [PGlite - Postgres in WASM](https://github.com/lucasthevenet/pglite-utils/tree/main/packages/prisma-adapter)\n\n## How to use driver adapters[​](https://www.prisma.io/docs/orm/overview/databases/database-drivers#how-to-use-driver-adapters \"Direct link to How to use driver adapters\")\n\nTo use this feature:\n\n1.  Update the `previewFeatures` block in your schema to include the `driverAdapters` Preview feature:\n    \n    ```\n    generator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}\n    ```\n    \n2.  Generate Prisma Client:\n    \n3.  Refer to the following pages to learn more about how to use the specific driver adapters with the specific database providers:\n    \n    *   [PostgreSQL](https://www.prisma.io/docs/orm/overview/databases/postgresql#using-the-node-postgres-driver)\n    *   [Neon](https://www.prisma.io/docs/orm/overview/databases/neon#how-to-use-neons-serverless-driver-with-prisma-orm-preview)\n    *   [PlanetScale](https://www.prisma.io/docs/orm/overview/databases/planetscale#how-to-use-the-planetscale-serverless-driver-with-prisma-orm-preview)\n    *   [Turso](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-connect-and-query-a-turso-database)\n    *   [Cloudflare D1](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1)\n\n## Notes about using driver adapters[​](https://www.prisma.io/docs/orm/overview/databases/database-drivers#notes-about-using-driver-adapters \"Direct link to Notes about using driver adapters\")\n\n### Driver adapters don't read the connection string from the Prisma schema[​](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters-dont-read-the-connection-string-from-the-prisma-schema \"Direct link to Driver adapters don't read the connection string from the Prisma schema\")\n\nWhen using Prisma ORM's built-in drivers, the connection string is read from the `url` field of the `datasource` block in your Prisma schema.\n\nOn the other hand, when using a driver adapter, the connection string needs to be provided in your _application code_ when the driver adapter is set up initially. Here is how this is done for the `pg` driver and the `@prisma/adapter-pg` adapter:\n\n```\nimport { PrismaClient } from '@prisma/client'import { PrismaPg } from '@prisma/adapter-pg'import { Pool } from 'pg'const pool = new Pool({ connectionString: env.DATABASE_URL })const adapter = new PrismaPg(pool)const prisma = new PrismaClient({ adapter })\n```\n\nSee the docs for the driver adapter you're using for concrete setup instructions.\n\n### Driver adapters and custom output paths[​](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters-and-custom-output-paths \"Direct link to Driver adapters and custom output paths\")\n\nSince Prisma 5.9.0, when using the driver adapters Preview feature along with a [custom output path for Prisma Client](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#using-a-custom-output-path), you cannot reference Prisma Client using a relative path.\n\nLet's assume you had `output` in your Prisma schema set to `../src/generated/client`:\n\n```\ngenerator client {  provider = \"prisma-client-js\"  output   = \"../src/generated/client\"}\n```\n\nWhat you should **not** do is reference that path relatively:\n\n```\n// what not to do!import { PrismaClient } from './src/generated/client'const client = new PrismaClient()\n```\n\nInstead, you will need to use a linked dependency.\n\n*   npm\n*   pnpm\n*   yarn\n\n```\nnpm add db@./src/generated/client\n```\n\nNow, you should be able to reference your generated client using `db`!\n\n```\nimport { PrismaClient } from 'db'const client = new PrismaClient()\n```\n\n### Driver adapters and specific frameworks[​](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters-and-specific-frameworks \"Direct link to Driver adapters and specific frameworks\")\n\n#### Nuxt[​](https://www.prisma.io/docs/orm/overview/databases/database-drivers#nuxt \"Direct link to Nuxt\")\n\nUsing a driver adapter with [Nuxt](https://nuxt.com/) to deploy to an edge function environment does not work out of the box, but adding the `nitro.experimental.wasm` configuration option fixes that:\n\n```\nexport default defineNuxtConfig({  // ...  nitro: {    // ...    experimental: {      wasm: true,    },  },  // ...})\n```\n\nSee [this example project](https://github.com/prisma/ecosystem-tests/tree/dev/driver-adapters-wasm/d1-cfpages-nuxt) for a full example that can be deployed to Cloudflare Pages.",
  "title": "Database drivers | Prisma Documentation",
  "description": "Learn how Prisma connects to your database using the built-in drivers and how you can use Prisma along with other JavaScript database drivers using driver adapters (Preview)",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-cockroachdb",
  "markdown": "# Add Prisma ORM to an existing project using TypeScript and CockroachDB (15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\nAs a first step, navigate into your project directory that contains the `package.json` file.\n\n```\nnpm install prisma --save-dev\n```\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:",
  "title": "Add Prisma ORM to an existing project using TypeScript and CockroachDB (15 min) | Prisma Documentation",
  "description": "Learn how to add Prisma ORM to an existing TypeScript project by connecting it to your CockroachDB database and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-typescript-mongodb",
  "markdown": "# Add Prisma ORM to an existing MongoDB project using TypeScript (15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-typescript-mongodb#prerequisites \"Direct link to Prerequisites\")\n\nIn order to successfully complete this guide, you need:\n\n*   [Node.js](https://nodejs.org/en/) installed on your machine\n    \n*   Access to a MongoDB 4.2+ server with a replica set deployment. We recommend using [MongoDB Atlas](https://www.mongodb.com/cloud/atlas).\n    \n    warning\n    \n    The MongoDB database connector uses transactions to support nested writes. Transactions **requires** a [replica set](https://docs.mongodb.com/manual/tutorial/deploy-replica-set/) deployment. The easiest way to deploy a replica set is with [Atlas](https://docs.atlas.mongodb.com/getting-started/). It's free to get started.\n    \n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n> See [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for exact version requirements.\n\n## Set up Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-typescript-mongodb#set-up-prisma-orm \"Direct link to Set up Prisma ORM\")\n\nAs a first step, navigate into it your project directory that contains the `package.json` file.\n\nNext, add the Prisma CLI as a development dependency to your project:\n\n```\nnpm install prisma --save-dev\n```\n\nYou can now invoke the Prisma CLI by prefixing it with `npx`:\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:\n\nThis command does two things:\n\n*   creates a new directory called `prisma` that contains a file called `schema.prisma`, which contains the Prisma schema with your database connection variable and schema models\n*   creates the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) in the root directory of the project, which is used for defining environment variables (such as your database connection)",
  "title": "Add Prisma ORM to an existing MongoDB project using TypeScript (15 min) | Prisma Documentation",
  "description": "Learn how to add Prisma ORM to an existing TypeScript project by connecting it to your MongoDB database and generating a Prisma Client for database access.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/supabase",
  "markdown": "# Supabase | Prisma Documentation\n\nThis guide discusses the concepts behind using Prisma ORM and Supabase, explains the commonalities and differences between Supabase and other database providers, and leads you through the process for configuring your application to integrate with Supabase.\n\n## What is Supabase?[​](https://www.prisma.io/docs/orm/overview/databases/supabase#what-is-supabase \"Direct link to What is Supabase?\")\n\n[Supabase](https://supabase.com/) is a PostgreSQL hosting service and open source Firebase alternative providing all the backend features you need to build a product. Unlike Firebase, Supabase is backed by PostgreSQL which can be accessed directly using Prisma ORM.\n\nTo learn more about Supabase, you can check out their architecture [here](https://supabase.com/docs/guides/getting-started/architecture) and features [here](https://supabase.com/docs/guides/getting-started/features)\n\n## Commonalities with other database providers[​](https://www.prisma.io/docs/orm/overview/databases/supabase#commonalities-with-other-database-providers \"Direct link to Commonalities with other database providers\")\n\nMany aspects of using Prisma ORM with Supabase are just like using Prisma ORM with any other relational database. You can still:\n\n*   model your database with the [Prisma Schema Language](https://www.prisma.io/docs/orm/prisma-schema)\n*   use Prisma ORM's existing [`postgresql` database connector](https://www.prisma.io/docs/orm/overview/databases/postgresql) in your schema, along with the [connection string Supabase provides you](https://supabase.com/docs/guides/database/connecting-to-postgres#finding-your-connection-string)\n*   use [Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) for existing projects if you already have a database schema in Supabase\n*   use [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) to push changes in your schema to Supabase\n*   use [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) in your application to talk to the database server at Supabase\n\n## Specific considerations[​](https://www.prisma.io/docs/orm/overview/databases/supabase#specific-considerations \"Direct link to Specific considerations\")\n\nIf you'd like to use the [connection pooling feature](https://supabase.com/docs/guides/database/connecting-to-postgres#connection-pooler) available with Supabase, you will need to use the connection pooling connection string available via your [Supabase database settings](https://supabase.com/dashboard/project/_/settings/database) with `?pgbouncer=true` appended to the end of your `DATABASE_URL` environment variable:\n\n.env\n\n```\n# Connect to Supabase via connection pooling with Supavisor.DATABASE_URL=\"postgres://postgres.[your-supabase-project]:[password]@aws-0-[aws-region].pooler.supabase.com:6543/postgres?pgbouncer=true\"\n```\n\nIf you would like to use the Prisma CLI in order to perform other actions on your database (e.g. migrations) you will need to add a `DIRECT_URL` environment variable to use in the `datasource.directUrl` property so that the CLI can bypass Supavisor:\n\n.env\n\n```\n# Connect to Supabase via connection pooling with Supavisor.DATABASE_URL=\"postgres://postgres.[your-supabase-project]:[password]@aws-0-[aws-region].pooler.supabase.com:6543/postgres?pgbouncer=true\"# Direct connection to the database. Used for migrations.DIRECT_URL=\"postgres://postgres.[your-supabase-project]:[password]@aws-0-[aws-region].pooler.supabase.com:5432/postgres\"\n```\n\nYou can then update your `schema.prisma` to use the new direct URL:\n\nschema.prisma\n\n```\ndatasource db {  provider  = \"postgresql\"  url       = env(\"DATABASE_URL\")  directUrl = env(\"DIRECT_URL\")}\n```\n\nMore information about the `directUrl` field can be found [here](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fields).\n\ninfo\n\nWe strongly recommend using connection pooling with Supavisor in addition to `DIRECT_URL`. You will gain the great developer experience of the Prisma CLI while also allowing for connections to be pooled regardless of your deployment strategy. While this is not strictly necessary for every app, serverless solutions will inevitably require connection pooling.\n\n## Getting started with Supabase[​](https://www.prisma.io/docs/orm/overview/databases/supabase#getting-started-with-supabase \"Direct link to Getting started with Supabase\")\n\nIf you're interested in learning more, Supabase has a great guide for connecting a database provided by Supabase to your Prisma project available [here](https://supabase.com/docs/guides/integrations/prisma).\n\nIf you're running into issues integrating with Supabase, check out these [specific troubleshooting tips](https://supabase.com/docs/guides/integrations/prisma#troubleshooting) or [Prisma's GitHub Discussions](https://github.com/prisma/prisma/discussions) for more help.",
  "title": "Supabase | Prisma Documentation",
  "description": "Guide to Supabase",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/neon",
  "markdown": "# Neon | Prisma Documentation\n\nThis guide explains how to:\n\n*   [Connect Prisma ORM using Neon's connection pooling feature](https://www.prisma.io/docs/orm/overview/databases/neon#how-to-use-neons-connection-pooling)\n*   [Resolve connection timeout issues](https://www.prisma.io/docs/orm/overview/databases/neon#resolving-connection-timeouts)\n*   [Use Neon's serverless driver with Prisma ORM](https://www.prisma.io/docs/orm/overview/databases/neon#how-to-use-neons-serverless-driver-with-prisma-orm-preview)\n\n## What is Neon?[​](https://www.prisma.io/docs/orm/overview/databases/neon#what-is-neon \"Direct link to What is Neon?\")\n\n![Neon's logo](https://avatars.githubusercontent.com/u/77690634?s=200&v=4)\n\n[Neon](https://neon.tech/) is a fully managed serverless PostgreSQL with a generous free tier. Neon separates storage and compute, and offers modern developer features such as serverless, branching, bottomless storage, and more. Neon is open source and written in Rust.\n\nLearn more about Neon [here](https://neon.tech/docs).\n\n## Commonalities with other database providers[​](https://www.prisma.io/docs/orm/overview/databases/neon#commonalities-with-other-database-providers \"Direct link to Commonalities with other database providers\")\n\nMany aspects of using Prisma ORM with Neon are just like using Prisma ORM with any other PostgreSQL database. You can:\n\n*   model your database with the [Prisma Schema Language](https://www.prisma.io/docs/orm/prisma-schema)\n*   use Prisma ORM's [`postgresql` database connector](https://www.prisma.io/docs/orm/overview/databases/postgresql) in your schema, along with the [connection string Neon provides you](https://neon.tech/docs/connect/connect-from-any-app)\n*   use [Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) for existing projects if you already have a database schema on Neon\n*   use [`prisma migrate dev`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production) to track schema migrations in your Neon database\n*   use [`prisma db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) to push changes in your schema to Neon\n*   use [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) in your application to communicate with the database hosted by Neon\n\n## Differences to consider[​](https://www.prisma.io/docs/orm/overview/databases/neon#differences-to-consider \"Direct link to Differences to consider\")\n\nThere are a few differences between Neon and PostgreSQL you should be aware of the following when deciding to use Neon with Prisma ORM:\n\n*   **Neon's serverless model** — By default, Neon scales a [compute](https://neon.tech/docs/introduction/compute-lifecycle) to zero after 5 minutes of inactivity. During this state, a compute instance is in _idle_ state. A characteristic of this feature is the concept of a \"cold start\". Activating a compute from an idle state takes from 500ms to a few seconds. Depending on how long it takes to connect to your database, your application may timeout. To learn more, see: [Connection latency and timeouts](https://neon.tech/docs/guides/prisma#connection-timeouts).\n*   **Neon's connection pooler** — Neon offers connection pooling using PgBouncer, enabling up to 10,000 concurrent connections. To learn more, see: [Connection pooling](https://neon.tech/docs/connect/connection-pooling).\n\n## How to use Neon's connection pooling[​](https://www.prisma.io/docs/orm/overview/databases/neon#how-to-use-neons-connection-pooling \"Direct link to How to use Neon's connection pooling\")\n\nIf you would like to use the [connection pooling](https://neon.tech/docs/guides/prisma#use-connection-pooling-with-prisma) available in Neon, you will need to add `-pooler` in the hostname of your `DATABASE_URL` environment variable used in the `url` property of the `datasource` block of your Prisma schema:\n\n.env\n\n```\n# Connect to Neon with Pooling.DATABASE_URL=postgres://daniel:<password>@ep-mute-rain-952417-pooler.us-east-2.aws.neon.tech:5432/neondb?sslmode=require\n```\n\nIf you would like to use Prisma CLI in order to perform other actions on your database (e.g. for migrations) you will need to add a `DIRECT_URL` environment variable to use in the `directUrl` property of the `datasource` block of your Prisma schema so that the CLI will use a direct connection string (without PgBouncer):\n\n.env\n\n```\n# Connect to Neon with Pooling.DATABASE_URL=postgres://daniel:<password>@ep-mute-rain-952417-pooler.us-east-2.aws.neon.tech/neondb?sslmode=require# Direct connection to the database used by Prisma CLI for e.g. migrations.DIRECT_URL=\"postgres://daniel:<password>@ep-mute-rain-952417.us-east-2.aws.neon.tech/neondb\"\n```\n\nYou can then update your `schema.prisma` to use the new direct URL:\n\nschema.prisma\n\n```\ndatasource db {  provider  = \"postgresql\"  url       = env(\"DATABASE_URL\")  directUrl = env(\"DIRECT_URL\")}\n```\n\nMore information about the `directUrl` field can be found [here](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fields).\n\ninfo\n\nWe strongly recommend using the pooled connection string in your `DATABASE_URL` environment variable. You will gain the great developer experience of the Prisma CLI while also allowing for connections to be pooled regardless of deployment strategy. While this is not strictly necessary for every app, serverless solutions will inevitably require connection pooling.\n\n## Resolving connection timeouts[​](https://www.prisma.io/docs/orm/overview/databases/neon#resolving-connection-timeouts \"Direct link to Resolving connection timeouts\")\n\nA connection timeout that occurs when connecting from Prisma ORM to Neon causes an error similar to the following:\n\n```\nError: P1001: Can't reach database server at `ep-white-thunder-826300.us-east-2.aws.neon.tech`:`5432`Please make sure your database server is running at `ep-white-thunder-826300.us-east-2.aws.neon.tech`:`5432`.\n```\n\nThis error most likely means that the connection created by Prisma Client timed out before the Neon compute was activated.\n\nA Neon compute has two main states: _Active_ and _Idle_. Active means that the compute is currently running. If there is no query activity for 5 minutes, Neon places a compute into an idle state by default. Refer to Neon's docs to [learn more](https://neon.tech/docs/introduction/compute-lifecycle).\n\nWhen you connect to an idle compute from Prisma ORM, Neon automatically activates it. Activation typically happens within a few seconds but added latency can result in a connection timeout. To address this issue, your can adjust your Neon connection string by adding a `connect_timeout` parameter. This parameter defines the maximum number of seconds to wait for a new connection to be opened. The default value is 5 seconds. A higher setting should provide the time required to avoid connection timeout issues. For example:\n\n```\nDATABASE_URL=postgres://daniel:<password>@ep-mute-rain-952417.us-east-2.aws.neon.tech/neondb?connect_timeout=10\n```\n\ninfo\n\nA `connect_timeout` setting of 0 means no timeout.\n\nAnother possible cause of connection timeouts is Prisma ORM's [connection pool](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool), which has a default timeout of 10 seconds. This is typically enough time for Neon, but if you are still experiencing connection timeouts, you can try increasing this limit (in addition to the `connect_timeout` setting described above) by setting the `pool_timeout` parameter to a higher value. For example:\n\n```\nDATABASE_URL=postgres://daniel:<password>@ep-mute-rain-952417.us-east-2.aws.neon.tech/neondb?connect_timeout=15&pool_timeout=15\n```\n\n## How to use Neon's serverless driver with Prisma ORM (Preview)[​](https://www.prisma.io/docs/orm/overview/databases/neon#how-to-use-neons-serverless-driver-with-prisma-orm-preview \"Direct link to How to use Neon's serverless driver with Prisma ORM (Preview)\")\n\nThe [Neon serverless driver](https://github.com/neondatabase/serverless) is a low-latency Postgres driver for JavaScript and TypeScript that allows you to query data from serverless and edge environments over HTTP or WebSockets in place of TCP.\n\nYou can use Prisma ORM along with the Neon serverless driver using a [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters) . A driver adapter allows you to use a different database driver from the default Prisma ORM provides to communicate with your database.\n\ninfo\n\nThis feature is available in Preview from Prisma ORM versions 5.4.2 and later.\n\nTo get started, enable the `driverAdapters` Preview feature flag:\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nGenerate Prisma Client:\n\nInstall the Prisma ORM adapter for Neon, Neon serverless driver and `ws` packages:\n\n```\nnpm install @prisma/adapter-neon @neondatabase/serverless wsnpm install --save-dev @types/ws\n```\n\nUpdate your Prisma Client instance:\n\n```\nimport { Pool, neonConfig } from '@neondatabase/serverless'import { PrismaNeon } from '@prisma/adapter-neon'import { PrismaClient } from '@prisma/client'import dotenv from 'dotenv'import ws from 'ws'dotenv.config()neonConfig.webSocketConstructor = wsconst connectionString = `${process.env.DATABASE_URL}`const pool = new Pool({ connectionString })const adapter = new PrismaNeon(pool)const prisma = new PrismaClient({ adapter })\n```\n\nYou can then use Prisma Client as you normally would with full type-safety. Prisma Migrate, introspection, and Prisma Studio will continue working as before, using the connection string defined in the Prisma schema.\n\n### Notes[​](https://www.prisma.io/docs/orm/overview/databases/neon#notes \"Direct link to Notes\")\n\n#### Specifying a PostgreSQL schema[​](https://www.prisma.io/docs/orm/overview/databases/neon#specifying-a-postgresql-schema \"Direct link to Specifying a PostgreSQL schema\")\n\nYou can specify a [PostgreSQL schema](https://www.postgresql.org/docs/current/ddl-schemas.html) by passing in the `schema` option when instantiating `PrismaNeon`:\n\n```\nconst adapter = new PrismaNeon(pool, {  schema: 'myPostgresSchema'})\n```",
  "title": "Neon | Prisma Documentation",
  "description": "Guide to Neon",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1",
  "markdown": "# Cloudflare D1 | Prisma Documentation\n\nThis guide discusses the concepts behind using Prisma ORM and Cloudflare D1, explains the commonalities and differences between Cloudflare D1 and other database providers, and leads you through the process for configuring your application to integrate with Cloudflare D1.\n\nPrisma ORM support for Cloudflare D1 is currently in [Preview](https://www.prisma.io/docs/orm/more/releases#preview). We would appreciate your feedback [on GitHub](https://github.com/prisma/prisma/discussions/23646).\n\nIf you want to deploy a Cloudflare Worker with D1 and Prisma ORM, follow this [tutorial](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#cloudflare-d1).\n\n## What is Cloudflare D1?[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#what-is-cloudflare-d1 \"Direct link to What is Cloudflare D1?\")\n\nD1 is Cloudflare's native serverless database and was initially [launched in 2022](https://blog.cloudflare.com/introducing-d1). It's based on SQLite and can be used when deploying applications with Cloudflare.\n\nFollowing Cloudflare's principles of geographic distribution and bringing compute and data closer to application users, D1 supports automatic read-replication. It dynamically manages the number of database instances and locations of read-only replicas based on how many queries a database is getting, and from where.\n\nFor write-operations, queries travel to a single primary instance in order to propagate the changes to all read-replicas and ensure data consistency.\n\n## Commonalities with other database providers[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#commonalities-with-other-database-providers \"Direct link to Commonalities with other database providers\")\n\nD1 is based on SQLite.\n\nMany aspects of using Prisma ORM with D1 are just like using Prisma ORM with any other relational database. You can still:\n\n*   model your database with the [Prisma Schema Language](https://www.prisma.io/docs/orm/prisma-schema)\n*   use Prisma ORM's existing [`sqlite` database connector](https://www.prisma.io/docs/orm/overview/databases/sqlite) in your schema\n*   use [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) in your application to talk to the database server at D1\n\n## Differences to consider[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#differences-to-consider \"Direct link to Differences to consider\")\n\nThere are a number of differences between D1 and SQLite to consider. You should be aware of the following when deciding to use D1 and Prisma ORM:\n\n*   **Local and remote D1 (SQLite) databases**. Cloudflare provides local and remote versions of D1. The [local](https://developers.cloudflare.com/d1/configuration/local-development) version is managed using the `--local` option of the `wrangler d1` CLI and is located in `.wrangler/state`. The [remote](https://developers.cloudflare.com/d1/configuration/remote-development) version is managed by Cloudflare and is accessed via HTTP.\n*   **Making schema changes**. Since D1 uses HTTP to connect to the remote database, this makes it incompatible with some commands of Prisma Migrate, like `prisma migrate dev`. However, you can use D1's [migration system](https://developers.cloudflare.com/d1/reference/migrations/) and the [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) command for your migration workflows. See the [Migration workflows](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#migration-workflows) below for more information.\n\n## How to connect to D1 in Cloudflare Workers or Cloudflare Pages[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#how-to-connect-to-d1-in-cloudflare-workers-or-cloudflare-pages \"Direct link to How to connect to D1 in Cloudflare Workers or Cloudflare Pages\")\n\nWhen using Prisma ORM with D1, you need to use the `sqlite` database provider and the `@prisma/adapter-d1` [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters).\n\nIf you want to deploy a Cloudflare Worker with D1 and Prisma ORM, follow these [step-by-step instructions](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#cloudflare-d1).\n\n## Migration workflows[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#migration-workflows \"Direct link to Migration workflows\")\n\nCloudflare D1 comes with its own [migration system](https://developers.cloudflare.com/d1/reference/migrations/). We recommend that you use this migration system via the `wrangler d1 migrations` command to create and manage migration files on your file system.\n\nThis command doesn't help you in figuring out the SQL statements for creating your database schema that need to be put _inside_ of these migration files though. If you want to query your database using Prisma Client, it's important that your database schema maps to your Prisma schema, this is why it's recommended to generate the SQL statements from your Prisma schema.\n\nWhen using D1, you can use the [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) command for that purpose.\n\n### Creating an initial migration[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#creating-an-initial-migration \"Direct link to Creating an initial migration\")\n\nThe workflow for creating an initial migration looks as follows. Assume you have a fresh D1 instance without any tables.\n\n#### 1\\. Update your Prisma data model[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#1-update-your-prisma-data-model \"Direct link to 1. Update your Prisma data model\")\n\nThis is your initial version of the Prisma schema that you want to map to your D1 instance:\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?}\n```\n\n#### 2\\. Create migration file using `wrangler` CLI[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#2-create-migration-file-using-wrangler-cli \"Direct link to 2-create-migration-file-using-wrangler-cli\")\n\nNext, you need to create the migration file using the [`wrangler d1 migrations create`](https://developers.cloudflare.com/workers/wrangler/commands/#migrations-create) command:\n\n```\nnpx wrangler d1 migrations create __YOUR_DATABASE_NAME__ create_user_table\n```\n\nSince this is the very first migration, this command will prompt you to also create a `migrations` folder. Note that if you want your migration files to be stored in a different location, you can [customize it using Wrangler](https://developers.cloudflare.com/d1/reference/migrations/#wrangler-customizations).\n\nOnce the command has executed and assuming you have chosen the default `migrations` name for the location of your migration files, the command has created the following folder and file for you:\n\n```\nmigrations/└── 0001_create_user_table.sql\n```\n\nHowever, before you can apply the migration to your D1 instance, you actually need to put a SQL statement into the currently empty `0001_create_user_table.sql` file.\n\n#### 3\\. Generate SQL statements using `prisma migrate diff`[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#3-generate-sql-statements-using-prisma-migrate-diff \"Direct link to 3-generate-sql-statements-using-prisma-migrate-diff\")\n\nTo generate the initial SQL statement, you can use the `prisma migrate diff` command which compares to _schemas_ (via its `--to-X` and `--from-X` options) and generates the steps that are needed to \"evolve\" from one to the other. These schemas can be either Prisma or SQL schemas.\n\nFor the initial migration, you can use the special `--from-empty` option though:\n\n```\nnpx prisma migrate diff \\  --from-empty \\  --to-schema-datamodel ./prisma/schema.prisma \\  --script \\  --output migrations/0001_create_user_table.sql\n```\n\nThe command above uses the following options:\n\n*   `--from-empty`: The source for the SQL statement is an empty schema.\n*   `--to-schema-datamodel ./prisma/schema.prisma`: The target for the SQL statement is the data model in `./prisma/schema.prisma`.\n*   `--script`: Output the result as SQL. If you omit this option, the \"migration steps\" will be generated in plain English.\n*   `--output migrations/0001_create_user_table.sql`: Store the result in `migrations/0001_create_user_table.sql`.\n\nAfter running this command, `migrations/0001_create_user_table.sql` will have the following contents:\n\nmigrations/0001\\_create\\_user\\_table.sql\n\n```\n-- CreateTableCREATE TABLE \"User\" (    \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,    \"email\" TEXT NOT NULL,    \"name\" TEXT);-- CreateIndexCREATE UNIQUE INDEX \"User_email_key\" ON \"User\"(\"email\");\n```\n\n#### 4\\. Execute the migration using `wrangler d1 migrations apply`[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#4-execute-the-migration-using-wrangler-d1-migrations-apply \"Direct link to 4-execute-the-migration-using-wrangler-d1-migrations-apply\")\n\nFinally, you can apply the migration against your D1 instances.\n\nFor the **local** instance, run:\n\n```\nnpx wrangler d1 migrations apply __YOUR_DATABASE_NAME__ --local\n```\n\nFor the **remote** instance, run:\n\n```\nnpx wrangler d1 migrations apply __YOUR_DATABASE_NAME__ --remote\n```\n\n### Evolve your schema with further migrations[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#evolve-your-schema-with-further-migrations \"Direct link to Evolve your schema with further migrations\")\n\nFor any further migrations, you can use the same workflow but instead of using `--from-empty`, you'll need to use `--from-local-d1` because your source schema for the `prisma migrate diff` command now is the current schema of that local D1 instance, while the target remains your (then updated) Prisma schema.\n\n#### 1\\. Update your Prisma data model[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#1-update-your-prisma-data-model-1 \"Direct link to 1. Update your Prisma data model\")\n\nAssume you have updated your Prisma schema with another model:\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}model Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id])  authorId Int}\n```\n\n#### 2\\. Create migration file using `wrangler` CLI[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#2-create-migration-file-using-wrangler-cli-1 \"Direct link to 2-create-migration-file-using-wrangler-cli-1\")\n\nLike before, you first need to create the migration file:\n\n```\nnpx wrangler d1 migrations create __YOUR_DATABASE_NAME__ create_post_table\n```\n\nOnce the command has executed (again assuming you have chosen the default `migrations` name for the location of your migration files), the command has created a new file inside of the `migrations` folder:\n\n```\nmigrations/├── 0001_create_user_table.sql└── 0002_create_post_table.sql\n```\n\nAs before, you now need to put a SQL statement into the currently empty `0002_create_post_table.sql` file.\n\n#### 3\\. Generate SQL statements using `prisma migrate diff`[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#3-generate-sql-statements-using-prisma-migrate-diff-1 \"Direct link to 3-generate-sql-statements-using-prisma-migrate-diff-1\")\n\nAs explained above, you now need to use `--from-local-d1` instead of `--from-empty` to specify a source schema:\n\n```\nnpx prisma migrate diff \\  --from-local-d1 \\  --to-schema-datamodel ./prisma/schema.prisma \\  --script \\  --output migrations/0002_create_post_table.sql\n```\n\nThe command above uses the following options:\n\n*   `--from-local-d1`: The source for the SQL statement is the local D1 database file.\n*   `--to-schema-datamodel ./prisma/schema.prisma`: The target for the SQL statement is the data model in `./prisma/schema.prisma`.\n*   `--script`: Output the result as SQL. If you omit this option, the \"migration steps\" will be generated in plain English.\n*   `--output migrations/0002_create_post_table.sql`: Store the result in `migrations/0002_create_post_table.sql`.\n\nAfter running this command, `migrations/0002_create_post_table.sql` will have the following contents:\n\nmigrations/0002\\_create\\_post\\_table.sql\n\n```\n-- CreateTableCREATE TABLE \"Post\" (    \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,    \"title\" TEXT NOT NULL,    \"authorId\" INTEGER NOT NULL,    CONSTRAINT \"Post_authorId_fkey\" FOREIGN KEY (\"authorId\") REFERENCES \"User\" (\"id\") ON DELETE RESTRICT ON UPDATE CASCADE);\n```\n\n#### 4\\. Execute the migration using `wrangler d1 migrations apply`[​](https://www.prisma.io/docs/orm/overview/databases/cloudflare-d1#4-execute-the-migration-using-wrangler-d1-migrations-apply-1 \"Direct link to 4-execute-the-migration-using-wrangler-d1-migrations-apply-1\")\n\nFinally, you can apply the migration against your D1 instances.\n\nFor the **local** instance, run:\n\n```\nnpx wrangler d1 migrations apply __YOUR_DATABASE_NAME__ --local\n```\n\nFor the **remote** instance, run:\n\n```\nnpx wrangler d1 migrations apply __YOUR_DATABASE_NAME__ --remote\n```",
  "title": "Cloudflare D1 | Prisma Documentation",
  "description": "Guide to Cloudflare D1",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/overview/data-sources",
  "markdown": "# Data sources (Reference) | Prisma Documentation\n\nA data source determines how Prisma ORM connects your database, and is represented by the [`datasource`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource) block in the Prisma schema. The following data source uses the `postgresql` provider and includes a connection URL:\n\nA Prisma schema can only have _one_ data source. However, you can:\n\nSome data source `provider`s allow you to configure your connection with SSL/TLS, and provide parameters for the `url` to specify the location of certificates.\n\nPrisma ORM resolves SSL certificates relative to the `./prisma` directory. If your certificate files are located outside that directory, e.g. your project root directory, use relative paths for certificates:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public&sslmode=require&sslcert=../server-ca.pem&sslidentity=../client-identity.p12&sslpassword=<REDACTED>\"}\n```",
  "title": "Data sources (Reference) | Prisma Documentation",
  "description": "Data sources enable Prisma to connect to your database. This page explains how to configure data sources in your Prisma schema.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/turso",
  "markdown": "# Turso (Early Access) | Prisma Documentation\n\nThis guide discusses the concepts behind using Prisma ORM and Turso, explains the commonalities and differences between Turso and other database providers, and leads you through the process for configuring your application to integrate with Turso.\n\nPrisma ORM support for Turso is currently in [Early Access](https://www.prisma.io/docs/orm/more/releases#early-access). We would appreciate your feedback in this [GitHub discussion](https://github.com/prisma/prisma/discussions/21345).\n\n## What is Turso?[​](https://www.prisma.io/docs/orm/overview/databases/turso#what-is-turso \"Direct link to What is Turso?\")\n\n![Turso's logo](https://avatars.githubusercontent.com/u/139391156?s=200&v=4)\n\n[Turso](https://turso.tech/) is an edge-hosted, distributed database that's based on [libSQL](https://turso.tech/libsql), an open-source and open-contribution fork of [SQLite](https://sqlite.org/), enabling you to bring data closer to your application and minimize query latency. Turso can also be hosted on a remote server.\n\nwarning\n\nSupport for Turso is available in [Early Access](https://www.prisma.io/docs/orm/more/releases#early-access) from Prisma ORM versions 5.4.2 and later.\n\n## Commonalities with other database providers[​](https://www.prisma.io/docs/orm/overview/databases/turso#commonalities-with-other-database-providers \"Direct link to Commonalities with other database providers\")\n\nlibSQL is 100% compatible with SQLite. libSQL extends SQLite and adds the following features and capabilities:\n\n*   Support for replication\n*   Support for automated backups\n*   Ability to embed Turso as part of other programs such as the Linux kernel\n*   Supports user-defined functions\n*   Support for asynchronous I/O\n\n> To learn more about the differences between libSQL and how it is different from SQLite, see [libSQL Manifesto](https://turso.tech/libsql-manifesto).\n\nMany aspects of using Prisma ORM with Turso are just like using Prisma ORM with any other relational database. You can still:\n\n*   model your database with the [Prisma Schema Language](https://www.prisma.io/docs/orm/prisma-schema)\n*   use Prisma ORM's existing [`sqlite` database connector](https://www.prisma.io/docs/orm/overview/databases/sqlite) in your schema\n*   use [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) in your application to talk to the database server at Turso\n\n## Differences to consider[​](https://www.prisma.io/docs/orm/overview/databases/turso#differences-to-consider \"Direct link to Differences to consider\")\n\nThere are a number of differences between Turso and SQLite to consider. You should be aware of the following when deciding to use Turso and Prisma ORM:\n\n*   **Remote and embedded SQLite databases**. libSQL uses HTTP to connect to the remote SQLite database. libSQL also supports remote database replicas and embedded replicas. Embedded replicas enable you to replicate your primary database inside your application.\n*   **Making schema changes**. Since libSQL uses HTTP to connect to the remote database, this makes it incompatible with Prisma Migrate. However, you can use [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) to create a schema migration and then apply the changes to your database using [Turso's CLI](https://docs.turso.tech/reference/turso-cli).\n\n## How to connect and query a Turso database[​](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-connect-and-query-a-turso-database \"Direct link to How to connect and query a Turso database\")\n\nThe subsequent section covers how you can create a Turso database, retrieve your database credentials and connect to your database.\n\n### How to provision a database and retrieve database credentials[​](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-provision-a-database-and-retrieve-database-credentials \"Direct link to How to provision a database and retrieve database credentials\")\n\ninfo\n\nEnsure that you have the [Turso CLI](https://docs.turso.tech/reference/turso-cli) installed to manage your databases.\n\nIf you don't have an existing database, you can provision a database by running the following command:\n\n```\nturso db create turso-prisma-db\n```\n\nThe above command will create a database in the closest region to your location.\n\nRun the following command to retrieve your database's connection string:\n\n```\nturso db show turso-prisma-db\n```\n\nNext, create an authentication token that will allow you to connect to the database:\n\n```\nturso db tokens create turso-prisma-db\n```\n\nUpdate your `.env` file with the authentication token and connection string:\n\n.env\n\n```\nTURSO_AUTH_TOKEN=\"eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...\"TURSO_DATABASE_URL=\"libsql://turso-prisma-db-user.turso.io\"\n```\n\n### How to connect to a Turso database[​](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-connect-to-a-turso-database \"Direct link to How to connect to a Turso database\")\n\nTo get started, enable the `driverAdapters` Preview feature flag:\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}datasource db {  provider = \"sqlite\"  url      = \"file:./dev.db\"}\n```\n\nGenerate Prisma Client:\n\nInstall the libSQL database client and Prisma ORM driver adapter for libSQL packages:\n\n```\nnpm install @libsql/client @prisma/adapter-libsql\n```\n\nUpdate your Prisma Client instance:\n\n```\nimport { PrismaClient } from '@prisma/client'import { PrismaLibSQL } from '@prisma/adapter-libsql'import { createClient } from '@libsql/client'const libsql = createClient({  url: `${process.env.TURSO_DATABASE_URL}`,  authToken: `${process.env.TURSO_AUTH_TOKEN}`,})const adapter = new PrismaLibSQL(libsql)const prisma = new PrismaClient({ adapter })\n```\n\nYou can use Prisma Client as you normally would with full type-safety in your project.\n\n## How to manage schema changes[​](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-manage-schema-changes \"Direct link to How to manage schema changes\")\n\nPrisma Migrate and Introspection workflows are currently not supported when working with Turso. This is because Turso uses HTTP to connect to your database, which Prisma Migrate doesn't support.\n\nTo update your database schema:\n\n1.  Generate a migration file using `prisma migrate dev` against a local SQLite database:\n    \n    ```\n    npx prisma migrate dev --name init\n    ```\n    \n2.  Apply the migration using Turso's CLI:\n    \n    ```\n    turso db shell turso-prisma-db < ./prisma/migrations/20230922132717_init/migration.sql\n    ```\n    \n    info\n    \n    Replace `20230922132717_init` with the name of your migration.\n    \n\nFor subsequent migrations, repeat the above steps to apply changes to your database. This workflow does not support track the history of applied migrations to your remote database.\n\n## Embedded Turso database replicas[​](https://www.prisma.io/docs/orm/overview/databases/turso#embedded-turso-database-replicas \"Direct link to Embedded Turso database replicas\")\n\nTurso supports [embedded replicas](https://blog.turso.tech/introducing-embedded-replicas-deploy-turso-anywhere-2085aa0dc242). Turso's embedded replicas enable you to have a copy of your primary, remote database _inside_ your application. Embedded replicas behave similarly to a local SQLite database. Database queries are faster because your database is inside your application.\n\n### How embedded database replicas work[​](https://www.prisma.io/docs/orm/overview/databases/turso#how-embedded-database-replicas-work \"Direct link to How embedded database replicas work\")\n\nWhen your app initially establishes a connection to your database, the primary database will fulfill the query:\n\n![Embedded Replica: First remote read](https://www.prisma.io/docs/assets/images/embedded-replica-remote-read-b62442c05d07a6fe77394a8db44611b1.png)\n\nTurso will (1) create an embedded replica inside your application and (2) copy data from your primary database to the replica so it is locally available:\n\n![Embedded Replica: Remote DB Copy](https://www.prisma.io/docs/assets/images/embedded-replica-create-replica-ef2238fff13051650ffb56ca40c2dd44.png)\n\nThe embedded replica will fulfill subsequent read queries. The libSQL client provides a [`sync()`](https://docs.turso.tech/libsql/client-access/javascript-typescript-sdk#client-capability-summary:~:text=an%20interactive%20transaction-,sync(),-Synchronize%20the%20embedded) method which you can invoke to ensure the embedded replica's data remains fresh.\n\n![Embedded Replica: Local DB reads](https://www.prisma.io/docs/assets/images/embedded-replica-read-dc917586761e34261c4eb49fde47faf0.png)\n\nWith embedded replicas, this setup guarantees a responsive application, because the data will be readily available locally and faster to access.\n\nLike a read replica setup you may be familiar with, write operations are forwarded to the primary remote database and executed before being propagated to all embedded replicas.\n\n![Embedded Replica: Write operation propagation](https://www.prisma.io/docs/assets/images/embedded-replica-write-propagation-24051b004c8d48bae1ecf952576275b9.png)\n\n1.  Write operations propagation are forwarded to the database.\n2.  Database responds to the server with the updates from 1.\n3.  Write operations are propagated to the database replica.\n\nYour application's data needs will determine how often you should synchronize data between your remote database and embedded database replica. For example, you can use either middleware functions (e.g. Express and Fastify) or a cron job to synchronize the data.\n\n### How to synchronize data between your remote database and embedded replica[​](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-synchronize-data-between-your-remote-database-and-embedded-replica \"Direct link to How to synchronize data between your remote database and embedded replica\")\n\nTo get started using embedded replicas with Prisma ORM, add the `sync()` method from libSQL in your application. The example below shows how you can synchronize data using Express middleware.\n\n```\nimport express from 'express'const app = express()// ... the rest of your application codeapp.use(async (req, res, next) => {  await libsql.sync()  next()})app.listen(3000, () => console.log(`Server ready at http://localhost:3000`))\n```",
  "title": "Turso (Early Access) | Prisma Documentation",
  "description": "Guide to Turso",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer",
  "markdown": "# Configure Prisma Client with PgBouncer\n\nAn external connection pooler like PgBouncer holds a connection pool to the database, and proxies incoming client connections by sitting between Prisma Client and the database. This reduces the number of processes a database has to handle at any given time.\n\nUsually, this works transparently, but some connection poolers only support a limited set of functionality. One common feature that external connection poolers do not support are named prepared statements, which Prisma ORM uses. For these cases, Prisma ORM can be configured to behave differently.\n\n## PgBouncer[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#pgbouncer \"Direct link to PgBouncer\")\n\n### Set PgBouncer to transaction mode[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#set-pgbouncer-to-transaction-mode \"Direct link to Set PgBouncer to transaction mode\")\n\nFor Prisma Client to work reliably, PgBouncer must run in [**Transaction mode**](https://www.pgbouncer.org/features.html).\n\nTransaction mode offers a connection for every transaction – a requirement for the Prisma Client to work with PgBouncer.\n\n### Add `pgbouncer=true` to the connection URL[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#add-pgbouncertrue-to-the-connection-url \"Direct link to add-pgbouncertrue-to-the-connection-url\")\n\nTo use Prisma Client with PgBouncer, add the `?pgbouncer=true` flag to the PostgreSQL connection URL:\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?pgbouncer=true\n```\n\n> Note: `PORT` specified for PgBouncer pooling is sometimes different from the default `5432` port. Check your database provider docs for the correct port number.\n\nHow `pgbouncer` mode works in Prisma ORM\n\n*   Prisma ORM opens a transaction for every query – even when just reading data, allowing Prisma to use prepared statements.\n*   Prisma ORM does not try to set the `search_path`, which is not supported by PgBouncer.\n*   Prisma ORM cleans up already present prepared statements in the connection by running `DEALLOCATE ALL` before preparing and executing Prisma Client queries.\n*   Prisma ORM also disables any prepared statement or type query caches.\n\n### Prisma Migrate and PgBouncer workaround[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#prisma-migrate-and-pgbouncer-workaround \"Direct link to Prisma Migrate and PgBouncer workaround\")\n\nPrisma Migrate uses **database transactions** to check out the current state of the database and the migrations table. However, the Schema Engine is designed to use a **single connection to the database**, and does not support connection pooling with PgBouncer. If you attempt to run Prisma Migrate commands in any environment that uses PgBouncer for connection pooling, you might see the following error:\n\n```\nError: undefined: Database errorError querying the database: db error: ERROR: prepared statement \"s0\" already exists\n```\n\nTo work around this issue, you must connect directly to the database rather than going through PgBouncer. To achieve this, you can use the [`directUrl`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fields) field in your [`datasource`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource) block.\n\nFor example, consider the following `datasource` block:\n\n```\ndatasource db {  provider  = \"postgresql\"  url       = \"postgres://USER:PASSWORD@HOST:PORT/DATABASE?pgbouncer=true\"  directUrl = \"postgres://USER:PASSWORD@HOST:PORT/DATABASE\"}\n```\n\nThe block above uses a PgBouncer connection string as the primary URL using `url`, allowing Prisma Client to take advantage of the PgBouncer connection pooler.\n\nIt also provides a connection string directly to the database, without PgBouncer, using the `directUrl` field. This connection string will be used when commands that require a single connection to the database, such as `prisma migrate dev` or `prisma db push`, are invoked.\n\n### PgBouncer with different database providers[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#pgbouncer-with-different-database-providers \"Direct link to PgBouncer with different database providers\")\n\nThere are sometimes minor differences in how to connect directly to a Postgres database that depend on the provider hosting the database.\n\nBelow are links to information on how to set up these connections with providers who have setup steps not covered here in our documentation:\n\n*   [Connecting directly to a PostgreSQL database hosted on Digital Ocean](https://github.com/prisma/prisma/issues/6157)\n*   [Connecting directly to a PostgreSQL database hosted on ScaleGrid](https://github.com/prisma/prisma/issues/6701#issuecomment-824387959)\n\n## Supabase Supavisor[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#supabase-supavisor \"Direct link to Supabase Supavisor\")\n\nSupabase's Supavisor behaves similarly to [PgBouncer](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#pgbouncer). You can add `?pgbouncer=true` to your connection pooled connection string available via your [Supabase database settings](https://supabase.com/dashboard/project/_/settings/database).\n\n## Other external connection poolers[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#other-external-connection-poolers \"Direct link to Other external connection poolers\")\n\nAlthough Prisma ORM does not have explicit support for other connection poolers, if the limitations are similar to the ones of [PgBouncer](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer#pgbouncer) you can usually also use `pgbouncer=true` in your connection string to put Prisma ORM in a mode that works with them as well.",
  "title": "Configure Prisma Client with PgBouncer | Prisma Documentation",
  "description": "An external connection pooler like PgBouncer holds a connection pool to the database, and proxies incoming client connections by sitting between Prisma Client and the database. This reduces the number of processes a database has to handle at any given time.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema",
  "markdown": "# Prototyping your schema | Prisma Documentation\n\nThe Prisma CLI has a dedicated command for prototyping schemas: [`db push`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-push)\n\n`db push` uses the same engine as Prisma Migrate to synchronize your Prisma schema with your database schema. The `db push` command:\n\n1.  Introspects the database to infer and executes the changes required to make your database schema reflect the state of your Prisma schema.\n    \n2.  By default, after changes have been applied to the database schema, generators are triggered (for example, Prisma Client). You do not need to manually invoke `prisma generate`.\n    \n3.  If `db push` anticipates that the changes could result in data loss, it will:\n    \n    *   Throw an error\n    *   Require the `--accept-data-loss` option if you still want to make the changes\n\n> **Notes**:\n> \n> *   `db push` does not interact with or rely on migrations. The migrations table `_prisma_migrations` will not be created or updated, and no migration files will be generated.\n> *   When working with PlanetScale, we recommend that you use `db push` instead of `migrate`. For details refer to our Getting Started documentation, either [Start from scratch](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-planetscale) or [Add to existing project](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-planetscale) depending on your situation.\n\n## Choosing `db push` or Prisma Migrate[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema#choosing-db-push-or-prisma-migrate \"Direct link to choosing-db-push-or-prisma-migrate\")\n\n`db push` works well if:\n\n*   You want to **quickly prototype and iterate** on schema design locally without the need to deploy these changes to other environments such as other developers, or staging and production environments.\n*   You are prioritizing reaching a **desired end-state** and not the changes or steps executed to reach that end-state (there is no way to preview changes made by `db push`)\n*   You do not need to control how schema changes impact data. There is no way to orchestrate schema and data migrations—if `db push` anticipates that changes will result in data loss, you can either accept data loss with the `--accept-data-loss` option or stop the process. There is no way to customize the changes.\n\nSee [Schema prototyping with `db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) for an example of how to use `db push` in this way.\n\n`db push` is **not recommended** if:\n\n*   You want to replicate your schema changes in other environments without losing data. You can use `db push` for prototyping, but you should use migrations to commit the schema changes and apply these in your other environments.\n*   You want fine-grained control over how the schema changes are executed - for example, [renaming a column instead of dropping it and creating a new one](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations#example-rename-a-field).\n*   You want to keep track of changes made to the database schema over time. `db push` does not create any artifacts that allow you to keep track of these changes.\n*   You want the schema changes to be reversible. You can use `db push` again to revert to the original state, but this might result in data loss.\n\n## Can I use Prisma Migrate and `db push` together?[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema#can-i-use-prisma-migrate-and-db-push-together \"Direct link to can-i-use-prisma-migrate-and-db-push-together\")\n\nYes, you can [use `db push` and Prisma Migrate together in your development workflow](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) . For example, you can:\n\n*   Use `db push` to prototype a schema at the start of a project and initialize a migration history when you are happy with the first draft\n*   Use `db push` to prototype a change to an existing schema, then run `prisma migrate dev` to generate a migration from your changes (you will be asked to reset)\n\n## Prototyping a new schema[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema#prototyping-a-new-schema \"Direct link to Prototyping a new schema\")\n\nThe following scenario demonstrates how to use `db push` to synchronize a new schema with an empty database, and evolve that schema - including what happens when `db push` detects that a change will result in data loss.\n\n1.  Create a first draft of your schema:\n    \n    ```\n    generator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model User {  id       Int      @id @default(autoincrement())  name     String  jobTitle String  posts    Post[]  profile  Profile?}model Profile {  id       Int    @id @default(autoincrement())  biograpy String // Intentional typo!  userId   Int    @unique  user     User   @relation(fields: [userId], references: [id])}model Post {  id         Int        @id @default(autoincrement())  title      String  published  Boolean    @default(true)  content    String     @db.VarChar(500)  authorId   Int  author     User       @relation(fields: [authorId], references: [id])  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String @db.VarChar(50)  posts Post[]  @@unique([name])}\n    ```\n    \n2.  Use `db push` to push the initial schema to the database:\n    \n3.  Create some example content:\n    \n    ```\n    const add = await prisma.user.create({  data: {    name: 'Eloise',    jobTitle: 'Programmer',    posts: {      create: {        title: 'How to create a MySQL database',        content: 'Some content',      },    },  },})\n    ```\n    \n4.  Make an additive change - for example, create a new required field:\n    \n    ```\n    // ... //model Post {  id          Int        @id @default(autoincrement())  title       String  description String  published   Boolean    @default(true)  content     String     @db.VarChar(500)  authorId    Int  author      User       @relation(fields: [authorId], references: [id])  categories  Category[]}// ... //\n    ```\n    \n5.  Push the changes:\n    \n    `db push` will prompt you to reset because you cannot add a required field to a table with existing content unless you provide a default value:\n    \n    ```\n    ⚠️ We found changes that cannot be executed:• Added the required column `description` to the `Post` table without a default value. There are 2 rows in this table, it is not possible to execute this.? To apply this step we need to reset the database, do you want to continue? All data will be lost. » (y/N)\n    ```\n    \n\ntip\n\nUse the `--accept-data-loss` flag to skip this warning, or `--force-reset` to ignore all warnings.\n\n6.  Confirm data loss and apply changes to your database (or revisit your schema):\n    \n    ```\n     There might be data loss when applying the changes: • Added the required column `description` to the `Post` table without a default value. ? Do you want to ignore the warning(s)? Some data will be lost. » (y/N)\n    ```\n    \n    > **Note**: Unlike Prisma Migrate, `db push` does not generate migrations that you can modify to preserve data, and is therefore best suited for prototyping in a development environment.\n    \n7.  Continue to evolve your schema until it reaches a relatively stable state.\n    \n8.  Initialize a migration history:\n    \n    ```\n    npx prisma migrate dev --name initial-state\n    ```\n    \n    The steps taken to reach the initial prototype are not preserved - `db push` does not generate a history.\n    \n9.  Push your migration history and Prisma schema to source control (e.g. Git).\n    \n\nAt this point, the final draft of your prototyping is preserved in a migration and can be pushed to other environments (testing, production, or other members of your team).\n\n## Prototyping with an existing migration history[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema#prototyping-with-an-existing-migration-history \"Direct link to Prototyping with an existing migration history\")\n\nThe following scenario demonstrates how to use `db push` to prototype a change to a Prisma schema where a migration history already exists.\n\n1.  Check out the latest Prisma schema and migration history:\n    \n    ```\n    generator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model User {  id       Int      @id @default(autoincrement())  name     String  jobTitle String  posts    Post[]  profile  Profile?}model Profile {  id       Int    @id @default(autoincrement())  biograpy String // Intentional typo!  userId   Int    @unique  user     User   @relation(fields: [userId], references: [id])}model Post {  id         Int        @id @default(autoincrement())  title      String  published  Boolean    @default(true)  content    String     @db.VarChar(500)  authorId   Int  author     User       @relation(fields: [authorId], references: [id])  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String @db.VarChar(50)  posts Post[]  @@unique([name])}\n    ```\n    \n2.  Prototype your new feature, which can involve any number of steps. For example, you might:\n    \n    *   Create a `tags String[]` field, then run `db push`\n    *   Change the field type to `tags Tag[]` and add a new model named `Tag`, then run `db push`\n    *   Change your mind and restore the original `tags String[]` field, then call `db push`\n    *   Make a manual change to the `tags` field in the database - for example, adding a constraint\n    \n    After experimenting with several solutions, the final schema change looks like this:\n    \n    ```\n    model Post {  id          Int        @id @default(autoincrement())  title       String  description String  published   Boolean    @default(true)  content     String     @db.VarChar(500)  authorId    Int  author      User       @relation(fields: [authorId], references: [id])  categories  Category[]  tags        String[]}\n    ```\n    \n3.  To create a migration that adds the new `tags` field, run the `migrate dev` command:\n    \n    ```\n    npx prisma migrate dev --name added-tags\n    ```\n    \n    Prisma Migrate will prompt you to reset because the changes you made manually and with `db push` while prototyping are not part of the migration history:\n    \n    ```\n    √ Drift detected: Your database schema is not in sync with your migration history.We need to reset the PostgreSQL database \"prototyping\" at \"localhost:5432\".Do you want to continue? All data will be lost. ... yes\n    ```\n    \n4.  Prisma Migrate replays the existing migration history, generates a new migration based on your schema changes, and applies those changes to the database.\n    \n\ntip\n\nWhen using `migrate dev`, if your schema changes mean that seed scripts will no longer work, you can use the `--skip-seed` flag to ignore seed scripts.\n\nAt this point, the final result of your prototyping is preserved in a migration, and can be pushed to other environments (testing, production, or other members of your team).",
  "title": "Prototyping your schema | Prisma Documentation",
  "description": "Prototyping your schema",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool",
  "markdown": "# Connection pool | Prisma Documentation\n\nThe query engine manages a **connection pool** of database connections. The pool is created when Prisma Client opens the _first_ connection to the database, which can happen in one of two ways:\n\n*   By [explicitly calling `$connect()`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#connect) _or_\n*   By running the first query, which calls `$connect()` under the hood\n\nRelational database connectors use Prisma ORM's own connection pool, and the MongoDB connectors uses the [MongoDB driver connection pool](https://github.com/mongodb/specifications/blob/master/source/connection-monitoring-and-pooling/connection-monitoring-and-pooling.rst).\n\n## Relational databases[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#relational-databases \"Direct link to Relational databases\")\n\nThe relational database connectors use Prisma ORM's connection pool. The connection pool has a **connection limit** and a **pool timeout**, which are controlled by connection URL parameters.\n\n### How the connection pool works[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#how-the-connection-pool-works \"Direct link to How the connection pool works\")\n\nThe following steps describe how the query engine uses the connection pool:\n\n1.  The query engine instantiates a connection pool with a [configurable pool size](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#setting-the-connection-pool-size) and [pool timeout](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#setting-the-connection-pool-timeout).\n2.  The query engine creates one connection and adds it to the connection pool.\n3.  When a query comes in, the query engine reserves a connection from the pool to process query.\n4.  If there are no idle connections available in the connection pool, the query engine opens additional database connections and adds them to the connection pool until the number of database connections reaches the limit defined by `connection_limit`.\n5.  If the query engine cannot reserve a connection from the pool, queries are added to a FIFO (First In First Out) queue in memory. FIFO means that queries are processed in the order they enter the queue.\n6.  If the query engine cannot process a query in the queue for **before the [time limit](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#default-pool-timeout)**, it throws an exception with error code `P2024` for that query and moves on to the next one in the queue.\n\nIf you consistently experience pool timeout errors, you need to [optimize the connection pool](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool) .\n\n### Connection pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#connection-pool-size \"Direct link to Connection pool size\")\n\n#### Default connection pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#default-connection-pool-size \"Direct link to Default connection pool size\")\n\nThe default number of connections (pool size) is calculated with the following formula:\n\n```\nnum_physical_cpus * 2 + 1\n```\n\n`num_physical_cpus` represents the number of physical CPUs on the machine your application is running on. If your machine has **four** physical CPUs, your connection pool will contain **nine** connections (`4 * 2 + 1 = 9`).\n\nAlthough the formula represents a good starting point, the [recommended connection limit](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#recommended-connection-pool-size) also depends on your deployment paradigm - particularly if you are using serverless.\n\n#### Setting the connection pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#setting-the-connection-pool-size \"Direct link to Setting the connection pool size\")\n\nYou can specify the number of connections by explicitly setting the `connection_limit` parameter in your database connection URL. For example, with the following `datasource` configuration in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) the connection pool will have exactly five connections:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5\"}\n```\n\n#### Viewing the connection pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#viewing-the-connection-pool-size \"Direct link to Viewing the connection pool size\")\n\nThe number of connections Prisma Client uses can be viewed using [logging](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging) and [metrics](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics).\n\nUsing the `info` [logging level](https://www.prisma.io/docs/orm/reference/prisma-client-reference#log-levels), you can log the number of connections in a connection pool that are opened when Prisma Client is instantiated.\n\nFor example, consider the following Prisma Client instance and invocation:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient({  log: ['info'],})async function main() {  await prisma.user.findMany()}main()\n```\n\nWhen the `PrismaClient` class was instantiated, the logging notified `stdout` that a connection pool with 21 connections was started.\n\nwarning\n\nNote that the output generated by `log: ['info']` can change in any release without notice. Be aware of this in case you are relying on the output in your application or a tool that you're building.\n\nIf you need even more insights into the size of your connection pool and the amount of in-use and idle connection, you can use the [metrics](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics) feature (which is currently in Preview).\n\nConsider the following example:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  await Promise.all([prisma.user.findMany(), prisma.post.findMany()])  const metrics = await prisma.$metrics.json()  console.dir(metrics, { depth: Infinity })}main()\n```\n\ninfo\n\nFor more details on what is available in the metrics output, see the [About metrics](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics#about-metrics) section.\n\n### Connection pool timeout[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#connection-pool-timeout \"Direct link to Connection pool timeout\")\n\n#### Default pool timeout[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#default-pool-timeout \"Direct link to Default pool timeout\")\n\nThe default connection pool timeout is 10 seconds. If the Query Engine does not get a connection from the database connection pool within that time, it throws an exception and moves on to the next query in the queue.\n\n#### Setting the connection pool timeout[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#setting-the-connection-pool-timeout \"Direct link to Setting the connection pool timeout\")\n\nYou can specify the pool timeout by explicitly setting the `pool_timeout` parameter in your database connection URL. In the following example, the pool times out after `2` seconds:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5&pool_timeout=2\"}\n```\n\n#### Disabling the connection pool timeout[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#disabling-the-connection-pool-timeout \"Direct link to Disabling the connection pool timeout\")\n\nYou disable the connection pool timeout by setting the `pool_timeout` parameter to `0`:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5&pool_timeout=0\"}\n```\n\nYou can choose to [disable the connection pool timeout if queries **must** remain in the queue](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#disabling-the-pool-timeout) - for example, if you are importing a large number of records in parallel and are confident that the queue will not use up all available RAM before the job is complete.\n\n## MongoDB[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#mongodb \"Direct link to MongoDB\")\n\nThe MongoDB connector does not use the Prisma ORM connection pool. The connection pool is managed internally by the MongoDB driver and [configured via connection string parameters](https://docs.mongodb.com/manual/reference/connection-string/#connection-pool-options).\n\n## External connection poolers[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#external-connection-poolers \"Direct link to External connection poolers\")\n\nYou cannot increase the `connection_limit` beyond what the underlying database can support. This is a particular challenge in serverless environments, where each function manages an instance of `PrismaClient` - and its own connection pool.\n\nConsider introducing [an external connection pooler like PgBouncer](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#pgbouncer) to prevent your application or functions from exhausting the database connection limit.\n\n## Manual database connection handling[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#manual-database-connection-handling \"Direct link to Manual database connection handling\")\n\nWhen using Prisma ORM, the database connections are handled on an [engine](https://github.com/prisma/prisma-engines)\\-level. This means they're not exposed to the developer and it's not possible to manually access them.",
  "title": "Connection pool | Prisma Documentation",
  "description": "Prisma ORM's query engine creates a connection pool to store and manage database connections.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features",
  "markdown": "# Prisma schema: Unsupported database features\n\nNot all database functions and features of Prisma ORM's supported databases have a Prisma Schema Language equivalent. Refer to the [database features matrix](https://www.prisma.io/docs/orm/reference/database-features) for a complete list of supported features.\n\n## Native database functions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#native-database-functions \"Direct link to Native database functions\")\n\nPrisma Schema Language supports several [functions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#attribute-functions) that you can use to set the default value of a field. The following example uses the Prisma ORM-level `uuid()` function to set the value of the `id` field:\n\n```\nmodel Post {  id String @id @default(uuid())}\n```\n\nHowever, you can also use **native database functions** to define default values with [`dbgenerated(...)`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#dbgenerated) on relational databases (MongoDB does not have the concept of database-level functions). The following example uses the PostgreSQL `gen_random_uuid()` function to populate the `id` field:\n\n```\nmodel User {  id String @id @default(dbgenerated(\"gen_random_uuid()\")) @db.Uuid}\n```\n\n### When to use a database-level function[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#when-to-use-a-database-level-function \"Direct link to When to use a database-level function\")\n\nThere are two reasons to use a database-level function:\n\n*   There is no equivalent Prisma ORM function (for example, `gen_random_bytes` in PostgreSQL).\n    \n*   You cannot or do not want to rely on functions such `uuid()` and `cuid()`, which are only implemented at a Prisma ORM level and do not manifest in the database.\n    \n    Consider the following example, which sets the `id` field to a randomly generated `UUID`:\n    \n    ```\n    model Post {  id String @id @default(uuid())}\n    ```\n    \n    The UUID is _only_ generated if you use Prisma Client to create the `Post`. If you create posts in any other way, such as a bulk import script written in plain SQL, you must generate the UUID yourself.\n    \n\n### Enable PostgreSQL extensions for native database functions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#enable-postgresql-extensions-for-native-database-functions \"Direct link to Enable PostgreSQL extensions for native database functions\")\n\nIn PostgreSQL, some native database functions are part of an extension. For example, in PostgreSQL versions 12.13 and earlier, the `gen_random_uuid()` function is part of the [`pgcrypto`](https://www.postgresql.org/docs/10/pgcrypto.html) extension.\n\nTo use a PostgreSQL extension, you must first install it on the file system of your database server.\n\nIn Prisma ORM versions 4.5.0 and later, you can then activate the extension by declaring it in your Prisma schema with the [`postgresqlExtensions` preview feature](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions):\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"postgresqlExtensions\"]}datasource db {  provider   = \"postgresql\"  url        = env(\"DATABASE_URL\")  extensions = [pgcrypto]}\n```\n\nIn earlier versions of Prisma ORM, you must instead run a SQL command to activate the extension:\n\n```\nCREATE EXTENSION IF NOT EXISTS pgcrypto;\n```\n\nIf your project uses [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate), you must [install the extension as part of a migration](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-functions) . Do not install the extension manually, because it is also required by the shadow database.\n\nPrisma Migrate returns the following error if the extension is not available:\n\n```\nMigration `20210221102106_failed_migration` failed to apply cleanly to a temporary database.Database error: Error querying the database: db error: ERROR: type \"pgcrypto\" does not exist\n```\n\n## Unsupported field types[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#unsupported-field-types \"Direct link to Unsupported field types\")\n\nSome database types of relational databases, such as `polygon` or `geometry`, do not have a Prisma Schema Language equivalent. Use the [`Unsupported`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unsupported) field type to represent the field in your Prisma schema:\n\n```\nmodel Star {  id       Int                    @id @default(autoincrement())  position Unsupported(\"circle\")? @default(dbgenerated(\"'<(10,4),11>'::circle\"))}\n```\n\nThe `prisma migrate dev` and `prisma db push` command will both create a `position` field of type `circle` in the database. However, the field will not be available in the generated Prisma Client.\n\n## Unsupported database features[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#unsupported-database-features \"Direct link to Unsupported database features\")\n\nSome features, like SQL views or partial indexes, cannot be represented in the Prisma schema. If your project uses [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate), you must [include unsupported features as part of a migration](https://www.prisma.io/docs/orm/prisma-migrate/workflows/unsupported-database-features) .",
  "title": "Prisma schema: Unsupported database features | Prisma Documentation",
  "description": "How to support database features that do not have an equivalent syntax in Prisma Schema Language.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/under-the-hood/engines",
  "markdown": "# Engines | Prisma Documentation\n\nFrom a technical perspective, Prisma Client consists of three major components:\n\n*   JavaScript client library\n*   TypeScript type definitions\n*   A query engine\n\nAll of these components are located in the [generated `.prisma/client` folder](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) after you ran `prisma generate`.\n\nThis page covers relevant technical details about the query engine.\n\n## Prisma engines[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#prisma-engines \"Direct link to Prisma engines\")\n\nAt the core of each module, there typically is a [Prisma engine](https://github.com/prisma/prisma-engines) that implements the core set of functionality. Engines are implemented in [Rust](https://www.rust-lang.org/) and expose a low-level API that is used by the higher-level interfaces.\n\nA Prisma engine is the **direct interface to the database**, any higher-level interfaces always communicate with the database _through_ the engine-layer.\n\nAs an example, Prisma Client connects to the [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines) in order to read and write data in a database:\n\n![Prisma engine](https://www.prisma.io/docs/assets/images/typical-flow-query-engine-at-runtime-73ffdee4acc20a853bbd431dc12fb64f.png)\n\n### Using custom engine libraries or binaries[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#using-custom-engine-libraries-or-binaries \"Direct link to Using custom engine libraries or binaries\")\n\nBy default, all engine files are automatically downloaded into the `node_modules/@prisma/engines` folder when you install or update `prisma`, the Prisma CLI package. The [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines) is also copied to the generated Prisma Client when you call `prisma generate`. You might want to use a [custom library or binary](https://github.com/prisma/prisma-engines) file if:\n\n*   Automated download of engine files is not possible.\n*   You have created your own engine library or binary for testing purposes, or for an OS that is not officially supported.\n\nUse the following environment variables to specify custom locations for your binaries:\n\n*   [`PRISMA_QUERY_ENGINE_LIBRARY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_query_engine_library) (Query engine, library)\n*   [`PRISMA_QUERY_ENGINE_BINARY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_query_engine_binary) (Query engine, binary)\n*   [`PRISMA_SCHEMA_ENGINE_BINARY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_schema_engine_binary) (Schema engine)\n*   [`PRISMA_MIGRATION_ENGINE_BINARY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_migration_engine_binary) (Migration engine)\n*   [`PRISMA_INTROSPECTION_ENGINE_BINARY`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_introspection_engine_binary) (Introspection engine)\n\nwarning\n\n*   `PRISMA_MIGRATION_ENGINE_BINARY` variable is deprecated in [5.0.0](https://github.com/prisma/prisma/releases/tag/5.0.0).\n*   The Introspection Engine is served by the Migration Engine from [4.9.0](https://github.com/prisma/prisma/releases/tag/4.9.0). Therefore, the `PRISMA_INTROSPECTION_ENGINE` environment variable will not be used.\n*   The `PRISMA_FMT_BINARY` variable is used in versions [4.2.0](https://github.com/prisma/prisma/releases/tag/4.2.0) or lower.\n\n#### Setting the environment variable[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#setting-the-environment-variable \"Direct link to Setting the environment variable\")\n\nYou can define environment variables globally on your machine or in the `.env` file.\n\n##### a) The `.env` file[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#a-the-env-file \"Direct link to a-the-env-file\")\n\nAdd the environment variable to the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files).\n\n*   Linux, Unix, MacOS\n*   Windows\n\n```\nPRISMA_QUERY_ENGINE_BINARY=custom/my-query-engine-unix\n```\n\n> **Note**: It is possible to [use an `.env` file in a location outside the `prisma` folder](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/managing-env-files-and-setting-variables).\n\n##### b) Global environment variable[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#b-global-environment-variable \"Direct link to b) Global environment variable\")\n\nRun the following command to set the environment variable globally (in this example, `PRISMA_QUERY_ENGINE_BINARY`):\n\n*   Linux, Unix, MacOS\n*   Windows\n\n```\nexport PRISMA_QUERY_ENGINE_BINARY=/custom/my-query-engine-unix\n```\n\n#### Test your environment variable[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#test-your-environment-variable \"Direct link to Test your environment variable\")\n\nRun the following command to output the paths to all binaries:\n\nThe output shows that the query engine path comes from the `PRISMA_QUERY_ENGINE_BINARY` environment variable:\n\n*   Linux, Unix, MacOS\n*   Windows\n\n```\nCurrent platform     : darwinQuery Engine         : query-engine d6ff7119649922b84e413b3b69660e2f49e2ddf3 (at /custom/my-query-engine-unix)Migration Engine     : migration-engine-cli d6ff7119649922b84e413b3b69660e2f49e2ddf3 (at /myproject/node_modules/@prisma/engines/migration-engine-unix)Introspection Engine : introspection-core d6ff7119649922b84e413b3b69660e2f49e2ddf3 (at /myproject/node_modules/@prisma/engines/introspection-engine-unix)\n```\n\n### Hosting engines[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#hosting-engines \"Direct link to Hosting engines\")\n\nThe [`PRISMA_ENGINES_MIRROR`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_engines_mirror) environment variable allows you to host engine files via a private server, AWS bucket or other cloud storage. This can be useful if you have a custom OS that requires custom-built engines.\n\n```\nPRISMA_ENGINES_MIRROR=https://my-aws-bucket\n```\n\n## The query engine file[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#the-query-engine-file \"Direct link to The query engine file\")\n\nThe **query engine file** is different for each operating system. It is named `query-engine-PLATFORM` or `libquery_engine-PLATFORM` where `PLATFORM` corresponds to the name of a compile target. Query engine file extensions depend on the platform as well. As an example, if the query engine must run on a [Darwin](https://en.wikipedia.org/wiki/Darwin_(operating_system)) operating system such as macOS Intel, it is called `libquery_engine-darwin.dylib.node` or `query-engine-darwin`. You can find an overview of all supported platforms [here](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#binarytargets-options).\n\nThe query engine file is downloaded into the `runtime` directory of the generated Prisma Client when `prisma generate` is called.\n\nNote that the query engine is implemented in Rust. The source code is located in the [`prisma-engines`](https://github.com/prisma/prisma-engines/) repository.\n\n## The query engine at runtime[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#the-query-engine-at-runtime \"Direct link to The query engine at runtime\")\n\nBy default, Prisma Client loads the query engine as a [Node-API library](https://nodejs.org/api/n-api.html). You can alternatively [configure Prisma to use the query engine compiled as an executable binary](https://www.prisma.io/docs/orm/more/under-the-hood/engines#configuring-the-query-engine), which is run as a sidecar process alongside your application. The Node-API library approach is recommended since it reduces the communication overhead between Prisma Client and the query engine.\n\n![Diagram showing the query engine and Node.js at runtime](https://www.prisma.io/docs/assets/images/query-engine-node-js-at-runtime-462396e7623f826c6b070819fd061c92.png)\n\nThe query engine is started when the first Prisma Client query is invoked or when the [`$connect()`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management) method is called on your `PrismaClient` instance. Once the query engine is started, it creates a [connection pool](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool) and manages the physical connections to the database. From that point onwards, Prisma Client is ready to send [queries](https://www.prisma.io/docs/orm/prisma-client/queries/crud) to the database (e.g. `findUnique()`, `findMany`, `create`, ...).\n\nThe query engine is stopped and the database connections are closed when [`$disconnect()`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management) is invoked.\n\nThe following diagram depicts a \"typical flow\":\n\n1.  `$connect()` is invoked on Prisma Client\n2.  The query engine is started\n3.  The query engine establishes connections to the database and creates connection pool\n4.  Prisma Client is now ready to send queries to the database\n5.  Prisma Client sends a `findMany()` query to the query engine\n6.  The query engine translates the query into SQL and sends it to the database\n7.  The query engine receives the SQL response from the database\n8.  The query engine returns the result as plain old JavaScript objects to Prisma Client\n9.  `$disconnect()` is invoked on Prisma Client\n10.  The query engine closes the database connections\n11.  The query engine is stopped\n\n![Typical flow of the query engine at run time](https://www.prisma.io/docs/assets/images/typical-flow-query-engine-at-runtime-73ffdee4acc20a853bbd431dc12fb64f.png)\n\n## Responsibilities of the query engine[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#responsibilities-of-the-query-engine \"Direct link to Responsibilities of the query engine\")\n\nThe query engine has the following responsibilities in an application that uses Prisma Client:\n\n*   manage physical database connections in connection pool\n*   receive incoming queries from the Prisma Client Node.js process\n*   generate SQL queries\n*   send SQL queries to the database\n*   process responses from the database and send them back to Prisma Client\n\n## Debugging the query engine[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#debugging-the-query-engine \"Direct link to Debugging the query engine\")\n\nYou can access the logs of the query engine by setting the [`DEBUG`](https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/debugging) environment variable to `engine`:\n\nYou can also get more visibility into the SQL queries that are generated by the query engine by setting the [`query` log level](https://www.prisma.io/docs/orm/reference/prisma-client-reference#log-levels) in Prisma Client:\n\n```\nconst prisma = new PrismaClient({  log: ['query'],})\n```\n\nLearn more about [Debugging](https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/debugging) and [Logging](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging).\n\n## Configuring the query engine[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#configuring-the-query-engine \"Direct link to Configuring the query engine\")\n\n### Defining the query engine type for Prisma Client[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#defining-the-query-engine-type-for-prisma-client \"Direct link to Defining the query engine type for Prisma Client\")\n\n[As described above](https://www.prisma.io/docs/orm/more/under-the-hood/engines#the-query-engine-at-runtime) the default query engine is a Node-API library that is loaded into Prisma Client, but there is also an alternative implementation as an executable binary that runs in its own process. You can configure the query engine type by providing the `engineType` property to the Prisma Client `generator`:\n\n```\ngenerator client {  provider   = \"prisma-client-js\"  engineType = \"binary\"}\n```\n\nValid values for `engineType` are `binary` and `library`. You can also use the environment variable [`PRISMA_CLIENT_ENGINE_TYPE`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_client_engine_type) instead.\n\ninfo\n\n*   Until Prisma 3.x the default and only engine type available was `binary`, so there was no way to configure the engine type to be used by Prisma Client and Prisma CLI.\n*   From versions [2.20.0](https://github.com/prisma/prisma/releases/2.20.0) to 3.x the `library` engine type was available and used by default by [activating the preview feature flag](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature) \"`nApi`\" or using the `PRISMA_FORCE_NAPI=true` environment variable.\n\n### Defining the query engine type for Prisma CLI[​](https://www.prisma.io/docs/orm/more/under-the-hood/engines#defining-the-query-engine-type-for-prisma-cli \"Direct link to Defining the query engine type for Prisma CLI\")\n\nPrisma CLI also uses its own query engine for its own needs. You can configure it to use the binary version of the query engine by defining the environment variable [`PRISMA_CLI_QUERY_ENGINE_TYPE=binary`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_cli_query_engine_type).",
  "title": "Engines | Prisma Documentation",
  "description": "Prisma's query engine manages the communication with the database when using Prisma Client. Learn how it works on this page.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/accelerate/connection-pooling",
  "markdown": "# Accelerate: Connection Pooling | Prisma Documentation\n\nA [connection pool](https://en.wikipedia.org/wiki/Connection_pool#:~:text=In%20software%20engineering%2C%20a%20connection,executing%20commands%20on%20a%20database.) is a storage of database connections that can be reused for future requests to the database. When a new connection is requested, it is retrieved from the pool if one is available. Once the connection is no longer needed, it is returned to the pool for reuse.\n\n[Connection pooling](https://www.prisma.io/dataguide/database-tools/connection-pooling) is important as it allows you to reuse existing connections instead of creating new ones, which can be an expensive operation.\n\nThe efficient management of database connections allows the database to process more queries without exhausting the available database connections, making your application more scalable.\n\nAccelerate provides built-in connection pooling by default. By simply using Accelerate, you get the benefits of connection pooling without having to configure anything. However, you can also configure the connection pool to suit your needs.\n\ninfo\n\nFor more information about connection pooling in Prisma, see the documentation [here](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool).\n\n### Default connection pool size[​](https://www.prisma.io/docs/accelerate/connection-pooling#default-connection-pool-size \"Direct link to Default connection pool size\")\n\nAccelerate has a default `connection_limit` set to `10`.\n\n### Configuring the connection pool size[​](https://www.prisma.io/docs/accelerate/connection-pooling#configuring-the-connection-pool-size \"Direct link to Configuring the connection pool size\")\n\nThe connection pool size can be configured via the _database connection string_ in your Platform project (_not_ the Accelerate connection string in your Prisma schema) via the `connection_limit` parameter. For example, set a connection pool size of `10` like this: `postgresql://USER:PASSWORD@HOST:PORT/DATABASE?connection_limit=10`.\n\nIf nothing is configured, a default value will be used.\n\nTo change the size of the connection pool:\n\n1.  Open the [Console](https://console.prisma.io/).\n2.  Select the _project_ in which you're using Accelerate. You might need to select a different _workspace_ if you can't see your project.\n3.  Select the _environment_ where you want to configure Accelerate's connection pool size.\n4.  Update the connection string by appending the `connection_limit` argument.\n\n![Update database connection string in Accelerate](https://www.prisma.io/docs/assets/images/accelerate-update-database-connection-string-634414bdbfa0f5e505ab8eb614d960ea.png)\n\n### Configuring the connection pool timeout[​](https://www.prisma.io/docs/accelerate/connection-pooling#configuring-the-connection-pool-timeout \"Direct link to Configuring the connection pool timeout\")\n\nThe connection pool timeout is the maximum number of seconds that a query will block while waiting for a connection from Accelerate's internal connection pool. This occurs if the number of concurrent requests exceeds the connection limit, resulting in queueing of additional requests until a free connection becomes available. An exception is thrown if a free connection does not become available within the pool timeout. The connection pool timeout can be disabled by setting the value to 0.\n\nSimilar to the connection pool size, you may also configure the connection pool timeout via the _database connection string_. To adjust this value, you may add the `pool_timeout` parameter to the database connection string.\n\nFor example:\n\n```\npostgresql://user:password@localhost:5432/db?connection_limit=10&pool_timeout=20\n```\n\ninfo\n\nThe default value for `pool_timeout` is `10` seconds.",
  "title": "Accelerate: Connection Pooling | Prisma Documentation",
  "description": "Learn about everything you need to know to use Accelerate's connection pooling.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/accelerate/limitations",
  "markdown": "# Accelerate: Limitations | Prisma Documentation\n\nBelow are descriptions of known limitations when using Accelerate. If you encounter any additional ones, please share them with us via [Discord](https://pris.ly/discord).\n\n## Query timeout limit[​](https://www.prisma.io/docs/accelerate/limitations#query-timeout-limit \"Direct link to Query timeout limit\")\n\nAccelerate has a global timeout of `10s` for each query. Reach out to [support@prisma.io](mailto:support@prisma.io) with your use case if your application requires a greater timeout value.\n\n> Also see the [troubleshooting guide](https://www.prisma.io/docs/accelerate/troubleshoot#p6004-querytimeout) for more information.\n\n## Interactive transactions query timeout limit[​](https://www.prisma.io/docs/accelerate/limitations#interactive-transactions-query-timeout-limit \"Direct link to Interactive transactions query timeout limit\")\n\nAccelerate has a global timeout of `15s` for each [interactive transaction](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions). Reach out to [support@prisma.io](mailto:support@prisma.io) with your use case if your application requires a greater timeout value.\n\n## Response size limit[​](https://www.prisma.io/docs/accelerate/limitations#response-size-limit \"Direct link to Response size limit\")\n\nAccelerate has a global response size limit of `5MB`. Reach out to [support@prisma.io](mailto:support@prisma.io) with your use case if your application requires a larger response size.\n\n> Also see the [troubleshooting guide](https://www.prisma.io/docs/accelerate/troubleshoot#p6009-responsesizelimitexceeded) for more information.\n\n## Cannot cache raw queries[​](https://www.prisma.io/docs/accelerate/limitations#cannot-cache-raw-queries \"Direct link to Cannot cache raw queries\")\n\nAt the moment, it is not possible to cache the responses of [raw queries](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries).\n\n## Not compatible with the fluent API[​](https://www.prisma.io/docs/accelerate/limitations#not-compatible-with-the-fluent-api \"Direct link to Not compatible with the fluent API\")\n\nClient Extensions (which are used in Accelerate) currently do not correctly forward the [fluent API](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api) types. We hope to get a fix into Client Extensions soon.",
  "title": "Accelerate: Limitations | Prisma Documentation",
  "description": "Learn about limitations of Accelerate.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/accelerate/caching",
  "markdown": "# Accelerate: Caching | Prisma Documentation\n\n## Cache strategies[​](https://www.prisma.io/docs/accelerate/caching#cache-strategies \"Direct link to Cache strategies\")\n\nFor all read queries in Prisma Client, you can define the `cacheStrategy` parameter that configures cache behavior. The cache strategy allows you to define two main characteristics of the cache:\n\n*   **Time-to-live (TTL):** Duration in seconds a cached response is considered _fresh_.\n*   **Stale-while-Revalidating (SWR):** Duration in seconds a stale cache response is considered acceptable while the cache is refreshed in the background\n\n## Time-to-live (TTL)[​](https://www.prisma.io/docs/accelerate/caching#time-to-live-ttl \"Direct link to Time-to-live (TTL)\")\n\nTime-to-Live (TTL) determines how long cached data is considered fresh. By specifying the `ttl` in seconds, you can control the duration for which data in the cache remains valid. When a read query is executed, if the cached response is within the `ttl` limit, Prisma Client retrieves the data from the cache without querying the database. If the cached data is not available or has expired, Prisma Client queries the database and stores the results in the cache for future requests.\n\nUse `ttl` in `cacheStrategy` and specify the TTL of the query in seconds:\n\n```\nawait prisma.user.findMany({  cacheStrategy: {    ttl: 60,  },});\n```\n\nWith a specified TTL of 60 seconds, the majority of requests will result in a cache hit throughout the TTL duration:\n\n![TTL](https://www.prisma.io/docs/assets/images/ttl-dafc2425fa18173f433138b62b89d656.png)\n\nTTL is useful for reducing database load and latency for data that does not require frequent updates.\n\n## Stale-While-Revalidate (SWR)[​](https://www.prisma.io/docs/accelerate/caching#stale-while-revalidate-swr \"Direct link to Stale-While-Revalidate (SWR)\")\n\nStale-While-Revalidate (SWR) allows you to control how long Accelerate can serve stale cache data while fetching fresh data in the background. When a read query is executed, Accelerate checks the age of the cached response against the `swr` duration. If the cache data is within the `swr` limit, Accelerate serves the stale data while simultaneously refreshing the cache by fetching the latest data from the database.\n\nUse `swr` in `cacheStrategy` and specify the SWR of the query in seconds:\n\n```\nawait prisma.user.findMany({  cacheStrategy: {    swr: 60,  },});\n```\n\nWhen specifying a SWR of 60 seconds, the cache serves stale data until the cache refreshes itself in the background after each request:\n\n![SWR](https://www.prisma.io/docs/assets/images/swr-0543c25ba2ca4064175a4d4b67b74465.png)\n\n## Selecting a cache strategy[​](https://www.prisma.io/docs/accelerate/caching#selecting-a-cache-strategy \"Direct link to Selecting a cache strategy\")\n\nCaching helps you improve query response times and reduce database load. However, it also means you might serve stale data to the client. Whether or not serving stale data is acceptable and to what extent depends on your use case. `ttl` and `swr` are parameters you can use the tweak the cache behavior.\n\n### Cache strategy using TTL[​](https://www.prisma.io/docs/accelerate/caching#cache-strategy-using-ttl \"Direct link to Cache strategy using TTL\")\n\nUse TTL to reduce database load when stale cached data is acceptable.\n\n#### Use case: Product catalog in e-commerce applications[​](https://www.prisma.io/docs/accelerate/caching#use-case-product-catalog-in-e-commerce-applications \"Direct link to Use case: Product catalog in e-commerce applications\")\n\nConsider an e-commerce application with a product catalog that doesn't frequently change. By setting a `ttl` of, let's say, 1 hour, Prisma Client can serve cached product data for subsequent user requests within that hour without hitting the database. This significantly reduces the database load and improves the response time for product listing pages.\n\n### Cache strategy using SWR[​](https://www.prisma.io/docs/accelerate/caching#cache-strategy-using-swr \"Direct link to Cache strategy using SWR\")\n\nUse SWR to respond quickly to requests with minimal stale data. While it does not reduce database load, it can improve response times significantly.\n\nImagine a social media platform where user profiles are frequently accessed. By leveraging `swr` with a duration of, let's say, 5 minutes, Accelerate can serve the cached user profile information quickly, reducing the latency for profile pages. Meanwhile, in the background, it refreshes the cache after every request, ensuring that any updates made to the profile are eventually reflected for subsequent requests.\n\n### Cache strategy using TTL + SWR[​](https://www.prisma.io/docs/accelerate/caching#cache-strategy-using-ttl--swr \"Direct link to Cache strategy using TTL + SWR\")\n\nFor very fast response times and reduced database load, use both TTL and SWR. You can use this strategy to fine-tune your application’s tolerance for stale data.\n\nUse `ttl` and `swr` in `cacheStrategy` and specify the TTL and SWR of the query in seconds:\n\n```\nawait prisma.user.findMany({  cacheStrategy: {    ttl: 30,    swr: 60,  },});\n```\n\nWhen specifying a TTL of 30 seconds and SWR of 60 seconds, the cache serves fresh data for the initial 30 seconds. Subsequently, it serves stale data until the cache refreshes itself in the background after each request:\n\n![ttl_and_swr.png](https://www.prisma.io/docs/assets/images/ttl_and_swr-2d64d0651978cd2b10ddf89149941179.png)\n\n#### Use case: News articles[​](https://www.prisma.io/docs/accelerate/caching#use-case-news-articles \"Direct link to Use case: News articles\")\n\nConsider a news application where articles are frequently accessed but don't require real-time updates. By setting a `ttl` of 2 hours and an `swr` duration of 5 minutes, Prisma Client can serve cached articles quickly, reducing latency for readers. As long as the articles are within the `ttl`, users get fast responses. After the `ttl` expires, Prisma Client serves the stale articles for an additional 5 minutes while fetching the latest news from the database, maintaining a balance between performance and freshness.\n\n## Default cache strategy [​](https://www.prisma.io/docs/accelerate/caching#default-cache-strategy \"Direct link to Default cache strategy \")\n\nAccelerate defaults to **no cache** to avoid counterintuitive issues. Caching can be a powerful tool for improving performance but can also be dangerous if not used correctly.\n\nFor example, consider writing a query on a critical path without explicitly defining a cache strategy. If you run the code, you might receive incorrect data without explanation. This could be caused by someone forgetting to disable the default _implicit_ cache behavior. Implicit caching allows these counterintuitive issues to arise, leading to undesirable results.\n\nYou must explicitly opt-in to caching if you want to use it. This makes it clear to developers that caching is not enabled by default and helps prevent counterintuitive issues from occurring.\n\n> When no cache strategy is specified or during a cache miss, a Prisma Client with the Accelerate extension routes all queries to the database through a connection pool instance near the database region.",
  "title": "Accelerate: Caching | Prisma Documentation",
  "description": "Learn everything you need to know to use Accelerate's global database caching.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/accelerate/faq",
  "markdown": "# Accelerate: FAQ | Prisma Documentation\n\nBelow are frequently asked questions about Accelerate.\n\n## When should I enable static IP for Prisma Accelerate?[​](https://www.prisma.io/docs/accelerate/faq#when-should-i-enable-static-ip-for-prisma-accelerate \"Direct link to When should I enable static IP for Prisma Accelerate?\")\n\nA static IP address is an IPv4 or an IPv6 address that is fixed. Unlike dynamic IP addresses, which can change unpredictably, traffic from static IP addresses can be easily identified. Enable static IP for Accelerate when your security setup requires IP allowlisting or if you're implementing firewalls that only permit access from trusted IPs, ensuring controlled and secure database connections.\n\n![What is a static IP](https://www.prisma.io/docs/assets/images/static-ip-c2016839d1d8658cfa5e1247b3e12de1.png)\n\nFor databases using IP allowlisting, enable static IP for Accelerate in your specified project environment, and add the obtained IP address to your database's allowlist to ensure authorized access from Accelerate.\n\n![](https://www.prisma.io/docs/assets/images/result-of-adding-static-ip-to-accelerate-273e29209a502217bf625879f59c7a56.png)\n\n> ℹ️ To enable static IP support for Accelerate within your existing or new project environment, your workspace will need to be on our **Pro** or **Business** plans. Take a look at the [pricing page](https://www.prisma.io/pricing) for more information.\n\n## Why do I sometimes see unexpected cache behavior?[​](https://www.prisma.io/docs/accelerate/faq#why-do-i-sometimes-see-unexpected-cache-behavior \"Direct link to Why do I sometimes see unexpected cache behavior?\")\n\nAccelerate's cache performs best when it observes a higher load from a project. Many cache operations, such as committing data to cache and refreshing stale data, happen asynchronously. When benchmarking Accelerate, we recommend doing so with loops or a load testing approach. This will mimic higher load scenarios better and reduce outliers from low frequency operations.\n\nPrisma operations are sent to Accelerate over HTTP. As a result, the first request to Accelerate must establish an HTTP handshake and may have additional latency as a result. We're exploring ways to reduce this initial request latency in the future.\n\n## What is the pricing of Accelerate?[​](https://www.prisma.io/docs/accelerate/faq#what-is-the-pricing-of-accelerate \"Direct link to What is the pricing of Accelerate?\")\n\nYou can find more details on our [Accelerate pricing page](https://www.prisma.io/pricing)\n\n## VS Code does not recognize the `$extends` method[​](https://www.prisma.io/docs/accelerate/faq#vs-code-does-not-recognize-the-extends-method \"Direct link to vs-code-does-not-recognize-the-extends-method\")\n\nIf you add the Prisma Client extension for Accelerate to an existing project that is currently open in VS Code, the editor might not immediately recognize the `$extends` method.\n\nThis might be an issue with the TypeScript server not yet recognizing the regenerated Prisma Client. To resolve this, you need to restart TypeScript.\n\n1.  In VS Code, open the Command Palette. You can do so when you press F1 or select **View** > **Command Palette**.\n2.  Enter `typescript` and select and run the **TypeScript: Restart TS server** command.\n\nVS Code should now recognize the `$extends` method.\n\n## What regions are Accelerate's cache nodes available in?[​](https://www.prisma.io/docs/accelerate/faq#what-regions-are-accelerates-cache-nodes-available-in \"Direct link to What regions are Accelerate's cache nodes available in?\")\n\nAccelerate runs on Cloudflare's network and cache hits are served from Cloudflare's 300+ locations. You can find the regions where Accelerate's cache nodes are available here: [https://www.cloudflare.com/network/](https://www.cloudflare.com/network/).\n\n## What regions is Accelerate's connection pool available in?[​](https://www.prisma.io/docs/accelerate/faq#what-regions-is-accelerates-connection-pool-available-in \"Direct link to What regions is Accelerate's connection pool available in?\")\n\nWhen no cache strategy is specified or in the event of a cache miss, the Prisma Client query is routed through Accelerate's connection pool. Currently, queries can be routed through any chosen region among the 16 available locations.\n\nCurrently, the list of available regions are:\n\n*   Asia Pacific, Mumbai (`ap-south-1`)\n*   Asia Pacific, Seoul (`ap-northeast-2`)\n*   Asia Pacific, Singapore (`ap-southeast-1`)\n*   Asia Pacific, Sydney (`ap-southeast-2`)\n*   Asia Pacific, Tokyo (`ap-northeast-1`)\n*   Canada, Central (`ca-central-1`)\n*   Europe, Frankfurt (`eu-central-1`)\n*   Europe, Ireland (`eu-west-1`)\n*   Europe, London (`eu-west-2`)\n*   Europe, Paris (`eu-west-3`)\n*   Europe, Stockholm (`eu-north-1`)\n*   South America, Sao Paulo (`sa-east-1`)\n*   US East, N. Virginia (`us-east-1`)\n*   US East, Ohio (`us-east-2`)\n*   US West, N. California (`us-west-1`)\n*   US West, Oregon (`us-west-2`)\n\nYou can also view the available regions when you're about to set up Accelerate or by visiting the **Settings** tab for Accelerate under the **Region** section in the Prisma Cloud Platform [dashboard](https://pris.ly/pdp).\n\n## How does Accelerate know what region to fetch the cache from?[​](https://www.prisma.io/docs/accelerate/faq#how-does-accelerate-know-what-region-to-fetch-the-cache-from \"Direct link to How does Accelerate know what region to fetch the cache from?\")\n\nUnder the hood, Accelerate uses Cloudflare, which uses [Anycast](https://www.cloudflare.com/learning/cdn/glossary/anycast-network/) for network addressing and routing. An incoming request will be routed to the nearest data center or \"node\" in their network that has the capacity to process the request efficiently. To learn more about how this works, we recommend looking into [Anycast](https://www.cloudflare.com/learning/cdn/glossary/anycast-network/).\n\n## How can I invalidate a cache on Accelerate?[​](https://www.prisma.io/docs/accelerate/faq#how-can-i-invalidate-a-cache-on-accelerate \"Direct link to How can I invalidate a cache on Accelerate?\")\n\nYou can invalidate your cache on a project level up to five times a day. This can be done via the Accelerate configuration page.\n\n## What is Accelerate's consistency model?[​](https://www.prisma.io/docs/accelerate/faq#what-is-accelerates-consistency-model \"Direct link to What is Accelerate's consistency model?\")\n\nAccelerate does not have a consistency model. It is not a distributed system where nodes need to reach a consensus (because data is only stored in the cache node(s) closest to the user). However, the data cached in Accelerate's cache nodes doesn't propagate to other nodes, so Accelerate by design doesn't need a consistency model.\n\nAccelerate implements a [read-through caching strategy](https://www.prisma.io/dataguide/managing-databases/introduction-database-caching#read-through) particularly suitable for read-heavy workloads.\n\nThe freshness of the data served by the cache depends on the cache strategy defined in your query. Refer to [this section](https://www.prisma.io/docs/accelerate/caching#selecting-a-cache-strategy) for more information on selecting the right cache strategy for your query.\n\n*   Accelerate is a _specialized_ cache that allows you to optimize data access in code at the query level with a cache strategy. On the other hand, tools such as Redis and Memcached are _general-purpose_ caches designed to be adaptable and flexible.\n*   Accelerate is a managed service that reduces the time, risk, and engineering effort of building and maintaining a cache service.\n*   By default, Accelerate is globally distributed, reducing the latency of your queries. Other cache tools would require additional configuration to make them available globally.\n\n## When should I not use Accelerate's caching features?[​](https://www.prisma.io/docs/accelerate/faq#when-should-i-not-use-accelerates-caching-features \"Direct link to When should I not use Accelerate's caching features?\")\n\nAccelerate is a global data cache and connection pool that allows you to optimize data access in code at the query level. While caching with Accelerate can greatly boost the performance of your app, it may not always the best choice for your use case.\n\nAccelerate's global cache feature may not be a good fit for your app if:\n\n*   Your app is exclusively used within a specific region and both your application server and database are situated in that same region on the same network. For example, database queries will likely be much faster if your application server and database are in the same region and network. However, If your application server is in different regions or networks from your database, Accelerate will speed up your queries because the data will be cached in the closest data center to your application.\n    \n*   You _only_ need a general-purpose cache. Accelerate is a connection pooler and a _specialized cache_ that only caches your database query responses in code. A general-purpose cache, such as Redis, would allow you to cache data from multiple sources, such as external APIs, which Accelerate currently doesn't support. If general-purpose caching interests you, please share your feedback with us via our [Discord](https://pris.ly/discord).\n    \n*   Your application data _always_ needs to be up-to-date on retrieval, which would be difficult to set a reasonable cache strategy.\n    \n\nEven without using Accelerate's global cache, you can still greatly benefit from Accelerate by using its connection pool, especially in serverless or edge functions, where it is difficult to manage and scale database connections. You can learn more about the serverless challenge [here](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#the-serverless-challenge).\n\n## Can I use Accelerate with other ORMs/query builders/drivers?[​](https://www.prisma.io/docs/accelerate/faq#can-i-use-accelerate-with-other-ormsquery-buildersdrivers \"Direct link to Can I use Accelerate with other ORMs/query builders/drivers?\")\n\nNo. We currently do not have any plans for supporting other ORMs/query builders or drivers. However, if you're interested in support for other libraries, feel free to reach out and let us know in our [Discord](https://pris.ly/discord) community in the `#help-and-questions` channel.\n\n## What is the maximum allowed value for the `ttl` parameter when configuring `cacheStrategy`?[​](https://www.prisma.io/docs/accelerate/faq#what-is-the-maximum-allowed-value-for-the-ttl-parameter-when-configuring-cachestrategy \"Direct link to what-is-the-maximum-allowed-value-for-the-ttl-parameter-when-configuring-cachestrategy\")\n\nThe [Time-to-live](https://www.prisma.io/docs/accelerate/caching#time-to-live-ttl) (`ttl`) parameter can be set for up to a _year_. However, it's important to note that items within the cache may be evicted if they are not frequently accessed.\n\nBased on our experimentation, we’ve seen cache items persist for around 18 hours. While items may remain in the cache for an extended period if they are actively accessed, there is no guarantee.\n\n> **Note**: Even frequently accessed items may occasionally be evicted from the cache. It's unlikely for an item to survive for up to or longer than a month, regardless of its activity level.\n\n## Why doesn’t Accelerate fall back to the direct connection string during a service disruption?[​](https://www.prisma.io/docs/accelerate/faq#why-doesnt-accelerate-fall-back-to-the-direct-connection-string-during-a-service-disruption \"Direct link to Why doesn’t Accelerate fall back to the direct connection string during a service disruption?\")\n\nIn the rare event of a service disruption, falling back to a direct connection would bypass the connection pool. This could potentially deplete the database's available connections and cause other issues on the database level.\n\nIf there is a service disruption, it's recommended to verify on the [status page](https://pris.ly/data-platform-status). You can reach out to one of Prisma's [support channels](https://www.prisma.io/docs/platform/support) for assistance.\n\n> **Note:** Additionally, it's worth noting that some edge function runtime environments may not support direct connections with Prisma ORM. For further details, refer to our [Edge functions documentation](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview).\n\n## Are each of the queries within an interactive transaction counted separately for billing?[​](https://www.prisma.io/docs/accelerate/faq#are-each-of-the-queries-within-an-interactive-transaction-counted-separately-for-billing \"Direct link to Are each of the queries within an interactive transaction counted separately for billing?\")\n\nYes, [interactive transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions) are billed based on the individual operations within the transaction. There is no charge for the start, commit, or rollback of the transaction itself. For example, in the following query, there are two billable queries:\n\n```\nawait prisma.$transaction(async (tx) => {  await tx.user.deleteMany({ where: { name: 'John Doe' } });  await tx.user.createMany({ data });});\n```\n\nHowever, when using the [`$transaction` API for sequential client operations](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#sequential-prisma-client-operations), regardless of the number of queries within the array, it counts as only one billable query. For example:\n\n```\nawait prisma.$transaction([  prisma.user.deleteMany({ where: { name: 'John Doe' } }),  prisma.user.createMany({ data }),]);\n```\n\nIf you don't need [interactive transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions), you can save costs and improve performance by using [sequential operations transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#sequential-prisma-client-operations). Sequential operations transactions perform better on Accelerate because they execute in one round-trip to the database, while interactive transactions require separate round-trips for start, commit, and each individual operation on the transaction.",
  "title": "Accelerate: FAQ | Prisma Documentation",
  "description": "Frequently asked questions about Accelerate.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/accelerate/evaluating",
  "markdown": "# Accelerate: Evaluating | Prisma Documentation\n\nPrisma Accelerate optimizes database interactions through advanced connection pooling and global edge caching. Its connection pooler is available in 16 regions and helps applications load-balance and scale database requests based on demand.\n\nConsidering the information above, we recommend evaluating Accelerate with high volume to see it perform under load.\n\nPrisma Accelerate employs a dynamic, serverless connection pooling infrastructure. When a request is made, a connection pool is quickly provisioned for the project in the region assigned while configuring Prisma Accelerate. This connection pool remains active, serving many additional requests while reusing established database connections. The connection pool will disconnect after a period of inactivity, so it’s important to evaluate Prisma Accelerate with a consistent stream of traffic.\n\nBy understanding and harnessing this mechanism, you can ensure that your database queries perform consistently and efficiently at scale.\n\nBelow you will find an example of how to evaluate Prisma Accelerate using a sample model:\n\n```\nimport { PrismaClient } from '@prisma/client'import { withAccelerate } from '@prisma/extension-accelerate'const prisma = new PrismaClient().$extends(withAccelerate())function calculateStatistics(numbers: number[]): {  average: number  p50: number  p75: number  p99: number} {  if (numbers.length === 0) {    throw new Error('The input array is empty.')  }  // Sort the array in ascending order  numbers.sort((a, b) => a - b)  const sum = numbers.reduce((acc, num) => acc + num, 0)  const count = numbers.length  const average = sum / count  const p50 = getPercentile(numbers, 50)  const p75 = getPercentile(numbers, 75)  const p99 = getPercentile(numbers, 99)  return { average, p50, p75, p99 }}function getPercentile(numbers: number[], percentile: number): number {  if (percentile <= 0 || percentile >= 100) {    throw new Error('Percentile must be between 0 and 100.')  }  const index = (percentile / 100) * (numbers.length - 1)  if (Number.isInteger(index)) {    // If the index is an integer, return the corresponding value    return numbers[index]  } else {    // If the index is not an integer, interpolate between two adjacent values    const lowerIndex = Math.floor(index)    const upperIndex = Math.ceil(index)    const lowerValue = numbers[lowerIndex]    const upperValue = numbers[upperIndex]    const interpolationFactor = index - lowerIndex    return lowerValue + (upperValue - lowerValue) * interpolationFactor  }}async function main() {  const timings = []  // fire a query before going to the loop  await prisma.notes.findMany({    take: 20,  })  // we recommend evaluationg Prisma Accelerate with a large loop  const LOOP_LENGTH = 10000  for (let i = 0; i < LOOP_LENGTH; i++) {    const start = Date.now()    await prisma.notes.findMany({      take: 20,    })    timings.push(Date.now() - start)  }  const statistics = calculateStatistics(timings)  console.log('Average:', statistics.average)  console.log('P50:', statistics.p50)  console.log('P75:', statistics.p75)  console.log('P99:', statistics.p99)}main()  .then(async () => {    await prisma.$disconnect()  })  .catch((e) => {    await prisma.$disconnect()    process.exit(1)  })\n```\n\nPrisma Accelerate’s edge cache is also optimized for a high volume of queries. The cache automatically optimizes for repeated queries. As a result, the cache hit rate will increase as the query frequency does. Adding a query result to the cache is also non-blocking, so a short burst of queries might not utilize the cache or a sustained load.\n\nTo evaluate Accelerate’s edge caching, you can modify the above script with the below:\n\n```\nimport { PrismaClient } from '@prisma/client'import { withAccelerate } from '@prisma/extension-accelerate'const prisma = new PrismaClient().$extends(withAccelerate())function calculateStatistics(numbers: number[]): {  average: number  p50: number  p75: number  p99: number} {  if (numbers.length === 0) {    throw new Error('The input array is empty.')  }  // Sort the array in ascending order  numbers.sort((a, b) => a - b)  const sum = numbers.reduce((acc, num) => acc + num, 0)  const count = numbers.length  const average = sum / count  const p50 = getPercentile(numbers, 50)  const p75 = getPercentile(numbers, 75)  const p99 = getPercentile(numbers, 99)  return { average, p50, p75, p99 }}function getPercentile(numbers: number[], percentile: number): number {  if (percentile <= 0 || percentile >= 100) {    throw new Error('Percentile must be between 0 and 100.')  }  const index = (percentile / 100) * (numbers.length - 1)  if (Number.isInteger(index)) {    // If the index is an integer, return the corresponding value    return numbers[index]  } else {    // If the index is not an integer, interpolate between two adjacent values    const lowerIndex = Math.floor(index)    const upperIndex = Math.ceil(index)    const lowerValue = numbers[lowerIndex]    const upperValue = numbers[upperIndex]    const interpolationFactor = index - lowerIndex    return lowerValue + (upperValue - lowerValue) * interpolationFactor  }}async function main() {  const timings = []  // fire a query before going to the loop  await prisma.notes.findMany({    take: 20,    cacheStrategy: {      ttl: 30,    },  })  // we recommend evaluating Prisma Accelerate with a large loop  const LOOP_LENGTH = 10000  for (let i = 0; i < LOOP_LENGTH; i++) {    const start = Date.now()    await prisma.notes.findMany({      take: 20,      cacheStrategy: {        ttl: 30,      },    })    timings.push(Date.now() - start)  }  const statistics = calculateStatistics(timings)  console.log('Average:', statistics.average)  console.log('P50:', statistics.p50)  console.log('P75:', statistics.p75)  console.log('P99:', statistics.p99)}main()  .then(async () => {    await prisma.$disconnect()  })  .catch((e) => {    await prisma.$disconnect()    process.exit(1)  })\n```",
  "title": "Accelerate: Evaluating | Prisma Documentation",
  "description": "Learn about evaluating Prisma Accelerate.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/accelerate/local-development",
  "markdown": "# Accelerate: Local development | Prisma Documentation\n\nPrisma Accelerate efficiently scales production traffic with integrated connection pooling and a global database cache.\n\nIn development environments, you may want to use a local database to minimize expenses. Furthermore, you may consider extending Prisma Client with the Accelerate client extension once so that you can use a local database in development and a hosted database with Accelerate’s connection pooling and caching enabled. This eliminates the need for conditional logic to switch clients between development and production.\n\nThis guide will explain how to use Prisma Accelerate client extension in a development environment with a local database.\n\n## Using Prisma Accelerate client extension in development and production[​](https://www.prisma.io/docs/accelerate/local-development#using-prisma-accelerate-client-extension-in-development-and-production \"Direct link to Using Prisma Accelerate client extension in development and production\")\n\n![](https://www.prisma.io/docs/assets/images/accelerate-in-dev-23954395536c6d2aabcfddf57b9fff16.png)\n\nAccelerate does not work with a local database. However, in a development environment, you can still use Prisma Client with the Accelerate client extension. This setup will not provide Accelerate's connection pooling and caching features.\n\nThe following steps outline how to use Prisma ORM and Prisma Accelerate with a local PostgreSQL database.\n\n1.  Update the `DATABASE_URL` environment variable with your local database's connection string:\n    \n    ```\n    DATABASE_URL=\"postgres://username:password@127.0.0.1:5432/localdb\"\n    ```\n    \n2.  Generate a Prisma Client:\n    \n    > Note: The `--no-engine` flag should only be used in preview and production environments. The command generates Prisma Client artifacts without a [Query Engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines) file, which requires an Accelerate connection string.\n    \n3.  Set up Prisma Client with the Accelerate client extension:\n    \n    ```\n    import { PrismaClient } from '@prisma/client'import { withAccelerate } from '@prisma/extension-accelerate'const prisma = new PrismaClient().$extends(withAccelerate())\n    ```\n    \n    > The extended instance of Prisma Client will use the local database. Hence, Prisma Accelerate will not be used in your development environment to respond to your Prisma Client queries.\n    \n\n![](https://www.prisma.io/docs/assets/images/accelerate-in-prod-5561d88bf69c7127d34450eba963a5af.png)\n\nIf an Accelerate connection string is used as the `DATABASE_URL` environment variable, Prisma Client will route your queries through Accelerate.\n\n## Using Prisma Accelerate locally in an edge function[​](https://www.prisma.io/docs/accelerate/local-development#using-prisma-accelerate-locally-in-an-edge-function \"Direct link to Using Prisma Accelerate locally in an edge function\")\n\nWhen using an edge function, e.g., [Vercel's edge functions](https://vercel.com/docs/functions/edge-functions), for your development environment, update your Prisma Client import as follows:\n\n```\nimport { PrismaClient } from '@prisma/client/edge'\n```\n\nGenerally, edge function environments lack native support for existing APIs enabling TCP-based database connections. Prisma Accelerate provides a connection string that allows querying your database over HTTP, a protocol supported in all edge runtimes.",
  "title": "Accelerate: Local development | Prisma Documentation",
  "description": "Learn how to use Prisma Accelerate in a development environment.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/accelerate/troubleshoot",
  "markdown": "# Troubleshooting: Prisma Accelerate | Prisma Documentation\n\nWhen working with Prisma Accelerate, you may encounter errors often highlighted by specific error codes during development and operations. It is important to understand the meaning of these errors, why they occur, and how to resolve them in order to ensure the smooth operation of your applications. This guide aims to provide insights and steps to troubleshoot specific error codes encountered with Prisma Accelerate.\n\n## [`P6009`](https://www.prisma.io/docs/orm/reference/error-reference#p6009-responsesizelimitexceeded) (`ResponseSizeLimitExceeded`)[​](https://www.prisma.io/docs/accelerate/troubleshoot#p6009-responsesizelimitexceeded \"Direct link to p6009-responsesizelimitexceeded\")\n\nThis error is triggered when the response size from a database query exceeds the 5MB limit. We've implemented this restriction to safeguard your application performance, as retrieving data over 5MB can significantly slow down your application due to multiple network layers. Typically, transmitting more than 5MB of data is common when conducting ETL (Extract, Transform, Load) operations. However, for other scenarios such as transactional queries, real-time data fetching for user interfaces, bulk data updates, or aggregating large datasets for analytics outside of ETL contexts, it should generally be avoided. These use cases, while essential, can often be optimized to work within the 5MB limit, ensuring smoother performance and a better user experience.\n\n### Possible causes for [`P6009`](https://www.prisma.io/docs/orm/reference/error-reference#p6009-responsesizelimitexceeded)[​](https://www.prisma.io/docs/accelerate/troubleshoot#possible-causes-for-p6009 \"Direct link to possible-causes-for-p6009\")\n\n#### Transmitting images/files in response[​](https://www.prisma.io/docs/accelerate/troubleshoot#transmitting-imagesfiles-in-response \"Direct link to Transmitting images/files in response\")\n\nThis error may arise if images or files stored within your table are being fetched, resulting in a large response size. Storing assets directly in the database is generally discouraged because it significantly impacts database performance and scalability. In addition to performance, it makes database backups slow and significantly increases the cost of storing routine backups.\n\n**Suggested solution:** Store the image/file in a BLOB store like [Cloudflare R2](https://developers.cloudflare.com/r2/), [AWS S3](https://aws.amazon.com/pm/serv-s3/), [Cloudinary](https://cloudinary.com/), etc. These services would allow you to store the assets optimally and return a URL through which you should be able to access the asset. You can store this URL in your table instead of storing the asset directly in database. This would substantially reduce the size of your response.\n\n#### Over-fetching of data[​](https://www.prisma.io/docs/accelerate/troubleshoot#over-fetching-of-data \"Direct link to Over-fetching of data\")\n\nIn certain cases, a large number of records or fields are unintentionally fetched, which results in exceeding the 5MB limit. This could happen when the [`where`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#where) clause in the query is incorrect or entirely missing.\n\n**Suggested solution:** Double-check if the `where` clause is filtering the data as you expect. Consider using [pagination](https://www.prisma.io/docs/orm/prisma-client/queries/pagination) to prevent a large number of records from being fetched. Additionally, use the [`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select) clause to return only the fields that are being consumed to further reduce the response size.\n\n#### Fetching a large volume of data[​](https://www.prisma.io/docs/accelerate/troubleshoot#fetching-a-large-volume-of-data \"Direct link to Fetching a large volume of data\")\n\nIn many data processing workflows, especially those involving ETL (Extract-Transform-Load) processes or scheduled CRON jobs, there's a need to extract large amounts of data from data sources (like databases, APIs, or file systems) for analysis, reporting, or further processing. If you are running an ETL/CRON workload that fetches a huge chunk of data for analytical processing then you might run into this limit.\n\n**Suggested solution:** Consider splitting your query to fetch data in batches to prevent the 5MB limit from being reached. By splitting your query to retrieve data in batches, you ensure that each operation fetches only a portion of the total data volume, thereby not exceeding the size limit for a single fetch operation.\n\n## [`P6004`](https://www.prisma.io/docs/orm/reference/error-reference#p6004-querytimeout) (`QueryTimeout`)[​](https://www.prisma.io/docs/accelerate/troubleshoot#p6004-querytimeout \"Direct link to p6004-querytimeout\")\n\nThis error occurs when a database query fails to return a response within 10 seconds. The 10-second limit includes the duration of waiting for a connection from the pool, network latency to the database, and the execution time of the query itself. We enforce this limit to prevent unintentional long-running queries that can overload system resources.\n\n> The time for Accelerate's cross-region networking is excluded from the 10-second limit.\n\n### Possible causes for [`P6004`](https://www.prisma.io/docs/orm/reference/error-reference#p6004-querytimeout)[​](https://www.prisma.io/docs/accelerate/troubleshoot#possible-causes-for-p6004 \"Direct link to possible-causes-for-p6004\")\n\nThis error could be caused by numerous reasons. Some of the prominent ones are:\n\n#### High traffic and insufficient connections[​](https://www.prisma.io/docs/accelerate/troubleshoot#high-traffic-and-insufficient-connections \"Direct link to High traffic and insufficient connections\")\n\nIf the application is receiving very high traffic and there are not a sufficient number of connections available to the database, then the queries would need to wait for a connection to become available. This situation can lead to queries waiting longer than 10 seconds for a connection, ultimately triggering a timeout error if they do not get serviced within this duration.\n\n**Suggested solution**: Review and possibly increase the `connection_limit` specified in the connection string parameter when setting up Accelerate in a platform environment ([reference](https://www.prisma.io/docs/accelerate/connection-pooling#configuring-the-connection-pool-size)). This limit should align with your database's maximum number of connections.\n\nBy default, the connection limit is set to 10 unless a different `connection_limit` is specified in your database connection string.\n\n#### Long-running queries[​](https://www.prisma.io/docs/accelerate/troubleshoot#long-running-queries \"Direct link to Long-running queries\")\n\nQueries may be slow to respond, hitting the 10-second timeout even when connections are available. This could happen if a very large amount of data is being fetched in a single query or if appropriate indexes are missing from the table.\n\n**Suggested solution**: Identify the slow-running queries and fetch only the required data. If you only need to use specific fields from the table, then you can use the select clause in your queries to prevent unnecessary data from being fetched. Additionally, you could consider adding appropriate indexes based on the query to ensure that data is fetched efficiently. You can also consider isolating long running queries into separate environments, so that these long running queries would not affect the transactional queries.\n\n#### Database resource contention[​](https://www.prisma.io/docs/accelerate/troubleshoot#database-resource-contention \"Direct link to Database resource contention\")\n\nA common yet challenging issue is when other services operating on the same database perform heavy analytics or data processing tasks, significantly consuming database resources. These operations can monopolize database connections and processing power, leading to a scenario where even simple queries cannot be executed in a timely manner. This \"busy\" or \"noisy\" database environment can cause queries that are typically fast to run slowly or even timeout, particularly during periods of high activity from other services.\n\nUsers often rely on CPU and memory usage metrics to gauge database load, which can be misleading. While these are important indicators, they might not fully represent the database's operational state. Direct metrics like the number of reads, writes, and wait times offer a clearer view of the database's performance and should be monitored closely. A noticeable degradation in these metrics, especially in the absence of changes to the queries or data model, suggests that external pressures are affecting database performance.\n\n**Suggestion solution**: If normally quick queries are intermittently slow or timing out without any modifications to them, it's probable that competing queries are exerting pressure on the same database tables. To diagnose this, adopt monitoring tools or leverage your database's inherent capabilities to observe reads, writes, and wait times. Such monitoring will unveil activity patterns or spikes that align with the observed performance dips.\n\nMoreover, it's crucial to periodically scrutinize and refine essential queries and verify that tables are properly indexed. This proactive approach minimizes the vulnerability of these queries to slowdowns caused by competing workloads.\n\n### Considerations for [`P6009`](https://www.prisma.io/docs/orm/reference/error-reference#p6009-responsesizelimitexceeded) and [`P6004`](https://www.prisma.io/docs/orm/reference/error-reference#p6004-querytimeout) errors[​](https://www.prisma.io/docs/accelerate/troubleshoot#considerations-for-p6009-and-p6004-errors \"Direct link to considerations-for-p6009-and-p6004-errors\")\n\nFor runtimes that support Prisma ORM natively, you could consider creating two `PrismaClient` Instances. One with the Accelerate connection string (prefixed with `prisma://`) and the other one with the direct database connection string (prefixed with `postgres://`, `mysql://` etc). The main idea behind this approach is to bypass Accelerate for certain specific queries.\n\nHowever, please note that the available connections would be split between both of your `PrismaClient` Instances. It's crucial to understand the implications of managing multiple instances, particularly in regards to direct database connections. Utilizing a `PrismaClient` instance with a direct database connection string means that this connection will interact directly with your database.\n\nThis approach requires careful consideration because the direct connections and those managed by Accelerate share the same underlying database connection pool. This can lead to competition for resources, potentially affecting the performance and availability of your database services.\n\nAdditionally, direct connections could have a significant impact on your database's performance and availability. Operations that consume a considerable amount of resources could potentially degrade the service for other users or processes that rely on the same database.\n\nIf your application's runtime environment supports Prisma ORM natively and you're considering this strategy to circumvent P6009 and P6004 errors, you might create two `PrismaClient` instances:\n\n1.  An instance using the Accelerate connection string (prefixed with `prisma://`) for general operations.\n2.  Another instance with the direct database connection string (e.g., prefixed with `postgres://`, `mysql://`, etc.) for specific operations anticipated to exceed 10 seconds in execution time or to result in responses larger than 5MB.\n\n```\nexport const prisma = new PrismaClient({  datasourceUrl: process.env.DIRECT_DB_CONNECTION,})export const prismaAccelerate = new PrismaClient({  datasourceUrl: process.env.ACCELERATE_CONNECTION,}).$extends(withAccelerate())\n```\n\nThis setup allows you to strategically direct certain operations through the direct connection, mitigating the risk of encountering the aforementioned errors. However, this decision should be made with a comprehensive understanding of the potential consequences and an assessment of whether your database infrastructure can support this additional load without compromising overall performance and availability.\n\n> Also see [**why doesn’t Accelerate fall back to the direct connection string during a service disruption?**](https://www.prisma.io/docs/accelerate/faq#why-doesnt-accelerate-fall-back-to-the-direct-connection-string-during-a-service-disruption)\n\n## [`P6008`](https://www.prisma.io/docs/orm/reference/error-reference#p6008-connectionerrorenginestarterror) (`ConnectionError|EngineStartError`)[​](https://www.prisma.io/docs/accelerate/troubleshoot#p6008-connectionerrorenginestarterror \"Direct link to p6008-connectionerrorenginestarterror\")\n\nThis error indicates that Prisma Accelerate cannot establish a connection to your database, potentially due to several reasons.\n\n### Possible causes for [`P6008`](https://www.prisma.io/docs/orm/reference/error-reference#p6008-connectionerrorenginestarterror)[​](https://www.prisma.io/docs/accelerate/troubleshoot#possible-causes-for-p6008 \"Direct link to possible-causes-for-p6008\")\n\n#### Database Not Publicly accessible[​](https://www.prisma.io/docs/accelerate/troubleshoot#database-not-publicly-accessible \"Direct link to Database Not Publicly accessible\")\n\nPrisma Accelerate currently requires the database to be publicly accessible. If your database is behind a VPC, or access is restricted to specific IP addresses, this error may occur.\n\n**Suggested solution:** Ensure your database is publicly accessible, if not, allow public access. Please note this is only an interim requirement, Static IPs are coming soon and will alleviate the need for complete public access if that’s not desirable.\n\n#### Unreachable Database Host/Port[​](https://www.prisma.io/docs/accelerate/troubleshoot#unreachable-database-hostport \"Direct link to Unreachable Database Host/Port\")\n\nIf the database’s server address (hostname) and port are incorrect or unreachable then you may encounter this error.\n\n**Suggested solution:** Verify the hostname/port of the database connection string that was provided while creating the Prisma Accelerate project. Additionally, attempt to connect to the database using a Database GUI tool (e.g., [Prisma Studio](https://www.prisma.io/studio), [TablePlus](https://tableplus.com/), or [DataGrip](https://www.jetbrains.com/datagrip/)) for further investigation.\n\n#### Incorrect username/password/database name[​](https://www.prisma.io/docs/accelerate/troubleshoot#incorrect-usernamepassworddatabase-name \"Direct link to Incorrect username/password/database name\")\n\nThis error can happen when the wrong credentials are provided to Prisma Accelerate, preventing it from establishing a connection to your database.\n\n**Suggested solution:** Verify the correctness of your database's username, password, and name in the connection string provided to Prisma Accelerate. Ensure that these credentials match those required by your database. Testing the connection using a direct database GUI tool can also help in confirming if the provided credentials are correct.",
  "title": "Troubleshooting: Prisma Accelerate | Prisma Documentation",
  "description": "Troubleshooting Prisma Accelerate.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/accelerate/feedback",
  "markdown": "# Accelerate: Feedback | Prisma Documentation\n\nYou can submit any feedback about Accelerate in our [Discord server](https://pris.ly/discord).",
  "title": "Accelerate: Feedback | Prisma Documentation",
  "description": "Learn where to submit feedback about Accelerate.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/sql-server/sql-server-local",
  "markdown": "# SQL Server on Windows | Prisma Documentation\n\nTo run a Microsoft SQL Server locally on a Windows machine:\n\n1.  If you do not have access to an instance of Microsoft SQL Server, download and set up [SQL Server 2019 Developer](https://www.microsoft.com/en-us/sql-server/sql-server-downloads).\n    \n2.  Download and install [SQL Server Management Studio](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver15).\n    \n3.  Use Windows Authentication to log in to Microsoft SQL Server Management Studio (expand the **Server Name** dropdown and click **<Browse for more...>** to find your database engine):\n    \n\n![The New Query button in SQL Server Management Studio](https://www.prisma.io/docs/assets/images/connect-sql-server-a007f9ba700b683d87d627a8bee86c57.png)\n\n## Enable TCP/IP[​](https://www.prisma.io/docs/orm/overview/databases/sql-server/sql-server-local#enable-tcpip \"Direct link to Enable TCP/IP\")\n\nPrisma Client requires TCP/IP to be enabled. To enable TCP/IP:\n\n1.  Open SQL Server Configuration Manager. (Search for \"SQL Server Configuration Manager\" in the Start Menu, or open the Start Menu and type \"SQL Server Configuration Manager\".)\n    \n2.  In the left-hand panel, click **SQL Server Network Configuration** > **Protocols for MSSQLSERVER**\n    \n3.  Right-click **TCP/IP** and choose **Enable**.\n    \n\n## Enable authentication with SQL logins (Optional)[​](https://www.prisma.io/docs/orm/overview/databases/sql-server/sql-server-local#enable-authentication-with-sql-logins-optional \"Direct link to Enable authentication with SQL logins (Optional)\")\n\nIf you want to use a username and password in your connection URL rather than integrated security, [enable mixed authentication mode](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/change-server-authentication-mode?view=sql-server-ver15) as follows:\n\n1.  Right-click on your database engine in the Object Explorer and click **Properties**.\n    \n2.  In the Server Properties window, click **Security** in the left-hand list and tick the **SQL Server and Windows Authentication Mode** option, then click **OK**.\n    \n3.  Right-click on your database engine in the Object Explorer and click **Restart**.\n    \n\n### Enable the `sa` login[​](https://www.prisma.io/docs/orm/overview/databases/sql-server/sql-server-local#enable-the-sa-login \"Direct link to enable-the-sa-login\")\n\nTo enable the default `sa` (administrator) SQL Server login:\n\n1.  In SQL Server Management Studio, in the Object Explorer, expand **Security** > **Logins** and double-click **sa**.\n    \n2.  On the **General** page, choose a password for the `sa` account (untick **Enforce password policy** if you do not want to enforce a policy).\n    \n3.  On the **Status** page, under **Settings** > **Login**, tick **Enabled**, then click **OK**.\n    \n\nYou can now use the `sa` account in a connection URL and when you log in to SQL Server Management Studio.\n\n> **Note**: The `sa` user has extensive permissions. You can also [create your own login with fewer permissions](https://docs.microsoft.com/en-us/sql/relational-databases/security/authentication-access/create-a-login?view=sql-server-ver15).",
  "title": "SQL Server on Windows | Prisma Documentation",
  "description": "Set up and configure SQL Server on Windows.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/databases/sql-server/sql-server-docker",
  "markdown": "# SQL Server on Docker | Prisma Documentation\n\nCreate an instance of the container image, replacing the value of `SA_PASSWORD` with a password of your choice:\n\n```\ndocker run --name sql_container -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=myPassword' -p 1433:1433 -d mcr.microsoft.com/mssql/server:2019-latest\n```",
  "title": "SQL Server  on Docker | Prisma Documentation",
  "description": "Download and use the Microsoft SQL Server Docker image.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql",
  "markdown": "# Building GraphQL servers with Prisma ORM\n\n[GraphQL](https://graphql.org/) is a query language for APIs. It is often used as an alternative to RESTful APIs, but can also be used as an additional \"gateway\" layer on top of existing RESTful services.\n\nWith Prisma ORM, you can build GraphQL servers that connect to a database. Prisma ORM is completely agnostic to the GraphQL tools you use. When building a GraphQL server, you can combine Prisma ORM with tools like Apollo Server, GraphQL Yoga, TypeGraphQL, GraphQL.js, or pretty much any tool or library that you're using in your GraphQL server setup.\n\n## GraphQL servers under the hood[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#graphql-servers-under-the-hood \"Direct link to GraphQL servers under the hood\")\n\nA GraphQL server consists of two major components:\n\n*   GraphQL schema (type definitions + resolvers)\n*   HTTP server\n\nNote that a GraphQL schema can be written code-first or SDL-first. Check out this [article](https://www.prisma.io/blog/the-problems-of-schema-first-graphql-development-x1mn4cb0tyl3) to learn more about these two approaches. If you like the SDL-first approach but still want to make your code type-safe, check out [GraphQL Code Generator](https://graphql-code-generator.com/) to generate various type definitions based on SDL.\n\nThe GraphQL schema and HTTP server are typically handled by separate libraries. Here is an overview of current GraphQL server tools and their purpose:\n\n| Library (npm package) | Purpose | Compatible with Prisma ORM | Prisma integration |\n| --- | --- | --- | --- |\n| `graphql` | GraphQL schema (code-first) | Yes | No  |\n| `graphql-tools` | GraphQL schema (SDL-first) | Yes | No  |\n| `type-graphql` | GraphQL schema (code-first) | Yes | [`typegraphql-prisma`](https://www.npmjs.com/package/typegraphql-prisma) |\n| `nexus` | GraphQL schema (code-first) | Yes | [`nexus-prisma`](https://graphql-nexus.github.io/nexus-prisma) _Early Preview_ |\n| `apollo-server` | HTTP server | Yes | n/a |\n| `express-graphql` | HTTP server | Yes | n/a |\n| `fastify-gql` | HTTP server | Yes | n/a |\n| `graphql-yoga` | HTTP server | Yes | n/a |\n\nIn addition to these standalone and single-purpose libraries, there are several projects building integrated _application frameworks_:\n\n| Framework | Stack | Built by | Prisma ORM | Description |\n| --- | --- | --- | --- | --- |\n| [Redwood.js](https://redwoodjs.com/) | Fullstack | [Tom Preston-Werner](https://github.com/mojombo/) | Built on top of Prisma ORM | _Bringing full-stack to the JAMstack._ |\n\n> **Note**: If you notice any GraphQL libraries/frameworks missing from the list, please let us know.\n\n## Prisma ORM & GraphQL examples[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#prisma-orm--graphql-examples \"Direct link to Prisma ORM & GraphQL examples\")\n\nIn the following section will find several ready-to-run examples that showcase how to use Prisma ORM with different combinations of the tools mentioned in the table above.\n\n### TypeScript[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#typescript \"Direct link to TypeScript\")\n\n| Example | HTTP Server | GraphQL schema | Description |\n| --- | --- | --- | --- |\n| [GraphQL API (Pothos)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql) | `graphql-yoga` | `pothos` | GraphQL server based on [`graphql-yoga`](https://the-guild.dev/graphql/yoga-server) |\n| [GraphQL API (SDL-first)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-sdl-first) | `graphql-yoga` | n/a | GraphQL server based on the SDL-first approach |\n| [GraphQL API -- NestJs](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-nestjs) | `@nestjs/apollo` | n/a | GraphQL server based on [NestJS](https://nestjs.com/) |\n| [GraphQL API -- NestJs (SDL-first)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-nestjs-sdl-first) | `@nestjs/apollo` | n/a | GraphQL server based on [NestJS](https://nestjs.com/) |\n| [GraphQL API (Nexus)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-nexus) | `@apollo/server` | `nexus` | GraphQL server based on [`@apollo/server`](https://www.apollographql.com/docs/apollo-server) |\n| [GraphQL API (TypeGraphQL)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-typegraphql) | `apollo-server` | `type-graphql` | GraphQL server based on the code-first approach of [TypeGraphQL](https://typegraphql.com/) |\n| [GraphQL API (Auth)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-auth) | `apollo-server` | `nexus` | GraphQL server with email-password authentication & permissions |\n| [Fullstack app](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-nextjs) | `graphql-yoga` | `pothos` | Fullstack app with Next.js (React), Apollo Client, GraphQL Yoga and Pothos |\n| [GraphQL subscriptions](https://github.com/prisma/prisma-examples/tree/latest/typescript/subscriptions-pubsub) | `apollo-server` | `nexus` | GraphQL server implementing realtime GraphQL subscriptions |\n| [GraphQL API -- Hapi](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-hapi) | `apollo-server-hapi` | `nexus` | GraphQL server based on [Hapi](https://hapi.dev/) |\n| [GraphQL API -- Hapi (SDL-first)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-hapi-sdl-first) | `apollo-server-hapi` | `graphql-tools` | GraphQL server based on [Hapi](https://hapi.dev/) |\n| [GraphQL API -- Fastify](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-fastify) | `fastify` & `mercurius` | n/a | GraphQL server based on [Fastify](https://fastify.io/) and [Mercurius](https://mercurius.dev/) |\n| [GraphQL API -- Fastify (SDL-first)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-fastify-sdl-first) | `fastify` | `Nexus` | GraphQL server based on [Fastify](https://fastify.io/) and [Mercurius](https://mercurius.dev/) |\n\n### JavaScript (Node.js)[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#javascript-nodejs \"Direct link to JavaScript (Node.js)\")\n\n| Demo | HTTP Server | GraphQL schema | Description |\n| --- | --- | --- | --- |\n| [GraphQL API (Apollo Server)](https://github.com/prisma/prisma-examples/tree/latest/javascript/graphql) | `apollo-server` | `nexus` | GraphQL server based on [`apollo-server`](https://www.apollographql.com/docs/apollo-server/) |\n| [GraphQL API (Auth)](https://github.com/prisma/prisma-examples/tree/latest/javascript/graphql-auth) | `apollo-server` | `nexus` | GraphQL server with email-password authentication & permissions |\n| [GraphQL API (SDL-first)](https://github.com/prisma/prisma-examples/tree/latest/javascript/graphql-sdl-first) | `apollo-server` | `graphql-tools` | GraphQL server based on the SDL-first approach of [`graphql-tools`](https://www.apollographql.com/docs/graphql-tools/) (Apollo) |\n\n## FAQ[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#faq \"Direct link to FAQ\")\n\n### What is Prisma ORM's role in a GraphQL server?[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#what-is-prisma-orms-role-in-a-graphql-server \"Direct link to What is Prisma ORM's role in a GraphQL server?\")\n\nNo matter which of the above GraphQL tools/libraries you use, Prisma ORM is used inside your GraphQL resolvers to connect to your database. It has the same role that any other ORM or SQL query builder would have inside your resolvers.\n\nIn the resolver of a GraphQL query, Prisma ORM typically reads data from the database to return it in the GraphQL response. In the resolver of a GraphQL mutation, Prisma ORM typically also writes data to the database (e.g. creating new or updating existing records).\n\n## Other GraphQL Resources[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/graphql#other-graphql-resources \"Direct link to Other GraphQL Resources\")\n\nPrisma curates [GraphQL Weekly](https://www.graphqlweekly.com/), a newsletter highlighting resources and updates from the GraphQL community. Subscribe to keep up-to-date with GraphQL articles, videos, tutorials, libraries, and more.",
  "title": "Building GraphQL servers with Prisma ORM | Prisma Documentation",
  "description": "This page gives explains how to build GraphQL servers with Prisma ORM. It shows how Prisma ORM fits into the GraphQL ecosystem and provides practical examples.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/development-environment/environment-variables",
  "markdown": "# Environment variables | Prisma Documentation\n\nAn environment variable is a key value pair of string data that is stored on your machine's local environment. Refer to our [Environment variables reference documentation](https://www.prisma.io/docs/orm/reference/environment-variables-reference) for specific details.\n\nTypically the name of the variable is uppercase, this is then followed by an equals sign then the value of the variable:\n\nThe environment variable belongs to the environment where a process is running.\n\nTaking the `TEMP` environment variable as an example, one can query its value to find where to store temporary files. This is a system environment variable and can be queried by any process or application running on the machine.\n\nAny program can read and create these environment variables. They are a cheap and effective way to store simple information.\n\n## How does Prisma ORM use environment variables?[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables#how-does-prisma-orm-use-environment-variables \"Direct link to How does Prisma ORM use environment variables?\")\n\nPrisma ORM always reads environment variables from the system's environment.\n\nWhen you initialize Prisma ORM in your project with `prisma init`, it creates a convenience `.env` file for you to set your [`connection url`](https://www.prisma.io/docs/orm/reference/connection-urls) as an environment variable. When you use Prisma CLI or Prisma Client, the `.env` file content and the variables defined in it are added to the [`process.env` object](https://nodejs.org/api/process.html#processenv), where Prisma ORM can read it and use it.\n\ninfo\n\nLooking to use more than one `.env` file? See [Using multiple `.env` files](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/using-multiple-env-files) for information on how to setup and use multiple `.env` files in your application.\n\n### Using environment variables in your code[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables#using-environment-variables-in-your-code \"Direct link to Using environment variables in your code\")\n\nIf you want environment variables to be evaluated at runtime, you need to load them manually in your application code (for example, by using [`dotenv`](https://github.com/motdotla/dotenv)):\n\n```\nimport * as dotenv from 'dotenv'dotenv.config() // Load the environment variablesconsole.log(`The connection URL is ${process.env.DATABASE_URL}`)\n```",
  "title": "Environment variables | Prisma Documentation",
  "description": "Learn how to use environment variables in your Prisma ORM project",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest",
  "markdown": "# Building REST APIs with Prisma ORM\n\nWhen building REST APIs, Prisma Client can be used inside your _route controllers_ to send databases queries.\n\n![REST APIs with Prisma Client](https://www.prisma.io/docs/assets/images/prisma-rest-apis-0e61276a3ec593d67c0a7d46875fe023.png)\n\n## Supported libraries[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#supported-libraries \"Direct link to Supported libraries\")\n\nAs Prisma Client is \"only\" responsible for sending queries to your database, it can be combined with any HTTP server library or web framework of your choice.\n\nHere's a non-exhaustive list of libraries and frameworks you can use with Prisma ORM:\n\n*   [Express](https://expressjs.com/)\n*   [koa](https://koajs.com/)\n*   [hapi](https://hapi.dev/)\n*   [Fastify](https://www.fastify.io/)\n*   [Sails](https://sailsjs.com/)\n*   [AdonisJs](https://adonisjs.com/)\n*   [NestJS](https://nestjs.com/)\n*   [Next.js](https://nextjs.org/)\n*   [Foal TS](https://foalts.org/)\n*   [Polka](https://github.com/lukeed/polka)\n*   [Micro](https://github.com/zeit/micro)\n*   [Feathers](https://feathersjs.com/)\n*   [Remix](https://remix.run/)\n\n## REST API server example[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#rest-api-server-example \"Direct link to REST API server example\")\n\nAssume you have a Prisma schema that looks similar to this:\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:./dev.db\"}generator client {  provider = \"prisma-client-js\"}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  author    User?   @relation(fields: [authorId], references: [id])  authorId  Int?}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\nYou can now implement route controller (e.g. using Express) that use the generated [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client) to perform a database operation when an incoming HTTP request arrives. This page only shows few sample code snippets; if you want to run these code snippets, you can use a [REST API example](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-express).\n\n#### `GET`[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#get \"Direct link to get\")\n\n```\napp.get('/feed', async (req, res) => {  const posts = await prisma.post.findMany({    where: { published: true },    include: { author: true },  })  res.json(posts)})\n```\n\nNote that the `feed` endpoint in this case returns a nested JSON response of `Post` objects that _include_ an `author` object. Here's a sample response:\n\n```\n[  {    \"id\": \"21\",    \"title\": \"Hello World\",    \"content\": \"null\",    \"published\": \"true\",    \"authorId\": 42,    \"author\": {      \"id\": \"42\",      \"name\": \"Alice\",      \"email\": \"alice@prisma.io\"    }  }]\n```\n\n#### `POST`[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#post \"Direct link to post\")\n\n```\napp.post(`/post`, async (req, res) => {  const { title, content, authorEmail } = req.body  const result = await prisma.post.create({    data: {      title,      content,      published: false,      author: { connect: { email: authorEmail } },    },  })  res.json(result)})\n```\n\n#### `PUT`[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#put \"Direct link to put\")\n\n```\napp.put('/publish/:id', async (req, res) => {  const { id } = req.params  const post = await prisma.post.update({    where: { id: Number(id) },    data: { published: true },  })  res.json(post)})\n```\n\n#### `DELETE`[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#delete \"Direct link to delete\")\n\n```\napp.delete(`/post/:id`, async (req, res) => {  const { id } = req.params  const post = await prisma.post.delete({    where: {      id: Number(id),    },  })  res.json(post)})\n```\n\n## Ready-to-run example projects[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#ready-to-run-example-projects \"Direct link to Ready-to-run example projects\")\n\nYou can find several ready-to-run examples that show how to implement a REST API with Prisma Client, as well as build full applications, in the [`prisma-examples`](https://github.com/prisma/prisma-examples/) repository.\n\n### TypeScript[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#typescript \"Direct link to TypeScript\")\n\n| **Example** | **Stack** | **Description** |\n| --- | --- | --- |\n| [`rest-express`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-express) | Backend only | REST API with Express for TypeScript |\n| [`rest-fastify`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-fastify) | Backend only | REST API using Fastify and Prisma Client. |\n| [`rest-hapi`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-hapi) | Backend only | REST API using hapi and Prisma Client |\n| [`rest-nestjs`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nestjs) | Backend only | Nest.js app (Express) with a REST API |\n| [`rest-nextjs-express`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nextjs-express) | Fullstack | Next.js app (React, Express) and Prisma Client |\n| [`rest-nextjs-api-routes`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nextjs-api-routes) | Fullstack | Next.js app (React) with a REST API |\n| [`rest-nextjs-api-routes-auth`](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nextjs-api-routes-auth) | Fullstack | Implement authentication using NextAuth.js |\n\n### JavaScript[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/rest#javascript \"Direct link to JavaScript\")\n\n| **Example** | **Stack** | **Description** |\n| --- | --- | --- |\n| [`rest-express`](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-express) | Backend only | REST API using Express and Prisma Client |\n| [`rest-fastify`](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-fastify) | Backend only | REST API using Fastify and Prisma Client |\n| [`rest-nextjs`](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-nextjs) | Fullstack | Next.js app (React) with a REST API |\n| [`rest-nuxtjs`](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-nuxtjs) | Fullstack | App with NuxtJs using Vue (frontend), Express, and Prisma Client |",
  "title": "Building REST APIs with Prisma ORM | Prisma Documentation",
  "description": "This page gives an overview of the most important things when building REST APIs with Prisma. It shows practical examples and the supported libraries.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack",
  "markdown": "# Building fullstack applications with Prisma ORM\n\nFullstack frameworks, such as Next.js, Remix or SvelteKit, blur the lines between the server and the client. These frameworks also provide different patterns for fetching and mutating data on the server.\n\nYou can query your database using Prisma Client, using your framework of choice, from the server-side part of your application.\n\n## Supported frameworks[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#supported-frameworks \"Direct link to Supported frameworks\")\n\nHere's a non-exhaustive list of frameworks and libraries you can use with Prisma ORM:\n\n*   [Next.js](https://nextjs.org/)\n*   [Remix](https://remix.run/)\n*   [SvelteKit](https://kit.svelte.dev/)\n*   [Nuxt](https://nuxt.com/)\n*   [Redwood](https://redwoodjs.com/)\n*   [t3 stack — using tRPC](https://create.t3.gg/)\n*   [Wasp](https://wasp-lang.dev/)\n\n## Fullstack app example (e.g. Next.js)[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#fullstack-app-example-eg-nextjs \"Direct link to Fullstack app example (e.g. Next.js)\")\n\ntip\n\nIf you want to learn how to build an app with Next.js and Prisma ORM, check out this comprehensive [video tutorial](https://www.youtube.com/watch?v=QXxy8Uv1LnQ&ab_channel=ByteGrad).\n\nAssume you have a Prisma schema that looks similar to this:\n\n```\ndatasource db {  provider = \"sqlite\"  url      = \"file:./dev.db\"}generator client {  provider = \"prisma-client-js\"}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  author    User?   @relation(fields: [authorId], references: [id])  authorId  Int?}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\nYou can now implement the logic for querying your database using [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client) inside `getServerSideProps`, `getStaticProps`, API routes, or using API libraries such as [tRPC](https://trpc.io/) and [GraphQL](https://graphql.org/).\n\n### `getServerSideProps`[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#getserversideprops \"Direct link to getserversideprops\")\n\n```\n// (in /pages/index.tsx)// Alternatively, you can use `getStaticProps`// in place of `getServerSideProps`.export const getServerSideProps = async () => {  const feed = await prisma.post.findMany({    where: {      published: true,    },  })  return { props: { feed } }}\n```\n\nNext.js will pass the props to your React component where you can display the data from your database.\n\n### API Routes[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#api-routes \"Direct link to API Routes\")\n\n```\n// Fetch all posts (in /pages/api/posts.ts)const prisma = new PrismaClient()export default async function handle(req, res) {  const posts = await prisma.post.findMany({    where: {      published: true,    },  })  res.json(posts)}\n```\n\nNote that you can use Prisma ORM inside of Next.js API routes to send queries to your database – with REST, GraphQL, and tRPC.\n\nYou can then fetch data and display it in your frontend.\n\n## Ready-to-run fullstack example projects[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#ready-to-run-fullstack-example-projects \"Direct link to Ready-to-run fullstack example projects\")\n\nYou can find several ready-to-run examples that show how to fullstack apps with Prisma Client in the [`prisma-examples`](https://github.com/prisma/prisma-examples/) repository.\n\n### TypeScript[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#typescript \"Direct link to TypeScript\")\n\n| **Example** | **Description** |\n| --- | --- |\n| [Next.js (API Routes)](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nextjs-api-routes) | Fullstack Next.js app using `getServerSideProps` & API Routes |\n| [Next.js (GraphQL)](https://github.com/prisma/prisma-examples/tree/latest/typescript/graphql-nextjs) | Fullstack Next.js app using GraphQL Yoga, Pothos, & Apollo Client |\n| [Next.js (tRPC)](https://github.com/prisma/prisma-examples/tree/latest/typescript/trpc-nextjs) | Fullstack Next.js app using tRPC |\n| [Next.js (API Routes with auth)](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nextjs-api-routes-auth) | Fullstack Next.js app using `getServerSideProps`, API Routes, & [NextAuth](https://next-auth.js.org/) |\n| [Remix](https://github.com/prisma/prisma-examples/tree/latest/typescript/remix) | Fullstack Remix app using actions and loaders |\n| [SvelteKit](https://github.com/prisma/prisma-examples/tree/latest/typescript/sveltekit) | Fullstack Sveltekit app using actions and loaders |\n| [SvelteKit (REST API)](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-sveltekit) | Fullstack Sveltekit app using API routes |\n| [Nuxt (REST API)](https://github.com/prisma/prisma-examples/tree/latest/typescript/rest-nuxtjs) | Fullstack Nuxt app using API routes |\n\n### JavaScript[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/fullstack#javascript \"Direct link to JavaScript\")\n\n| **Example** | **Description** |\n| --- | --- |\n| [Next.js (API Routes)](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-nextjs) | Fullstack Next.js app using `getServerSideProps` & API Routes |\n| [SvelteKit (REST API)](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-sveltekit) | Fullstack Sveltekit app using API routes |\n| [Nuxt (REST API)](https://github.com/prisma/prisma-examples/tree/latest/javascript/rest-nuxtjs) | Fullstack Nuxt app using API routes |",
  "title": "Building fullstack applications with Prisma ORM | Prisma Documentation",
  "description": "This page gives explains how to build fullstack applications with Prisma. It shows how Prisma fits in with fullstack frameworks and provides practical examples",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions",
  "markdown": "# Special rules for referential actions in SQL Server and MongoDB\n\nSome databases have specific requirements that you should consider if you are using referential actions.\n\n*   Microsoft SQL Server doesn't allow cascading referential actions on a foreign key, if the relation chain causes a cycle or multiple cascade paths. If the referential actions on the foreign key are set to something other than `NO ACTION` (or `NoAction` if Prisma ORM is managing referential integrity), the server will check for cycles or multiple cascade paths and return an error when executing the SQL.\n    \n*   With MongoDB, using referential actions in Prisma ORM requires that for any data model with self-referential relations or cycles between three models, you must set the referential action of `NoAction` to prevent the referential action emulations from looping infinitely. Be aware that by default, the `relationMode = \"prisma\"` mode is used for MongoDB, which means that Prisma ORM manages [referential integrity](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode).\n    \n\nGiven the SQL:\n\n```\nCREATE TABLE [dbo].[Employee] (  [id] INT NOT NULL IDENTITY(1,1),  [managerId] INT,  CONSTRAINT [PK__Employee__id] PRIMARY KEY ([id]));ALTER TABLE [dbo].[Employee]  ADD CONSTRAINT [FK__Employee__managerId]    FOREIGN KEY ([managerId]) REFERENCES [dbo].[Employee]([id])    ON DELETE CASCADE ON UPDATE CASCADE;\n```\n\nWhen the SQL is run, the database would throw the following error:\n\n```\nIntroducing FOREIGN KEY constraint 'FK__Employee__managerId' on table 'Employee' may cause cycles or multiple cascade paths. Specify ON DELETE NO ACTION or ON UPDATE NO ACTION, or modify other FOREIGN KEY constraints.\n```\n\nIn more complicated data models, finding the cascade paths can get complex. Therefore in Prisma ORM, the data model is validated _before_ generating any SQL to be run during any migrations, highlighting relations that are part of the paths. This makes it much easier to find and break these action chains.\n\n## Self-relation (SQL Server and MongoDB)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions#self-relation-sql-server-and-mongodb \"Direct link to Self-relation (SQL Server and MongoDB)\")\n\nThe following model describes a self-relation where an `Employee` can have a manager and managees, referencing entries of the same model.\n\n```\nmodel Employee {  id        Int        @id @default(autoincrement())  manager   Employee?  @relation(name: \"management\", fields: [managerId], references: [id])  managees  Employee[] @relation(name: \"management\")  managerId Int?}\n```\n\nThis will result in the following error:\n\n```\nError parsing attribute \"@relation\": A self-relation must have `onDelete` and `onUpdate` referential actions set to `NoAction` in one of the @relation attributes. (Implicit default `onDelete`: `SetNull`, and `onUpdate`: `Cascade`)\n```\n\nBy not defining any actions, Prisma ORM will use the following default values depending if the underlying [scalar fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) are set to be optional or required.\n\n| Clause | All of the scalar fields are optional | At least one scalar field is required |\n| --- | --- | --- |\n| `onDelete` | `SetNull` | `NoAction` |\n| `onUpdate` | `Cascade` | `Cascade` |\n\nSince the default referential action for `onUpdate` in the above relation would be `Cascade` and for `onDelete` it would be `SetNull`, it creates a cycle and the solution is to explicitly set the `onUpdate` and `onDelete` values to `NoAction`.\n\n```\nmodel Employee {  id        Int        @id @default(autoincrement())  manager   Employee   @relation(name: \"management\", fields: [managerId], references: [id])  manager   Employee   @relation(name: \"management\", fields: [managerId], references: [id], onDelete: NoAction, onUpdate: NoAction)  managees  Employee[] @relation(name: \"management\")  managerId Int}\n```\n\n## Cyclic relation between three tables (SQL Server and MongoDB)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions#cyclic-relation-between-three-tables-sql-server-and-mongodb \"Direct link to Cyclic relation between three tables (SQL Server and MongoDB)\")\n\nThe following models describe a cyclic relation between a `Chicken`, an `Egg` and a `Fox`, where each model references the other.\n\n```\nmodel Chicken {  id        Int   @id @default(autoincrement())  egg       Egg   @relation(fields: [eggId], references: [id])  eggId     Int  predators Fox[]}model Egg {  id         Int       @id @default(autoincrement())  predator   Fox       @relation(fields: [predatorId], references: [id])  predatorId Int  parents    Chicken[]}model Fox {  id        Int     @id @default(autoincrement())  meal      Chicken @relation(fields: [mealId], references: [id])  mealId    Int  foodStore Egg[]}\n```\n\nThis will result in three validation errors in every relation field that is part of the cycle.\n\nThe first one is in the relation `egg` in the `Chicken` model:\n\n```\nError parsing attribute \"@relation\": Reference causes a cycle. One of the @relation attributes in this cycle must have `onDelete` and `onUpdate` referential actions set to `NoAction`. Cycle path: Chicken.egg → Egg.predator → Fox.meal. (Implicit default `onUpdate`: `Cascade`)\n```\n\nThe second one is in the relation `predator` in the `Egg` model:\n\n```\nError parsing attribute \"@relation\": Reference causes a cycle. One of the @relation attributes in this cycle must have `onDelete` and `onUpdate` referential actions set to `NoAction`. Cycle path: Egg.predator → Fox.meal → Chicken.egg. (Implicit default `onUpdate`: `Cascade`)\n```\n\nAnd the third one is in the relation `meal` in the `Fox` model:\n\n```\nError parsing attribute \"@relation\": Reference causes a cycle. One of the @relation attributes in this cycle must have `onDelete` and `onUpdate` referential actions set to `NoAction`. Cycle path: Fox.meal → Chicken.egg → Egg.predator. (Implicit default `onUpdate`: `Cascade`)\n```\n\nAs the relation fields are required, the default referential action for `onDelete` is `NoAction` but for `onUpdate` it is `Cascade`, which causes a referential action cycle. The solution is to set the `onUpdate` value to `NoAction` in any one of the relations.\n\n```\nmodel Chicken {  id        Int   @id @default(autoincrement())  egg       Egg   @relation(fields: [eggId], references: [id])  egg       Egg   @relation(fields: [eggId], references: [id], onUpdate: NoAction)  eggId     Int  predators Fox[]}\n```\n\nor\n\n```\nmodel Egg {  id         Int       @id @default(autoincrement())  predator   Fox       @relation(fields: [predatorId], references: [id])  predator   Fox       @relation(fields: [predatorId], references: [id], onUpdate: NoAction)  predatorId Int  parents    Chicken[]}\n```\n\nor\n\n```\nmodel Fox {  id        Int     @id @default(autoincrement())  meal      Chicken @relation(fields: [mealId], references: [id])  meal      Chicken @relation(fields: [mealId], references: [id], onUpdate: NoAction)  mealId    Int  foodStore Egg[]}\n```\n\n## Multiple cascade paths between two models (SQL Server only)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions/special-rules-for-referential-actions#multiple-cascade-paths-between-two-models-sql-server-only \"Direct link to Multiple cascade paths between two models (SQL Server only)\")\n\nThe data model describes two different paths between same models, with both relations triggering cascading referential actions.\n\n```\nmodel User {  id       Int       @id @default(autoincrement())  comments Comment[]  posts    Post[]}model Post {  id       Int       @id @default(autoincrement())  authorId Int  author   User      @relation(fields: [authorId], references: [id])  comments Comment[]}model Comment {  id          Int  @id @default(autoincrement())  writtenById Int  postId      Int  writtenBy   User @relation(fields: [writtenById], references: [id])  post        Post @relation(fields: [postId], references: [id])}\n```\n\nThe problem in this data model is how there are two paths from `Comment` to the `User`, and how the default `onUpdate` action in both relations is `Cascade`. This leads into two validation errors:\n\nThe first one is in the relation `writtenBy`:\n\n```\nError parsing attribute \"@relation\": When any of the records in model `User` is updated or deleted, the referential actions on the relations cascade to model `Comment` through multiple paths. Please break one of these paths by setting the `onUpdate` and `onDelete` to `NoAction`. (Implicit default `onUpdate`: `Cascade`)\n```\n\nThe second one is in the relation `post`:\n\n```\nError parsing attribute \"@relation\": When any of the records in model `User` is updated or deleted, the referential actions on the relations cascade to model `Comment` through multiple paths. Please break one of these paths by setting the `onUpdate` and `onDelete` to `NoAction`. (Implicit default `onUpdate`: `Cascade`)\n```\n\nThe error means that by updating a primary key in a record in the `User` model, the update will cascade once between the `Comment` and `User` through the `writtenBy` relation, and again through the `Post` model from the `post` relation due to `Post` being related with the `Comment` model.\n\nThe fix is to set the `onUpdate` referential action to `NoAction` in the `writtenBy` or `post` relation fields, or from the `Post` model by changing the actions in the `author` relation:\n\n```\nmodel Comment {  id          Int  @id @default(autoincrement())  writtenById Int  postId      Int  writtenBy   User @relation(fields: [writtenById], references: [id])  writtenBy   User @relation(fields: [writtenById], references: [id], onUpdate: NoAction)  post        Post @relation(fields: [postId], references: [id])}\n```\n\nor\n\n```\nmodel Comment {  id          Int  @id @default(autoincrement())  writtenById Int  postId      Int  writtenBy   User @relation(fields: [writtenById], references: [id])  post        Post @relation(fields: [postId], references: [id])  post        Post @relation(fields: [postId], references: [id], onUpdate: NoAction)}\n```\n\nor\n\n```\nmodel Post {  id       Int       @id @default(autoincrement())  authorId Int  author   User      @relation(fields: [authorId], references: [id])  author   User      @relation(fields: [authorId], references: [id], onUpdate: NoAction)  comments Comment[]}\n```",
  "title": "Special rules for referential actions in SQL Server and MongoDB | Prisma Documentation",
  "description": "Circular references or multiple cascade paths can cause validation errors on Microsoft SQL Server and MongoDB. Since the database does not handle these situations out of the box, learn how to solve this problem.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm",
  "markdown": "# Is Prisma ORM an ORM? | What is an ORM?\n\nTo answer the question briefly: _Yes, Prisma ORM is a new kind of ORM that fundamentally differs from traditional ORMs and doesn't suffer from many of the problems commonly associated with these_.\n\nTraditional ORMs provide an object-oriented way for working with relational databases by mapping tables to _model classes_ in your programming language. This approach leads to many problems that are caused by the [object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object%E2%80%93relational_impedance_mismatch).\n\nPrisma ORM works fundamentally different compared to that. With Prisma ORM, you define your models in the declarative [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) which serves as the single source of truth for your database schema and the models in your programming language. In your application code, you can then use Prisma Client to read and write data in your database in a type-safe manner without the overhead of managing complex model instances. This makes the process of querying data a lot more natural as well as more predictable since Prisma Client always returns plain JavaScript objects.\n\nIn this article, you will learn in more detail about ORM patterns and workflows, how Prisma ORM implements the Data Mapper pattern, and the benefits of Prisma ORM's approach.\n\n## What are ORMs?[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#what-are-orms \"Direct link to What are ORMs?\")\n\nIf you're already familiar with ORMs, feel free to jump to the [next section](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#prisma-orm) on Prisma ORM.\n\n### ORM Patterns - Active Record and Data Mapper[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#orm-patterns---active-record-and-data-mapper \"Direct link to ORM Patterns - Active Record and Data Mapper\")\n\nORMs provide a high-level database abstraction. They expose a programmatic interface through objects to create, read, delete, and manipulate data while hiding some of the complexity of the database.\n\nThe idea with ORMs is that you define your models as **classes** that map to tables in a database. The classes and their instances provide you with a programmatic API to read and write data in the database.\n\nThere are two common ORM patterns: [_Active Record_](https://en.wikipedia.org/wiki/Active_record_pattern) and [_Data Mapper_](https://en.wikipedia.org/wiki/Data_mapper_pattern) which differ in how they transfer data between objects and the database. While both patterns require you to define classes as the main building block, the most notable difference between the two is that the Data Mapper pattern decouples in-memory objects in the application code from the database and uses the data mapper layer to transfer data between the two. In practice, this means that with Data Mapper the in-memory objects (representing data in the database) don't even know that there’s a database present.\n\n#### Active Record[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#active-record \"Direct link to Active Record\")\n\n_Active Record_ ORMs map model classes to database tables where the structure of the two representations is closely related, e.g. each field in the model class will have a matching column in the database table. Instances of the model classes wrap database rows and carry both the data and the access logic to handle persisting changes in the database. Additionally, model classes can carry business logic specific to the data in the model.\n\nThe model class typically has methods that do the following:\n\n*   Construct an instance of the model from an SQL query.\n*   Construct a new instance for later insertion into the table.\n*   Wrap commonly used SQL queries and return Active Record objects.\n*   Update the database and insert into it the data in the Active Record.\n*   Get and set the fields.\n*   Implement business logic.\n\n#### Data Mapper[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#data-mapper \"Direct link to Data Mapper\")\n\n_Data Mapper_ ORMs, in contrast to Active Record, decouple the application's in-memory representation of data from the database's representation. The decoupling is achieved by requiring you to separate the mapping responsibility into two types of classes:\n\n*   **Entity classes**: The application's in-memory representation of entities which have no knowledge of the database\n*   **Mapper classes**: These have two responsibilities:\n    *   Transforming the data between the two representations.\n    *   Generating the SQL necessary to fetch data from the database and persist changes in the database.\n\nData Mapper ORMs allow for greater flexibility between the problem domain as implemented in code and the database. This is because the data mapper pattern allows you to hide the ways in which your database is implemented which isn’t an ideal way to think about your domain behind the whole data-mapping layer.\n\nOne of the reasons that traditional data mapper ORMs do this is due to the structure of organizations where the two responsibilities would be handled by separate teams, e.g., [DBAs](https://en.wikipedia.org/wiki/Database_administrator) and backend developers.\n\nIn reality, not all Data Mapper ORMs adhere to this pattern strictly. For example, [TypeORM](https://github.com/typeorm/typeorm/blob/master/docs/active-record-data-mapper.md#what-is-the-data-mapper-pattern), a popular ORM in the TypeScript ecosystem which supports both Active Record and Data Mapper, takes the following approach to Data Mapper:\n\n*   Entity classes use decorators (`@Column`) to map class properties to table columns and are aware of the database.\n*   Instead of mapper classes, _repository_ classes are used for querying the database and may contain custom queries. Repositories use the decorators to determine the mapping between entity properties and database columns.\n\nGiven the following `User` table in the database:\n\n![user-table](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAAB+CAYAAAC9MirBAAAACXBIWXMAAAsSAAALEgHS3X78AAAQnElEQVR42u2dy09bZxbAzX9AZpHZwj4j0VW6JIuqMVQKVYCZ1dQzPGzPAjuZbtqNXWkyq7TQ8shMWsV5CCdVojKJ0kkbEOShtlI6xUqbOE4EOGCNggSxYQhpC63vnPM9rj9f3+sHfmDjc6QjuPd7+Nr++dzzffec77PZhCS8gcZE70VfvHd85nlvUCMlrRaN9wZnE/3Bt2xGSbgCTc97glH6kEirWnuCC8iqDq4OLfxd6b3QmnAEGm0kJFUgqz3nUTsURhcYn6t94w4JLQFLUo0CXIKe3SfhXekd99tWe4MhPEj0XjpCHxFJtQp4AqiHuM87Pm2T/gN9NCQ1YXU5r0kCl6RmBDhtIHBJCFwSEgK3yqSty+UA1Q53ulrV84f/4GrC822dLj99SgQugUtC4FYaXPvR/g44F7B3uWbsR11Dsk1rhxfU09jW7fLZu90TWPZaV1+L6If3Bf2wOvB6WOcNw+uRELhlAVfWs3dyMO2drhmEWIDZDP9H7ahQ1tbpnIDjpP2ouwP6tYEeYn1143lnAspnDxO4BG4lwAVQz7J6Ha4mQ3vUPyGosgwAbmBWucs1rYILxwvG9iQEblnBxXJ2DFaVWVoDpKIsoCjUc8YVcJP2zn4vfeIEbsV9XDwnLS+zoN393hS44AKkg4t6RgUXX4s+cQK3JCIGXJrRGupAd7sz4kQ51M4QwgogNwiYkzBIywhiInAJ3LJIR4ej0c5v64l2gBQtr73L6ZGDLd0lAMDZYAuOUXm5M5Tmw3a7P8PZBCzHuqI/ApfALY8IF0D6qdwNgGN1IAXw+dPKGex8ygug5mBz/1fUccbRlSBwCdyyC97qEVazW74OsLC4FmVZy0kIXBICl4SEwCUhIXBJCFwCl4TAJSGpGLjb/54lJa16JXBJ9wa4dCMiIR+XhITAJSEhcEkIXBISApeEhMAlIXB3VbTw8gEtsujRHsU+1h4tXStII7Eh1vbJ8kH6ygncygB7f3k/wHeiYFitNLz4iXZ/bj999QRuGaF92qyFly6WDNqUXtQiT5vp669zcGVyoFU5Jhmy5Yiy1DG1tOWBNgUvWd76BrcdU6+7nCGr8p0sCsdu6SbAbZycmt848cUS6ouRmcjWzR9uybKfP/323sbJyfm0+sPTjzc+mn5sAe8JQqCOwW3r+kuLzGItBbja/eirVpYyPnBlM/HXiXUEd/3dayt4vS9O33mAZQhyAsplXTyOD1x+uX03MmVpeeeWDhAG9eoqdPZ71cUwMPNVXY1QX5IoX3DDMU82cBFIeYzwrvuvPzOCizDje9m6+f3t7DMOix7CoG4triuKawukQOZLD7H1B/hqhNGCwH24+GHe4Po+f7b2ztVVFdxtcB/wffz48Z0f8pllIAwIXOE28EXdVItcELhZQENw133Xn/10/ptZdBfwel+e+zqkuwbuS1tYB/8mv1u4kc9AjTAgcPX1tV7vdB7ZsY+bA9zn4LcyFwEAltBKcPH6N9FNcF/aRrAJXAI3T4trvqJhYeBaPx0zugqqqj7u1tXQV/hecKYh11M1woDA1deGVVc01N2HfMGN5D84swIXdfP9yXl0GX65+3iSBmcEblZw8WFDO1//NYoQ8xUNxSJxec8qLB0oBbjo46JbIQdvpvokRvELBK487mtJrUaI68L2exnMhTyAKGV8As0oELiFSK7VDLOCO1fmR77Y9xw98iVwyyAYCFMWeMMUZEPglhtetLw7icG11hNkaQncygH8MHaQzTaEY0OFwwrgYyB5mOISCFwSEgKXhITAJSFwSUgIXBKS6gNXblHPg8fZTuCt7SY7LZKQVA24qU2X3SEMHEdw5W6KxVwcPnV7LUtK0F4Qr3/U5vWNtpSuv0HUJgI3H2srdlJUIcMYXGNoY6GCMQ5qDMSeg9Y3DJANt3r9p86UDtqh5mP+0WkCNw9rK6O/ML9MBtIw10EJbWR5acwy97Ww3cL1en0t2A5dDDyP7gXbtZFbcbZHLtY1bvxseh34GrhlqeiP5bspOzdiv2Lv3YBZuVUfyvWwdmYukNqvsRzPG+8cwjK+ApDNHPOPhcDy+o+9N/aWUtYCZUPH/acCqfOjqC1e35jXCD/WQUt73D82CP1FsT9UAjeLVWQuAovB5fDxL5LBHFW+vGhbt3OCR4k5QwwaAISHQLpDHHrnRFunm7kXeMzT3lmUWcDe6RzMx+rLSDWR66ap18DXd2Ahl+yHIzeUloFAah+8juzDHZLtZNSbCmd7t3OQRcEh7DLfrpv/0MSaEhqCbW5txyZAbwFkDvjbkbKaOnwOADgEQH4gyvaxMoBXqbsgLHcT/H9W/BAc4II4CNw8oFGtlym4HApHpm9svuGyMVwyn2tIC2A/6hwyXpcarWbM1jDtA35kah8SRPkDle9BzXLmr5v6QVhFyAkL6lddBYC0gVnhNOvLYE3C/42izSsc1kEAdeTscWFZAVSbAJ1chVKCa4QQIVB2EQ+YpPsUDK56S9bBNLgDom4A7wBm4Kp98PfhTBivS4Ir27Tz9xtg7o7YXT3XBtPm4I4BuGManAvI2z1zI/yjcTjXygEdg3ZjXjiXQIBTVpzArQi4chDHBmECYPQRiwFXvQYjuPyWzn8kzCeVFtkAbrb3YQWudJNUzRWLnA1c9G9VcEW9pvRB2JiGLgSBuwvgpvUjQJIWr5TgGm/x3I/mGclFgWuRHJr3VJi5q6BbV4uZA+bnHntv1MNdBmmJCdyKgIszCjjIQVCxrRzYSHDlbZqV5wAjX3CxT9mf9LuLATcjx66DTwOm+bwmswoctBEAbcSrgiZhBiBn5XysHMhxsEca0K9F2MX5Q1A3jnUNx40EbtnAxexf9qVran6aahHV3LViXQVl1oC/FvSP0BUDrnR35CBO0YBeZpEommY9mXKAAdwG0CHuMrDzCTieTllUtLKBxvS6UK73NxoSfS4QuGUUZqWyDGSKyV0zCpuTzTFoKrZv47Xm9nVPoTZJGPm5AGqj8Xx+LkhmfwTuLgoOqNACGrVNWTWHpD6kpsCVFs2opbLGJAQuCQmBS0JC4JIQuCQkBC4JCYFLQuDmIfYujEPNHuhNQlJ14BYSDJNLKM9sJ/3VR55ZVYNLeWY7gbY+8szKDi4LLOl2+axzsKo7zwxfu5g8MzjXQHlmNQguh841o+ZgqdFSu5Vnxq6nRHlmPFg8M88MXs92pMOxD46TheWZIdCF5pkB0HWUZ1ZxV0ENDZQ5Wq9bBMbUap4Zh9cZx9cCLVeeWbye88zKDi67zWJ6OlpUnsYSleDu8TyzZGnzzBBcyjOrCLgicDoqb6MMYEMwdmaeWcolKHeembytlynP7EyZ88xeqec8s7KCK7c/VS2pGQjGW3vF8swM11dDeWbN9Z5nVhFw0YqyPLLfs5G3PmCyyjOT4OyFPDOrWQUO2s7zzKDNoJJXtqDkmb1ZD3lmZQXX4MOKHdQZHALc3Hlm7Xp5zeWZnYHzWNZc+Twz2d/ezTMrObimc6x55JHt1TyzbLMKKYApz6wqwS2VUJ4ZSU2CS3lmJDUJLgkJgUtC4JKQELgkRYn2aKmhrBqJgS7atCfLBG7dwxZeRj3A9hgu7SbbpddIbIhd55Plg1p4sUG7P0fg1h2w95dR97Nd3KsZVisNL34C4O7XIk8J3J2IDBCXDxbeEEHf5XrQUBpon6I2a+GlizUJbUqDAG7zblremgVXPtqVcb2FBr6w5/wlerYvAsEbs+V9CUv72z0AbQpesLwE7g4E4w70TIYCwT3OshBONZUGXB47kC37gPmGeJvd8S06xzmr8nAeba36y9ae6wltbqm2wc2Wn4VQsegpkzqYmya3UjXe5lk+mJJLZtwAEINYlHDINHBxd0tsY3atPDQQA7L1+NcWBUIHy/liZSkL6vWNeA31ZHhik4jWivIfA54bbk23tlHUV62AjHuubG5N/nBLntu++2hKPwfl6/7Pn629PbGW/M/8DVnn50/v3dv4+xdLav3tu5Ep2efG8PTj+MCVTfw+sS0ey7Y/XQ19hfXV60g7h9cEbZl6uL44feeByfVfBXAP1Cy4IjGSBVYreWN6TK2MtjLmcLG4A5ErZswFE+2i6XuSpcA0bjWVkZIj4nzNHg2LaCsNAeZ5X9zyYtIhHM+Icz6RA9bC2wx38GN0CVhAi4+FIfKwQlHGMhgcxtRzLRxD9ViBi5/5FoCjgqufQ3Dfubby3H1pe+Pk5LwO2vlvZtfeubqq1mfgQv3/nby5EB+4/BLbb9+JTL0893UI20v4EFKsbwRXPyeuCetjH6wf+aPImHFY9NQkuGbB2hnWryt9+yQe2sjAjRrbWO95JtqIEMhc4MoBnNV1i1SZlEXFrFkGnxqthVb3VEA95nDLZEXeXuaMWbkK2kNwEx4ufrhjcN+9trJx4osltZ4VuL+CVcb/X57/OqS+zovhmUjcfWmrEHDl62dxFXCW4eOaBFcCpOZfybwuCZVFfGsa7Gab9fHtVnkKuN6niHHNB9xskgGuD4O7UyneqHjrx3PKIKxRxMrGZWJjXuDyifxrxYCLVnPz/cl5vO3jOStwt798cIu1VVwPFUysky+42D/+YFAtLS64CzUNrl0FV6jB4hYEbsr9wDBGzBVze8sKLs9ACGXkfCnrGfB2mInAs20rDS76uPyWf/uBJbg3ObhG0HYCLvrQL0ZmIqh7D9wsu8oYfdyCwDWu1SBchTKCi35vKGsbnu8V5dm2LM2mMT9wYw2WT8cEJD/CYEsHV7WaCrhYtnn67gO85W9+NBMxAzcpXYVziqsAfeCxdBUk3MbBnqmrkPup2mDNDs5knhjOFKAfiyN9tJjFgqvnnmFumvCT8wVXpqRnATd67L1/HEl3A0YTx2HQpZ7D1WXkvK9IaGySoMpsW/jbgG7FcYtVZODLRbUcnCGY677rz36583jy12/nbzB/dODyplqugyiO5a3cbHCGfSU8VzaxP+ZWiBmDzfen2OBOWm422IPyX+/N38A2a+/y/iS4+Jrbtx9NoSa/TUFuGJwN1Cy4PN1cX7GGq1idZqfgHk4N1vS8NJbjlSe42WYVuE/LrCbmd4UkwDiDIPO99L/Cl+XTXWIRjtR+YiwzV0lYFP2NetJnFZZQf2dltRC8xNufrcvPf+3tf61t3fz+dhq4ymBLggqgrejHfcGkvJ0jmHibl/2hSmjTLOzA5Zf6awK06nSa2pbNMIC7YDod9iR2sOYfQFjt81WMFNNf7sU5eH5Xvudz9JW1nfBzs8YnJL9buIHTV6V8wrX15fe3EVB1Ki3tRwOvh6+7w7iFXZlRoCCbSsYpzC2j4iPfYKUfzyK8aNGNU2TFBdvA+5ijR771AW/kqY0Fp+wCvKWNEONBNrv5WRK4u2N592uPYqeZj1hb0OL1/m03LS2Bu9sAP4yhHmSzDeHYkICiShV+ZJHFAbC0B6rl8yNwSWpSCFwSApeEhMAlISFwSQhcEpJqBTfhCNCCciRVK//t/yewOp4CN947PoMHK70XWunjIalG0fx+22rfedtqz4U3kdXV3uCsbaV33M8o7glGyeqSVBuwCU/Attp/wZYYOPsbZBStbaIn+EcbwipOMHhXe4Id9JGl+VSku6V9wYaE5+w+8AYOKYzO619QwnGxSS8gJa1OTSK0yGqGhVn987gD/IdQ3X9ApFWlq73j0+DS+lRX9v/2CuVQIST8YQAAAABJRU5ErkJggg==)\n\nThis is what the corresponding entity class would look like:\n\n```\nimport { Entity, PrimaryGeneratedColumn, Column } from 'typeorm'@Entity()export class User {  @PrimaryGeneratedColumn()  id: number  @Column({ name: 'first_name' })  firstName: string  @Column({ name: 'last_name' })  lastName: string  @Column({ unique: true })  email: string}\n```\n\n### Schema migration workflows[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#schema-migration-workflows \"Direct link to Schema migration workflows\")\n\nA central part of developing applications that make use of a database is changing the database schema to accommodate new features and to better fit the problem you're solving. In this section, we'll discuss what [schema migrations](https://www.prisma.io/dataguide/types/relational/what-are-database-migrations) are and how they affect the workflow.\n\nBecause the ORM sits between the developer and the database, most ORMs provide a **migration tool** to assist with the creation and modification of the database schema.\n\nA migration is a set of steps to take the database schema from one state to another. The first migration usually creates tables and indices. Subsequent migrations may add or remove columns, introduce new indices, or create new tables. Depending on the migration tool, the migration may be in the form of SQL statements or programmatic code which will get converted to SQL statements (as with [ActiveRecord](https://guides.rubyonrails.org/active_record_migrations.html) and [SQLAlchemy](https://alembic.sqlalchemy.org/en/latest/tutorial.html#create-a-migration-script)).\n\nBecause databases usually contain data, migrations assist you with breaking down schema changes into smaller units which helps avoid inadvertent data loss.\n\nAssuming you were starting a project from scratch, this is what a full workflow would look like: you create a migration that will create the `User` table in the database schema and define the `User` entity class as in the example above.\n\nThen, as the project progresses and you decide you want to add a new `salutation` column to the `User` table, you would create another migration which would alter the table and add the `salutation` column.\n\nLet's take a look at how that would look like with a TypeORM migration:\n\n```\nimport { MigrationInterface, QueryRunner } from 'typeorm'export class UserRefactoring1604448000 implements MigrationInterface {  async up(queryRunner: QueryRunner): Promise<void> {    await queryRunner.query(`ALTER TABLE \"User\" ADD COLUMN \"salutation\" TEXT`)  }  async down(queryRunner: QueryRunner): Promise<void> {    await queryRunner.query(`ALTER TABLE \"User\" DROP COLUMN \"salutation\"`)  }}\n```\n\nOnce a migration is carried out and the database schema has been altered, the entity and mapper classes must also be updated to account for the new `salutation` column.\n\nWith TypeORM that means adding a `salutation` property to the `User` entity class:\n\n```\nimport { Entity, PrimaryGeneratedColumn, Column } from 'typeorm'@Entity()export class User {  @PrimaryGeneratedColumn()  id: number  @Column({ name: 'first_name' })  firstName: string  @Column({ name: 'last_name' })  lastName: string  @Column({ unique: true })  email: string  @Column()  salutation: string}\n```\n\nSynchronizing such changes can be a challenge with ORMs because the changes are applied manually and are not easily verifiable programmatically. Renaming an existing column can be even more cumbersome and involve searching and replacing references to the column.\n\n> **Note:** Django's [makemigrations](https://docs.djangoproject.com/en/3.1/ref/django-admin/#django-admin-makemigrations) CLI generates migrations by inspecting changes in models which, similar to Prisma ORM, does away with the synchronization problem.\n\nIn summary, evolving the schema is a key part of building applications. With ORMs, the workflow for updating the schema involves using a migration tool to create a migration followed by updating the corresponding entity and mapper classes (depending on the implementation). As you'll see, Prisma ORM takes a different approach to this.\n\nNow that you've seen what migrations are and how they fit into the development workflows, you will learn more about the benefits and drawbacks of ORMs.\n\n### Benefits of ORMs[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#benefits-of-orms \"Direct link to Benefits of ORMs\")\n\nThere are different reasons why developers choose to use ORMs:\n\n*   ORMs facilitate implementing the domain model. The domain model is an object model that incorporates the behavior and data of your business logic. In other words, it allows you to focus on real business concepts rather than the database structure or SQL semantics.\n*   ORMs help reduce the amount of code. They save you from writing repetitive SQL statements for common CRUD (Create Read Update Delete) operations and escaping user input to prevent vulnerabilities such as SQL injections.\n*   ORMs require you to write little to no SQL (depending on your complexity you may still need to write the odd raw query). This is beneficial for developers who are not familiar with SQL but still want to work with a database.\n*   Many ORMs abstract database-specific details. In theory, this means that an ORM can make changing from one database to another easier. It should be noted that in practice applications rarely change the database they use.\n\nAs with all abstractions that aim to improve productivity, there are also drawbacks to using ORMs.\n\n### Drawbacks of ORMs[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#drawbacks-of-orms \"Direct link to Drawbacks of ORMs\")\n\nThe drawbacks of ORMs are not always apparent when you start using them. This section covers some of the commonly accepted ones:\n\n*   With ORMs, you form an object graph representation of database tables which may lead to the [object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch). This happens when the problem you are solving forms a complex object graph which doesn't trivially map to a relational database. Synchronizing between two different representations of data, one in the relational database, and the other in-memory (with objects) is quite difficult. This is because objects are more flexible and varied in the way they can relate to each other compared to relational database records.\n*   While ORMs handle the complexity associated with the problem, the synchronization problem doesn't go away. Any changes to the database schema or the data model require the changes to be mapped back to the other side. This burden is often on the developer. In the context of a team working on a project, database schema changes require coordination.\n*   ORMs tend to have a large API surface due to the complexity they encapsulate. The flip side of not having to write SQL is that you spend a lot of time learning how to use the ORM. This applies to most abstractions, however without understanding how the database works, improving slow queries can be difficult.\n*   Some _complex queries_ aren't supported by ORMs due to the flexibility that SQL offers. This problem is alleviated by raw SQL querying functionality in which you pass the ORM a SQL statement string and the query is run for you.\n\nNow that the costs and benefits of ORMs have been covered, you can better understand what Prisma ORM is and how it fits in.\n\n## Prisma ORM[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#prisma-orm \"Direct link to Prisma ORM\")\n\nPrisma ORM is a **next-generation ORM** that makes working with databases easy for application developers and features the following tools:\n\n*   [**Prisma Client**](https://www.prisma.io/docs/orm/prisma-client): Auto-generated and type-safe database client for use in your application.\n*   [**Prisma Migrate**](https://www.prisma.io/docs/orm/prisma-migrate): A declarative data modeling and migration tool.\n*   [**Prisma Studio**](https://www.prisma.io/docs/orm/tools/prisma-studio): A modern GUI for browsing and managing data in your database.\n\n> **Note:** Since Prisma Client is the most prominent tool, we often refer to it as simply Prisma.\n\nThese three tools use the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) as a single source of truth for the database schema, your application's object schema, and the mapping between the two. It's defined by you and is your main way of configuring Prisma ORM.\n\nPrisma ORM makes you productive and confident in the software you're building with features such as _type safety_, rich auto-completion, and a natural API for fetching relations.\n\nIn the next section, you will learn about how Prisma ORM implements the Data Mapper ORM pattern.\n\n### How Prisma ORM implements the Data Mapper pattern[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#how-prisma-orm-implements-the-data-mapper-pattern \"Direct link to How Prisma ORM implements the Data Mapper pattern\")\n\nAs mentioned earlier in the article, the Data Mapper pattern aligns well with organizations where the database and application are owned by different teams.\n\nWith the rise of modern cloud environments with managed database services and DevOps practices, more teams embrace a cross-functional approach, whereby teams own both the full development cycle including the database and operational concerns.\n\nPrisma ORM enables the evolution of the DB schema and object schema in tandem, thereby reducing the need for deviation in the first place, while still allowing you to keep your application and database somewhat decoupled using `@map` attributes. While this may seem like a limitation, it prevents the domain model's evolution (through the object schema) from getting imposed on the database as an afterthought.\n\nTo understand how Prisma ORM's implementation of the Data Mapper pattern differs conceptually to traditional Data Mapper ORMs, here's a brief comparison of their concepts and building blocks:\n\n| Concept | Description | Building block in traditional ORMs | Building block in Prisma ORM | Source of truth in Prisma ORM |\n| --- | --- | --- | --- | --- |\n| Object schema | The in-memory data structures in your applications | Model classes | Generated TypeScript types | Models in the Prisma schema |\n| Data Mapper | The code which transforms between the object schema and the database | Mapper classes | Generated functions in Prisma Client | @map attributes in the Prisma schema |\n| Database schema | The structure of data in the database, e.g., tables and columns | SQL written by hand or with a programmatic API | SQL generated by Prisma Migrate | Prisma schema |\n\nPrisma ORM aligns with the Data Mapper pattern with the following added benefits:\n\n*   Reducing the boilerplate of defining classes and mapping logic by generating a Prisma Client based on the Prisma schema.\n*   Eliminating the synchronization challenges between application objects and the database schema.\n*   Database migrations are a first-class citizen as they're derived from the Prisma schema.\n\nNow that we've talked about the concepts behind Prisma ORM's approach to Data Mapper, we can go through how the Prisma schema works in practice.\n\n### Prisma schema[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#prisma-schema \"Direct link to Prisma schema\")\n\nAt the heart of Prisma's implementation of the Data Mapper pattern is the _Prisma schema_ – a single source of truth for the following responsibilities:\n\n*   Configuring how Prisma connects to your database.\n*   Generating Prisma Client – the type-safe ORM for use in your application code.\n*   Creating and evolving the database schema with Prisma Migrate.\n*   Defining the mapping between application objects and database columns.\n\nModels in Prisma ORM mean something slightly different to Active Record ORMs. With Prisma ORM, models are defined in the Prisma schema as abstract entities which describe tables, relations, and the mappings between columns to properties in Prisma Client.\n\nAs an example, here's a Prisma schema for a blog:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String? @map(\"post_content\")  published Boolean @default(false)  author    User?   @relation(fields: [authorId], references: [id])  authorId  Int?}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\nHere's a break down of the example above:\n\n*   The `datasource` block defines the connection to the database.\n*   The `generator` block tells Prisma ORM to generate Prisma Client for TypeScript and Node.js.\n*   The `Post` and `User` models map to database tables.\n*   The two models have a _1-n_ relation where each `User` can have many related `Post`s.\n*   Each field in the models has a type, e.g. the `id` has the type `Int`.\n*   Fields may contain field attributes to define:\n    *   Primary keys with the `@id` attribute.\n    *   Unique keys with the `@unique` attribute.\n    *   Default values with the `@default` attribute.\n    *   Mapping between table columns and Prisma Client fields with the `@map` attribute, e.g., the `content` field (which will be accessible in Prisma Client) maps to the `post_content` database column.\n\nThe `User` / `Post` relation can be visualized with the following diagram:\n\n![1-n relation between User and Post](https://www.prisma.io/docs/assets/images/user-post-relation-1-n-bb9740243c22ae8f3685667ee2cce56f.png)\n\nAt a Prisma ORM level, the `User` / `Post` relation is made up of:\n\n*   The scalar `authorId` field, which is referenced by the `@relation` attribute. This field exists in the database table – it is the foreign key that connects Post and User.\n*   The two relation fields: `author` and `posts` **do not exist** in the database table. Relation fields define connections between models at the Prisma ORM level and exist only in the Prisma schema and generated Prisma Client, where they are used to access the relations.\n\nThe declarative nature of Prisma schema is concise and allows defining the database schema and corresponding representation in Prisma Client.\n\nIn the next section, you will learn about Prisma ORM's supported workflows.\n\n### Prisma ORM workflow[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#prisma-orm-workflow \"Direct link to Prisma ORM workflow\")\n\nThe workflow with Prisma ORM is slightly different to traditional ORMs. You can use Prisma ORM when building new applications from scratch or adopt it incrementally:\n\n*   _New application_ (greenfield): Projects that have no database schema yet can use Prisma Migrate to create the database schema.\n*   _Existing application_ (brownfield): Projects that already have a database schema can be [introspected](https://www.prisma.io/docs/orm/prisma-schema/introspection) by Prisma ORM to generate the Prisma schema and Prisma Client. This use-case works with any existing migration tool and is useful for incremental adoption. It's possible to switch to Prisma Migrate as the migration tool. However, this is optional.\n\nWith both workflows, the Prisma schema is the main configuration file.\n\n#### Workflow for incremental adoption in projects with an existing database[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#workflow-for-incremental-adoption-in-projects-with-an-existing-database \"Direct link to Workflow for incremental adoption in projects with an existing database\")\n\nBrownfield projects typically already have some database abstraction and schema. Prisma ORM can integrate with such projects by introspecting the existing database to obtain a Prisma schema that reflects the existing database schema and to generate Prisma Client. This workflow is compatible with any migration tool and ORM which you may already be using. If you prefer to incrementally evaluate and adopt, this approach can be used as part of a [parallel adoption strategy](https://en.wikipedia.org/wiki/Parallel_adoption).\n\nA non-exhaustive list of setups compatible with this workflow:\n\n*   Projects using plain SQL files with `CREATE TABLE` and `ALTER TABLE` to create and alter the database schema.\n*   Projects using a third party migration library like [db-migrate](https://github.com/db-migrate/node-db-migrate) or [Umzug](https://github.com/sequelize/umzug).\n*   Projects already using an ORM. In this case, database access through the ORM remains unchanged while the generated Prisma Client can be incrementally adopted.\n\nIn practice, these are the steps necessary to introspect an existing DB and generate Prisma Client:\n\n1.  Create a `schema.prisma` defining the `datasource` (in this case, your existing DB) and `generator`:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://janedoe:janedoe@localhost:5432/hello-prisma\"}generator client {  provider = \"prisma-client-js\"}\n```\n\n2.  Run `prisma db pull` to populate the Prisma schema with models derived from your database schema.\n3.  (Optional) Customize [field and model mappings](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections) between Prisma Client and the database.\n4.  Run `prisma generate`.\n\nPrisma ORM will generate Prisma Client inside the `node_modules` folder, from which it can be imported in your application. For more extensive usage documentation, see the [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client) docs.\n\nTo summarize, Prisma Client can be integrated into projects with an existing database and tooling as part of a parallel adoption strategy. New projects will use a different workflow detailed next.\n\n#### Workflow for new projects[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#workflow-for-new-projects \"Direct link to Workflow for new projects\")\n\nPrisma ORM is different from ORMs in terms of the workflows it supports. A closer look at the steps necessary to create and change a new database schema is useful for understanding Prisma Migrate.\n\nPrisma Migrate is a CLI for declarative data modeling & migrations. Unlike most migration tools that come as part of an ORM, you only need to describe the current schema, instead of the operations to move from one state to another. Prisma Migrate infers the operations, generates the SQL and carries out the migration for you.\n\nThis example demonstrates using Prisma ORM in a new project with a new database schema similar to the blog example above:\n\n1.  Create the Prisma schema:\n\n```\n// schema.prismadatasource db {  provider = \"postgresql\"  url      = \"postgresql://janedoe:janedoe@localhost:5432/hello-prisma\"}generator client {  provider = \"prisma-client-js\"}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String? @map(\"post_content\")  published Boolean @default(false)  author    User?   @relation(fields: [authorId], references: [id])  authorId  Int?}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\n2.  Run `prisma migrate` to generate the SQL for the migration, apply it to the database, and generate Prisma Client.\n\nFor any further changes to the database schema:\n\n1.  Apply changes to the Prisma schema, e.g., add a `registrationDate` field to the `User` model\n2.  Run `prisma migrate` again.\n\nThe last step demonstrates how declarative migrations work by adding a field to the Prisma schema and using Prisma Migrate to transform the database schema to the desired state. After the migration is run, Prisma Client is automatically regenerated so that it reflects the updated schema.\n\nIf you don't want to use Prisma Migrate but still want to use the type-safe generated Prisma Client in a new project, see the next section.\n\n##### Alternative for new projects without Prisma Migrate[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#alternative-for-new-projects-without-prisma-migrate \"Direct link to Alternative for new projects without Prisma Migrate\")\n\nIt is possible to use Prisma Client in a new project with a third-party migration tool instead of Prisma Migrate. For example, a new project could choose to use the Node.js migration framework [db-migrate](https://github.com/db-migrate/node-db-migrate) to create the database schema and migrations and Prisma Client for querying. In essence, this is covered by the [workflow for existing databases](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#workflow-for-incremental-adoption-in-projects-with-an-existing-database).\n\n## Accessing data with Prisma Client[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#accessing-data-with-prisma-client \"Direct link to Accessing data with Prisma Client\")\n\nSo far, the article covered the concepts behind Prisma ORM, its implementation of the Data Mapper pattern, and the workflows it supports. In this last section, you will see how to access data in your application using Prisma Client.\n\nAccessing the database with Prisma Client happens through the query methods it exposes. All queries return plain old JavaScript objects. Given the blog schema from above, fetching a user looks as follows:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()const user = await prisma.user.findUnique({  where: {    email: 'alice@prisma.io',  },})\n```\n\nIn this query, the `findUnique()` method is used to fetch a single row from the `User` table. By default, Prisma ORM will return all the scalar fields in the `User` table.\n\n> **Note:** The example uses TypeScript to make full use of the type safety features offered by Prisma Client. However, Prisma ORM also works with [JavaScript in Node.js](https://dev.to/prisma/productive-development-with-prisma-s-zero-cost-type-safety-4od2).\n\nPrisma Client maps queries and results to [structural types](https://en.wikipedia.org/wiki/Structural_type_system) by generating code from the Prisma schema. This means that `user` has an associated type in the generated Prisma Client:\n\n```\nexport type User = {  id: number  email: string  name: string | null}\n```\n\nThis ensures that accessing a non-existent field will raise a type error. More broadly, it means that the result's type for every query is known ahead of running the query, which helps catch errors. For example, the following code snippet will raise a type error:\n\n```\nconsole.log(user.lastName) // Property 'lastName' does not exist on type 'User'.\n```\n\n### Fetching relations[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#fetching-relations \"Direct link to Fetching relations\")\n\nFetch relations with Prisma Client is done with the `include` option. For example, to fetch a user and their posts would be done as follows:\n\n```\nconst user = await prisma.user.findUnique({  where: {    email: 'alice@prisma.io',  },  include: {    posts: true,  },})\n```\n\nWith this query, `user`'s type will also include `Post`s which can be accessed with the `posts` array field:\n\n```\nconsole.log(user.posts[0].title)\n```\n\nThe example only scratches the surface of Prisma Client's API for [CRUD operations](https://www.prisma.io/docs/orm/prisma-client/queries/crud) which you can learn more about in the docs. The main idea is that all queries and results are backed by types and you have full control over how relations are fetched.\n\n## Conclusion[​](https://www.prisma.io/docs/orm/overview/prisma-in-your-stack/is-prisma-an-orm#conclusion \"Direct link to Conclusion\")\n\nIn summary, Prisma ORM is a new kind of Data Mapper ORM that differs from traditional ORMs and doesn't suffer from the problems commonly associated with them.\n\nUnlike traditional ORMs, with Prisma ORM, you define the Prisma schema – a declarative single source of truth for the database schema and application models. All queries in Prisma Client return plain JavaScript objects which makes the process of interacting with the database a lot more natural as well as more predictable.\n\nPrisma ORM supports two main workflows for starting new projects and adopting in an existing project. For both workflows, your main avenue for configuration is via the Prisma schema.\n\nLike all abstractions, both Prisma ORM and other ORMs hide away some of the underlying details of the database with different assumptions.\n\nThese differences and your use case all affect the workflow and cost of adoption. Hopefully understanding how they differ can help you make an informed decision.",
  "title": "Is Prisma ORM an ORM? | What is an ORM? | Prisma Documentation",
  "description": "Learn about how Prisma ORM implements the Data Mapper ORM pattern and how it achieves the same goal as traditional ORMs without requiring you to map classes to tables as traditional ORMs do.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/overview/introduction/data-modeling",
  "markdown": "# Data modeling with Prisma | Prisma Documentation\n\n## What is data modeling?[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#what-is-data-modeling \"Direct link to What is data modeling?\")\n\nThe term _data modeling_ refers to the **process of defining the shape and structure of the objects in an application**, these objects are often called \"application models\". In relational databases (like PostgreSQL), they are stored in _tables_ . When using document databases (like MongoDB), they are stored in _collections_.\n\nDepending on the domain of your application, the models will be different. For example, if you're writing a blogging application, you might have models such as _blog_, _author_, _article_. When writing a car-sharing app, you probably have models like _driver_, _car_, _route_. Application models enable you to represent these different entities in your code by creating respective _data structures_.\n\nWhen modeling data, you typically ask questions like:\n\n*   What are the main entities/concepts in my application?\n*   How do they relate to each other?\n*   What are their main characteristics/properties?\n*   How can they be represented with my technology stack?\n\n## Data modeling without Prisma ORM[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#data-modeling-without-prisma-orm \"Direct link to Data modeling without Prisma ORM\")\n\nData modeling typically needs to happen on (at least) two levels:\n\n*   On the **database** level\n*   On the **application** level (i.e., in your programming language)\n\nThe way that the application models are represented on both levels might differ due to a few reasons:\n\n*   Databases and programming languages use different data types\n*   Relations are represented differently in a database than in a programming language\n*   Databases typically have more powerful data modeling capabilities, like indexes, cascading deletes, or a variety of additional constraints (e.g. unique, not null, ...)\n*   Databases and programming languages have different technical constraints\n\n### Data modeling on the database level[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#data-modeling-on-the-database-level \"Direct link to Data modeling on the database level\")\n\n#### Relational databases[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#relational-databases \"Direct link to Relational databases\")\n\nIn relational databases, models are represented by _tables_. For example, you might define a `users` table to store information about the users of your application. Using PostgreSQL, you'd define it as follows:\n\n```\nCREATE TABLE users (  user_id SERIAL PRIMARY KEY NOT NULL,  name VARCHAR(255),  email VARCHAR(255) UNIQUE NOT NULL,  isAdmin BOOLEAN NOT NULL DEFAULT false);\n```\n\nA visual representation of the `users` table with some random data might look as follows:\n\n| `user_id` | `name` | `email` | `isAdmin` |\n| --- | --- | --- | --- |\n| `1` | `Alice` | `alice@prisma.io` | `false` |\n| `2` | `Bob` | `bob@prisma.io` | `false` |\n| `3` | `Sarah` | `sarah@prisma.io` | `true` |\n\nIt has the following columns:\n\n*   `user_id`: An integer that increments with every new record in the `users` table. It also represents the [primary key](https://en.wikipedia.org/wiki/Primary_key) for each record.\n*   `name`: A string with at most 255 characters.\n*   `email`: A string with at most 255 characters. Additionally, the added constraints express that no two records can have duplicate values for the `email` column, and that _every_ record needs to have a value for it.\n*   `isAdmin`: A boolean that indicates whether the user has admin rights (default value: `false`)\n\n#### MongoDB[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#mongodb \"Direct link to MongoDB\")\n\nIn MongoDB databases, models are represented by _collections_ and contain _documents_ that can have any structure:\n\n```\n{  _id: '607ee94800bbe41f001fd568',  slug: 'prisma-loves-mongodb',  title: 'Prisma <3 MongoDB',  body: \"This is my first post. Isn't MongoDB + Prisma awesome?!\"}\n```\n\nPrisma Client currently expects a consistent model and [normalized model design](https://docs.mongodb.com/manual/core/data-model-design/#normalized-data-models). This means that:\n\n*   If a model or field is not present in the Prisma schema, it is ignored\n*   If a field is mandatory but not present in the MongoDB dataset, you will get an error\n\n### Data modeling on the application level[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#data-modeling-on-the-application-level \"Direct link to Data modeling on the application level\")\n\nIn addition to creating the tables that represent the entities from your application domain, you also need to create application models in your programming language. In object-oriented languages, this is often done by creating _classes_ to represent your models. Depending on the programming language, this might also be done with _interfaces_ or _structs_.\n\nThere often is a strong correlation between the tables in your database and the models you define in your code. For example, to represent records from the aforementioned `users` table in your application, you might define a JavaScript (ES6) class looking similar to this:\n\n```\nclass User {  constructor(user_id, name, email, isAdmin) {    this.user_id = user_id    this.name = name    this.email = email    this.isAdmin = isAdmin  }}\n```\n\nWhen using TypeScript, you might define an interface instead:\n\n```\ninterface User {  user_id: number  name: string  email: string  isAdmin: boolean}\n```\n\nNotice how the `User` model in both cases has the same properties as the `users` table in the previous example. While it's often the case that there's a 1:1 mapping between database tables and application models, it can also happen that models are represented completely differently in the database and your application.\n\nWith this setup, you can retrieve records from the `users` table and store them as instances of your `User` type. The following example code snippet uses [`pg`](https://node-postgres.com/) as the driver for PostgreSQL and creates a `User` instance based on the above defined JavaScript class:\n\n```\nconst resultRows = await client.query('SELECT * FROM users WHERE user_id = 1')const userData = resultRows[0]const user = new User(  userData.user_id,  userData.name,  userData.email,  userData.isAdmin)// user = {//   user_id: 1,//   name: \"Alice\",//   email: \"alice@prisma.io\",//   isAdmin: false// }\n```\n\nNotice that in these examples, the application models are \"dumb\", meaning they don't implement any logic but their sole purpose is to carry data as _plain old JavaScript objects_.\n\n### Data modeling with ORMs[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#data-modeling-with-orms \"Direct link to Data modeling with ORMs\")\n\nORMs are commonly used in object-oriented languages to make it easier for developers to work with a database. The key characteristic of an ORM is that it lets you model your application data in terms of _classes_ which are mapped to _tables_ in the underlying database.\n\nThe main difference compared to the approaches explained above is these classes not only carry data but also implement a substantial amount of logic. Mostly for storage, retrieval, serialization, and deserialization, but sometimes they also implement business logic that's specific to your application.\n\nThis means, you don't write SQL statements to read and write data in the database, but instead the instances of your model classes provide an API to store and retrieve data.\n\n[Sequelize](https://sequelize.org/) is a popular ORM in the Node.js ecosystem, this is how you'd define the same `User` model from the sections before using Sequelize's modeling approach:\n\n```\nclass User extends Model {}User.init(  {    user_id: {      type: Sequelize.INTEGER,      primaryKey: true,      autoIncrement: true,    },    name: Sequelize.STRING(255),    email: {      type: Sequelize.STRING(255),      unique: true,    },    isAdmin: Sequelize.BOOLEAN,  },  { sequelize, modelName: 'user' })\n```\n\nTo get an example with this `User` class to work, you still need to create the corresponding table in the database. With Sequelize, you have two ways of doing this:\n\n*   Run `User.sync()` (typically not recommended for production)\n*   Use [Sequelize migrations](https://sequelize.org/v5/manual/migrations.html) to change your database schema\n\nNote that you'll never instantiate the `User` class manually (using `new User(...)`) as was shown in the previous section, but rather call _static_ methods on the `User` class which then return the `User` model instances:\n\n```\nconst user = await User.findByPk(42)\n```\n\nThe call to `findByPk` creates a SQL statement to retrieve the `User` record that's identified by the ID value `42`.\n\nThe resulting `user` object is an instance of Sequelize's `Model` class (because `User` inherits from `Model`). It's not a POJO, but an object that implements additional behavior from Sequelize.\n\n## Data modeling with Prisma ORM[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#data-modeling-with-prisma-orm \"Direct link to Data modeling with Prisma ORM\")\n\nDepending on which parts of Prisma ORM you want to use in your application, the data modeling flow looks slightly different. The following two sections explain the workflows for using [**only Prisma Client**](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#using-only-prisma-client) and using [**Prisma Client and Prisma Migrate**](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#using-prisma-client-and-prisma-migrate).\n\nNo matter which approach though, with Prisma ORM you never create application models in your programming language by manually defining classes, interfaces, or structs. Instead, the application models are defined in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema):\n\n*   **Only Prisma Client**: Application models in the Prisma schema are _generated based on the introspection of your database schema_. Data modeling happens primarily on the database-level.\n*   **Prisma Client and Prisma Migrate**: Data modeling happens in the Prisma schema by _manually adding application models_ to it. Prisma Migrate maps these application models to tables in the underlying database (currently only supported for relational databases).\n\nAs an example, the `User` model from the previous example would be represented as follows in the Prisma schema:\n\n```\nmodel User {  user_id Int     @id @default(autoincrement())  name    String?  email   String  @unique  isAdmin Boolean @default(false)}\n```\n\nOnce the application models are in your Prisma schema (whether they were added through introspection or manually by you), the next step typically is to generate Prisma Client which provides a programmatic and type-safe API to read and write data in the shape of your application models.\n\nPrisma Client uses TypeScript [type aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases) to represent your application models in your code. For example, the `User` model would be represented as follows in the generated Prisma Client library:\n\n```\nexport declare type User = {  id: number  name: string | null  email: string  isAdmin: boolean}\n```\n\nIn addition to the generated types, Prisma Client also provides a data access API that you can use once you've installed the `@prisma/client` package:\n\n```\nimport { PrismaClient } from '@prisma/client'// or// const { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()// use inside an `async` function to `await` the resultawait prisma.user.findUnique(...)await prisma.user.findMany(...)await prisma.user.create(...)await prisma.user.update(...)await prisma.user.delete(...)await prisma.user.upsert(...)\n```\n\n### Using only Prisma Client[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#using-only-prisma-client \"Direct link to Using only Prisma Client\")\n\nWhen using only Prisma Client and _not_ using Prisma Migrate in your application, data modeling needs to happen on the database level via SQL. Once your SQL schema is ready, you use Prisma's introspection feature to add the application models to your Prisma schema. Finally, you generate Prisma Client which creates the types as well as the programmatic API for you to read and write data in your database.\n\nHere is an overview of the main workflow:\n\n1.  Change your database schema using SQL (e.g. `CREATE TABLE`, `ALTER TABLE`, ...)\n2.  Run `prisma db pull` to introspect the database and add application models to the Prisma schema\n3.  Run `prisma generate` to update your Prisma Client API\n\n### Using Prisma Client and Prisma Migrate[​](https://www.prisma.io/docs/orm/overview/introduction/data-modeling#using-prisma-client-and-prisma-migrate \"Direct link to Using Prisma Client and Prisma Migrate\")\n\nWhen using [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate), you define your application in the Prisma schema and with relational databases use the `prisma migrate` subcommand to generate plain SQL migration files, which you can edit before applying. With MongoDB, you use `prisma db push` instead which applies the changes to your database directly.\n\nHere is an overview of the main workflow:\n\n1.  Manually change your application models in the Prisma schema (e.g. add a new model, remove an existing one, ...)\n2.  Run `prisma migrate dev` to create and apply a migration or run `prisma db push` to apply the changes directly (in both cases Prisma Client is automatically generated)",
  "title": "Data modeling with Prisma | Prisma Documentation",
  "description": "Learn how data modeling with Prisma differs from data modeling with SQL or ORMs. Prisma uses a declarative data modeling language to describe a database schema.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections",
  "markdown": "# Database connections | Prisma Documentation\n\nDatabases can handle a limited number of concurrent connections. Each connection requires RAM, which means that simply increasing the database connection limit without scaling available resources:\n\n*   ✔ might allow more processes to connect _but_\n*   ✘ significantly affects **database performance**, and can result in the database being **shut down** due to an out of memory error\n\nThe way your application **manages connections** also impacts performance. This guide describes how to approach connection management in [serverless environments](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas) and [long-running processes](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#long-running-processes).\n\nwarning\n\nThis guide focuses on **relational databases** and how to configure and tune the Prisma ORM connection pool (MongoDB uses the MongoDB driver connection pool).\n\n## Long-running processes[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#long-running-processes \"Direct link to Long-running processes\")\n\nExamples of long-running processes include Node.js applications hosted on a service like Heroku or a virtual machine. Use the following checklist as a guide to connection management in long-running environments:\n\n*   Start with the [recommended pool size (`connection_limit`)](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#recommended-connection-pool-size) and [tune it](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool)\n*   Make sure you have [**one** global instance of `PrismaClient`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#prismaclient-in-long-running-applications)\n\n### Recommended connection pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#recommended-connection-pool-size \"Direct link to Recommended connection pool size\")\n\nThe recommended connection pool size (`connection_limit`) to [start with](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool) for long-running processes is the **default pool size** (`num_physical_cpus * 2 + 1`) ÷ **number of application instances**.\n\ninfo\n\n`num_physical_cpus` refers to the the number of CPUs of the machine your application is running on.\n\nIf you have **one** application instances:\n\n*   The default pool size applies by default (`num_physical_cpus * 2 + 1`) - you do not need to set the `connection_limit` parameter.\n*   You can optionally [tune the pool size](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool).\n\nIf you have **multiple** application instances:\n\n*   You must **manually** [set the `connection_limit` parameter](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#setting-the-connection-pool-size) . For example, if your calculated pool size is _10_ and you have _2_ instances of your app, the `connection_limit` parameter should be **no more than _5_**.\n*   You can optionally [tune the pool size](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool).\n\n### `PrismaClient` in long-running applications[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#prismaclient-in-long-running-applications \"Direct link to prismaclient-in-long-running-applications\")\n\nIn **long-running** applications, we recommend that you:\n\n*   ✔ Create **one** instance of `PrismaClient` and re-use it across your application\n*   ✔ Assign `PrismaClient` to a global variable _in dev environments only_ to [prevent hot reloading from creating new instances](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#prevent-hot-reloading-from-creating-new-instances-of-prismaclient)\n\n#### Re-using a single `PrismaClient` instance[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#re-using-a-single-prismaclient-instance \"Direct link to re-using-a-single-prismaclient-instance\")\n\nTo re-use a single instance, create a module that exports a `PrismaClient` object:\n\nclient.ts\n\n```\nimport { PrismaClient } from '@prisma/client'let prisma = new PrismaClient()export default prisma\n```\n\nThe object is [cached](https://nodejs.org/api/modules.html#modules_caching) the first time the module is imported. Subsequent requests return the cached object rather than creating a new `PrismaClient`:\n\napp.ts\n\n```\nimport prisma from './client'async function main() {  const allUsers = await prisma.user.findMany()}main()\n```\n\nYou do not have to replicate the example above exactly - the goal is to make sure `PrismaClient` is cached. For example, you can [instantiate `PrismaClient` in the `context` object](https://github.com/prisma/prisma-examples/blob/9f1a6b9e7c25b9e1851bd59b273046158d748995/typescript/graphql-express/src/context.ts#L9) that you [pass into an Express app](https://github.com/prisma/prisma-examples/blob/9f1a6b9e7c25b9e1851bd59b273046158d748995/typescript/graphql-express/src/server.ts#L12).\n\n#### Do not explicitly `$disconnect()`[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#do-not-explicitly-disconnect \"Direct link to do-not-explicitly-disconnect\")\n\nYou [do not need to explicitly `$disconnect()`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#calling-disconnect-explicitly) in the context of a long-running application that is continuously serving requests. Opening a new connection takes time and can slow down your application if you disconnect after each query.\n\n#### Prevent hot reloading from creating new instances of `PrismaClient`[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#prevent-hot-reloading-from-creating-new-instances-of-prismaclient \"Direct link to prevent-hot-reloading-from-creating-new-instances-of-prismaclient\")\n\nFrameworks like [Next.js](https://nextjs.org/) support hot reloading of changed files, which enables you to see changes to your application without restarting. However, if the framework refreshes the module responsible for exporting `PrismaClient`, this can result in **additional, unwanted instances of `PrismaClient` in a development environment**.\n\nAs a workaround, you can store `PrismaClient` as a global variable in development environments only, as global variables are not reloaded:\n\nclient.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const globalForPrisma = globalThis as unknown as { prisma: PrismaClient }export const prisma =  globalForPrisma.prisma || new PrismaClient()if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n```\n\nThe way that you import and use Prisma Client does not change:\n\napp.ts\n\n```\nimport { prisma } from './client'async function main() {  const allUsers = await prisma.user.findMany()}main()\n```\n\n## Serverless environments (FaaS)[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas \"Direct link to Serverless environments (FaaS)\")\n\nExamples of serverless environments include Node.js functions hosted on AWS Lambda, Vercel or Netlify Functions. Use the following checklist as a guide to connection management in serverless environments:\n\n*   Familiarize yourself with the [serverless connection management challenge](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#the-serverless-challenge)\n*   [Set pool size (`connection_limit`)](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#recommended-connection-pool-size-1) based on whether you have an external connection pooler, and optionally [tune the pool size](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool)\n*   [Instantiate `PrismaClient` outside the handler](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#instantiate-prismaclient-outside-the-handler) and do not explicitly `$disconnect()`\n*   Configure [function concurrency](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#concurrency-limits) and handle [idle connections](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#zombie-connections)\n\n### The serverless challenge[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#the-serverless-challenge \"Direct link to The serverless challenge\")\n\nIn a serverless environment, each function creates **its own instance** of `PrismaClient`, and each client instance has its own connection pool.\n\nConsider the following example, where a single AWS Lambda function uses `PrismaClient` to connect to a database. The `connection_limit` is **3**:\n\n![An AWS Lambda function connecting to a database.](https://www.prisma.io/docs/assets/images/serverless-connections-a0fa3c9d0c54eb1b9d4c7321ae812a74.png)\n\nA traffic spike causes AWS Lambda to spawn two additional lambdas to handle the increased load. Each lambda creates an instance of `PrismaClient`, each with a `connection_limit` of **3**, which results in a maximum of **9** connections to the database:\n\n![Three AWS Lambda function connecting to a database.](https://www.prisma.io/docs/assets/images/serverless-connections-2-23447d81bde18522c5b4dcf08bcf4dac.png)\n\n200 _concurrent functions_ (and therefore 600 possible connections) responding to a traffic spike 📈 can exhaust the database connection limit very quickly. Furthermore, any functions that are **paused** keep their connections open by default and block them from being used by another function.\n\n1.  Start by [setting the `connection_limit` to `1`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#recommended-connection-pool-size-1)\n2.  If a smaller pool size is not enough, consider using an [external connection pooler like PgBouncer](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#external-connection-poolers)\n\n### Recommended connection pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#recommended-connection-pool-size-1 \"Direct link to Recommended connection pool size\")\n\nThe recommended pool size (`connection_limit`) in serverless environments depends on:\n\n*   Whether you are using an [external connection pooler](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#external-connection-poolers)\n*   Whether your functions are [designed to send queries in parallel](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-for-parallel-requests)\n\n#### Without an external connection pooler[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#without-an-external-connection-pooler \"Direct link to Without an external connection pooler\")\n\nIf you are **not** using an external connection pooler, _start_ by setting the pool size (`connection_limit`) to **1**, then [optimize](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-for-parallel-requests). Each incoming request starts a short-lived Node.js process, and many concurrent functions with a high `connection_limit` can quickly **exhaust the _database_ connection limit** during a traffic spike.\n\nThe following example demonstrates how to set the `connection_limit` to 1 in your connection URL:\n\n*   PostgreSQL\n*   MySQL\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=public&connection_limit=1\n```\n\n#### With an external connection pooler[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#with-an-external-connection-pooler \"Direct link to With an external connection pooler\")\n\nIf you are using an external connection pooler, use the default pool size (`num_physical_cpus * 2 + 1`) as a starting point and then [tune the pool size](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool). The external connection pooler should prevent a traffic spike from overwhelming the database.\n\n#### Optimizing for parallel requests[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-for-parallel-requests \"Direct link to Optimizing for parallel requests\")\n\nIf you rarely or never exceed the database connection limit with the pool size set to 1, you can further optimize the connection pool size. Consider a function that sends queries in parallel:\n\n```\nPromise.all() {  query1,  query2,  query3  query4,  ...}\n```\n\nIf the `connection_limit` is 1, this function is forced to send queries **serially** (one after the other) rather than **in parallel**. This slows down the function's ability to process requests, and may result in pool timeout errors. Tune the `connection_limit` parameter until a traffic spike:\n\n*   Does not exhaust the database connection limit\n*   Does not result in pool timeout errors\n\n### `PrismaClient` in serverless environments[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#prismaclient-in-serverless-environments \"Direct link to prismaclient-in-serverless-environments\")\n\n#### Instantiate `PrismaClient` outside the handler[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#instantiate-prismaclient-outside-the-handler \"Direct link to instantiate-prismaclient-outside-the-handler\")\n\nInstantiate `PrismaClient` [outside the scope of the function handler](https://github.com/prisma/e2e-tests/blob/5d1041d3f19245d3d237d959eca94d1d796e3a52/platforms/serverless-lambda/index.ts#L3) to increase the chances of reuse. As long as the handler remains 'warm' (in use), the connection is potentially reusable:\n\n```\nimport { PrismaClient } from '@prisma/client'const client = new PrismaClient()export async function handler() {  /* ... */}\n```\n\n#### Do not explicitly `$disconnect()`[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#do-not-explicitly-disconnect-1 \"Direct link to do-not-explicitly-disconnect-1\")\n\nYou [do not need to explicitly `$disconnect()`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#calling-disconnect-explicitly) at the end of a function, as there is a possibility that the container might be reused. Opening a new connection takes time and slows down your function's ability to process requests.\n\n### Other serverless considerations[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#other-serverless-considerations \"Direct link to Other serverless considerations\")\n\n#### Container reuse[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#container-reuse \"Direct link to Container reuse\")\n\nThere is no guarantee that subsequent nearby invocations of a function will hit the same container - for example, AWS can choose to create a new container at any time.\n\nCode should assume the container to be stateless and create a connection only if it does not exist - Prisma Client JS already implements this logic.\n\n#### Zombie connections[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#zombie-connections \"Direct link to Zombie connections\")\n\nContainers that are marked \"to be removed\" and are not being reused still **keep a connection open** and can stay in that state for some time (unknown and not documented from AWS). This can lead to sub-optimal utilization of the database connections.\n\nA potential solution is to **clean up idle connections** ([`serverless-mysql`](https://github.com/jeremydaly/serverless-mysql) implements this idea, but cannot be used with Prisma ORM).\n\n#### Concurrency limits[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#concurrency-limits \"Direct link to Concurrency limits\")\n\nDepending on your serverless concurrency limit (the number of serverless functions running in parallel), you might still exhaust your database's connection limit. This can happen when too many functions are invoked concurrently, each with its own connection pool, which eventually exhausts the database connection limit. To prevent this, you can [set your serverless concurrency limit](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html) to a number lower than the maximum connection limit of your database divided by the number of connections used by each function invocation (as you might want to be able to connect from another client for other purposes).\n\n## Optimizing the connection pool[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-the-connection-pool \"Direct link to Optimizing the connection pool\")\n\nIf the query engine cannot [process a query in the queue before the time limit](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool#how-the-connection-pool-works) , you will see connection pool timeout exceptions in your log. A connection pool timeout can occur if:\n\n*   Many users are accessing your app simultaneously\n*   You send a large number of queries in parallel (for example, using `await Promise.all()`)\n\nIf you consistently experience connection pool timeouts after configuring the recommended pool size, you can further tune the `connection_limit` and `pool_timeout` parameters.\n\n### Increasing the pool size[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#increasing-the-pool-size \"Direct link to Increasing the pool size\")\n\nIncreasing the pool size allows the query engine to process a larger number of queries in parallel. Be aware that your database must be able to support the increased number of concurrent connections, otherwise you will **exhaust the database connection limit**.\n\nTo increase the pool size, manually set the `connection_limit` to a higher number:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public&connection_limit=40\"}\n```\n\n> **Note**: Setting the `connection_limit` to 1 in serverless environments is a recommended starting point, but [this value can also be tuned](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#optimizing-for-parallel-requests).\n\n### Increasing the pool timeout[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#increasing-the-pool-timeout \"Direct link to Increasing the pool timeout\")\n\nIncreasing the pool timeout gives the query engine more time to process queries in the queue. You might consider this approach in the following scenario:\n\n*   You have already increased the `connection_limit`.\n*   You are confident that the queue will not grow beyond a certain size, otherwise **you will eventually run out of RAM**.\n\nTo increase the pool timeout, set the `pool_timeout` parameter to a value larger than the default (10 seconds):\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5&pool_timeout=20\"}\n```\n\n### Disabling the pool timeout[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#disabling-the-pool-timeout \"Direct link to Disabling the pool timeout\")\n\nDisabling the pool timeout prevents the query engine from throwing an exception after x seconds of waiting for a connection and allows the queue to build up. You might consider this approach in the following scenario:\n\n*   You are submitting a large number of queries for a limited time - for example, as part of a job to import or update every customer in your database.\n*   You have already increased the `connection_limit`.\n*   You are confident that the queue will not grow beyond a certain size, otherwise **you will eventually run out of RAM**.\n\nTo disable the pool timeout, set the `pool_timeout` parameter to `0`:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = \"postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5&pool_timeout=0\"}\n```\n\n## External connection poolers[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#external-connection-poolers \"Direct link to External connection poolers\")\n\nConnection poolers like [Prisma Accelerate](https://www.prisma.io/docs/accelerate) and PgBouncer prevent your application from exhausting the database's connection limit.\n\nIf you would like to use the Prisma CLI in order to perform other actions on your database ,e.g. migrations and introspection, you will need to add an environment variable that provides a direct connection to your database in the `datasource.directUrl` property in your Prisma schema:\n\n.env\n\n```\n# Connection URL to your database using PgBouncer.DATABASE_URL=\"postgres://root:password@127.0.0.1:54321/postgres?pgbouncer=true\"# Direct connection URL to the database used for migrationsDIRECT_URL=\"postgres://root:password@127.0.0.1:5432/postgres\"\n```\n\nYou can then update your `schema.prisma` to use the new direct URL:\n\nschema.prisma\n\n```\ndatasource db {  provider  = \"postgresql\"  url       = env(\"DATABASE_URL\")  directUrl = env(\"DIRECT_URL\")}\n```\n\nMore information about the `directUrl` field can be found [here](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fields).\n\n### Prisma Accelerate[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#prisma-accelerate \"Direct link to Prisma Accelerate\")\n\n[Prisma Accelerate](https://www.prisma.io/docs/accelerate) is a managed external connection pooler built by Prisma that is integrated in the [Prisma Data Platform](https://www.prisma.io/docs/platform) and handles connection pooling for you.\n\n### PgBouncer[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#pgbouncer \"Direct link to PgBouncer\")\n\nPostgreSQL only supports a certain amount of concurrent connections, and this limit can be reached quite fast when the service usage goes up – especially in [serverless environments](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas).\n\n[PgBouncer](https://www.pgbouncer.org/) holds a connection pool to the database and proxies incoming client connections by sitting between Prisma Client and the database. This reduces the number of processes a database has to handle at any given time. PgBouncer passes on a limited number of connections to the database and queues additional connections for delivery when connections becomes available. To use PgBouncer, see [Configure Prisma Client with PgBouncer](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer).\n\n### AWS RDS Proxy[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#aws-rds-proxy \"Direct link to AWS RDS Proxy\")\n\nDue to the way AWS RDS Proxy pins connections, [it does not provide any connection pooling benefits](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#aws-rds-proxy) when used together with Prisma Client.",
  "title": "Database connections | Prisma Documentation",
  "description": "Databases connections",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-typescript-planetscale",
  "markdown": "# Connect your database using TypeScript and PlanetScale\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL as the `provider`. For PlanetScale, you need to edit the `datasource` block to use the `mysql` provider instead:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mysql\"  url      = env(\"DATABASE_URL\")}\n```\n\nYou will also need to set the relation mode type to `prisma` in order to [emulate foreign key constraints](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client) in the `datasource` block:\n\nschema.prisma\n\n```\ndatasource db {  provider     = \"mysql\"  url          = env(\"DATABASE_URL\")  relationMode = \"prisma\"}\n```\n\n> **Note**: Since February 2024, you can alternatively [use foreign key constraints on a database-level in PlanetScale](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-2-enable-foreign-key-constraints-in-the-planetscale-database-settings), which omits the need for setting `relationMode = \"prisma\"`.\n\nThe `url` is [set via an environment variable](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"mysql://janedoe:mypassword@server.us-east-2.psdb.cloud/mydb?sslaccept=strict\"\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database typically depends on the database you use. PlanetScale uses the MySQL connection URL format, which has the following structure (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running (typically `3306` for MySQL)\n*   `DATABASE`: The name of the [database](https://dev.mysql.com/doc/refman/8.0/en/creating-database.html)\n\nFor a database hosted with PlanetScale, the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://myusername:mypassword@server.us-east-2.psdb.cloud/mydb?sslaccept=strict\"\n```\n\nThe connection URL for a given database branch can be found from your PlanetScale account by going to the overview page for the branch and selecting the 'Connect' dropdown. In the 'Passwords' section, generate a new password and select 'Prisma' to get the Prisma format for the connection URL.\n\nAlternative method: connecting using the PlanetScale CLI\n\nAlternatively, you can connect to your PlanetScale database server using the [PlanetScale CLI](https://docs.planetscale.com/reference/planetscale-environment-setup), and use a local connection URL. In this case the connection URL will look like this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://root@localhost:PORT/mydb\"\n```\n\ninfo\n\nWe recommend adding `.env` to your `.gitignore` file to prevent committing your environment variables.\n\nTo connect to your branch, use the following command:\n\n```\npscale connect prisma-test branchname --port PORT\n```\n\nThe `--port` flag can be omitted if you are using the default port `3306`.",
  "title": "Connect your database using TypeScript and PlanetScale | Prisma Documentation",
  "description": "Connect your database to your project using TypeScript and PlanetScale",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode",
  "markdown": "# Manage relations between records with relation modes in Prisma\n\n## Relation mode\n\nIn Prisma schema, relations between records are defined with the [`@relation`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relation) attribute. For example, in the following schema there is a one-to-many relation between the `User` and `Post` models:\n\nschema.prisma\n\n```\nmodel Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)  authorId Int}model User {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\nPrisma ORM has two _relation modes_, `foreignKeys` and `prisma`, that specify how relations between records are enforced.\n\nIf you use Prisma ORM with a relational database, then by default Prisma ORM uses the [`foreignKeys` relation mode](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#handle-relations-in-your-relational-database-with-the-foreignkeys-relation-mode), which enforces relations between records at the database level with foreign keys. A foreign key is a column or group of columns in one table that take values based on the primary key in another table. Foreign keys allow you to:\n\n*   set constraints that prevent you from making changes that break references\n*   set [referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) that define how changes to records are handled\n\nTogether these constraints and referential actions guarantee the _referential integrity_ of the data.\n\nFor the example schema above, Prisma Migrate will generate the following SQL by default if you use the PostgreSQL connector:\n\n```\n-- CreateTableCREATE TABLE \"Post\" (    \"id\" SERIAL NOT NULL,    \"title\" TEXT NOT NULL,    \"authorId\" INTEGER NOT NULL,    CONSTRAINT \"Post_pkey\" PRIMARY KEY (\"id\"));-- CreateTableCREATE TABLE \"User\" (    \"id\" SERIAL NOT NULL,    CONSTRAINT \"User_pkey\" PRIMARY KEY (\"id\"));-- AddForeignKey//highlight-startALTER TABLE \"Post\"  ADD CONSTRAINT \"Post_authorId_fkey\"  FOREIGN KEY (\"authorId\")  REFERENCES \"User\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;//highlight-end\n```\n\nIn this case, the foreign key constraint on the `authorId` column of the `Post` table references the `id` column of the `User` table, and guarantees that a post must have an author that exists. If you update or delete a user then the `ON DELETE` and `ON UPDATE` referential actions specify the `CASCADE` option, which will also delete or update all posts belonging to the user.\n\nSome databases, such as MongoDB or [PlanetScale](https://www.prisma.io/docs/orm/overview/databases/planetscale#differences-to-consider), do not support foreign keys. Additionally, in some cases developers may prefer not to use foreign keys in their relational database that usually does support foreign keys. For these situations, Prisma ORM offers [the `prisma` relation mode](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#emulate-relations-in-prisma-orm-with-the-prisma-relation-mode), which emulates some properties of relations in relational databases. When you use Prisma Client with the `prisma` relation mode enabled, the behavior of queries is identical or similar, but referential actions and some constraints are handled by the Prisma engine rather than in the database.\n\nwarning\n\nThere are performance implications to emulation of referential integrity and referential actions in Prisma Client. In cases where the underlying database supports foreign keys, it is usually the preferred choice.\n\n## How to set the relation mode in your Prisma schema[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#how-to-set-the-relation-mode-in-your-prisma-schema \"Direct link to How to set the relation mode in your Prisma schema\")\n\nTo set the relation mode, add the `relationMode` field in the `datasource` block:\n\nschema.prisma\n\n```\ndatasource db {  provider     = \"mysql\"  url          = env(\"DATABASE_URL\")  relationMode = \"prisma\"}\n```\n\ninfo\n\nThe ability to set the relation mode was introduced as part of the `referentialIntegrity` preview feature in Prisma ORM version 3.1.1, and is generally available in Prisma ORM versions 4.8.0 and later.\n\nThe `relationMode` field was renamed in Prisma ORM version 4.5.0, and was previously named `referentialIntegrity`.\n\nFor relational databases, the available options are:\n\n*   `foreignKeys`: this handles relations in the database with foreign keys. This is the default option for all relational database connectors and is active if no `relationMode` is explicitly set in the `datasource` block.\n*   `prisma`: this emulates relations in Prisma Client. You should also [enable this option](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client) when you use the MySQL connector with a PlanetScale database and don't have native foreign key constraints enabled in your PlanetScale database settings.\n\nFor MongoDB, the only available option is the `prisma` relation mode. This mode is also active if no `relationMode` is explicitly set in the `datasource` block.\n\nwarning\n\nIf you switch between relation modes, Prisma ORM will add or remove foreign keys to your database next time you apply changes to your schema with Prisma Migrate or `db push`. See [Switch between relation modes](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#switch-between-relation-modes) for more information.\n\n## Handle relations in your relational database with the `foreignKeys` relation mode[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#handle-relations-in-your-relational-database-with-the-foreignkeys-relation-mode \"Direct link to handle-relations-in-your-relational-database-with-the-foreignkeys-relation-mode\")\n\nThe `foreignKeys` relation mode handles relations in your relational database with foreign keys. This is the default option when you use a relational database connector (PostgreSQL, MySQL, SQLite, SQL Server, CockroachDB).\n\nThe `foreignKeys` relation mode is not available when you use the MongoDB connector. Some relational databases, [such as PlanetScale](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client), also forbid the use of foreign keys. In these cases, you should instead [emulate relations in Prisma ORM with the `prisma` relation mode](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#emulate-relations-in-prisma-orm-with-the-prisma-relation-mode).\n\n### Referential integrity[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#referential-integrity \"Direct link to Referential integrity\")\n\nThe `foreignKeys` relation mode maintains referential integrity at the database level with foreign key constraints and referential actions.\n\n#### Foreign key constraints[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#foreign-key-constraints \"Direct link to Foreign key constraints\")\n\nWhen you _create_ or _update_ a record with a relation to another record, the related record needs to exist. Foreign key constraints enforce this behavior in the database. If the record does not exist, the database will return an error message.\n\n#### Referential actions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#referential-actions \"Direct link to Referential actions\")\n\nWhen you _update_ or _delete_ a record with a relation to another record, referential actions are triggered in the database. To maintain referential integrity in related records, referential actions prevent changes that would break referential integrity, cascade changes through to related records, or set the value of fields that reference the updated or deleted records to a `null` or default value.\n\nFor more information, see the [referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) page.\n\n### Introspection[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#introspection \"Direct link to Introspection\")\n\nWhen you introspect a relational database with the `db pull` command with the `foreignKeys` relation mode enabled, a `@relation` attribute will be added to your Prisma schema for relations where foreign keys exist.\n\n### Prisma Migrate and `db push`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#prisma-migrate-and-db-push \"Direct link to prisma-migrate-and-db-push\")\n\nWhen you apply changes to your Prisma schema with Prisma Migrate or `db push` with the `foreignKeys` relation mode enabled, foreign keys will be created in your database for all `@relation` attributes in your schema.\n\n## Emulate relations in Prisma ORM with the `prisma` relation mode[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#emulate-relations-in-prisma-orm-with-the-prisma-relation-mode \"Direct link to emulate-relations-in-prisma-orm-with-the-prisma-relation-mode\")\n\nThe `prisma` relation mode emulates some foreign key constraints and referential actions for each Prisma Client query to maintain referential integrity, using some additional database queries and logic.\n\nThe `prisma` relation mode is the default option for the MongoDB connector. It should also be set if you use a relational database that does not support foreign keys. For example, [if you use PlanetScale](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client) without foreign key constraints, you should use the `prisma` relation mode.\n\nwarning\n\nThere are performance implications to emulation of referential integrity in Prisma Client, because it uses additional database queries to maintain referential integrity. In cases where the underlying database can handle referential integrity with foreign keys, it is usually the preferred choice.\n\nEmulation of relations is only available for Prisma Client queries and does not apply to raw queries.\n\n### Which foreign key constraints are emulated?[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#which-foreign-key-constraints-are-emulated \"Direct link to Which foreign key constraints are emulated?\")\n\nWhen you _update_ a record, Prisma ORM will emulate foreign key constraints. This means that when you update a record with a relation to another record, the related record needs to exist. If the record does not exist, Prisma Client will return an error message.\n\nHowever, when you _create_ a record, Prisma ORM does not emulate any foreign key constraints. You will be able to create invalid data.\n\n### Which referential actions are emulated?[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#which-referential-actions-are-emulated \"Direct link to Which referential actions are emulated?\")\n\nWhen you _update_ or _delete_ a record with related records, Prisma ORM will emulate referential actions.\n\nThe following table shows which emulated referential actions are available for each database connector:\n\n| Database | Cascade | Restrict | NoAction | SetNull | SetDefault |\n| --- | --- | --- | --- | --- | --- |\n| PostgreSQL | **✔️** | **✔️** | **❌**‡ | **✔️** | **❌**† |\n| MySQL | **✔️** | **✔️** | **✔️** | **✔️** | **❌**† |\n| SQLite | **✔️** | **✔️** | **❌**‡ | **✔️** | **❌**† |\n| SQL Server | **✔️** | **✔️** | **✔️** | **✔️** | **❌**† |\n| CockroachDB | **✔️** | **✔️** | **✔️** | **✔️** | **❌**† |\n| MongoDB | **✔️** | **✔️** | **✔️** | **✔️** | **❌**† |\n\n*   † The `SetDefault` referential action is not supported in the `prisma` relation mode.\n*   ‡ The `NoAction` referential action is not supported in the `prisma` relation mode for PostgreSQL and SQLite. Instead, use the `Restrict` action.\n\n### Error messages[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#error-messages \"Direct link to Error messages\")\n\nError messages returned by emulated constraints and referential actions in the `prisma` relation mode are generated by Prisma Client and differ slightly from the error messages in the `foreignKeys` relation mode:\n\n```\nExample:// foreignKeys:... Foreign key constraint failed on the field: `ProfileOneToOne_userId_fkey (index)`// prisma:... The change you are trying to make would violate the required relation 'ProfileOneToOneToUserOneToOne' between the `ProfileOneToOne` and `UserOneToOne` models.\n```\n\n### Introspection[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#introspection-1 \"Direct link to Introspection\")\n\nWhen you introspect a database with the `db pull` command with the `prisma` relation mode enabled, relations will not be automatically added to your schema. You will instead need to add any relations manually with the `@relation` attribute. This only needs to be done once – next time you introspect your database, Prisma ORM will keep your added `@relation` attributes.\n\n### Prisma Migrate and `db push`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#prisma-migrate-and-db-push-1 \"Direct link to prisma-migrate-and-db-push-1\")\n\nWhen you apply changes to your Prisma schema with Prisma Migrate or `db push` with the `prisma` relation mode enabled, Prisma ORM will not use foreign keys in your database.\n\n### Indexes[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#indexes \"Direct link to Indexes\")\n\nIn relational databases that use foreign key constraints, the database usually also implicitly creates an index for the foreign key columns. For example, [MySQL will create an index on all foreign key columns](https://dev.mysql.com/doc/refman/8.0/en/constraint-foreign-key.html#:~:text=MySQL%20requires%20that%20foreign%20key%20columns%20be%20indexed%3B%20if%20you%20create%20a%20table%20with%20a%20foreign%20key%20constraint%20but%20no%20index%20on%20a%20given%20column%2C%20an%20index%20is%20created.). This is to allow foreign key checks to run fast and not require a table scan.\n\nThe `prisma` relation mode does not use foreign keys, so no indexes are created when you use Prisma Migrate or `db push` to apply changes to your database. You instead need to manually add an index on your relation scalar fields with the [`@@index`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#index) attribute (or the [`@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique), [`@@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique-1) or [`@@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1) attributes, if applicable).\n\n#### Index validation[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#index-validation \"Direct link to Index validation\")\n\nIf you do not add the index manually, queries might require full table scans. This can be slow, and also expensive on database providers that bill per accessed row. To help avoid this, Prisma ORM warns you when your schema contains fields that are used in a `@relation` that does not have an index defined. For example, take the following schema with a relation between the `User` and `Post` models:\n\nschema.prisma\n\n```\ndatasource db {  provider     = \"mysql\"  url          = env(\"DATABASE_URL\")  relationMode = \"prisma\"}model User {  id    Int    @id  posts Post[]}model Post {  id     Int  @id  userId Int  user   User @relation(fields: [userId], references: [id])}\n```\n\nPrisma ORM displays the following warning when you run `prisma format` or `prisma validate`:\n\n```\nWith `relationMode = \"prisma\"`, no foreign keys are used, so relation fields will not benefit from the index usually created by the relational database under the hood. This can lead to poor performance when querying these fields. We recommend adding an index manually.\n```\n\nTo fix this, add an index to your `Post` model:\n\nschema.prisma\n\n```\nmodel Post {  id     Int  @id  userId Int  user   User @relation(fields: [userId], references: [id])  @@index([userId])}\n```\n\nIf you use the [Prisma VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) (or our [language server in another editor](https://www.prisma.io/docs/orm/more/development-environment/editor-setup)), the warning is augmented with a Quick Fix that adds the required index for you:\n\n![The Quick Fix pop-up for adding an index on a relation scalar field in VS Code](https://www.prisma.io/docs/assets/images/quick-fix-index-a2282aafe221d87196e61ec54170f9b2.png)\n\nIt is only possible to switch between relation modes when you use a relational database connector (PostgreSQL, MySQL, SQLite, SQL Server, CockroachDB).\n\n### Switch from `foreignKeys` to `prisma`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#switch-from-foreignkeys-to-prisma \"Direct link to switch-from-foreignkeys-to-prisma\")\n\nThe default relation mode if you use a relational database and do not include the `relationMode` field in your `datasource` block is `foreignKeys`. To switch to the `prisma` relation mode, add the `relationMode` field with a value of `prisma`, or update the `relationMode` field value to `prisma` if it already exists.\n\nWhen you switch the relation mode from `foreignKeys` to `prisma`, after you first apply changes to your schema with Prisma Migrate or `db push` Prisma ORM will remove all previously created foreign keys in the next migration.\n\nIf you keep the same database, you can then continue to work as normal. If you switch to a database that does not support foreign keys at all, your existing migration history contains SQL DDL that creates foreign keys, which might trigger errors if you ever have to rerun these migrations. In this case, we recommend that you delete the `migrations` directory. (If you use PlanetScale, which does not support foreign keys, we generally recommend that you [use `db push` rather than Prisma Migrate](https://www.prisma.io/docs/orm/overview/databases/planetscale#differences-to-consider).)\n\n### Switch from `prisma` to `foreignKeys`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#switch-from-prisma-to-foreignkeys \"Direct link to switch-from-prisma-to-foreignkeys\")\n\nTo switch from the `prisma` relation mode to the `foreignKeys` relation mode, update the `relationMode` field value from `prisma` to `foreignKeys`. To do this, the database must support foreign keys. When you apply changes to your schema with Prisma Migrate or `db push` for the first time after you switch relation modes, Prisma ORM will create foreign keys for all relations in the next migration.",
  "title": "Manage relations between records with relation modes in Prisma | Prisma Documentation",
  "description": "Manage relations between records with relation modes in Prisma",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/select-fields",
  "markdown": "# Select fields (Concepts) | Prisma Documentation\n\nBy default, when a query returns records (as opposed to a count), the result includes the **default selection set**:\n\n*   **All** scalar fields defined in the Prisma schema (including enums)\n*   **None** of the relations\n\nTo customize the result:\n\n*   Use [`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select) to return specific fields - [you can also use a nested `select` to include relation fields](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#select-specific-fields-of-included-relations)\n*   Use [`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include) to explicitly [include relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads)\n\nSelecting only the fields and relations that you require rather than relying on the default selection set can ✔ reduce the size of the response and ✔ improve query speed.\n\nSince version [5.9.0](https://github.com/prisma/prisma/releases/tag/5.9.0), when doing a relation query with `include` or by using `select` on a relation field, you can also specify the `relationLoadStrategy` to decide whether you want to use a database-level join or perform multiple queries and merge the data on the application level. This feature is currently in [Preview](https://www.prisma.io/docs/orm/more/releases#preview), you can learn more about it [here](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-load-strategies-preview).\n\n## Example schema[​](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#example-schema \"Direct link to Example schema\")\n\nAll examples are based on the following schema:\n\nExpand for sample schema\n\n*   Relational databases\n*   MongoDB\n\n```\ngenerator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model ExtendedProfile {  id        Int    @id @default(autoincrement())  biography String  user      User   @relation(fields: [userId], references: [id])  userId    Int    @unique}model User {  id           Int              @id @default(autoincrement())  name         String?  email        String           @unique  profileViews Int              @default(0)  role         Role             @default(USER)  coinflips    Boolean[]  posts        Post[]  profile      ExtendedProfile?}model Post {  id         Int        @id @default(autoincrement())  title      String  published  Boolean    @default(true)  author     User       @relation(fields: [authorId], references: [id])  authorId   Int  comments   Json?  views      Int        @default(0)  likes      Int        @default(0)  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String @unique  posts Post[]}enum Role {  USER  ADMIN}\n```\n\nFor **relational databases**, use `db push` command to push the example schema to your own database\n\nFor **MongoDB**, ensure your data is in a uniform shape and matches the model defined in the Prisma schema.\n\n## Return the default selection set[​](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#return-the-default-selection-set \"Direct link to Return the default selection set\")\n\nThe following query returns the default selection set (all scalar fields, no relations):\n\n```\n// Query returns User or nullconst getUser: User | null = await prisma.user.findUnique({  where: {    id: 22,  },})\n```\n\n## Select specific fields[​](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#select-specific-fields \"Direct link to Select specific fields\")\n\nUse `select` to return a limited subset of fields instead of all fields. The following example returns the `email` and `name` fields only:\n\n```\n// Returns an object or nullconst getUser: object | null = await prisma.user.findUnique({  where: {    id: 22,  },  select: {    email: true,    name: true,  },})\n```\n\n## Include relations and select relation fields[​](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields \"Direct link to Include relations and select relation fields\")\n\nTo return **specific relation fields**, you can:\n\n*   Use a nested `select`\n*   Use a `select` within an `include`\n\n> To return _all_ relation fields, use `include` only - for example, `{ include: { posts: true } }`.\n\nThe following query uses a nested `select` to select each user's `name` and the `title` of each related post:\n\n```\nconst users = await prisma.user.findMany({  select: {    name: true,    posts: {      select: {        title: true,      },    },  },})\n```\n\nThe following query uses `select` within an `include`, and returns _all_ user fields and each post's `title` field:\n\n```\nconst users = await prisma.user.findMany({  // Returns all user fields  include: {    posts: {      select: {        title: true,      },    },  },})\n```\n\nFor more information about querying relations, refer to the following documentation:\n\n*   [Include a relation (including all fields)](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#include-all-fields-for-a-specific-relation)\n*   [Select specific relation fields](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#select-specific-fields-of-included-relations)\n\n## Relation count[​](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#relation-count \"Direct link to Relation count\")\n\nIn [3.0.1](https://github.com/prisma/prisma/releases/3.0.1) and later, you can [`include` or `select` a count of relations](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count-relations) alongside fields - for example, a user's post count.",
  "title": "Select fields (Concepts) | Prisma Documentation",
  "description": "This page explains how to select only a subset of a model's fields and/or include relations (\"eager loading\") in a Prisma Client query.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-typescript-planetscale",
  "markdown": "# Introspection with Prisma ORM, TypeScript, and PlanetScale\n\nSometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake\\_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.\n\nAssume you obtained the following model from introspection that's based on _snake\\_case_ notation:\n\n```\nmodel my_user {  user_id    Int     @id @default(autoincrement())  first_name String?  last_name  String  @unique}\n```\n\nIf you generated a Prisma Client API for this model, it would pick up the _snake\\_case_ notation in its API:\n\n```\nconst user = await prisma.my_user.create({  data: {    first_name: 'Alice',    last_name: 'Smith',  },})\n```\n\nIf you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):\n\n```\nmodel MyUser {  userId    Int     @id @default(autoincrement()) @map(\"user_id\")  firstName String? @map(\"first_name\")  lastName  String  @unique @map(\"last_name\")  @@map(\"my_user\")}\n```\n\nWith this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:\n\n```\nconst user = await prisma.myUser.create({  data: {    firstName: 'Alice',    lastName: 'Smith',  },})\n```\n\nLearn more about this on the [Configuring your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.",
  "title": "Introspection with Prisma ORM, TypeScript, and PlanetScale | Prisma Documentation",
  "description": "Introspect your existing project with Prisma ORM, TypeScript, and PlanetScale",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations",
  "markdown": "# Many-to-many relations | Prisma Documentation\n\nMany-to-many (m-n) relations refer to relations where zero or more records on one side of the relation can be connected to zero or more records on the other side.\n\nPrisma schema syntax and the implementation in the underlying database differs between [relational databases](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relational-databases) and [MongoDB](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#mongodb).\n\n## Relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relational-databases \"Direct link to Relational databases\")\n\nIn relational databases, m-n-relations are typically modelled via [relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables). m-n-relations can be either [explicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations) or [implicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) in the Prisma schema. We recommend using [implicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) m-n-relations if you do not need to store any additional meta-data in the relation table itself. You can always migrate to an [explicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations) m-n-relation later if needed.\n\n### Explicit many-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations \"Direct link to Explicit many-to-many relations\")\n\nIn an explicit m-n relation, the **relation table is represented as a model in the Prisma schema** and can be used in queries. Explicit m-n relations define three models:\n\n*   Two models with m-n relation, such as `Category` and `Post`.\n*   One model that represents the [relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables), such as `CategoriesOnPosts` (also sometimes called _JOIN_, _link_ or _pivot_ table) in the underlying database. The fields of a relation table model are both annotated relation fields (`post` and `category`) with a corresponding relation scalar field (`postId` and `categoryId`).\n\nThe relation table `CategoriesOnPosts` connects related `Post` and `Category` records. In this example, the model representing the relation table also **defines additional fields** that describe the `Post`/`Category` relationship - who assigned the category (`assignedBy`), and when the category was assigned (`assignedAt`):\n\n```\nmodel Post {  id         Int                 @id @default(autoincrement())  title      String  categories CategoriesOnPosts[]}model Category {  id    Int                 @id @default(autoincrement())  name  String  posts CategoriesOnPosts[]}model CategoriesOnPosts {  post       Post     @relation(fields: [postId], references: [id])  postId     Int // relation scalar field (used in the `@relation` attribute above)  category   Category @relation(fields: [categoryId], references: [id])  categoryId Int // relation scalar field (used in the `@relation` attribute above)  assignedAt DateTime @default(now())  assignedBy String  @@id([postId, categoryId])}\n```\n\nThe underlying SQL looks like this:\n\n```\nCREATE TABLE \"Post\" (    \"id\" SERIAL NOT NULL,    \"title\" TEXT NOT NULL,    CONSTRAINT \"Post_pkey\" PRIMARY KEY (\"id\"));CREATE TABLE \"Category\" (    \"id\" SERIAL NOT NULL,    \"name\" TEXT NOT NULL,    CONSTRAINT \"Category_pkey\" PRIMARY KEY (\"id\"));-- Relation table + indexes --CREATE TABLE \"CategoriesOnPosts\" (    \"postId\" INTEGER NOT NULL,    \"categoryId\" INTEGER NOT NULL,    \"assignedAt\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,    CONSTRAINT \"CategoriesOnPosts_pkey\" PRIMARY KEY (\"postId\",\"categoryId\"));ALTER TABLE \"CategoriesOnPosts\" ADD CONSTRAINT \"CategoriesOnPosts_postId_fkey\" FOREIGN KEY (\"postId\") REFERENCES \"Post\"(\"id\") ON DELETE RESTRICT ON UPDATE CASCADE;ALTER TABLE \"CategoriesOnPosts\" ADD CONSTRAINT \"CategoriesOnPosts_categoryId_fkey\" FOREIGN KEY (\"categoryId\") REFERENCES \"Category\"(\"id\") ON DELETE RESTRICT ON UPDATE CASCADE;\n```\n\nNote that the same rules as for [1-n relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations) apply (because `Post`↔ `CategoriesOnPosts` and `Category` ↔ `CategoriesOnPosts` are both in fact 1-n relations), which means one side of the relation needs to be annotated with the `@relation` attribute.\n\nWhen you don't need to attach additional information to the relation, you can model m-n-relations as [implicit m-n-relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations). If you're not using Prisma Migrate but obtain your data model from [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection), you can still make use of implicit m-n-relations by following Prisma ORM's [conventions for relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations).\n\n#### Querying an explicit many-to-many[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#querying-an-explicit-many-to-many \"Direct link to Querying an explicit many-to-many\")\n\nThe following section demonstrates how to query an explicit m-n-relation. You can query the relation model directly (`prisma.categoriesOnPosts(...)`), or use nested queries to go from `Post` -> `CategoriesOnPosts` -> `Category` or the other way.\n\nThe following query does three things:\n\n1.  Creates a `Post`\n2.  Creates a new record in the relation table `CategoriesOnPosts`\n3.  Creates a new `Category` that is associated with the newly created `Post` record\n\n```\nconst createCategory = await prisma.post.create({  data: {    title: 'How to be Bob',    categories: {      create: [        {          assignedBy: 'Bob',          assignedAt: new Date(),          category: {            create: {              name: 'New category',            },          },        },      ],    },  },})\n```\n\nThe following query:\n\n*   Creates a new `Post`\n*   Creates a new record in the relation table `CategoriesOnPosts`\n*   Connects the category assignment to existing categories (with IDs `9` and `22`)\n\n```\nconst assignCategories = await prisma.post.create({  data: {    title: 'How to be Bob',    categories: {      create: [        {          assignedBy: 'Bob',          assignedAt: new Date(),          category: {            connect: {              id: 9,            },          },        },        {          assignedBy: 'Bob',          assignedAt: new Date(),          category: {            connect: {              id: 22,            },          },        },      ],    },  },})\n```\n\nSometimes you might not know if a `Category` record exists. If the `Category` record exists, you want to connect a new `Post` record to that category. If the `Category` record does not exist, you want to create the record first and then connect it to the new `Post` record. The following query:\n\n1.  Creates a new `Post`\n2.  Creates a new record in the relation table `CategoriesOnPosts`\n3.  Connects the category assignment to an existing category (with ID `9`), or creates a new category first if it does not exist\n\n```\nconst assignCategories = await prisma.post.create({  data: {    title: 'How to be Bob',    categories: {      create: [        {          assignedBy: 'Bob',          assignedAt: new Date(),          category: {            connectOrCreate: {              where: {                id: 9,              },              create: {                name: 'New Category',                id: 9,              },            },          },        },      ],    },  },})\n```\n\nThe following query returns all `Post` records where at least one (`some`) category assignment (`categories`) refers to a category named `\"New category\"`:\n\n```\nconst getPosts = await prisma.post.findMany({  where: {    categories: {      some: {        category: {          name: 'New Category',        },      },    },  },})\n```\n\nThe following query returns all categories where at least one (`some`) related `Post` record titles contain the words `\"Cool stuff\"` _and_ the category was assigned by Bob.\n\n```\nconst getAssignments = await prisma.category.findMany({  where: {    posts: {      some: {        assignedBy: 'Bob',        post: {          title: {            contains: 'Cool stuff',          },        },      },    },  },})\n```\n\nThe following query gets all category assignments (`CategoriesOnPosts`) records that were assigned by `\"Bob\"` to one of 5 posts:\n\n```\nconst getAssignments = await prisma.categoriesOnPosts.findMany({  where: {    assignedBy: 'Bob',    post: {      id: {        in: [9, 4, 10, 12, 22],      },    },  },})\n```\n\n### Implicit many-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations \"Direct link to Implicit many-to-many relations\")\n\nImplicit m-n relations define relation fields as lists on both sides of the relation. Although the relation table exists in the underlying database, **it is managed by Prisma ORM and does not manifest in the Prisma schema**. Implicit relation tables follow a [specific convention](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations).\n\nImplicit m-n-relations makes the [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client) for m-n-relations a bit simpler (since you have one fewer level of nesting inside of [nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes)).\n\nIn the example below, there's one _implicit_ m-n-relation between `Post` and `Category`:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  title      String  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String  posts Post[]}\n```\n\n#### Querying an implicit many-to-many[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#querying-an-implicit-many-to-many \"Direct link to Querying an implicit many-to-many\")\n\nThe following section demonstrates how to query an [implicit m-n](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) relation. The queries require less nesting than [explicit m-n queries](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#querying-an-explicit-many-to-many).\n\nThe following query creates a single `Post` and multiple `Category` records:\n\n```\nconst createPostAndCategory = await prisma.post.create({  data: {    title: 'How to become a butterfly',    categories: {      create: [{ name: 'Magic' }, { name: 'Butterflies' }],    },  },})\n```\n\nThe following query creates a single `Category` and multiple `Post` records:\n\n```\nconst createCategoryAndPosts = await prisma.category.create({  data: {    name: 'Stories',    posts: {      create: [        { title: 'That one time with the stuff' },        { title: 'The story of planet Earth' },      ],    },  },})\n```\n\nThe following query returns all `Post` records with a list of that post's assigned categories:\n\n```\nconst getPostsAndCategories = await prisma.post.findMany({  include: {    categories: true,  },})\n```\n\n#### Rules for defining an implicit m-n relation[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#rules-for-defining-an-implicit-m-n-relation \"Direct link to Rules for defining an implicit m-n relation\")\n\nImplicit m-n relations:\n\n*   Use a specific [convention for relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations)\n    \n*   Do **not** require the `@relation` attribute unless you need to [disambiguate relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#disambiguating-relations) with a name, e.g. `@relation(\"MyRelation\")` or `@relation(name: \"MyRelation\")`.\n    \n*   If you do use the `@relation` attribute, you cannot use the `references`, `fields`, `onUpdate` or `onDelete` arguments. This is because these take a fixed value for implicit m-n-relations and cannot be changed.\n    \n*   Require both models to have a single `@id`. Be aware that:\n    \n    *   You cannot use a [multi-field ID](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1)\n    *   You cannot use a `@unique` in place of an `@id`\n\n#### Conventions for relation tables in implicit m-n relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations \"Direct link to Conventions for relation tables in implicit m-n relations\")\n\nIf you obtain your data model from [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection), you can still use implicit m-n-relations by following Prisma ORM's [conventions for relation tables](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations). The following example assumes you want to create a relation table to get an implicit m-n-relation for two models called `Post` and `Category`.\n\n##### Relation table[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-table \"Direct link to Relation table\")\n\nIf you want a relation table to be picked up by introspection as an implicit m-n-relation, the name must follow this exact structure:\n\n*   It must start with an underscore `_`\n*   Then the name of the first model in alphabetical order (in this case `Category`)\n*   Then the relationship (in this case `To`)\n*   Then the name of the second model in alphabetical order (in this case `Post`)\n\nIn the example, the correct table name is `_CategoryToPost`.\n\nWhen creating an implicit m-n-relation yourself in the Prisma schema file, you can [configure the relation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#configuring-the-name-of-the-relation-table-in-implicit-many-to-many-relations) to have a different name. This will change the name given to the relation table in the database. For example, for a relation named `\"MyRelation\"` the corresponding table will be called `_MyRelation`.\n\n###### Multi-schema[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#multi-schema \"Direct link to Multi-schema\")\n\nIf your implicit many-to-many relationship spans multiple database schemas (using the [`multiSchema` preview feature](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema)), the relation table (with the name defined directly above, in the example `_CategoryToPost`) must be present in the same database schema as the first model in alphabetical order (in this case `Category`).\n\n##### Columns[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#columns \"Direct link to Columns\")\n\nA relation table for an implicit m-n-relation must have exactly two columns:\n\n*   A foreign key column that points to `Category` called `A`\n*   A foreign key column that points to `Post` called `B`\n\nThe columns must be called `A` and `B` where `A` points to the model that comes first in the alphabet and `B` points to the model which comes last in the alphabet.\n\n##### Indexes[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#indexes \"Direct link to Indexes\")\n\nThere further must be:\n\n*   A unique index defined on both foreign key columns:\n    \n    ```\n    CREATE UNIQUE INDEX \"_CategoryToPost_AB_unique\" ON \"_CategoryToPost\"(\"A\" int4_ops,\"B\" int4_ops);\n    ```\n    \n*   A non-unique index defined on B:\n    \n    ```\n    CREATE INDEX \"_CategoryToPost_B_index\" ON \"_CategoryToPost\"(\"B\" int4_ops);\n    ```\n    \n\n##### Example[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#example \"Direct link to Example\")\n\nThis is a sample SQL statement that would create the three tables including indexes (in PostgreSQL dialect) that are picked up as a implicit m-n-relation by Prisma Introspection:\n\n```\nCREATE TABLE \"_CategoryToPost\" (    \"A\" integer NOT NULL REFERENCES \"Category\"(id) ,    \"B\" integer NOT NULL REFERENCES \"Post\"(id));CREATE UNIQUE INDEX \"_CategoryToPost_AB_unique\" ON \"_CategoryToPost\"(\"A\" int4_ops,\"B\" int4_ops);CREATE INDEX \"_CategoryToPost_B_index\" ON \"_CategoryToPost\"(\"B\" int4_ops);CREATE TABLE \"Category\" (    id integer SERIAL PRIMARY KEY);CREATE TABLE \"Post\" (    id integer SERIAL PRIMARY KEY);\n```\n\nAnd you can define multiple many-to-many relations between two tables by using the different relationship name. This example shows how the Prisma introspection works under such case:\n\n```\nCREATE TABLE IF NOT EXISTS \"User\" (    \"id\" SERIAL PRIMARY KEY);CREATE TABLE IF NOT EXISTS \"Video\" (    \"id\" SERIAL PRIMARY KEY);CREATE TABLE IF NOT EXISTS \"_UserLikedVideos\" (    \"A\" SERIAL NOT NULL,    \"B\" SERIAL NOT NULL,    CONSTRAINT \"_UserLikedVideos_A_fkey\" FOREIGN KEY (\"A\") REFERENCES \"User\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,    CONSTRAINT \"_UserLikedVideos_B_fkey\" FOREIGN KEY (\"B\") REFERENCES \"Video\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE);CREATE TABLE IF NOT EXISTS \"_UserDislikedVideos\" (    \"A\" SERIAL NOT NULL,    \"B\" SERIAL NOT NULL,    CONSTRAINT \"_UserDislikedVideos_A_fkey\" FOREIGN KEY (\"A\") REFERENCES \"User\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,    CONSTRAINT \"_UserDislikedVideos_B_fkey\" FOREIGN KEY (\"B\") REFERENCES \"Video\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE);CREATE UNIQUE INDEX \"_UserLikedVideos_AB_unique\" ON \"_UserLikedVideos\"(\"A\", \"B\");CREATE INDEX \"_UserLikedVideos_B_index\" ON \"_UserLikedVideos\"(\"B\");CREATE UNIQUE INDEX \"_UserDislikedVideos_AB_unique\" ON \"_UserDislikedVideos\"(\"A\", \"B\");CREATE INDEX \"_UserDislikedVideos_B_index\" ON \"_UserDislikedVideos\"(\"B\");\n```\n\nIf you run `prisma db pull` on this database, the Prisma CLI will generate the following schema through introspection:\n\n```\nmodel User {  id                       Int     @id @default(autoincrement())  Video_UserDislikedVideos Video[] @relation(\"UserDislikedVideos\")  Video_UserLikedVideos    Video[] @relation(\"UserLikedVideos\")}model Video {  id                      Int    @id @default(autoincrement())  User_UserDislikedVideos User[] @relation(\"UserDislikedVideos\")  User_UserLikedVideos    User[] @relation(\"UserLikedVideos\")}\n```\n\n#### Configuring the name of the relation table in implicit many-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#configuring-the-name-of-the-relation-table-in-implicit-many-to-many-relations \"Direct link to Configuring the name of the relation table in implicit many-to-many relations\")\n\nWhen using Prisma Migrate, you can configure the name of the relation table that's managed by Prisma ORM using the `@relation` attribute. For example, if you want the relation table to be called `_MyRelationTable` instead of the default name `_CategoryToPost`, you can specify it as follows:\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  categories Category[] @relation(\"MyRelationTable\")}model Category {  id    Int    @id @default(autoincrement())  posts Post[] @relation(\"MyRelationTable\")}\n```\n\n### Relation tables[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables \"Direct link to Relation tables\")\n\nA relation table (also sometimes called a _JOIN_, _link_ or _pivot_ table) connects two or more other tables and therefore creates a _relation_ between them. Creating relation tables is a common data modelling practice in SQL to represent relationships between different entities. In essence it means that \"one m-n relation is modeled as two 1-n relations in the database\".\n\nWe recommend using [implicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) m-n-relations, where Prisma ORM automatically generates the relation table in the underlying database. [Explicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations) m-n-relations should be used when you need to store additional data in the relations, such as the date the relation was created.\n\n## MongoDB[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#mongodb \"Direct link to MongoDB\")\n\nIn MongoDB, m-n-relations are represented by:\n\n*   relation fields on both sides, that each have a `@relation` attribute, with mandatory `fields` and `references` arguments\n*   a scalar list of referenced IDs on each side, with a type that matches the ID field on the other side\n\nThe following example demonstrates a m-n-relation between posts and categories:\n\n```\nmodel Post {  id          String     @id @default(auto()) @map(\"_id\") @db.ObjectId  categoryIDs String[]   @db.ObjectId  categories  Category[] @relation(fields: [categoryIDs], references: [id])}model Category {  id      String   @id @default(auto()) @map(\"_id\") @db.ObjectId  name    String  postIDs String[] @db.ObjectId  posts   Post[]   @relation(fields: [postIDs], references: [id])}\n```\n\nPrisma ORM validates m-n-relations in MongoDB with the following rules:\n\n*   The fields on both sides of the relation must have a list type (in the example above, `categories` have a type of `Category[]` and `posts` have a type of `Post[]`)\n*   The `@relation` attribute must define `fields` and `references` arguments on both sides\n*   The `fields` argument must have only one scalar field defined, which must be of a list type\n*   The `references` argument must have only one scalar field defined. This scalar field must exist on the referenced model and must be of the same type as the scalar field in the `fields` argument, but singular (no list)\n*   The scalar field to which `references` points must have the `@id` attribute\n*   No [referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) are allowed in `@relation`\n\nThe implicit m-n-relations [used in relational databases](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) are not supported on MongoDB.\n\n### Querying MongoDB many-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#querying-mongodb-many-to-many-relations \"Direct link to Querying MongoDB many-to-many relations\")\n\nThis section demonstrates how to query m-n-relations in MongoDB, using the example schema above.\n\nThe following query finds posts with specific matching category IDs:\n\n```\nconst newId1 = new ObjectId()const newId2 = new ObjectId()const posts = await prisma.post.findMany({  where: {    categoryIDs: {      hasSome: [newId1.toHexString(), newId2.toHexString()],    },  },})\n```\n\nThe following query finds posts where the category name contains the string `'Servers'`:\n\n```\nconst posts = await prisma.post.findMany({  where: {    categories: {      some: {        name: {          contains: 'Servers',        },      },    },  },})\n```",
  "title": "Many-to-many relations | Prisma Documentation",
  "description": "How to define and work with many-to-many relations in Prisma.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting",
  "markdown": "# Filtering and Sorting (Concepts) | Prisma Documentation\n\nPrisma Client supports [filtering](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filtering) with the `where` query option, and [sorting](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sorting) with the `orderBy` query option.\n\n## Filtering[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filtering \"Direct link to Filtering\")\n\nPrisma Client allows you to filter records on any combination of model fields, [including related models](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-on-relations), and supports a variety of [filter conditions](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-conditions-and-operators).\n\nwarning\n\nSome filter conditions use the SQL operators `LIKE` and `ILIKE` which may cause unexpected behavior in your queries. Please refer to [our filtering FAQs](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filtering-faqs) for more information.\n\nThe following query:\n\n*   Returns all `User` records with:\n    *   an email address that ends with `prisma.io` _and_\n    *   at least one published post (a relation query)\n*   Returns all `User` fields\n*   Includes all related `Post` records where `published` equals `true`\n\n```\nconst result = await prisma.user.findMany({  where: {    email: {      endsWith: 'prisma.io',    },    posts: {      some: {        published: true,      },    },  },  include: {    posts: {      where: {        published: true,      },    },  },})\n```\n\n### Filter conditions and operators[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-conditions-and-operators \"Direct link to Filter conditions and operators\")\n\nRefer to Prisma Client's reference documentation for [a full list of operators](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions-and-operators) , such as `startsWith` and `contains`.\n\n#### Combining operators[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#combining-operators \"Direct link to Combining operators\")\n\nYou can use operators (such as [`NOT`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#not-1) and [`OR`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#or) ) to filter by a combination of conditions. The following query returns all users with an `email` that ends in `\"prisma.io\"` or `\"gmail.com\"`, but not `\"hotmail.com\"`:\n\n```\nconst result = await prisma.user.findMany({  where: {    OR: [      {        email: {          endsWith: 'prisma.io',        },      },      { email: { endsWith: 'gmail.com' } },    ],    NOT: {      email: {        endsWith: 'hotmail.com',      },    },  },  select: {    email: true,  },})\n```\n\n### Filter on null fields[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-on-null-fields \"Direct link to Filter on null fields\")\n\nThe following query returns all posts whose `content` field is `null`:\n\n```\nconst posts = await prisma.post.findMany({  where: {    content: null,  },})\n```\n\n### Filter for non-null fields[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-for-non-null-fields \"Direct link to Filter for non-null fields\")\n\nThe following query returns all posts whose `content` field is **not** `null`:\n\n```\nconst posts = await prisma.post.findMany({  where: {    content: { not: null },  },})\n```\n\n### Filter on relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-on-relations \"Direct link to Filter on relations\")\n\nPrisma Client supports [filtering on related records](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-filters). For example, in the following schema, a user can have many blog posts:\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  name  String?  email String  @unique  posts Post[] // User can have many posts}model Post {  id        Int     @id @default(autoincrement())  title     String  published Boolean @default(true)  author    User    @relation(fields: [authorId], references: [id])  authorId  Int}\n```\n\nThe one-to-many relation between `User` and `Post` allows you to query users based on their posts - for example, the following query returns all users where _at least one_ post (`some`) has more than 10 views:\n\n```\nconst result = await prisma.user.findMany({  where: {    posts: {      some: {        views: {          gt: 10,        },      },    },  },})\n```\n\nYou can also query posts based on the properties of the author. For example, the following query returns all posts where the author's `email` contains `\"prisma.io\"`:\n\n```\nconst res = await prisma.post.findMany({  where: {    author: {      email: {        contains: 'prisma.io',      },    },  },})\n```\n\n### Filter on scalar lists / arrays[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-on-scalar-lists--arrays \"Direct link to Filter on scalar lists / arrays\")\n\nScalar lists (for example, `String[]`) have a special set of [filter conditions](https://www.prisma.io/docs/orm/reference/prisma-client-reference#scalar-list-filters) - for example, the following query returns all posts where the `tags` array contains `databases`:\n\n```\nconst posts = await client.post.findMany({  where: {    tags: {      has: 'databases',    },  },})\n```\n\n### Case-insensitive filtering[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#case-insensitive-filtering \"Direct link to Case-insensitive filtering\")\n\nCase-insensitive filtering [is available as a feature for the PostgreSQL and MongoDB providers](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#options-for-case-insensitive-filtering). MySQL, MariaDB and Microsoft SQL Server are case-insensitive by default, and do not require a Prisma Client feature to make case-insensitive filtering possible.\n\nTo use case-insensitive filtering, add the `mode` property to a particular filter and specify `insensitive`:\n\n```\nconst users = await prisma.user.findMany({  where: {    email: {      endsWith: 'prisma.io',      mode: 'insensitive', // Default value: default    },    name: {      equals: 'Archibald', // Default mode    },  },})\n```\n\nSee also: [Case sensitivity](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity)\n\n### Filtering FAQs[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filtering-faqs \"Direct link to Filtering FAQs\")\n\n#### How does filtering work at the database level?[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#how-does-filtering-work-at-the-database-level \"Direct link to How does filtering work at the database level?\")\n\nFor MySQL and PostgreSQL, Prisma Client utilizes the [`LIKE`](https://www.w3schools.com/sql/sql_like.asp) (and [`ILIKE`](https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE)) operator to search for a given pattern. The operators have built-in pattern matching using symbols unique to `LIKE`. The pattern-matching symbols include `%` for zero or more characters (similar to `*` in other regex implementations) and `_` for one character (similar to `.`)\n\nTo match the literal characters, `%` or `_`, make sure you escape those characters. For example:\n\n```\nconst users = await prisma.user.findMany({  where: {    name: {      startsWith: '_benny',    },  },})\n```\n\nThe above query will match any user whose name starts with a character followed by `benny` such as `7benny` or `&benny`. If you instead wanted to find any user whose name starts with the literal string `_benny`, you could do:\n\n```\nconst users = await prisma.user.findMany({  where: {    name: {      startsWith: '\\\\_benny', // note that the `_` character is escaped, preceding `\\` with `\\` when included in a string    },  },})\n```\n\n## Sorting[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sorting \"Direct link to Sorting\")\n\nUse [`orderBy`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#orderby) to sort a list of records or a nested list of records by a particular field or set of fields. For example, the following query returns all `User` records sorted by `role` and `name`, **and** each user's posts sorted by `title`:\n\n```\nconst usersWithPosts = await prisma.user.findMany({  orderBy: [    {      role: 'desc',    },    {      name: 'desc',    },  ],  include: {    posts: {      orderBy: {        title: 'desc',      },      select: {        title: true,      },    },  },})\n```\n\n> **Note**: You can also [sort lists of nested records](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-a-list-of-relations) to retrieve a single record by ID.\n\n### Sort by relation[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-by-relation \"Direct link to Sort by relation\")\n\nYou can also sort by properties of a relation. For example, the following query sorts all posts by the author's email address:\n\n```\nconst posts = await prisma.post.findMany({  orderBy: {    author: {      email: 'asc',    },  },})\n```\n\n### Sort by relation aggregate value[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-by-relation-aggregate-value \"Direct link to Sort by relation aggregate value\")\n\nIn [2.19.0](https://github.com/prisma/prisma/releases/2.19.0) and later, you can sort by the **count of related records**.\n\nFor example, the following query sorts users by the number of related posts:\n\n```\nconst getActiveUsers = await prisma.user.findMany({  take: 10,  orderBy: {    posts: {      _count: 'desc',    },  },})\n```\n\n> **Note**: It is not currently possible to [return the count of a relation](https://github.com/prisma/prisma/issues/5079).\n\n### Sort by relevance (PostgreSQL and MySQL)[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-by-relevance-postgresql-and-mysql \"Direct link to Sort by relevance (PostgreSQL and MySQL)\")\n\nIn [3.5.0+](https://github.com/prisma/prisma/releases/3.5.0) for PostgreSQL and [3.8.0+](https://github.com/prisma/prisma/releases/3.8.0) for MySQL, you can sort records by relevance to the query using the `_relevance` keyword. This uses the relevance ranking functions from full text search features.\n\nThis feature is further explain in [the PostgreSQL documentation](https://www.postgresql.org/docs/12/textsearch-controls.html) and [the MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html).\n\nEnable order by relevance with the `fullTextSearch` [preview feature](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search):\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextSearch\"]}\n```\n\nOrdering by relevance can be used either separately from or together with the `search` filter: `_relevance` is used to order the list, while `search` filters the unordered list. For example, the following query uses `_relevance` to order the list of users by relevance to the search term `'developer'` in their bio, and `search` to filter the list:\n\n```\nconst getUsersByRelevance = await prisma.user.findMany({  take: 10,  orderBy: {    _relevance: {      fields: ['bio'],      search: 'developer',      sort: 'asc',    },  },})\n```\n\n  \n\nnote\n\nPrior to Prisma ORM 5.16.0, enabling the `fullTextSearch` preview feature would rename the `<Model>OrderByWithRelationInput` TypeScript types to `<Model>OrderByWithRelationAndSearchRelevanceInput`. If you are using the Preview feature, you will need to update your type imports.\n\n### Sort with null records first or last[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-with-null-records-first-or-last \"Direct link to Sort with null records first or last\")\n\ninfo\n\nThis feature is generally available in version `4.16.0` and later. To use this feature in versions [`4.1.0`](https://github.com/prisma/prisma/releases/tag/4.1.0) to [`4.15.0`](https://github.com/prisma/prisma/releases/tag/4.15.0) the [Preview feature](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature) `orderByNulls` will need to be enabled.\n\ninfo\n\nNote: Prisma Client does not support this feature for MongoDB.\n\nYou can sort the results so that records with `null` fields appear either first or last.\n\ninfo\n\n**Note:** You can only sort by nulls on optional [scalar](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) fields. If you try to sort by nulls on a required or [relation](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#relation-fields) field, Prisma Client throws a [P2009 error](https://www.prisma.io/docs/orm/reference/error-reference#p2009).\n\nExample: If `updatedAt` is an optional field, then the following query sorts posts by `updatedAt`, with null records at the end:\n\n```\nconst posts = await prisma.post.findMany({  orderBy: {    updatedAt: { sort: 'asc', nulls: 'last' },  },})\n```\n\n### Sorting FAQs[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sorting-faqs \"Direct link to Sorting FAQs\")\n\n#### Can I perform case-insensitive sorting?[​](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#can-i-perform-case-insensitive-sorting \"Direct link to Can I perform case-insensitive sorting?\")\n\nFollow [issue #841 on GitHub](https://github.com/prisma/prisma-client-js/issues/841).",
  "title": "Filtering and Sorting (Concepts) | Prisma Documentation",
  "description": "Use Prisma Client API to filter records by any combination of fields or related record fields, and/or sort query results.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries",
  "markdown": "# Relation queries (Concepts) | Prisma Documentation\n\nA key feature of Prisma Client is the ability to query [relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) between two or more models. Relation queries include:\n\n*   [Nested reads](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads) (sometimes referred to as _eager loading_) via [`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select) and [`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include)\n*   [Nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) with [transactional](https://www.prisma.io/docs/orm/prisma-client/queries/transactions) guarantees\n*   [Filtering on related records](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-filters)\n\nPrisma Client also has a [fluent API for traversing relations](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api).\n\n## Nested reads[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads \"Direct link to Nested reads\")\n\nNested reads allow you to read related data from multiple tables in your database - such as a user and that user's posts. You can:\n\n*   Use [`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include) to include related records, such as a user's posts or profile, in the query response.\n*   Use a nested [`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select) to include specific fields from a related record. You can also nest `select` inside an `include`.\n\n### Relation load strategies (Preview)[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-load-strategies-preview \"Direct link to Relation load strategies (Preview)\")\n\nSince version [5.8.0](https://github.com/prisma/prisma/releases/tag/5.8.0), you can decide on a per-query-level _how_ you want Prisma Client to execute a relation query (i.e. what _load strategy_ should be applied) via the `relationLoadStrategy` option for PostgreSQL databases.\n\nSince version [5.10.0](https://github.com/prisma/prisma/releases/tag/5.10.0), this feature is also available for MySQL.\n\nBecause the `relationLoadStrategy` option is currently in Preview, you need to enable it via the `relationJoins` preview feature flag in your Prisma schema file:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"relationJoins\"]}\n```\n\nAfter adding this flag, you need to run `prisma generate` again to re-generate Prisma Client. This feature is currently available on PostgreSQL, CockroachDB and MySQL.\n\nPrisma Client supports two load strategies for relations:\n\n*   `join` (default): Uses a database-level `LATERAL JOIN` (PostgreSQL) or correlated subqueries (MySQL) and fetches all data with a single query to the database.\n*   `query`: Sends multiple queries to the database (one per table) and joins them on the application level.\n\nAnother important difference between these two options is that the `join` strategy uses JSON aggregation on the database level. That means that it creates the JSON structures returned by Prisma Client already in the database which saves computation resources on the application level.\n\n> **Note**: Once `relationLoadStrategy` moves from [Preview](https://www.prisma.io/docs/orm/more/releases#preview) into [General Availability](https://www.prisma.io/docs/orm/more/releases#generally-available-ga), `join` will universally become the default for all relation queries.\n\n#### Examples[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#examples \"Direct link to Examples\")\n\nYou can use the `relationLoadStrategy` option on the top-level in any query that supports `include` or `select`.\n\nHere is an example with `include`:\n\n```\nconst users = await prisma.user.findMany({  relationLoadStrategy: 'join', // or 'query'  include: {    posts: true,  },})\n```\n\nAnd here is another example with `select`:\n\n```\nconst users = await prisma.user.findMany({  relationLoadStrategy: 'join', // or 'query'  select: {    posts: true,  },})\n```\n\n#### When to use which load strategy?[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#when-to-use-which-load-strategy \"Direct link to When to use which load strategy?\")\n\n*   The `join` strategy (default) will be more effective in most scenarios. On PostgreSQL, it uses a combination of `LATERAL JOINs` and JSON aggregation to reduce redundancy in result sets and delegate the work of transforming the query results into the expected JSON structures on the database server. On MySQL, it uses correlated subqueries to fetch the results with a single query.\n*   There may be edge cases where `query` could be more performant depending on the characteristics of the dataset and query. We recommend that you profile your database queries to identify these situations.\n*   Use `query` if you want to save resources on the database server and do heavy-lifting of merging and transforming data in the application server which might be easier to scale.\n\n### Include a relation[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#include-a-relation \"Direct link to Include a relation\")\n\nThe following example returns a single user and that user's posts:\n\n```\nconst user = await prisma.user.findFirst({  include: {    posts: true,  },})\n```\n\n### Include all fields for a specific relation[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#include-all-fields-for-a-specific-relation \"Direct link to Include all fields for a specific relation\")\n\nThe following example returns a post and its author:\n\n```\nconst post = await prisma.post.findFirst({  include: {    author: true,  },})\n```\n\n### Include deeply nested relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#include-deeply-nested-relations \"Direct link to Include deeply nested relations\")\n\nYou can nest `include` options to include relations of relations. The following example returns a user's posts, and each post's categories:\n\n```\nconst user = await prisma.user.findFirst({  include: {    posts: {      include: {        categories: true,      },    },  },})\n```\n\n### Select specific fields of included relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#select-specific-fields-of-included-relations \"Direct link to Select specific fields of included relations\")\n\nYou can use a nested `select` to choose a subset of fields of relations to return. For example, the following query returns the user's `name` and the `title` of each related post:\n\n```\nconst user = await prisma.user.findFirst({  select: {    name: true,    posts: {      select: {        title: true,      },    },  },})\n```\n\nYou can also nest a `select` inside an `include` - the following example returns _all_ `User` fields and the `title` field of each post:\n\n```\nconst user = await prisma.user.findFirst({  include: {    posts: {      select: {        title: true,      },    },  },})\n```\n\nNote that you **cannot** use `select` and `include` _on the same level_. This means that if you choose to `include` a user's post and `select` each post's title, you cannot `select` only the users' `email`:\n\n```\n// The following query returns an exceptionconst user = await prisma.user.findFirst({  select: { // This won't work!    email:  true  }  include: { // This won't work!    posts: {      select: {        title: true      }    }  },})\n```\n\nInstead, use nested `select` options:\n\n```\nconst user = await prisma.user.findFirst({  select: {    // This will work!    email: true,    posts: {      select: {        title: true,      },    },  },})\n```\n\n## Relation count[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-count \"Direct link to Relation count\")\n\nIn [3.0.1](https://github.com/prisma/prisma/releases/3.0.1) and later, you can [`include` or `select` a count of relations](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count-relations) alongside fields - for example, a user's post count.\n\n```\nconst relationCount = await prisma.user.findMany({  include: {    _count: {      select: { posts: true },    },  },})\n```\n\n## Filter a list of relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-a-list-of-relations \"Direct link to Filter a list of relations\")\n\nWhen you use `select` or `include` to return a subset of the related data, you can **filter and sort the list of relations** inside the `select` or `include`.\n\nFor example, the following query returns all users and a list of titles of the unpublished posts associated with each user:\n\n```\nconst result = await prisma.user.findFirst({  select: {    posts: {      where: {        published: false,      },      orderBy: {        title: 'asc',      },      select: {        title: true,      },    },  },})\n```\n\nYou can also write the same query using `include` as follows:\n\n```\nconst result = await prisma.user.findFirst({  include: {    posts: {      where: {        published: false,      },      orderBy: {        title: 'asc',      },    },  },})\n```\n\n## Nested writes[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes \"Direct link to Nested writes\")\n\nA nested write allows you to write **relational data** to your database in **a single transaction**.\n\nNested writes:\n\n*   Provide **transactional guarantees** for creating, updating or deleting data across multiple tables in a single Prisma Client query. If any part of the query fails (for example, creating a user succeeds but creating posts fails), Prisma Client rolls back all changes.\n*   Support any level of nesting supported by the data model.\n*   Are available for [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) when using the model's create or update query. The following section shows the nested write options that are available per query.\n\nYou can create a record and one or more related records at the same time. The following query creates a `User` record and two related `Post` records:\n\n```\nconst result = await prisma.user.create({  data: {    email: 'elsa@prisma.io',    name: 'Elsa Prisma',    posts: {      create: [        { title: 'How to make an omelette' },        { title: 'How to eat an omelette' },      ],    },  },  include: {    posts: true, // Include all posts in the returned object  },})\n```\n\n### Create a single record and multiple related records[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#create-a-single-record-and-multiple-related-records \"Direct link to Create a single record and multiple related records\")\n\nThere are two ways to create or update a single record and multiple related records - for example, a user with multiple posts:\n\n*   Use a nested [`create`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-1) query\n*   Use a nested [`createMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany-1) query\n\nIn most cases, a nested `create` will be preferable unless the [`skipDuplicates` query option](https://www.prisma.io/docs/orm/reference/prisma-client-reference#nested-createmany-options) is required. Here's a quick table describing the differences between the two options:\n\n| Feature | `create` | `createMany` | Notes |\n| --- | --- | --- | --- |\n| Supports nesting additional relations | ✔   | ✘ \\* | For example, you can create a user, several posts, and several comments per post in one query.  <br>\\* You can manually set a foreign key in a has-one relation - for example: `{ authorId: 9}` |\n| Supports 1-n relations | ✔   | ✔   | For example, you can create a user and multiple posts (one user has many posts) |\n| Supports m-n relations | ✔   | ✘   | For example, you can create a post and several categories (one post can have many categories, and one category can have many posts) |\n| Supports skipping duplicate records | ✘   | ✔   | Use `skipDuplicates` query option. |\n\n#### Using nested `create`[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#using-nested-create \"Direct link to using-nested-create\")\n\nThe following query uses nested [`create`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-1) to create:\n\n*   One user\n*   Two posts\n*   One post category\n\nThe example also uses a nested `include` to include all posts and post categories in the returned data.\n\n```\nconst result = await prisma.user.create({  data: {    email: 'yvette@prisma.io',    name: 'Yvette',    posts: {      create: [        {          title: 'How to make an omelette',          categories: {            create: {              name: 'Easy cooking',            },          },        },        { title: 'How to eat an omelette' },      ],    },  },  include: {    // Include posts    posts: {      include: {        categories: true, // Include post categories      },    },  },})\n```\n\n#### Using nested `createMany`[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#using-nested-createmany \"Direct link to using-nested-createmany\")\n\nThe following query uses a nested [`createMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-1) to create:\n\n*   One user\n*   Two posts\n\nThe example also uses a nested `include` to include all posts in the returned data.\n\n```\nconst result = await prisma.user.create({  data: {    email: 'saanvi@prisma.io',    posts: {      createMany: {        data: [{ title: 'My first post' }, { title: 'My second post' }],      },    },  },  include: {    posts: true,  },})\n```\n\nwarning\n\n**Note**: It is **not possible** to nest an additional `create` or `createMany` inside the highlighted query, which means that you cannot create a user, posts, and post categories at the same time.\n\n### Create multiple records and multiple related records[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#create-multiple-records-and-multiple-related-records \"Direct link to Create multiple records and multiple related records\")\n\nYou cannot access relations in a `createMany()` or `createManyAndReturn()` query, which means that you cannot create multiple users and multiple posts in a single nested write. The following is **not** possible:\n\n```\nconst createMany = await prisma.user.createMany({  data: [    {      name: 'Yewande',      email: 'yewande@prisma.io',      posts: {        // Not possible to create posts!      },    },    {      name: 'Noor',      email: 'noor@prisma.io',      posts: {        // Not possible to create posts!      },    },  ],})\n```\n\n### Connect multiple records[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#connect-multiple-records \"Direct link to Connect multiple records\")\n\nThe following query creates ([`create`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create) ) a new `User` record and connects that record ([`connect`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect) ) to three existing posts:\n\n```\nconst result = await prisma.user.create({  data: {    email: 'vlad@prisma.io',    posts: {      connect: [{ id: 8 }, { id: 9 }, { id: 10 }],    },  },  include: {    posts: true, // Include all posts in the returned object  },})\n```\n\n> **Note**: Prisma Client throws an exception if any of the post records cannot be found: `connect: [{ id: 8 }, { id: 9 }, { id: 10 }]`\n\n### Connect a single record[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#connect-a-single-record \"Direct link to Connect a single record\")\n\nYou can [`connect`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect) an existing record to a new or existing user. The following query connects an existing post (`id: 11`) to an existing user (`id: 9`)\n\n```\nconst result = await prisma.user.update({  where: {    id: 9,  },  data: {    posts: {      connect: {        id: 11,      },    },  },  include: {    posts: true,  },})\n```\n\n### Connect _or_ create a record[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#connect-or-create-a-record \"Direct link to connect-or-create-a-record\")\n\nIf a related record may or may not already exist, use [`connectOrCreate`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connectorcreate) to connect the related record:\n\n*   Connect a `User` with the email address `viola@prisma.io` _or_\n*   Create a new `User` with the email address `viola@prisma.io` if the user does not already exist\n\n```\nconst result = await prisma.post.create({  data: {    title: 'How to make croissants',    author: {      connectOrCreate: {        where: {          email: 'viola@prisma.io',        },        create: {          email: 'viola@prisma.io',          name: 'Viola',        },      },    },  },  include: {    author: true,  },})\n```\n\nTo `disconnect` one out of a list of records (for example, a specific blog post) provide the ID or unique identifier of the record(s) to disconnect:\n\n```\nconst result = await prisma.user.update({  where: {    id: 16,  },  data: {    posts: {      disconnect: [{ id: 12 }, { id: 19 }],    },  },  include: {    posts: true,  },})\n```\n\nTo `disconnect` _one_ record (for example, a post's author), use `disconnect: true`:\n\n```\nconst result = await prisma.post.update({  where: {    id: 23,  },  data: {    author: {      disconnect: true,    },  },  include: {    author: true,  },})\n```\n\nTo [`disconnect`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#disconnect) _all_ related records in a one-to-many relation (a user has many posts), `set` the relation to an empty list as shown:\n\n```\nconst result = await prisma.user.update({  where: {    id: 16,  },  data: {    posts: {      set: [],    },  },  include: {    posts: true,  },})\n```\n\nDelete all related `Post` records:\n\n```\nconst result = await prisma.user.update({  where: {    id: 11,  },  data: {    posts: {      deleteMany: {},    },  },  include: {    posts: true,  },})\n```\n\nUpdate a user by deleting all unpublished posts:\n\n```\nconst result = await prisma.user.update({  where: {    id: 11,  },  data: {    posts: {      deleteMany: {        published: false,      },    },  },  include: {    posts: true,  },})\n```\n\nUpdate a user by deleting specific posts:\n\n```\nconst result = await prisma.user.update({  where: {    id: 6,  },  data: {    posts: {      deleteMany: [{ id: 7 }],    },  },  include: {    posts: true,  },})\n```\n\nYou can use a nested `updateMany` to update _all_ related records for a particular user. The following query unpublishes all posts for a specific user:\n\n```\nconst result = await prisma.user.update({  where: {    id: 6,  },  data: {    posts: {      updateMany: {        where: {          published: true,        },        data: {          published: false,        },      },    },  },  include: {    posts: true,  },})\n```\n\n```\nconst result = await prisma.user.update({  where: {    id: 6,  },  data: {    posts: {      update: {        where: {          id: 9,        },        data: {          title: 'My updated title',        },      },    },  },  include: {    posts: true,  },})\n```\n\nThe following query uses a nested `upsert` to update `\"bob@prisma.io\"` if that user exists, or create the user if they do not exist:\n\n```\nconst result = await prisma.post.update({  where: {    id: 6,  },  data: {    author: {      upsert: {        create: {          email: 'bob@prisma.io',          name: 'Bob the New User',        },        update: {          email: 'bob@prisma.io',          name: 'Bob the existing user',        },      },    },  },  include: {    author: true,  },})\n```\n\nYou can nest `create` or `createMany` inside an `update` to add new related records to an existing record. The following query adds two posts to a user with an `id` of 9:\n\n```\nconst result = await prisma.user.update({  where: {    id: 9,  },  data: {    posts: {      createMany: {        data: [{ title: 'My first post' }, { title: 'My second post' }],      },    },  },  include: {    posts: true,  },})\n```\n\n## Relation filters[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-filters \"Direct link to Relation filters\")\n\n### Filter on \"-to-many\" relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-on--to-many-relations \"Direct link to Filter on \"-to-many\" relations\")\n\nPrisma Client provides the [`some`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#some), [`every`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#every), and [`none`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#none) options to filter records by the properties of related records on the \"-to-many\" side of the relation. For example, filtering users based on properties of their posts.\n\nFor example:\n\n| Requirement | Query option to use |\n| --- | --- |\n| \"I want a list of every `User` that has _at least one_ unpublished `Post` record\" | `some` posts are unpublished |\n| \"I want a list of every `User` that has _no_ unpublished `Post` records\" | `none` of the posts are unpublished |\n| \"I want a list of every `User` that has _only_ unpublished `Post` records\" | `every` post is unpublished |\n\nFor example, the following query returns `User` that meet the following criteria:\n\n*   No posts with more than 100 views\n*   All posts have less than, or equal to 50 likes\n\n```\nconst users = await prisma.user.findMany({  where: {    posts: {      none: {        views: {          gt: 100,        },      },      every: {        likes: {          lte: 50,        },      },    },  },  include: {    posts: true,  },})\n```\n\n### Filter on \"-to-one\" relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-on--to-one-relations \"Direct link to Filter on \"-to-one\" relations\")\n\nPrisma Client provides the [`is`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#is) and [`isNot`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#isnot) options to filter records by the properties of related records on the \"-to-one\" side of the relation. For example, filtering posts based on properties of their author.\n\nFor example, the following query returns `Post` records that meet the following criteria:\n\n*   Author's name is not Bob\n*   Author is older than 40\n\n```\nconst users = await prisma.post.findMany({  where: {    author: {      isNot: {        name: 'Bob',      },      is: {        age: {          gt: 40,        },      },    },  },  include: {    author: true,  },})\n```\n\n### Filter on absence of \"-to-many\" records[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-on-absence-of--to-many-records \"Direct link to Filter on absence of \"-to-many\" records\")\n\nFor example, the following query uses `none` to return all users that have zero posts:\n\n```\nconst usersWithZeroPosts = await prisma.user.findMany({  where: {    posts: {      none: {},    },  },  include: {    posts: true,  },})\n```\n\n### Filter on absence of \"-to-one\" relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filter-on-absence-of--to-one-relations \"Direct link to Filter on absence of \"-to-one\" relations\")\n\nThe following query returns all posts that don't have an author relation:\n\n```\nconst postsWithNoAuthor = await prisma.post.findMany({  where: {    author: null, // or author: { }  },  include: {    author: true,  },})\n```\n\nThe following query returns all users with at least one post:\n\n```\nconst usersWithSomePosts = await prisma.user.findMany({  where: {    posts: {      some: {},    },  },  include: {    posts: true,  },})\n```\n\n## Fluent API[​](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api \"Direct link to Fluent API\")\n\nThe fluent API lets you _fluently_ traverse the [relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) of your models via function calls. Note that the _last_ function call determines the return type of the entire query (the respective type annotations are added in the code snippets below to make that explicit).\n\nThis query returns all `Post` records by a specific `User`:\n\n```\nconst postsByUser: Post[] = await prisma.user  .findUnique({ where: { email: 'alice@prisma.io' } })  .posts()\n```\n\nThis is equivalent to the following `findMany` query:\n\n```\nconst postsByUser = await prisma.post.findMany({  where: {    author: {      email: 'alice@prisma.io',    },  },})\n```\n\nThe main difference between the queries is that the fluent API call is translated into two separate database queries while the other one only generates a single query (see this [GitHub issue](https://github.com/prisma/prisma/issues/1984))\n\n> **Note**: You can use the fact that `.findUnique({ where: { email: 'alice@prisma.io' } }).posts()` queries are automatically batched by the Prisma dataloader in Prisma Client to [avoid the n+1 problem in GraphQL resolvers](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-n1-in-graphql-with-findunique-and-prisma-clients-dataloader).\n\nThis request returns all categories by a specific post:\n\n```\nconst categoriesOfPost: Category[] = await prisma.post  .findUnique({ where: { id: 1 } })  .categories()\n```\n\nNote that you can chain as many queries as you like. In this example, the chaining starts at `Profile` and goes over `User` to `Post`:\n\n```\nconst posts: Post[] = await prisma.profile  .findUnique({ where: { id: 1 } })  .user()  .posts()\n```\n\nThe only requirement for chaining is that the previous function call must return only a _single object_ (e.g. as returned by a `findUnique` query or a \"to-one relation\" like `profile.user()`).\n\nThe following query is **not possible** because `findMany` does not return a single object but a _list_:\n\n```\n// This query is illegalconst posts = await prisma.user.findMany().posts()\n```",
  "title": "Relation queries (Concepts) | Prisma Documentation",
  "description": "Prisma Client provides convenient queries for working with relations, such as a fluent API, nested writes (transactions), nested reads and relation filters.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/pagination",
  "markdown": "# Pagination (Reference) | Prisma Documentation\n\nPrisma Client supports both offset pagination and cursor-based pagination.\n\nOffset pagination uses `skip` and `take` to skip a certain number of results and select a limited range. The following query skips the first 3 `Post` records and returns records 4 - 7:\n\n```\nconst results = await prisma.post.findMany({  skip: 3,  take: 4,})\n```\n\n![](https://www.prisma.io/docs/assets/images/offset-skip-take-761acfc939aa498db1a8a48a1b7c1a38.png)\n\nTo implement pages of results, you would just `skip` the number of pages multiplied by the number of results you show per page.\n\n*   You can jump to any page immediately. For example, you can `skip` 200 records and `take` 10, which simulates jumping straight to page 21 of the result set (the underlying SQL uses `OFFSET`). This is not possible with cursor-based pagination.\n*   You can paginate the same result set in any sort order. For example, you can jump to page 21 of a list of `User` records sorted by first name. This is not possible with cursor-based pagination, which requires sorting by a unique, sequential column.\n\n*   Offset pagination **does not scale** at a database level. For example, if you skip 200,000 records and take the first 10, the database still has to traverse the first 200,000 records before returning the 10 that you asked for - this negatively affects performance.\n\n*   Shallow pagination of a small result set. For example, a blog interface that allows you to filter `Post` records by author and paginate the results.\n\n### Example: Filtering and offset pagination[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#example-filtering-and-offset-pagination \"Direct link to Example: Filtering and offset pagination\")\n\nThe following query returns all records where the `email` field contains `prisma.io`. The query skips the first 40 records and returns records 41 - 50.\n\n```\nconst results = await prisma.post.findMany({  skip: 40,  take: 10,  where: {    email: {      contains: 'prisma.io',    },  },})\n```\n\n### Example: Sorting and offset pagination[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#example-sorting-and-offset-pagination \"Direct link to Example: Sorting and offset pagination\")\n\nThe following query returns all records where the `email` field contains `Prisma`, and sorts the result by the `title` field. The query skips the first 200 records and returns records 201 - 220.\n\n```\nconst results = await prisma.post.findMany({  skip: 200,  take: 20,  where: {    email: {      contains: 'Prisma',    },  },  orderBy: {    title: 'desc',  },})\n```\n\nCursor-based pagination uses `cursor` and `take` to return a limited set of results before or after a given **cursor**. A cursor bookmarks your location in a result set and must be a unique, sequential column - such as an ID or a timestamp.\n\nThe following example returns the first 4 `Post` records that contain the word `\"Prisma\"` and saves the ID of the last record as `myCursor`:\n\n> **Note**: Since this is the first query, there is no cursor to pass in.\n\n```\nconst firstQueryResults = await prisma.post.findMany({  take: 4,  where: {    title: {      contains: 'Prisma' /* Optional filter */,    },  },  orderBy: {    id: 'asc',  },})// Bookmark your location in the result set - in this// case, the ID of the last post in the list of 4.const lastPostInResults = firstQueryResults[3] // Remember: zero-based index! :)const myCursor = lastPostInResults.id // Example: 29\n```\n\nThe following diagram shows the IDs of the first 4 results - or page 1. The cursor for the next query is **29**:\n\n![](https://www.prisma.io/docs/assets/images/cursor-1-77db774b6e7cd70f97903db7aaf5c2af.png)\n\nThe second query returns the first 4 `Post` records that contain the word `\"Prisma\"` **after the supplied cursor** (in other words - IDs that are larger than **29**):\n\n```\nconst secondQueryResults = await prisma.post.findMany({  take: 4,  skip: 1, // Skip the cursor  cursor: {    id: myCursor,  },  where: {    title: {      contains: 'Prisma' /* Optional filter */,    },  },  orderBy: {    id: 'asc',  },})const lastPostInResults = secondQueryResults[3] // Remember: zero-based index! :)const myCursor = lastPostInResults.id // Example: 52\n```\n\nThe following diagram shows the first 4 `Post` records **after** the record with ID **29**. In this example, the new cursor is **52**:\n\n![](https://www.prisma.io/docs/assets/images/cursor-2-d6143e7931d422bb653ca96523d8a542.png)\n\n### FAQ[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#faq \"Direct link to FAQ\")\n\n#### Do I always have to skip: 1?[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#do-i-always-have-to-skip-1 \"Direct link to Do I always have to skip: 1?\")\n\nIf you do not `skip: 1`, your result set will include your previous cursor. The first query returns four results and the cursor is **29**:\n\n![](https://www.prisma.io/docs/assets/images/cursor-1-77db774b6e7cd70f97903db7aaf5c2af.png)\n\nWithout `skip: 1`, the second query returns 4 results after (and _including_) the cursor:\n\n![](https://www.prisma.io/docs/assets/images/cursor-3-afdca78b2f1c2407a2b82df6e8b0aebf.png)\n\nIf you `skip: 1`, the cursor is not included:\n\n![](https://www.prisma.io/docs/assets/images/cursor-2-d6143e7931d422bb653ca96523d8a542.png)\n\nYou can choose to `skip: 1` or not depending on the pagination behavior that you want.\n\n#### Can I guess the value of the cursor?[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#can-i-guess-the-value-of-the-cursor \"Direct link to Can I guess the value of the cursor?\")\n\nIf you guess the value of the next cursor, you will page to an unknown location in your result set. Although IDs are sequential, you cannot predict the rate of increment (`2`, `20`, `32` is more likely than `1`, `2`, `3`, particularly in a filtered result set).\n\nNo, cursor pagination does not use cursors in the underlying database ([e.g. PostgreSQL](https://www.postgresql.org/docs/9.2/plpgsql-cursors.html)).\n\n#### What happens if the cursor value does not exist?[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#what-happens-if-the-cursor-value-does-not-exist \"Direct link to What happens if the cursor value does not exist?\")\n\nUsing a nonexistent cursor returns `null`. Prisma Client does not try to locate adjacent values.\n\n*   Cursor-based pagination **scales**. The underlying SQL does not use `OFFSET`, but instead queries all `Post` records with an ID greater than the value of `cursor`.\n\n*   You must sort by your cursor, which has to be a unique, sequential column.\n*   You cannot jump to a specific page using only a cursor. For example, you cannot accurately predict which cursor represents the start of page 400 (page size 20) without first requesting pages 1 - 399.\n\n*   Infinite scroll - for example, sort blog posts by date/time descending and request 10 blog posts at a time.\n*   Paging through an entire result set in batches - for example, as part of a long-running data export.\n\n### Example: Filtering and cursor-based pagination[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#example-filtering-and-cursor-based-pagination \"Direct link to Example: Filtering and cursor-based pagination\")\n\n```\nconst secondQuery = await prisma.post.findMany({  take: 4,  cursor: {    id: myCursor,  },  where: {    title: {      contains: 'Prisma' /* Optional filter */,    },  },  orderBy: {    id: 'asc',  },})\n```\n\n### Sorting and cursor-based pagination[​](https://www.prisma.io/docs/orm/prisma-client/queries/pagination#sorting-and-cursor-based-pagination \"Direct link to Sorting and cursor-based pagination\")\n\nCursor-based pagination requires you to sort by a sequential, unique column such as an ID or a timestamp. This value - known as a cursor - bookmarks your place in the result set and allows you to request the next set.\n\nTo page backwards, set `take` to a negative value. The following query returns 4 `Post` records with an `id` of less than 200, excluding the cursor:\n\n```\nconst myOldCursor = 200const firstQueryResults = await prisma.post.findMany({  take: -4,  skip: 1,  cursor: {    id: myOldCursor,  },  where: {    title: {      contains: 'Prisma' /* Optional filter */,    },  },  orderBy: {    id: 'asc',  },})\n```",
  "title": "Pagination (Reference) | Prisma Documentation",
  "description": "Prisma Client supports both offset pagination and cursor-based pagination. Learn more about the pros and cons of different pagination approaches and how to implement them.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing",
  "markdown": "# Aggregation, grouping, and summarizing (Concepts)\n\nPrisma Client allows you to count records, aggregate number fields, and select distinct field values.\n\n## Aggregate[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#aggregate \"Direct link to Aggregate\")\n\nPrisma Client allows you to [`aggregate`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#aggregate) on the **number** fields (such as `Int` and `Float`) of a model. The following query returns the average age of all users:\n\n```\nconst aggregations = await prisma.user.aggregate({  _avg: {    age: true,  },})console.log('Average age:' + aggregations._avg.age)\n```\n\nYou can combine aggregation with filtering and ordering. For example, the following query returns the average age of users:\n\n*   Ordered by `age` ascending\n*   Where `email` contains `prisma.io`\n*   Limited to the 10 users\n\n```\nconst aggregations = await prisma.user.aggregate({  _avg: {    age: true,  },  where: {    email: {      contains: 'prisma.io',    },  },  orderBy: {    age: 'asc',  },  take: 10,})console.log('Average age:' + aggregations._avg.age)\n```\n\n### Aggregate values are nullable[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#aggregate-values-are-nullable \"Direct link to Aggregate values are nullable\")\n\nIn [2.21.0](https://github.com/prisma/prisma/releases/tag/2.21.0) and later, aggregations on **nullable fields** can return a `number` or `null`. This excludes `count`, which always returns 0 if no records are found.\n\nConsider the following query, where `age` is nullable in the schema:\n\n```\nconst aggregations = await prisma.user.aggregate({  _avg: {    age: true,  },  _count: {    age: true,  },})\n```\n\nThe query returns `{ _avg: { age: null } }` in either of the following scenarios:\n\n*   There are no users\n*   The value of every user's `age` field is `null`\n\nThis allows you to differentiate between the true aggregate value (which could be zero) and no data.\n\n## Group by[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#group-by \"Direct link to Group by\")\n\nPrisma Client's [`groupBy()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#groupby) allows you to **group records** by one or more field values - such as `country`, or `country` and `city` and **perform aggregations** on each group, such as finding the average age of people living in a particular city. `groupBy()` is a GA in [2.20.0](https://github.com/prisma/prisma/releases/2.20.0) and later.\n\nThe following video uses `groupBy()` to summarize total COVID-19 cases by continent:\n\nThe following example groups all users by the `country` field and returns the total number of profile views for each country:\n\n```\nconst groupUsers = await prisma.user.groupBy({  by: ['country'],  _sum: {    profileViews: true,  },})\n```\n\nIf you have a single element in the `by` option, you can use the following shorthand syntax to express your query:\n\n```\nconst groupUsers = await prisma.user.groupBy({  by: 'country',})\n```\n\n### `groupBy()` and filtering[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#groupby-and-filtering \"Direct link to groupby-and-filtering\")\n\n`groupBy()` supports two levels of filtering: `where` and `having`.\n\n#### Filter records with `where`[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#filter-records-with-where \"Direct link to filter-records-with-where\")\n\nUse `where` to filter all records **before grouping**. The following example groups users by country and sums profile views, but only includes users where the email address contains `prisma.io`:\n\n```\nconst groupUsers = await prisma.user.groupBy({  by: ['country'],  where: {    email: {      contains: 'prisma.io',    },  },  _sum: {    profileViews: true,  },})\n```\n\n#### Filter groups with `having`[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#filter-groups-with-having \"Direct link to filter-groups-with-having\")\n\nUse `having` to filter **entire groups** by an aggregate value such as the sum or average of a field, not individual records - for example, only return groups where the _average_ `profileViews` is greater than 100:\n\n```\nconst groupUsers = await prisma.user.groupBy({  by: ['country'],  where: {    email: {      contains: 'prisma.io',    },  },  _sum: {    profileViews: true,  },  having: {    profileViews: {      _avg: {        gt: 100,      },    },  },})\n```\n\n##### Use case for `having`[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#use-case-for-having \"Direct link to use-case-for-having\")\n\nThe primary use case for `having` is to filter on aggregations. We recommend that you use `where` to reduce the size of your data set as far as possible _before_ grouping, because doing so ✔ reduces the number of records the database has to return and ✔ makes use of indices.\n\nFor example, the following query groups all users that are _not_ from Sweden or Ghana:\n\n```\nconst fd = await prisma.user.groupBy({  by: ['country'],  where: {    country: {      notIn: ['Sweden', 'Ghana'],    },  },  _sum: {    profileViews: true,  },  having: {    profileViews: {      _min: {        gte: 10,      },    },  },})\n```\n\nThe following query technically achieves the same result, but excludes users from Ghana _after_ grouping. This does not confer any benefit and is not recommended practice.\n\n```\nconst groupUsers = await prisma.user.groupBy({  by: ['country'],  where: {    country: {      not: 'Sweden',    },  },  _sum: {    profileViews: true,  },  having: {    country: {      not: 'Ghana',    },    profileViews: {      _min: {        gte: 10,      },    },  },})\n```\n\n> **Note**: Within `having`, you can only filter on aggregate values _or_ fields available in `by`.\n\n### `groupBy()` and ordering[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#groupby-and-ordering \"Direct link to groupby-and-ordering\")\n\nThe following constraints apply when you combine `groupBy()` and `orderBy`:\n\n*   You can `orderBy` fields that are present in `by`\n*   You can `orderBy` aggregate (Preview in 2.21.0 and later)\n*   If you use `skip` and/or `take` with `groupBy()`, you must also include `orderBy` in the query\n\n#### Order by aggregate group[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#order-by-aggregate-group \"Direct link to Order by aggregate group\")\n\nYou can **order by aggregate group**. Prisma ORM added support for using `orderBy` with aggregated groups in relational databases in version [2.21.0](https://github.com/prisma/prisma/releases/2.21.0) and support for MongoDB in [3.4.0](https://github.com/prisma/prisma/releases/3.4.0).\n\nThe following example sorts each `city` group by the number of users in that group (largest group first):\n\n```\nconst groupBy = await prisma.user.groupBy({  by: ['city'],  _count: {    city: true,  },  orderBy: {    _count: {      city: 'desc',    },  },})\n```\n\n#### Order by field[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#order-by-field \"Direct link to Order by field\")\n\nThe following query orders groups by country, skips the first two groups, and returns the 3rd and 4th group:\n\n```\nconst groupBy = await prisma.user.groupBy({  by: ['country'],  _sum: {    profileViews: true,  },  orderBy: {    country: 'desc',  },  skip: 2,  take: 2,})\n```\n\n### `groupBy()` FAQ[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#groupby-faq \"Direct link to groupby-faq\")\n\n#### Can I use `select` with `groupBy()`?[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#can-i-use-select-with-groupby \"Direct link to can-i-use-select-with-groupby\")\n\nYou cannot use `select` with `groupBy()`. However, all fields included in `by` are automatically returned.\n\n#### What is the difference between using `where` and `having` with `groupBy()`?[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#what-is-the-difference-between-using-where-and-having-with-groupby \"Direct link to what-is-the-difference-between-using-where-and-having-with-groupby\")\n\n`where` filters all records before grouping, and `having` filters entire groups and supports filtering on an aggregate field value, such as the average or sum of a particular field in that group.\n\n#### What is the difference between `groupBy()` and `distinct`?[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#what-is-the-difference-between-groupby-and-distinct \"Direct link to what-is-the-difference-between-groupby-and-distinct\")\n\nBoth `distinct` and `groupBy()` group records by one or more unique field values. `groupBy()` allows you to aggregate data within each group - for example, return the average number of views on posts from Denmark - whereas distinct does not.\n\n## Count[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count \"Direct link to Count\")\n\n### Count records[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count-records \"Direct link to Count records\")\n\nUse [`count()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#count) to count the number of records or non-`null` field values. The following example query counts all users:\n\n```\nconst userCount = await prisma.user.count()\n```\n\n### Count relations[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count-relations \"Direct link to Count relations\")\n\ninfo\n\nThis feature is generally available in version [3.0.1](https://github.com/prisma/prisma/releases/3.0.1) and later. To use this feature in versions before 3.0.1 the [Preview feature](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature) `selectRelationCount` will need to be enabled.\n\nTo return a count of relations (for example, a user's post count), use the `_count` parameter with a nested `select` as shown:\n\n```\nconst usersWithCount = await prisma.user.findMany({  include: {    _count: {      select: { posts: true },    },  },})\n```\n\nThe `_count` parameter:\n\n*   Can be used inside a top-level `include` _or_ `select`\n*   Can be used with any query that returns records (including `delete`, `update`, and `findFirst`)\n*   Can return [multiple relation counts](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#return-multiple-relation-counts)\n*   Can [filter relation counts](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#filter-the-relation-count) (from version 4.3.0)\n\n#### Return a relations count with `include`[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#return-a-relations-count-with-include \"Direct link to return-a-relations-count-with-include\")\n\nThe following query includes each user's post count in the results:\n\n```\nconst usersWithCount = await prisma.user.findMany({  include: {    _count: {      select: { posts: true },    },  },})\n```\n\n#### Return a relations count with `select`[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#return-a-relations-count-with-select \"Direct link to return-a-relations-count-with-select\")\n\nThe following query uses `select` to return each user's post count _and no other fields_:\n\n```\nconst usersWithCount = await prisma.user.findMany({  select: {    _count: {      select: { posts: true },    },  },})\n```\n\n#### Return multiple relation counts[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#return-multiple-relation-counts \"Direct link to Return multiple relation counts\")\n\nThe following query returns a count of each user's `posts` and `recipes` and no other fields:\n\n```\nconst usersWithCount = await prisma.user.findMany({  select: {    _count: {      select: {        posts: true,        recipes: true,      },    },  },})\n```\n\n#### Filter the relation count[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#filter-the-relation-count \"Direct link to Filter the relation count\")\n\ninfo\n\nThis feature is generally available in version `4.16.0` and later. To use this feature in versions [`4.3.0`](https://github.com/prisma/prisma/releases/tag/4.3.0) to [`4.15.0`](https://github.com/prisma/prisma/releases/tag/4.15.0) the [Preview feature](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature) `filteredRelationCount` will need to be enabled.\n\nUse `where` to filter the fields returned by the `_count` output type. You can do this on [scalar fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields), [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#relation-fields) and fields of a [composite type](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types).\n\nFor example, the following query returns all user posts with the title \"Hello!\":\n\n```\n// Count all user posts with the title \"Hello!\"await prisma.user.findMany({  select: {    _count: {      select: {        posts: { where: { title: 'Hello!' } },      },    },  },})\n```\n\nThe following query finds all user posts with comments from an author named \"Alice\":\n\n```\n// Count all user posts that have comments// whose author is named \"Alice\"await prisma.user.findMany({  select: {    _count: {      select: {        posts: {          where: { comments: { some: { author: { is: { name: 'Alice' } } } } },        },      },    },  },})\n```\n\n### Count non-`null` field values[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count-non-null-field-values \"Direct link to count-non-null-field-values\")\n\nIn [2.15.0](https://github.com/prisma/prisma/releases/2.15.0) and later, you can count all records as well as all instances of non-`null` field values. The following query returns a count of:\n\n*   All `User` records (`_all`)\n*   All non-`null` `name` values (not distinct values, just values that are not `null`)\n\n```\nconst userCount = await prisma.user.count({  select: {    _all: true, // Count all records    name: true, // Count all non-null field values  },})\n```\n\n### Filtered count[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#filtered-count \"Direct link to Filtered count\")\n\n`count` supports filtering. The following example query counts all users with more than 100 profile views:\n\n```\nconst userCount = await prisma.user.count({  where: {    profileViews: {      gte: 100,    },  },})\n```\n\nThe following example query counts a particular user's posts:\n\n```\nconst postCount = await prisma.post.count({  where: {    authorId: 29,  },})\n```\n\n## Select distinct[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#select-distinct \"Direct link to Select distinct\")\n\nPrisma Client allows you to filter duplicate rows from a Prisma Query response to a [`findMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findmany) query using [`distinct`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#distinct) . `distinct` is often used in combination with [`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select) to identify certain unique combinations of values in the rows of your table.\n\nThe following example returns all fields for all `User` records with distinct `name` field values:\n\n```\nconst result = await prisma.user.findMany({  where: {},  distinct: ['name'],})\n```\n\nThe following example returns distinct `role` field values (for example, `ADMIN` and `USER`):\n\n```\nconst distinctRoles = await prisma.user.findMany({  distinct: ['role'],  select: {    role: true,  },})\n```\n\n### `distinct` under the hood[​](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#distinct-under-the-hood \"Direct link to distinct-under-the-hood\")\n\nPrisma Client's `distinct` option does not use SQL `SELECT DISTINCT`. Instead, `distinct` uses:\n\n*   A `SELECT` query\n*   In-memory post-processing to select distinct\n\nIt was designed in this way in order to **support `select` and `include`** as part of `distinct` queries.\n\nThe following example selects distinct on `gameId` and `playerId`, ordered by `score`, in order to return **each player's highest score per game**. The query uses `include` and `select` to include additional data:\n\n*   Select `score` (field on `Play`)\n*   Select related player name (relation between `Play` and `User`)\n*   Select related game name (relation between `Play` and `Game`)\n\nExpand for sample schema\n\n```\nmodel User {  id   Int     @id @default(autoincrement())  name String?  play Play[]}model Game {  id   Int     @id @default(autoincrement())  name String?  play Play[]}model Play {  id       Int   @id @default(autoincrement())  score    Int?  @default(0)  playerId Int?  player   User? @relation(fields: [playerId], references: [id])  gameId   Int?  game     Game? @relation(fields: [gameId], references: [id])}\n```\n\n```\nconst distinctScores = await prisma.play.findMany({  distinct: ['playerId', 'gameId'],  orderBy: {    score: 'desc',  },  select: {    score: true,    game: {      select: {        name: true,      },    },    player: {      select: {        name: true,      },    },  },})\n```\n\nWithout `select` and `distinct`, the query would return:\n\n```\n[  {    gameId: 2,    playerId: 5  },  {    gameId: 2,    playerId: 10  }]\n```",
  "title": "Aggregation, grouping, and summarizing (Concepts) | Prisma Documentation",
  "description": "Use Prisma Client to aggregate, group by, count, and select distinct.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/computed-fields",
  "markdown": "# Computed fields | Prisma Documentation\n\nwarning\n\nWith Prisma Client extensions Generally Available as of Prisma ORM version 4.16.0, the following steps are not recommended. Please use [a client extension](https://www.prisma.io/docs/orm/prisma-client/queries/computed-fields#using-a-prisma-client-extension) to accomplish this.\n\nPrisma Client does not yet natively support computed fields, but, you can define a function that accepts a generic type as an input then extend that generic to ensure it conforms to a specific structure. Finally, you can return that generic with additional computed fields. Let's see how that might look:\n\n*   TypeScript\n*   JavaScript\n\n```\n// Define a type that needs a first and last nametype FirstLastName = {  firstName: string  lastName: string}// Extend the T generic with the fullName attributetype WithFullName<T> = T & {  fullName: string}// Take objects that satisfy FirstLastName and computes a full namefunction computeFullName<User extends FirstLastName>(  user: User): WithFullName<User> {  return {    ...user,    fullName: user.firstName + ' ' + user.lastName,  }}async function main() {  const user = await prisma.user.findUnique({ where: 1 })  const userWithFullName = computeFullName(user)}\n```\n\nIn the TypeScript example above, a `User` generic has been defined that extends the `FirstLastName` type. This means that whatever you pass into `computeFullName` must contain `firstName` and `lastName` keys.\n\nA `WithFullName<User>` return type has also been defined, which takes whatever `User` is and tacks on a `fullName` string attribute.\n\nWith this function, any object that contains `firstName` and `lastName` keys can compute a `fullName`. Pretty neat, right?",
  "title": "Computed fields | Prisma Documentation",
  "description": "This page explains how to use client extensions to add computed fields to Prisma models.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search",
  "markdown": "# Full-text search (Preview) | Prisma Documentation\n\nPrisma Client supports full-text search for **PostgreSQL** databases in versions 2.30.0 and later, and **MySQL** databases in versions 3.8.0 and later. With full-text search enabled, you can add search functionality to your application by searching for text within a database column.\n\n> **Note**: There currently is a [known issue](https://github.com/prisma/prisma/issues/23627) in the full-text search feature. If you observe slow search queries, you can [optimize your query with raw SQL](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#full-text-search-with-raw-sql).\n\n## Enabling full-text search[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#enabling-full-text-search \"Direct link to Enabling full-text search\")\n\nThe full-text search API is currently a Preview feature. To enable this feature, carry out the following steps:\n\n1.  Update the [`previewFeatures`](https://www.prisma.io/docs/orm/reference/preview-features) block in your schema to include the `fullTextSearch` preview feature flag:\n    \n    schema.prisma\n    \n    ```\n    generator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextSearch\"]}\n    ```\n    \n    For MySQL, you will also need to include the `fullTextIndex` preview feature flag:\n    \n    schema.prisma\n    \n    ```\n    generator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextSearch\", \"fullTextIndex\"]}\n    ```\n    \n2.  Generate Prisma Client:\n    \n\nAfter you regenerate your client, a new `search` field will be available on any `String` fields created on your models. For example, the following search will return all posts that contain the word 'cat'.\n\n```\n// All posts that contain the word 'cat'.const result = await prisma.posts.findMany({  where: {    body: {      search: 'cat',    },  },})\n```\n\n## Querying the database[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#querying-the-database \"Direct link to Querying the database\")\n\nThe `search` field uses the database's native querying capabilities under the hood. This means that the exact query operators available are also database-specific.\n\n### PostgreSQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#postgresql \"Direct link to PostgreSQL\")\n\nThe following examples demonstrate the use of the PostgreSQL 'and' (`&`) and 'or' (`|`) operators:\n\n```\n// All posts that contain the words 'cat' or 'dog'.const result = await prisma.posts.findMany({  where: {    body: {      search: 'cat | dog',    },  },})// All drafts that contain the words 'cat' and 'dog'.const result = await prisma.posts.findMany({  where: {    status: 'Draft',    body: {      search: 'cat & dog',    },  },})\n```\n\nTo get a sense of how the query format works, consider the following text:\n\n**\"The quick brown fox jumps over the lazy dog\"**\n\nHere's how the following queries would match that text:\n\n| Query | Match? | Description |\n| --- | --- | --- |\n| `fox & dog` | Yes | The text contains 'fox' and 'dog' |\n| `dog & fox` | Yes | The text contains 'dog' and 'fox' |\n| `dog & cat` | No  | The text contains 'dog' but not 'cat' |\n| `!cat` | Yes | 'cat' is not in the text |\n| `fox &#124; cat` | Yes | The text contains 'fox' or 'cat' |\n| `cat &#124; pig` | No  | The text doesn't contain 'cat' or 'pig' |\n| `fox <-> dog` | Yes | 'dog' follows 'fox' in the text |\n| `dog <-> fox` | No  | 'fox' doesn't follow 'dog' in the text |\n\nFor the full range of supported operations, see the [PostgreSQL full text search documentation](https://www.postgresql.org/docs/12/functions-textsearch.html).\n\n### MySQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#mysql \"Direct link to MySQL\")\n\nThe following examples demonstrate use of the MySQL 'and' (`+`) and 'not' (`-`) operators:\n\n```\n// All posts that contain the words 'cat' or 'dog'.const result = await prisma.posts.findMany({  where: {    body: {      search: 'cat dog',    },  },})// All posts that contain the words 'cat' and not 'dog'.const result = await prisma.posts.findMany({  where: {    body: {      search: '+cat -dog',    },  },})// All drafts that contain the words 'cat' and 'dog'.const result = await prisma.posts.findMany({  where: {    status: 'Draft',    body: {      search: '+cat +dog',    },  },})\n```\n\nTo get a sense of how the query format works, consider the following text:\n\n**\"The quick brown fox jumps over the lazy dog\"**\n\nHere's how the following queries would match that text:\n\n| Query | Match? | Description |\n| --- | --- | --- |\n| `+fox +dog` | Yes | The text contains 'fox' and 'dog' |\n| `+dog +fox` | Yes | The text contains 'dog' and 'fox' |\n| `+dog -cat` | Yes | The text contains 'dog' but not 'cat' |\n| `-cat` | No  | The minus operator cannot be used on its own (see note below) |\n| `fox dog` | Yes | The text contains 'fox' or 'dog' |\n| `quic*` | Yes | The text contains a word starting with 'quic' |\n| `quick fox @2` | Yes | 'fox' starts within a 2 word distance of 'quick' |\n| `fox dog @2` | No  | 'dog' does not start within a 2 word distance of 'fox' |\n| `\"jumps over\"` | Yes | The text contains the whole phrase 'jumps over' |\n\n> **Note**: The - operator acts only to exclude rows that are otherwise matched by other search terms. Thus, a boolean-mode search that contains only terms preceded by - returns an empty result. It does not return “all rows except those containing any of the excluded terms.”\n\nMySQL also has `>`, `<` and `~` operators for altering the ranking order of search results. As an example, consider the following two records:\n\n**1\\. \"The quick brown fox jumps over the lazy dog\"**\n\n**2\\. \"The quick brown fox jumps over the lazy cat\"**\n\n| Query | Result | Description |\n| --- | --- | --- |\n| `fox ~cat` | Return 1. first, then 2. | Return all records containing 'fox', but rank records containing 'cat' lower |\n| `fox (<cat >dog)` | Return 1. first, then 2. | Return all records containing 'fox', but rank records containing 'cat' lower than rows containing 'dog' |\n\nFor the full range of supported operations, see the [MySQL full text search documentation](https://dev.mysql.com/doc/refman/8.0/en/fulltext-boolean.html).\n\n## Sorting results by `_relevance`[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#sorting-results-by-_relevance \"Direct link to sorting-results-by-_relevance\")\n\nwarning\n\nSorting by relevance is only available for PostgreSQL and MySQL.\n\nIn addition to [Prisma Client's default `orderBy` behavior](https://www.prisma.io/docs/orm/reference/prisma-client-reference#orderby), full-text search also adds sorting by relevance to a given string or strings. As an example, if you wanted to order posts by their relevance to the term `'database'` in their title, you could use the following:\n\n```\nconst posts = await prisma.post.findMany({  orderBy: {    _relevance: {      fields: ['title'],      search: 'database',      sort: 'asc'    },  },})\n```\n\n## Adding indexes[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#adding-indexes \"Direct link to Adding indexes\")\n\n### PostgreSQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#postgresql-1 \"Direct link to PostgreSQL\")\n\nPrisma Client does not currently support using indexes to speed up full text search. There is an existing [GitHub Issue](https://github.com/prisma/prisma/issues/8950) for this.\n\n### MySQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#mysql-1 \"Direct link to MySQL\")\n\nFor MySQL, it is necessary to add indexes to any columns you search using the `@@fulltext` argument in the `schema.prisma` file. To do this, the `\"fullTextIndex\"` preview feature must be enabled.\n\nIn the following example, one full text index is added to the `content` field of the `Blog` model, and another is added to both the `content` and `title` fields together:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextSearch\", \"fullTextIndex\"]}model Blog {  id      Int    @unique  content String  title   String  @@fulltext([content])  @@fulltext([content, title])}\n```\n\nThe first index allows searching the `content` field for occurrences of the word 'cat':\n\n```\nconst result = await prisma.blogs.findMany({  where: {    content: {      search: 'cat',    },  },})\n```\n\nThe second index allows searching both the `content` and `title` fields for occurrences of the word 'cat' in the `content` and 'food' in the `title`:\n\n```\nconst result = await prisma.blogs.findMany({  where: {    content: {      search: 'cat',    },    title: {      search: 'food',    },  },})\n```\n\nHowever, if you try to search on `title` alone, the search will fail with the error \"Cannot find a fulltext index to use for the search\" and the message code is `P2030`, because the index requires a search on both fields.\n\n## Full-text search with raw SQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#full-text-search-with-raw-sql \"Direct link to Full-text search with raw SQL\")\n\nFull-text search is currently in Preview and due to a [known issue](https://github.com/prisma/prisma/issues/23627), you may be seeing slow search queries. If that's the case, you can optimize your query using [raw SQL](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access).\n\n### PostgreSQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#postgresql-2 \"Direct link to PostgreSQL\")\n\nIn PostgreSQL, you can use `to_tsvector` and `to_tsquery` to express your search query:\n\n```\nconst term = `cat`const result =  await prisma.$queryRaw`SELECT * FROM \"Blog\" WHERE to_tsvector('english', \"Blog\".\"content\") @@ to_tsquery('english', ${term});`\n```\n\n> **Note**: Depending on your language preferences, you may exchange `english` against another language in the SQL statement.\n\nIf you want to include a wildcard in your search term, you can do this as follows:\n\n```\nconst term = `cat:*`const result =  await prisma.$queryRaw`SELECT * FROM \"Blog\" WHERE to_tsvector('english', \"Blog\".\"content\") @@ to_tsquery('english', ${term});`\n```\n\n### MySQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search#mysql-2 \"Direct link to MySQL\")\n\nIn MySQL, you can express your search query as follows:\n\n```\nconst term = `cat`const result =  await prisma.$queryRaw`SELECT * FROM Blog WHERE MATCH(content) AGAINST(${term} IN NATURAL LANGUAGE MODE);`\n```",
  "title": "Full-text search (Preview) | Prisma Documentation",
  "description": "This page explains how to search for text within a field.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/custom-validation",
  "markdown": "# Custom validation | Prisma Documentation\n\n```\nimport { PrismaClient, Prisma } from '@prisma/client'import { z } from 'zod'/** * Zod schema */export const ProductCreateInput = z.object({  slug: z    .string()    .max(100)    .regex(/^[a-z0-9]+(?:-[a-z0-9]+)*$/),  name: z.string().max(100),  description: z.string().max(1000),  price: z    .instanceof(Prisma.Decimal)    .refine((price) => price.gte('0.01') && price.lt('1000000.00')),}) satisfies z.Schema<Prisma.ProductUncheckedCreateInput>/** * Prisma Client Extension */const prisma = new PrismaClient().$extends({  query: {    product: {      create({ args, query }) {        args.data = ProductCreateInput.parse(args.data)        return query(args)      },      update({ args, query }) {        args.data = ProductCreateInput.partial().parse(args.data)        return query(args)      },      updateMany({ args, query }) {        args.data = ProductCreateInput.partial().parse(args.data)        return query(args)      },      upsert({ args, query }) {        args.create = ProductCreateInput.parse(args.create)        args.update = ProductCreateInput.partial().parse(args.update)        return query(args)      },    },  },})async function main() {  /**   * Example usage   */  // Valid product  const product = await prisma.product.create({    data: {      slug: 'example-product',      name: 'Example Product',      description: 'Lorem ipsum dolor sit amet',      price: new Prisma.Decimal('10.95'),    },  })  // Invalid product  try {    await prisma.product.create({      data: {        slug: 'invalid-product',        name: 'Invalid Product',        description: 'Lorem ipsum dolor sit amet',        price: new Prisma.Decimal('-1.00'),      },    })  } catch (err: any) {    console.log(err?.cause?.issues)  }}main()\n```",
  "title": "Custom validation | Prisma Documentation",
  "description": "This page explains how to add custom validation to Prisma Client",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/transactions",
  "markdown": "# Transactions and batch queries (Reference)\n\nA database transaction refers to a sequence of read/write operations that are _guaranteed_ to either succeed or fail as a whole. This section describes the ways in which the Prisma Client API supports transactions.\n\n## Transactions overview[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transactions-overview \"Direct link to Transactions overview\")\n\ninfo\n\nBefore Prisma ORM version 4.4.0, you could not set isolation levels on transactions. The isolation level in your database configuration always applied.\n\nDevelopers take advantage of the safety guarantees provided by the database by wrapping the operations in a transaction. These guarantees are often summarized using the ACID acronym:\n\n*   **Atomic**: Ensures that either _all_ or _none_ operations of the transactions succeed. The transaction is either _committed_ successfully or _aborted_ and _rolled back_.\n*   **Consistent**: Ensures that the states of the database before and after the transaction are _valid_ (i.e. any existing invariants about the data are maintained).\n*   **Isolated**: Ensures that concurrently running transactions have the same effect as if they were running in serial.\n*   **Durability**: Ensures that after the transaction succeeded, any writes are being stored persistently.\n\nWhile there's a lot of ambiguity and nuance to each of these properties (for example, consistency could actually be considered an _application-level responsibility_ rather than a database property or isolation is typically guaranteed in terms of stronger and weaker _isolation levels_), overall they serve as a good high-level guideline for expectations developers have when thinking about database transactions.\n\n> \"Transactions are an abstraction layer that allows an application to pretend that certain concurrency problems and certain kinds of hardware and software faults don’t exist. A large class of errors is reduced down to a simple transaction abort, and the application just needs to try again.\" [Designing Data-Intensive Applications](https://dataintensive.net/), [Martin Kleppmann](https://twitter.com/martinkl)\n\nPrisma Client supports six different ways of handling transactions for three different scenarios:\n\nScenario\n\nAvailable techniques\n\nDependent writes\n\n*   Nested writes\n\nIndependent writes\n\n*   `$transaction([])` API\n*   Batch operations\n\nRead, modify, write\n\n*   Idempotent operations\n*   Optimistic concurrency control\n*   Interactive transactions\n\nThe technique you choose depends on your particular use case.\n\n> **Note**: For the purposes of this guide, _writing_ to a database encompasses creating, updating, and deleting data.\n\n## About transactions in Prisma Client[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#about-transactions-in-prisma-client \"Direct link to About transactions in Prisma Client\")\n\nPrisma Client provides the following options for using transactions:\n\n*   [Nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#nested-writes): use the Prisma Client API to process multiple operations on one or more related records inside the same transaction.\n*   [Batch / bulk transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#batchbulk-operations): process one or more operations in bulk with `updateMany`, `deleteMany`, and `createMany`.\n*   The `$transaction` API in Prisma Client:\n    *   [Sequential operations](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#sequential-prisma-client-operations): pass an array of Prisma Client queries to be executed sequentially inside a transaction, using `$transaction<R>(queries: PrismaPromise<R>[]): Promise<R[]>`.\n    *   [Interactive transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions): pass a function that can contain user code including Prisma Client queries, non-Prisma code and other control flow to be executed in a transaction, using `$transaction<R>(fn: (prisma: PrismaClient) => R, options?: object): R`\n\n## Nested writes[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#nested-writes \"Direct link to Nested writes\")\n\nA [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) lets you perform a single Prisma Client API call with multiple _operations_ that touch multiple [_related_](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) records. For example, creating a _user_ together with a _post_ or updating an _order_ together with an _invoice_. Prisma Client ensures that all operations succeed or fail as a whole.\n\nThe following example demonstrates a nested write with `create`:\n\n```\n// Create a new user with two posts in a// single transactionconst newUser: User = await prisma.user.create({  data: {    email: 'alice@prisma.io',    posts: {      create: [        { title: 'Join the Prisma Discord at https://pris.ly/discord' },        { title: 'Follow @prisma on Twitter' },      ],    },  },})\n```\n\nThe following example demonstrates a nested write with `update`:\n\n```\n// Change the author of a post in a single transactionconst updatedPost: Post = await prisma.post.update({  where: { id: 42 },  data: {    author: {      connect: { email: 'alice@prisma.io' },    },  },})\n```\n\n## Batch/bulk operations[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#batchbulk-operations \"Direct link to Batch/bulk operations\")\n\nThe following bulk operations run as transactions:\n\n*   `deleteMany()`\n*   `updateMany()`\n*   `createMany()`\n*   `createManyAndReturn()`\n\n> Refer to the section about [bulk operations](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#bulk-operations) for more examples.\n\n## The `$transaction` API[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#the-transaction-api \"Direct link to the-transaction-api\")\n\nThe `$transaction` API can be used in two ways:\n\n*   [Sequential operations](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#sequential-prisma-client-operations): Pass an array of Prisma Client queries to be executed sequentially inside of a transaction.\n    \n    `$transaction<R>(queries: PrismaPromise<R>[]): Promise<R[]>`\n    \n*   [Interactive transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions): Pass a function that can contain user code including Prisma Client queries, non-Prisma code and other control flow to be executed in a transaction.\n    \n    `$transaction<R>(fn: (prisma: PrismaClient) => R): R`\n    \n\n### Sequential Prisma Client operations[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#sequential-prisma-client-operations \"Direct link to Sequential Prisma Client operations\")\n\nThe following query returns all posts that match the provided filter as well as a count of all posts:\n\n```\nconst [posts, totalPosts] = await prisma.$transaction([  prisma.post.findMany({ where: { title: { contains: 'prisma' } } }),  prisma.post.count(),])\n```\n\nYou can also use raw queries inside of a `$transaction`:\n\n*   Relational databases\n*   MongoDB\n\n```\nconst [userList, updateUser] = await prisma.$transaction([  prisma.$queryRaw`SELECT 'title' FROM User`,  prisma.$executeRaw`UPDATE User SET name = 'Hello' WHERE id = 2;`,])\n```\n\nInstead of immediately awaiting the result of each operation when it's performed, the operation itself is stored in a variable first which later is submitted to the database with a method called `$transaction`. Prisma Client will ensure that either all three `create` operations succeed or none of them succeed.\n\n> **Note**: Operations are executed according to the order they are placed in the transaction. Using a query in a transaction does not influence the order of operations in the query itself.\n> \n> Refer to the section about the [transactions API](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-api) for more examples.\n\nFrom version 4.4.0, the sequential operations transaction API has a second parameter. You can use the following optional configuration option in this parameter:\n\n*   `isolationLevel`: Sets the [transaction isolation level](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-isolation-level). By default this is set to the value currently configured in your database.\n\nFor example:\n\n```\nawait prisma.$transaction(  [    prisma.resource.deleteMany({ where: { name: 'name' } }),    prisma.resource.createMany({ data }),  ],  {    isolationLevel: Prisma.TransactionIsolationLevel.Serializable, // optional, default defined by database configuration  })\n```\n\n### Interactive transactions[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions \"Direct link to Interactive transactions\")\n\n#### Overview[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#overview \"Direct link to Overview\")\n\nSometimes you need more control over what queries execute within a transaction. Interactive transactions are meant to provide you with an escape hatch.\n\ninfo\n\nInteractive transactions have been generally available from version 4.7.0.\n\nIf you use interactive transactions in preview from version 2.29.0 to 4.6.1 (included), you need to add the `interactiveTransactions` preview feature to the generator block of your Prisma schema.\n\nTo use interactive transactions, you can pass an async function into [`$transaction`](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-api).\n\nThe first argument passed into this async function is an instance of Prisma Client. Below, we will call this instance `tx`. Any Prisma Client call invoked on this `tx` instance is encapsulated into the transaction.\n\nwarning\n\n**Use interactive transactions with caution**. Keeping transactions open for a long time hurts database performance and can even cause deadlocks. Try to avoid performing network requests and executing slow queries inside your transaction functions. We recommend you get in and out as quick as possible!\n\n#### Example[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#example \"Direct link to Example\")\n\nLet's look at an example:\n\nImagine that you are building an online banking system. One of the actions to perform is to send money from one person to another.\n\nAs experienced developers, we want to make sure that during the transfer,\n\n*   the amount doesn't disappear\n*   the amount isn't doubled\n\nThis is a great use-case for interactive transactions because we need to perform logic in-between the writes to check the balance.\n\nIn the example below, Alice and Bob each have $100 in their account. If they try to send more money than they have, the transfer is rejected.\n\nAlice is expected to be able to make 1 transfer for $100 while the other transfer would be rejected. This would result in Alice having $0 and Bob having $200.\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()function transfer(from: string, to: string, amount: number) {  return prisma.$transaction(async (tx) => {    // 1. Decrement amount from the sender.    const sender = await tx.account.update({      data: {        balance: {          decrement: amount,        },      },      where: {        email: from,      },    })    // 2. Verify that the sender's balance didn't go below zero.    if (sender.balance < 0) {      throw new Error(`${from} doesn't have enough to send ${amount}`)    }    // 3. Increment the recipient's balance by amount    const recipient = await tx.account.update({      data: {        balance: {          increment: amount,        },      },      where: {        email: to,      },    })    return recipient  })}async function main() {  // This transfer is successful  await transfer('alice@prisma.io', 'bob@prisma.io', 100)  // This transfer fails because Alice doesn't have enough funds in her account  await transfer('alice@prisma.io', 'bob@prisma.io', 100)}main()\n```\n\nIn the example above, both `update` queries run within a database transaction. When the application reaches the end of the function, the transaction is **committed** to the database.\n\nIf your application encounters an error along the way, the async function will throw an exception and automatically **rollback** the transaction.\n\nTo catch the exception, you can wrap `$transaction` in a try-catch block:\n\n```\ntry {  await prisma.$transaction(async (tx) => {    // Code running in a transaction...  })} catch (err) {  // Handle the rollback...}\n```\n\n#### Transaction options[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-options \"Direct link to Transaction options\")\n\nThe transaction API has a second parameter. For interactive transactions, you can use the following optional configuration options in this parameter:\n\n*   `maxWait`: The maximum amount of time Prisma Client will wait to acquire a transaction from the database. The default value is 2 seconds.\n*   `timeout`: The maximum amount of time the interactive transaction can run before being canceled and rolled back. The default value is 5 seconds.\n*   `isolationLevel`: Sets the [transaction isolation level](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-isolation-level). By default this is set to the value currently configured in your database.\n\nFor example:\n\n```\nawait prisma.$transaction(  async (tx) => {    // Code running in a transaction...  },  {    maxWait: 5000, // default: 2000    timeout: 10000, // default: 5000    isolationLevel: Prisma.TransactionIsolationLevel.Serializable, // optional, default defined by database configuration  })\n```\n\nYou can also set these globally on the constructor-level:\n\n```\nconst prisma = new PrismaClient({  transactionOptions: {    isolationLevel: Prisma.TransactionIsolationLevel.Serializable,    maxWait: 5000, // default: 2000    timeout: 10000, // default: 5000  },})\n```\n\n### Transaction isolation level[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-isolation-level \"Direct link to Transaction isolation level\")\n\ninfo\n\nThis feature is not available on MongoDB, because MongoDB does not support isolation levels.\n\nYou can set the transaction [isolation level](https://www.prisma.io/dataguide/intro/database-glossary#isolation-levels) for transactions.\n\ninfo\n\nThis is available in the following Prisma ORM versions for interactive transactions from version 4.2.0, for sequential operations from version 4.4.0.\n\nIn versions before 4.2.0 (for interactive transactions), or 4.4.0 (for sequential operations), you cannot configure the transaction isolation level at a Prisma ORM level. Prisma ORM does not explicitly set the isolation level, so the [isolation level configured in your database](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#database-specific-information-on-isolation-levels) is used.\n\n#### Set the isolation level[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#set-the-isolation-level \"Direct link to Set the isolation level\")\n\nTo set the transaction isolation level, use the `isolationLevel` option in the second parameter of the API.\n\nFor sequential operations:\n\n```\nawait prisma.$transaction(  [    // Prisma Client operations running in a transaction...  ],  {    isolationLevel: Prisma.TransactionIsolationLevel.Serializable, // optional, default defined by database configuration  })\n```\n\nFor an interactive transaction:\n\n```\nawait prisma.$transaction(  async (prisma) => {    // Code running in a transaction...  },  {    isolationLevel: Prisma.TransactionIsolationLevel.Serializable, // optional, default defined by database configuration    maxWait: 5000, // default: 2000    timeout: 10000, // default: 5000  })\n```\n\n#### Supported isolation levels[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#supported-isolation-levels \"Direct link to Supported isolation levels\")\n\nPrisma Client supports the following isolation levels if they are available in the underlying database:\n\n*   `ReadUncommitted`\n*   `ReadCommitted`\n*   `RepeatableRead`\n*   `Snapshot`\n*   `Serializable`\n\nThe isolation levels available for each database connector are as follows:\n\nDatabase\n\n`ReadUncommitted`\n\n`ReadCommitted`\n\n`RepeatableRead`\n\n`Snapshot`\n\n`Serializable`\n\nPostgreSQL\n\n✔️\n\n✔️\n\n✔️\n\nNo\n\n✔️\n\nMySQL\n\n✔️\n\n✔️\n\n✔️\n\nNo\n\n✔️\n\nSQL Server\n\n✔️\n\n✔️\n\n✔️\n\n✔️\n\n✔️\n\nCockroachDB\n\nNo\n\nNo\n\nNo\n\nNo\n\n✔️\n\nSQLite\n\nNo\n\nNo\n\nNo\n\nNo\n\n✔️\n\nBy default, Prisma Client sets the isolation level to the value currently configured in your database.\n\nThe isolation levels configured by default in each database are as follows:\n\nDatabase\n\nDefault\n\nPostgreSQL\n\n`ReadCommitted`\n\nMySQL\n\n`RepeatableRead`\n\nSQL Server\n\n`ReadCommitted`\n\nCockroachDB\n\n`Serializable`\n\nSQLite\n\n`Serializable`\n\n#### Database-specific information on isolation levels[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#database-specific-information-on-isolation-levels \"Direct link to Database-specific information on isolation levels\")\n\nSee the following resources:\n\n*   [Transaction isolation levels in PostgreSQL](https://www.postgresql.org/docs/9.3/runtime-config-client.html#GUC-DEFAULT-TRANSACTION-ISOLATION)\n*   [Transaction isolation levels in Microsoft SQL Server](https://docs.microsoft.com/en-us/sql/t-sql/statements/set-transaction-isolation-level-transact-sql?view=sql-server-ver15)\n*   [Transaction isolation levels in MySQL](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)\n\nCockroachDB and SQLite only support the `Serializable` isolation level.\n\n### Transaction timing issues[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-timing-issues \"Direct link to Transaction timing issues\")\n\ninfo\n\n*   The solution in this section does not apply to MongoDB, because MongoDB does not support [isolation levels](https://www.prisma.io/dataguide/intro/database-glossary#isolation-levels).\n*   The timing issues discussed in this section do not apply to CockroachDB and SQLite, because these databases only support the highest `Serializable` isolation level.\n\nWhen two or more transactions run concurrently in certain [isolation levels](https://www.prisma.io/dataguide/intro/database-glossary#isolation-levels), timing issues can cause write conflicts or deadlocks, such as the violation of unique constraints. For example, consider the following sequence of events where Transaction A and Transaction B both attempt to execute a `deleteMany` and a `createMany` operation:\n\n1.  Transaction B: `createMany` operation creates a new set of rows.\n2.  Transaction B: The application commits transaction B.\n3.  Transaction A: `createMany` operation.\n4.  Transaction A: The application commits transaction A. The new rows conflict with the rows that transaction B added at step 2.\n\nThis conflict can occur at the isolation level `ReadCommited`, which is the default isolation level in PostgreSQL and Microsoft SQL Server. To avoid this problem, you can set a higher isolation level (`RepeatableRead` or `Serializable`). You can set the isolation level on a transaction. This overrides your database isolation level for that transaction.\n\nTo avoid transaction write conflicts and deadlocks on a transaction:\n\n1.  On your transaction, use the `isolationLevel` parameter to `Prisma.TransactionIsolationLevel.Serializable`.\n    \n    This ensures that your application commits multiple concurrent or parallel transactions as if they were run serially. When a transaction fails due to a write conflict or deadlock, Prisma Client returns a [P2034 error](https://www.prisma.io/docs/orm/reference/error-reference#p2034).\n    \n2.  In your application code, add a retry around your transaction to handle any P2034 errors, as shown in this example:\n    \n    ```\n    import { Prisma, PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  const MAX_RETRIES = 5  let retries = 0  let result  while (retries < MAX_RETRIES) {    try {      result = await prisma.$transaction(        [          prisma.user.deleteMany({            where: {              /** args */            },          }),          prisma.post.createMany({            data: {              /** args */            },          }),        ],        {          isolationLevel: Prisma.TransactionIsolationLevel.Serializable,        }      )      break    } catch (error) {      if (error.code === 'P2034') {        retries++        continue      }      throw error    }  }}\n    ```\n    \n\n## Dependent writes[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#dependent-writes \"Direct link to Dependent writes\")\n\nWrites are considered **dependent** on each other if:\n\n*   Operations depend on the result of a preceding operation (for example, the database generating an ID)\n\nThe most common scenario is creating a record and using the generated ID to create or update a related record. Examples include:\n\n*   Creating a user and two related blog posts (a one-to-many relationship) - the author ID must be known before creating blog posts\n*   Creating a team and assigning members (a many-to-many relationship) - the team ID must be known before assigning members\n\nDependent writes must succeed together in order to maintain data consistency and prevent unexpected behavior, such as blog post without an author or a team without members.\n\n### Nested writes[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#nested-writes-1 \"Direct link to Nested writes\")\n\nPrisma Client's solution to dependent writes is the **nested writes** feature, which is supported by `create` and `update`. The following nested write creates one user and two blog posts:\n\n```\nconst nestedWrite = await prisma.user.create({  data: {    email: 'imani@prisma.io',    posts: {      create: [        { title: 'My first day at Prisma' },        { title: 'How to configure a unique constraint in PostgreSQL' },      ],    },  },})\n```\n\nIf any operation fails, Prisma Client rolls back the entire transaction. Nested writes are not currently supported by top-level bulk operations like `client.user.deleteMany` and `client.user.updateMany`.\n\n#### When to use nested writes[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#when-to-use-nested-writes \"Direct link to When to use nested writes\")\n\nConsider using nested writes if:\n\n*   ✔ You want to create two or more records related by ID at the same time (for example, create a blog post and a user)\n*   ✔ You want to update and create records related by ID at the same time (for example, change a user's name and create a new blog post)\n\n#### Scenario: Sign-up flow[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#scenario-sign-up-flow \"Direct link to Scenario: Sign-up flow\")\n\nConsider the Slack sign-up flow, which:\n\n1.  Creates a team\n2.  Adds one user to that team, which automatically becomes that team's administrator\n\nThis scenario can be represented by the following schema - note that users can belong to many teams, and teams can have many users (a many-to-many relationship):\n\n```\nmodel Team {  id      Int    @id @default(autoincrement())  name    String  members User[] // Many team members}model User {  id    Int    @id @default(autoincrement())  email String @unique  teams Team[] // Many teams}\n```\n\nThe most straightforward approach is to create a team, then create and attach a user to that team:\n\n```\n// Create a teamconst team = await prisma.team.create({  data: {    name: 'Aurora Adventures',  },})// Create a user and assign them to the teamconst user = await prisma.user.create({  data: {    email: 'alice@prisma.io',    team: {      connect: {        id: team.id,      },    },  },})\n```\n\nHowever, this code has a problem - consider the following scenario:\n\n1.  Creating the team succeeds - \"Aurora Adventures\" is now taken\n2.  Creating and connecting the user fails - the team \"Aurora Adventures\" exists, but has no users\n3.  Going through the sign-up flow again and attempting to recreate \"Aurora Adventures\" fails - the team already exists\n\nCreating a team and adding a user should be one atomic operation that **succeeds or fails as a whole**.\n\nTo implement atomic writes in a low-level database clients, you must wrap your inserts in `BEGIN`, `COMMIT` and `ROLLBACK` statements. Prisma Client solves the problem with [nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes). The following query creates a team, creates a user, and connects the records in a single transaction:\n\n```\nconst team = await prisma.team.create({  data: {    name: 'Aurora Adventures',    members: {      create: {        email: 'alice@prisma.io',      },    },  },})\n```\n\nFurthermore, if an error occurs at any point, Prisma Client rolls back the entire transaction.\n\n#### Nested writes FAQs[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#nested-writes-faqs \"Direct link to Nested writes FAQs\")\n\n##### Why can't I use the `$transaction([])` API to solve the same problem?[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#why-cant-i-use-the-transaction-api-to-solve-the-same-problem \"Direct link to why-cant-i-use-the-transaction-api-to-solve-the-same-problem\")\n\nThe `$transaction([])` API does not allow you to pass IDs between distinct operations. In the following example, `createUserOperation.id` is not available yet:\n\n```\nconst createUserOperation = prisma.user.create({  data: {    email: 'ebony@prisma.io',  },})const createTeamOperation = prisma.team.create({  data: {    name: 'Aurora Adventures',    members: {      connect: {        id: createUserOperation.id, // Not possible, ID not yet available      },    },  },})await prisma.$transaction([createUserOperation, createTeamOperation])\n```\n\n##### Nested writes support nested updates, but updates are not dependent writes - should I use the `$transaction([])` API?[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#nested-writes-support-nested-updates-but-updates-are-not-dependent-writes---should-i-use-the-transaction-api \"Direct link to nested-writes-support-nested-updates-but-updates-are-not-dependent-writes---should-i-use-the-transaction-api\")\n\nIt is correct to say that because you know the ID of the team, you can update the team and its team members independently within a `$transaction([])`. The following example performs both operations in a `$transaction([])`:\n\n```\nconst updateTeam = prisma.team.update({  where: {    id: 1,  },  data: {    name: 'Aurora Adventures Ltd',  },})const updateUsers = prisma.user.updateMany({  where: {    teams: {      some: {        id: 1,      },    },    name: {      equals: null,    },  },  data: {    name: 'Unknown User',  },})await prisma.$transaction([updateUsers, updateTeam])\n```\n\nHowever, you can achieve the same result with a nested write:\n\n```\nconst updateTeam = await prisma.team.update({  where: {    id: 1,  },  data: {    name: 'Aurora Adventures Ltd', // Update team name    members: {      updateMany: {        // Update team members that do not have a name        data: {          name: 'Unknown User',        },        where: {          name: {            equals: null,          },        },      },    },  },})\n```\n\n##### Can I perform multiple nested writes - for example, create two new teams and assign users?[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#can-i-perform-multiple-nested-writes---for-example-create-two-new-teams-and-assign-users \"Direct link to Can I perform multiple nested writes - for example, create two new teams and assign users?\")\n\nYes, but this is a combination of scenarios and techniques:\n\n*   Creating a team and assigning users is a dependent write - use nested writes\n*   Creating all teams and users at the same time is an independent write because team/user combination #1 and team/user combination #2 are unrelated writes - use the `$transaction([])` API\n\n```\n// Nested writeconst createOne = prisma.team.create({  data: {    name: 'Aurora Adventures',    members: {      create: {        email: 'alice@prisma.io',      },    },  },})// Nested writeconst createTwo = prisma.team.create({  data: {    name: 'Cool Crew',    members: {      create: {        email: 'elsa@prisma.io',      },    },  },})// $transaction([]) APIawait prisma.$transaction([createTwo, createOne])\n```\n\n## Independent writes[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#independent-writes \"Direct link to Independent writes\")\n\nWrites are considered **independent** if they do not rely on the result of a previous operation. The following groups of independent writes can occur in any order:\n\n*   Updating the status field of a list of orders to \"Dispatched\"\n*   Marking a list of emails as \"Read\"\n\n> **Note**: Independent writes may have to occur in a specific order if constraints are present - for example, you must delete blog posts before the blog author if the post have a mandatory `authorId` field. However, they are still considered independent writes because no operations depend on the _result_ of a previous operation, such as the database returning a generated ID.\n\nDepending on your requirements, Prisma Client has four options for handling independent writes that should succeed or fail together.\n\n### Bulk operations[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#bulk-operations \"Direct link to Bulk operations\")\n\nBulk writes allow you to write multiple records of the same type in a single transaction - if any operation fails, Prisma Client rolls back the entire transaction. Prisma Client currently supports:\n\n*   `updateMany()`\n*   `deleteMany()`\n*   `createMany()`\n*   `createManyAndReturn()`\n\n#### When to use bulk operations[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#when-to-use-bulk-operations \"Direct link to When to use bulk operations\")\n\nConsider bulk operations as a solution if:\n\n*   ✔ You want to update a batch of the _same type_ of record, like a batch of emails\n\n#### Scenario: Marking emails as read[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#scenario-marking-emails-as-read \"Direct link to Scenario: Marking emails as read\")\n\nYou are building a service like gmail.com, and your customer wants a **\"Mark as read\"** feature that allows users to mark all emails as read. Each update to the status of an email is an independent write because the emails do not depend on one another - for example, the \"Happy Birthday! 🍰\" email from your aunt is unrelated to the promotional email from IKEA.\n\nIn the following schema, a `User` can have many received emails (a one-to-many relationship):\n\n```\nmodel User {  id    Int       @id @default(autoincrement())  email           String @unique  receivedEmails  Email[] // Many emails}model Email {  id      Int     @id @default(autoincrement())  user    User    @relation(fields: [userId], references: [id])  userId  Int  subject String  body    String  unread  Boolean}\n```\n\nBased on this schema, you can use `updateMany` to mark all unread emails as read:\n\n```\nawait prisma.email.updateMany({  where: {    user: {      id: 10,    },    unread: true,  },  data: {    unread: false,  },})\n```\n\n#### Can I use nested writes with bulk operations?[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#can-i-use-nested-writes-with-bulk-operations \"Direct link to Can I use nested writes with bulk operations?\")\n\nNo - neither `updateMany` nor `deleteMany` currently supports nested writes. For example, you cannot delete multiple teams and all of their members (a cascading delete):\n\n```\nawait prisma.team.deleteMany({  where: {    id: {      in: [2, 99, 2, 11],    },  },  data: {    members: {}, // Cannot access members here  },})\n```\n\n#### Can I use bulk operations with the `$transaction([])` API?[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#can-i-use-bulk-operations-with-the-transaction-api \"Direct link to can-i-use-bulk-operations-with-the-transaction-api\")\n\nYes — for example, you can include multiple `deleteMany` operations inside a `$transaction([])`.\n\n### `$transaction([])` API[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-api \"Direct link to transaction-api\")\n\nThe `$transaction([])` API is generic solution to independent writes that allows you to run multiple operations as a single, atomic operation - if any operation fails, Prisma Client rolls back the entire transaction.\n\nIts also worth noting that operations are executed according to the order they are placed in the transaction.\n\n```\nawait prisma.$transaction([iRunFirst, iRunSecond, iRunThird])\n```\n\n> **Note**: Using a query in a transaction does not influence the order of operations in the query itself.\n\nAs Prisma Client evolves, use cases for the `$transaction([])` API will increasingly be replaced by more specialized bulk operations (such as `createMany`) and nested writes.\n\n#### When to use the `$transaction([])` API[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#when-to-use-the-transaction-api \"Direct link to when-to-use-the-transaction-api\")\n\nConsider the `$transaction([])` API if:\n\n*   ✔ You want to update a batch that includes different types of records, such as emails and users. The records do not need to be related in any way.\n*   ✔ You want to batch raw SQL queries (`$executeRaw`) - for example, for features that Prisma Client does not yet support.\n\n#### Scenario: Privacy legislation[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#scenario-privacy-legislation \"Direct link to Scenario: Privacy legislation\")\n\nGDPR and other privacy legislation give users the right to request that an organization deletes all of their personal data. In the following example schema, a `User` can have many posts and private messages:\n\n```\nmodel User {  id              Int              @id @default(autoincrement())  posts           Post[]  privateMessages PrivateMessage[]}model Post {  id      Int    @id @default(autoincrement())  user    User   @relation(fields: [userId], references: [id])  userId  Int  title   String  content String}model PrivateMessage {  id      Int    @id @default(autoincrement())  user    User   @relation(fields: [userId], references: [id])  userId  Int  message String}\n```\n\nIf a user invokes the right to be forgotten, we must delete three records: the user record, private messages, and posts. It is critical that _all_ delete operations succeed together or not at all, which makes this a use case for a transaction. However, using a single bulk operation like `deleteMany` is not possible in this scenario because we need to delete across three models. Instead, we can use the `$transaction([])` API to run three operations together - two `deleteMany` and one `delete`:\n\n```\nconst id = 9 // User to be deletedconst deletePosts = prisma.post.deleteMany({  where: {    userId: id,  },})const deleteMessages = prisma.privateMessage.deleteMany({  where: {    userId: id,  },})const deleteUser = prisma.user.delete({  where: {    id: id,  },})await prisma.$transaction([deletePosts, deleteMessages, deleteUser]) // Operations succeed or fail together\n```\n\n#### Scenario: Pre-computed IDs and the `$transaction([])` API[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#scenario-pre-computed-ids-and-the-transaction-api \"Direct link to scenario-pre-computed-ids-and-the-transaction-api\")\n\nDependent writes are not supported by the `$transaction([])` API - if operation A relies on the ID generated by operation B, use [nested writes](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#nested-writes). However, if you _pre-computed_ IDs (for example, by generating GUIDs), your writes become independent. Consider the sign-up flow from the nested writes example:\n\n```\nawait prisma.team.create({  data: {    name: 'Aurora Adventures',    members: {      create: {        email: 'alice@prisma.io',      },    },  },})\n```\n\nInstead of auto-generating IDs, change the `id` fields of `Team` and `User` to a `String` (if you do not provide a value, a UUID is generated automatically). This example uses UUIDs:\n\n```\nmodel Team {  id      Int    @id @default(autoincrement())  id      String @id @default(uuid())  name    String  members User[]}model User {  id    Int    @id @default(autoincrement())  id    String @id @default(uuid())  email String @unique  teams Team[]}\n```\n\nRefactor the sign-up flow example to use the `$transaction([])` API instead of nested writes:\n\n```\nimport { v4 } from 'uuid'const teamID = v4()const userID = v4()await prisma.$transaction([  prisma.user.create({    data: {      id: userID,      email: 'alice@prisma.io',      team: {        id: teamID,      },    },  }),  prisma.team.create({    data: {      id: teamID,      name: 'Aurora Adventures',    },  }),])\n```\n\nTechnically you can still use nested writes with pre-computed APIs if you prefer that syntax:\n\n```\nimport { v4 } from 'uuid'const teamID = v4()const userID = v4()await prisma.team.create({  data: {    id: teamID,    name: 'Aurora Adventures',    members: {      create: {        id: userID,        email: 'alice@prisma.io',        team: {          id: teamID,        },      },    },  },})\n```\n\nThere's no compelling reason to switch to manually generated IDs and the `$transaction([])` API if you are already using auto-generated IDs and nested writes.\n\n## Read, modify, write[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#read-modify-write \"Direct link to Read, modify, write\")\n\nIn some cases you may need to perform custom logic as part of an atomic operation - also known as the [read-modify-write pattern](https://en.wikipedia.org/wiki/Read%E2%80%93modify%E2%80%93write). The following is an example of the read-modify-write pattern:\n\n*   Read a value from the database\n*   Run some logic to manipulate that value (for example, contacting an external API)\n*   Write the value back to the database\n\nAll operations should **succeed or fail together** without making unwanted changes to the database, but you do not necessarily need to use an actual database transaction. This section of the guide describes two ways to work with Prisma Client and the read-modify-write pattern:\n\n*   Designing idempotent APIs\n*   Optimistic concurrency control\n\n### Idempotent APIs[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#idempotent-apis \"Direct link to Idempotent APIs\")\n\nIdempotency is the ability to run the same logic with the same parameters multiple times with the same result: the **effect on the database** is the same whether you run the logic once or one thousand times. For example:\n\n*   **NOT IDEMPOTENT**: Upsert (update-or-insert) a user in the database with email address `\"letoya@prisma.io\"`. The `User` table **does not** enforce unique email addresses. The effect on the database is different if you run the logic once (one user created) or ten times (ten users created).\n*   **IDEMPOTENT**: Upsert (update-or-insert) a user in the database with the email address `\"letoya@prisma.io\"`. The `User` table **does** enforce unique email addresses. The effect on the database is the same if you run the logic once (one user created) or ten times (existing user is updated with the same input).\n\nIdempotency is something you can and should actively design into your application wherever possible.\n\n#### When to design an idempotent API[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#when-to-design-an-idempotent-api \"Direct link to When to design an idempotent API\")\n\n*   ✔ You need to be able to retry the same logic without creating unwanted side-effects in the databases\n\n#### Scenario: Upgrading a Slack team[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#scenario-upgrading-a-slack-team \"Direct link to Scenario: Upgrading a Slack team\")\n\nYou are creating an upgrade flow for Slack that allows teams to unlock paid features. Teams can choose between different plans and pay per user, per month. You use Stripe as your payment gateway, and extend your `Team` model to store a `stripeCustomerId`. Subscriptions are managed in Stripe.\n\n```\nmodel Team {  id               Int     @id @default(autoincrement())  name             String  User             User[]  stripeCustomerId String?}\n```\n\nThe upgrade flow looks like this:\n\n1.  Count the number of users\n2.  Create a subscription in Stripe that includes the number of users\n3.  Associate the team with the Stripe customer ID to unlock paid features\n\n```\nconst teamId = 9const planId = 'plan_id'// Count team membersconst numTeammates = await prisma.user.count({  where: {    teams: {      some: {        id: teamId,      },    },  },})// Create a customer in Stripe for plan-9454549const customer = await stripe.customers.create({  externalId: teamId,  plan: planId,  quantity: numTeammates,})// Update the team with the customer id to indicate that they are a customer// and support querying this customer in Stripe from our application code.await prisma.team.update({  data: {    customerId: customer.id,  },  where: {    id: teamId,  },})\n```\n\nThis example has a problem: you can only run the logic _once_. Consider the following scenario:\n\n1.  Stripe creates a new customer and subscription, and returns a customer ID\n    \n2.  Updating the team **fails** - the team is not marked as a customer in the Slack database\n    \n3.  The customer is charged by Stripe, but paid features are not unlocked in Slack because the team lacks a valid `customerId`\n    \n4.  Running the same code again either:\n    \n    *   Results in an error because the team (defined by `externalId`) already exists - Stripe never returns a customer ID\n    *   If `externalId` is not subject to a unique constraint, Stripe creates yet another subscription (**not idempotent**)\n\nYou cannot re-run this code in case of an error and you cannot change to another plan without being charged twice.\n\nThe following refactor (highlighted) introduces a mechanism that checks if a subscription already exists, and either creates the description or updates the existing subscription (which will remain unchanged if the input is identical):\n\n```\n// Calculate the number of users times the cost per userconst numTeammates = await prisma.user.count({  where: {    teams: {      some: {        id: teamId,      },    },  },})// Find customer in Stripelet customer = await stripe.customers.get({ externalId: teamID })if (customer) {  // If team already exists, update  customer = await stripe.customers.update({    externalId: teamId,    plan: 'plan_id',    quantity: numTeammates,  })} else {  customer = await stripe.customers.create({    // If team does not exist, create customer    externalId: teamId,    plan: 'plan_id',    quantity: numTeammates,  })}// Update the team with the customer id to indicate that they are a customer// and support querying this customer in Stripe from our application code.await prisma.team.update({  data: {    customerId: customer.id,  },  where: {    id: teamId,  },})\n```\n\nYou can now retry the same logic multiple times with the same input without adverse effect. To further enhance this example, you can introduce a mechanism whereby the subscription is cancelled or temporarily deactivated if the update does not succeed after a set number of attempts.\n\n### Optimistic concurrency control[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#optimistic-concurrency-control \"Direct link to Optimistic concurrency control\")\n\nOptimistic concurrency control (OCC) is a model for handling concurrent operations on a single entity that does not rely on 🔒 locking. Instead, we **optimistically** assume that a record will remain unchanged in between reading and writing, and use a concurrency token (a timestamp or version field) to detect changes to a record.\n\nIf a ❌ conflict occurs (someone else has changed the record since you read it), you cancel the transaction. Depending on your scenario, you can then:\n\n*   Re-try the transaction (book another cinema seat)\n*   Throw an error (alert the user that they are about to overwrite changes made by someone else)\n\nThis section describes how to build your own optimistic concurrency control. See also: Plans for [application-level optimistic concurrency control on GitHub](https://github.com/prisma/prisma/issues/4988)\n\ninfo\n\n*   If you use version 4.4.0 or earlier, you cannot use optimistic concurrency control on `update` operations, because you cannot filter on non-unique fields. The `version` field you need to use with optimistic concurrency control is a non-unique field.\n    \n*   Since version 5.0.0 you are able to [filter on non-unique fields in `update` operations](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-on-non-unique-fields-with-userwhereuniqueinput) so that optimistic concurrency control is being used. The feature was also available via the Preview flag `extendedWhereUnique` from versions 4.5.0 to 4.16.2.\n    \n\n#### When to use optimistic concurrency control[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#when-to-use-optimistic-concurrency-control \"Direct link to When to use optimistic concurrency control\")\n\n*   ✔ You anticipate a high number of concurrent requests (multiple people booking cinema seats)\n*   ✔ You anticipate that conflicts between those concurrent requests will be rare\n\nAvoiding locks in a application with a high number of concurrent requests makes the application more resilient to load and more scalable overall. Although locking is not inherently bad, locking in a high concurrency environment can lead to unintended consequences - even if you are locking individual rows, and only for a short amount of time. For more information, see:\n\n*   [Why ROWLOCK Hints Can Make Queries Slower and Blocking Worse in SQL Server](https://littlekendra.com/2016/02/04/why-rowlock-hints-can-make-queries-slower-and-blocking-worse-in-sql-server/)\n*   [The High Concurrency strategy](https://www.ibm.com/developerworks/library/j-ts5/index.html)\n\n#### Scenario: Reserving a seat at the cinema[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#scenario-reserving-a-seat-at-the-cinema \"Direct link to Scenario: Reserving a seat at the cinema\")\n\nYou are creating a booking system for a cinema. Each movie has a set number of seats. The following schema models movies and seats:\n\n```\nmodel Seat {  id        Int   @id @default(autoincrement())  userId    Int?  claimedBy User? @relation(fields: [userId], references: [id])  movieId   Int  movie     Movie @relation(fields: [movieId], references: [id])}model Movie {  id    Int    @id     @default(autoincrement())  name  String @unique  seats Seat[]}\n```\n\nThe following sample code finds the first available seat and assigns that seat to a user:\n\n```\nconst movieName = 'Hidden Figures'// Find first available seatconst availableSeat = await prisma.seat.findFirst({  where: {    movie: {      name: movieName,    },    claimedBy: null,  },})// Throw an error if no seats are availableif (!availableSeat) {  throw new Error(`Oh no! ${movieName} is all booked.`)}// Claim the seatawait prisma.seat.update({  data: {    claimedBy: userId,  },  where: {    id: availableSeat.id,  },})\n```\n\nHowever, this code suffers from the \"double-booking problem\" - it is possible for two people to book the same seats:\n\n1.  Seat 3A returned to Sorcha (`findFirst`)\n2.  Seat 3A returned to Ellen (`findFirst`)\n3.  Seat 3A claimed by Sorcha (`update`)\n4.  Seat 3A claimed by Ellen (`update` - overwrites Sorcha's claim)\n\nEven though Sorcha has successfully booked the seat, the system ultimately stores Ellen's claim. To solve this problem with optimistic concurrency control, add a `version` field to the seat:\n\n```\nmodel Seat {  id        Int   @id @default(autoincrement())  userId    Int?  claimedBy User? @relation(fields: [userId], references: [id])  movieId   Int  movie     Movie @relation(fields: [movieId], references: [id])  version   Int}\n```\n\nNext, adjust the code to check the `version` field before updating:\n\n```\nconst userEmail = 'alice@prisma.io'const movieName = 'Hidden Figures'// Find the first available seat// availableSeat.version might be 0const availableSeat = await client.seat.findFirst({  where: {    Movie: {      name: movieName,    },    claimedBy: null,  },})if (!availableSeat) {  throw new Error(`Oh no! ${movieName} is all booked.`)}// Only mark the seat as claimed if the availableSeat.version// matches the version we're updating. Additionally, increment the// version when we perform this update so all other clients trying// to book this same seat will have an outdated version.const seats = await client.seat.updateMany({  data: {    claimedBy: userEmail,    version: {      increment: 1,    },  },  where: {    id: availableSeat.id,    version: availableSeat.version, // This version field is the key; only claim seat if in-memory version matches database version, indicating that the field has not been updated  },})if (seats.count === 0) {  throw new Error(`That seat is already booked! Please try again.`)}\n```\n\nIt is now impossible for two people to book the same seat:\n\n1.  Seat 3A returned to Sorcha (`version` is 0)\n2.  Seat 3A returned to Ellen (`version` is 0)\n3.  Seat 3A claimed by Sorcha (`version` is incremented to 1, booking succeeds)\n4.  Seat 3A claimed by Ellen (in-memory `version` (0) does not match database `version` (1) - booking does not succeed)\n\n### Interactive transactions[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions-1 \"Direct link to Interactive transactions\")\n\nIf you have an existing application, it can be a significant undertaking to refactor your application to use optimistic concurrency control. Interactive Transactions offers a useful escape hatch for cases like this.\n\nTo create an interactive transaction, pass an async function into [$transaction](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#transaction-api).\n\nThe first argument passed into this async function is an instance of Prisma Client. Below, we will call this instance `tx`. Any Prisma Client call invoked on this `tx` instance is encapsulated into the transaction.\n\nIn the example below, Alice and Bob each have $100 in their account. If they try to send more money than they have, the transfer is rejected.\n\nThe expected outcome would be for Alice to make 1 transfer for $100 and the other transfer would be rejected. This would result in Alice having $0 and Bob having $200.\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function transfer(from: string, to: string, amount: number) {  return await prisma.$transaction(async (tx) => {    // 1. Decrement amount from the sender.    const sender = await tx.account.update({      data: {        balance: {          decrement: amount,        },      },      where: {        email: from,      },    })    // 2. Verify that the sender's balance didn't go below zero.    if (sender.balance < 0) {      throw new Error(`${from} doesn't have enough to send ${amount}`)    }    // 3. Increment the recipient's balance by amount    const recipient = tx.account.update({      data: {        balance: {          increment: amount,        },      },      where: {        email: to,      },    })    return recipient  })}async function main() {  // This transfer is successful  await transfer('alice@prisma.io', 'bob@prisma.io', 100)  // This transfer fails because Alice doesn't have enough funds in her account  await transfer('alice@prisma.io', 'bob@prisma.io', 100)}main()\n```\n\nIn the example above, both `update` queries run within a database transaction. When the application reaches the end of the function, the transaction is **committed** to the database.\n\nIf the application encounters an error along the way, the async function will throw an exception and automatically **rollback** the transaction.\n\nYou can learn more about interactive transactions in this [section](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions).\n\nwarning\n\n**Use interactive transactions with caution**. Keeping transactions open for a long time hurts database performance and can even cause deadlocks. Try to avoid performing network requests and executing slow queries inside your transaction functions. We recommend you get in and out as quick as possible!\n\n## Conclusion[​](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#conclusion \"Direct link to Conclusion\")\n\nPrisma Client supports multiple ways of handling transactions, either directly through the API or by supporting your ability to introduce optimistic concurrency control and idempotency into your application. If you feel like you have use cases in your application that are not covered by any of the suggested options, please open a [GitHub issue](https://github.com/prisma/prisma/issues/new/choose) to start a discussion.",
  "title": "Transactions and batch queries (Reference) | Prisma Documentation",
  "description": "This page explains the transactions API of Prisma Client.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields",
  "markdown": "# Excluding fields | Prisma Documentation\n\nBy default Prisma Client returns all fields from a model. You can use `select` to narrow the result set, but that can be unwieldy if you have a large model and you only want to exclude one or two fields.\n\ninfo\n\nAs of Prisma ORM 5.16.0, excluding fields globally and locally is supported via the `omitApi` Preview feature.\n\n## Excluding a field globally using `omit`[​](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#excluding-a-field-globally-using-omit \"Direct link to excluding-a-field-globally-using-omit\")\n\nThe following is a type-safe way to exclude a field globally using the [`omitApi` Preview feature](https://www.prisma.io/docs/orm/reference/preview-features):\n\n*   Schema\n*   Code\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"omitApi\"]}model User {  id        Int      @id @default(autoincrement())  firstName String  lastName  String  email     String   @unique  password  String  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt}\n```\n\n## Excluding a field locally using `omit`[​](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#excluding-a-field-locally-using-omit \"Direct link to excluding-a-field-locally-using-omit\")\n\nThe following is a type-safe way to exclude a field locally using the `omitApi` Preview feature:\n\n*   Schema\n*   Code\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"omitApi\"]}model User {  id        Int      @id @default(autoincrement())  firstName String  lastName  String  email     String   @unique  password  String  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt}\n```\n\n## How to omit multiple fields[​](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#how-to-omit-multiple-fields \"Direct link to How to omit multiple fields\")\n\nOmitting multiple fields works the same as selecting multiple fields: add multiple key-value pairs to the omit option. Using the same schema as before, you could omit password and email with the following:\n\n```\nconst prisma = new PrismaClient()// password and email are excludedconst user = await prisma.user.findUnique({  omit: {    email: true,    password: true,  },  where: {    id: 1,  },})\n```\n\nMultiple fields can be omitted locally and globally.\n\n## How to select a previously omitted field[​](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#how-to-select-a-previously-omitted-field \"Direct link to How to select a previously omitted field\")\n\nIf you [omit a field globally](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#excluding-a-field-globally-using-omit), you can \"override\" by either selecting the field specifically or by setting `omit` to `false` in a query.\n\n*   Explicit Select\n*   Omit False\n\n```\nconst user = await prisma.user.findUnique({  select: {    firstName: true,    lastName: true,    password: true // The password field is now selected.  },  where: {    id: 1  }})\n```\n\n## When to use `omit` globally or locally[​](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#when-to-use-omit-globally-or-locally \"Direct link to when-to-use-omit-globally-or-locally\")\n\nIt's important to understand when to omit a field globally or locally:\n\n*   If you are omitting a field in order to prevent it from accidentally being included in a query, it's best to omit it globally. For example: Globally omitting the password field from a User model so that sensitive information doesn't accidentally get exposed.\n*   If you are omitting a field because it's not needed in a query, it's best to omit it locally.\n\nLocal omit (when an `omit` option is provided in a query) only applies to the query it is defined in, while a global omit applies to every query made with the same Prisma Client instance, [unless a specific select is used or the omit is overridden](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#how-to-select-a-previously-omitted-field).\n\n## Excluding the password field without using `omit`[​](https://www.prisma.io/docs/orm/prisma-client/queries/excluding-fields#excluding-the-password-field-without-using-omit \"Direct link to excluding-the-password-field-without-using-omit\")\n\nnote\n\nThe `omitApi` Preview feature, released in Prisma ORM 5.13.0, is the preferred way of omitting fields from a query result. The ability to globally omit fields was added to the `omitApi` Preview feature in Prisma ORM 5.16.0. This documentation is still relevant for versions of Prisma ORM prior to 5.13.0.\n\nThe following is a type-safe `exclude` function returns a user without the `password` field.\n\n*   TypeScript\n*   JavaScript\n\n```\n// Exclude keys from userfunction exclude<User, Key extends keyof User>(  user: User,  keys: Key[]): Omit<User, Key> {  return Object.fromEntries(    Object.entries(user).filter(([key]) => !keys.includes(key))  )}function main() {  const user = await prisma.user.findUnique({ where: 1 })  const userWithoutPassword = exclude(user, ['password'])}\n```\n\nIn the TypeScript example, we've provided two generics: `User` and `Key`. The `Key` generic is defined as the keys of a `User` (e.g. `email`, `password`, `firstName`, etc.).\n\nThese generics flow through the logic, returning a `User` that omits the list of `Key`s provided.",
  "title": "Excluding fields | Prisma Documentation",
  "description": "This page explains how to exclude sensitive fields from Prisma Client",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity",
  "markdown": "# Case sensitivity (Reference) | Prisma Documentation\n\nCase sensitivity affects **filtering** and **sorting** of data, and is determined by your [database collation](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#database-collation-and-case-sensitivity). Sorting and filtering data yields different results depending on your settings:\n\n| Action | Case sensitive | Case insensitive |\n| --- | --- | --- |\n| Sort ascending | `Apple`, `Banana`, `apple pie`, `banana pie` | `Apple`, `apple pie`, `Banana`, `banana pie` |\n| Match `\"apple\"` | `apple` | `Apple`, `apple` |\n\nIf you use a **relational database connector**, [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) respects your database collation. Options and recommendations for supporting **case-insensitive** filtering and sorting with Prisma Client depend on your [database provider](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#options-for-case-insensitive-filtering).\n\nIf you use the MongoDB connector, [Prisma Client](https://www.prisma.io/docs/orm/prisma-client/queries) uses RegEx rules to enable case-insensitive filtering. The connector _does not_ use [MongoDB collation](https://docs.mongodb.com/manual/reference/collation/).\n\n> **Note**: Follow the progress of [case-insensitive sorting on GitHub](https://github.com/prisma/prisma-client-js/issues/841).\n\n## Database collation and case sensitivity[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#database-collation-and-case-sensitivity \"Direct link to Database collation and case sensitivity\")\n\ninfo\n\nIn the context of Prisma Client, the following section refers to relational database connectors only.\n\nCollation specifies how data is **sorted and compared** in a database, which includes casing. Collation is something you choose when you set up a database.\n\nThe following example demonstrates how to view the collation of a MySQL database:\n\n```\nSELECT @@character_set_database, @@collation_database;\n```\n\nThe example collation, [`utf8mb4_0900_ai_ci`](https://dev.mysql.com/doc/refman/8.0/en/charset-collation-names.html), is:\n\n*   Accent-insensitive (`ai`)\n*   Case-insensitive (`ci`).\n\nThis means that `prisMa` will match `prisma`, `PRISMA`, `priSMA`, and so on:\n\n```\nSELECT id, email FROM User WHERE email LIKE \"%prisMa%\"\n```\n\nThe same query with Prisma Client:\n\n```\nconst users = await prisma.user.findMany({  where: {    email: {      contains: 'prisMa',    },  },  select: {    id: true,    name: true,  },})\n```\n\n## Options for case-insensitive filtering[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#options-for-case-insensitive-filtering \"Direct link to Options for case-insensitive filtering\")\n\nThe recommended way to support case-insensitive filtering with Prisma Client depends on your underlying provider.\n\n### PostgreSQL provider[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#postgresql-provider \"Direct link to PostgreSQL provider\")\n\nPostgreSQL uses [deterministic collation](https://www.postgresql.org/docs/current/collation.html#COLLATION-NONDETERMINISTIC) by default, which means that filtering is **case-sensitive**. To support case-insensitive filtering, use the `mode: 'insensitive'` property on a per-field basis.\n\nUse the `mode` property on a filter as shown:\n\n```\nconst users = await prisma.user.findMany({  where: {    email: {      endsWith: 'prisma.io',      mode: 'insensitive', // Default value: default    },  },})\n```\n\nSee also: [Filtering (Case-insensitive filtering)](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#case-insensitive-filtering)\n\n#### Caveats[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#caveats \"Direct link to Caveats\")\n\n*   You cannot use case-insensitive filtering with C collation\n*   [`citext`](https://www.postgresql.org/docs/12/citext.html) columns are always case-insensitive and are not affected by `mode`\n\n#### Performance[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#performance \"Direct link to Performance\")\n\nIf you rely heavily on case-insensitive filtering, consider [creating indexes in the PostgreSQL database](https://www.postgresql.org/docs/current/indexes.html) to improve performance:\n\n*   [Create an expression index](https://www.postgresql.org/docs/current/indexes-expressional.html) for Prisma Client queries that use `equals` or `not`\n*   Use the `pg_trgm` module to [create a trigram-based index](https://www.postgresql.org/docs/12/pgtrgm.html#id-1.11.7.40.7) for Prisma Client queries that use `startsWith`, `endsWith`, `contains` (maps to`LIKE` / `ILIKE` in PostgreSQL)\n\n### MySQL provider[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#mysql-provider \"Direct link to MySQL provider\")\n\nMySQL uses **case-insensitive collation** by default. Therefore, filtering with Prisma Client and MySQL is case-insensitive by default.\n\n`mode: 'insensitive'` property is not required and therefore not available in the generated Prisma Client API.\n\n#### Caveats[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#caveats-1 \"Direct link to Caveats\")\n\n*   You _must_ use a case-insensitive (`_ci`) collation in order to support case-insensitive filtering. Prisma Client does no support the `mode` filter property for the MySQL provider.\n\n### MongoDB provider[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#mongodb-provider \"Direct link to MongoDB provider\")\n\nTo support case-insensitive filtering, use the `mode: 'insensitive'` property on a per-field basis:\n\n```\nconst users = await prisma.user.findMany({  where: {    email: {      endsWith: 'prisma.io',      mode: 'insensitive', // Default value: default    },  },})\n```\n\nThe MongoDB uses a RegEx rule for case-insensitive filtering.\n\n### SQLite provider[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#sqlite-provider \"Direct link to SQLite provider\")\n\nBy default, text fields created by Prisma Client in SQLite databases do not support case-insensitive filtering. In SQLite, only [case-insensitive comparisons of ASCII characters](https://www.sqlite.org/faq.html#q18) are possible.\n\nTo enable limited support (ASCII only) for case-insensitive filtering on a per-column basis, you will need to add `COLLATE NOCASE` when you define a text column.\n\n#### Adding case-insensitive filtering to a new column.[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#adding-case-insensitive-filtering-to-a-new-column \"Direct link to Adding case-insensitive filtering to a new column.\")\n\nTo add case-insensitive filtering to a new column, you will need to modify the migration file that is created by Prisma Client.\n\nTaking the following Prisma Schema model:\n\n```\nmodel User {  id    Int    @id  email String}\n```\n\nand using `prisma migrate dev --create-only` to create the following migration file:\n\n```\n-- CreateTableCREATE TABLE \"User\" (    \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,    \"email\" TEXT NOT NULL);\n```\n\nYou would need to add `COLLATE NOCASE` to the `email` column in order to make case-insensitive filtering possible:\n\n```\n-- CreateTableCREATE TABLE \"User\" (    \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,    //highlight-next-line    \"email\" TEXT NOT NULL COLLATE NOCASE);\n```\n\n#### Adding case-insensitive filtering to an existing column.[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#adding-case-insensitive-filtering-to-an-existing-column \"Direct link to Adding case-insensitive filtering to an existing column.\")\n\nSince columns cannot be updated in SQLite, `COLLATE NOCASE` can only be added to an existing column by creating a blank migration file and migrating data to a new table.\n\nTaking the following Prisma Schema model:\n\n```\nmodel User {  id    Int    @id  email String}\n```\n\nand using `prisma migrate dev --create-only` to create an empty migration file, you will need to rename the current `User` table and create a new `User` table with `COLLATE NOCASE`.\n\n```\n-- UpdateTableALTER TABLE \"User\" RENAME TO \"User_old\";CREATE TABLE \"User\" (    \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,    \"email\" TEXT NOT NULL COLLATE NOCASE);INSERT INTO \"User\" (id, email)SELECT id, email FROM \"User_old\";DROP TABLE \"User_old\";\n```\n\n### Microsoft SQL Server provider[​](https://www.prisma.io/docs/orm/prisma-client/queries/case-sensitivity#microsoft-sql-server-provider \"Direct link to Microsoft SQL Server provider\")\n\nMicrosoft SQL Server uses **case-insensitive collation** by default. Therefore, filtering with Prisma Client and Microsoft SQL Server is case-insensitive by default.\n\n`mode: 'insensitive'` property is not required and therefore not available in the generated Prisma Client API.",
  "title": "Case sensitivity (Reference) | Prisma Documentation",
  "description": "How Prisma Client handles case sensitivity when filtering and sorting.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/custom-models",
  "markdown": "# Custom models | Prisma Documentation\n\nAs your application grows, you may find the need to group related logic together. We suggest either:\n\n*   Creating static methods using a [Prisma Client extension](https://www.prisma.io/docs/orm/prisma-client/client-extensions)\n*   Wrapping a model in a class\n*   Extending Prisma Client model object\n\n## Static methods with Prisma Client extensions[​](https://www.prisma.io/docs/orm/prisma-client/queries/custom-models#static-methods-with-prisma-client-extensions \"Direct link to Static methods with Prisma Client extensions\")\n\nThe following example demonstrates how to create a Prisma Client extension that adds a `signUp` and `findManyByDomain` methods to a User model.\n\n*   Prisma Client extension\n*   Prisma schema\n\n```\nimport bcrypt from 'bcryptjs'import { PrismaClient } from '@prisma/client'const prisma = new PrismaClient().$extends({  model: {    user: {      async signUp(email: string, password: string) {        const hash = await bcrypt.hash(password, 10)        return prisma.user.create({          data: {            email,            password: {              create: {                hash,              },            },          },        })      },      async findManyByDomain(domain: string) {        return prisma.user.findMany({          where: { email: { endsWith: `@${domain}` } },        })      },    },  },})async function main() {  // Example usage  await prisma.user.signUp('user2@example2.com', 's3cret')  await prisma.user.findManyByDomain('example2.com')}\n```\n\n## Wrap a model in a class[​](https://www.prisma.io/docs/orm/prisma-client/queries/custom-models#wrap-a-model-in-a-class \"Direct link to Wrap a model in a class\")\n\nIn the example below, you'll see how you can wrap the `user` model in the Prisma Client within a `Users` class.\n\n```\nimport { PrismaClient, User } from '@prisma/client'type Signup = {  email: string  firstName: string  lastName: string}class Users {  constructor(private readonly prismaUser: PrismaClient['user']) {}  // Signup a new user  async signup(data: Signup): Promise<User> {    // do some custom validation...    return this.prismaUser.create({ data })  }}async function main() {  const prisma = new PrismaClient()  const users = new Users(prisma.user)  const user = await users.signup({    email: 'alice@prisma.io',    firstName: 'Alice',    lastName: 'Prisma',  })}\n```\n\nWith this new `Users` class, you can define custom functions like `signup`:\n\nNote that in the example above, you're only exposing a `signup` method from Prisma Client. The Prisma Client is hidden within the `Users` class, so you're no longer be able to call methods like `findMany` and `upsert`.\n\nThis approach works well when you have a large application and you want to intentionally limit what your models can do.\n\n## Extending Prisma Client model object[​](https://www.prisma.io/docs/orm/prisma-client/queries/custom-models#extending-prisma-client-model-object \"Direct link to Extending Prisma Client model object\")\n\nBut what if you don't want to hide existing functionality but still want to group custom functions together? In this case, you can use `Object.assign` to extend Prisma Client without limiting its functionality:\n\n```\nimport { PrismaClient, User } from '@prisma/client'type Signup = {  email: string  firstName: string  lastName: string}function Users(prismaUser: PrismaClient['user']) {  return Object.assign(prismaUser, {    /**     * Signup the first user and create a new team of one. Return the User with     * a full name and without a password     */    async signup(data: Signup): Promise<User> {      return prismaUser.create({ data })    },  })}async function main() {  const prisma = new PrismaClient()  const users = Users(prisma.user)  const user = await users.signup({    email: 'alice@prisma.io',    firstName: 'Alice',    lastName: 'Prisma',  })  const numUsers = await users.count()  console.log(user, numUsers)}\n```\n\nNow you can use your custom `signup` method alongside `count`, `updateMany`, `groupBy()` and all of the other wonderful methods that Prisma Client provides. Best of all, it's all type-safe!\n\n## Going further[​](https://www.prisma.io/docs/orm/prisma-client/queries/custom-models#going-further \"Direct link to Going further\")\n\nWe recommend using [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) to extend your models with [custom model methods](https://github.com/prisma/prisma-client-extensions/tree/main/instance-methods).",
  "title": "Custom models | Prisma Documentation",
  "description": "This page explains how to wrap Prisma Client in custom models",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access",
  "markdown": "# Raw database access | Prisma Documentation\n\nWhile Prisma ORM aims to make all your database queries intuitive, type-safe, and convenient, there may be situations where you need to drop down to raw queries.\n\nThis may happen for several reasons, e.g., because you need to optimize the performance of a specific query or because your data requirements can't be expressed by Prisma Client's query API.\n\nIn that case, you can use one of Prisma Client's escape hatches, such as `$queryRaw` or `$executeRaw`, to send raw queries to the database.\n\nWhen using relational databases, you can use **community tools** that can still vastly improve the developer experience writing raw SQL, e.g., by enabling type safety or providing auto-completion for your SQL queries:\n\n*   [`prisma-extension-kysely`](https://github.com/eoin-obrien/prisma-extension-kysely): A Client extension that uses the [Kysely](https://kysely.dev/) SQL query builder API to compose SQL queries in TypeScript, with auto-completion and type safety, and submits them through Prisma Client's connection pool.\n*   [SafeQL](https://safeql.dev/compatibility/prisma.html): An ESLint plugin enabling syntax highlighting and type safety for SQL strings inside Prisma ORM's raw SQL escape hatches. For a tutorial on using SafeQL, visit this [page](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries).\n\n## In this section[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access#in-this-section \"Direct link to In this section\")\n\n[\n\n## Raw queries\n\n](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries)\n\n[\n\n## Custom & type-safe queries\n\n](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries)",
  "title": "Raw database access | Prisma Documentation",
  "description": "Raw database access with Prisma Client.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance",
  "markdown": "# Query optimization | Prisma Documentation\n\nThis guide describes ways to optimize query performance, debug performance issues, and how to tackle common performance issues such as the [n+1 problem](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-the-n1-problem).\n\n## Debugging performance issues[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#debugging-performance-issues \"Direct link to Debugging performance issues\")\n\nTo help you debug and diagnose performance issues, you can [log query events at client level](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging#event-based-logging), which allows you to see the generated queries, parameters, and durations.\n\nAlternatively, if you are only interested in the time taken to run a query, you can implement [logging middleware](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/logging-middleware).\n\n## Solving the n+1 problem[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-the-n1-problem \"Direct link to Solving the n+1 problem\")\n\nThe n+1 problem occurs when you loop through the results of a query and perform one additional query **per result**, resulting in `n` number of queries plus the original (n+1). This is a common problem with ORMs, particularly in combination with GraphQL, because it is not always immediately obvious that your code is generating inefficient queries.\n\n### Solving n+1 in GraphQL with `findUnique()` and Prisma Client's dataloader[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-n1-in-graphql-with-findunique-and-prisma-clients-dataloader \"Direct link to solving-n1-in-graphql-with-findunique-and-prisma-clients-dataloader\")\n\nThe Prisma Client dataloader automatically _batches_ `findUnique()` queries that occur in the same [tick](https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick#processnexttick) and have the same `where` and `include` parameters if:\n\n*   All criteria of the `where` filter are on scalar fields (unique or non-unique) of the same model you're querying.\n*   All criteria use the `equal` filter, whether that's via the shorthand or explicit syntax `(where: { field: <val>, field1: { equals: <val> } })`.\n*   No boolean operators or relation filters are present.\n\nAutomatic batching of `findUnique()` is particularly useful in a **GraphQL context**. GraphQL runs a separate resolver function for every field, which can make it difficult to optimize a nested query.\n\nFor example - the following GraphQL runs the `allUsers` resolver to get all users, and the `posts` resolver **once per user** to get each user's posts (n+1):\n\n```\nquery {  allUsers {    id,    posts {      id    }  }}\n```\n\nThe `allUsers` query uses `user.findMany(..)` to return all users:\n\n```\nconst Query = objectType({  name: 'Query',  definition(t) {    t.nonNull.list.nonNull.field('allUsers', {      type: 'User',      resolve: (_parent, _args, context) => {        return context.prisma.user.findMany()      },    })  },})\n```\n\nThis results in a single SQL query:\n\n```\n{  timestamp: 2021-02-19T09:43:06.332Z,  query: 'SELECT `dev`.`User`.`id`, `dev`.`User`.`email`, `dev`.`User`.`name` FROM `dev`.`User` WHERE 1=1 LIMIT ? OFFSET ?',  params: '[-1,0]',  duration: 0,  target: 'quaint::connector::metrics'}\n```\n\nHowever, the resolver function for `posts` is then invoked **once per user**. This results in a `findMany()` query **✘ per user** rather than a single `findMany()` to return all posts by all users (expand CLI output to see queries).\n\n```\nconst User = objectType({  name: 'User',  definition(t) {    t.nonNull.int('id')    t.string('name')    t.nonNull.string('email')    t.nonNull.list.nonNull.field('posts', {      type: 'Post',      resolve: (parent, _, context) => {        return context.prisma.post.findMany({          where: { authorId: parent.id || undefined },        })      },    })  },})\n```\n\nInstead, use `findUnique()` in combination with [the fluent API](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api) (`.posts()`) as shown to return a user's posts. Even though the resolver is called once per user, the Prisma dataloader in Prisma Client **✔ batches the `findUnique()` queries**.\n\n```\nconst User = objectType({  name: 'User',  definition(t) {    t.nonNull.int('id')    t.string('name')    t.nonNull.string('email')    t.nonNull.list.nonNull.field('posts', {      type: 'Post',      resolve: (parent, _, context) => {        return context.prisma.post.findMany({          where: { authorId: parent.id || undefined },        })        return context.prisma.user          .findUnique({            where: { id: parent.id || undefined },          })          .posts()      },    })  },})\n```\n\nIf the `posts` resolver is invoked once per user, the dataloader in Prisma Client groups `findUnique()` queries with the same parameters and selection set. Each group is optimized into a single `findMany()`.\n\n#### Do I have to use the fluent API to enable batching of queries?[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#do-i-have-to-use-the-fluent-api-to-enable-batching-of-queries \"Direct link to Do I have to use the fluent API to enable batching of queries?\")\n\nIt may seem counterintitive to use a `prisma.user.findUnique(...).posts()` query to return posts instead of `prisma.posts.findMany()` - particularly as the former results in two queries rather than one.\n\nThe **only** reason you need to use the fluent API (`user.findUnique(...).posts()`) to return posts is that the dataloader in Prisma Client batches `findUnique()` queries and does not currently [batch `findMany()` queries](https://github.com/prisma/prisma/issues/1477).\n\nWhen the dataloader batches `findMany()` queries, you no longer need to use `findUnique()` with the fluent API in this way.\n\n### n+1 in other contexts[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#n1-in-other-contexts \"Direct link to n+1 in other contexts\")\n\nThe n+1 problem is most commonly seen in a GraphQL context because you have to find a way to optimize a single query across multiple resolvers. However, you can just as easily introduce the n+1 problem by looping through results with `forEach` in your own code.\n\nThe following code results in n+1 queries - one `findMany()` to get all users, and one `findMany()` **per user** to get each user's posts:\n\n```\n// One query to get all usersconst users = await prisma.user.findMany({})// One query PER USER to get all postsusers.forEach(async (usr) => {  const posts = await prisma.post.findMany({    where: {      authorId: usr.id,    },  })  // Do something with each users' posts})\n```\n\nThis is not an efficient way to query. Instead, you can:\n\n*   Use nested reads ([`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include) ) to return users and related posts\n*   Use the [`in`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#in) filter\n\n#### Solving n+1 with `include`[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-n1-with-include \"Direct link to solving-n1-with-include\")\n\nYou can use `include` to return each user's posts. This only results in **two** SQL queries - one to get users, and one to get posts. This is known as a [nested read](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads).\n\n```\nconst usersWithPosts = await prisma.user.findMany({  include: {    posts: true,  },})\n```\n\n#### Solving n+1 with `in`[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#solving-n1-with-in \"Direct link to solving-n1-with-in\")\n\nIf you have a list of user IDs, you can use the `in` filter to return all posts where the `authorId` is `in` that list of IDs:\n\n```\nconst users = await prisma.user.findMany({})const userIds = users.map((x) => x.id)const posts = await prisma.post.findMany({  where: {    authorId: {      in: userIds,    },  },})\n```\n\n## Using bulk queries[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#using-bulk-queries \"Direct link to Using bulk queries\")\n\nIt is generally more performant to read and write large amounts of data in bulk - for example, inserting 50,000 records in batches of 1000 rather than as 50,000 separate inserts. Prisma Client supports the following bulk queries:\n\n*   [`createMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany)\n*   [`createManyAndReturn()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmanyandreturn)\n*   [`deleteMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#deletemany)\n*   [`updateMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#updatemany)\n*   [`findMany()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findmany)\n\n## Using `select` to limit number of columns returned[​](https://www.prisma.io/docs/orm/prisma-client/queries/query-optimization-performance#using-select-to-limit-number-of-columns-returned \"Direct link to using-select-to-limit-number-of-columns-returned\")\n\nUsing `select` to limit the number of columns that are returned is **unlikely to have an effect on performance** unless you have identified this as a performance bottleneck through testing. For example, reading all fields may negatively affect performance if you have:\n\n*   Tables with a large number of columns\n*   Large columns that are stored in a separate location on disk rather than a row, which results in an additional disk read\n\nFurthermore, if you have a mature product with well-established query patterns and finely tuned indexes, selecting a specific subset of fields may be beneficial as it avoids reading data from disk. However, in most cases, this level of performance tuning is only necessary at a certain scale.",
  "title": "Query optimization | Prisma Documentation",
  "description": "How Prisma optimizes queries under the hood",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries",
  "markdown": "# Raw queries | Prisma Documentation\n\nPrisma Client supports the option of sending raw queries to your database. You may wish to use raw queries if:\n\n*   you want to run a heavily optimized query\n*   you require a feature that Prisma Client does not yet support (please [consider raising an issue](https://github.com/prisma/prisma/issues/new/choose))\n\nRaw queries are available for all relational databases Prisma ORM supports. In addition, from version `3.9.0` raw queries are supported in MongoDB. For more details, see the relevant sections:\n\n*   [Raw queries with relational databases](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-queries-with-relational-databases)\n*   [Raw queries with MongoDB](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-queries-with-mongodb)\n\n## Raw queries with relational databases[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-queries-with-relational-databases \"Direct link to Raw queries with relational databases\")\n\nFor relational databases, Prisma Client exposes four methods that allow you to send raw queries. You can use:\n\n*   `$queryRaw` to return actual records (for example, using `SELECT`).\n*   `$executeRaw` to return a count of affected rows (for example, after an `UPDATE` or `DELETE`).\n*   `$queryRawUnsafe` to return actual records (for example, using `SELECT`) using a raw string.\n*   `$executeRawUnsafe` to return a count of affected rows (for example, after an `UPDATE` or `DELETE`) using a raw string.\n\nThe methods with \"Unsafe\" in the name are a lot more flexible but are at **significant risk of making your code vulnerable to SQL injection**.\n\nThe other two methods are safe to use with a simple template tag, no string building, and no concatenation. **However**, caution is required for more complex use cases as it is still possible to introduce SQL injection if these methods are used in certain ways. For more details, see the [SQL injection prevention](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#sql-injection-prevention) section below.\n\n> **Note**: All methods in the above list can only run **one** query at a time. You cannot append a second query - for example, calling any of them with `select 1; select 2;` will not work.\n\n### `$queryRaw`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#queryraw \"Direct link to queryraw\")\n\n`$queryRaw` returns actual database records. For example, the following `SELECT` query returns all fields for each record in the `User` table:\n\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User`\n```\n\nThe method is implemented as a [tagged template](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates), which allows you to pass a template literal where you can easily insert your [variables](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#using-variables). In turn, Prisma Client creates prepared statements that are safe from SQL injections:\n\n```\nconst email = 'emelie@prisma.io'const result = await prisma.$queryRaw`SELECT * FROM User WHERE email = ${email}`\n```\n\nYou can also use the [`Prisma.sql`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#tagged-template-helpers) helper, in fact, the `$queryRaw` method will **only accept** a template string or the `Prisma.sql` helper:\n\n```\nconst email = 'emelie@prisma.io'const result = await prisma.$queryRaw(  Prisma.sql`SELECT * FROM User WHERE email = ${email}`)\n```\n\nwarning\n\nIf you use string building to incorporate untrusted input into queries passed to this method, then you open up the possibility for SQL injection attacks. SQL injection attacks can expose your data to modification or deletion. The prefered mechanism would be to include the text of the query at the point that you run this method. For more information on this risk and also examples of how to prevent it, see the [SQL injection prevention](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#sql-injection-prevention) section below.\n\n#### Considerations[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#considerations \"Direct link to Considerations\")\n\nBe aware that:\n\n*   Template variables cannot be used inside SQL string literals. For example, the following query would **not** work:\n    \n    ```\n    const name = 'Bob'await prisma.$queryRaw`SELECT 'My name is ${name}';`\n    ```\n    \n    Instead, you can either pass the whole string as a variable, or use string concatenation:\n    \n    ```\n    const name = 'My name is Bob'await prisma.$queryRaw`SELECT ${name};`\n    ```\n    \n    ```\n    const name = 'Bob'await prisma.$queryRaw`SELECT 'My name is ' || ${name};`\n    ```\n    \n*   Template variables can only be used for data values (such as `email` in the example above). Variables cannot be used for identifiers such as column names, table names or database names, or for SQL keywords. For example, the following two queries would **not** work:\n    \n    ```\n    const myTable = 'user'await prisma.$queryRaw`SELECT * FROM ${myTable};`\n    ```\n    \n    ```\n    const ordering = 'desc'await prisma.$queryRaw`SELECT * FROM Table ORDER BY ${ordering};`\n    ```\n    \n*   Prisma maps any database values returned by `$queryRaw` and `$queryRawUnsafe` to their corresponding JavaScript types. [Learn more](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-type-mapping).\n    \n*   `$queryRaw` does not support dynamic table names in PostgreSQL databases. [Learn more](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#dynamic-table-names-in-postgresql)\n    \n\n#### Return type[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#return-type \"Direct link to Return type\")\n\n`$queryRaw` returns an array. Each object corresponds to a database record:\n\n```\n[  { id: 1, email: 'emelie@prisma.io', name: 'Emelie' },  { id: 2, email: 'yin@prisma.io', name: 'Yin' },]\n```\n\nYou can also [type the results of `$queryRaw`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#typing-queryraw-results).\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature \"Direct link to Signature\")\n\n```\n$queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;\n```\n\n#### Typing `$queryRaw` results[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#typing-queryraw-results \"Direct link to typing-queryraw-results\")\n\n`PrismaPromise<T>` uses a [generic type parameter `T`](https://www.typescriptlang.org/docs/handbook/generics.html). You can determine the type of `T` when you invoke the `$queryRaw` method. In the following example, `$queryRaw` returns `User[]`:\n\n```\n// import the generated `User` type from the `@prisma/client` moduleimport { User } from '@prisma/client'const result = await prisma.$queryRaw<User[]>`SELECT * FROM User`// result is of type: `User[]`\n```\n\n> **Note**: If you do not provide a type, `$queryRaw` defaults to `unknown`.\n\nIf you are selecting **specific fields** of the model or want to include relations, refer to the documentation about [leveraging Prisma Client's generated types](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types#problem-using-variations-of-the-generated-model-type) if you want to make sure that the results are properly typed.\n\n#### Type caveats when using raw SQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#type-caveats-when-using-raw-sql \"Direct link to Type caveats when using raw SQL\")\n\nWhen you type the results of `$queryRaw`, the raw data might not always match the suggested TypeScript type. For example, the following Prisma model includes a `Boolean` field named `published`:\n\n```\nmodel Post {  id        Int     @id @default(autoincrement())  published Boolean @default(false)  title     String  content   String?}\n```\n\nThe following query returns all posts. It then prints out the value of the `published` field for each `Post`:\n\n```\nconst result = await prisma.$queryRaw<Post[]>`SELECT * FROM Post`result.forEach((x) => {  console.log(x.published)})\n```\n\nFor regular CRUD queries, the Prisma Client query engine standardizes the return type for all databases. **Using the raw queries does not**. If the database provider is MySQL, the returned values are `1` or `0`. However, if the database provider is PostgreSQL, the values are `true` or `false`.\n\n> **Note**: Prisma sends JavaScript integers to PostgreSQL as `INT8`. This might conflict with your user-defined functions that accept only `INT4` as input. If you use `$queryRaw` in conjunction with a PostgreSQL database, update the input types to `INT8`, or cast your query parameters to `INT4`.\n\n#### Dynamic table names in PostgreSQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#dynamic-table-names-in-postgresql \"Direct link to Dynamic table names in PostgreSQL\")\n\n[It is not possible to interpolate table names](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#considerations). This means that you cannot use dynamic table names with `$queryRaw`. Instead, you must use [`$queryRawUnsafe`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#queryrawunsafe), as follows:\n\n```\nlet userTable = 'User'let result = await prisma.$queryRawUnsafe(`SELECT * FROM ${userTable}`)\n```\n\nNote that if you use `$queryRawUnsafe` in conjunction with user inputs, you risk SQL injection attacks. [Learn more](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#queryrawunsafe).\n\n### `$queryRawUnsafe()`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#queryrawunsafe \"Direct link to queryrawunsafe\")\n\nThe `$queryRawUnsafe()` method allows you to pass a raw string (or template string) to the database.\n\nwarning\n\nIf you use this method with user inputs (in other words, `SELECT * FROM table WHERE columnx = ${userInput}`), then you open up the possibility for SQL injection attacks. SQL injection attacks can expose your data to modification or deletion.\n\nWherever possible you should use the `$queryRaw` method instead. When used correctly `$queryRaw` method is significantly safer but note that the `$queryRaw` method can also be made vulnerable in certain circumstances. For more information, see the [SQL injection prevention](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#sql-injection-prevention) section below.\n\nThe following query returns all fields for each record in the `User` table:\n\n```\n// import the generated `User` type from the `@prisma/client` moduleimport { User } from '@prisma/client'const result = await prisma.$queryRawUnsafe('SELECT * FROM User')\n```\n\nYou can also run a parameterized query. The following example returns all users whose email contains the string `emelie@prisma.io`:\n\n```\nprisma.$queryRawUnsafe(  'SELECT * FROM users WHERE email = $1',  'emelie@prisma.io')\n```\n\n> **Note**: Prisma sends JavaScript integers to PostgreSQL as `INT8`. This might conflict with your user-defined functions that accept only `INT4` as input. If you use a parameterized `$queryRawUnsafe` query in conjunction with a PostgreSQL database, update the input types to `INT8`, or cast your query parameters to `INT4`.\n\nFor more details on using parameterized queries, see the [parameterized queries](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#parameterized-queries) section below.\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature-1 \"Direct link to Signature\")\n\n```\n$queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\n```\n\n### `$executeRaw`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#executeraw \"Direct link to executeraw\")\n\n`$executeRaw` returns the _number of rows affected by a database operation_, such as `UPDATE` or `DELETE`. This function does **not** return database records. The following query updates records in the database and returns a count of the number of records that were updated:\n\n```\nconst result: number =  await prisma.$executeRaw`UPDATE User SET active = true WHERE emailValidated = true`\n```\n\nThe method is implemented as a [tagged template](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates), which allows you to pass a template literal where you can easily insert your [variables](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#using-variables). In turn, Prisma Client creates prepared statements that are safe from SQL injections:\n\n```\nconst emailValidated = trueconst active = trueconst result: number =  await prisma.$executeRaw`UPDATE User SET active = ${active} WHERE emailValidated = ${emailValidated};`\n```\n\nwarning\n\nIf you use string building to incorporate untrusted input into queries passed to this method, then you open up the possibility for SQL injection attacks. SQL injection attacks can expose your data to modification or deletion. The prefered mechanism would be to include the text of the query at the point that you run this method. For more information on this risk and also examples of how to prevent it, see the [SQL injection prevention](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#sql-injection-prevention) section below.\n\n#### Considerations[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#considerations-1 \"Direct link to Considerations\")\n\nBe aware that:\n\n*   `$executeRaw` does not support multiple queries in a single string (for example, `ALTER TABLE` and `CREATE TABLE` together).\n    \n*   Prisma Client submits prepared statements, and prepared statements only allow a subset of SQL statements. For example, `START TRANSACTION` is not permitted. You can learn more about [the syntax that MySQL allows in Prepared Statements here](https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html).\n    \n*   [`PREPARE` does not support `ALTER`](https://www.postgresql.org/docs/current/sql-prepare.html) - see the [workaround](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#alter-limitation-postgresql).\n    \n*   Template variables cannot be used inside SQL string literals. For example, the following query would **not** work:\n    \n    ```\n    const name = 'Bob'await prisma.$queryRaw`UPDATE user SET greeting = 'My name is ${name}';`\n    ```\n    \n    Instead, you can either pass the whole string as a variable, or use string concatenation:\n    \n    ```\n    const name = 'My name is Bob'await prisma.$queryRaw`UPDATE user SET greeting = ${name};`\n    ```\n    \n    ```\n    const name = 'Bob'await prisma.$queryRaw`UPDATE user SET greeting = 'My name is ' || ${name};`\n    ```\n    \n*   Template variables can only be used for data values (such as `email` in the example above). Variables cannot be used for identifiers such as column names, table names or database names, or for SQL keywords. For example, the following two queries would **not** work:\n    \n    ```\n    const myTable = 'user'await prisma.$queryRaw`UPDATE ${myTable} SET active = true;`\n    ```\n    \n    ```\n    const ordering = 'desc'await prisma.$queryRaw`UPDATE User SET active = true ORDER BY ${desc};`\n    ```\n    \n\n#### Return type[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#return-type-1 \"Direct link to Return type\")\n\n`$executeRaw` returns a `number`.\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature-2 \"Direct link to Signature\")\n\n```\n$executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;\n```\n\n### `$executeRawUnsafe()`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#executerawunsafe \"Direct link to executerawunsafe\")\n\nThe `$executeRawUnsafe()` method allows you to pass a raw string (or template string) to the database. Like `$executeRaw`, it does **not** return database records, but returns the number of rows affected.\n\nwarning\n\nIf you use this method with user inputs (in other words, `SELECT * FROM table WHERE columnx = ${userInput}`), then you open up the possibility for SQL injection attacks. SQL injection attacks can expose your data to modification or deletion.\n\nWherever possible you should use the `$executeRaw` method instead. When used correctly `$executeRaw` method is significantly safer but note that the `$executeRaw` method can also be made vulnerable in certain circumstances. For more information, see the [SQL injection prevention](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#sql-injection-prevention) section below.\n\nThe following example uses a template string to update records in the database. It then returns a count of the number of records that were updated:\n\n```\nconst emailValidated = trueconst active = trueconst result = await prisma.$executeRawUnsafe(  `UPDATE User SET active = ${active} WHERE emailValidated = ${emailValidated}`)\n```\n\nThe same can be written as a parameterized query:\n\n```\nconst result = prisma.$executeRawUnsafe(  'UPDATE User SET active = $1 WHERE emailValidated = $2',  'yin@prisma.io',  true)\n```\n\nFor more details on using parameterized queries, see the [parameterized queries](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#parameterized-queries) section below.\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature-3 \"Direct link to Signature\")\n\n```\n$executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;\n```\n\n### Raw query type mapping[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-type-mapping \"Direct link to Raw query type mapping\")\n\nPrisma maps any database values returned by `$queryRaw` and `$queryRawUnsafe`to their corresponding [JavaScript types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures). This behavior is the same as for regular Prisma query methods like `findMany()`.\n\ninfo\n\n**Feature availability:**\n\n*   In v3.14.x and v3.15.x, raw query type mapping was available with the preview feature `improvedQueryRaw`. We made raw query type mapping [Generally Available](https://www.prisma.io/docs/orm/more/releases#generally-available-ga) in version 4.0.0, so you do not need to use `improvedQueryRaw` in version 4.0.0 or later.\n*   Before version 4.0.0, raw query type mapping was not available for SQLite.\n\nAs an example, take a raw query that selects columns with `BigInt`, `Bytes`, `Decimal` and `Date` types from a table:\n\n```\nconst result =  await prisma.$queryRaw`SELECT bigint, bytes, decimal, date FROM \"Table\";`console.log(result)\n```\n\nIn the `result` object, the database values have been mapped to the corresponding JavaScript types.\n\nThe following table shows the conversion between types used in the database and the JavaScript type returned by the raw query:\n\n| Database type | JavaScript type |\n| --- | --- |\n| Text | `String` |\n| 32-bit integer | `Number` |\n| Floating point number | `Number` |\n| Double precision number | `Number` |\n| 64-bit integer | `BigInt` |\n| Decimal / numeric | `Decimal` |\n| Bytes | `Buffer` |\n| Json | `Object` |\n| DateTime | `Date` |\n| Date | `Date` |\n| Time | `Date` |\n| Uuid | `String` |\n| Xml | `String` |\n\nNote that the exact name for each database type will vary between databases – for example, the boolean type is known as `boolean` in PostgreSQL and `STRING` in CockroachDB. See the [Scalar types reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) for full details of type names for each database.\n\n### Raw query typecasting behavior[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-typecasting-behavior \"Direct link to Raw query typecasting behavior\")\n\nRaw queries with Prisma Client might require parameters to be in the expected types of the SQL function or query. Prisma Client does not do subtle, implicit casts.\n\nAs an example, take the following query using PostgreSQL's `LENGTH` function, which only accepts the `text` type as an input:\n\n```\nawait prisma.$queryRaw`SELECT LENGTH(${42});`\n```\n\nThis query returns an error:\n\n```\n// ERROR: function length(integer) does not exist// HINT: No function matches the given name and argument types. You might need to add explicit type casts.\n```\n\nThe solution in this case is to explicitly cast `42` to the `text` type:\n\n```\nawait prisma.$queryRaw`SELECT LENGTH(${42}::text);`\n```\n\ninfo\n\n**Feature availability:** This funtionality is [Generally Available](https://www.prisma.io/docs/orm/more/releases#generally-available-ga) since version 4.0.0. In v3.14.x and v3.15.x, it was available with the preview feature `improvedQueryRaw`.\n\nFor the example above before version 4.0.0, Prisma ORM silently coerces `42` to `text` and does not require the explicit cast.\n\nOn the other hand the following raw query now works correctly, returning an integer result, and failed before:\n\n```\nawait prisma.$queryRaw`SELECT ${1.5}::int as int`// Now: [{ int: 2 }]// Before: db error: ERROR: incorrect binary data format in bind parameter 1\n```\n\n### Transactions[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#transactions \"Direct link to Transactions\")\n\nIn 2.10.0 and later, you can use `.$executeRaw()` and `.$queryRaw()` inside a [transaction](https://www.prisma.io/docs/orm/prisma-client/queries/transactions).\n\n### Using variables[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#using-variables \"Direct link to Using variables\")\n\n`$executeRaw` and `$queryRaw` are implemented as [**tagged templates**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates). Tagged templates are the recommended way to use variables with raw SQL in the Prisma Client.\n\nThe following example includes a placeholder named `${userId}`:\n\n```\nconst userId = 42const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${userId};`\n```\n\n✔ Benefits of using the tagged template versions of `$queryRaw` and `$executeRaw` include:\n\n*   Prisma Client escapes all variables.\n*   Tagged templates are database-agnostic - you do not need to remember if variables should be written as `$1` (PostgreSQL) or `?` (MySQL).\n*   [SQL Template Tag](https://github.com/blakeembrey/sql-template-tag) give you access to [useful helpers](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#tagged-template-helpers).\n*   Embedded, named variables are easier to read.\n\n> **Note**: You cannot pass a table or column name into a tagged template placeholder. For example, you cannot `SELECT ?` and pass in `*` or `id, name` based on some condition.\n\n#### Tagged template helpers[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#tagged-template-helpers \"Direct link to Tagged template helpers\")\n\nPrisma Client specifically uses [SQL Template Tag](https://github.com/blakeembrey/sql-template-tag), which exposes a number of helpers. For example, the following query uses `join()` to pass in a list of IDs:\n\n```\nimport { Prisma } from '@prisma/client'const ids = [1, 3, 5, 10, 20]const result =  await prisma.$queryRaw`SELECT * FROM User WHERE id IN (${Prisma.join(ids)})`\n```\n\nThe following example uses the `empty` and `sql` helpers to change the query depending on whether `userName` is empty:\n\n```\nimport { Prisma } from '@prisma/client'const userName = ''const result = await prisma.$queryRaw`SELECT * FROM User ${  userName ? Prisma.sql`WHERE name = ${userName}` : Prisma.empty // Cannot use \"\" or NULL here!}`\n```\n\n#### `ALTER` limitation (PostgreSQL)[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#alter-limitation-postgresql \"Direct link to alter-limitation-postgresql\")\n\nPostgreSQL [does not support using `ALTER` in a prepared statement](https://www.postgresql.org/docs/current/sql-prepare.html), which means that the following queries **will not work**:\n\n```\nawait prisma.$executeRaw`ALTER USER prisma WITH PASSWORD \"${password}\"`await prisma.$executeRaw(  Prisma.sql`ALTER USER prisma WITH PASSWORD \"${password}\"`)\n```\n\nYou can use the following query, but be aware that this is potentially **unsafe** as `${password}` is not escaped:\n\n```\nawait prisma.$executeRawUnsafe('ALTER USER prisma WITH PASSWORD \"$1\"', password})\n```\n\n### Unsupported types[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#unsupported-types \"Direct link to Unsupported types\")\n\n[`Unsupported` types](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unsupported) need to be cast to Prisma Client supported types before using them in `$queryRaw` or `$queryRawUnsafe`. For example, take the following model, which has a `location` field with an `Unsupported` type:\n\n```\nmodel Country {  location  Unsupported(\"point\")?}\n```\n\nThe following query on the unsupported field will **not** work:\n\n```\nawait prisma.$queryRaw`SELECT location FROM Country;`\n```\n\nInstead, cast `Unsupported` fields to any supported Prisma Client type, **if your `Unsupported` column supports the cast**.\n\nThe most common type you may want to cast your `Unsupported` column to is `String`. For example, on PostgreSQL, this would map to the `text` type:\n\n```\nawait prisma.$queryRaw`SELECT location::text FROM Country;`\n```\n\nThe database will thus provide a `String` representation of your data which Prisma Client supports.\n\nFor details of supported Prisma types, see the [Prisma connector overview](https://www.prisma.io/docs/orm/overview/databases) for the relevant database.\n\n## SQL injection prevention[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#sql-injection-prevention \"Direct link to SQL injection prevention\")\n\nThe ideal way to avoid SQL injection in Prisma Client is to use the ORM models to perform queries wherever possible.\n\nWhere this is not possible and raw queries are required, Prisma Client provides various raw methods, but it is important to use these methods safely.\n\nThis section will provide various examples of using these methods safely and unsafely. You can test these examples in the [Prisma Playground](https://playground.prisma.io/examples).\n\n### In `$queryRaw` and `$executeRaw`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#in-queryraw-and-executeraw \"Direct link to in-queryraw-and-executeraw\")\n\n#### Simple, safe use of `$queryRaw` and `$executeRaw`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#simple-safe-use-of-queryraw-and-executeraw \"Direct link to simple-safe-use-of-queryraw-and-executeraw\")\n\nThese methods can mitigate the risk of SQL injection by escaping all variables when you use tagged templates and sends all queries as prepared statements.\n\n```\n$queryRaw`...` // Tagged template$executeRaw`...` // Tagged template\n```\n\nThe following example is safe ✅ from SQL Injection:\n\n```\nconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`const result =  await prisma.$queryRaw`SELECT id, name FROM \"User\" WHERE name = ${inputString}`console.log(result)\n```\n\n#### Unsafe use of `$queryRaw` and `$executeRaw`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#unsafe-use-of-queryraw-and-executeraw \"Direct link to unsafe-use-of-queryraw-and-executeraw\")\n\nHowever, it is also possible to use these methods in unsafe ways.\n\nOne way is by artificially generating a tagged template that unsafely concatenates user input.\n\nThe following example is vulnerable ❌ to SQL Injection:\n\n```\n// Unsafely generate query textconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"` // SQL Injectionconst query = `SELECT id, name FROM \"User\" WHERE name = ${inputString}`// Version for Typescriptconst stringsArray: any = [...[query]]// Version for Javascriptconst stringsArray = [...[query]]// Use the `raw` property to impersonate a tagged templatestringsArray.raw = [query]// Use queryRawconst result = await prisma.$queryRaw(stringsArray)console.log(result)\n```\n\nAnother way to make these methods vulnerable is misuse of the `Prisma.raw` function.\n\nThe following examples are all vulnerable ❌ to SQL Injection:\n\n```\nconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`const result =  await prisma.$queryRaw`SELECT id, name FROM \"User\" WHERE name = ${Prisma.raw(    inputString  )}`console.log(result)\n```\n\n```\nconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`const result = await prisma.$queryRaw(  Prisma.raw(`SELECT id, name FROM \"User\" WHERE name = ${inputString}`))console.log(result)\n```\n\n```\nconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`const query = Prisma.raw(  `SELECT id, name FROM \"User\" WHERE name = ${inputString}`)const result = await prisma.$queryRaw(query)console.log(result)\n```\n\n#### Safely using `$queryRaw` and `$executeRaw` in more complex scenarios[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#safely-using-queryraw-and-executeraw-in-more-complex-scenarios \"Direct link to safely-using-queryraw-and-executeraw-in-more-complex-scenarios\")\n\n##### Building raw queries separate to query execution[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#building-raw-queries-separate-to-query-execution \"Direct link to Building raw queries separate to query execution\")\n\nIf you want to build your raw queries elsewhere or separate to your parameters you will need to use one of the following methods.\n\nIn this example, the `sql` helper method is used to build the query text by safely including the variable. It is safe ✅ from SQL Injection:\n\n```\n// inputString can be untrusted inputconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`// Safe if the text query below is completely trusted contentconst query = Prisma.sql`SELECT id, name FROM \"User\" WHERE name = ${inputString}`const result = await prisma.$queryRaw(query)console.log(result)\n```\n\nIn this example which is safe ✅ from SQL Injection, the `sql` helper method is used to build the query text including a parameter marker for the input value. Each variable is represented by a marker symbol (`?` for MySQL, `$1`, `$2`, and so on for PostgreSQL). Note that the examples just show PostgreSQL queries.\n\n```\n// Version for Typescriptconst query: any// Version for Javascriptconst query// Safe if the text query below is completely trusted contentquery = Prisma.sql`SELECT id, name FROM \"User\" WHERE name = $1`// inputString can be untrusted inputconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`query.values = [inputString]const result = await prisma.$queryRaw(query)console.log(result)\n```\n\n> **Note**: PostgreSQL variables are represented by `$1`, etc\n\n##### Building raw queries elsewhere or in stages[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#building-raw-queries-elsewhere-or-in-stages \"Direct link to Building raw queries elsewhere or in stages\")\n\nIf you want to build your raw queries somewhere other than where the query is executed, the ideal way to do this is to create an `Sql` object from the segments of your query and pass it the parameter value.\n\nIn the following example we have two variables to parameterize. The example is safe ✅ from SQL Injection as long as the query strings being passed to `Prisma.sql` only contain trusted content:\n\n```\n// Example is safe if the text query below is completely trusted contentconst query1 = `SELECT id, name FROM \"User\" WHERE name = ` // The first parameter would be inserted after this stringconst query2 = ` OR name = ` // The second parameter would be inserted after this stringconst inputString1 = \"Fred\"const inputString2 = `'Sarah' UNION SELECT id, title FROM \"Post\"`const query = Prisma.sql([query1, query2, \"\"], inputString1, inputString2)const result = await prisma.$queryRaw(query);console.log(result);\n```\n\n> Note: Notice that the string array being passed as the first parameter `Prisma.sql` needs to have an empty string at the end as the `sql` function expects one more query segment than the number of parameters.\n\nIf you want to build your raw queries into one large string, this is still possible but requires some care as it is uses the potentially dangerous `Prisma.raw` method. You also need to build your query using the correct parameter markers for your database as Prisma won't be able to provide markers for the relevant database as it usually is.\n\nThe following example is safe ✅ from SQL Injection as long as the query strings being passed to `Prisma.raw` only contain trusted content:\n\n```\n// Version for Typescriptconst query: any// Version for Javascriptconst query// Example is safe if the text query below is completely trusted contentconst query1 = `SELECT id, name FROM \"User\" `const query2 = `WHERE name = $1 `query = Prisma.raw(`${query1}${query2}`)// inputString can be untrusted inputconst inputString = `'Sarah' UNION SELECT id, title FROM \"Post\"`query.values = [inputString]const result = await prisma.$queryRaw(query)console.log(result)\n```\n\n### In `$queryRawUnsafe` and `$executeRawUnsafe`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#in-queryrawunsafe-and-executerawunsafe \"Direct link to in-queryrawunsafe-and-executerawunsafe\")\n\n#### Using `$queryRawUnsafe` and `$executeRawUnsafe` unsafely[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#using-queryrawunsafe-and-executerawunsafe-unsafely \"Direct link to using-queryrawunsafe-and-executerawunsafe-unsafely\")\n\nIf you cannot use tagged templates, you can instead use [`$queryRawUnsafe`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#queryrawunsafe) or [`$executeRawUnsafe`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#executerawunsafe) but **be aware that your these functions make it much more likely that your code will be vulnerable to SQL injection**.\n\nThe following example concatenates `query` and `inputString`. Prisma Client ❌ **cannot** escape `inputString` in this example, which makes it vulnerable to SQL injection:\n\n```\nconst inputString = '\"Sarah\" UNION SELECT id, title, content FROM Post' // SQL Injectionconst query = 'SELECT id, name, email FROM User WHERE name = ' + inputStringconst result = await prisma.$queryRawUnsafe(query)console.log(result)\n```\n\n#### Parameterized queries[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#parameterized-queries \"Direct link to Parameterized queries\")\n\nAs an alternative to tagged templates, `$queryRawUnsafe` supports standard parameterized queries where each variable is represented by a symbol (`?` for MySQL, `$1`, `$2`, and so on for PostgreSQL). Note that the examples just show PostgreSQL queries.\n\nThe following example is safe ✅ from SQL Injection:\n\n```\nconst userName = 'Sarah'const email = 'sarah@prisma.io'const result = await prisma.$queryRawUnsafe(  'SELECT * FROM User WHERE (name = $1 OR email = $2)',  userName,  email)\n```\n\n> **Note**: PostgreSQL variables are represented by `$1` and `$2`\n\nAs with tagged templates, Prisma Client escapes all variables when they are provided in this way.\n\n> **Note**: You cannot pass a table or column name as a variable into a parameterized query. For example, you cannot `SELECT ?` and pass in `*` or `id, name` based on some condition.\n\n##### Parameterized PostgreSQL `ILIKE` query[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#parameterized-postgresql-ilike-query \"Direct link to parameterized-postgresql-ilike-query\")\n\nWhen you use `ILIKE`, the `%` wildcard character(s) should be included in the variable itself, not the query (`string`). This example is safe ✅ from SQL Injection.\n\n```\nconst userName = 'Sarah'const emailFragment = 'prisma.io'const result = await prisma.$queryRawUnsafe(  'SELECT * FROM \"User\" WHERE (name = $1 OR email ILIKE $2)',  userName,  `%${emailFragment}`)\n```\n\n> **Note**: Using `%$2` as an argument would not work\n\n## Raw queries with MongoDB[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-queries-with-mongodb \"Direct link to Raw queries with MongoDB\")\n\nFor MongoDB in versions `3.9.0` and later, Prisma Client exposes three methods that allow you to send raw queries. You can use:\n\n*   `$runCommandRaw` to run a command against the database\n*   `<model>.findRaw` to find zero or more documents that match the filter.\n*   `<model>.aggregateRaw` to perform aggregation operations on a collection.\n\n### `$runCommandRaw()`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#runcommandraw \"Direct link to runcommandraw\")\n\n`$runCommandRaw()` runs a raw MongoDB command against the database. As input, it accepts all [MongoDB database commands](https://www.mongodb.com/docs/manual/reference/command/), with the following exceptions:\n\n*   `find` (use [`findRaw()`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#findraw) instead)\n*   `aggregate` (use [`aggregateRaw()`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#aggregateraw) instead)\n\nWhen you use `$runCommandRaw()` to run a MongoDB database command, note the following:\n\n*   The object that you pass when you invoke `$runCommandRaw()` must follow the syntax of the MongoDB database command.\n*   You must connect to the database with an appropriate role for the MongoDB database command.\n\nIn the following example, a query inserts two records with the same `_id`. This bypasses normal document validation.\n\n```\nprisma.$runCommandRaw({  insert: 'Pets',  bypassDocumentValidation: true,  documents: [    {      _id: 1,      name: 'Felinecitas',      type: 'Cat',      breed: 'Russian Blue',      age: 12,    },    {      _id: 1,      name: 'Nao Nao',      type: 'Dog',      breed: 'Chow Chow',      age: 2,    },  ],})\n```\n\nwarning\n\nDo not use `$runCommandRaw()` for queries which contain the `\"find\"` or `\"aggregate\"` commands, because you might be unable to fetch all data. This is because MongoDB returns a [cursor](https://docs.mongodb.com/manual/tutorial/iterate-a-cursor/) that is attached to your MongoDB session, and you might not hit the same MongoDB session every time. For these queries, you should use the specialised [`findRaw()`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#findraw) and [`aggregateRaw()`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#aggregateraw) methods instead.\n\n#### Return type[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#return-type-2 \"Direct link to Return type\")\n\n`$runCommandRaw()` returns a `JSON` object whose shape depends on the inputs.\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature-4 \"Direct link to Signature\")\n\n```\n$runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\n```\n\n### `findRaw()`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#findraw \"Direct link to findraw\")\n\n`<model>.findRaw()` returns actual database records. It will find zero or more documents that match the filter on the `User` collection:\n\n```\nconst result = await prisma.user.findRaw({  filter: { age: { $gt: 25 } },  options: { projection: { _id: false } },})\n```\n\n#### Return type[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#return-type-3 \"Direct link to Return type\")\n\n`<model>.findRaw()` returns a `JSON` object whose shape depends on the inputs.\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature-5 \"Direct link to Signature\")\n\n```\n<model>.findRaw(args?: {filter?: InputJsonObject, options?: InputJsonObject}): PrismaPromise<JsonObject>;\n```\n\n*   `filter`: The query predicate filter. If unspecified, then all documents in the collection will match the [predicate](https://docs.mongodb.com/manual/reference/operator/query).\n*   `options`: Additional options to pass to the [`find` command](https://docs.mongodb.com/manual/reference/command/find/#command-fields).\n\n### `aggregateRaw()`[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#aggregateraw \"Direct link to aggregateraw\")\n\n`<model>.aggregateRaw()` returns aggregated database records. It will perform aggregation operations on the `User` collection:\n\n```\nconst result = await prisma.user.aggregateRaw({  pipeline: [    { $match: { status: 'registered' } },    { $group: { _id: '$country', total: { $sum: 1 } } },  ],})\n```\n\n#### Return type[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#return-type-4 \"Direct link to Return type\")\n\n`<model>.aggregateRaw()` returns a `JSON` object whose shape depends on the inputs.\n\n#### Signature[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#signature-6 \"Direct link to Signature\")\n\n```\n<model>.aggregateRaw(args?: {pipeline?: InputJsonObject[], options?: InputJsonObject}): PrismaPromise<JsonObject>;\n```\n\n*   `pipeline`: An array of aggregation stages to process and transform the document stream via the [aggregation pipeline](https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline).\n*   `options`: Additional options to pass to the [`aggregate` command](https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields).",
  "title": "Raw queries | Prisma Documentation",
  "description": "Learn how you can send raw SQL and MongoDB queries to your database using the raw() methods from the Prisma Client API.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose",
  "markdown": "# How to migrate from Mongoose to Prisma ORM\n\nThis guide describes how to migrate from Mongoose to Prisma ORM. It uses an extended version of the [Mongoose Express example](https://github.com/Automattic/mongoose/tree/master/examples/express) as a [sample project](https://github.com/prisma/migrate-from-mongoose-to-prisma) to demonstrate the migration steps. You can find the example used for this guide on [GitHub](https://github.com/prisma/migrate-from-mongoose-to-prisma).\n\nYou can learn how Prisma ORM compares to Mongoose on the [Prisma ORM vs Mongoose](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose) page.\n\n## Overview of the migration process[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#overview-of-the-migration-process \"Direct link to Overview of the migration process\")\n\nNote that the steps for migrating from Mongoose to Prisma ORM are always the same, no matter what kind of application or API layer you're building:\n\n1.  [Install the Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli#installation)\n2.  [Introspect your database](https://www.prisma.io/docs/orm/prisma-schema/introspection)\n3.  [Install and generate Prisma Client](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client)\n4.  Gradually replace your Mongoose queries with Prisma Client\n\nThese steps apply whether you're building a REST API (e.g. with Express, koa or NestJS), a GraphQL API (e.g. with Apollo Server, TypeGraphQL or Nexus) or any other kind of application that uses Mongoose for database access.\n\nPrisma ORM lends itself really well for **incremental adoption**. This means, you don't have migrate your entire project from Mongoose to Prisma ORM at once, but rather you can _step-by-step_ move your database queries from Mongoose to Prisma ORM.\n\n## Overview of the sample project[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#overview-of-the-sample-project \"Direct link to Overview of the sample project\")\n\nFor this guide, we'll use a REST API built with Express as a [sample project](https://github.com/prisma/migrate-from-mongoose-to-prisma) to migrate to Prisma ORM. It has three documents and one sub-document (embedded document):\n\n*   post.js\n*   user.js\n*   category.js\n\n```\nconst mongoose = require('mongoose')const Schema = mongoose.Schemaconst PostSchema = new Schema({  title: String,  content: String,  published: {    type: Boolean,    default: false,  },  author: {    type: Schema.Types.ObjectId,    ref: 'author',    required: true,  },  categories: [    {      type: Schema.Types.ObjectId,      ref: 'Category',    },  ],})module.exports = mongoose.model('Post', PostSchema)\n```\n\nThe models/documents have the following types of relationships:\n\n*   1-n: `User` ↔ `Post`\n*   m-n: `Post` ↔ `Category`\n*   Sub-document/ Embedded document: `User` ↔ `Profile`\n\nIn the example used in this guide, the route handlers are located in the `src/controllers` directory. The models are located in the `src/models` directory. From there, the models are pulled into a central `src/routes.js` file, which is used to define the required routes in `src/index.js`:\n\n```\n└── blog-mongoose    ├── package.json    └──src        ├── controllers        │   ├── post.js        │   └── user.js        ├── models        │   ├── category.js        │   ├── post.js        │   └── user.js        ├── index.js        ├── routes.js        └── seed.js\n```\n\nThe example repository contains a `seed` script inside the `package.json` file.\n\nRun `npm run seed` to populate your database with the sample data in the `./src/seed.js` file.\n\n## Step 1. Install the Prisma CLI[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#step-1-install-the-prisma-cli \"Direct link to Step 1. Install the Prisma CLI\")\n\nThe first step to adopt Prisma ORM is to [install the Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli#installation) in your project:\n\n```\nnpm install prisma --save-dev\n```\n\n## Step 2. Introspect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#step-2-introspect-your-database \"Direct link to Step 2. Introspect your database\")\n\nIntrospection is a process of inspecting the structure of a database, used in Prisma ORM to generate a [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema).\n\n### 2.1. Set up Prisma[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#21-set-up-prisma \"Direct link to 2.1. Set up Prisma\")\n\nBefore you can introspect your database, you need to set up your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) and connect Prisma ORM to your database. Run the following command in your terminal to create a basic Prisma schema file:\n\n```\nnpx prisma init --datasource-provider mongodb\n```\n\nThis command creates:\n\n*   A new directory called `prisma` that contains a `schema.prisma` file; your Prisma schema specifies your database connection and models\n*   `.env`: A [`dotenv`](https://github.com/motdotla/dotenv) file at the root of your project (if it doesn't already exist), used to configure your database connection URL as an environment variable\n\nThe Prisma schema currently looks as follows:\n\nprisma/schema.prisma\n\n```\n// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemadatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\n  \n\ntip\n\nFor an optimal development experience when working with Prisma ORM, refer to [editor setup](https://www.prisma.io/docs/orm/more/development-environment/editor-setup) to learn about syntax highlighting, formatting, auto-completion, and many more cool features.\n\n### 2.2. Connect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#22-connect-your-database \"Direct link to 2.2. Connect your database\")\n\nConfigure your [database connection URL](https://www.prisma.io/docs/orm/reference/connection-urls#mongodb) in the `.env` file.\n\nThe format of the connection URL that Mongoose uses is similar to the one Prisma ORM uses.\n\n.env\n\n```\nDATABASE_URL=\"mongodb://alice:myPassword43@localhost:27017/blog-mongoose\"\n```\n\nRefer to the [MongoDB connection URL specification](https://www.mongodb.com/docs/manual/reference/connection-string/#connection-string-options) for further details.\n\n### 2.3. Run Prisma ORM's introspection[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#23-run-prisma-orms-introspection \"Direct link to 2.3. Run Prisma ORM's introspection\")\n\nWith your connection URL in place, you can [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) your database to generate your Prisma models:\n\n> **Note**: MongoDB is a _schemaless_ database. To incrementally adopt Prisma ORM in your project, ensure your database is populated with sample data. Prisma ORM introspects a MongoDB schema by sampling data stored and inferring the schema from the data in the database.\n\nThis creates the following Prisma models:\n\nprisma/schema.prisma\n\n```\ntype UsersProfile {  bio String}model categories {  id   String @id @default(auto()) @map(\"_id\") @db.ObjectId  v    Int    @map(\"__v\")  name String}model posts {  id         String   @id @default(auto()) @map(\"_id\") @db.ObjectId  v          Int      @map(\"__v\")  author     String   @db.ObjectId  categories String[] @db.ObjectId  content    String  published  Boolean  title      String}model users {  id      String        @id @default(auto()) @map(\"_id\") @db.ObjectId  v       Int           @map(\"__v\")  email   String        @unique(map: \"email_1\")  name    String  profile UsersProfile?}\n```\n\nThe generated Prisma models represent the MongoDB collections and are the foundation of your programmatic Prisma Client API which allows you to send queries to your database.\n\n### 2.4. Update the relations[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#24-update-the-relations \"Direct link to 2.4. Update the relations\")\n\nMongoDB doesn't support relations between different collections. However, you can create references between documents using the [`ObjectId`](https://www.prisma.io/docs/orm/overview/databases/mongodb#using-objectid) field type or from one document to many using an array of `ObjectIds` in the collection. The reference will store id(s) of the related document(s). You can use the `populate()` method that Mongoose provides to populate the reference with the data of the related document.\n\nUpdate the 1-n relationship between `Post` <-> `User` as follows:\n\n*   Rename the existing `author` reference in the `posts` model to `authorId` and add the `@map(\"author\")` attribute\n*   Add the `author` relation field in the `posts` model and it's `@relation` attribute specifying the `fields` and `references`\n*   Add the `posts` relation in the `users` model\n\n*   diff\n*   schema.prisma\n\n```\ntype UsersProfile {  bio String}model categories {  id   String @id @default(auto()) @map(\"_id\") @db.ObjectId  v    Int    @map(\"__v\")  name String}model posts {  id        String  @id @default(auto()) @map(\"_id\") @db.ObjectId  title     String  content   String  published Boolean  v         Int     @map(\"__v\")  -  author     String   @db.ObjectId  +  author     users  @relation(fields: [authorId], references: [id])  +  authorId   String @map(\"author\") @db.ObjectId  categories String[] @db.ObjectId}model users {  id      String        @id @default(auto()) @map(\"_id\") @db.ObjectId  v       Int           @map(\"__v\")  email   String        @unique(map: \"email_1\")  name    String  profile UsersProfile?  +  posts   posts[]}\n```\n\nUpdate the m-n between `Post` <-> `Category` references as follows:\n\n*   Rename the `categories` field to `categoryIds` and map it using `@map(\"categories\")` in the `posts` model\n*   Add a new `categories` relation field in the `posts` model\n*   Add the `postIds` scalar list field in the `categories` model\n*   Add the `posts` relation in the `categories` model\n*   Add a [relation scalar](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#annotated-relation-fields) on both models\n*   Add the `@relation` attribute specifying the `fields` and `references` arguments on both sides\n\n*   diff\n*   schema.prisma\n\n```\ntype UsersProfile {  bio String}model categories {  id   String @id @default(auto()) @map(\"_id\") @db.ObjectId  v    Int    @map(\"__v\")  name String  +  posts    posts[]  @relation(fields: [postIds], references: [id])  +  postIds String[] @db.ObjectId}model posts {  id        String  @id @default(auto()) @map(\"_id\") @db.ObjectId  title     String  content   String  published Boolean  v         Int     @map(\"__v\")  author   users  @relation(fields: [authorId], references: [id])  authorId String @map(\"author\") @db.ObjectId  -  categories  String[] @db.ObjectId  +  categories  categories[] @relation(fields: [categoryIds], references: [id])  +  categoryIds String[] @map(\"categories\") @db.ObjectId}model users {  id      String        @id @default(auto()) @map(\"_id\") @db.ObjectId  v       Int           @map(\"__v\")  email   String        @unique(map: \"email_1\")  name    String  profile UsersProfile?  posts   posts[]}\n```\n\n### 2.5 Adjust the Prisma schema (optional)[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#25-adjust-the-prisma-schema-optional \"Direct link to 2.5 Adjust the Prisma schema (optional)\")\n\nThe models that were generated via introspection currently _exactly_ map to your database collections. In this section, you'll learn how you can adjust the naming of the Prisma models to adhere to [Prisma ORM's naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions).\n\nSome of these adjustments are entirely optional and you are free to skip to the next step already if you don't want to adjust anything for now. You can go back and make the adjustments at any later point.\n\nAs opposed to the current snake\\_case notation of Prisma models, Prisma ORM's naming conventions are:\n\n*   PascalCase for model names\n*   camelCase for field names\n\nYou can adjust the naming by [_mapping_](https://www.prisma.io/docs/orm/overview/databases/mongodb#using-objectid) the Prisma model and field names to the existing table and column names in the underlying database using `@@map` and `@map`, respectively.\n\ntip\n\nYou can use the [rename symbol](https://code.visualstudio.com/docs/editor/refactoring#_rename-symbol) operation to refactor model names by highlighting the model name, pressing F2, and finally typing the desired name. This will rename all instances where it is referenced and add the `@@map()` attribute to the existing model with its former name.\n\nIf your schema includes a [`versionKey`](https://mongoosejs.com/docs/guide.html#versionKey), update it by adding the `@default(0)` and `@ignore` attributes to the `v` field. This means the field will be excluded from the generated Prisma Client and will have a default value of 0. Prisma ORM does not handle document versioning.\n\nAlso note that you can rename [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) to optimize the Prisma Client API that you'll use later to send queries to your database. For example, the `post` field on the `user` model is a _list_, so a better name for this field would be `posts` to indicate that it's plural.\n\nUpdate the `published` field by including the `@default` attribute to define the default value of the field.\n\nYou can also rename the `UserProfile` composite type to `Profile`.\n\nHere's an adjusted version of the Prisma schema that addresses these points:\n\nprisma/schema.prisma\n\n```\ngenerator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}type Profile {  bio String}model Category {  id   String @id @default(auto()) @map(\"_id\") @db.ObjectId  name String  v    Int    @default(0) @map(\"__v\") @ignore  posts    Post[]   @relation(fields: [post_ids], references: [id])  post_ids String[] @db.ObjectId  @@map(\"categories\")}model Post {  id        String  @id @default(auto()) @map(\"_id\") @db.ObjectId  title     String  content   String  published Boolean @default(false)  v         Int     @default(0) @map(\"__v\") @ignore  author   User   @relation(fields: [authorId], references: [id])  authorId String @map(\"author\") @db.ObjectId  categories  Category[] @relation(fields: [categoryIds], references: [id])  categoryIds String[]   @db.ObjectId  @@map(\"posts\")}model User {  id      String   @id @default(auto()) @map(\"_id\") @db.ObjectId  v       Int      @default(0) @map(\"__v\") @ignore  email   String   @unique(map: \"email_1\")  name    String  profile Profile?  posts   Post[]  @@map(\"users\")}\n```\n\n## Step 3. Install Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#step-3-install-prisma-client \"Direct link to Step 3. Install Prisma Client\")\n\nAs a next step, you can install Prisma Client in your project so that you can start replacing the database queries in your project that are currently made with Mongoose:\n\n```\nnpm install @prisma/client\n```\n\n## Step 4. Replace your Mongoose queries with Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#step-4-replace-your-mongoose-queries-with-prisma-client \"Direct link to Step 4. Replace your Mongoose queries with Prisma Client\")\n\nIn this section, we'll show a few sample queries that are being migrated from Mongoose to Prisma Client, based on the example routes from the sample REST API project. For a comprehensive overview of how the Prisma Client API differs from Mongoose, check out the [Mongoose and Prisma API comparison](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose) page.\n\nFirst, to set up the `PrismaClient` instance that you'll use to send database queries from the various route handlers, create a new file named `prisma.js` in the `src` directory:\n\nNow, instantiate `PrismaClient` and export it from the file so you can use it in your route handlers later:\n\nsrc/prisma.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()module.exports = prisma\n```\n\nThe imports in our controller files are as follows:\n\nsrc/controllers/post.js\n\n```\nconst Post = require('../models/post')const User = require('../models/user')const Category = require('../models/category')\n```\n\nsrc/controllers/user.js\n\n```\nconst Post = require('../models/post')const User = require('../models/user')\n```\n\nYou'll update the controller imports as you migrate from Mongoose to Prisma:\n\nsrc/controllers/post.js\n\n```\nconst prisma = require('../prisma')\n```\n\nsrc/controllers/user.js\n\n```\nconst prisma = require('../prisma')\n```\n\n### 4.1. Replacing queries in `GET` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#41-replacing-queries-in-get-requests \"Direct link to 41-replacing-queries-in-get-requests\")\n\nThe example REST API used in this guide has four routes that accept `GET` requests:\n\n*   `/feed?searchString={searchString}&take={take}&skip={skip}`: Return all published posts\n    *   Query Parameters (optional):\n        *   `searchString`: Filter posts by `title` or `content`\n        *   `take`: Specifies how many objects should be returned in the list\n        *   `skip`: Specifies how many of the returned objects should be skipped\n*   `/post/:id`: Returns a specific post\n*   `/authors`: Returns a list of authors\n\nLet's dive into the route handlers that implement these requests.\n\n#### `/feed`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#feed \"Direct link to feed\")\n\nThe `/feed` handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst feed = async (req, res) => {  try {    const { searchString, skip, take } = req.query    const or =      searchString !== undefined        ? {            $or: [              { title: { $regex: searchString, $options: 'i' } },              { content: { $regex: searchString, $options: 'i' } },            ],          }        : {}    const feed = await Post.find(      {        ...or,        published: true,      },      null,      {        skip,        batchSize: take,      }    )      .populate({ path: 'author', model: User })      .populate('categories')    return res.status(200).json(feed)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that each returned `Post` object includes the relation to the `author` and `category` with which it is associated. With Mongoose, including the relation is not type-safe. For example, if there was a typo in the relation that is retrieved, your database query would fail only at _runtime_ – the JavaScript compiler does not provide any safety here.\n\nHere is how the same route handler is implemented using Prisma Client:\n\nsrc/controllers/post.js\n\n```\nconst feed = async (req, res) => {  try {    const { searchString, skip, take } = req.query    const or = searchString      ? {          OR: [            { title: { contains: searchString } },            { content: { contains: searchString } },          ],        }      : {}    const feed = await prisma.post.findMany({      where: {        published: true,        ...or,      },      include: { author: true, categories: true },      take: Number(take) || undefined,      skip: Number(skip) || undefined,    })    return res.status(200).json(feed)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that the way in which Prisma Client includes the `author` relation is absolutely type-safe. The JavaScript compiler would throw an error if you were trying to include a relation that does not exist on the `Post` model.\n\n#### `/post/:id`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#postid \"Direct link to postid\")\n\nThe `/post/:id` handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst getPostById = async (req, res) => {  const { id } = req.params  try {    const post = await Post.findById(id)      .populate({ path: 'author', model: User })      .populate('categories')    if (!post) return res.status(404).json({ message: 'Post not found' })    return res.status(200).json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst getPostById = async (req, res) => {  const { id } = req.params  try {    const post = await prisma.post.findUnique({      where: { id },      include: {        author: true,        category: true,      },    })    if (!post) return res.status(404).json({ message: 'Post not found' })    return res.status(200).json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\n### 4.2. Replacing queries in `POST` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#42-replacing-queries-in-post-requests \"Direct link to 42-replacing-queries-in-post-requests\")\n\nThe REST API has three routes that accept `POST` requests:\n\n*   `/user`: Creates a new `User` record\n*   `/post`: Creates a new `User` record\n*   `/user/:id/profile`: Creates a new `Profile` record for a `User` record with a given ID\n\n#### `/user`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#user \"Direct link to user\")\n\nThe `/user` handler is implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst createUser = async (req, res) => {  const { name, email } = req.body  try {    const user = await User.create({      name,      email,    })    return res.status(201).json(user)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route handler is implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst createUser = async (req, res) => {  const { name, email } = req.body  try {    const user = await prisma.user.create({      data: {        name,        email,      },    })    return res.status(201).json(user)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\n#### `/post`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#post \"Direct link to post\")\n\nThe `/post` handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst createDraft = async (req, res) => {  const { title, content, authorEmail } = req.body  try {    const author = await User.findOne({ email: authorEmail })    if (!author) return res.status(404).json({ message: 'Author not found' })    const draft = await Post.create({      title,      content,      author: author._id,    })    res.status(201).json(draft)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst createDraft = async (req, res) => {  const { title, content, authorEmail } = req.body  try {    const draft = await prisma.post.create({      data: {        title,        content,        author: {          connect: {            email: authorEmail,          },        },      },    })    res.status(201).json(draft)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that Prisma Client's nested write here saves the initial query where the `User` record is first retrieved by its `email`. That's because, with Prisma Client you can connect records in relations using any unique property.\n\n#### `/user/:id/profile`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#useridprofile \"Direct link to useridprofile\")\n\nThe `/user/:id/profile` handler is implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst setUserBio = async (req, res) => {  const { id } = req.params  const { bio } = req.body  try {    const user = await User.findByIdAndUpdate(      id,      {        profile: {          bio,        },      },      { new: true }    )    if (!user) return res.status(404).json({ message: 'Author not found' })    return res.status(200).json(user)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route handler is implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst setUserBio = async (req, res) => {  const { id } = req.params  const { bio } = req.body  try {    const user = await prisma.user.update({      where: { id },      data: {        profile: {          bio,        },      },    })    if (!user) return res.status(404).json({ message: 'Author not found' })    return res.status(200).json(user)  } catch (error) {    console.log(error)    return res.status(500).json(error)  }}\n```\n\nAlternatively, you can use the `set` property to update the value of an embedded document as follows:\n\nsrc/controllers/user.js\n\n```\nconst setUserBio = async (req, res) => {  const { id } = req.params  const { bio } = req.body  try {    const user = await prisma.user.update({      where: {        id,      },      data: {        profile: {          set: { bio },        },      },    })    return res.status(200).json(user)  } catch (error) {    console.log(error)    return res.status(500).json(error)  }}\n```\n\n### 4.3. Replacing queries in `PUT` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#43-replacing-queries-in-put-requests \"Direct link to 43-replacing-queries-in-put-requests\")\n\nThe REST API has two routes that accept a `PUT` request:\n\n*   `/post/:id/:categoryId`: Adds the post with `:id` to the category with `:categoryId`\n*   `/post/:id`: Updates the `published` status of a post to true.\n\nLet's dive into the route handlers that implement these requests.\n\n#### `/post/:id/:categoryId`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#postidcategoryid \"Direct link to postidcategoryid\")\n\nThe `/post/:id/:categoryId` handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst addPostToCategory = async (req, res) => {  const { id, categoryId } = req.params  try {    const category = await Category.findById(categoryId)    if (!category)      return res.status(404).json({ message: 'Category not found' })    const post = await Post.findByIdAndUpdate(      { _id: id },      {        categories: [{ _id: categoryId }],      },      { new: true }    )    if (!post) return res.status(404).json({ message: 'Post not found' })    return res.status(200).json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst addPostToCategory = async (req, res) => {  const { id, categoryId } = req.query  try {    const post = await prisma.post.update({      where: {        id,      },      data: {        categories: {          connect: {            id: categoryId,          },        },      },    })    if (!post) return res.status(404).json({ message: 'Post not found' })    return res.status(200).json(post)  } catch (error) {    console.log({ error })    return res.status(500).json(error)  }}\n```\n\n#### `/post/:id`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#postid-1 \"Direct link to postid-1\")\n\nThe `/post/:id` handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst publishDraft = async (req, res) => {  const { id } = req.params  try {    const post = await Post.findByIdAndUpdate(      { id },      { published: true },      { new: true }    )    return res.status(200).json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the handler is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst publishDraft = async (req, res) => {  const { id } = req.params  try {    const post = await prisma.post.update({      where: { id },      data: { published: true },    })    return res.status(200).json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\n## More[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#more \"Direct link to More\")\n\n### Embedded documents `_id` field[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#embedded-documents-_id-field \"Direct link to embedded-documents-_id-field\")\n\nBy default, Mongoose assigns each document and embedded document an `_id` field. If you wish to disable this option for embedded documents, you can set the `_id` option to false.\n\n```\nconst ProfileSchema = new Schema(  {    bio: String,  },  {    _id: false,  })\n```\n\n### Document version key[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#document-version-key \"Direct link to Document version key\")\n\nMongoose assigns each document a version when created. You can disable Mongoose from versioning your documents by setting the `versionKey` option of a model to false. It is [not recommended](http://aaronheckmann.blogspot.com/2012/06/mongoose-v3-part-1-versioning.html) to disable this unless you are an advanced user.\n\n```\nconst ProfileSchema = new Schema(  {    bio: String,  },  {    versionKey: false,  })\n```\n\nWhen migrating to Prisma ORM, mark the `versionKey` field as optional ( **?** ) in your Prisma schema and add the `@ignore` attribute to exclude it from Prisma Client.\n\n### Collection name inference[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#collection-name-inference \"Direct link to Collection name inference\")\n\nMongoose infers the collection names by automatically converting the model names to lowercase and plural form.\n\nOn the other hand, Prisma ORM maps the model name to the table name in your database [modeling your data](https://www.prisma.io/docs/orm/prisma-schema/data-model/models).\n\nYou can enforce the collection name in Mongoose to have the same name as the model by setting the [](https://mongoosejs.com/docs/guide.html#collection)option while creating your schema\n\n```\nconst PostSchema = new Schema(  {    title: String,    content: String,    // more fields here  },  {    collection: 'Post',  })\n```\n\n### Modeling relations[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose#modeling-relations \"Direct link to Modeling relations\")\n\nYou can model relations in Mongoose between documents by either using [sub-documents](https://mongoosejs.com/docs/subdocs.html) or storing [a reference to other documents](https://mongoosejs.com/docs/queries.html#refs).\n\nPrisma ORM allows you to model different types of relations between documents when working with MongoDB:\n\n*   [One-to-one relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#mongodb)\n*   [One-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations#mongodb)\n*   [Many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#mongodb)\n*   [Self-relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#mongodb)\n*   [Embedded documents](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types)",
  "title": "How to migrate from Mongoose to Prisma ORM | Prisma Documentation",
  "description": "Learn how to migrate from Mongoose to Prisma ORM",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle",
  "markdown": "# How to migrate from Drizzle to Prisma ORM\n\nThis guide describes how to migrate from Drizzle to Prisma ORM. It uses a sample project based off of the [Drizzle Next.js example](https://orm.drizzle.team/learn/tutorials/drizzle-nextjs-neon) as a [sample project](https://github.com/prisma/migrate-from-drizzle-to-prisma) to demonstrate the migration steps. You can find the example used for this guide on [GitHub](https://github.com/prisma/migrate-from-drizzle-to-prisma).\n\nnote\n\nthis migration guide uses Neon PostgreSQL as the example database, but it equally applies to any other relational database that are [supported by Prisma ORM](https://www.prisma.io/docs/orm/reference/supported-databases).\n\nYou can learn how Prisma ORM compares to Drizzle on the [Prisma ORM vs Drizzle](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle) page.\n\n## Overview of the migration process[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#overview-of-the-migration-process \"Direct link to Overview of the migration process\")\n\nNote that the steps for migrating from Drizzle to Prisma ORM are always the same, no matter what kind of application or API layer you're building:\n\n1.  Install the Prisma CLI\n2.  Introspect your database\n3.  Create a baseline migration\n4.  Install Prisma Client\n5.  Gradually replace your Drizzle queries with Prisma Client\n\nThese steps apply, no matter if you're building a REST API (e.g. with Express, koa or NestJS), a GraphQL API (e.g. with Apollo Server, TypeGraphQL or Nexus) or any other kind of application that uses Drizzle for database access.\n\nPrisma ORM lends itself really well for **incremental adoption**. This means, you don't have migrate your entire project from Drizzle to Prisma ORM at once, but rather you can _step-by-step_ move your database queries from Drizzle to Prisma ORM.\n\n## Step 1. Install the Prisma CLI[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#step-1-install-the-prisma-cli \"Direct link to Step 1. Install the Prisma CLI\")\n\nThe first step to adopt Prisma ORM is to [install the Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli#installation) in your project:\n\n```\nnpm install prisma --save-dev\n```\n\n## Step 2. Introspect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#step-2-introspect-your-database \"Direct link to Step 2. Introspect your database\")\n\n### 2.1. Set up Prisma ORM[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#21-set-up-prisma-orm \"Direct link to 2.1. Set up Prisma ORM\")\n\nBefore you can introspect your database, you need to set up your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) and connect Prisma to your database. Run the following command in the root of your project to create a basic Prisma schema file:\n\nThis command created a new directory called `prisma` with the following files for you:\n\n*   `schema.prisma`: Your Prisma schema that specifies your database connection and models\n*   `.env`: A [`dotenv`](https://github.com/motdotla/dotenv) to configure your database connection URL as an environment variable\n\nnote\n\nyou may already have a `.env` file. If so, the `prisma init` command will append lines to it rather than creating a new file.\n\nThe Prisma schema currently looks as follows:\n\nprisma/schema.prisma\n\n```\n// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemadatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\ntip\n\nIf you're using VS Code, be sure to install the [Prisma VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) for syntax highlighting, formatting, auto-completion and a lot more cool features.\n\n### 2.2. Connect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#22-connect-your-database \"Direct link to 2.2. Connect your database\")\n\nIf you're not using PostgreSQL, you need to adjust the `provider` field on the `datasource` block to the database you currently use:\n\n*   PostgreSQL\n*   MySQL\n*   Microsoft SQL Server\n*   SQLite\n\nschema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nOnce that's done, you can configure your [database connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) in the `.env` file. Drizzle and Prisma ORM use the same format for connection URLs, so your existing connection URL should work fine.\n\n### 2.3. Introspect your database using Prisma ORM[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#23-introspect-your-database-using-prisma-orm \"Direct link to 2.3. Introspect your database using Prisma ORM\")\n\nWith your connection URL in place, you can [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) your database to generate your Prisma models:\n\nIf you're using the [sample project](https://github.com/prisma/migrate-from-drizzle-to-prisma) the following model would be created:\n\nprisma/schema.prisma\n\n```\nmodel todo {  id   Int     @id  text String  done Boolean @default(false)}\n```\n\nThe generated Prisma model represents a database table. Prisma models are the foundation for your programmatic Prisma Client API which allows you to send queries to your database.\n\n### 2.4. Create a baseline migration[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#24-create-a-baseline-migration \"Direct link to 2.4. Create a baseline migration\")\n\nTo continue using Prisma Migrate to evolve your database schema, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\n```\nmkdir -p prisma/migrations/0_init\n```\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n*   `--from-empty`: assumes the data model you're migrating from is empty\n*   `--to-schema-datamodel`: the current database state using the URL in the `datasource` block\n*   `--script`: output a SQL script\n\n```\nnpx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql\n```\n\nReview the generated migration to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\n```\nnpx prisma migrate resolve --applied 0_init\n```\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.\n\n### 2.5. Adjust the Prisma schema (optional)[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#25-adjust-the-prisma-schema-optional \"Direct link to 2.5. Adjust the Prisma schema (optional)\")\n\nModels that are generated via introspection currently _exactly_ map to your database tables. In this section, you'll learn how you can adjust the naming of the Prisma models to adhere to [Prisma ORM's naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions).\n\nAll of these adjustment are entirely optional and you are free to skip to the next step already if you don't want to adjust anything for now. You can go back and make the adjustments at any later point.\n\nAs opposed to the current camelCase notation of Drizzle models, Prisma ORM's naming conventions are:\n\n*   PascalCase for model names\n*   camelCase for field names\n\nYou can adjust the naming by _mapping_ the Prisma model and field names to the existing table and column names in the underlying database using `@@map` and `@map`.\n\nHere's an example on how you could modify the model above:\n\nprisma/schema.prisma\n\n```\nmodel Todo {  id   Int     @id  text String  done Boolean @default(false)  @@map(\"todo\")}\n```\n\n## Step 3. Install and generate Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#step-3-install-and-generate-prisma-client \"Direct link to Step 3. Install and generate Prisma Client\")\n\nAs a next step, you can install Prisma Client in your project so that you can start replacing the database queries in your project that are currently made with Drizzle:\n\n```\nnpm install @prisma/client\n```\n\nAfter installing, you need to run `generate` in order to have your schema reflected in TypeScript types and autocomplete.\n\n## Step 4. Replace your Drizzle queries with Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#step-4-replace-your-drizzle-queries-with-prisma-client \"Direct link to Step 4. Replace your Drizzle queries with Prisma Client\")\n\nIn this section, we'll show a few sample queries that are being migrated from Drizzle to Prisma Client based on the example routes from the sample REST API project. For a comprehensive overview of how the Prisma Client API differs from Drizzle, check out the [comparison page](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle).\n\nFirst, to set up the `PrismaClient` instance that you'll use to send database queries from the various route handlers. Create a new file named `prisma.ts` in the `db` directory:\n\nNow, instantiate `PrismaClient` and export it from the file so you can use it in your route handlers later:\n\ndb/prisma.ts\n\n```\nimport { PrismaClient } from '@prisma/client'export const prisma = new PrismaClient()\n```\n\n### 4.1. Replacing `getData` queries[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#41-replacing-getdata-queries \"Direct link to 41-replacing-getdata-queries\")\n\nThe fullstack Next.js app has several `actions` including `getData`.\n\nThe `getData` action is currently implemented as follows:\n\nactions/todoActions.ts\n\n```\nimport db from \"@/db/drizzle\";import { todo } from \"@/db/schema\";export const getData = async () => {  const data = await db.select().from(todo);  return data;};\n```\n\nHere is the same action implemented using Prisma Client:\n\nsrc/controllers/FeedAction.ts\n\n```\nimport { prisma } from \"@/db/prisma\";export const getData = async () => {  const data = await prisma.todo.findMany();  return data;};\n```\n\n### 4.2. Replacing queries in `POST` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#42-replacing-queries-in-post-requests \"Direct link to 42-replacing-queries-in-post-requests\")\n\nThe [sample project](https://github.com/prisma/migrate-from-drizzle-to-prisma) has four actions that are utilized during `POST` requests:\n\n*   `addTodo`: Creates a new `Todo` record\n*   `deleteTodo`: Deletes an existing `Todo` record\n*   `toggleTodo`: Toggles the boolean `done` field on an existing `Todo` record\n*   `editTodo`: Edits the `text` field on an existing `Todo` record\n\n#### `addTodo`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#addtodo \"Direct link to addtodo\")\n\nThe `addTodo` action is currently implemented as follows:\n\nactions/todoActions.ts\n\n```\nimport { revalidatePath } from \"next/cache\";import db from \"@/db/drizzle\";import { todo } from \"@/db/schema\";export const addTodo = async (id: number, text: string) => {  await db.insert(todo).values({    id: id,    text: text,  });  revalidatePath(\"/\");};\n```\n\nHere is the same action implemented using Prisma Client:\n\nactions/todoActions.ts\n\n```\nimport { revalidatePath } from \"next/cache\";import { prisma } from \"@/db/prisma\";export const addTodo = async (id: number, text: string) => {  await prisma.todo.create({    data: { id, text },  })  revalidatePath(\"/\");};\n```\n\n#### `deleteTodo`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#deletetodo \"Direct link to deletetodo\")\n\nThe `deleteTodo` action is currently implemented as follows:\n\nactions/todoActions.ts\n\n```\nimport { eq } from \"drizzle-orm\";import { revalidatePath } from \"next/cache\";import db from \"@/db/drizzle\";import { todo } from \"@/db/schema\";export const deleteTodo = async (id: number) => {  await db.delete(todo).where(eq(todo.id, id));  revalidatePath(\"/\");};\n```\n\nHere is the same action implemented using Prisma Client:\n\nactions/todoActions.ts\n\n```\nimport { revalidatePath } from \"next/cache\";import { prisma } from \"@/db/prisma\";export const deleteTodo = async (id: number) => {  await prisma.todo.delete({ where: { id } });  revalidatePath(\"/\");};\n```\n\n#### `toggleTodo`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#toggletodo \"Direct link to toggletodo\")\n\nThe `ToggleTodo` action is currently implemented as follows:\n\nactions/todoActions.ts\n\n```\nimport { eq, not } from \"drizzle-orm\";import { revalidatePath } from \"next/cache\";import db from \"@/db/drizzle\";import { todo } from \"@/db/schema\";export const toggleTodo = async (id: number) => {  await db    .update(todo)    .set({      done: not(todo.done),    })    .where(eq(todo.id, id));  revalidatePath(\"/\");};\n```\n\nHere is the same action implemented using Prisma Client:\n\nactions/todoActions.ts\n\n```\nimport { revalidatePath } from \"next/cache\";import { prisma } from \"@/db/prisma\";export const toggleTodo = async (id: number) => {  const todo = await prisma.todo.findUnique({ where: { id } });  if (todo) {    await prisma.todo.update({      where: { id: todo.id },      data: { done: !todo.done },    })    revalidatePath(\"/\");  }};\n```\n\nNote that Prisma ORM does not have the ability to edit a boolean field \"in place\", so the record must be fetched before hand.\n\n#### `editTodo`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#edittodo \"Direct link to edittodo\")\n\nThe `editTodo` action is currently implemented as follows:\n\nactions/todoActions.ts\n\n```\nimport { eq } from \"drizzle-orm\";import { revalidatePath } from \"next/cache\";import db from \"@/db/drizzle\";import { todo } from \"@/db/schema\";export const editTodo = async (id: number, text: string) => {  await db    .update(todo)    .set({      text: text,    })    .where(eq(todo.id, id));  revalidatePath(\"/\");};\n```\n\nHere is the same action implemented using Prisma Client:\n\nactions/todoActions.ts\n\n```\nimport { revalidatePath } from \"next/cache\";import { prisma } from \"@/db/prisma\";export const editTodo = async (id: number, text: string) => {  await prisma.todo.update({    where: { id },    data: { text },  })  revalidatePath(\"/\");};\n```\n\n## More[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#more \"Direct link to More\")\n\n### Implicit many-to-many relations[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-drizzle#implicit-many-to-many-relations \"Direct link to Implicit many-to-many relations\")\n\nUnlike Drizzle, Prisma ORM allows you to [model many-to-many relations _implicitly_](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations). That is, a many-to-many relation where you do not have to manage the [relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables) (also sometimes called JOIN table) _explicitly_ in your schema. Here is an example comparing Drizzle with Prisma ORM:\n\nschema.ts\n\n```\nimport { boolean, integer, pgTable, serial, text } from \"drizzle-orm/pg-core\";export const posts = pgTable('post', {  id: serial('serial').primaryKey(),  title: text('title').notNull(),  content: text('content'),  published: boolean('published').default(false).notNull(),});export const categories = pgTable('category', {  id: serial('serial').primaryKey(),  name: text('name').notNull(),});export const postsToCategories = pgTable('posts_to_categories', {  postId: integer('post_id').notNull().references(() => users.id),  categoryId: integer('category_id').notNull().references(() => chatGroups.id),});\n```\n\nThis schema is equivalent to the following Prisma schema:\n\nschema.prisma\n\n```\nmodel Post {  id                Int                @id @default(autoincrement())  title             String  content           String?  published         Boolean            @default(false)  postsToCategories PostToCategories[]  @@map(\"post\")}model Category {  id                Int                @id @default(autoincrement())  name              String  postsToCategories PostToCategories[]  @@map(\"category\")}model PostToCategories {  postId     Int  categoryId Int  category   Category @relation(fields: [categoryId], references: [id])  post       Post     @relation(fields: [postId], references: [id])  @@id([postId, categoryId])  @@index([postId])  @@index([categoryId])  @@map(\"posts_to_categories\")}\n```\n\nIn this Prisma schema, the many-to-many relation is modeled _explicitly_ via the relation table `PostToCategories`.\n\nBy instead adhering to the conventions for Prisma ORM relation tables, the relation could look as follows:\n\nschema.prisma\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  title      String  content    String?  published  Boolean    @default(false)  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String  posts Post[]}\n```\n\nThis would also result in a more ergonomic and less verbose Prisma Client API to modify the records in this relation, because you have a direct path from `Post` to `Category` (and the other way around) instead of needing to traverse the `PostToCategories` model first.\n\nwarning\n\nIf your database provider requires tables to have primary keys then you have to use explicit syntax, and manually create the join model with a primary key. This is because relation tables (JOIN tables) created by Prisma ORM (expressed via `@relation`) for many-to-many relations using implicit syntax do not have primary keys.",
  "title": "How to migrate from Drizzle to Prisma ORM | Prisma Documentation",
  "description": "Learn how to migrate from Drizzle to Prisma ORM",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize",
  "markdown": "# How to migrate from Sequelize to Prisma ORM\n\nThis guide describes how to migrate from Sequelize to Prisma ORM. It uses an extended version of the [Sequelize Express example](https://github.com/sequelize/express-example) as a [sample project](https://github.com/prisma/migrate-from-sequelize-to-prisma) to demonstrate the migration steps. You can find the example used for this guide on [GitHub](https://github.com/prisma/migrate-from-sequelize-to-prisma).\n\nThis migration guide uses PostgreSQL as the example database, but it equally applies to any other relational database that's [supported by Prisma](https://www.prisma.io/docs/orm/reference/supported-databases).\n\nYou can learn how Prisma ORM compares to Sequelize on the [Prisma ORM vs Sequelize](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize) page.\n\n## Overview of the migration process[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#overview-of-the-migration-process \"Direct link to Overview of the migration process\")\n\nNote that the steps for migrating from Sequelize to Prisma ORM are always the same, no matter what kind of application or API layer you're building:\n\n1.  Install the Prisma CLI\n2.  Introspect your database\n3.  Create a baseline migration\n4.  Install Prisma Client\n5.  Gradually replace your Sequelize queries with Prisma Client\n\nThese steps apply, no matter if you're building a REST API (e.g. with Express, koa or NestJS), a GraphQL API (e.g. with Apollo Server, TypeGraphQL or Nexus) or any other kind of application that uses Sequelize for database access.\n\nPrisma ORM lends itself really well for **incremental adoption**. This means, you don't have migrate your entire project from Sequelize to Prisma ORM at once, but rather you can _step-by-step_ move your database queries from Sequelize to Prisma ORM.\n\n## Overview of the sample project[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#overview-of-the-sample-project \"Direct link to Overview of the sample project\")\n\nFor this guide, we'll use a REST API built with Express as a [sample project](https://github.com/prisma/migrate-from-sequelize-to-prisma) to migrate to Prisma ORM. It has four models/entities:\n\n*   User.js\n*   Post.js\n*   Profile.js\n*   Category.js\n\n```\nmodule.exports = (sequelize, DataTypes) => {  const User = sequelize.define('User', {    name: {      type: DataTypes.STRING,    },    email: {      type: DataTypes.STRING,      unique: true,      allowNull: false,    },  })  User.associate = (models) => {    User.hasMany(models.Post, {      foreignKey: 'authorId',      as: 'posts',    })    User.hasOne(models.Profile, {      onDelete: 'CASCADE',      foreignKey: 'userId',    })  }  return User}\n```\n\nThe models have the following relations:\n\n*   1-1: `User` ↔ `Profile`\n*   1-n: `User` ↔ `Post`\n*   m-n: `Post` ↔ `Category`\n\nThe corresponding tables have been created using a generated Sequelize migration.\n\nIn this guide, the route handlers are located in the `src/controllers` directory. The models are located in the `src/models` directory. From there, they are pulled into a central `src/routes.js` file which is used to set up the required routes in `src/index.js`:\n\n```\n└── blog-sequelize    ├── package.json    └──src        ├── controllers        │   ├── post.js        │   └── user.js        ├── models        │   ├── Category.js        │   ├── Post.js        │   ├── Profile.js        │   └── User.js        ├── index.js        └── routes.js\n```\n\n## Step 1. Install the Prisma CLI[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#step-1-install-the-prisma-cli \"Direct link to Step 1. Install the Prisma CLI\")\n\nThe first step to adopt Prisma ORM is to [install the Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli#installation) in your project:\n\n```\nnpm install prisma --save-dev\n```\n\n## Step 2. Introspect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#step-2-introspect-your-database \"Direct link to Step 2. Introspect your database\")\n\n### 2.1. Set up Prisma ORM[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#21-set-up-prisma-orm \"Direct link to 2.1. Set up Prisma ORM\")\n\nBefore you can introspect your database, you need to set up your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) and connect Prisma ORM to your database. Run the following command in your terminal to create a basic Prisma schema file:\n\nThis command created a new directory called `prisma` with the following files for you:\n\n*   `schema.prisma`: Your Prisma schema that specifies your database connection and models\n*   `.env`: A [`dotenv`](https://github.com/motdotla/dotenv) to configure your database connection URL as an environment variable\n\nThe Prisma schema currently looks as follows:\n\nprisma/schema.prisma\n\n```\n// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemadatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\ntip\n\nIf you're using VS Code, be sure to install the [Prisma VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) for syntax highlighting, formatting, auto-completion and a lot more cool features.\n\n### 2.2. Connect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#22-connect-your-database \"Direct link to 2.2. Connect your database\")\n\nIf you're not using PostgreSQL, you need to adjust the `provider` field on the `datasource` block to the database you currently use:\n\n*   PostgreSQL\n*   MySQL\n*   Microsoft SQL Server\n*   SQLite\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nOnce that's done, you can configure your [database connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) in the `.env` file. Here's how the database connection from Sequelize maps to the connection URL format used by Prisma ORM:\n\n*   PostgreSQL\n*   MySQL\n*   Microsoft SQL Server\n*   SQLite\n\nAssume you have the following database connection details in `src/models/index.js`:\n\nsrc/models/index.js\n\n```\nconst sequelize = new Sequelize('blog-sequelize', 'alice', 'myPassword42', {  host: 'localhost',  dialect: 'postgres',})\n```\n\nThe respective connection URL would look as follows in Prisma ORM:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://alice:myPassword42@localhost:5432/blog-sequelize\"\n```\n\nNote that you can optionally configure the PostgreSQL [schema](https://www.postgresql.org/docs/9.1/ddl-schemas.html) by appending the `schema` argument to the connection URL:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://alice:myPassword42@localhost:5432/blog-sequelize?schema=myschema\"\n```\n\nIf not provided, the default schema called `public` is being used.\n\n  \n\n### 2.3. Introspect your database using Prisma ORM[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#23-introspect-your-database-using-prisma-orm \"Direct link to 2.3. Introspect your database using Prisma ORM\")\n\nWith your connection URL in place, you can [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) your database to generate your Prisma models:\n\nThis creates the following Prisma models:\n\nprisma/schema.prisma\n\n```\nmodel Categories {  id             Int              @id @default(autoincrement())  name           String  createdAt      DateTime  updatedAt      DateTime  PostCategories PostCategories[]}model PostCategories {  createdAt  DateTime  updatedAt  DateTime  CategoryId Int  PostId     Int  Categories Categories @relation(fields: [CategoryId], references: [id])  Posts      Posts      @relation(fields: [PostId], references: [id])  @@id([CategoryId, PostId])}model Posts {  id             Int              @id @default(autoincrement())  title          String  content        String?  published      Boolean?         @default(false)  createdAt      DateTime  updatedAt      DateTime  authorId       Int?  Users          Users?           @relation(fields: [authorId], references: [id])  PostCategories PostCategories[]}model Profiles {  id        Int      @id @default(autoincrement())  bio       String  createdAt DateTime  updatedAt DateTime  userId    Int?     @unique  Users     Users?   @relation(fields: [userId], references: [id])}model SequelizeMeta {  name String @id}model Users {  id        Int       @id @default(autoincrement())  name      String?  email     String    @unique  createdAt DateTime  updatedAt DateTime  Posts     Posts[]  Profiles  Profiles?}\n```\n\n### 2.4. Create a baseline migration[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#24-create-a-baseline-migration \"Direct link to 2.4. Create a baseline migration\")\n\nTo continue using Prisma Migrate to evolve your database schema, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\n```\nmkdir -p prisma/migrations/0_init\n```\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n*   `--from-empty`: assumes the data model you're migrating from is empty\n*   `--to-schema-datamodel`: the current database state using the URL in the `datasource` block\n*   `--script`: output a SQL script\n\n```\nnpx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql\n```\n\nReview the generated migration to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\n```\nnpx prisma migrate resolve --applied 0_init\n```\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.\n\n### 2.5. Adjust `createdAt` and `updatedAt` fields[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#25-adjust-createdat-and-updatedat-fields \"Direct link to 25-adjust-createdat-and-updatedat-fields\")\n\nThe generated Prisma models represent your database tables and are the foundation for your programmatic Prisma Client API which allows you to send queries to your database. You'll adjust the `createdAt` and `updatedAt` fields in our models. Sequelize doesn't add the `DEFAULT` constraint to `createdAt` when creating the tables in the database. Therefore, you'll add `@default(now())` and `@updatedAt` attributes to the `createdAt` and `updatedAt` columns respectively. To learn more how Prisma ORM does this, you can read more [`@default(now())`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#now) and [`@updatedAt`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#updatedat) here. Our updated schema will be as follows:\n\nprisma/schema.prisma\n\n```\nmodel Categories {  id             Int              @id @default(autoincrement())  name           String  createdAt      DateTime         @default(now())  updatedAt      DateTime         @updatedAt  PostCategories PostCategories[]}model PostCategories {  createdAt  DateTime   @default(now())  updatedAt  DateTime   @updatedAt  CategoryId Int  PostId     Int  Categories Categories @relation(fields: [CategoryId], references: [id])  Posts      Posts      @relation(fields: [PostId], references: [id])  @@id([CategoryId, PostId])}model Posts {  id             Int              @id @default(autoincrement())  title          String  content        String?  published      Boolean?         @default(false)  createdAt      DateTime         @default(now())  updatedAt      DateTime         @updatedAt  authorId       Int?  Users          Users?           @relation(fields: [authorId], references: [id])  PostCategories PostCategories[]}model Profiles {  id        Int      @id @default(autoincrement())  bio       String  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  userId    Int?     @unique  Users     Users?   @relation(fields: [userId], references: [id])}model SequelizeMeta {  name String @id}model Users {  id        Int       @id @default(autoincrement())  name      String?  email     String    @unique  createdAt DateTime  @default(now())  updatedAt DateTime  @updatedAt  Posts     Posts[]  Profiles  Profiles?}\n```\n\n### 2.6. Adjust the Prisma schema (optional)[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#26-adjust-the-prisma-schema-optional \"Direct link to 2.6. Adjust the Prisma schema (optional)\")\n\nThe models that were generated via introspection currently _exactly_ map to your database tables. In this section, you'll learn how you can adjust the naming of the Prisma models to adhere to [Prisma ORM's naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions).\n\nAll of these adjustment are entirely optional and you are free to skip to the next step already if you don't want to adjust anything for now. You can go back and make the adjustments at any later point.\n\nAs opposed to the current snake\\_case notation of Prisma models, Prisma ORM's naming conventions are:\n\n*   PascalCase for model names\n*   camelCase for field names\n\nYou can adjust the naming by _mapping_ the Prisma model and field names to the existing table and column names in the underlying database using `@@map` and `@map`.\n\nAlso note that you can rename [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) to optimize the Prisma Client API that you'll use later to send queries to your database. For example, although we are singularizing the `Posts` model name to `Post`, the `posts` field on the `user` model is a _list_, so it makes sense to keep that named `posts` to indicate that it's plural.\n\nSequelize generates a `SequelizeMeta` model that is used internally by the library that is not needed. Therefore, you'll manually delete it from the schema.\n\nHere's an adjusted version of the Prisma schema that addresses these points:\n\nprisma/schema.prisma\n\n```\ngenerator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model Category {  id             Int                @id @default(autoincrement())  name           String  createdAt      DateTime           @default(now())  updatedAt      DateTime           @updatedAt  postCategories PostToCategories[]  @@map(\"Categories\")}model PostToCategories {  createdAt  DateTime @default(now())  updatedAt  DateTime @updatedAt  categoryId Int  postId     Int  category   Category @relation(fields: [categoryId], references: [id])  post       Post     @relation(fields: [postId], references: [id])  @@id([categoryId, postId])  @@map(\"PostCategories\")}model Post {  id               Int                @id @default(autoincrement())  title            String  content          String?  published        Boolean?           @default(false)  createdAt        DateTime           @default(now())  updatedAt        DateTime           @updatedAt  authorId         Int?  author           User?              @relation(fields: [authorId], references: [id])  postToCategories PostToCategories[]  @@map(\"Posts\")}model Profile {  id        Int      @id @default(autoincrement())  bio       String  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  userId    Int?     @unique  user      User?    @relation(fields: [userId], references: [id])  @@map(\"Profiles\")}model User {  id        Int      @id @default(autoincrement())  name      String?  email     String   @unique  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  posts     Post[]  profile   Profile?  @@map(\"Users\")}\n```\n\n## Step 3. Install Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#step-3-install-prisma-client \"Direct link to Step 3. Install Prisma Client\")\n\nAs a next step, you can install Prisma Client in your project so that you can start replacing the database queries in your project that are currently made with Sequelize:\n\n```\nnpm install @prisma/client\n```\n\n## Step 4. Replace your Sequelize queries with Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#step-4-replace-your-sequelize-queries-with-prisma-client \"Direct link to Step 4. Replace your Sequelize queries with Prisma Client\")\n\nIn this section, we'll show a few sample queries that are being migrated from Sequelize to Prisma Client based on the example routes from the sample REST API project. For a comprehensive overview of how the Prisma Client API differs from Sequelize, check out the [API comparison](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#api-comparison) page.\n\nFirst, to set up the `PrismaClient` instance that you'll use to send database queries from the various route handlers. Create a new file named `prisma.js` in the `src` directory:\n\nNow, instantiate `PrismaClient` and export it from the file so you can use it in your route handlers later:\n\nsrc/prisma.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()module.exports = prisma\n```\n\nThe imports in our controller files are as follows:\n\nsrc/controllers/post.js\n\n```\nconst { Post, User, Category } = require('../models')const { Op } = require('sequelize')\n```\n\nsrc/controllers/user.js\n\n```\nconst { User } = require('../models')\n```\n\nYou'll update the controller imports as you migrate from Sequelize to Prisma:\n\nsrc/controllers/post.js\n\n```\nconst prisma = require('../prisma')\n```\n\nsrc/controllers/user.js\n\n```\nconst prisma = require('../prisma')\n```\n\n### 4.1. Replacing queries in `GET` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#41-replacing-queries-in-get-requests \"Direct link to 41-replacing-queries-in-get-requests\")\n\nThe REST API has four routes that accept `GET` requests:\n\n*   `/feed`: Return all published posts\n*   `/filterPosts?searchString=SEARCH_STRING`: Filter returned posts by `SEARCH_STRING`\n*   `/post/:postId`: Returns a specific post\n*   `/authors`: Returns a list of authors\n\nLet's dive into the route handlers that implement these requests.\n\n#### `/feed`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#feed \"Direct link to feed\")\n\nThe `/feed` handler is currently implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst feed = async (req, res) => {  try {    const feed = await Post.findAll({      where: { published: true },      include: ['author', 'categories'],    })    return res.json(feed)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that each returned `Post` object includes the relation to the `author` and `category` it's associated with. With Sequelize, including the relation is not type-safe. For example, if there was a typo in the relation that is retrieved, your database query would fail only at _runtime_ – the JavaScript compiler does not provide any safety here.\n\nHere is how the same route is implemented using Prisma Client:\n\nsrc/controllers/post.js\n\n```\nconst feed = async (req, res) => {  try {    const feed = await prisma.post.findMany({      where: { published: true },      include: { author: true, postToCategories: true },    })    return res.json(feed)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that the way how Prisma Client includes the `author` relation is absolutely type-safe. The JavaScript compiler would throw an error if you were trying to include a relation that does not exist on the `Post` model.\n\n#### `/filterPosts?searchString=SEARCH_STRING`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#filterpostssearchstringsearch_string \"Direct link to filterpostssearchstringsearch_string\")\n\nThe `/filterPosts` handler is currently implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst filterPosts = async (req, res) => {  const { searchString } = req.query  try {    const filteredPosts = await Post.findAll({      where: {        [Op.or]: [          {            title: {              [Op.like]: `%${searchString}%`,            },          },          {            content: {              [Op.like]: `%${searchString}%`,            },          },        ],      },      include: 'author',    })    res.json(filteredPosts)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst filterPosts = async (req, res) => {  const { searchString } = req.query  try {    const filteredPosts = prisma.post.findMany({      where: {        OR: [          {            title: { contains: searchString },          },          {            content: { contains: searchString },          },        ],      },    })    res.json(filteredPosts)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that Sequelize provides [Operator symbols](https://sequelize.org/master/variable/index.html#static-variable-Op) - `Op` - to be used when querying data. Prisma ORM on the other hand [combines several `where` conditions with an implicit `AND` operator](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-content-field-contains-prisma-and-published-is-false-no-and), so in this case the Prisma Client query needs to make the `OR` explicit.\n\n#### `/post/:postId`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#postpostid \"Direct link to postpostid\")\n\nThe `/post/:postId` handler is currently implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst getPostById = async (req, res) => {  const { postId } = req.params  try {    const post = await Post.findOne({      where: { id: postId },      include: 'author',    })    return res.json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst getPostById = async (req, res) => {  const { postId } = req.params  try {    const post = await prisma.post.findUnique({      where: { id: Number(postId) },      include: { author: true },    })    return res.json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\n### 4.2. Replacing queries in `POST` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#42-replacing-queries-in-post-requests \"Direct link to 42-replacing-queries-in-post-requests\")\n\nThe REST API has three routes that accept `POST` requests:\n\n*   `/user`: Creates a new `User` record\n*   `/post`: Creates a new `User` record\n*   `/user/:userId/profile`: Creates a new `Profile` record for a `User` record with a given ID\n\n#### `/user`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#user \"Direct link to user\")\n\nThe `/user` handler is currently implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst createUser = async (req, res) => {  const { name, email } = req.body  try {    const user = await User.create({      name,      email,    })    return res.json(user)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst createUser = async (req, res) => {  const { name, email } = req.body  try {    const user = await prisma.user.create({      data: {        name,        email,      },    })    return res.json(user)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\n#### `/post`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#post \"Direct link to post\")\n\nThe `/post` handler is currently implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst createDraft = async (req, res) => {  const { title, content, authorEmail } = req.body  try {    const user = await User.findOne({ email: authorEmail })    const draft = await Post.create({      title,      content,      authorId: user.id,    })    res.json(draft)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst createDraft = async (req, res) => {  const { title, content, authorEmail } = req.body  try {    const draft = await prisma.post.create({      data: {        title,        content,        author: {          connect: { email: authorEmail },        },      },    })    res.json(draft)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that Prisma Client's nested write here save an initial query where first the `User` record needs to be retrieved by its `email`. That's because, with Prisma Client you can connect records in relations using any unique property.\n\n#### `/user/:userId/profile`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#useruseridprofile \"Direct link to useruseridprofile\")\n\nThe `/user/:userId/profile` handler is currently implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst setUserBio = async (req, res) => {  const { userId } = req.params  const { bio } = req.body  try {    const user = await User.findOne({      where: {        id: Number(userId),      },    })    const updatedUser = await user.createProfile({ bio })    return res.json(updatedUser)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/user.js\n\n```\nconst setUserBio = async (req, res) => {  const { userId } = req.params  const { bio } = req.body  try {    const user = await prisma.user.update({      where: { id: Number(userId) },      data: {        profile: {          create: { bio },        },      },    })    return res.json(user)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\n### 4.3. Replacing queries in `PUT` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#43-replacing-queries-in-put-requests \"Direct link to 43-replacing-queries-in-put-requests\")\n\nThe REST API has one route that accept a `PUT` request:\n\n*   `/addPostToCategory?postId=POST_ID&categoryId=CATEGORY_ID`: Adds the post with `POST_ID` to the category with `CATEGORY_ID`\n\nLet's dive into the route handlers that implement these requests.\n\n#### `/addPostToCategory?postId=POST_ID&categoryId=CATEGORY_ID`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#addposttocategorypostidpost_idcategoryidcategory_id \"Direct link to addposttocategorypostidpost_idcategoryidcategory_id\")\n\nThe `/addPostToCategory?postId=POST_ID&categoryId=CATEGORY_ID` handler is currently implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst addPostToCategory = async (req, res) => {  const { postId, categoryId } = req.query  try {    const post = await Post.findOne({      where: { id: postId },    })    const category = await Category.findOne({      where: { id: categoryId },    })    const updatedPost = await post.addCategory(category)    return res.json(updatedPost)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/post.js\n\n```\nconst addPostToCategory = async (req, res) => {  const { postId, categoryId } = req.query  try {    const post = await prisma.post.update({      data: {        postToCategories: {          create: {            categories: {              connect: { id: Number(categoryId) },            },          },        },      },      where: {        id: Number(postId),      },    })    return res.json(post)  } catch (error) {    return res.status(500).json(error)  }}\n```\n\nNote that this Prisma Client can be made less verbose by modeling the relation as an [implicit many-to-many relation](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#implicit-many-to-many-relations) instead. In that case, the query would look as follows:\n\nsrc/controllers/posts.js\n\n```\nconst post = await prisma.post.update({  data: {    category: {      connect: { id: categoryId },    },  },  where: { id: postId },})\n```\n\n## More[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#more \"Direct link to More\")\n\n### Primary key column[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#primary-key-column \"Direct link to Primary key column\")\n\nBy default, Sequelize defines a `primaryKey` and used `id` with the autoby default if not defined. This is optional. If you would like to set your own primary key, you can use the `primaryKey: true` and define your preferred data type in your field of choice:\n\n```\n// changing the primary key columnmodule.exports = (sequelize, DataTypes) => {  const Post = sequelize.define('Post', {    postId: {      type: DataTypes.INTEGER,      primaryKey: true,    },  })  return Post}// changing the id DataTypemodule.exports = (sequelize, DataTypes) => {  const Post = sequelize.define('Post', {    id: {      type: DataTypes.UUID, // alternative: DataTypes.STRING      primaryKey: true,    },  })  return Post}\n```\n\n### Table name inference[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#table-name-inference \"Direct link to Table name inference\")\n\nSequelize infers table names from the model name. When the name of a table isn't provided Sequelize automatically pluralizes the model name and uses that as the table name using a library called [inflection](https://www.npmjs.com/package/inflection). Prisma ORM on the other hand maps the model name to the table name in your database [modelling your data](https://www.prisma.io/docs/orm/prisma-schema/data-model/models). If you wish to change this default behaviour in Sequelize, you can either enforce the table name to be equal to the model name or provide the table name directly:\n\n```\n// enforcing table name to be equal to model namemodule.exports = (sequelize, DataTypes) => {  const Post = sequelize.define(    'Post',    {      // ... attributes    },    {      freezeTableName: true,    }  )  return Post}\n```\n\n```\n// providing the table name directlymodule.exports = (sequelize, DataTypes) => {  const Post = sequelize.define(    'Post',    {      // ... attributes    },    {      tableName: 'Post',    }  )  return Post}\n```\n\n### Timestamps[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#timestamps \"Direct link to Timestamps\")\n\nSequelize automatically adds the fields `createdAt` and `updatedAt` to every model using the data type `DataTypes.DATE`, by default. You can disable this for a model with the `timestamps: false` option:\n\n```\nsequelize.define(  'User',  {    // ... (attributes)  },  {    timestamps: false,  })\n```\n\nPrisma ORM offers you the flexibility to define these fields in your model. You add the `createdAt` and [`updatedAt`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#updatedat) fields by defining them explicitly in your model. To set the `createdAt` field in your model, add the `default(now())` attribute to the column. In order to set the `updatedAt` column, update your model by adding the `@updatedAt` attribute to the column.\n\n```\nmodel User {  id        Int      @id @default(autoincrement())  name      String?  email     String   @unique  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt}\n```\n\n### Implicit many-to-many relations[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-sequelize#implicit-many-to-many-relations \"Direct link to Implicit many-to-many relations\")\n\nSimilar to the `belongsToMany()` association method in Sequelize, Prisma ORM allows you to [model many-to-many relations _implicitly_](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations). That is, a many-to-many relation where you do not have to manage the [relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables) (also sometimes called JOIN table) _explicitly_ in your schema. Here is an example with Sequelize:\n\n```\nmodule.exports = (sequelize, DataTypes) => {  const Post = sequelize.define('Post', {    title: {      type: DataTypes.STRING,      allowNull: false,    },    content: {      type: DataTypes.STRING,    },    published: {      type: DataTypes.BOOLEAN,      defaultValue: false,    },  })  Post.associate = (models) => {    Post.belongsTo(models.User, {      foreignKey: 'authorId',      as: 'author',    })    Post.belongsToMany(models.Category, {      through: 'PostCategories',      as: 'categories',    })  }  return Post}\n```\n\n```\nmodule.exports = (sequelize, DataTypes) => {  const Category = sequelize.define('Category', {    name: {      type: DataTypes.STRING,      allowNull: false,    },  })  Category.associate = (models) => {    Category.belongsToMany(models.Post, {      through: 'PostCategories',      as: 'posts',    })  }  return Category}\n```\n\nWhen you start your application, Sequelize will create the the tables for you - based on these models:\n\n```\nExecuting (default): CREATE TABLE IF NOT EXISTS \"PostCategories\"(\"createdAt\" TIMESTAMP WITH TIME ZONE NOT NULL, \"updatedAt\" TIMESTAMP WITH TIME ZONE NOT NULL,\"CategoryId\" INTEGER  REFERENCES \"Categories\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE,\"PostId\" INTEGER  REFERENCES \"Posts\" (\"id\") ON DELETE CASCADE ON UPDATE CASCADE, PRIMARY KEY (\"CategoryId\",\"PostId\"));\n```\n\nIf you introspect the database with Prisma ORM, you'll get the following result in the Prisma schema (note that some relation field names have been adjusted to look friendlier compared to the raw version from introspection):\n\n```\nmodel Categories {  id             Int              @id @default(autoincrement())  name           String  createdAt      DateTime  updatedAt      DateTime  PostCategories PostCategories[]  @@map(\"category\")}model PostCategories {  createdAt  DateTime  updatedAt  DateTime  CategoryId Int  PostId     Int  Categories Categories @relation(fields: [CategoryId], references: [id])  Posts      Posts      @relation(fields: [PostId], references: [id])  @@id([CategoryId, PostId])  @@map(\"PostCategories\")}model Posts {  id             Int              @id @default(autoincrement())  title          String  content        String?  published      Boolean?         @default(false)  createdAt      DateTime  updatedAt      DateTime  authorId       Int?  Users          Users?           @relation(fields: [authorId], references: [id])  PostCategories PostCategories[]  @@map(\"post\")}\n```\n\nIn this Prisma schema, the many-to-many relation is modeled explicitly via the relation table `PostCategories`\n\nBy adhering to the conventions for Prisma relation tables, the relation could look as follows:\n\n```\nmodel Categories {  id    Int     @id @default(autoincrement())  name  String  posts Posts[]  @@map(\"category\")}model Posts {  id         Int          @id @default(autoincrement())  title      String  content    String?  published  Boolean      @default(false)  authorId   Int?  author     User?        @relation(fields: [authorId], references: [id])  categories Categories[]  @@map(\"post\")}\n```\n\nThis would also result in a more ergonomic and less verbose Prisma Client API to modify the records in this relation, because you have a direct path from `Post` to `Category` (and the other way around) instead of needing to traverse the `PostCategories` model first.",
  "title": "How to migrate from Sequelize to Prisma ORM | Prisma Documentation",
  "description": "Learn how to migrate from Sequelize to Prisma ORM",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle",
  "markdown": "# Prisma ORM vs Drizzle | Prisma Documentation\n\nThis page compares Prisma ORM and Drizzle.\n\n## Drizzle vs Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#drizzle-vs-prisma-orm \"Direct link to Drizzle vs Prisma ORM\")\n\nWhile Prisma ORM and Drizzle solve similar problems, they work in very different ways and have individual pros and cons. Which one to choose will depend on the needs of your project and the exact tradeoffs that are important for it.\n\n**Drizzle** is a traditional SQL query builder that lets you compose SQL queries with JavaScript/TypeScript functions. It can be used to query a database or run migrations. Drizzle also offers a Queries API, which offers a higher level abstraction from SQL and can be used to read nested relations. Drizzle schema is defined in TypeScript files, which are used to generate SQL migrations and are then executed against a database.\n\n**Prisma ORM** mitigates many problems of traditional ORMs, such as bloated model instances, mixing business with storage logic, lack of type-safety or unpredictable queries caused e.g. by lazy loading. It uses the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) to define application models in a declarative way. Prisma Migrate then allows the generation of SQL migrations from the Prisma schema and executes them against the database. CRUD queries are provided by Prisma Client, a lightweight and entirely type-safe database client for Node.js and TypeScript.\n\n## Type safety[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#type-safety \"Direct link to Type safety\")\n\nDrizzle is not _fully_ type safe. As quoted on this [comparison study](https://github.com/thetutlage/meta/discussions/8) done by a 3rd party, \"Drizzle gives the impression of type-safety. However, only the query results have type information. You can write invalid queries with Drizzle.\"\n\nWith Prisma, you get _full_ type safety thanks to the generated types. This means, less potential for errors when writing code and collaborating with team members.\n\n## API design & Level of abstraction[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#api-design--level-of-abstraction \"Direct link to API design & Level of abstraction\")\n\nDrizzle and Prisma ORM operate on different levels of abstraction. Drizzle's philosophy is \"If you know SQL, you know Drizzle ORM\". It mirrors SQL in its API while Prisma Client provides a higher-level abstraction that was designed with the common tasks of application developers in mind. Prisma ORM's API design heavily leans on the idea of [making the right thing easy](https://jason.energy/right-thing-easy-thing/).\n\nWhile Prisma Client operates on a higher level of abstraction, you are able to drop down to [raw SQL](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries) at any time. However, full use of Prisma ORM and development of your application does not require SQL knowledge. Prisma ORM's goal is to construct a query syntax focused on developer experience and productivity that feels familiar to developers. You can learn more about this here: [Why Prisma](https://www.prisma.io/docs/orm/overview/introduction/why-prisma#application-developers-should-care-about-data--not-sql).\n\nThe following sections examine a few examples of how Prisma ORM's and Drizzle's APIs differ in certain scenarios and what the rationale of Prisma ORM's API design is in these cases.\n\n### Data modeling[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#data-modeling \"Direct link to Data modeling\")\n\nPrisma models are defined in the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema), while Drizzle uses TypeScript functions for table definitions. These functions are then exported and used in queries.\n\nPrisma generates a lightweight database client that exposes a tailored and fully type-safe API to read and write data for the models that are defined in the Prisma schema, following the DataMapper ORM pattern.\n\nPrisma ORM's DSL for data modeling is lean, simple and intuitive to use. When modeling data in VS Code, you can further take advantage of Prisma ORM's powerful [VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) with features like autocompletion, quick fixes, jump to definition and other benefits that increase developer productivity. On the other hand, Drizzle's use of TypeScript means that you can lean on the power of TypeScript for additional flexibility (via reused code, for example).\n\n**Prisma ORM**\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  name  String?  email String  @unique  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  authorId  Int?  author    User?   @relation(fields: [authorId], references: [id])}\n```\n\n**Drizzle**\n\n```\nimport {  boolean,  integer,  pgTable,  serial,  text,  uniqueIndex,  varchar,} from 'drizzle-orm/pg-core'export const users = pgTable('users', {  id: serial('id').primaryKey(),  name: varchar('name', { length: 256 }),  email: varchar('email', { length: 256 }).unique(),})export const posts = pgTable('posts', {  id: serial('id').primaryKey(),  title: varchar('title', { length: 256 }).notNull(),  content: text('content'),  published: boolean('published'),  authorId: integer('author_id').references(() => users.id),})\n```\n\n### Migrations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#migrations \"Direct link to Migrations\")\n\nMigrations work similarly between Drizzle and Prisma ORM. Both tools follow the approach of generating SQL files based on the provided model definitions and provide a CLI to execute them against the database. The SQL files can be modified before the migrations are executed so that any custom database operation can be performed with either migration system.\n\n### Querying[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#querying \"Direct link to Querying\")\n\nPlain queries are natural to construct in both Drizzle and Prisma ORM. Using Drizzle's Queries API, the two approaches are very similar:\n\n**Prisma ORM**\n\n```\n// find all usersconst allUsers = await prisma.user.findMany()// find a single userconst user = await prisma.user.findFirst({  where: { id: 27 },})// find a unique userconst user = await prisma.user.findUnique({  where: { email: 'nilu@prisma.io' },})\n```\n\n**Drizzle**\n\n```\nimport { eq } from 'drizzle-orm'// find all usersconst allUsers = await db.query.users.findMany()// find a single userconst user = await db.query.users.findFirst({  where: eq(users.id, 1),})// find a unique postconst user = await db.query.users.findFirst({  where: eq(users.email, 'nilu@prisma.io'),})\n```\n\nWhen performing a mutation, a `create`, `update`, or `delete`, the Drizzle Queries API is not available. In these cases, you will need to use Drizzle's SQL-like APIs:\n\n**Prisma ORM**\n\n```\n// create a userconst user = await prisma.user.create({  data: {    name: 'Nilu',    email: 'nilu@prisma.io',  },})// update a userconst user = await prisma.user.update({  where: { email: 'nilu@prisma.io' },  data: { name: 'Another Nilu' },})// delete a userconst deletedUser = await prisma.user.delete({  where: { email: 'nilu@prisma.io' },})\n```\n\n**Drizzle**\n\n```\n// create a userconst user = await db.insert(users).values({  name: 'Nilu',  email: 'nilu@prisma.io',})// update a userconst user = await db  .update(users)  .set({ name: 'Another Nilu' })  .where(eq(users.email, 'nilu@prisma.io'))  .returning()// delete a userconst deletedUser = await db  .delete(users)  .where(eq(users.email, 'nilu@prisma.io'))  .returning()\n```\n\n### Relations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#relations \"Direct link to Relations\")\n\nWorking with records that are connected via foreign keys can become very complex in SQL. Prisma ORM's concept of [virtual relation field](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) enables an intuitive and convenient way for application developers to work with related data. Some benefits of Prisma ORM's approach are:\n\n*   traversing relationships via the fluent API ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api))\n*   nested writes that enable updating/creating connected records ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes))\n*   applying filters on related records ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-filters))\n*   easy and type-safe querying of nested data without worrying about underlying SQL ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads))\n*   creating nested TypeScript typings based on models and their relations ([docs](https://www.prisma.io/docs/orm/prisma-client/type-safety))\n*   intuitive modeling of relations in the data model via relation fields ([docs](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations))\n*   implicit handling of relation tables (also sometimes called JOIN, link, pivot or junction tables) ([docs](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations))\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  include: {    author: true,  },})\n```\n\n**Drizzle**\n\n```\nconst posts = await db.query.posts.findMany({  with: {    author: true,  },})\n```\n\n### Filtering[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#filtering \"Direct link to Filtering\")\n\nDrizzle exposes the underlying filter and conditional operators for a given SQL dialect. Prisma ORM on the other hand, provides a more [generic set of operators](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-conditions-and-operators) that are intuitive to use.\n\nA good example of how the filtering APIs of both Drizzle and Prisma ORM differ is by looking at `string` filters. While Drizzle provides filters for `like` and `ilike`, Prisma ORM provides more specific operators that developers can use, e.g.: `contains`, `startsWith` and `endsWith`.\n\n**Prisma ORM**\n\n```\n// case sensitive filterconst posts = await prisma.post.findMany({  where: {    title: 'Hello World',  },})// case insensitive filterconst posts = await prisma.post.findMany({  where: {    title: 'Hello World',    mode: 'insensitive',  },})\n```\n\n**Drizzle**\n\n```\n// case sensitive filterconst posts = await db  .select()  .from(posts)  .where(like(posts.title, 'Hello World'))// case insensitive filterconst posts = await db  .select()  .from(posts)  .where(ilike(posts.title, 'Hello World'))\n```\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: {      contains: 'Hello World',    },  },})\n```\n\n**Drizzle**\n\n```\nconst posts = await db  .select()  .from(posts)  .where(ilike(posts.title, '%Hello World%'))\n```\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: {      startsWith: 'Hello World',    },  },})\n```\n\n**Drizzle**\n\n```\nconst posts = await db  .select()  .from(posts)  .where(ilike(posts.title, 'Hello World%'))\n```\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: {      endsWith: 'Hello World',    },  },})\n```\n\n**Drizzle**\n\n```\nconst posts = await db  .select()  .from(posts)  .where(ilike(posts.title, '%Hello World'))\n```\n\nDrizzle only offers limit-offset pagination while Prisma ORM conveniently provides dedicated APIs for both limit-offset but also cursor-based. You can learn more about both approaches in the [Pagination](https://www.prisma.io/docs/orm/prisma-client/queries/pagination) section of the docs.\n\n**Prisma ORM**\n\n```\n// limit-offset paginationconst postPage = await prisma.post.findMany({  where: {    title: 'Hello World',  },  skip: 6,  take: 3,})// cursor-based paginationconst postPage = await prisma.post.findMany({  where: {    title: 'Hello World',  },  cursor: { id: 7 },  take: 3,})\n```\n\n**Drizzle**\n\n```\n// limit-offset pagination (cursor-based not currently possible)const postPage = await db  .select()  .from(users)  .where(ilike(posts.title, 'Hello World%'))  .limit(3)  .offset(6)\n```\n\n### Observability[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#observability \"Direct link to Observability\")\n\nBoth Drizzle and Prisma ORM have the ability to log queries and the underlying SQL generated.\n\nPrisma ORM has additional features built into the client that help teams get a better understanding of their data usage. [Metrics](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics) and [tracing](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing) are two features that can be enabled at any time and give you per query information. This information can be integrated with external tools so that you can track performance over time.\n\n## Additional products[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#additional-products \"Direct link to Additional products\")\n\nBoth Drizzle and Prisma offer products alongside an ORM. Prisma Studio was released to allow users to interact with their database via a GUI and also allows for limited self-hosting for use within a team. Drizzle Studio was released to accomplish the same tasks.\n\nIn addition to Prisma Studio, Prisma offers commercial products via the Prisma Data Platform:\n\n*   [Prisma Accelerate](https://prisma.io/data-platform/accelerate): A connection pooler and global cache that integrates with Prisma ORM. Users can take advantage of connection pooling immediately and can control caching at an individual query level.\n*   [Prisma Pulse](https://prisma.io/data-platform/pulse): A change data capture (CDC) service where Prisma Client can subscribe to database changes and receive them in real-time with little to no setup.\n\nThese products work hand-in-hand with Prisma ORM to offer comprehensive data tooling, making building data-driven applications easy by following [Data DX](https://datadx.io/) principles.\n\n## Ecosystem[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#ecosystem \"Direct link to Ecosystem\")\n\nBoth Drizzle and Prisma ORM have cases where users want to do something not directly supported by the library. Drizzle relies on the expressiveness of SQL to avoid these cases, while Prisma ORM has [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) to allow any user to add additional behaviors to their instance of Prisma Client. These extensions are also shareable, meaning teams can develop them for use across their projects or even for use by other teams.\n\nWhile Drizzle is a relatively new product, Prisma ORM was [released in 2021](https://www.prisma.io/blog/prisma-the-complete-orm-inw24qjeawmb) and is well established in the JavaScript/TypeScript space. It has proven value and many companies trust [Prisma ORM in production](http://prisma.io/showcase).\n\nPrisma ORM is also included as the data layer tool of choice in many meta-frameworks and development platforms like [Amplication](https://amplication.com/), [Wasp](https://wasp-lang.dev/), [RedwoodJS](https://redwoodjs.com/), [KeystoneJS](https://keystonejs.com/), [Remix](https://remix.run/) and the [t3 stack](https://create.t3.gg/).\n\nThanks to its maturity, Prisma's community has developed a [plethora of useful tools](https://www.prisma.io/ecosystem) that helps with various Prisma workflows. Here are a few highlights:\n\n*   [`zenstack`](https://zenstack.dev/): Toolkit that extends Prisma with access control policies in the Prisma schema, auto-generated CRUD APIs and frontend query hooks.\n*   [`prisma-erd-generator`](https://github.com/keonik/prisma-erd-generator#prisma-entity-relationship-diagram-generator): Visualizes the Prisma schema as an entity-relationship-diagram (ERD).\n*   [`prisma-zod-generator`](https://github.com/omar-dulaimi/prisma-zod-generator): Generates [Zod](https://github.com/colinhacks/zod) schemas from the Prisma schema.\n*   [`bridg`](https://github.com/joeroddy/bridg): Let's you access your database from the frontend using Prisma Client.\n*   [`jest-prisma`](https://github.com/Quramy/jest-prisma): Environment for Prisma integrated testing with [Jest](https://jestjs.io/).\n*   [`prisma-pothos-types`](https://github.com/hayes/pothos/tree/main/packages/plugin-prisma): Creates GraphQL types based on Prisma models when using [GraphQL Pothos](https://github.com/hayes/pothos/tree/main).\n*   [`prisma-trpc-generator`](https://github.com/omar-dulaimi/prisma-trpc-generator): Creates [tRPC](https://trpc.io/) routers from your Prisma schema.\n*   [`@cerbos/orm-prisma`](https://github.com/cerbos/query-plan-adapters/tree/main/prisma): Filter data based on authorization policies from [Cerbos](https://cerbos.dev/).\n\n## Database support[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#database-support \"Direct link to Database support\")\n\nBoth Drizzle and Prisma ORM support multiple and different kinds of databases. Drizzle achieves this support through driver implementations created by Drizzle, which integrate with existing third-party database drivers.\n\nPrisma ORM has begun adding support for [third-party database drivers](https://www.prisma.io/blog/serverless-database-drivers-KML1ehXORxZV), but primarily uses [built-in drivers](https://www.prisma.io/docs/orm/more/under-the-hood/engines#the-query-engine-at-runtime) to communicate with an underlying database. Prisma also defaults connections to TLS, which improves security.\n\nAdditionally, Prisma ORM supports CockroachDB, Microsoft SQL Server, and MongoDB, which Drizzle does not currently support. Prisma ORM also offers the [relation mode](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode) that allows Prisma ORM to emulate foreign key constraints for those database engines that do not support it. Drizzle currently supports Cloudflare D1, `bun:sqlite`, and SQLite via HTTP Proxy, which Prisma ORM currently does not.\n\n## Benchmarks[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#benchmarks \"Direct link to Benchmarks\")\n\nWe understand that performance is a key consideration when selecting an ORM. To compare performance of various ORMs, you can use the open-source [database latency benchmark tool](https://pris.ly/benchmark) hosted by Vercel.\n\nThis tool allows you to evaluate the latency and throughput of various ORMs under different workloads and configurations. By running the benchmarks against the databases or database providers you are considering, you can get a clear picture of their relative performance characteristics to help make an informed decision.\n\n## Conclusion[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-drizzle#conclusion \"Direct link to Conclusion\")\n\nBoth Drizzle ORM and Prisma ORM are tools for data access and migrations. Drizzle is focused on being a thin wrapper around a SQL-like syntax while Prisma is focused on a convenient and expressive API. Other important differences include Prisma ORM's support of MSSQL and MongoDB, support for additional features via [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions), additional cloud-ready products, and a robust ecosystem.\n\nFor teams that use SQL daily, Drizzle offers a convenient wrapper that will feel familiar and is type-safe. Prisma ORM's `$queryRaw` feature, while available, does not provide the same level of type safety. However, the experience of writing raw SQL in Prisma ORM can be enhanced using the [SafeQL](https://safeql.dev/compatibility/prisma.html) community plugin for Prisma ORM, offering syntax highlighting and type-checking in your editor as well.\n\nOn the other hand, for teams that are a mix of developers (front-end, back-end, and full-stack) that have varying levels of experience with databases, Prisma ORM offers a comprehensive and easy-to-learn approach for data access and managing database schemas.",
  "title": "Prisma ORM vs Drizzle | Prisma Documentation",
  "description": "Learn how Prisma ORM compares to Drizzle.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm",
  "markdown": "# How to migrate from TypeORM to Prisma ORM\n\nThis guide describes how to migrate from TypeORM to Prisma ORM. It uses an extended version of the [TypeORM Express example](https://github.com/typeorm/typescript-express-example/) as a [sample project](https://github.com/prisma/migrate-from-typeorm-to-prisma) to demonstrate the migration steps. You can find the example used for this guide on [GitHub](https://github.com/prisma/migrate-from-typeorm-to-prisma).\n\nThis migration guide uses PostgreSQL as the example database, but it equally applies to any other relational database that's [supported by Prisma ORM](https://www.prisma.io/docs/orm/reference/supported-databases).\n\nYou can learn how Prisma ORM compares to TypeORM on the [Prisma ORM vs TypeORM](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm) page.\n\n## Overview of the migration process[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#overview-of-the-migration-process \"Direct link to Overview of the migration process\")\n\nNote that the steps for migrating from TypeORM to Prisma ORM are always the same, no matter what kind of application or API layer you're building:\n\n1.  Install the Prisma CLI\n2.  Introspect your database\n3.  Create a baseline migration\n4.  Install Prisma Client\n5.  Gradually replace your TypeORM queries with Prisma Client\n\nThese steps apply, no matter if you're building a REST API (e.g. with Express, koa or NestJS), a GraphQL API (e.g. with Apollo Server, TypeGraphQL or Nexus) or any other kind of application that uses TypeORM for database access.\n\nPrisma ORM lends itself really well for **incremental adoption**. This means, you don't have migrate your entire project from TypeORM to Prisma ORM at once, but rather you can _step-by-step_ move your database queries from TypeORM to Prisma ORM.\n\n## Overview of the sample project[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#overview-of-the-sample-project \"Direct link to Overview of the sample project\")\n\nFor this guide, we'll use a REST API built with Express as a [sample project](https://github.com/prisma/migrate-from-typeorm-to-prisma) to migrate to Prisma ORM. It has four models/entities:\n\n*   User.ts\n*   Post.ts\n*   Profile.ts\n*   Category.ts\n\n```\n@Entity()export class User {  @PrimaryGeneratedColumn()  id: number  @Column({ nullable: true })  name: string  @Column({ unique: true })  email: string  @OneToMany((type) => Post, (post) => post.author)  posts: Post[]  @OneToOne((type) => Profile, (profile) => profile.user, { cascade: true })  profile: Profile}\n```\n\nThe models have the following relations:\n\n*   1-1: `User` ↔ `Profile`\n*   1-n: `User` ↔ `Post`\n*   m-n: `Post` ↔ `Category`\n\nThe corresponding tables have been created using a generated TypeORM migration.\n\nExpand to view details of the migration\n\nThe migration has been created using\n\n```\ntypeorm migration:generate -n Init\n```\n\nThis created the following migration file:\n\nmigrations/1605698662257-Init.ts\n\n```\nimport { MigrationInterface, QueryRunner } from 'typeorm'export class Init1605698662257 implements MigrationInterface {  name = 'Init1605698662257'  public async up(queryRunner: QueryRunner): Promise<void> {    await queryRunner.query(      `CREATE TABLE \"profile\" (\"id\" SERIAL NOT NULL, \"bio\" character varying, \"userId\" integer, CONSTRAINT \"REL_a24972ebd73b106250713dcddd\" UNIQUE (\"userId\"), CONSTRAINT \"PK_3dd8bfc97e4a77c70971591bdcb\" PRIMARY KEY (\"id\"))`    )    await queryRunner.query(      `CREATE TABLE \"user\" (\"id\" SERIAL NOT NULL, \"name\" character varying, \"email\" character varying NOT NULL, CONSTRAINT \"UQ_e12875dfb3b1d92d7d7c5377e22\" UNIQUE (\"email\"), CONSTRAINT \"PK_cace4a159ff9f2512dd42373760\" PRIMARY KEY (\"id\"))`    )    await queryRunner.query(      `CREATE TABLE \"post\" (\"id\" SERIAL NOT NULL, \"title\" character varying NOT NULL, \"content\" character varying, \"published\" boolean NOT NULL DEFAULT false, \"authorId\" integer, CONSTRAINT \"PK_be5fda3aac270b134ff9c21cdee\" PRIMARY KEY (\"id\"))`    )    await queryRunner.query(      `CREATE TABLE \"category\" (\"id\" SERIAL NOT NULL, \"name\" character varying NOT NULL, CONSTRAINT \"PK_9c4e4a89e3674fc9f382d733f03\" PRIMARY KEY (\"id\"))`    )    await queryRunner.query(      `CREATE TABLE \"post_categories_category\" (\"postId\" integer NOT NULL, \"categoryId\" integer NOT NULL, CONSTRAINT \"PK_91306c0021c4901c1825ef097ce\" PRIMARY KEY (\"postId\", \"categoryId\"))`    )    await queryRunner.query(      `CREATE INDEX \"IDX_93b566d522b73cb8bc46f7405b\" ON \"post_categories_category\" (\"postId\") `    )    await queryRunner.query(      `CREATE INDEX \"IDX_a5e63f80ca58e7296d5864bd2d\" ON \"post_categories_category\" (\"categoryId\") `    )    await queryRunner.query(      `ALTER TABLE \"profile\" ADD CONSTRAINT \"FK_a24972ebd73b106250713dcddd9\" FOREIGN KEY (\"userId\") REFERENCES \"user\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION`    )    await queryRunner.query(      `ALTER TABLE \"post\" ADD CONSTRAINT \"FK_c6fb082a3114f35d0cc27c518e0\" FOREIGN KEY (\"authorId\") REFERENCES \"user\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION`    )    await queryRunner.query(      `ALTER TABLE \"post_categories_category\" ADD CONSTRAINT \"FK_93b566d522b73cb8bc46f7405bd\" FOREIGN KEY (\"postId\") REFERENCES \"post\"(\"id\") ON DELETE CASCADE ON UPDATE NO ACTION`    )    await queryRunner.query(      `ALTER TABLE \"post_categories_category\" ADD CONSTRAINT \"FK_a5e63f80ca58e7296d5864bd2d3\" FOREIGN KEY (\"categoryId\") REFERENCES \"category\"(\"id\") ON DELETE CASCADE ON UPDATE NO ACTION`    )  }  public async down(queryRunner: QueryRunner): Promise<void> {    await queryRunner.query(      `ALTER TABLE \"post_categories_category\" DROP CONSTRAINT \"FK_a5e63f80ca58e7296d5864bd2d3\"`    )    await queryRunner.query(      `ALTER TABLE \"post_categories_category\" DROP CONSTRAINT \"FK_93b566d522b73cb8bc46f7405bd\"`    )    await queryRunner.query(      `ALTER TABLE \"post\" DROP CONSTRAINT \"FK_c6fb082a3114f35d0cc27c518e0\"`    )    await queryRunner.query(      `ALTER TABLE \"profile\" DROP CONSTRAINT \"FK_a24972ebd73b106250713dcddd9\"`    )    await queryRunner.query(`DROP INDEX \"IDX_a5e63f80ca58e7296d5864bd2d\"`)    await queryRunner.query(`DROP INDEX \"IDX_93b566d522b73cb8bc46f7405b\"`)    await queryRunner.query(`DROP TABLE \"post_categories_category\"`)    await queryRunner.query(`DROP TABLE \"category\"`)    await queryRunner.query(`DROP TABLE \"post\"`)    await queryRunner.query(`DROP TABLE \"user\"`)    await queryRunner.query(`DROP TABLE \"profile\"`)  }}\n```\n\nAs mentioned before, this guide is an extended variation of the TypeORM Express example and uses the same file structure. The route handlers are located in the `src/controller` directory. From there, they are pulled into a central `src/routes.ts` file which is used to set up the required routes in `src/index.ts`:\n\n```\n└── blog-typeorm    ├── ormconfig.json    ├── package.json    ├── src    │   ├── controllers    │   │   ├── AddPostToCategoryAction.ts    │   │   ├── CreateDraftAction.ts    │   │   ├── CreateUserAction.ts    │   │   ├── FeedAction.ts    │   │   ├── FilterPostsAction.ts    │   │   ├── GetPostByIdAction.ts    │   │   └── SetBioForUserAction.ts    │   ├── entity    │   │   ├── Category.ts    │   │   ├── Post.ts    │   │   ├── Profile.ts    │   │   └── User.ts    │   ├── index.ts    │   ├── migration    │   │   └── 1605698662257-Init.ts    │   └── routes.ts    └── tsconfig.json\n```\n\n## Step 1. Install the Prisma CLI[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#step-1-install-the-prisma-cli \"Direct link to Step 1. Install the Prisma CLI\")\n\nThe first step to adopt Prisma ORM is to [install the Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli#installation) in your project:\n\n```\nnpm install prisma --save-dev\n```\n\n## Step 2. Introspect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#step-2-introspect-your-database \"Direct link to Step 2. Introspect your database\")\n\n### 2.1. Set up Prisma ORM[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#21-set-up-prisma-orm \"Direct link to 2.1. Set up Prisma ORM\")\n\nBefore you can introspect your database, you need to set up your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) and connect Prisma to your database. Run the following command in your terminal to create a basic Prisma schema file:\n\nThis command created a new directory called `prisma` with the following files for you:\n\n*   `schema.prisma`: Your Prisma schema that specifies your database connection and models\n*   `.env`: A [`dotenv`](https://github.com/motdotla/dotenv) to configure your database connection URL as an environment variable\n\nThe Prisma schema currently looks as follows:\n\nprisma/schema.prisma\n\n```\n// This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemadatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\ntip\n\nIf you're using VS Code, be sure to install the [Prisma VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) for syntax highlighting, formatting, auto-completion and a lot more cool features.\n\n### 2.2. Connect your database[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#22-connect-your-database \"Direct link to 2.2. Connect your database\")\n\nIf you're not using PostgreSQL, you need to adjust the `provider` field on the `datasource` block to the database you currently use:\n\n*   PostgreSQL\n*   MySQL\n*   Microsoft SQL Server\n*   SQLite\n\nschema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nOnce that's done, you can configure your [database connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) in the `.env` file. Here's how the database connection from TypeORM maps to the connection URL format used by Prisma ORM:\n\n*   PostgreSQL\n*   MySQL\n*   Microsoft SQL Server\n*   SQLite\n\nAssume you have the following database connection details in `ormconfig.json`:\n\normconfig.json\n\n```\n{  \"type\": \"postgres\",  \"host\": \"localhost\",  \"port\": 5432,  \"username\": \"alice\",  \"password\": \"myPassword42\",  \"database\": \"blog-typeorm\"}\n```\n\nThe respective connection URL would look as follows in Prisma ORM:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://alice:myPassword42@localhost:5432/blog-typeorm\"\n```\n\nNote that you can optionally configure the PostgreSQL [schema](https://www.postgresql.org/docs/9.1/ddl-schemas.html) by appending the `schema` argument to the connection URL:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://alice:myPassword42@localhost:5432/blog-typeorm?schema=myschema\"\n```\n\nIf not provided, the default schema called `public` is being used.\n\n  \n\n### 2.3. Introspect your database using Prisma ORM[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#23-introspect-your-database-using-prisma-orm \"Direct link to 2.3. Introspect your database using Prisma ORM\")\n\nWith your connection URL in place, you can [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) your database to generate your Prisma models:\n\nThis creates the following Prisma models:\n\nprisma/schema.prisma\n\n```\nmodel typeorm_migrations {  id        Int    @id @default(autoincrement())  timestamp Int  name      String  @@map(\"_typeorm_migrations\")}model category {  id                       Int                        @id @default(autoincrement())  name                     String  post_categories_category post_categories_category[]}model post {  id                       Int                        @id @default(autoincrement())  title                    String  content                  String?  published                Boolean                    @default(false)  authorId                 Int?  user                     user?                      @relation(fields: [authorId], references: [id])  post_categories_category post_categories_category[]}model post_categories_category {  postId     Int  categoryId Int  category   category @relation(fields: [categoryId], references: [id])  post       post     @relation(fields: [postId], references: [id])  @@id([postId, categoryId])  @@index([postId], name: \"IDX_93b566d522b73cb8bc46f7405b\")  @@index([categoryId], name: \"IDX_a5e63f80ca58e7296d5864bd2d\")}model profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int?    @unique  user   user?   @relation(fields: [userId], references: [id])}model user {  id      Int      @id @default(autoincrement())  name    String?  email   String   @unique  post    post[]  profile profile?}\n```\n\nThe generated Prisma models represent your database tables and are the foundation for your programmatic Prisma Client API which allows you to send queries to your database.\n\n### 2.4. Create a baseline migration[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#24-create-a-baseline-migration \"Direct link to 2.4. Create a baseline migration\")\n\nTo continue using Prisma Migrate to evolve your database schema, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\n```\nmkdir -p prisma/migrations/0_init\n```\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n*   `--from-empty`: assumes the data model you're migrating from is empty\n*   `--to-schema-datamodel`: the current database state using the URL in the `datasource` block\n*   `--script`: output a SQL script\n\n```\nnpx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql\n```\n\nReview the generated migration to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\n```\nnpx prisma migrate resolve --applied 0_init\n```\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.\n\n### 2.5. Adjust the Prisma schema (optional)[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#25-adjust-the-prisma-schema-optional \"Direct link to 2.5. Adjust the Prisma schema (optional)\")\n\nThe models that were generated via introspection currently _exactly_ map to your database tables. In this section, you'll learn how you can adjust the naming of the Prisma models to adhere to [Prisma ORM's naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions).\n\nAll of these adjustment are entirely optional and you are free to skip to the next step already if you don't want to adjust anything for now. You can go back and make the adjustments at any later point.\n\nAs opposed to the current snake\\_case notation of TypeORM models, Prisma ORM's naming conventions are:\n\n*   PascalCase for model names\n*   camelCase for field names\n\nYou can adjust the naming by _mapping_ the Prisma model and field names to the existing table and column names in the underlying database using `@@map` and `@map`.\n\nAlso note that you can rename [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) to optimize the Prisma Client API that you'll use later to send queries to your database. For example, the `post` field on the `user` model is a _list_, so a better name for this field would be `posts` to indicate that it's plural.\n\nYou can further completely remove model that represents the TypeORM migrations table (called `_typeorm_migrations` here) from the Prisma schema.\n\nHere's an adjusted version of the Prisma schema that addresses these points:\n\nprisma/schema.prisma\n\n```\nmodel Category {  id                Int                @id @default(autoincrement())  name              String  postsToCategories PostToCategories[]  @@map(\"category\")}model Post {  id                Int                @id @default(autoincrement())  title             String  content           String?  published         Boolean            @default(false)  authorId          Int?  author            User?              @relation(fields: [authorId], references: [id])  postsToCategories PostToCategories[]  @@map(\"post\")}model PostToCategories {  postId     Int  categoryId Int  category   Category @relation(fields: [categoryId], references: [id])  post       Post     @relation(fields: [postId], references: [id])  @@id([postId, categoryId])  @@index([postId], name: \"IDX_93b566d522b73cb8bc46f7405b\")  @@index([categoryId], name: \"IDX_a5e63f80ca58e7296d5864bd2d\")  @@map(\"post_categories_category\")}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int?    @unique  user   User?   @relation(fields: [userId], references: [id])  @@map(\"profile\")}model User {  id      Int      @id @default(autoincrement())  name    String?  email   String   @unique  posts   Post[]  profile Profile?  @@map(\"user\")}\n```\n\n## Step 3. Install Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#step-3-install-prisma-client \"Direct link to Step 3. Install Prisma Client\")\n\nAs a next step, you can install Prisma Client in your project so that you can start replacing the database queries in your project that are currently made with TypeORM:\n\n```\nnpm install @prisma/client\n```\n\n## Step 4. Replace your TypeORM queries with Prisma Client[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#step-4-replace-your-typeorm-queries-with-prisma-client \"Direct link to Step 4. Replace your TypeORM queries with Prisma Client\")\n\nIn this section, we'll show a few sample queries that are being migrated from TypeORM to Prisma Client based on the example routes from the sample REST API project. For a comprehensive overview of how the Prisma Client API differs from TypeORM, check out the [API comparison](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#api-comparison) page.\n\nFirst, to set up the `PrismaClient` instance that you'll use to send database queries from the various route handlers. Create a new file named `prisma.ts` in the `src` directory:\n\nNow, instantiate `PrismaClient` and export it from the file so you can use it in your route handlers later:\n\nsrc/prisma.ts\n\n```\nimport { PrismaClient } from '@prisma/client'export const prisma = new PrismaClient()\n```\n\n### 4.1. Replacing queries in `GET` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#41-replacing-queries-in-get-requests \"Direct link to 41-replacing-queries-in-get-requests\")\n\nThe REST API has three routes that accept `GET` requests:\n\n*   `/feed`: Return all published posts\n*   `/filterPosts?searchString=SEARCH_STRING`: Filter returned posts by `SEARCH_STRING`\n*   `/post/:postId`: Returns a specific post\n\nLet's dive into the route handlers that implement these requests.\n\n#### `/feed`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#feed \"Direct link to feed\")\n\nThe `/feed` handler is currently implemented as follows:\n\nsrc/controllers/FeedAction.ts\n\n```\nimport { getManager } from 'typeorm'import { Post } from '../entity/Post'export async function feedAction(req, res) {  const postRepository = getManager().getRepository(Post)  const publishedPosts = await postRepository.find({    where: { published: true },    relations: ['author'],  })  res.send(publishedPosts)}\n```\n\nNote that each returned `Post` object includes the relation to the `author` it's associated with. With TypeORM, including the relation is not type-safe. For example, if there was a typo in the relation that is retrieved, your database query would fail only at _runtime_ – the TypeScript compiler does not provide any safety here.\n\nHere is how the same route is implemented using Prisma Client:\n\nsrc/controllers/FeedAction.ts\n\n```\nimport { prisma } from '../prisma'export async function feedAction(req, res) {  const publishedPosts = await prisma.post.findMany({    where: { published: true },    include: { author: true },  })  res.send(publishedPosts)}\n```\n\nNote that the way how Prisma Client includes the `author` relation is absolutely type-safe. The TypeScript compiler would throw an error if you were trying to include a relation that does not exist on the `Post` model.\n\n#### `/filterPosts?searchString=SEARCH_STRING`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#filterpostssearchstringsearch_string \"Direct link to filterpostssearchstringsearch_string\")\n\nThe `/filterPosts` handler is currently implemented as follows:\n\nsrc/controllers/FilterPostsActions.ts\n\n```\nimport { getManager, Like } from 'typeorm'import { Post } from '../entity/Post'export async function filterPostsAction(req, res) {  const { searchString } = req.query  const postRepository = getManager().getRepository(Post)  const filteredPosts = await postRepository.find({    where: [      { title: Like(`%${searchString}%`) },      { content: Like(`%${searchString}%`) },    ],  })  res.send(filteredPosts)}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/FilterPostsActions.ts\n\n```\nimport { prisma } from '../prisma'export async function filterPostsAction(req, res) {  const { searchString } = req.query  const filteredPosts = prisma.post.findMany({    where: {      OR: [        {          title: { contains: searchString },        },        {          content: { contains: searchString },        },      ],    },  })  res.send(filteredPosts)}\n```\n\nNote that TypeORM by default combines several `where` conditions with an implicit `OR` operator. Prisma ORM on the other hand [combines several `where` conditions with an implicit `AND` operator](https://www.prisma.io/docs/orm/reference/prisma-client-reference#get-all-post-records-where-the-content-field-contains-prisma-and-published-is-false-no-and), so in this case the Prisma Client query needs to make the `OR` explicit.\n\n#### `/post/:postId`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#postpostid \"Direct link to postpostid\")\n\nThe `/post/:postId` handler is currently implemented as follows:\n\nsrc/controllers/GetPostByIdAction.ts\n\n```\nimport { getManager } from 'typeorm'import { Post } from '../entity/Post'export async function getPostByIdAction(req, res) {  const { postId } = req.params  const postRepository = getManager().getRepository(Post)  const post = await postRepository.findOne(postId)  res.send(post)}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/GetPostByIdAction.ts\n\n```\nimport { prisma } from '../prisma'export async function getPostByIdAction(req, res) {  const { postId } = req.params  const post = await prisma.post.findUnique({    where: { id: postId },  })  res.send(post)}\n```\n\n### 4.2. Replacing queries in `POST` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#42-replacing-queries-in-post-requests \"Direct link to 42-replacing-queries-in-post-requests\")\n\nThe REST API has three routes that accept `POST` requests:\n\n*   `/user`: Creates a new `User` record\n*   `/post`: Creates a new `Post` record\n*   `/user/:userId/profile`: Creates a new `Profile` record for a `User` record with a given ID\n\n#### `/user`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#user \"Direct link to user\")\n\nThe `/user` handler is currently implemented as follows:\n\nsrc/controllers/CreateUserAction.ts\n\n```\nimport { getManager } from 'typeorm'import { User } from '../entity/User'export async function createUserAction(req, res) {  const { name, email } = req.body  const userRepository = getManager().getRepository(User)  const newUser = new User()  newUser.name = name  newUser.email = email  userRepository.save(newUser)  res.send(newUser)}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/CreateUserAction.ts\n\n```\nimport { prisma } from '../prisma'export async function createUserAction(req, res) {  const { name, email } = req.body  const newUser = await prisma.user.create({    data: {      name,      email,    },  })  res.send(newUser)}\n```\n\n#### `/post`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#post \"Direct link to post\")\n\nThe `/post` handler is currently implemented as follows:\n\nsrc/controllers/CreateDraftAction.ts\n\n```\nimport { getManager } from 'typeorm'import { Post } from '../entity/Post'import { User } from '../entity/User'export async function createDraftAction(req, res) {  const { title, content, authorEmail } = req.body  const userRepository = getManager().getRepository(User)  const user = await userRepository.findOne({ email: authorEmail })  const postRepository = getManager().getRepository(Post)  const newPost = new Post()  newPost.title = title  newPost.content = content  newPost.author = user  postRepository.save(newPost)  res.send(newPost)}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/CreateDraftAction.ts\n\n```\nimport { prisma } from '../prisma'export async function createDraftAction(req, res) {  const { title, content, authorEmail } = req.body  const newPost = await prisma.post.create({    data: {      title,      content,      author: {        connect: { email: authorEmail },      },    },  })  res.send(newPost)}\n```\n\nNote that Prisma Client's nested write here save an initial query where first the `User` record needs to be retrieved by its `email`. That's because, with Prisma Client you can connect records in relations using any unique property.\n\n#### `/user/:userId/profile`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#useruseridprofile \"Direct link to useruseridprofile\")\n\nThe `/user/:userId/profile` handler is currently implemented as follows:\n\nsrc/controllers/SetBioForUserAction.ts.ts\n\n```\nimport { getManager } from 'typeorm'import { Profile } from '../entity/Profile'import { User } from '../entity/User'export async function setBioForUserAction(req, res) {  const { userId } = req.params  const { bio } = req.body  const userRepository = getManager().getRepository(User)  const user = await userRepository.findOne(userId, {    relations: ['profile'],  })  const profileRepository = getManager().getRepository(Profile)  user.profile.bio = bio  profileRepository.save(user.profile)  res.send(user)}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/SetBioForUserAction.ts.ts\n\n```\nimport { prisma } from '../prisma'export async function setBioForUserAction(req, res) {  const { userId } = req.params  const { bio } = req.body  const user = await prisma.user.update({    where: { id: userId },    data: {      profile: {        update: {          bio,        },      },    },  })  res.send(user)}\n```\n\n### 4.3. Replacing queries in `PUT` requests[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#43-replacing-queries-in-put-requests \"Direct link to 43-replacing-queries-in-put-requests\")\n\nThe REST API has one route that accept a `PUT` request:\n\n*   `/addPostToCategory?postId=POST_ID&categoryId=CATEGORY_ID`: Adds the post with `POST_ID` to the category with `CATEGORY_ID`\n\nLet's dive into the route handlers that implement these requests.\n\n#### `/addPostToCategory?postId=POST_ID&categoryId=CATEGORY_ID`[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#addposttocategorypostidpost_idcategoryidcategory_id \"Direct link to addposttocategorypostidpost_idcategoryidcategory_id\")\n\nThe `/addPostToCategory?postId=POST_ID&categoryId=CATEGORY_ID` handler is currently implemented as follows:\n\nsrc/controllers/AddPostToCategoryAction.ts\n\n```\nimport { getManager } from 'typeorm'import { Post } from '../entity/Post'import { Category } from '../entity/Category'export async function addPostToCategoryAction(req, res) {  const { postId, categoryId } = req.query  const postRepository = getManager().getRepository(Post)  const post = await postRepository.findOne(postId, {    relations: ['categories'],  })  const categoryRepository = getManager().getRepository(Category)  const category = await categoryRepository.findOne(categoryId)  post.categories.push(category)  postRepository.save(post)  res.send(post)}\n```\n\nWith Prisma ORM, the route is implemented as follows:\n\nsrc/controllers/AddPostToCategoryAction.ts\n\n```\nimport { prisma } from '../prisma'export async function addPostToCategoryAction(req, res) {  const { postId, categoryId } = req.query  const post = await prisma.post.update({    data: {      postsToCategories: {        create: {          category: {            connect: { id: categoryId },          },        },      },    },    where: {      id: postId,    },  })  res.send(post)}\n```\n\nNote that this Prisma Client can be made less verbose by modeling the relation as an [implicit many-to-many relation](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#implicit-many-to-many-relations) instead. In that case, the query would look as follows:\n\nsrc/controllers/AddPostToCategoryAction.ts\n\n```\nconst post = await prisma.post.update({  data: {    categories: {      connect: { id: categoryId },    },  },  where: { id: postId },})\n```\n\n## More[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#more \"Direct link to More\")\n\n### Implicit many-to-many relations[​](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm#implicit-many-to-many-relations \"Direct link to Implicit many-to-many relations\")\n\nSimilar to the `@manyToMany` decorator in TypeORM, Prisma ORM allows you to [model many-to-many relations _implicitly_](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations). That is, a many-to-many relation where you do not have to manage the [relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables) (also sometimes called JOIN table) _explicitly_ in your schema. Here is an example with TypeORM:\n\n```\nimport {  Entity,  PrimaryGeneratedColumn,  Column,  ManyToMany,  JoinTable,} from 'typeorm'import { Category } from './Category'@Entity()export class Post {  @PrimaryGeneratedColumn()  id: number  @ManyToMany((type) => Category, (category) => category.posts)  @JoinTable()  categories: Category[]}\n```\n\n```\nimport { Entity, PrimaryGeneratedColumn, Column, ManyToMany } from 'typeorm'import { Post } from './Post'@Entity()export class Category {  @PrimaryGeneratedColumn()  id: number  @ManyToMany((type) => Post, (post) => post.categories)  posts: Post[]}\n```\n\nIf you generate and run a migration with TypeORM based on these models, TypeORM will automatically create the following relation table for you:\n\n```\n-- Table Definition ----------------------------------------------CREATE TABLE post_categories_category (    \"postId\" integer REFERENCES post(id) ON DELETE CASCADE,    \"categoryId\" integer REFERENCES category(id) ON DELETE CASCADE,    CONSTRAINT \"PK_91306c0021c4901c1825ef097ce\" PRIMARY KEY (\"postId\", \"categoryId\"));-- Indices -------------------------------------------------------CREATE UNIQUE INDEX \"PK_91306c0021c4901c1825ef097ce\" ON post_categories_category(\"postId\" int4_ops,\"categoryId\" int4_ops);CREATE INDEX \"IDX_93b566d522b73cb8bc46f7405b\" ON post_categories_category(\"postId\" int4_ops);CREATE INDEX \"IDX_a5e63f80ca58e7296d5864bd2d\" ON post_categories_category(\"categoryId\" int4_ops);\n```\n\nIf you introspect the database with Prisma ORM, you'll get the following result in the Prisma schema (note that some relation field names have been adjusted to look friendlier compared to the raw version from introspection):\n\nschema.prisma\n\n```\nmodel Category {  id                Int                @id @default(autoincrement())  name              String  postsToCategories PostToCategories[]  @@map(\"category\")}model Post {  id                Int                @id @default(autoincrement())  title             String  content           String?  published         Boolean            @default(false)  authorId          Int?  author            User?              @relation(fields: [authorId], references: [id])  postsToCategories PostToCategories[]  @@map(\"post\")}model PostToCategories {  postId     Int  categoryId Int  category   Category @relation(fields: [categoryId], references: [id])  post       Post     @relation(fields: [postId], references: [id])  @@id([postId, categoryId])  @@index([postId], name: \"IDX_93b566d522b73cb8bc46f7405b\")  @@index([categoryId], name: \"IDX_a5e63f80ca58e7296d5864bd2d\")  @@map(\"post_categories_category\")}\n```\n\nIn this Prisma schema, the many-to-many relation is modeled _explicitly_ via the relation table `PostToCategories`.\n\nBy adhering to the conventions for Prisma ORM relation tables, the relation could look as follows:\n\nschema.prisma\n\n```\nmodel Category {  id    Int    @id @default(autoincrement())  name  String  posts Post[]  @@map(\"category\")}model Post {  id         Int        @id @default(autoincrement())  title      String  content    String?  published  Boolean    @default(false)  authorId   Int?  author     User?      @relation(fields: [authorId], references: [id])  categories Category[]  @@map(\"post\")}\n```\n\nThis would also result in a more ergonomic and less verbose Prisma Client API to modify the records in this relation, because you have a direct path from `Post` to `Category` (and the other way around) instead of needing to traverse the `PostToCategories` model first.\n\nwarning\n\nIf your database provider requires tables to have primary keys then you have to use explicit syntax, and manually create the join model with a primary key. This is because relation tables (JOIN tables) created by Prisma ORM (expressed via `@relation`) for many-to-many relations using implicit syntax do not have primary keys.",
  "title": "How to migrate from TypeORM to Prisma ORM | Prisma Documentation",
  "description": "Learn how to migrate from TypeORM to Prisma ORM",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma",
  "markdown": "# Deploying Prisma ORM-based projects | Prisma Documentation\n\n## Deploy Prisma ORM\n\nProjects using Prisma Client can be deployed to many different cloud platforms. Given the variety of cloud platforms and different names, it's noteworthy to mention the different deployment paradigms, as they affect the way you deploy an application using Prisma Client.\n\n## Deployment paradigms[​](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#deployment-paradigms \"Direct link to Deployment paradigms\")\n\nEach paradigm has different tradeoffs that affect the performance, scalability, and operational costs of your application.\n\nMoreover, the user traffic pattern of your application is also an important factor to consider. For example, any application with consistent user traffic may be better suited for a [continuously running paradigm](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#traditional-servers), whereas an application with sudden spikes may be better suited to [serverless](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#serverless-functions).\n\n### Traditional servers[​](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#traditional-servers \"Direct link to Traditional servers\")\n\nYour application is [traditionally deployed](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional) if a Node.js process is continuously running and handles multiple requests at the same time. Your application could be deployed to a Platform-as-a-Service (PaaS) like [Heroku](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku), [Koyeb](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb), as a Docker container to Kubernetes, or as a Node.js process on a virtual machine, or good old bare metal server.\n\nSee also: [Connection management in long-running processes](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#long-running-processes)\n\n### Serverless Functions[​](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#serverless-functions \"Direct link to Serverless Functions\")\n\nYour application is [serverless](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless) if the Node.js processes of your application (or subsets of it broken into functions) are started as requests come in, and each function only handles one request at a time. Your application would most likely be deployed to a Function-as-a-Service (FaaS) offering, such as [AWS Lambda](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda) or [Azure Functions](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-azure-functions)\n\nServerless environments have the concept of warm starts, which means that for subsequent invocations of the same function, it may use an already existing container that has the allocated processes, memory, file system (`/tmp` is writable on AWS Lambda), and even DB connection still available.\n\nTypically, any piece of code [outside the handler](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-features.html#gettingstarted-features-programmingmodel) remains initialized.\n\nSee also: [Connection management in serverless environments](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas)\n\n### Edge Functions[​](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#edge-functions \"Direct link to Edge Functions\")\n\nYour application is [edge deployed](https://www.prisma.io/docs/orm/prisma-client/deployment/edge) if your application is [serverless](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma#serverless-functions) and the functions are distributed across one or more regions close to the user.\n\nTypically, edge environments also have a different runtime than a traditional or serverless environment, leading to common APIs being unavailable.",
  "title": "Deploying Prisma ORM-based projects | Prisma Documentation",
  "description": "Learn more about the different deployment paradigms for Node.js applications and how they affect deploying an application using Prisma Client.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/traditional",
  "markdown": "# Deploy Prisma ORM apps to traditional (PaaS) servers\n\nIf your application is deployed via a Platform-as-a-Service (PaaS) provider, whether containerized or not, it is a traditionally-deployed app. Common deployment examples include [Heroku](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku) and [Koyeb](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb).\n\n## Traditional (PaaS) guides[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional#traditional-paas-guides \"Direct link to Traditional (PaaS) guides\")\n\n[\n\n## Deploy to Heroku\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku)\n\n[\n\n## Deploy to Koyeb\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb)",
  "title": "Deploy Prisma ORM apps to traditional (PaaS) servers | Prisma Documentation",
  "description": "Learn how to deploy your Prisma-backed apps to PaaS providers like Heroku, Koyeb, or AWS EC2",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/serverless",
  "markdown": "# Deploy Prisma ORM apps to serverless function (FaaS) providers\n\n## Serverless functions\n\nIf your application is deployed via a \"Serverless Function\" or \"Function-as-a-Service (FaaS)\" offering and uses a standard Node.js runtime, it is a serverless app. Common deployment examples include [AWS Lambda](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda) and [Vercel Serverless Functions](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-vercel).\n\n## Guides for Serverless Function providers[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless#guides-for-serverless-function-providers \"Direct link to Guides for Serverless Function providers\")\n\n[\n\n## Deploy to Azure Functions\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-azure-functions)\n\n[\n\n## Deploy to Vercel\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-vercel)\n\n[\n\n## Deploy to AWS Lambda\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda)\n\n[\n\n## Deploy to Netlify\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-netlify)",
  "title": "Deploy Prisma ORM apps to serverless function (FaaS) providers | Prisma Documentation",
  "description": "Learn how to deploy your Prisma ORM-backed apps to FaaS providers like AWS Lambda, Netlify, or Vercel Serverless Functions",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/edge",
  "markdown": "# Deploy Prisma ORM apps to edge function (distributed FaaS) providers\n\n## Edge functions\n\nIf your application is deployed via an \"Edge Function\" offering or is deployed from a [serverless](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless) offering and has a non-standard runtime, it is a _edge-deployed_ app. Common examples for such offerings include [Cloudflare Workers or Pages](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare), [Vercel Edge Functions or Edge Middleware](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel), and [Deno Deploy](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy).\n\n## In this section[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge#in-this-section \"Direct link to In this section\")\n\n[\n\n## Overview\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview)\n\n[\n\n## Deploy to Cloudflare\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare)\n\n[\n\n## Deploy to Vercel\n\n](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel)\n\n[](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy)",
  "title": "Deploy Prisma ORM apps to edge function (distributed FaaS) providers | Prisma Documentation",
  "description": "Learn how to deploy your Prisma ORM-backed apps to edge functions like Cloudflare Workers or Vercel Edge Functions",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/module-bundlers",
  "markdown": "# Module bundlers (Reference) | Prisma Documentation\n\n## Overview[​](https://www.prisma.io/docs/orm/prisma-client/deployment/module-bundlers#overview \"Direct link to Overview\")\n\n_Module bundlers_ bundle JavaScript modules into a single JavaScript file. Most bundlers work by copying over the JavaScript code from a variety of source files into the target file.\n\nSince Prisma Client is not only based on JavaScript code, but also relies on the [**query engine binary file**](https://www.prisma.io/docs/orm/more/under-the-hood/engines#the-query-engine-file) to be available, you need to make sure that your bundled code has access to the binary file.\n\nTo do so, you can use plugins that let you copy over static assets:\n\n| Bundler | Plugin |\n| --- | --- |\n| Webpack | [`copy-webpack-plugin`](https://github.com/webpack-contrib/copy-webpack-plugin#copy-webpack-plugin) |\n| Webpack (with [Next.js monorepo](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-monorepo)) | [`nextjs-monorepo-workaround-plugin`](https://www.npmjs.com/package/@prisma/nextjs-monorepo-workaround-plugin) |\n| Parcel | [`parcel-plugin-static-files-copy`](https://github.com/elwin013/parcel-plugin-static-files-copy#readme) |",
  "title": "Module bundlers (Reference) | Prisma Documentation",
  "description": "This page gives an overview of the most important things to be aware of when using a module bundler to bundle an application that uses Prisma Client.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-migrations-from-a-local-environment",
  "markdown": "# Deploy migrations from a local environment\n\nThere are two scenarios where you might consider deploying migrations directly from a local environment to a production environment.\n\nThis page outlines some examples of how you can do that and **why we would generally not recommend it**.\n\nIf you do not have an automated CI/CD process, you can technically deploy new migrations from your local environment to production in the following ways:\n\n```\n//delete-next-lineDATABASE_URL=\"postgresql://johndoe:randompassword@localhost:5432/my_local_database\"//add-next-lineDATABASE_URL=\"postgresql://johndoe:randompassword@localhost:5432/my_production_database\"\n```\n\nThe pipeline should handle deployment to staging and production environments, and use `migrate deploy` in a pipeline step. See the [deployment guides](https://www.prisma.io/docs/orm/prisma-client/deployment) for examples.\n\nWhen you add Prisma Migrate to an **existing database**, you must [baseline](https://www.prisma.io/docs/orm/prisma-migrate/workflows/baselining) the production database. Baselining is performed **once**, and can be done from a local instance.",
  "title": "Deploy migrations from a local environment | Prisma Documentation",
  "description": "Learn how to deploy Node.js and TypeScript applications that are using Prisma Client locally.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-database-changes-with-prisma-migrate",
  "markdown": "# Deploying database changes with Prisma Migrate\n\nTo apply pending migrations to staging, testing, or production environments, run the `migrate deploy` command as part of your CI/CD pipeline:\n\n```\nnpx prisma migrate deploy\n```\n\ninfo\n\nThis guide **does not apply for MongoDB**.  \nInstead of `migrate deploy`, [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) is used for [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb).\n\nExactly when to run `prisma migrate deploy` depends on your platform. For example, a simplified [Heroku](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku) workflow includes:\n\n1.  Ensuring the `./prisma/migration` folder is in source control\n2.  Running `prisma migrate deploy` during the [release phase](https://devcenter.heroku.com/articles/release-phase)\n\nIdeally, `migrate deploy` should be part of an automated CI/CD pipeline, and we do not generally recommend running this command locally to deploy changes to a production database (for example, by temporarily changing the `DATABASE_URL` environment variable). It is not generally considered good practice to store the production database URL locally.\n\nBeware that in order to run the `prisma migrate deploy` command, you need access to the `prisma` dependency that is typically added to the `devDependencies`. Some platforms like Vercel, prune development dependencies during the build, thereby preventing you from calling the command. This can be worked around by making the `prisma` a production dependency, by moving it to `dependencies` in your `package.json`. For more information about the `migrate deploy` command, see:\n\n*   [`migrate deploy` reference](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-deploy)\n*   [How `migrate deploy` works](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#production-and-testing-environments)\n*   [Production troubleshooting](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing)\n\n## Deploying database changes using GitHub Actions[​](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-database-changes-with-prisma-migrate#deploying-database-changes-using-github-actions \"Direct link to Deploying database changes using GitHub Actions\")\n\nAs part of your CI/CD, you can run `prisma migrate deploy` as part of your pipeline to apply pending migrations to your production database.\n\nHere is an example action that will run your migrations against your database:\n\ndeploy.yml\n\n```\nname: Deployon:  push:    paths:      - prisma/migrations/** # Only run this workflow when migrations are updated    branches:      - mainjobs:  deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout repo        uses: actions/checkout@v3      - name: Setup Node        uses: actions/setup-node@v3      - name: Install dependencies        run: npm install      - name: Apply all pending migrations to the database        run: npx prisma migrate deploy        env:          DATABASE_URL: ${{ secrets.DATABASE_URL }}\n```\n\nEnsure you have the `DATABASE_URL` variable [set as a secret in your repository](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions), without quotes around the connection string.",
  "title": "Deploying database changes with Prisma Migrate | Prisma Documentation",
  "description": "Learn how to deploy database changes with Prisma Migrate.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms",
  "markdown": "# Caveats when deploying to AWS platforms\n\nThe following describes some caveats you might face when deploying to different AWS platforms.\n\n## AWS RDS Proxy[​](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#aws-rds-proxy \"Direct link to AWS RDS Proxy\")\n\nPrisma ORM is compatible with AWS RDS Proxy. However, there is no benefit in using it for connection pooling with Prisma ORM due to the way RDS Proxy pins connections:\n\n> \"Your connections to the proxy can enter a state known as pinning. When a connection is pinned, each later transaction uses the same underlying database connection until the session ends. Other client connections also can't reuse that database connection until the session ends. The session ends when Prisma Client's connection is dropped.\" - [AWS RDS Proxy Docs](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy-managing.html#rds-proxy-pinning)\n\n[Prepared statements (of any size) or query statements greater than 16 KB cause RDS Proxy to pin the session.](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-proxy-managing.html#rds-proxy-pinning.all) Because Prisma ORM uses prepared statements for all queries, you won't see any benefit when using RDS Proxy with Prisma ORM.\n\n## AWS Elastic Beanstalk[​](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#aws-elastic-beanstalk \"Direct link to AWS Elastic Beanstalk\")\n\nAWS Elastic Beanstalk is a PaaS-like deployment service that abstracts away infrastructure and allows you to deploy applications to AWS quickly.\n\nWhen deploying an app using Prisma Client to AWS Elastic Beanstalk, Prisma ORM generates the Prisma Client code into `node_modules`. This is typically done in the `postinstall` hook.\n\nBecause Beanstalk limits the ability to write to the filesystem in the `postinstall` hook, you need to create an [`.npmrc`](https://docs.npmjs.com/cli/v6/configuring-npm/npmrc) file in the root of your project and add the following configuration:\n\n.npmrc\n\nEnabling `unsafe-perm` forces _npm_ to run as _root_, avoiding the filesystem access problem, thereby allowing the `prisma generate` command in the `postinstall` hook to generate code into `node_modules`.\n\n### Error: @prisma/client did not initialize yet[​](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#error-prismaclient-did-not-initialize-yet \"Direct link to Error: @prisma/client did not initialize yet\")\n\nThis error happens because AWS Elastic Beanstalk doesn't install `devDependencies`, which means that it doesn't pick up the Prisma CLI. To remedy this you can either:\n\n1.  Add the `prisma` CLI package to your `dependencies` instead of the `devDependencies`. (Making sure to run `npm install` afterward to update the `package-lock.json`).\n2.  Or install your `devDependencies` on AWS Elastic Beanstalk instances. To do this you must set the AWS Elastic Beanstalk `NPM_USE_PRODUCTION` environment property to false.\n\n## AWS Lambda upload limit[​](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#aws-lambda-upload-limit \"Direct link to AWS Lambda upload limit\")\n\nAWS Lambda defines an **deployment package upload limit**, which includes:\n\n*   All application code\n*   Binaries like the [Prisma ORM query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines)\n\nThe [deployment package (.zip) size limit for lambdas is 50MB](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html). When you prepare a deployment package, remove any files that the function does not require in production to keep the final .zip as small as possible. This includes some [Prisma ORM engine binaries](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#deleting-prisma-orm-engines-that-are-not-required).\n\n### Deleting Prisma ORM engines that are not required[​](https://www.prisma.io/docs/orm/prisma-client/deployment/caveats-when-deploying-to-aws-platforms#deleting-prisma-orm-engines-that-are-not-required \"Direct link to Deleting Prisma ORM engines that are not required\")\n\nPrisma CLI downloads additional engine binaries that are **not required** in production. You can delete the following files and folders:\n\n1.  The entire `node_modules/@prisma/engines` folder (refer to the [sample bash script](https://github.com/prisma/ecosystem-tests/blob/13e74dc47eababa5d3c8f488b73fe7fc8bffead7/platforms-serverless/lambda/run.sh#L16) used by the Prisma end-to-end tests)\n    \n2.  The **local engine file** for your development platform from the `node_modules/.prisma/client` folder. For example, your schema might define the following `binaryTargets` if you develop on Debian (`native`) but deploy to AWS Lambda (`rhel-openssl-3.0.x`):\n    \n    ```\n    binaryTargets = [\"native\", \"rhel-openssl-3.0.x\"]\n    ```\n    \n    In this scenario:\n    \n    *   Keep `node_modules/.prisma/client/query-engine-rhel-openssl-3.0.x`, which is the engine file used by AWS Lambda\n        \n    *   Delete `node_modules/.prisma/client/query-engine-debian-openssl-1.1.x`, which is only required locally\n        \n    \n    > **Note**: When using Node.js 18 or earlier, the correct `binaryTarget` for AWS Lambda is `rhel-openssl-1.0.x`. `rhel-openssl-3.0.x` is the correct `binaryTarget` for Node.js versions greater than 18.",
  "title": "Caveats when deploying to AWS platforms | Prisma Documentation",
  "description": "Known caveats when deploying to an AWS platform",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware",
  "markdown": "# Middleware (Reference) | Prisma Documentation\n\nwarning\n\n**Deprecated**: Middleware is deprecated in version 4.16.0.\n\nWe recommend using the [Prisma Client extensions `query` component type](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query) as an alternative to middleware. Prisma Client extensions were first introduced into Preview in version 4.7.0 and made Generally Available in 4.16.0.\n\nPrisma Client extensions allow you to create independent Prisma Client instances and bind each client to a specific filter or user. For example, you could bind clients to specific users to provide user isolation. Prisma Client extensions also provide end-to-end type safety.\n\nMiddlewares act as query-level lifecycle hooks, which allow you to perform an action before or after a query runs. Use the [`prisma.$use`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#use) method to add middleware, as follows:\n\n```\nconst prisma = new PrismaClient()// Middleware 1prisma.$use(async (params, next) => {  // Manipulate params here  const result = await next(params)  // See results here  return result})// Middleware 2prisma.$use(async (params, next) => {  // Manipulate params here  const result = await next(params)  // See results here  return result})// Queries here\n```\n\nwarning\n\nDo not invoke `next` multiple times within a middleware when using [batch transactions](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#sequential-prisma-client-operations). This will cause you to break out of the transaction and lead to unexpected results.\n\n[`params`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#params) represent parameters available in the middleware, such as the name of the query, and [`next`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#next) represents [the next middleware in the stack _or_ the original Prisma Client query](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware#running-order-and-the-middleware-stack).\n\nPossible use cases for middleware include:\n\n*   Setting or overwriting a field value - for example, [setting the context language of a blog post comment](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/session-data-middleware)\n*   Validating input data - for example, check user input for inappropriate language via an external service\n*   Intercept a `delete` query and change it to an `update` in order to perform a [soft delete](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/soft-delete-middleware)\n*   [Log the time taken to perform a query](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/logging-middleware)\n\nThere are many more use cases for middleware - this list serves as inspiration for the types of problems that middleware is designed to address.\n\n## Samples[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware#samples \"Direct link to Samples\")\n\nThe following sample scenarios show how to use middleware in practice:\n\n[\n\n## Middleware sample: soft delete\n\n](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/soft-delete-middleware)\n\n[\n\n## Middleware sample: logging\n\n](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/logging-middleware)\n\n[\n\n## Middleware sample: session data\n\n](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/session-data-middleware)\n\n## Where to add middleware[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware#where-to-add-middleware \"Direct link to Where to add middleware\")\n\nAdd Prisma Client middleware **outside the context of the request handler**, otherwise each request adds a new _instance_ of the middleware to the stack. The following example demonstrates where to add Prisma Client middleware in the context of an Express app:\n\n```\nimport express from 'express'import { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()prisma.$use(async (params, next) => {  // Manipulate params here  const result = await next(params)  // See results here  return result})const app = express()app.get('/feed', async (req, res) => {  // NO MIDDLEWARE HERE  const posts = await prisma.post.findMany({    where: { published: true },    include: { author: true },  })  res.json(posts)})\n```\n\n## Running order and the middleware stack[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware#running-order-and-the-middleware-stack \"Direct link to Running order and the middleware stack\")\n\nIf you have multiple middlewares, the running order for **each separate query** is:\n\n1.  All logic **before** `await next(params)` in each middleware, in descending order\n2.  All logic **after** `await next(params)` in each middleware, in ascending order\n\nDepending on where you are in the stack, `await next(params)` either:\n\n*   Runs the next middleware (in middlewares #1 and #2 in the example) _or_\n*   Runs the original Prisma Client query (in middleware #3)\n\n```\nconst prisma = new PrismaClient()// Middleware 1prisma.$use(async (params, next) => {  console.log(params.args.data.title)  console.log('1')  const result = await next(params)  console.log('6')  return result})// Middleware 2prisma.$use(async (params, next) => {  console.log('2')  const result = await next(params)  console.log('5')  return result})// Middleware 3prisma.$use(async (params, next) => {  console.log('3')  const result = await next(params)  console.log('4')  return result})const create = await prisma.post.create({  data: {    title: 'Welcome to Prisma Day 2020',  },})const create2 = await prisma.post.create({  data: {    title: 'How to Prisma!',  },})\n```\n\nOutput:\n\n```\nWelcome to Prisma Day 2020123456How to Prisma!123456\n```\n\n## Performance and appropriate use cases[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware#performance-and-appropriate-use-cases \"Direct link to Performance and appropriate use cases\")\n\nMiddleware executes for **every** query, which means that overuse has the potential to negatively impact performance. To avoid adding performance overheads:\n\n*   Check the `params.model` and `params.action` properties early in your middleware to avoid running logic unnecessarily:\n    \n    ```\n    prisma.$use(async (params, next) => {  if (params.model == 'Post' && params.action == 'delete') {    // Logic only runs for delete action and Post model  }  return next(params)})\n    ```\n    \n*   Consider whether middleware is the appropriate solution for your scenario. For example:\n    \n    *   If you need to populate a field, can you use the [`@default`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default) attribute?\n    *   If you need to set the value of a `DateTime` field, can you use the `now()` function or the `@updatedAt` attribute?\n    *   If you need to perform more complex validation, can you use a `CHECK` constraint in the database itself?",
  "title": "Middleware (Reference) | Prisma Documentation",
  "description": "Prisma Client middleware allows you to perform actions before or after any query on any model with the prisma.$use method.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-to-a-different-os",
  "markdown": "# Deploy to a different OS\n\nPrisma Client depends on the [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines) that is running as a binary on the same host as your application.\n\nThe query engine is implemented in Rust and is used by Prisma Client in the form of executable binary files. The binary is downloaded when `prisma generate` is called.\n\nIf you have developed your application on a Windows machine for example, and wish to upload to AWS Lambda, which is a Linux environment, you may encounter issues and be presented with some warnings in your terminal.\n\nTo solve this, if you know ahead of time that you will be deploying to a different environment, you can use the [binary targets](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#binary-targets) and specify which of the [supported operating systems](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#binarytargets-options) binaries should be included.\n\n> **Note**: If your OS isn't supported you can include a [custom binary](https://www.prisma.io/docs/orm/more/under-the-hood/engines#using-custom-engine-libraries-or-binaries).",
  "title": "Deploy to a different OS | Prisma Documentation",
  "description": "Learn how to deploy Node.js and TypeScript applications that are using Prisma Client to a different operating system.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/handling-exceptions-and-errors",
  "markdown": "# Handling exceptions and errors (Reference)\n\nIn order to handle different types of errors you can use `instanceof` to check what the error is and handle it accordingly.\n\nThe following example tries to create a user with an already existing email record. This will throw an error because the `email` field has the `@unique` attribute applied to it.\n\nUse the `Prisma` namespace to access the error type. The [error code](https://www.prisma.io/docs/orm/reference/error-reference#error-codes) can then be checked and a message can be printed.\n\n```\nimport { PrismaClient, Prisma } from '@prisma/client'const client = new PrismaClient()try {  await client.user.create({ data: { email: 'alreadyexisting@mail.com' } })} catch (e) {  if (e instanceof Prisma.PrismaClientKnownRequestError) {    // The .code property can be accessed in a type-safe manner    if (e.code === 'P2002') {      console.log(        'There is a unique constraint violation, a new user cannot be created with this email'      )    }  }  throw e}\n```\n\nSee [Errors reference](https://www.prisma.io/docs/orm/reference/error-reference) for a detailed breakdown of the different error types and their codes.",
  "title": "Handling exceptions and errors (Reference) | Prisma Documentation",
  "description": "This page covers how to handle exceptions and errors",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/overview/generators",
  "markdown": "# Generators (Reference) | Prisma Documentation\n\nA Prisma schema can have one or more generators, represented by the [`generator`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#generator) block:\n\n```\ngenerator client {  provider = \"prisma-client-js\"  output   = \"./generated/prisma-client-js\"}\n```\n\nA generator determines which assets are created when you run the `prisma generate` command. The main property `provider` defines which **Prisma Client (language specific)** is created - currently, only `prisma-client-js` is available. Alternatively you can define any npm package that follows our generator specification. Additionally and optionally you can define a custom output folder for the generated assets with `output`.\n\n## Prisma Client: `prisma-client-js`[​](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#prisma-client-prisma-client-js \"Direct link to prisma-client-prisma-client-js\")\n\nThe generator for Prisma's JavaScript Client accepts multiple additional properties:\n\n*   `previewFeatures`: [Preview features](https://www.prisma.io/docs/orm/reference/preview-features) to include\n*   `binaryTargets`: Engine binary targets for `prisma-client-js` (for example, `debian-openssl-1.1.x` if you are deploying to Ubuntu 18+, or `native` if you are working locally)\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"sample-preview-feature\"]  binaryTargets   = [\"linux-musl\"]}\n```\n\n### Binary targets[​](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#binary-targets \"Direct link to Binary targets\")\n\nPrisma Client JS (`prisma-client-js`) uses several [engines](https://github.com/prisma/prisma-engines). Engines are implemented in Rust and are used by Prisma Client in the form of executable, platform dependent engine files. Depending on which platform you are executing your code on, you need the correct file. \"Binary targets\" are used to define which files should be present for the target platform(s).\n\nThe correct file is particularly important when [deploying](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma) your application to production, which often differs from your local development environment.\n\n#### The `native` binary target[​](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#the-native-binary-target \"Direct link to the-native-binary-target\")\n\nThe `native` binary target is special. It doesn't map to a concrete operating system. Instead, when `native` is specified in `binaryTargets`, Prisma Client detects the _current_ operating system and automatically specifies the correct binary target for it.\n\nAs an example, assume you're running **macOS** and you specify the following generator:\n\n```\ngenerator client {  provider      = \"prisma-client-js\"  binaryTargets = [\"native\"]}\n```\n\nIn that case, Prisma Client detects your operating system and finds the right binary file for it based on the [list of supported operating systems](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#binarytargets-options) . If you use macOS Intel x86 (`darwin`), then the binary file that was compiled for `darwin` will be selected. If you use macOS ARM64 (`darwin-arm64`), then the binary file that was compiled for `darwin-arm64` will be selected.\n\n> **Note**: The `native` binary target is the default. You can set it explicitly if you wish to include additional [binary targets](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#binarytargets-options) for deployment to different environments.\n\nThe following is a list of community created generators. If you want to create your own generator, you can use the [`create-prisma-generator`](https://github.com/YassinEldeeb/create-prisma-generator) CLI built by our community member [Yassin Eldeep](https://github.com/YassinEldeeb).\n\n> **Note**: Community projects are not maintained or officially supported by Prisma and some features may be out of sync. Use at your own discretion. If you create a community generator, please use this naming convention: `prisma-generator-<custom-name>`.\n\n*   [`prisma-dbml-generator`](https://notiz.dev/blog/prisma-dbml-generator): Transforms the Prisma schema into [Database Markup Language](https://dbml.dbdiagram.io/home/) (DBML) which allows for an easy visual representation\n*   [`prisma-docs-generator`](https://github.com/pantharshit00/prisma-docs-generator): Generates an individual API reference for Prisma Client\n*   [`prisma-json-schema-generator`](https://github.com/valentinpalkovic/prisma-json-schema-generator): Transforms the Prisma schema in [JSON schema](https://json-schema.org/)\n*   [`prisma-json-types-generator`](https://github.com/arthurfiorette/prisma-json-types-generator): Adds support for [Strongly Typed `Json`](https://github.com/arthurfiorette/prisma-json-types-generator#readme) fields for all databases. It goes on `prisma-client-js` output and changes the json fields to match the type you provide. Helping with code generators, intellisense and much more. All of that without affecting any runtime code.\n*   [`typegraphql-prisma`](https://github.com/MichalLytek/typegraphql-prisma#readme): Generates [TypeGraphQL](https://typegraphql.com/) CRUD resolvers for Prisma models\n*   [`typegraphql-prisma-nestjs`](https://github.com/EndyKaufman/typegraphql-prisma-nestjs#readme): Fork of [`typegraphql-prisma`](https://github.com/MichalLytek/typegraphql-prisma), which also generates CRUD resolvers for Prisma models but for NestJS\n*   [`prisma-typegraphql-types-gen`](https://github.com/YassinEldeeb/prisma-tgql-types-gen): Generates [TypeGraphQL](https://typegraphql.com/) class types and enums from your prisma type definitions, the generated output can be edited without being overwritten by the next gen and has the ability to correct you when you mess up the types with your edits.\n*   [`nexus-prisma`](https://github.com/prisma/nexus-prisma/): Allows to project Prisma models to GraphQL via [GraphQL Nexus](https://nexusjs.org/docs/)\n*   [`prisma-nestjs-graphql`](https://github.com/unlight/prisma-nestjs-graphql): Generates object types, inputs, args, etc. from the Prisma Schema for usage with `@nestjs/graphql` module\n*   [`prisma-appsync`](https://github.com/maoosi/prisma-appsync): Generates a full-blown GraphQL API for [AWS AppSync](https://aws.amazon.com/appsync/)\n*   [`prisma-kysely`](https://github.com/valtyr/prisma-kysely): Generates type definitions for Kysely, a TypeScript SQL query builder. This can be useful to perform queries against your database from an edge runtime, or to write more complex SQL queries not possible in Prisma without dropping type safety.\n*   [`prisma-generator-nestjs-dto`](https://github.com/vegardit/prisma-generator-nestjs-dto): Generates DTO and Entity classes with relation `connect` and `create` options for use with [NestJS Resources](https://docs.nestjs.com/recipes/crud-generator) and [@nestjs/swagger](https://www.npmjs.com/package/@nestjs/swagger)\n*   [`prisma-erd-generator`](https://github.com/keonik/prisma-erd-generator): Generates an entity relationship diagram\n*   [`prisma-class-generator`](https://github.com/kimjbstar/prisma-class-generator): Generates classes from your Prisma Schema that can be used as DTO, Swagger Response, TypeGraphQL and so on.\n*   [`zod-prisma`](https://github.com/CarterGrimmeisen/zod-prisma): Creates Zod schemas from your Prisma models.\n*   [`prisma-pothos-types`](https://github.com/hayes/pothos/tree/main/packages/plugin-prisma): Makes it easier to define Prisma-based object types, and helps solve n+1 queries for relations. It also has integrations for the Relay plugin to make defining nodes and connections easy and efficient.\n*   [`prisma-generator-pothos-codegen`](https://github.com/Cauen/prisma-generator-pothos-codegen): Auto generate input types (for use as args) and auto generate decoupled type-safe base files makes it easy to create customizable objects, queries and mutations for [Pothos](https://pothos-graphql.dev/) from Prisma schema. Optionally generate all crud at once from the base files.\n*   [`prisma-joi-generator`](https://github.com/omar-dulaimi/prisma-joi-generator): Generate full Joi schemas from your Prisma schema.\n*   [`prisma-yup-generator`](https://github.com/omar-dulaimi/prisma-yup-generator): Generate full Yup schemas from your Prisma schema.\n*   [`prisma-class-validator-generator`](https://github.com/omar-dulaimi/prisma-class-validator-generator): Emit TypeScript models from your Prisma schema with class validator validations ready.\n*   [`prisma-zod-generator`](https://github.com/omar-dulaimi/prisma-zod-generator): Emit Zod schemas from your Prisma schema.\n*   [`prisma-trpc-generator`](https://github.com/omar-dulaimi/prisma-trpc-generator): Emit fully implemented tRPC routers.\n*   [`prisma-json-server-generator`](https://github.com/omar-dulaimi/prisma-json-server-generator): Emit a JSON file that can be run with json-server.\n*   [`prisma-trpc-shield-generator`](https://github.com/omar-dulaimi/prisma-trpc-shield-generator): Emit a tRPC shield from your Prisma schema.\n*   [`prisma-custom-models-generator`](https://github.com/omar-dulaimi/prisma-custom-models-generator): Emit custom models from your Prisma schema, based on Prisma recommendations.\n*   [`nestjs-prisma-graphql-crud-gen`](https://github.com/mk668a/nestjs-prisma-graphql-crud-gen): Generate CRUD resolvers from GraphQL schema with NestJS and Prisma.\n*   [`prisma-generator-dart`](https://github.com/FredrikBorgstrom/abcx3/tree/master/libs/prisma-generator-dart): Generates Dart/Flutter class files with to- and fromJson methods.\n*   [`prisma-generator-graphql-typedef`](https://github.com/mavvy22/prisma-generator-graphql-typedef): Generates graphql schema.\n*   [`prisma-markdown`](https://github.com/samchon/prisma-markdown): Generates markdown document composed with ERD diagrams and their descriptions. Supports pagination of ERD diagrams through `@namespace` comment tag.\n*   [`prisma-models-graph`](https://github.com/dangchinh25/prisma-models-graph): Generates a bi-directional models graph for schema without strict relationship defined in the schema, works via a custom schema annotation.\n*   [`prisma-generator-fake-data`](https://github.com/luisrudge/prisma-generator-fake-data): Generates realistic-looking fake data for your Prisma models that can be used in unit/integration tests, demos, and more.\n*   [`prisma-generator-drizzle`](https://github.com/farreldarian/prisma-generator-drizzle): A Prisma generator for generating Drizzle schema with ease.\n*   [`prisma-generator-express`](https://github.com/multipliedtwice/prisma-generator-express): Generates Express CRUD and Router generator function.\n*   [`prismabox`](https://github.com/m1212e/prismabox): Generates versatile [typebox](https://github.com/sinclairzx81/typebox) schema from your Prisma models.",
  "title": "Generators (Reference) | Prisma Documentation",
  "description": "Generators in your Prisma schema specify what assets are generated when the `prisma generate` command is invoked. This page explains how to configure generators.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing",
  "markdown": "# Integration testing with Prisma | Prisma Documentation\n\nIntegration tests focus on testing how separate parts of the program work together. In the context of applications using a database, integration tests usually require a database to be available and contain data that is convenient to the scenarios intended to be tested.\n\nOne way to simulate a real world environment is to use [Docker](https://www.docker.com/get-started) to encapsulate a database and some test data. This can be spun up and torn down with the tests and so operate as an isolated environment away from your production databases.\n\n> **Note:** This [blog post](https://www.prisma.io/blog/testing-series-2-xPhjjmIEsM) offers a comprehensive guide on setting up an integration testing environment and writing integration tests against a real database, providing valuable insights for those looking to explore this topic.\n\n## Prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#prerequisites \"Direct link to Prerequisites\")\n\nThis guide assumes you have [Docker](https://docs.docker.com/get-docker/) and [Docker Compose](https://docs.docker.com/compose/install/) installed on your machine as well as `Jest` setup in your project.\n\nThe following ecommerce schema will be used throughout the guide. This varies from the traditional `User` and `Post` models used in other parts of the docs, mainly because it is unlikely you will be running integration tests against your blog.\n\nEcommerce schema\n\nschema.prisma\n\n```\n// Can have 1 customer// Can have many order detailsmodel CustomerOrder {  id           Int            @id @default(autoincrement())  createdAt    DateTime       @default(now())  customer     Customer       @relation(fields: [customerId], references: [id])  customerId   Int  orderDetails OrderDetails[]}// Can have 1 order// Can have many productsmodel OrderDetails {  id        Int           @id @default(autoincrement())  products  Product       @relation(fields: [productId], references: [id])  productId Int  order     CustomerOrder @relation(fields: [orderId], references: [id])  orderId   Int  total     Decimal  quantity  Int}// Can have many order details// Can have 1 categorymodel Product {  id           Int            @id @default(autoincrement())  name         String  description  String  price        Decimal  sku          Int  orderDetails OrderDetails[]  category     Category       @relation(fields: [categoryId], references: [id])  categoryId   Int}// Can have many productsmodel Category {  id       Int       @id @default(autoincrement())  name     String  products Product[]}// Can have many ordersmodel Customer {  id      Int             @id @default(autoincrement())  email   String          @unique  address String?  name    String?  orders  CustomerOrder[]}\n```\n\nThe guide uses a singleton pattern for Prisma Client setup. Refer to the [singleton](https://www.prisma.io/docs/orm/prisma-client/testing/unit-testing#singleton) docs for a walk through of how to set that up.\n\n## Add Docker to your project[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#add-docker-to-your-project \"Direct link to Add Docker to your project\")\n\n![Docker compose code pointing towards image of container holding a Postgres database](https://www.prisma.io/docs/assets/images/Docker_Diagram_V1-c836b310ed1106c721c48224b5404a99.png)\n\nWith Docker and Docker compose both installed on your machine you can use them in your project.\n\n1.  Begin by creating a `docker-compose.yml` file at your projects root. Here you will add a Postgres image and specify the environments credentials.\n\ndocker-compose.yml\n\n```\n# Set the version of docker compose to useversion: '3.9'# The containers that compose the projectservices:  db:    image: postgres:13    restart: always    container_name: integration-tests-prisma    ports:      - '5433:5432'    environment:      POSTGRES_USER: prisma      POSTGRES_PASSWORD: prisma      POSTGRES_DB: tests\n```\n\n> **Note**: The compose version used here (`3.9`) is the latest at the time of writing, if you are following along be sure to use the same version for consistency.\n\nThe `docker-compose.yml` file defines the following:\n\n*   The Postgres image (`postgres`) and version tag (`:13`). This will be downloaded if you do not have it locally available.\n*   The port `5433` is mapped to the internal (Postgres default) port `5432`. This will be the port number the database is exposed on externally.\n*   The database user credentials are set and the database given a name.\n\n2.  To connect to the database in the container, create a new connection string with the credentials defined in the `docker-compose.yml` file. For example:\n\n.env.test\n\n```\nDATABASE_URL=\"postgresql://prisma:prisma@localhost:5433/tests\"\n```\n\ninfo\n\nThe above `.env.test` file is used as part of a multiple `.env` file setup. Checkout the [using multiple .env files.](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/using-multiple-env-files) section to learn more about setting up your project with multiple `.env` files\n\n3.  To create the container in a detached state so that you can continue to use the terminal tab, run the following command:\n\n4.  Next you can check that the database has been created by executing a `psql` command inside the container. Make a note of the container id.\n    \n\n> **Note**: The container id is unique to each container, you will see a different id displayed.\n\n5.  Using the container id from the previous step, run `psql` in the container, login with the created user and check the database is created:\n    \n    ```\n    docker exec -it 1322e42d833f psql -U prisma tests\n    ```\n    \n\n## Integration testing[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#integration-testing \"Direct link to Integration testing\")\n\nIntegration tests will be run against a database in a **dedicated test environment** instead of the production or development environments.\n\n### The flow of operations[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#the-flow-of-operations \"Direct link to The flow of operations\")\n\nThe flow for running said tests goes as follows:\n\n1.  Start the container and create the database\n2.  Migrate the schema\n3.  Run the tests\n4.  Destroy the container\n\nEach test suite will seed the database before all the test are run. After all the tests in the suite have finished, the data from all the tables will be dropped and the connection terminated.\n\n### The function to test[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#the-function-to-test \"Direct link to The function to test\")\n\nThe ecommerce application you are testing has a function which creates an order. This function does the following:\n\n*   Accepts input about the customer making the order\n*   Accepts input about the product being ordered\n*   Checks if the customer has an existing account\n*   Checks if the product is in stock\n*   Returns an \"Out of stock\" message if the product doesn't exist\n*   Creates an account if the customer doesn't exist in the database\n*   Create the order\n\nAn example of how such a function might look can be seen below:\n\ncreate-order.ts\n\n```\nimport prisma from '../client'export interface Customer {  id?: number  name?: string  email: string  address?: string}export interface OrderInput {  customer: Customer  productId: number  quantity: number}/** * Creates an order with customer. * @param input The order parameters */export async function createOrder(input: OrderInput) {  const { productId, quantity, customer } = input  const { name, email, address } = customer  // Get the product  const product = await prisma.product.findUnique({    where: {      id: productId,    },  })  // If the product is null its out of stock, return error.  if (!product) return new Error('Out of stock')  // If the customer is new then create the record, otherwise connect via their unique email  await prisma.customerOrder.create({    data: {      customer: {        connectOrCreate: {          create: {            name,            email,            address,          },          where: {            email,          },        },      },      orderDetails: {        create: {          total: product.price,          quantity,          products: {            connect: {              id: product.id,            },          },        },      },    },  })}\n```\n\n### The test suite[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#the-test-suite \"Direct link to The test suite\")\n\nThe following tests will check if the `createOrder` function works as it should do. They will test:\n\n*   Creating a new order with a new customer\n*   Creating an order with an existing customer\n*   Show an \"Out of stock\" error message if a product doesn't exist\n\nBefore the test suite is run the database is seeded with data. After the test suite has finished a [`deleteMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#deletemany) is used to clear the database of its data.\n\ntip\n\nUsing `deleteMany` may suffice in situations where you know ahead of time how your schema is structured. This is because the operations need to be executed in the correct order according to how the model relations are setup.\n\nHowever, this doesn't scale as well as having a more generic solution that maps over your models and performs a truncate on them. For those scenarios and examples of using raw SQL queries see [Deleting all data with raw SQL / `TRUNCATE`](https://www.prisma.io/docs/orm/prisma-client/queries/crud#deleting-all-data-with-raw-sql--truncate)\n\n\\_\\_tests\\_\\_/create-order.ts\n\n```\nimport prisma from '../src/client'import { createOrder, Customer, OrderInput } from '../src/functions/index'beforeAll(async () => {  // create product categories  await prisma.category.createMany({    data: [{ name: 'Wand' }, { name: 'Broomstick' }],  })  console.log('✨ 2 categories successfully created!')  // create products  await prisma.product.createMany({    data: [      {        name: 'Holly, 11\", phoenix feather',        description: 'Harry Potters wand',        price: 100,        sku: 1,        categoryId: 1,      },      {        name: 'Nimbus 2000',        description: 'Harry Potters broom',        price: 500,        sku: 2,        categoryId: 2,      },    ],  })  console.log('✨ 2 products successfully created!')  // create the customer  await prisma.customer.create({    data: {      name: 'Harry Potter',      email: 'harry@hogwarts.io',      address: '4 Privet Drive',    },  })  console.log('✨ 1 customer successfully created!')})afterAll(async () => {  const deleteOrderDetails = prisma.orderDetails.deleteMany()  const deleteProduct = prisma.product.deleteMany()  const deleteCategory = prisma.category.deleteMany()  const deleteCustomerOrder = prisma.customerOrder.deleteMany()  const deleteCustomer = prisma.customer.deleteMany()  await prisma.$transaction([    deleteOrderDetails,    deleteProduct,    deleteCategory,    deleteCustomerOrder,    deleteCustomer,  ])  await prisma.$disconnect()})it('should create 1 new customer with 1 order', async () => {  // The new customers details  const customer: Customer = {    id: 2,    name: 'Hermione Granger',    email: 'hermione@hogwarts.io',    address: '2 Hampstead Heath',  }  // The new orders details  const order: OrderInput = {    customer,    productId: 1,    quantity: 1,  }  // Create the order and customer  await createOrder(order)  // Check if the new customer was created by filtering on unique email field  const newCustomer = await prisma.customer.findUnique({    where: {      email: customer.email,    },  })  // Check if the new order was created by filtering on unique email field of the customer  const newOrder = await prisma.customerOrder.findFirst({    where: {      customer: {        email: customer.email,      },    },  })  // Expect the new customer to have been created and match the input  expect(newCustomer).toEqual(customer)  // Expect the new order to have been created and contain the new customer  expect(newOrder).toHaveProperty('customerId', 2)})it('should create 1 order with an existing customer', async () => {  // The existing customers email  const customer: Customer = {    email: 'harry@hogwarts.io',  }  // The new orders details  const order: OrderInput = {    customer,    productId: 1,    quantity: 1,  }  // Create the order and connect the existing customer  await createOrder(order)  // Check if the new order was created by filtering on unique email field of the customer  const newOrder = await prisma.customerOrder.findFirst({    where: {      customer: {        email: customer.email,      },    },  })  // Expect the new order to have been created and contain the existing customer with an id of 1 (Harry Potter from the seed script)  expect(newOrder).toHaveProperty('customerId', 1)})it(\"should show 'Out of stock' message if productId doesn't exit\", async () => {  // The existing customers email  const customer: Customer = {    email: 'harry@hogwarts.io',  }  // The new orders details  const order: OrderInput = {    customer,    productId: 3,    quantity: 1,  }  // The productId supplied doesn't exit so the function should return an \"Out of stock\" message  await expect(createOrder(order)).resolves.toEqual(new Error('Out of stock'))})\n```\n\n## Running the tests[​](https://www.prisma.io/docs/orm/prisma-client/testing/integration-testing#running-the-tests \"Direct link to Running the tests\")\n\nThis setup isolates a real world scenario so that you can test your applications functionality against real data in a controlled environment.\n\nYou can add some scripts to your projects `package.json` file which will setup the database and run the tests, then afterwards manually destroy the container.\n\npackage.json\n\n```\n  \"scripts\": {    \"docker:up\": \"docker compose up -d\",    \"docker:down\": \"docker compose down\",    \"test\": \"yarn docker:up && yarn prisma migrate deploy && jest -i\"  },\n```\n\nThe `test` script does the following:\n\n1.  Runs `docker compose up -d` to create the container with the Postgres image and database.\n2.  Applies the migrations found in `./prisma/migrations/` directory to the database, this creates the tables in the container's database.\n3.  Executes the tests.\n\nOnce you are satisfied you can run `yarn docker:down` to destroy the container, its database and any test data.",
  "title": "Integration testing with Prisma | Prisma Documentation",
  "description": "Learn how to setup and run integration tests with Prisma and Docker",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client",
  "markdown": "# Generating Prisma Client | Prisma Documentation\n\nPrisma Client is an auto-generated database client that's tailored to your database schema. By default, Prisma Client is generated into the `node_modules/.prisma/client` folder, but [you can specify a custom location](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#using-a-custom-output-path).\n\nTo generate and instantiate Prisma Client:\n\n1.  Ensure that you have [Prisma CLI installed on your machine](https://www.prisma.io/docs/orm/tools/prisma-cli#installation).\n    \n2.  Add the following `generator` definition to your Prisma schema:\n    \n    ```\n    generator client {  provider = \"prisma-client-js\"}\n    ```\n    \n3.  Install the `@prisma/client` npm package:\n    \n    ```\n    npm install @prisma/client\n    ```\n    \n    warning\n    \n    We recommend that you keep **both** the `prisma` and `@prisma/client` packages in sync to avoid any unexpected errors or behaviors.\n    \n4.  Generate Prisma Client with the following command:\n    \n5.  You can now [instantiate Prisma Client](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/instantiate-prisma-client) in your code:\n    \n\n*   TypeScript\n*   JavaScript\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()// use `prisma` in your application to read and write data in your DB\n```\n\n> **Important**: You need to re-run the `prisma generate` command after every change that's made to your Prisma schema to update the generated Prisma Client code.\n\nHere is a graphical illustration of the typical workflow for generation of Prisma Client:\n\n![Graphical illustration of the typical workflow for generation of Prisma Client](https://www.prisma.io/docs/assets/images/prisma-client-generation-workflow-3b42c24d27aef3025f2eb4ffc4644642.png)\n\nNote also that `prisma generate` is _automatically_ invoked when you're installing the `@prisma/client` npm package. So, when you're initially setting up Prisma Client, you can typically save the third step from the list above.\n\n## The `@prisma/client` npm package[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package \"Direct link to the-prismaclient-npm-package\")\n\nThe `@prisma/client` npm package consists of two key parts:\n\n*   The `@prisma/client` module itself, which only changes when you re-install the package\n*   The `.prisma/client` folder, which is the [default location](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#using-a-custom-output-path) for the unique Prisma Client generated from your schema\n\n`@prisma/client/index.d.ts` exports `.prisma/client`:\n\n```\nexport * from '.prisma/client'\n```\n\nThis means that you still import `@prisma/client` in your own `.ts` files:\n\n```\nimport { PrismaClient } from '@prisma/client'\n```\n\nPrisma Client is generated from your Prisma schema and is unique to your project. Each time you change the schema (for example, by performing a [schema migration](https://www.prisma.io/docs/orm/prisma-migrate)) and run `prisma generate`, Prisma Client's code changes:\n\n![The .prisma and @prisma folders](https://www.prisma.io/docs/assets/images/prisma-client-node-module-7c4bfa76f2c2d8d4a02e98ada95a067f.png)\n\nThe `.prisma` folder is unaffected by [pruning](https://docs.npmjs.com/cli/prune.html) in Node.js package managers.\n\n## The location of Prisma Client[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-location-of-prisma-client \"Direct link to The location of Prisma Client\")\n\nIf you do not specify a custom `output` in the `generator` block, Prisma Client is generated into the `./node_modules/.prisma/client` folder by default. There are [some advantages to maintaining the default location](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#why-is-prisma-client-generated-into-node_modulesprismaclient-by-default).\n\n### Using a custom `output` path[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#using-a-custom-output-path \"Direct link to using-a-custom-output-path\")\n\nYou can also specify a custom `output` path on the `generator` configuration, for example (assuming your `schema.prisma` file is located at the default `prisma` subfolder):\n\n```\ngenerator client {  provider = \"prisma-client-js\"  output   = \"../src/generated/client\"}\n```\n\nAfter running `prisma generate` for that schema file, the Prisma Client package will be located in:\n\nTo import the `PrismaClient` from a custom location (for example, from a file named `./src/script.ts`):\n\n```\nimport { PrismaClient } from './generated/client'\n```\n\n### Why is Prisma Client generated into `node_modules/.prisma/client` by default?[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#why-is-prisma-client-generated-into-node_modulesprismaclient-by-default \"Direct link to why-is-prisma-client-generated-into-node_modulesprismaclient-by-default\")\n\n#### Importing Prisma Client[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#importing-prisma-client \"Direct link to Importing Prisma Client\")\n\nBy generating Prisma Client into `node_modules/.prisma/client` and exporting it from `@prisma/client`, you can import it and instantiate Prisma Client in your code as follows:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()// use `prisma` in your application to read and write data in your DB\n```\n\nor\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()// use `prisma` in your application to read and write data in your DB\n```\n\n#### Keeping the query engine out of version control by default[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#keeping-the-query-engine-out-of-version-control-by-default \"Direct link to Keeping the query engine out of version control by default\")\n\nPrisma Client uses a [_query engine_](https://www.prisma.io/docs/orm/more/under-the-hood/engines) to run queries against the database. This query engine is downloaded when `prisma generate` is invoked and stored in the `output` path together with the generated Client.\n\nBy generating Prisma Client into `node_modules`, the query engine is usually kept out of version control by default since `node_modules` is typically ignored for version control. When using a custom `output` path for the generated Prisma Client, it is advised to exclude it from your version control. For Git, this means adding the `output` path to your `.gitignore` file.\n\n## Generating Prisma Client in the `postinstall` hook of `@prisma/client`[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#generating-prisma-client-in-the-postinstall-hook-of-prismaclient \"Direct link to generating-prisma-client-in-the-postinstall-hook-of-prismaclient\")\n\nThe `@prisma/client` package defines its own `postinstall` hook that's being executed whenever the package is being installed. This hook invokes the `prisma generate` command which in turn generates the Prisma Client code into the default location `node_modules/.prisma/client`. Notice that this requires the `prisma` CLI to be available, either as local dependency or as a global installation. It is recommended to always install the `prisma` package as a development dependency, using `npm install prisma --save-dev`, to avoid versioning conflicts.",
  "title": "Generating Prisma Client | Prisma Documentation",
  "description": "This page explains how to generate Prisma Client. It also provides additional context on the generated client, typical workflows and Node.js configuration.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding",
  "markdown": "# Seeding | Prisma Documentation\n\nThis guide describes how to seed your database using Prisma Client and Prisma ORM's integrated seeding functionality. Seeding allows you to consistently re-create the same data in your database and can be used to:\n\n*   Populate your database with data that is required for your application to start, such as a default language or currency.\n*   Provide basic data for validating and using your application in a development environment. This is particularly useful if you are using Prisma Migrate, which sometimes requires resetting your development database.\n\n## How to seed your database in Prisma ORM[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#how-to-seed-your-database-in-prisma-orm \"Direct link to How to seed your database in Prisma ORM\")\n\nPrisma ORM's integrated seeding functionality expects a command in the `\"seed\"` key in the `\"prisma\"` key of your `package.json` file. This can be any command, `prisma db seed` will just execute it. In this guide and as a default, we recommend writing a seed script inside your project's `prisma/` folder and starting it with the command.\n\n*   TypeScript\n*   JavaScript\n\n  \n\n```\n\"prisma\": {  \"seed\": \"ts-node prisma/seed.ts\"},\n```\n\n  \n\ninfo\n\nWith TypeScript,`ts-node` does transpiling and typechecking by default; typechecking can be disabled with the following flag `--transpile-only`.\n\nExample: `\"seed\": \"ts-node --transpile-only prisma/seed.ts\"`\n\nThis can be useful to reduce memory usage (RAM) and increase execution speed of the seed script.\n\n## Integrated seeding with Prisma Migrate[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#integrated-seeding-with-prisma-migrate \"Direct link to Integrated seeding with Prisma Migrate\")\n\nDatabase seeding happens in two ways with Prisma ORM: manually with `prisma db seed` and automatically in `prisma migrate reset` and (in some scenarios) `prisma migrate dev`.\n\nWith `prisma db seed`, _you_ decide when to invoke the seed command. It can be useful for a test setup or to prepare a new development environment, for example.\n\nPrisma Migrate also integrates seamlessly with your seeds, assuming you follow the steps in the section below. Seeding is triggered automatically when Prisma Migrate resets the development database.\n\nPrisma Migrate resets the database and triggers seeding in the following scenarios:\n\n*   You manually run the `prisma migrate reset` CLI command.\n*   The database is reset interactively in the context of using `prisma migrate dev` - for example, as a result of migration history conflicts or database schema drift.\n*   The database is actually created by `prisma migrate dev`, because it did not exist before.\n\nWhen you want to use `prisma migrate dev` or `prisma migrate reset` without seeding, you can pass the `--skip-seed` flag.\n\n## Example seed scripts[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#example-seed-scripts \"Direct link to Example seed scripts\")\n\nHere we suggest some specific seed scripts for different situations. You are free to customize these in any way, but can also use them as presented here:\n\n### Seeding your database with TypeScript or JavaScript[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#seeding-your-database-with-typescript-or-javascript \"Direct link to Seeding your database with TypeScript or JavaScript\")\n\n> If you're using TypeScript with PostgreSQL, SQLite or MySQL see also: [@snaplet/seed](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#seeding-your-database-with-snapletseed).\n\n*   TypeScript\n*   JavaScript\n\n1.  Create a new file named `seed.ts`. This can be placed anywhere within your project's folder structure. The example below places it in the `/prisma` folder.\n    \n2.  In the `seed.ts` file, import Prisma Client, initialize it and create some records. As an example, take the following Prisma schema with a `User` and `Post` model:\n    \n    schema.prisma\n    \n    ```\n    model User {  id    Int    @id @default(autoincrement())  email String @unique  name  String  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String  published Boolean  user      User    @relation(fields: [userId], references: [id])  userId    Int}\n    ```\n    \n    Create some new users and posts in your `seed.ts` file:\n    \n    seed.ts\n    \n    ```\n    import { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  const alice = await prisma.user.upsert({    where: { email: 'alice@prisma.io' },    update: {},    create: {      email: 'alice@prisma.io',      name: 'Alice',      posts: {        create: {          title: 'Check out Prisma with Next.js',          content: 'https://www.prisma.io/nextjs',          published: true,        },      },    },  })  const bob = await prisma.user.upsert({    where: { email: 'bob@prisma.io' },    update: {},    create: {      email: 'bob@prisma.io',      name: 'Bob',      posts: {        create: [          {            title: 'Follow Prisma on Twitter',            content: 'https://twitter.com/prisma',            published: true,          },          {            title: 'Follow Nexus on Twitter',            content: 'https://twitter.com/nexusgql',            published: true,          },        ],      },    },  })  console.log({ alice, bob })}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n    ```\n    \n3.  Add `typescript`, `ts-node` and `@types/node` development dependencies:\n    \n    ```\n    npm install -D typescript ts-node @types/node\n    ```\n    \n\n4.  Add the `prisma.seed` field to your `package.json` file:\n    \n    package.json\n    \n    ```\n    {  \"name\": \"my-project\",  \"version\": \"1.0.0\",  \"prisma\": {    \"seed\": \"ts-node prisma/seed.ts\"  },  \"devDependencies\": {    \"@types/node\": \"^14.14.21\",    \"ts-node\": \"^9.1.1\",    \"typescript\": \"^4.1.3\"  }}\n    ```\n    \n    Some projects may require you to add compile options. When using Next.js for example, you would setup your seed script like so:\n    \n    package.json\n    \n    ```\n    \"prisma\": {  \"seed\": \"ts-node --compiler-options {\\\"module\\\":\\\"CommonJS\\\"} prisma/seed.ts\"},\n    ```\n    \n5.  To seed the database, run the `db seed` CLI command:\n    \n\n### Seeding your database via raw SQL queries[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#seeding-your-database-via-raw-sql-queries \"Direct link to Seeding your database via raw SQL queries\")\n\nYou can also make use of raw SQL queries in order to seed the database with data.\n\nWhile you can use a plain-text `.sql` file (such as a data dump) for that, it is often easier to place those raw queries, if they're of short size, into the `seed.js` file because it saves you the hassle of working out database connection strings and creating a dependency on a binary like `psql`.\n\nTo seed additional data to the `schema.prisma` above, add the following to the `seed.js` (or `seed.ts`) file:\n\nseed.js\n\n```\nasync function rawSql() {  const result = await prisma.$executeRaw`INSERT INTO \"User\" (\"id\", \"email\", \"name\") VALUES (3, 'foo@example.com', 'Foo') ON CONFLICT DO NOTHING;`  console.log({ result })}\n```\n\nand chain this function to the promise calls, such as the following change towards the end of the file:\n\nseed.js\n\n```\nmain()  .then(rawSql)  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\n### Seeding your database via any language (with a Bash script)[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#seeding-your-database-via-any-language-with-a-bash-script \"Direct link to Seeding your database via any language (with a Bash script)\")\n\nIn addition to TypeScript and JavaScript, you can also use a Bash script (`seed.sh`) to seed your database in another language such as Go, or plain SQL.\n\n*   Go\n*   SQL\n\nThe following example runs a Go script in the same folder as `seed.sh`:\n\nseed.sh\n\n```\n#!/bin/sh# -e Exit immediately when a command returns a non-zero status.# -x Print commands before they are executedset -ex# Seeding commandgo run ./seed/\n```\n\n### Seeding your database with `@snaplet/seed`[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#seeding-your-database-with-snapletseed \"Direct link to seeding-your-database-with-snapletseed\")\n\n[`@snaplet/seed`](https://docs.snaplet.dev/seed/getting-started/overview) offers a toolkit designed to understand your database schema, enabling you to generate production-accurate data and efficiently seed your database. It uses the full power of TypeScript to provide you with a type-safe and auto-completed experience to write your seed scripts.\n\n`@snaplet/seed` supports PostgreSQL, SQLite and MySQL.\n\n1.  Begin by setting up a local database using `npx prisma migrate dev`. This example will use the following Prisma schema featuring a `User` and `Post` model:\n    \n    schema.prisma\n    \n    ```\n    model User {  id    Int    @id @default(autoincrement())  email String @unique  name  String  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String  published Boolean  user      User    @relation(fields: [userId], references: [id])  userId    Int}\n    ```\n    \n2.  Execute `npx @snaplet/seed init prisma/seed` to initialize Snaplet Seed in your Prisma project. This command generates the seed client and creates an example seed file at `prisma/seed/seed.ts`.\n    \n    > **Note:** Snaplet Seed also has an [AI-enhanced version](https://www.snaplet.dev/seed#ai). You can opt in for improved seed data quality with a free Snaplet account.\n    \n3.  Use the generated `@snaplet/seed` client within the `prisma/seed/seed.ts` file to compose your seeds.\n    \n    Here's how to create new users and posts by modifying the initially generated `prisma/seed/seed.ts` file:\n    \n    prisma/seed/seed.ts\n    \n    ```\n    /** * ! Executing this script will delete all data in your database and seed it with 10 users. * ! Make sure to adjust the script to your needs. * Use any TypeScript runner to run this script, for example: `npx tsx seed.ts` * Learn more about the Seed Client by following our guide: https://docs.snaplet.dev/seed/getting-started */import { createSeedClient } from \"@snaplet/seed\";async function main() {  const seed = await createSeedClient();    // Truncate all tables in the database  await seed.$resetDatabase();    // Seed the database with 10 users  await seed.user((createMany) => createMany(10, {    // Create 10 posts for each of those users    posts: (createMany) => createMany(10),  }))    console.log(\"Database seeded successfully!\");    process.exit();};main();\n    ```\n    \n4.  Add `tsx` (or any other typescript runners) as a development dependency:\n    \n5.  Insert the `prisma.seed` field into your `package.json` file and configure commands to seed your database:\n    \n    package.json\n    \n    ```\n    {  \"name\": \"my-project\",  \"version\": \"1.0.0\",  \"prisma\": {    \"seed\": \"tsx prisma/seed/seed.ts\"  },  \"devDependencies\": {    \"@types/node\": \"^14.14.21\",    \"tsx\": \"^4.7.2\",    \"typescript\": \"^4.1.3\"  }}\n    ```\n    \n6.  To seed the database, execute the following CLI command:\n    \n7.  To ensure the seed client remains synchronized with your schema, add a `migrate` and `postmigrate` scripts to the package.json:\n    \n    package.json\n    \n    ```\n    {  \"name\": \"my-project\",  \"version\": \"1.0.0\",  \"prisma\": {    \"seed\": \"npx tsx prisma/seed/seed.ts\"  },  \"scripts\": {    \"migrate\": \"prisma migrate dev\",    \"postmigrate\": \"npx @snaplet/seed sync\"  },  \"devDependencies\": {    \"@types/node\": \"^14.14.21\",    \"tsx\": \"^4.7.2\",    \"typescript\": \"^4.1.3\"  }}\n    ```\n    \n\nNow, instead of `npx prisma migrate dev` you can run `npm run migrate` which will also sync the seed client after schema changes and keep both your database and seed client in sync.\n\n### User-defined arguments[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#user-defined-arguments \"Direct link to User-defined arguments\")\n\n> This feature is available from version 4.15.0 and later.\n\n`prisma db seed` allows you to define custom arguments in your seed file that you can pass to the `prisma db seed` command. For example, you could define your own arguments to seed different data for different environments or partially seeding data in some tables.\n\nHere is an example seed file that defines a custom argument to seed different data in different environments:\n\n\"seed.js\"\n\n```\nimport { parseArgs } from 'node:util'const options = {  environment: { type: 'string' },}async function main() {  const {    values: { environment },  } = parseArgs({ options })  switch (environment) {    case 'development':      /** data for your development */      break    case 'test':      /** data for your test environment */      break    default:      break  }}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nYou can then provide the `environment` argument when using `prisma db seed` by adding a [delimiter](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02) — `--` —, followed by your custom arguments:\n\n```\nnpx prisma db seed -- --environment development\n```\n\n## Going further[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding#going-further \"Direct link to Going further\")\n\nHere's a non-exhaustive list of other tools you can integrate with Prisma ORM in your development workflow to seed your database:\n\n*   [Snaplet](https://docs.snaplet.dev/recipes/prisma)\n*   [Replibyte](https://www.replibyte.com/docs/introduction)",
  "title": "Seeding | Prisma Documentation",
  "description": "Learn how to seed your database using Prisma ORM's integrated seeding functionality and Prisma Client",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database",
  "markdown": "# About the shadow database | Prisma Documentation\n\nThe shadow database is a second, _temporary_ database that is **created and deleted automatically**\\* each time you run `prisma migrate dev` and is primarily used to **detect problems** such as schema drift or potential data loss of the generated migration.\n\n[`migrate diff` command](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) also requires a shadow database when diffing against a local `migrations` directory with `--from-migrations` or `--to-migrations`.\n\n*   If your database does not allow creation and deleting of databases (e.g. in a cloud-hosted environment), you need to [create and configure the shadow database manually](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#cloud-hosted-shadow-databases-must-be-created-manually).\n\nwarning\n\nThe shadow database is **not** required in production, and is not used by production-focused commands such as `prisma migrate resolve` and `prisma migrate deploy`.\n\nnote\n\nA shadow database is never used for MongoDB as `migrate dev` is not used there.\n\n## How the shadow database works[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#how-the-shadow-database-works \"Direct link to How the shadow database works\")\n\nWhen you run `prisma migrate dev` to create a new migration, Prisma Migrate uses the shadow database to:\n\n*   [Detect schema drift](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#detecting-schema-drift), which means checking that no **unexpected changes** have been made to the development database\n*   [Generate new migrations](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#generating-new-migrations) and evaluate if those could lead to **data loss** when applied\n\n🎨 Expand to see the shadow database explained as a cartoon.\n\n![A cartoon that shows how the shadow database works.](https://www.prisma.io/docs/assets/images/shadow-database-4851f4376ca80c1b94316445aa5bd85b.png)\n\n### Detecting schema drift[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#detecting-schema-drift \"Direct link to Detecting schema drift\")\n\nTo detect drift in development, Prisma Migrate:\n\n1.  Creates a fresh copy of the shadow database (or performs a soft reset if the shadow database is configured via [`shadowDatabaseUrl`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource))\n2.  Reruns the **current**, existing migration history in the shadow database.\n3.  **Introspects** the shadow database to generate the 'current state' of your Prisma schema.\n4.  Compares the end state of the current migration history to the development database.\n5.  Reports **schema drift** if the end state of the current migration history (via the shadow database) does not match the development database (for example, due to a manual change)\n\nIf Prisma Migrate does not detect schema drift, it moves on to [generating new migrations](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#generating-new-migrations).\n\n> **Note**: The shadow database is not responsible for checking if a migration file has been **edited or deleted**. This is done using the `checksum` field in the `_prisma_migrations` table.\n\nIf Prisma Migrate detects schema drift, it outputs detailed information about which parts of the database have drifted. The following example output could be shown when the development database has been modified manually: The `Color` enum is missing the expected variant `RED` and includes the unexpected variant `TRANSPARENT`:\n\n```\n[*] Changed the `Color` enum  [+] Added variant `TRANSPARENT`  [-] Removed variant `RED`\n```\n\n### Generating new migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#generating-new-migrations \"Direct link to Generating new migrations\")\n\nAssuming Prisma Migrate did not [detect schema drift](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#detecting-schema-drift), it moves on to generating new migrations from Prisma schema changes. To generate new migrations, Prisma Migrate:\n\n1.  Calculates the target database schema as a function of the current Prisma schema.\n2.  Compares the end state of the existing migration history and the target schema, and generates steps to get from one to the other.\n3.  Renders these steps to a SQL string and saves it in the new migration file.\n4.  Evaluate data loss caused by the SQL and warns about that.\n5.  Applies the generated migration to the development database (assuming you have not specified the `--create-only` flag)\n6.  Drops the shadow database (shadow databases configured via [`shadowDatabaseUrl`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource) are not dropped, but are reset at the start of the `migrate dev` command)\n\n## Manually configuring the shadow database[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#manually-configuring-the-shadow-database \"Direct link to Manually configuring the shadow database\")\n\nIn some cases it might make sense (e.g. when [creating and dropping databases is not allowed on cloud-hosted databases](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#cloud-hosted-shadow-databases-must-be-created-manually)) to manually define the connection string and name of the database that should be used as the shadow database for `migrate dev`. In such a case you can:\n\n1.  Create a dedicated database that should be used as the shadow database\n2.  Add the connection string of that database your environment variable `SHADOW_DATABASE_URL` (or `.env` file)\n3.  Add the [`shadowDatabaseUrl`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource) field reading this environment variable:\n\n```\ndatasource db {  provider          = \"postgresql\"  url               = env(\"DATABASE_URL\")  shadowDatabaseUrl = env(\"SHADOW_DATABASE_URL\")}\n```\n\n> **Important**: Do not use the exact same values for `url` and `shadowDatabaseUrl` as that might delete all your database in your database.\n\n## Cloud-hosted shadow databases must be created manually[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#cloud-hosted-shadow-databases-must-be-created-manually \"Direct link to Cloud-hosted shadow databases must be created manually\")\n\nSome cloud providers do not allow you to drop and create databases with SQL. Some require to create or drop the database via an online interface, and some really limit you to 1 database. If you **develop** in such a cloud-hosted environment, you must:\n\n1.  Create a dedicated cloud-hosted shadow database\n2.  Add the URL to your environment variable `SHADOW_DATABASE_URL`\n3.  Add the [`shadowDatabaseUrl`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#datasource) field reading this environment variable:\n\n```\ndatasource db {  provider          = \"postgresql\"  url               = env(\"DATABASE_URL\")  shadowDatabaseUrl = env(\"SHADOW_DATABASE_URL\")}\n```\n\n> **Important**: Do not use the same values for `url` and `shadowDatabaseUrl`.\n\n## Shadow database user permissions[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#shadow-database-user-permissions \"Direct link to Shadow database user permissions\")\n\nIn order to create and delete the shadow database when using `migrate dev`, Prisma Migrate currently requires that the database user defined in your `datasource` has permission to **create databases**.\n\n| Database | Database user requirements |\n| --- | --- |\n| SQLite | No special requirements. |\n| MySQL/MariaDB | Database user must have `CREATE, ALTER, DROP, REFERENCES ON *.*` privileges |\n| PostgreSQL | The user must be a super user or have `CREATEDB` privilege. See `CREATE ROLE` ([PostgreSQL official documentation](https://www.postgresql.org/docs/12/sql-createrole.html)) |\n| Microsoft SQL Server | The user must be a site admin or have the `SERVER` securable. See the [official documentation](https://docs.microsoft.com/en-us/sql/relational-databases/security/permissions-database-engine?view=sql-server-ver15). |\n\n> If you use a cloud-hosted database for development and can not use these permissions, see: [Cloud-hosted shadow databases](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#cloud-hosted-shadow-databases-must-be-created-manually)\n\n> Note: The automatic creation of shadow databases is disabled on Azure SQL for example.\n\nPrisma Migrate throws the following error if it cannot create the shadow database with the credentials your connection URL supplied:\n\n```\nError: A migration failed when applied to the shadow databaseDatabase error: Error querying the database: db error: ERROR: permission denied to create database\n```\n\nTo resolve this error:\n\n*   If you are working locally, we recommend that you update the database user's privileges.\n*   If you are developing against a database that does not allow creating and dropping databases (for any reason) see [Manually configuring the shadow database](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#manually-configuring-the-shadow-database)\n*   If you are developing against a cloud-based database (for example, on Heroku, Digital Ocean, or Vercel Postgres) see: [Cloud-hosted shadow databases](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#cloud-hosted-shadow-databases-must-be-created-manually).\n*   If you are developing against a cloud-based database (for example, on Heroku, Digital Ocean, or Vercel Postgres) and are currently **prototyping** such that you don't care about generated migration files and only need to apply your Prisma schema to the database schema, you can run [`prisma db push`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db) instead of the `prisma migrate dev` command.\n\n> **Important**: The shadow database is _only_ required in a development environment (specifically for the `prisma migrate dev` command) - you **do not** need to make any changes to your production environment.",
  "title": "About the shadow database | Prisma Documentation",
  "description": "About the shadow database",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4",
  "markdown": "# Upgrade to Prisma ORM 4\n\nPrisma ORM 4 introduces a number of **breaking changes** when you upgrade from an earlier Prisma ORM version. This guide explains how this upgrade might affect your application and gives instructions on how to handle any changes.\n\n## Breaking changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#breaking-changes \"Direct link to Breaking changes\")\n\nThis section gives an overview of breaking changes in Prisma ORM 4, grouped under [general changes](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#general-changes) that affect both the Prisma Schema and Prisma Client, [Schema changes](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#schema-changes) and [Client changes](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#client-changes).\n\nWe recommend that you first address any Prisma schema validation errors, then pull your database to reflect new Prisma schema capabilities, and finally fix any type errors in Prisma Client and validate by running your test suite.\n\n### Upgrade your Prisma Schema[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-your-prisma-schema \"Direct link to Upgrade your Prisma Schema\")\n\n1.  Carefully skim the list of changes and check if you are impacted by a breaking change.\n2.  Review the Prisma schema validation errors (via `npx prisma validate`, or via the Prisma VS Code extension).\n    1.  If you don't have validation errors, continue with step 3.\n    2.  If you have validation errors:\n        1.  Try to map the validation error to a change from the list below to understand which change caused the invalid Prisma schema, and read the linked instructions for how to upgrade. It can only come from:\n            *   [Explicit unique constraints for 1:1 relations](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#explicit-unique-constraints-on-one-to-one-relations)\n            *   [Removed support for usage of `references` on implicit many-to-many relations](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#disallow-references-syntax-for-implicit-many-to-many-relations)\n            *   [Enforced uniqueness of referenced fields in the `references` argument in one-to-one and one-to-many relations for MySQL and MongoDB](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#enforced-use-of-unique-or-id-attribute-for-one-to-one-and-one-to-many-relations-mysql-and-mongodb)\n            *   Removal of undocumented support for the `type` alias\n            *   Removal of the `sqlite` protocol for SQLite URLs\n            *   [Better grammar for string literals](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#better-grammar-for-string-literals)\n3.  Repeat until your Prisma schema is valid.\n4.  Run `npx prisma db pull` to upgrade the Prisma schema to all new capabilities (e.g. `extendedIndexes`).\n5.  Review changes of the Prisma schema and verify validity.\n6.  Continue with Prisma Client steps.\n\n### Upgrade your use of Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-your-use-of-prisma-client \"Direct link to Upgrade your use of Prisma Client\")\n\n1.  Carefully skim the [list of changes](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#client-changes) to understand if you are impacted by a breaking change.\n    1.  If yes, read the detailed upgrade instructions.\n    2.  If no, proceed with 2.\n2.  Some API changes in Prisma Client are impacting runtime behavior, so please run your test suite.\n\nEnjoy Prisma ORM 4!\n\n### General changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#general-changes \"Direct link to General changes\")\n\nThis section includes changes that affect both the Prisma Schema and Prisma Client.\n\n#### Node.js minimum version change[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#nodejs-minimum-version-change \"Direct link to Node.js minimum version change\")\n\nFrom Prisma ORM version 4.0.0, the minimum version of Node.js that we support is 14.17.x. If you use an earlier version of Node.js, you will need to update it.\n\nSee our [system requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for all minimum version requirements.\n\n### Schema changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#schema-changes \"Direct link to Schema changes\")\n\nThis section includes changes that affect the Prisma Schema.\n\n#### Index configuration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#index-configuration \"Direct link to Index configuration\")\n\nIn Prisma ORM 4, the `extendedIndexes` Preview feature will now become generally available. This includes the following index configuration options:\n\n*   Length configuration of indexes, unique constraints and primary key constraints for MySQL (in Preview in versions 3.5.0 and later)\n*   Sort order configuration of indexes, unique constraints and primary key constraints (in Preview in versions 3.5.0 and later)\n*   New index types for PostgreSQL: Hash (in Preview in versions 3.6.0 and later) and GIN, GiST, SP-GiST and BRIN (in Preview in versions 3.14.0 and later)\n*   Index clustering for SQL Server (in Preview in versions 3.13.0 and later)\n\nSee our documentation on [Index configuration](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#index-configuration) for more details of these features.\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path \"Direct link to Upgrade path\")\n\nThese can all be breaking changes if you were previously configuring these properties at the database level. In this case, you will need to:\n\n1.  Upgrade to the new Prisma ORM 4 packages following [these instructions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4)\n2.  Run `npx prisma db pull` afterwards to retrieve any existing configuration of indexes and constraints. This needs to be done before running any `npx prisma db push` or `npx prisma migrate dev` command, or you may lose any configuration that was defined in the database but not previously represented in the Prisma schema.\n\nFor more details, see the [Upgrading from previous versions](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#upgrading-from-previous-versions) section of our index configuration documentation.\n\n#### Scalar list defaults[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#scalar-list-defaults \"Direct link to Scalar list defaults\")\n\nFor database connectors that support scalar lists (PostgreSQL, CockroachDB and MongoDB), Prisma ORM 4 introduces the ability to set a default value in your Prisma schema with the `@default` attribute:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id             Int      @id @default(autoincrement())  posts          Post[]  favoriteColors String[] @default([\"red\", \"yellow\", \"purple\"])}\n```\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-1 \"Direct link to Upgrade path\")\n\nThis is a breaking change if you previously had defaults defined for scalar lists at the database level. In this case, you will need to:\n\n1.  Upgrade to the new Prisma ORM 4 packages following [these instructions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4)\n2.  Run `npx prisma db pull` afterwards to retrieve any existing configuration of indexes and constraints. This needs to be done before running any `npx prisma db push` or `npx prisma migrate dev` command, or you will lose any defaults that are defined in the database but not previously represented in the Prisma schema.\n\n#### Explicit `@unique` constraints on one-to-one relations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#explicit-unique-constraints-on-one-to-one-relations \"Direct link to explicit-unique-constraints-on-one-to-one-relations\")\n\nWhen using one-to-one relations in Prisma ORM 4, you will need to explicitly add the `@unique` attribute to the relation scalar field. For example, for this one-to-one relation between a `User` and a `Profile` model, you will need to add the `@unique` attribute to the `profileId` field:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        Int      @id @default(autoincrement())  profile   Profile? @relation(fields: [profileId], references: [id])  profileId Int?     @unique // <-- include this explicitly}model Profile {  id   Int   @id @default(autoincrement())  user User?}\n```\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-2 \"Direct link to Upgrade path\")\n\nAfter you upgrade to Prisma ORM 4, any one-to-one relations without a `@unique` attribute on the relation scalar will trigger a validation error. To upgrade, you will need to:\n\n1.  Upgrade to the new Prisma ORM 4 packages following [these instructions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4)\n    \n2.  Manually fix the validation errors in your Prisma schema by adding the explicit `@unique` or `@id` attribute to your data model.\n    \n3.  Push the changes to your database using `prisma db push` for MongoDB or `prisma migrate dev` for MySQL.\n    \n\n#### Enforced use of `@unique` or `@id` attribute for one-to-one and one-to-many relations (MySQL and MongoDB)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#enforced-use-of-unique-or-id-attribute-for-one-to-one-and-one-to-many-relations-mysql-and-mongodb \"Direct link to enforced-use-of-unique-or-id-attribute-for-one-to-one-and-one-to-many-relations-mysql-and-mongodb\")\n\nWhen you use one-to-one and one-to-many relations in Prisma ORM 4, you will need to use a `@unique` attribute on the relation field to guarantee that the singular side(s) of the relation has only one record. This is now enforced for MySQL and MongoDB, bringing them into line with other connectors. Missing `@unique` attributes will now trigger a validation error.\n\nIn the following example of a _one-to-many relation_ between a `User` and `Post` model, the `@unique` attribute must be added to the `email` field:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  email String @unique // <-- we enforce this attribute  posts Post[]}model Post {  id          Int    @id @default(autoincrement())  authorEmail String  author      User   @relation(fields: [authorEmail], references: [email])}\n```\n\nIn the following example of a _one-to-one relation_ between a `User` and `Profile` model, the `@unique` attribute must be added to the `email` field:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        Int     @id @default(autoincrement())  email     String  @unique // <- we enforce this unique attribute  profile   Profile @relation(fields: [profileId], references: [id])  profileId Int}model Profile {  id        Int     @id @default(autoincrement())  userEmail String? @unique  user      User?}\n```\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-3 \"Direct link to Upgrade path\")\n\nAfter you upgrade to Prisma ORM 4, any one-to-one or one-to-many relations without a `@unique` or `@id` attribute on the relation field will trigger a validation error. To upgrade, you will need to:\n\n1.  Upgrade to the new Prisma ORM 4 packages following [these instructions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4)\n2.  Manually fix the validation errors in your Prisma schema. Alternatively, if you have an up-to-date live database, running `npx prisma db pull` will add the `@unique` attributes automatically.\n\n#### Disallow `references` syntax for implicit many-to-many relations[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#disallow-references-syntax-for-implicit-many-to-many-relations \"Direct link to disallow-references-syntax-for-implicit-many-to-many-relations\")\n\nWhen using [implicit many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) in Prisma ORM 4, you will no longer be able to use the `references` argument, which was previously optional. For example, the following relation would now trigger a validation error:\n\nschema.prisma\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  categories Category[] @relation(\"my-relation\", references: [id]) // <-- validation error}model Category {  id    Int    @id @default(autoincrement())  posts Post[] @relation(\"my-relation\", references: [id]) // <-- validation error}\n```\n\nInstead, you can write:\n\nschema.prisma\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  categories Category[] @relation(\"my-relation\")}model Category {  id    Int    @id @default(autoincrement())  posts Post[] @relation(\"my-relation\")}\n```\n\nThis is because the only valid value for `references` was `id`, so removing this argument makes it clearer what can and cannot be changed.\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-4 \"Direct link to Upgrade path\")\n\nAfter you upgrade to Prisma ORM 4, any implicit many-to-many relations with a `references` argument will trigger a validation error. To upgrade, you will need to:\n\n1.  Upgrade to the new Prisma ORM 4 packages following [these instructions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4)\n2.  Manually fix the validation errors in your Prisma schema. Alternatively, if you have an up-to-date live database, running `npx prisma db pull` will remove the `references` arguments automatically.\n\n#### Better grammar for string literals[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#better-grammar-for-string-literals \"Direct link to Better grammar for string literals\")\n\nString literals in your Prisma Schema now need to follow the same rules as strings in JSON. This mostly changes the escaping of some special characters. More details can be found in [the JSON specification](https://www.ietf.org/rfc/rfc4627.txt) or on the [JSON website](https://www.json.org/json-en.html).\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-5 \"Direct link to Upgrade path\")\n\nThis is a breaking change for some existing schemas. After you upgrade to Prisma ORM 4, incorrectly escaped characters will trigger a validation error. To upgrade, you will need to:\n\n1.  Upgrade to the new Prisma ORM 4 packages following [these instructions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4)\n2.  Manually fix the validation errors in your Prisma schema.\n\n### Client changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#client-changes \"Direct link to Client changes\")\n\nThis section includes changes that affect Prisma Client.\n\n#### Raw query type mapping: scalar values are now deserialized as their correct JavaScript types[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#raw-query-type-mapping-scalar-values-are-now-deserialized-as-their-correct-javascript-types \"Direct link to Raw query type mapping: scalar values are now deserialized as their correct JavaScript types\")\n\nIn versions 3.14.x and 3.15.x, [raw query type mapping](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-type-mapping) was available with the Preview feature `improvedQueryRaw`. In version 4.0.0, we have made raw query type mapping Generally Available. You do not need to use `improvedQueryRaw` to get this functionality in versions 4.0.0 and later.\n\nRaw queries now deserialize scalar values to their corresponding JavaScript types. Note that Prisma ORM infers types from the values themselves and not from the Prisma Schema types.\n\nExample query and response:\n\n```\nconst res =  await prisma.$queryRaw`SELECT bigint, bytes, decimal, date FROM \"Table\";`console.log(res) // [{ bigint: BigInt(\"123\"), bytes: Buffer.from([1, 2]), decimal: new Prisma.Decimal(\"12.34\"), date: Date(\"<some_date>\") }]\n```\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-6 \"Direct link to Upgrade path\")\n\nFrom version 4.0.0, some data types returned by `queryRaw` or `queryRawUnsafe` are different, as follows:\n\n| Data type | Before version 4.0.0 | From version 4.0.0 |\n| --- | --- | --- |\n| `DateTime` | Returned as `String` | Returned as `Date` |\n| `Numeric` | Returned as `Float` | Returned as `Decimal` |\n| `Bytes` | Returned as `String` | Returned as `Buffer` |\n| `Int64` | Returned as `Integer` | Returned as `BigInt` |\n\nIf you use `queryRaw` or `queryRawUnsafe` to return any of the above data types, then you must change your code to handle the new types.\n\nFor example, if you return `DateTime` data, then you need to take into account the following:\n\n*   You no longer need to manually instantiate a `DateTime` object for the returned data.\n*   If your code currently uses the returned `String` data, then you now need to convert the `DateTime` object to a `String`.\n\nYou must make equivalent code changes for the other data types in the table above.\n\n#### Raw query mapping: PostgreSQL type-casts[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#raw-query-mapping-postgresql-type-casts \"Direct link to Raw query mapping: PostgreSQL type-casts\")\n\nIn versions 3.14.x and 3.15.x, [raw query type mapping](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-type-mapping) was available with the Preview feature `improvedQueryRaw`. In version 4.0.0, we have made raw query type mapping Generally Available. You do not need to use `improvedQueryRaw` to get this functionality in versions 4.0.0 and later.\n\nBefore version 4.0.0, many PostgreSQL type-casts did not work. We have tightened the type coercion rules so that all type-casts now work. As a result, some implicit casts now fail.\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-7 \"Direct link to Upgrade path\")\n\nWe recommend that you re-test your use of `$queryRaw` to ensure that the types you pass into your raw queries match the types that PostgreSQL expects.\n\nFor example, in version 4.0.0, the following query fails:\n\n```\nawait prisma.$queryRaw`select length(${42});`// ERROR: function length(integer) does not exist// HINT: No function matches the given name and argument types. You might need to add explicit type casts.\n```\n\nThis is because PostgreSQL’s `length` function expects `text` as input. Prisma ORM used to silently coerce `42` to `text`, but does not do this in version 4.0.0. To fix this, explicitly cast `42` to `text` as follows:\n\n```\nawait prisma.$queryRaw`select length(${42}::text);`\n```\n\n#### Raw query mapping: PostgreSQL and JavaScript integers[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#raw-query-mapping-postgresql-and-javascript-integers \"Direct link to Raw query mapping: PostgreSQL and JavaScript integers\")\n\nIn versions 3.14.x and 3.15.x, [raw query type mapping](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-type-mapping) was available with the Preview feature `improvedQueryRaw`. In version 4.0.0, we have made raw query type mapping Generally Available. You do not need to use `improvedQueryRaw` to get this functionality in versions 4.0.0 and later.\n\nPrisma ORM sends JavaScript integers to PostgreSQL as `INT8`. This might conflict with your user-defined functions that accept only `INT4` as input.\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-8 \"Direct link to Upgrade path\")\n\nIf you use `$queryRaw` or parametrized `$queryRawUnsafe`queries with a PostgreSQL database, do one of the following:\n\n*   Update the input types of any integers in your user-defined functions to `INT8`, or\n*   Cast any integers in your query parameters to `INT4`.\n\n#### `DbNull`, `JsonNull` and `AnyNull` are now objects[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#dbnull-jsonnull-and-anynull-are-now-objects \"Direct link to dbnull-jsonnull-and-anynull-are-now-objects\")\n\nJavaScript `null` is ambiguous for JSON columns, so Prisma ORM uses `DbNull`, `JsonNull`, and `AnyNull` to distinguish between the database `NULL` value and the JSON `null` value. Before version 4.0.0, `DbNull`, `JsonNull`, and `AnyNull` were string constants. From version 4.0.0, they are objects.\n\nSee [Filtering by null values](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filtering-by-null-values) for more information.\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-9 \"Direct link to Upgrade path\")\n\n1.  If you use literal strings to address these values, then you must replace them with the following named constants:\n    \n    *   `DbNull`: replace with `Prisma.DbNull`\n    *   `JsonNull`: replace with `Prisma.JsonNull`\n    *   `AnyNull`: replace with `Prisma.AnyNull`\n    \n    If you already use these named constants, then you do not need to take any action.\n    \n2.  If you now get a type error when you pass `Prisma.DbNull` as the value of a JSON field, then this probably indicates a bug in your code that our types did not catch before version 4.0.0. The field where you tried to store `DbNull` is probably not nullable in your schema. As a result, a literal `DbNull` string was stored in the database instead of `NULL`.\n    \n3.  You might now encounter a type error or runtime validation error when you use `Prisma.DbNull`, `Prisma.JsonNull`, or `Prisma.AnyNull` with MongoDB. This was never valid, but was silently accepted prior to Prisma ORM 4. You need to review your data and change these fields to `null`.\n    \n4.  If you pass in dynamic JSON to a JSON column in Prisma Client (for example `prisma.findMany({where: { jsonColumn: someJson } })`), then you must check that `someJson`cannot be the string \"DBNull\", \"JsonNull\", or \"AnyNull\". If it is any of these values, then the query will return different results in version 4.0.0.\n    \n\n#### Default fields on composite types in MongoDB[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#default-fields-on-composite-types-in-mongodb \"Direct link to Default fields on composite types in MongoDB\")\n\nFrom version 4.0.0, if you carry out a database read on a composite type when all of the following conditions are true, then Prisma Client inserts the default value into the result.\n\nConditions:\n\n*   A field on the composite type is required, and\n*   this field has a default value, and\n*   this field is not present in the returned document or documents.\n\nThis behavior is now consistent with the behavior for model fields.\n\nTo learn more, see [Default values for required fields on composite types](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#default-values-for-required-fields-on-composite-types).\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-10 \"Direct link to Upgrade path\")\n\nIf you currently rely on a return value of `null`, then you need to refactor your code to handle the default value that is now returned in Prisma ORM 4.\n\n#### Rounding errors on big numbers in SQLite[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#rounding-errors-on-big-numbers-in-sqlite \"Direct link to Rounding errors on big numbers in SQLite\")\n\nSQLite is a loosely-typed database. If your schema has a field with type `Int`, then Prisma ORM prevents you from inserting a value larger than an integer. However, nothing prevents the database from directly accepting a bigger number. These manually-inserted big numbers cause rounding errors when queried.\n\nTo avoid this problem, Prisma ORM version 4.0.0 and later checks numbers on the way out of the database to verify that they fit within the boundaries of an integer. If a number does not fit, then Prisma ORM throws a P2023 error, such as:\n\n```\nInconsistent column data: Conversion failed:Value 9223372036854775807 does not fit in an INT column,try migrating the 'int' column type to BIGINT\n```\n\n##### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-path-11 \"Direct link to Upgrade path\")\n\nIf you use Prisma ORM in conjunction with SQLite, then you need to find any code that queries `Int` fields and ensure that it handles any P2023 errors that might be returned.\n\n#### Prisma ORM no longer exports `Prisma.dmmf.schema` into the generated Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#prisma-orm-no-longer-exports-prismadmmfschema-into-the-generated-prisma-client \"Direct link to prisma-orm-no-longer-exports-prismadmmfschema-into-the-generated-prisma-client\")\n\nFrom version 4.0.0, Prisma ORM no longer exports `Prisma.dmmf.schema` into the generated Prisma Client. This makes the generated Prisma Client much more efficient, and also avoids some memory leaks with Jest.\n\nNote:\n\n*   This change does not affect the DMMF that Prisma ORM passes to the generators.\n*   You can use `getDmmf()`from `@prisma/internals` to access the schema property.\n*   We still export `Prisma.dmmf.datamodel` into the generated Prisma Client.\n\n## Upgrade the `prisma` and `@prisma/client` packages to version 4[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#upgrade-the-prisma-and-prismaclient-packages-to-version-4 \"Direct link to upgrade-the-prisma-and-prismaclient-packages-to-version-4\")\n\nTo upgrade to Prisma ORM 4 from an earlier version, you need to update both the `prisma` and `@prisma/client` packages. Both the `prisma` and `@prisma/client` packages install with a caret `^` in their version number. This allows upgrades to new minor versions, but not major versions, to safeguard against breaking changes.\n\nTo ignore the caret `^` and upgrade across major versions, you can use the `@4` tag when you upgrade with `npm`, or `yarn`:\n\ndanger\n\nBefore you upgrade, check each **breaking change** to see how the upgrade might affect your application.\n\n*   npm\n*   yarn\n\n```\nnpm install prisma@4 @prisma/client@4\n```\n\n## Video guide[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-4#video-guide \"Direct link to Video guide\")\n\nFor a video walkthrough of the upgrade process and examples of upgrade scenarios, see our recorded livestream on upgrading to Prisma ORM 4:",
  "title": "Upgrade to Prisma ORM 4 | Prisma Documentation",
  "description": "Guides on how to upgrade to Prisma ORM 4",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays",
  "markdown": "# Working with scalar lists/arrays (Concepts)\n\n[Scalar lists](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#-modifier) are represented by the `[]` modifier and are only available if the underlying database supports scalar lists. The following example has one scalar `String` list named `pets`:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id   Int      @id @default(autoincrement())  name String  pets String[]}\n```\n\nExample field value:\n\n```\n['Fido', 'Snoopy', 'Brian']\n```\n\n## Setting the value of a scalar list[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays#setting-the-value-of-a-scalar-list \"Direct link to Setting the value of a scalar list\")\n\nThe following example demonstrates how to [`set`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#set-1) the value of a scalar list (`coinflips`) when you create a model:\n\n```\nconst createdUser = await prisma.user.create({  data: {    email: 'eloise@prisma.io',    coinflips: [true, true, true, false, true],  },})\n```\n\n## Unsetting the value of a scalar list[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays#unsetting-the-value-of-a-scalar-list \"Direct link to Unsetting the value of a scalar list\")\n\nwarning\n\nThis method is available on MongoDB only in versions [3.11.1](https://github.com/prisma/prisma/releases/tag/3.11.1) and later.\n\nThe following example demonstrates how to [`unset`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#unset) the value of a scalar list (`coinflips`):\n\n```\nconst createdUser = await prisma.user.create({  data: {    email: 'eloise@prisma.io',    coinflips: {      unset: true,    },  },})\n```\n\nUnlike `set: null`, `unset` removes the list entirely.\n\n## Adding items to a scalar list[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays#adding-items-to-a-scalar-list \"Direct link to Adding items to a scalar list\")\n\nwarning\n\nAvailable for:\n\n*   PostgreSQL in versions [2.15.0](https://github.com/prisma/prisma/releases/tag/2.15.0) and later\n*   CockroachDB in versions [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0) and later\n*   MongoDB in versions [3.11.0](https://github.com/prisma/prisma/releases/tag/3.11.0) and later\n\nUse the [`push`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#push) method to add a single value to a scalar list:\n\n```\nconst userUpdate = await prisma.user.update({  where: {    id: 9,  },  data: {    coinflips: {      push: true,    },  },})\n```\n\nIn earlier versions, you have to overwrite the entire value. The following example retrieves user, uses `push()` to add three new coin flips, and overwrites the `coinflips` field in an `update`:\n\n```\nconst user = await prisma.user.findUnique({  where: {    email: 'eloise@prisma.io',  },})if (user) {  console.log(user.coinflips)  user.coinflips.push(true, true, false)  const updatedUser = await prisma.user.update({    where: {      email: 'eloise@prisma.io',    },    data: {      coinflips: user.coinflips,    },  })  console.log(updatedUser.coinflips)}\n```\n\n## Filtering scalar lists[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays#filtering-scalar-lists \"Direct link to Filtering scalar lists\")\n\nwarning\n\nAvailable for:\n\n*   PostgreSQL in versions [2.15.0](https://github.com/prisma/prisma/releases/tag/2.15.0) and later\n*   CockroachDB in versions [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0) and later\n*   MongoDB in versions [3.11.0](https://github.com/prisma/prisma/releases/tag/3.11.0) and later\n\nUse [scalar list filters](https://www.prisma.io/docs/orm/reference/prisma-client-reference#scalar-list-filters) to filter for records with scalar lists that match a specific condition. The following example returns all posts where the tags list includes `databases` _and_ `typescript`:\n\n```\nconst posts = await prisma.post.findMany({  where: {    tags: {      hasEvery: ['databases', 'typescript'],    },  },})\n```\n\n### `NULL` values in arrays[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-scalar-lists-arrays#null-values-in-arrays \"Direct link to null-values-in-arrays\")\n\nwarning\n\nThis section applies to:\n\n*   PostgreSQL in versions [2.15.0](https://github.com/prisma/prisma/releases/tag/2.15.0) and later\n*   CockroachDB in versions [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0) and later\n\nWhen using scalar list filters with a relational database connector, array fields with a `NULL` value are not considered by the following conditions:\n\n*   `NOT` (array does not contain X)\n*   `isEmpty` (array is empty)\n\nThis means that records you might expect to see are not returned. Consider the following examples:\n\n*   The following query returns all posts where the `tags` **do not** include `databases`:\n    \n    ```\n    const posts = await prisma.post.findMany({  where: {    NOT: {      tags: {        has: 'databases',      },    },  },})\n    ```\n    \n    *   ✔ Arrays that do not contain `\"databases\"`, such as `{\"typescript\", \"graphql\"}`\n    *   ✔ Empty arrays, such as `[]`\n    \n    The query does not return:\n    \n    *   ✘ `NULL` arrays, even though they do not contain `\"databases\"`\n\nThe following query returns all posts where `tags` is empty:\n\n```\nconst posts = await prisma.post.findMany({  where: {    tags: {      isEmpty: true,    },  },})\n```\n\nThe query returns:\n\n*   ✔ Empty arrays, such as `[]`\n\nThe query does not return:\n\n*   ✘ `NULL` arrays, even though they could be considered empty\n\nTo work around this issue, you can set the default value of array fields to `[]`.",
  "title": "Working with scalar lists/arrays (Concepts) | Prisma Documentation",
  "description": "How to read, write, and filter by scalar lists / arrays.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names",
  "markdown": "# Custom model and field names\n\nThe Prisma Client API is generated based on the models in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema). Models are _typically_ 1:1 mappings of your database tables.\n\nIn some cases, especially when using [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection), it might be useful to _decouple_ the naming of database tables and columns from the names that are used in your Prisma Client API. This can be done via the [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections) attributes in your Prisma schema.\n\nYou can use `@map` and `@@map` to rename MongoDB fields and collections respectively. This page uses a relational database example.\n\n## Example: Relational database[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names#example-relational-database \"Direct link to Example: Relational database\")\n\nAssume you have a PostgreSQL relational database schema looking similar to this:\n\n```\nCREATE TABLE users (\tuser_id SERIAL PRIMARY KEY NOT NULL,\tname VARCHAR(256),\temail VARCHAR(256) UNIQUE NOT NULL);CREATE TABLE posts (\tpost_id SERIAL PRIMARY KEY NOT NULL,\tcreated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\ttitle VARCHAR(256) NOT NULL,\tcontent TEXT,\tauthor_id INTEGER REFERENCES users(user_id));CREATE TABLE profiles (\tprofile_id SERIAL PRIMARY KEY NOT NULL,\tbio TEXT,\tuser_id INTEGER NOT NULL UNIQUE REFERENCES users(user_id));CREATE TABLE categories (\tcategory_id SERIAL PRIMARY KEY NOT NULL,\tname VARCHAR(256));CREATE TABLE post_in_categories (\tpost_id INTEGER NOT NULL REFERENCES posts(post_id),\tcategory_id INTEGER NOT NULL REFERENCES categories(category_id));CREATE UNIQUE INDEX post_id_category_id_unique ON post_in_categories(post_id int4_ops,category_id int4_ops);\n```\n\nWhen introspecting a database with that schema, you'll get a Prisma schema looking similar to this:\n\n```\nmodel categories {  category_id        Int                  @id @default(autoincrement())  name               String?              @db.VarChar(256)  post_in_categories post_in_categories[]}model post_in_categories {  post_id     Int  category_id Int  categories  categories @relation(fields: [category_id], references: [category_id], onDelete: NoAction, onUpdate: NoAction)  posts       posts      @relation(fields: [post_id], references: [post_id], onDelete: NoAction, onUpdate: NoAction)  @@unique([post_id, category_id], map: \"post_id_category_id_unique\")}model posts {  post_id            Int                  @id @default(autoincrement())  created_at         DateTime?            @default(now()) @db.Timestamptz(6)  title              String               @db.VarChar(256)  content            String?  author_id          Int?  users              users?               @relation(fields: [author_id], references: [user_id], onDelete: NoAction, onUpdate: NoAction)  post_in_categories post_in_categories[]}model profiles {  profile_id Int     @id @default(autoincrement())  bio        String?  user_id    Int     @unique  users      users   @relation(fields: [user_id], references: [user_id], onDelete: NoAction, onUpdate: NoAction)}model users {  user_id  Int       @id @default(autoincrement())  name     String?   @db.VarChar(256)  email    String    @unique @db.VarChar(256)  posts    posts[]  profiles profiles?}\n```\n\nThere are a few \"issues\" with this Prisma schema when the Prisma Client API is generated:\n\n**Adhering to Prisma ORM's naming conventions**\n\nPrisma ORM has a [naming convention](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions) of **camelCasing** and using the **singular form** for Prisma models. If these naming conventions are not met, the Prisma schema can become harder to interpret and the generated Prisma Client API will feel less natural. Consider the following, generated model:\n\n```\nmodel users {  user_id  Int       @id @default(autoincrement())  name     String?   @db.VarChar(256)  email    String    @unique @db.VarChar(256)  posts    posts[]  profiles profiles?}\n```\n\nAlthough `profiles` refers to a 1:1 relation, its type is currently called `profiles` in plural, suggesting that there might be many `profiles` in this relation. With Prisma ORM conventions, the models and fields were _ideally_ named as follows:\n\n```\nmodel User {  user_id Int      @id @default(autoincrement())  name    String?  @db.VarChar(256)  email   String   @unique @db.VarChar(256)  posts   Post[]  profile Profile?}\n```\n\nBecause these fields are \"Prisma ORM-level\" [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) that do not manifest you can manually rename them in your Prisma schema.\n\n**Naming of annotated relation fields**\n\nForeign keys are represented as a combination of a [annotated relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) and its corresponding relation scalar field in the Prisma schema. Here's how all the relations from the SQL schema are currently represented:\n\n```\nmodel categories {  category_id        Int                  @id @default(autoincrement())  name               String?              @db.VarChar(256)  post_in_categories post_in_categories[] // virtual relation field}model post_in_categories {  post_id     Int // relation scalar field  category_id Int // relation scalar field  categories  categories @relation(fields: [category_id], references: [category_id], onDelete: NoAction, onUpdate: NoAction) // virtual relation field  posts       posts      @relation(fields: [post_id], references: [post_id], onDelete: NoAction, onUpdate: NoAction)  @@unique([post_id, category_id], map: \"post_id_category_id_unique\")}model posts {  post_id            Int                  @id @default(autoincrement())  created_at         DateTime?            @default(now()) @db.Timestamptz(6)  title              String               @db.VarChar(256)  content            String?  author_id          Int?  users              users?               @relation(fields: [author_id], references: [user_id], onDelete: NoAction, onUpdate: NoAction)  post_in_categories post_in_categories[]}model profiles {  profile_id Int     @id @default(autoincrement())  bio        String?  user_id    Int     @unique  users      users   @relation(fields: [user_id], references: [user_id], onDelete: NoAction, onUpdate: NoAction)}model users {  user_id  Int       @id @default(autoincrement())  name     String?   @db.VarChar(256)  email    String    @unique @db.VarChar(256)  posts    posts[]  profiles profiles?}\n```\n\n## Using `@map` and `@@map` to rename fields and models in the Prisma Client API[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names#using-map-and-map-to-rename-fields-and-models-in-the-prisma-client-api \"Direct link to using-map-and-map-to-rename-fields-and-models-in-the-prisma-client-api\")\n\nYou can \"rename\" fields and models that are used in Prisma Client by mapping them to the \"original\" names in the database using the `@map` and `@@map` attributes. For the example above, you could e.g. annotate your models as follows.\n\n_After_ you introspected your database with `prisma db pull`, you can manually adjust the resulting Prisma schema as follows:\n\n```\nmodel Category {  id                 Int                @id @default(autoincrement()) @map(\"category_id\")  name               String?            @db.VarChar(256)  post_in_categories PostInCategories[]  @@map(\"categories\")}model PostInCategories {  post_id     Int  category_id Int  categories  Category @relation(fields: [category_id], references: [id], onDelete: NoAction, onUpdate: NoAction)  posts       Post     @relation(fields: [post_id], references: [id], onDelete: NoAction, onUpdate: NoAction)  @@unique([post_id, category_id], map: \"post_id_category_id_unique\")  @@map(\"post_in_categories\")}model Post {  id                 Int                @id @default(autoincrement()) @map(\"post_id\")  created_at         DateTime?          @default(now()) @db.Timestamptz(6)  title              String             @db.VarChar(256)  content            String?  author_id          Int?  users              User?              @relation(fields: [author_id], references: [id], onDelete: NoAction, onUpdate: NoAction)  post_in_categories PostInCategories[]  @@map(\"posts\")}model Profile {  id      Int     @id @default(autoincrement()) @map(\"profile_id\")  bio     String?  user_id Int     @unique  users   User    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)  @@map(\"profiles\")}model User {  id       Int      @id @default(autoincrement()) @map(\"user_id\")  name     String?  @db.VarChar(256)  email    String   @unique @db.VarChar(256)  posts    Post[]  profiles Profile?  @@map(\"users\")}\n```\n\nWith these changes, you're now adhering to Prisma ORM's naming conventions and the generated Prisma Client API feels more \"natural\":\n\n```\n// Nested writesconst profile = await prisma.profile.create({  data: {    bio: 'Hello World',    users: {      create: {        name: 'Alice',        email: 'alice@prisma.io',      },    },  },})// Fluent APIconst userByProfile = await prisma.profile  .findUnique({    where: { id: 1 },  })  .users()\n```\n\n## Renaming relation fields[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names#renaming-relation-fields \"Direct link to Renaming relation fields\")\n\nPrisma ORM-level [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) (sometimes referred to as \"virtual relation fields\") only exist in the Prisma schema, but do not actually manifest in the underlying database. You can therefore name these fields whatever you want.\n\nConsider the following example of an ambiguous relation in a SQL database:\n\n```\nCREATE TABLE \"User\" (    id SERIAL PRIMARY KEY);CREATE TABLE \"Post\" (    id SERIAL PRIMARY KEY,    \"author\" integer NOT NULL,    \"favoritedBy\" INTEGER,    FOREIGN KEY (\"author\") REFERENCES \"User\"(id),    FOREIGN KEY (\"favoritedBy\") REFERENCES \"User\"(id));\n```\n\nPrisma ORM's introspection will output the following Prisma schema:\n\n```\nmodel Post {  id                          Int   @id @default(autoincrement())  author                      Int  favoritedBy                 Int?  User_Post_authorToUser      User  @relation(\"Post_authorToUser\", fields: [author], references: [id], onDelete: NoAction, onUpdate: NoAction)  User_Post_favoritedByToUser User? @relation(\"Post_favoritedByToUser\", fields: [favoritedBy], references: [id], onDelete: NoAction, onUpdate: NoAction)}model User {  id                          Int    @id @default(autoincrement())  Post_Post_authorToUser      Post[] @relation(\"Post_authorToUser\")  Post_Post_favoritedByToUser Post[] @relation(\"Post_favoritedByToUser\")}\n```\n\nBecause the names of the virtual relation fields `Post_Post_authorToUser` and `Post_Post_favoritedByToUser` are based on the generated relation names, they don't look very friendly in the Prisma Client API. In that case, you can rename the relation fields. For example:\n\n```\nmodel Post {  id                          Int   @id @default(autoincrement())  author                      Int  favoritedBy                 Int?  User_Post_authorToUser      User  @relation(\"Post_authorToUser\", fields: [author], references: [id], onDelete: NoAction, onUpdate: NoAction)  User_Post_favoritedByToUser User? @relation(\"Post_favoritedByToUser\", fields: [favoritedBy], references: [id], onDelete: NoAction, onUpdate: NoAction)}model User {  id             Int    @id @default(autoincrement())  writtenPosts   Post[] @relation(\"Post_authorToUser\")  favoritedPosts Post[] @relation(\"Post_favoritedByToUser\")}\n```\n\ninfo\n\n`prisma db pull` preserves custom relation fields defined in your Prisma schema on re-introspecting your database.",
  "title": "Custom model and field names | Prisma Documentation",
  "description": "Learn how you can decouple the naming of Prisma models from database tables to improve the ergonomics of the generated Prisma Client API.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping",
  "markdown": "# Database mapping | Prisma Documentation\n\nThe [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) includes mechanisms that allow you to define names of certain database objects. You can:\n\n*   [Map model and field names to different collection/table and field/column names](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#mapping-collectiontable-and-fieldcolumn-names)\n*   [Define constraint and index names](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#constraint-and-index-names)\n\n## Mapping collection/table and field/column names[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#mapping-collectiontable-and-fieldcolumn-names \"Direct link to Mapping collection/table and field/column names\")\n\nSometimes the names used to describe entities in your database might not match the names you would prefer in your generated API. Mapping names in the Prisma schema allows you to influence the naming in your Client API without having to change the underlying database names.\n\nA common approach for naming tables/collections in databases for example is to use plural form and [snake\\_case](https://en.wikipedia.org/wiki/Snake_case) notation. However, we recommended a different [naming convention (singular form, PascalCase)](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions).\n\n`@map` and `@@map` allow you to [tune the shape of your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) by decoupling model and field names from table and column names in the underlying database.\n\n### Map collection / table names[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#map-collection--table-names \"Direct link to Map collection / table names\")\n\nAs an example, when you [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) a database with a table named `comments`, the resulting Prisma model will look like this:\n\n```\nmodel comments {  // Fields}\n```\n\nHowever, you can still choose `Comment` as the name of the model (e.g. to follow the naming convention) without renaming the underlying `comments` table in the database by using the [`@@map`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map-1) attribute:\n\n```\nmodel Comment {  // Fields  @@map(\"comments\")}\n```\n\nWith this modified model definition, Prisma Client automatically maps the `Comment` model to the `comments` table in the underlying database.\n\n### Map field / column names[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#map-field--column-names \"Direct link to Map field / column names\")\n\nYou can also [`@map`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map) a column/field name:\n\n```\nmodel Comment {  content String @map(\"comment_text\")  email   String @map(\"commenter_email\")  type    Enum   @map(\"comment_type\")  @@map(\"comments\")}\n```\n\nThis way the `comment_text` column is not available under `prisma.comment.comment_text` in the Prisma Client API, but can be accessed via `prisma.comment.content`.\n\n### Map enum names and values[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#map-enum-names-and-values \"Direct link to Map enum names and values\")\n\nYou can also `@map` an enum value, or `@@map` an enum:\n\n```\nenum Type {  Blog,  Twitter @map(\"comment_twitter\")  @@map(\"comment_source_enum\")}\n```\n\n## Constraint and index names[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#constraint-and-index-names \"Direct link to Constraint and index names\")\n\nYou can optionally use the `map` argument to explicitly define the **underlying constraint and index names** in the Prisma schema for the attributes [`@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id), [`@@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1), [`@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique), [`@@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique-1), [`@@index`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#index) and [`@relation`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relation). (This is available in Prisma ORM version [2.29.0](https://github.com/prisma/prisma/releases/tag/2.29.0) and later.)\n\nWhen introspecting a database, the `map` argument will _only_ be rendered in the schema if the name _differs_ from Prisma ORM's [default constraint naming convention for indexes and constraints](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#prisma-orms-default-naming-conventions-for-indexes-and-constraints).\n\ndanger\n\nIf you use Prisma Migrate in a version earlier than 2.29.0 and want to maintain your existing constraint and index names after upgrading to a newer version, **do not** immediately run `prisma migrate` or `prisma db push`. This will **change any underlying constraint name that does not follow Prisma ORM's convention**. Follow the [upgrade path that allows you to maintain existing constraint and index names](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints#option-1-i-want-to-maintain-my-existing-constraint-and-index-names).\n\n### Use cases for named constraints[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#use-cases-for-named-constraints \"Direct link to Use cases for named constraints\")\n\nSome use cases for explicitly named constraints include:\n\n*   Company policy\n*   Conventions of other tools\n\n### Prisma ORM's default naming conventions for indexes and constraints[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#prisma-orms-default-naming-conventions-for-indexes-and-constraints \"Direct link to Prisma ORM's default naming conventions for indexes and constraints\")\n\nPrisma ORM naming convention was chosen to align with PostgreSQL since it is deterministic. It also helps to maximize the amount of times where names do not need to be rendered because many databases out there they already align with the convention.\n\nPrisma ORM always uses the database names of entities when generating the default index and constraint names. If a model is remapped to a different name in the data model via `@@map` or `@map`, the default name generation will still take the name of the _table_ in the database as input. The same is true for fields and _columns_.\n\n| Entity | Convention | Example |\n| --- | --- | --- |\n| Primary Key | {tablename}\\_pkey | `User_pkey` |\n| Unique Constraint | {tablename}\\_{column\\_names}\\_key | `User_firstName_last_Name_key` |\n| Non-Unique Index | {tablename}\\_{column\\_names}\\_idx | `User_age_idx` |\n| Foreign Key | {tablename}\\_{column\\_names}\\_fkey | `User_childName_fkey` |\n\nSince most databases have a length limit for entity names, the names will be trimmed if necessary to not violate the database limits. We will shorten the part before the `_suffix` as necessary so that the full name is at most the maximum length permitted.\n\n### Using default constraint names[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#using-default-constraint-names \"Direct link to Using default constraint names\")\n\nWhen no explicit names are provided via `map` arguments Prisma ORM will generate index and constraint names following the [default naming convention](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#prisma-orms-default-naming-conventions-for-indexes-and-constraints).\n\nIf you introspect a database the names for indexes and constraints will be added to your schema unless they follow Prisma ORM's naming convention. If they do, the names are not rendered to keep the schema more readable. When you migrate such a schema Prisma will infer the default names and persist them in the database.\n\n#### Example[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#example \"Direct link to Example\")\n\nThe following schema defines three constraints (`@id`, `@unique`, and `@relation`) and one index (`@@index`):\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  name  String @unique  posts Post[]}model Post {  id         Int    @id @default(autoincrement())  title      String  authorName String @default(\"Anonymous\")  author     User?  @relation(fields: [authorName], references: [name])  @@index([title, authorName])}\n```\n\nSince no explicit names are provided via `map` arguments Prisma will assume they follow our default naming convention.\n\nThe following table lists the name of each constraint and index in the underlying database:\n\n| Constraint or index | Follows convention | Underlying constraint or index names |\n| --- | --- | --- |\n| `@id` (on `User` > `id` field) | Yes | `User_pk` |\n| `@@index` (on `Post`) | Yes | `Post_title_authorName_idx` |\n| `@id` (on `Post` > `id` field) | Yes | `Post_pk` |\n| `@relation` (on `Post` > `author`) | Yes | `Post_authorName_fkey` |\n\n### Using custom constraint / index names[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#using-custom-constraint--index-names \"Direct link to Using custom constraint / index names\")\n\nYou can use the `map` argument to define **custom constraint and index names** in the underlying database.\n\n#### Example[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#example-1 \"Direct link to Example\")\n\nThe following example adds custom names to one `@id` and the `@@index`:\n\n```\nmodel User {  id    Int    @id(map: \"Custom_Primary_Key_Constraint_Name\") @default(autoincrement())  name  String @unique  posts Post[]}model Post {  id         Int    @id @default(autoincrement())  title      String  authorName String @default(\"Anonymous\")  author     User?  @relation(fields: [authorName], references: [name])  @@index([title, authorName], map: \"My_Custom_Index_Name\")}\n```\n\nThe following table lists the name of each constraint and index in the underlying database:\n\n| Constraint or index | Follows convention | Underlying constraint or index names |\n| --- | --- | --- |\n| `@id` (on `User` > `id` field) | No  | `Custom_Primary_Key_Constraint_Name` |\n| `@@index` (on `Post`) | No  | `My_Custom_Index_Name` |\n| `@id` (on `Post` > `id` field) | Yes | `Post_pk` |\n| `@relation` (on `Post` > `author`) | Yes | `Post_authorName_fkey` |\n\n### Related: Naming indexes and primary keys for Prisma Client[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#related-naming-indexes-and-primary-keys-for-prisma-client \"Direct link to Related: Naming indexes and primary keys for Prisma Client\")\n\nAdditionally to `map`, the `@@id` and `@@unique` attributes take an optional `name` argument that allows you to customize your Prisma Client API.\n\nOn a model like:\n\n```\nmodel User {  firstName String  lastName  String  @@id([firstName, lastName])}\n```\n\nthe default API for selecting on that primary key uses a generated combination of the fields:\n\n```\nconst user = await prisma.user.findUnique({  where: {    firstName_lastName: {      firstName: 'Paul',      lastName: 'Panther',    },  },})\n```\n\nSpecifying `@@id([firstName, lastName], name: \"fullName\")` will change the Prisma Client API to this instead:\n\n```\nconst user = await prisma.user.findUnique({  where: {    fullName: {      firstName: 'Paul',      lastName: 'Panther',    },  },})\n```",
  "title": "Database mapping | Prisma Documentation",
  "description": "Database mapping in Prisma schema",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing",
  "markdown": "# Patching & hotfixing | Prisma Documentation\n\nPatching or hotfixing a database involves making an often time critical change directly in production. For example, you might add an index directly to a production database to resolve an issue with a slow-running query.\n\nPatching the production database directly results in **schema drift**: your database schema has 'drifted away' from the source of truth, and is out of sync with your migration history. You can use the `prisma migrate resolve` command to reconcile your migration history _without_ having to remove and re-apply the hotfix with `prisma migrate deploy`.\n\nwarning\n\nThis guide **does not apply for MongoDB**.  \nInstead of `migrate dev`, [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) is used for [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb).\n\n## Reconciling your migration history with a patch or hotfix[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#reconciling-your-migration-history-with-a-patch-or-hotfix \"Direct link to Reconciling your migration history with a patch or hotfix\")\n\nThe following scenario assumes that you made a manual change in production and want to propagate that change to your migration history and other databases.\n\nTo reconcile your migration history and database schema in production:\n\n1.  Replicate the change you made in production in the schema - for example, add an `@@index` to a particular model.\n    \n2.  Generate a new migration and take note of the full migration name, including a timestamp, which is written to the CLI:(`20210316150542_retroactively_add_index`):\n    \n    ```\n    npx prisma migrate dev --name retroactively-add-index\n    ```\n    \n3.  Push the migration to production **without running `migrate deploy`**. Instead, mark the migration created in the previous step as 'already applied' so that Prisma Migrate does not attempt to apply your hotfix a second time:\n    \n    ```\n    prisma migrate resolve --applied \"20201127134938-retroactively-add-index\"\n    ```\n    \n    This command adds the migration to the migration history table without running the actual SQL.\n    \n4.  Repeat the previous step for other databases that were patched - for example, if you applied the patch to a staging database.\n    \n5.  Propagate the migration to other databases that were not patched - for example, by committing the migration to source control and allowing your CI/CD pipeline to apply it to all databases.\n    \n\n> **Note**: The migration will not be applied to databases where it has been marked as already applied by the `prisma migrate resolve` command.\n\n## Failed migration[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#failed-migration \"Direct link to Failed migration\")\n\nA migration might fail if:\n\n*   You [modify a migration before running it](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations) and introduce a syntax error\n*   You add a mandatory (`NOT NULL`) column to a table that already has data\n*   The migration process stopped unexpectedly\n*   The database shut down in the middle of the migration process\n\nEach migration in the `_prisma_migrations` table has a `logs` column that stores the error.\n\nThere are two ways to deal with failed migrations in a production environment:\n\n*   Roll back, optionally fix issues, and re-deploy\n*   Manually complete the migration steps and resolve the migration\n\n### Option 1: Mark the migration as rolled back and re-deploy[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#option-1-mark-the-migration-as-rolled-back-and-re-deploy \"Direct link to Option 1: Mark the migration as rolled back and re-deploy\")\n\nThe following example demonstrates how to roll back a migration, optionally make changes to fix the issue, and re-deploy:\n\n1.  Mark the migration as rolled back - this updates the migration record in the `_prisma_migrations` table to register it as rolled back, allowing it to be applied again:\n    \n    ```\n    prisma migrate resolve --rolled-back \"20201127134938_added_bio_index\"\n    ```\n    \n2.  If the migration was partially run, you can either:\n    \n    *   Modify the migration to check if a step was already completed (for example: `CREATE TABLE ... IF NOT EXISTS`) _OR_\n        \n    *   Manually revert the steps that were completed (for example, delete created tables)\n        \n    \n    > If you modify the migration, make sure you copy it back to source control to ensure that state of your production database is reflected exactly in development.\n    \n3.  Fix the root cause of the failed migration, if relevant - for example, if the migration failed due to an issue with the SQL script itself. Make sure that you copy any changed migrations back to source control.\n    \n4.  Re-deploy the migration:\n    \n\n### Option 2: Manually complete migration and resolve as applied[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#option-2-manually-complete-migration-and-resolve-as-applied \"Direct link to Option 2: Manually complete migration and resolve as applied\")\n\nThe following example demonstrates how to manually complete the steps of a migration and mark that migration as applied.\n\n1.  Manually complete the migration steps on the production database. Make sure that any manual steps exactly match the steps in the migration file, and copy any changes back to source control.\n    \n2.  Resolve the migration as applied - this tells Prisma Migrate to consider the migration successfully applied:\n    \n    ```\n    prisma migrate resolve --applied \"20201127134938_my_migration\"\n    ```\n    \n\n## Fixing failed migrations with `migrate diff` and `db execute`[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#fixing-failed-migrations-with-migrate-diff-and-db-execute \"Direct link to fixing-failed-migrations-with-migrate-diff-and-db-execute\")\n\nTo help with fixing a failed migration, Prisma ORM provides the following commands for creating and executing a migration file:\n\n*   [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) which diffs two database schema sources to create a migration taking one to the state of the second. You can output either a summary of the difference or a sql script. The script can be output into a file via `> file_name.sql` or be piped to the `db execute --stdin` command.\n*   [`prisma db execute`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-execute) which applies a SQL script to the database without interacting with the Prisma migrations table.\n\nThese commands are available in Preview in versions `3.9.0` and later (with the `--preview-feature` CLI flag), and generally available in versions `3.13.0` and later.\n\nThis section gives an example scenario of a failed migration, and explains how to use `migrate diff` and `db execute` to fix it.\n\n### Example of a failed migration[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#example-of-a-failed-migration \"Direct link to Example of a failed migration\")\n\nImagine that you have the following `User` model in your schema, in both your local development environment and your production environment:\n\nschema.prisma\n\n```\nmodel User {  id   Int    @id  name String}\n```\n\nAt this point, your schemas are in sync, but the data in the two environments is different.\n\nYou then decide to make changes to your data model, adding another `Post` model and making the `name` field on `User` unique:\n\nschema.prisma\n\n```\nmodel User {  id    Int     @id  name  String  @unique  email String?}model Post {  id    Int    @id  title String}\n```\n\nYou create a migration called 'Unique' with the command `prisma migrate dev -n Unique` which is saved in your local migrations history. Applying the migration succeeds in your dev environment and now it is time to release to production.\n\nUnfortunately this migration can only be partially executed. Creating the `Post` model and adding the `email` column succeeds, but making the `name` field unique fails with the following error:\n\n```\nERROR 1062 (23000): Duplicate entry 'paul' for key 'User_name_key'\n```\n\nThis is because there is non-unique data in your production database (e.g. two users with the same name).\n\nYou now need to recover manually from the partially executed migration. Until you recover from the failed state, further migrations using `prisma migrate deploy` are impossible.\n\nAt this point there are two options, depending on what you decide to do with the non-unique data:\n\n*   You realize that non-unique data is valid and you cannot move forward with your current development work. You want to roll back the complete migration. To do this, see [Moving backwards and reverting all changes](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#moving-backwards-and-reverting-all-changes)\n*   The existence of non-unique data in your database is unintentional and you want to fix that. After fixing, you want to go ahead with the rest of the migration. To do this, see [Moving forwards and applying missing changes](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#moving-forwards-and-applying-missing-changes)\n\n#### Moving backwards and reverting all changes[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#moving-backwards-and-reverting-all-changes \"Direct link to Moving backwards and reverting all changes\")\n\nIn this case, you need to create a migration that takes your production database to the state of your data model before the last migration.\n\n*   First you need your migration history at the time before the failed migration. You can either get this from your git history, or locally delete the folder of the last failed migration in your migration history.\n    \n*   You now want to take your production environment from its current failed state back to the state specified in your local migrations history:\n    \n    *   Run the following `prisma migrate diff` command:\n        \n        ```\n         npx prisma migrate diff \\  --from-url \"$DATABASE_URL_PROD\" \\  --to-migrations ./prisma/migrations \\  --shadow-database-url $SHADOW_DATABASE_URL \\  --script > backward.sql\n        ```\n        \n        This will create a SQL script file containing all changes necessary to take your production environment from its current failed state to the target state defined by your migrations history. Note that because we're using `--to-migrations`, the command requires a [shadow database](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database).\n        \n    *   Run the following `prisma db execute` command:\n        \n        ```\n         npx prisma db execute --url \"$DATABASE_URL_PROD\" --file backward.sql\n        ```\n        \n        This applies the changes in the SQL script against the target database without interacting with the migrations table.\n        \n    *   Run the following `prisma migrate resolve` command:\n        \n        ```\n         npx prisma migrate resolve --rolled-back Unique\n        ```\n        \n        This will mark the failed migration called 'Unique' in the migrations table on your production environment as rolled back.\n        \n\nYour local migration history now yields the same result as the state your production database is in. You can now modify the datamodel again to create a migration that suits your new understanding of the feature you're working on (with non-unique names).\n\n#### Moving forwards and applying missing changes[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#moving-forwards-and-applying-missing-changes \"Direct link to Moving forwards and applying missing changes\")\n\nIn this case, you need to fix the non-unique data and then go ahead with the rest of the migration as planned:\n\n*   The error message from trying to deploy the migration to production already told you there was duplicate data in the column `name`. You need to either alter or delete the offending rows.\n    \n*   Continue applying the rest of the failed migration to get to the data model defined in your `schema.prisma` file:\n    \n    *   Run the following `prisma migrate diff` command:\n        \n        ```\n        npx prisma migrate diff --from-url \"$DATABASE_URL_PROD\" --to-schema-datamodel schema.prisma --script > forward.sql\n        ```\n        \n        This will create a SQL script file containing all changes necessary to take your production environment from its current failed state to the target state defined in your `schema.prisma` file.\n        \n    *   Run the following `prisma db execute` command:\n        \n        ```\n        npx prisma db execute --url \"$DATABASE_URL_PROD\" --file forward.sql\n        ```\n        \n        This applies the changes in the SQL script against the target database without interacting with the migrations table.\n        \n    *   Run the following `prisma migrate resolve` command:\n        \n        ```\n        npx prisma migrate resolve --applied Unique\n        ```\n        \n        This will mark the failed migration called 'Unique' in the migrations table on your production environment as applied.\n        \n\nYour local migration history now yields the same result as the state your production environment is in. You can now continue using the already known `migrate dev` /`migrate deploy` workflow.\n\n## Migration history conflicts[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#migration-history-conflicts \"Direct link to Migration history conflicts\")\n\ninfo\n\nThis does not apply from version [3.12.0](https://github.com/prisma/prisma/releases/tag/3.12.0) upwards.\n\n`prisma migrate deploy` issues a warning if an already applied migration has been edited - however, it does not stop the migration process. To remove the warnings, restore the original migration from source control.\n\n## Prisma Migrate and PgBouncer[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#prisma-migrate-and-pgbouncer \"Direct link to Prisma Migrate and PgBouncer\")\n\nYou might see the following error if you attempt to run Prisma Migrate commands in an environment that uses PgBouncer for connection pooling:\n\n```\nError: undefined: Database errorError querying the database: db error: ERROR: prepared statement \"s0\" already exists\n```\n\nSee [Prisma Migrate and PgBouncer workaround](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer) for further information and a workaround. Follow [GitHub issue #6485](https://github.com/prisma/prisma/issues/6485) for updates.",
  "title": "Patching & hotfixing | Prisma Documentation",
  "description": "How to reconcile the migration history after applying a hotfix or patch to a production environment.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema",
  "markdown": "# How to use Prisma ORM with multiple database schemas\n\nwarning\n\nMultiple database schema support is currently available with the PostgreSQL, CockroachDB, and SQL Server connectors.\n\nMany database providers allow you to organize database tables into named groups. You can use this to make the logical structure of the data model easier to understand, or to avoid naming collisions between tables.\n\nIn PostgreSQL, CockroachDB, and SQL Server, these groups are known as schemas. We will refer to them as _database schemas_ to distinguish them from Prisma ORM's own schema.\n\nThis guide explains how to:\n\n*   include multiple database schemas in your Prisma schema\n*   apply your schema changes to your database with Prisma Migrate and `db push`\n*   introspect an existing database with multiple database schemas\n*   query across multiple database schemas with Prisma Client\n\n## How to enable the `multiSchema` preview feature[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#how-to-enable-the-multischema-preview-feature \"Direct link to how-to-enable-the-multischema-preview-feature\")\n\nMulti-schema support is currently in preview. To enable the `multiSchema` preview feature, add the `multiSchema` feature flag to the `previewFeatures` field of the `generator` block in your Prisma Schema:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"multiSchema\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\n## How to include multiple database schemas in your Prisma schema[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#how-to-include-multiple-database-schemas-in-your-prisma-schema \"Direct link to How to include multiple database schemas in your Prisma schema\")\n\nTo use multiple database schemas in your Prisma schema file, add the names of your database schemas to an array in the `schemas` field, in the `datasource` block. The following example adds a `\"base\"` and a `\"transactional\"` schema:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"multiSchema\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")  schemas  = [\"base\", \"transactional\"]}\n```\n\nYou do not need to change your connection string. The `schema` value of your connection string is the default database schema that Prisma Client connects to and uses for raw queries. All other Prisma Client queries use the schema of the model or enum that you are querying.\n\nTo designate that a model or enum belongs to a specific database schema, add the `@@schema` attribute with the name of the database schema as a parameter. In the following example, the `User` model is part of the `\"base\"` schema, and the `Order` model and `Size` enum are part of the `\"transactional\"` schema:\n\nschema.prisma\n\n```\nmodel User {  id     Int     @id  orders Order[]  @@schema(\"base\")}model Order {  id      Int  @id  user    User @relation(fields: [id], references: [id])  user_id Int  @@schema(\"transactional\")}enum Size {  Small  Medium  Large  @@schema(\"transactional\")}\n```\n\n### Tables with the same name in different database schemas[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#tables-with-the-same-name-in-different-database-schemas \"Direct link to Tables with the same name in different database schemas\")\n\nIf you have tables with the same name in different database schemas, you will need to map the table names to unique model names in your Prisma schema. This avoids name conflicts when you query models in Prisma Client.\n\nFor example, consider a situation where the `config` table in the `base` database schema has the same name as the `config` table in the `users` database schema. To avoid name conflicts, give the models in your Prisma schema unique names (`BaseConfig` and `UserConfig`) and use the `@@map` attribute to map each model to the corresponding table name:\n\nschema.prisma\n\n```\nmodel BaseConfig {  id Int @id  @@map(\"config\")  @@schema(\"base\")}model UserConfig {  id Int @id  @@map(\"config\")  @@schema(\"users\")}\n```\n\n## How to apply your schema changes with Prisma Migrate and `db push`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#how-to-apply-your-schema-changes-with-prisma-migrate-and-db-push \"Direct link to how-to-apply-your-schema-changes-with-prisma-migrate-and-db-push\")\n\nYou can use Prisma Migrate or `db push` to apply changes to a Prisma schema with multiple database schemas.\n\nAs an example, add a `Profile` model to the `base` schema of the blog post model above:\n\nschema.prisma\n\n```\nmodel User {  id      Int      @id  orders  Order[]  profile Profile?  @@schema(\"base\")}model Profile {  id     Int    @id @default(autoincrement())  bio    String  user   User   @relation(fields: [userId], references: [id])  userId Int    @unique  @@schema(\"base\")}model Order {  id      Int  @id  user    User @relation(fields: [id], references: [id])  user_id Int  @@schema(\"transactional\")}enum Size {  Small  Medium  Large  @@schema(\"transactional\")}\n```\n\nYou can then apply this schema change to your database. For example, you can use `migrate dev` to create and apply your schema changes as a migration:\n\n```\nnpx prisma migrate dev --name add_profile\n```\n\nNote that if you move a model or enum from one schema to another, Prisma ORM deletes the model or enum from the source schema and creates a new one in the target schema.\n\n## How to introspect an existing database with multiple database schemas[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#how-to-introspect-an-existing-database-with-multiple-database-schemas \"Direct link to How to introspect an existing database with multiple database schemas\")\n\nYou can introspect an existing database that has multiple database schemas in the same way that you introspect a database that has a single database schema, using `db pull`:\n\nThis updates your Prisma schema to match the current state of the database.\n\nIf you have tables with the same name in different database schemas, Prisma ORM shows a validation error pointing out the conflict. To fix this, [rename the introspected models with the `@map` attribute](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#tables-with-the-same-name-in-different-database-schemas).\n\n## How to query across multiple database schemas with Prisma Client[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#how-to-query-across-multiple-database-schemas-with-prisma-client \"Direct link to How to query across multiple database schemas with Prisma Client\")\n\nYou can query models in multiple database schemas without any change to your Prisma Client query syntax. For example, the following query finds all orders for a given user, using the Prisma schema above:\n\n```\nconst orders = await prisma.order.findMany({  where: {    user: {      id: 1,    },  },})\n```\n\n## Learn more about the `multiSchema` preview feature[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/multi-schema#learn-more-about-the-multischema-preview-feature \"Direct link to learn-more-about-the-multischema-preview-feature\")\n\nTo learn more about future plans for the `multiSchema` preview feature, or to give feedback, refer to [our Github issue](https://github.com/prisma/prisma/issues/1122).",
  "title": "How to use Prisma ORM with multiple database schemas | Prisma Documentation",
  "description": "How to use Prisma ORM with multiple database schemas",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging",
  "markdown": "# Logging | Prisma Documentation\n\n```\nconst prisma = new PrismaClient({  log: [    {      emit: 'event',      level: 'query',    },    {      emit: 'stdout',      level: 'error',    },    {      emit: 'stdout',      level: 'info',    },    {      emit: 'stdout',      level: 'warn',    },  ],})prisma.$on('query', (e) => {  console.log('Query: ' + e.query)  console.log('Params: ' + e.params)  console.log('Duration: ' + e.duration + 'ms')})\n```",
  "title": "Logging | Prisma Documentation",
  "description": "Learn how to configure Prisma Client to log the raw SQL queries it sends to the database and other information.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator",
  "markdown": "# Prisma validator | Prisma Documentation\n\nThe [`Prisma.validator`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#prismavalidator) is a utility function that takes a generated type and returns a type-safe object which adheres to the generated types model fields.\n\nThis page introduces the `Prisma.validator` and offers some motivations behind why you might choose to use it.\n\n> **Note**: If you have a use case for `Prisma.validator`, be sure to check out this [blog post](https://www.prisma.io/blog/satisfies-operator-ur8ys8ccq7zb) about improving your Prisma Client workflows with the new TypeScript `satisfies` keyword. It's likely that you can solve your use case natively using `satisfies` instead of using `Prisma.validator`.\n\n## Creating a typed query statement[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator#creating-a-typed-query-statement \"Direct link to Creating a typed query statement\")\n\nLet's imagine that you created a new `userEmail` object that you wanted to re-use in different queries throughout your application. It's typed and can be safely used in queries.\n\nThe below example asks `Prisma` to return the `email` of the user whose `id` is 3, if no user exists it will return `null`.\n\n```\nimport { Prisma } from '@prisma/client'const userEmail: Prisma.UserSelect = {  email: true,}// Run inside async functionconst user = await prisma.user.findUnique({  where: {    id: 3,  },  select: userEmail,})\n```\n\nThis works well but there is a caveat to extracting query statements this way.\n\nYou'll notice that if you hover your mouse over `userEmail` TypeScript won't infer the object's key or value (that is, `email: true`).\n\nThe same applies if you use dot notation on `userEmail` within the `prisma.user.findUnique(...)` query, you will be able to access all of the properties available to a `select` object.\n\nIf you are using this in one file that may be fine, but if you are going to export this object and use it in other queries, or if you are compiling an external library where you want to control how the user uses this object within their queries then this won't be type-safe.\n\nThe object `userEmail` has been created to select only the user's `email`, and yet it still gives access to all the other properties available. **It is typed, but not type-safe**.\n\n`Prisma` has a way to validate generated types to make sure they are type-safe, a utility function available on the namespace called `validator`.\n\n## Using the `Prisma.validator`[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator#using-the-prismavalidator \"Direct link to using-the-prismavalidator\")\n\nThe following example passes the `UserSelect` generated type into the `Prisma.validator` utility function and defines the expected return type in much the same way as the previous example.\n\n```\nimport { Prisma } from '@prisma/client'const userEmail: Prisma.UserSelect = {  email: true,}const userEmail = Prisma.validator<Prisma.UserSelect>()({  email: true,})// Run inside async functionconst user = await prisma.user.findUnique({  where: {    id: 3,  },  select: userEmail,})\n```\n\nAlternatively, you can use the following syntax that uses a \"selector\" pattern using an existing instance of Prisma Client:\n\n```\nimport { Prisma } from '@prisma/client'import prisma from './lib/prisma'const userEmail = Prisma.validator(  prisma,  'user',  'findUnique',  'select')({  email: true,})\n```\n\nThe big difference is that the `userEmail` object is now type-safe. If you hover your mouse over it TypeScript will tell you the object's key/value pair. If you use dot notation to access the object's properties you will only be able to access the `email` property of the object.\n\nThis functionality is handy when combined with user defined input, like form data.\n\n## Combining `Prisma.validator` with form input[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator#combining-prismavalidator-with-form-input \"Direct link to combining-prismavalidator-with-form-input\")\n\nThe following example creates a type-safe function from the `Prisma.validator` which can be used when interacting with user created data, such as form inputs.\n\n> **Note**: Form input is determined at runtime so can't be verified by only using TypeScript. Be sure to validate your form input through other means too (such as an external validation library) before passing that data through to your database.\n\n```\nimport { Prisma, PrismaClient } from '@prisma/client'const prisma = new PrismaClient()// Create a new function and pass the parameters onto the validatorconst createUserAndPost = (  name: string,  email: string,  postTitle: string,  profileBio: string) => {  return Prisma.validator<Prisma.UserCreateInput>()({    name,    email,    posts: {      create: {        title: postTitle,      },    },    profile: {      create: {        bio: profileBio,      },    },  })}const findSpecificUser = (email: string) => {  return Prisma.validator<Prisma.UserWhereInput>()({    email,  })}// Create the user in the database based on form input// Run inside async functionawait prisma.user.create({  data: createUserAndPost(    'Rich',    'rich@boop.com',    'Life of Pie',    'Learning each day'  ),})// Find the specific user based on form input// Run inside async functionconst oneUser = await prisma.user.findUnique({  where: findSpecificUser('rich@boop.com'),})\n```\n\nThe `createUserAndPost` custom function is created using the `Prisma.validator` and passed a generated type, `UserCreateInput`. The `Prisma.validator` validates the functions input because the types assigned to the parameters must match those the generated type expects.",
  "title": "Prisma validator | Prisma Documentation",
  "description": "The Prisma validator is a utility function that takes a generated type and returns a type-safe object which adheres to the generated types model fields.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries",
  "markdown": "# Compare columns of the same table with raw queries\n\n## Problem[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries#problem \"Direct link to Problem\")\n\nComparing different columns from the same table is a common scenario that developers encounter. Some examples include comparing two numeric values in the same table or comparing two dates in a same table. There's an existing [GitHub Issue](https://github.com/prisma/prisma/issues/5048) regarding the same.\n\ninfo\n\nFrom version 4.3.0, you do not need to use raw queries to compare columns in the same table. You can use the `<model>.fields` property to compare the columns. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#compare-columns-in-the-same-table)\n\n## Workaround[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries#workaround \"Direct link to Workaround\")\n\nComparing values from two columns in the same table can be achieved by using [raw queries](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries).\n\n### Comparing numeric values[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries#comparing-numeric-values \"Direct link to Comparing numeric values\")\n\ninfo\n\nFrom version 4.3.0, you do not need to use raw queries to compare columns in the same table. You can use the `<model>.fields` property to compare the columns. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#compare-columns-in-the-same-table)\n\nOne use case for comparing values from different columns would be retrieving posts that have more comments than likes; in this case, you need to compare the values of `commentsCount` and `likesCount`.\n\n```\nmodel Post {  id            Int      @id @default(autoincrement())  createdAt     DateTime @default(now())  updatedAt     DateTime @updatedAt  title         String  content       String?  published     Boolean  @default(false)  author        User     @relation(fields: [authorId], references: [id])  authorId      Int  likesCount    Int  commentsCount Int}\n```\n\nQueries (depending upon which database) could look something like:\n\n_PostgreSQL / CockroachDB_\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function initiateNumbersComparisonRawQuery() {  const response =    await prisma.$queryRaw`SELECT * FROM \"public\".\"Post\" WHERE \"likesCount\" < \"commentsCount\";`  console.log(response)}await initiateNumbersComparisonRawQuery()\n```\n\n_MySQL_\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function initiateNumbersComparisonRawQuery() {  const response =    await prisma.$queryRaw`SELECT * FROM \\`public\\`.\\`Post\\` WHERE \\`likesCount\\` < \\`commentsCount\\`;`  console.log(response)}await initiateNumbersComparisonRawQuery()\n```\n\n_Sqlite_\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function initiateNumbersComparisonRawQuery() {  const response =    await prisma.$queryRaw`SELECT * FROM \"Post\" WHERE \"likesCount\" < \"commentsCount\";`  console.log(response)}await initiateNumbersComparisonRawQuery()\n```\n\nRunning the above queries (depending upon the database) would filter posts that has fewer likes compared to comments.\n\n_Query Response_\n\n```\n;[  {    id: 1,    createdAt: '2022-03-03T12:08:11.421+00:00',    updatedAt: '2022-03-03T12:08:11.422+00:00',    title: 'Hello World',    content: 'This is my first post',    published: false,    authorId: 1,    likesCount: 50,    commentsCount: 100,  },]\n```\n\n### Comparing date values[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries#comparing-date-values \"Direct link to Comparing date values\")\n\ninfo\n\nFrom version 4.3.0, you do not need to use raw queries to compare columns in the same table. You can use the `<model>.fields` property to compare the columns. [Learn more](https://www.prisma.io/docs/orm/reference/prisma-client-reference#compare-columns-in-the-same-table)\n\nSimilarly, if you need to compare dates, you could also achieve the same thing using raw queries.\n\nFor example, a use case could be to get all projects completed after the due date.\n\n```\nmodel Project {  id            Int      @id @default(autoincrement())  title         String  author        User     @relation(fields: [authorId], references: [id])  authorId      Int  dueDate       DateTime  completedDate DateTime  createdAt     DateTime @default(now())}\n```\n\nQueries (depending upon the database) could look something like:\n\n_PostgreSQL / CockroachDB_\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function initiateDatesComparisonRawQuery() {  const response =    await prisma.$queryRaw`SELECT * FROM \"public\".\"Project\" WHERE \"completedDate\" > \"dueDate\";`  console.log(response)}await initiateDatesComparisonRawQuery()\n```\n\n_MySQL_\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function initiateDatesComparisonRawQuery() {  const response =    await prisma.$queryRaw`SELECT * FROM \\`public\\`.\\`Project\\` WHERE \\`completedDate\\` > \\`dueDate\\`;`  console.log(response)}await initiateDatesComparisonRawQuery()\n```\n\n_Sqlite_\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function initiateDatesComparisonRawQuery() {  const response =    await prisma.$queryRaw`SELECT * FROM \"Project\" WHERE \"completedDate\" > \"dueDate\";`  console.log(response)}await initiateDatesComparisonRawQuery()\n```\n\nRunning the above query would fetch projects where `completedDate` is after the `dueDate`.\n\n_Query Response_\n\n```\n;[  {    id: 1,    title: 'Project 1',    authorId: 1,    dueDate: '2022-03-10T00:00:00+00:00',    completedDate: '2022-03-12T00:00:00+00:00',    createdAt: '2022-03-03T12:08:11.421+00:00',  },]\n```",
  "title": "Compare columns of the same table with raw queries | Prisma Documentation",
  "description": "Compare columns with inbuilt raw query methods in Prisma",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types",
  "markdown": "# Composite types | Prisma Documentation\n\nwarning\n\nComposite types are only available with MongoDB.\n\n[Composite types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types), known as [embedded documents](https://docs.mongodb.com/manual/core/data-model-design/#std-label-data-modeling-embedding) in MongoDB, allow you to embed records within other records.\n\nWe made composite types [Generally Available](https://www.prisma.io/docs/orm/more/releases#generally-available-ga) in v3.12.0. They were previously available in [Preview](https://www.prisma.io/docs/orm/reference/preview-features) from v3.10.0.\n\nThis page explains how to:\n\n*   [find](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#finding-records-that-contain-composite-types-with-find-and-findmany) records that contain composite types using `findFirst` and `findMany`\n*   [create](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#creating-records-with-composite-types-using-create-and-createmany) new records with composite types using `create` and `createMany`\n*   [update](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#changing-composite-types-within-update-and-updatemany) composite types within existing records using `update` and `updateMany`\n*   [delete](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#deleting-records-that-contain-composite-types-with-delete-and-deletemany) records with composite types using `delete` and `deleteMany`\n\n## Example schema[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#example-schema \"Direct link to Example schema\")\n\nWe’ll use this schema for the examples that follow:\n\nschema.prisma\n\n```\ngenerator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}model Product {  id     String  @id @default(auto()) @map(\"_id\") @db.ObjectId  name   String  @unique  price  Float  colors Color[]  sizes  Size[]  photos Photo[]  orders Order[]}model Order {  id              String   @id @default(auto()) @map(\"_id\") @db.ObjectId  product         Product  @relation(fields: [productId], references: [id])  color           Color  size            Size  shippingAddress Address  billingAddress  Address?  productId       String   @db.ObjectId}enum Color {  Red  Green  Blue}enum Size {  Small  Medium  Large  XLarge}type Photo {  height Int    @default(200)  width  Int    @default(100)  url    String}type Address {  street String  city   String  zip    String}\n```\n\nIn this schema, the `Product` model has a `Photo[]` composite type, and the `Order` model has two composite `Address` types. The `shippingAddress` is required, but the `billingAddress` is optional.\n\n## Considerations when using composite types[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#considerations-when-using-composite-types \"Direct link to Considerations when using composite types\")\n\nThere are currently some limitations when using composite types in Prisma Client:\n\n*   [`findUnique()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#findunique) can't filter on composite types\n*   [`aggregate`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#aggregate), [`groupBy()`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#group-by), [`count`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count) don’t support composite operations\n\n## Default values for required fields on composite types[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#default-values-for-required-fields-on-composite-types \"Direct link to Default values for required fields on composite types\")\n\nFrom version 4.0.0, if you carry out a database read on a composite type when all of the following conditions are true, then Prisma Client inserts the default value into the result.\n\nConditions:\n\n*   A field on the composite type is [required](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#optional-and-mandatory-fields), and\n*   this field has a [default value](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-a-default-value), and\n*   this field is not present in the returned document or documents.\n\nNote:\n\n*   This is the same behavior as with [model fields](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types).\n*   On read operations, Prisma Client inserts the default value into the result, but does not insert the default value into the database.\n\nIn our example schema, suppose that you add a required field to `photo`. This field, `bitDepth`, has a default value:\n\nschema.prisma\n\n```\n...type Photo {  ...  bitDepth Int @default(8)}...\n```\n\nSuppose that you then run `npx prisma migrate deploy` to [deploy your database changes](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-database-changes-with-prisma-migrate) and regenerate your Prisma Client with `npx prisma generate`. Then, you run the following application code:\n\n```\nconsole.dir(await prisma.product.findMany({}), { depth: Infinity })\n```\n\nThe `bitDepth` field has no content because you have only just added this field, so the query returns the default value of `8`.\n\n\\*\\* Earlier versions \\*\\*\n\nBefore version 4.0.0, Prisma ORM threw a P2032 error as follows:\n\n```\nError converting field \"bitDepth\" of expected non-nullabletype \"int\", found incompatible value of \"null\".\n```\n\n## Finding records that contain composite types with `find` and `findMany`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#finding-records-that-contain-composite-types-with-find-and-findmany \"Direct link to finding-records-that-contain-composite-types-with-find-and-findmany\")\n\nRecords can be filtered by a composite type within the `where` operation.\n\nThe following section describes the operations available for filtering by a single type or multiple types, and gives examples of each.\n\n### Filtering for one composite type[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#filtering-for-one-composite-type \"Direct link to Filtering for one composite type\")\n\nUse the `is`, `equals`, `isNot` and `isSet` operations to change a single composite type:\n\n*   `is`: Filter results by matching composite types. Requires one or more fields to be present _(e.g. Filter orders by the street name on the shipping address)_\n*   `equals`: Filter results by matching composite types. Requires all fields to be present. _(e.g. Filter orders by the full shipping address)_\n*   `isNot`: Filter results by non-matching composite types\n*   `isSet` : Filter optional fields to include only results that have been set (either set to a value, or explicitly set to `null`). Setting this filter to `true` will exclude `undefined` results that are not set at all.\n\nFor example, use `is` to filter for orders with a street name of `'555 Candy Cane Lane'`:\n\n```\nconst orders = await prisma.order.findMany({  where: {    shippingAddress: {      is: {        street: '555 Candy Cane Lane',      },    },  },})\n```\n\nUse `equals` to filter for orders which match on all fields in the shipping address:\n\n```\nconst orders = await prisma.order.findMany({  where: {    shippingAddress: {      equals: {        street: '555 Candy Cane Lane',        city: 'Wonderland',        zip: '52337',      },    },  },})\n```\n\nYou can also use a shorthand notation for this query, where you leave out the `equals`:\n\n```\nconst orders = await prisma.order.findMany({  where: {    shippingAddress: {      street: '555 Candy Cane Lane',      city: 'Wonderland',      zip: '52337',    },  },})\n```\n\nUse `isNot` to filter for orders that do not have a `zip` code of `'52337'`:\n\n```\nconst orders = await prisma.order.findMany({  where: {    shippingAddress: {      isNot: {        zip: '52337',      },    },  },})\n```\n\nUse `isSet` to filter for orders where the optional `billingAddress` has been set (either to a value or to `null`):\n\n```\nconst orders = await prisma.order.findMany({  where: {    billingAddress: {      isSet: true,    },  },})\n```\n\n### Filtering for many composite types[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#filtering-for-many-composite-types \"Direct link to Filtering for many composite types\")\n\nUse the `equals`, `isEmpty`, `every`, `some` and `none` operations to filter for multiple composite types:\n\n*   `equals`: Checks exact equality of the list\n*   `isEmpty`: Checks if the list is empty\n*   `every`: Every item in the list must match the condition\n*   `some`: One or more of the items in the list must match the condition\n*   `none`: None of the items in the list can match the condition\n*   `isSet` : Filter optional fields to include only results that have been set (either set to a value, or explicitly set to `null`). Setting this filter to `true` will exclude `undefined` results that are not set at all.\n\nFor example, you can use `equals` to find products with a specific list of photos (all `url`, `height` and `width` fields must match):\n\n```\nconst product = prisma.product.findMany({  where: {    photos: {      equals: [        {          url: '1.jpg',          height: 200,          width: 100,        },        {          url: '2.jpg',          height: 200,          width: 100,        },      ],    },  },})\n```\n\nYou can also use a shorthand notation for this query, where you leave out the `equals` and specify just the fields that you want to filter for:\n\n```\nconst product = prisma.product.findMany({  where: {    photos: [      {        url: '1.jpg',        height: 200,        width: 100,      },      {        url: '2.jpg',        height: 200,        width: 100,      },    ],  },})\n```\n\nUse `isEmpty` to filter for products with no photos:\n\n```\nconst product = prisma.product.findMany({  where: {    photos: {      isEmpty: true,    },  },})\n```\n\nUse `some` to filter for products where one or more photos has a `url` of `\"2.jpg\"`:\n\n```\nconst product = prisma.product.findFirst({  where: {    photos: {      some: {        url: '2.jpg',      },    },  },})\n```\n\nUse `none` to filter for products where no photos have a `url` of `\"2.jpg\"`:\n\n```\nconst product = prisma.product.findFirst({  where: {    photos: {      none: {        url: '2.jpg',      },    },  },})\n```\n\n## Creating records with composite types using `create` and `createMany`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#creating-records-with-composite-types-using-create-and-createmany \"Direct link to creating-records-with-composite-types-using-create-and-createmany\")\n\ninfo\n\nWhen you create a record with a composite type that has a unique restraint, note that MongoDB does not enforce unique values inside a record. [Learn more](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#duplicate-values-in-unique-fields-of-composite-types).\n\nComposite types can be created within a `create` or `createMany` method using the `set` operation. For example, you can use `set` within `create` to create an `Address` composite type inside an `Order`:\n\n```\nconst order = await prisma.order.create({  data: {    // Normal relation    product: { connect: { id: 'some-object-id' } },    color: 'Red',    size: 'Large',    // Composite type    shippingAddress: {      set: {        street: '1084 Candycane Lane',        city: 'Silverlake',        zip: '84323',      },    },  },})\n```\n\nYou can also use a shorthand notation where you leave out the `set` and specify just the fields that you want to create:\n\n```\nconst order = await prisma.order.create({  data: {    // Normal relation    product: { connect: { id: 'some-object-id' } },    color: 'Red',    size: 'Large',    // Composite type    shippingAddress: {      street: '1084 Candycane Lane',      city: 'Silverlake',      zip: '84323',    },  },})\n```\n\nFor an optional type, like the `billingAddress`, you can also set the value to `null`:\n\n```\nconst order = await prisma.order.create({  data: {    // Normal relation    product: { connect: { id: 'some-object-id' } },    color: 'Red',    size: 'Large',    // Composite type    shippingAddress: {      street: '1084 Candycane Lane',      city: 'Silverlake',      zip: '84323',    },    // Embedded optional type, set to null    billingAddress: {      set: null,    },  },})\n```\n\nTo model the case where an `product` contains a list of multiple `photos`, you can `set` multiple composite types at once:\n\n```\nconst product = await prisma.product.create({  data: {    name: 'Forest Runners',    price: 59.99,    colors: ['Red', 'Green'],    sizes: ['Small', 'Medium', 'Large'],    // New composite type    photos: {      set: [        { height: 100, width: 200, url: '1.jpg' },        { height: 100, width: 200, url: '2.jpg' },      ],    },  },})\n```\n\nYou can also use a shorthand notation where you leave out the `set` and specify just the fields that you want to create:\n\n```\nconst product = await prisma.product.create({  data: {    name: 'Forest Runners',    price: 59.99,    // Scalar lists that we already support    colors: ['Red', 'Green'],    sizes: ['Small', 'Medium', 'Large'],    // New composite type    photos: [      { height: 100, width: 200, url: '1.jpg' },      { height: 100, width: 200, url: '2.jpg' },    ],  },})\n```\n\nThese operations also work within the `createMany` method. For example, you can create multiple `product`s which each contain a list of `photos`:\n\n```\nconst product = await prisma.product.createMany({  data: [    {      name: 'Forest Runners',      price: 59.99,      colors: ['Red', 'Green'],      sizes: ['Small', 'Medium', 'Large'],      photos: [        { height: 100, width: 200, url: '1.jpg' },        { height: 100, width: 200, url: '2.jpg' },      ],    },    {      name: 'Alpine Blazers',      price: 85.99,      colors: ['Blue', 'Red'],      sizes: ['Large', 'XLarge'],      photos: [        { height: 100, width: 200, url: '1.jpg' },        { height: 150, width: 200, url: '4.jpg' },        { height: 200, width: 200, url: '5.jpg' },      ],    },  ],})\n```\n\n## Changing composite types within `update` and `updateMany`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#changing-composite-types-within-update-and-updatemany \"Direct link to changing-composite-types-within-update-and-updatemany\")\n\ninfo\n\nWhen you update a record with a composite type that has a unique restraint, note that MongoDB does not enforce unique values inside a record. [Learn more](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#duplicate-values-in-unique-fields-of-composite-types).\n\nComposite types can be set, updated or removed within an `update` or `updateMany` method. The following section describes the operations available for updating a single type or multiple types at once, and gives examples of each.\n\n### Changing a single composite type[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#changing-a-single-composite-type \"Direct link to Changing a single composite type\")\n\nUse the `set`, `unset` `update` and `upsert` operations to change a single composite type:\n\n*   Use `set` to set a composite type, overriding any existing value\n*   Use `unset` to unset a composite type. Unlike `set: null`, `unset` removes the field entirely\n*   Use `update` to update a composite type\n*   Use `upsert` to `update` an existing composite type if it exists, and otherwise `set` the composite type\n\nFor example, use `update` to update a required `shippingAddress` with an `Address` composite type inside an `Order`:\n\n```\nconst order = await prisma.order.update({  where: {    id: 'some-object-id',  },  data: {    shippingAddress: {      // Update just the zip field      update: {        zip: '41232',      },    },  },})\n```\n\nFor an optional embedded type, like the `billingAddress`, use `upsert` to create a new record if it does not exist, and update the record if it does:\n\n```\nconst order = await prisma.order.update({  where: {    id: 'some-object-id',  },  data: {    billingAddress: {      // Create the address if it doesn't exist,      // otherwise update it      upsert: {        set: {          street: '1084 Candycane Lane',          city: 'Silverlake',          zip: '84323',        },        update: {          zip: '84323',        },      },    },  },})\n```\n\nYou can also use the `unset` operation to remove an optional embedded type. The following example uses `unset` to remove the `billingAddress` from an `Order`:\n\n```\nconst order = await prisma.order.update({  where: {    id: 'some-object-id',  },  data: {    billingAddress: {      // Unset the billing address      // Removes \"billingAddress\" field from order      unset: true,    },  },})\n```\n\nYou can use [filters](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#finding-records-that-contain-composite-types-with-find-and-findmany) within `updateMany` to update all records that match a composite type. The following example uses the `is` filter to match the street name from a shipping address on a list of orders:\n\n```\nconst orders = await prisma.order.updateMany({  where: {    shippingAddress: {      is: {        street: '555 Candy Cane Lane',      },    },  },  data: {    shippingAddress: {      update: {        street: '111 Candy Cane Drive',      },    },  },})\n```\n\n### Changing multiple composite types[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#changing-multiple-composite-types \"Direct link to Changing multiple composite types\")\n\nUse the `set`, `push`, `updateMany` and `deleteMany` operations to change a list of composite types:\n\n*   `set`: Set an embedded list of composite types, overriding any existing list\n*   `push`: Push values to the end of an embedded list of composite types\n*   `updateMany`: Update many composite types at once\n*   `deleteMany`: Delete many composite types at once\n\nFor example, use `push` to add a new photo to the `photos` list:\n\n```\nconst product = prisma.product.update({  where: {    id: '62de6d328a65d8fffdae2c18',  },  data: {    photos: {      // Push a photo to the end of the photos list      push: [{ height: 100, width: 200, url: '1.jpg' }],    },  },})\n```\n\nUse `updateMany` to update photos with a `url` of `1.jpg` or `2.png`:\n\n```\nconst product = prisma.product.update({  where: {    id: '62de6d328a65d8fffdae2c18',  },  data: {    photos: {      updateMany: {        where: {          url: '1.jpg',        },        data: {          url: '2.png',        },      },    },  },})\n```\n\nThe following example uses `deleteMany` to delete all photos with a `height` of 100:\n\n```\nconst product = prisma.product.update({  where: {    id: '62de6d328a65d8fffdae2c18',  },  data: {    photos: {      deleteMany: {        where: {          height: 100,        },      },    },  },})\n```\n\n## Upserting composite types with `upsert`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#upserting-composite-types-with-upsert \"Direct link to upserting-composite-types-with-upsert\")\n\ninfo\n\nWhen you create or update the values in a composite type that has a unique restraint, note that MongoDB does not enforce unique values inside a record. [Learn more](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#duplicate-values-in-unique-fields-of-composite-types).\n\nTo create or update a composite type, use the `upsert` method. You can use the same composite operations as the `create` and `update` methods above.\n\nFor example, use `upsert` to either create a new product or add a photo to an existing product:\n\n```\nconst product = await prisma.product.upsert({  where: {    name: 'Forest Runners',  },  create: {    name: 'Forest Runners',    price: 59.99,    colors: ['Red', 'Green'],    sizes: ['Small', 'Medium', 'Large'],    photos: [      { height: 100, width: 200, url: '1.jpg' },      { height: 100, width: 200, url: '2.jpg' },    ],  },  update: {    photos: {      push: { height: 300, width: 400, url: '3.jpg' },    },  },})\n```\n\n## Deleting records that contain composite types with `delete` and `deleteMany`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#deleting-records-that-contain-composite-types-with-delete-and-deletemany \"Direct link to deleting-records-that-contain-composite-types-with-delete-and-deletemany\")\n\nTo remove records which embed a composite type, use the `delete` or `deleteMany` methods. This will also remove the embedded composite type.\n\nFor example, use `deleteMany` to delete all products with a `size` of `\"Small\"`. This will also delete any embedded `photos`.\n\n```\nconst deleteProduct = await prisma.product.deleteMany({  where: {    sizes: {      equals: 'Small',    },  },})\n```\n\nYou can also use [filters](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#finding-records-that-contain-composite-types-with-find-and-findmany) to delete records that match a composite type. The example below uses the `some` filter to delete products that contain a certain photo:\n\n```\nconst product = await prisma.product.deleteMany({  where: {    photos: {      some: {        url: '2.jpg',      },    },  },})\n```\n\n## Ordering composite types[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#ordering-composite-types \"Direct link to Ordering composite types\")\n\nYou can use the `orderBy` operation to sort results in ascending or descending order.\n\nFor example, the following command finds all orders and orders them by the city name in the shipping address, in ascending order:\n\n```\nconst orders = await prisma.order.findMany({  orderBy: {    shippingAddress: {      city: 'asc',    },  },})\n```\n\n## Duplicate values in unique fields of composite types[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#duplicate-values-in-unique-fields-of-composite-types \"Direct link to Duplicate values in unique fields of composite types\")\n\nBe careful when you carry out any of the following operations on a record with a composite type that has a unique constraint. In this situation, MongoDB does not enforce unique values inside a record.\n\n*   When you create the record\n*   When you add data to the record\n*   When you update data in the record\n\nIf your schema has a composite type with a `@@unique` constraint, MongoDB prevents you from storing the same value for the constrained value in two or more of the records that contain this composite type. However, MongoDB does does not prevent you from storing multiple copies of the same field value in a single record.\n\nNote that you can [use Prisma ORM relations to work around this issue](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#use-prisma-orm-relations-to-enforce-unique-values-in-a-record).\n\nFor example, in the following schema, `MailBox` has a composite type, `addresses`, which has a `@@unique` constraint on the `email` field.\n\n```\ntype Address {  email String}model MailBox {  name      String  addresses Address[]  @@unique([addresses.email])}\n```\n\nThe following code creates a record with two identical values in `address`. MongoDB does not throw an error in this situation, and it stores `alice@prisma.io` in `addresses` twice.\n\n```\nawait prisma.MailBox.createMany({  data: [    {      name: 'Alice',      addresses: {        set: [          {            address: 'alice@prisma.io', // Not unique          },          {            address: 'alice@prisma.io', // Not unique          },        ],      },    },  ],})\n```\n\nNote: MongoDB throws an error if you try to store the same value in two separate records. In our example above, if you try to store the email address `alice@prisma.io` for the user Alice and for the user Bob, MongoDB does not store the data and throws an error.\n\n### Use Prisma ORM relations to enforce unique values in a record[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/composite-types#use-prisma-orm-relations-to-enforce-unique-values-in-a-record \"Direct link to Use Prisma ORM relations to enforce unique values in a record\")\n\nIn the example above, MongoDB did not enforce the unique constraint on a nested address name. However, you can model your data differently to enforce unique values in a record. To do so, use Prisma ORM [relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) to turn the composite type into a collection. Set a relationship to this collection and place a unique constraint on the field that you want to be unique.\n\nIn the following example, MongoDB enforces unique values in a record. There is a relation between `Mailbox` and the `Address` model. Also, the `name` field in the `Address` model has a unique constraint.\n\n```\nmodel Address {  id        String   @id @default(auto()) @map(\"_id\") @db.ObjectId  name      String  mailbox   Mailbox? @relation(fields: [mailboxId], references: [id])  mailboxId String?  @db.ObjectId  @@unique([name])}model Mailbox {  id        String    @id @default(auto()) @map(\"_id\") @db.ObjectId  name      String  addresses Address[] @relation}\n```\n\n```\nawait prisma.MailBox.create({  data: {    name: 'Alice',    addresses: {      create: [        { name: 'alice@prisma.io' }, // Not unique        { name: 'alice@prisma.io' }, // Not unique      ],    },  },})\n```\n\nIf you run the above code, MongoDB enforces the unique constraint. It does not allow your application to add two addresses with the name `alice@prisma.io`.",
  "title": "Composite types | Prisma Documentation",
  "description": "Composite types",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management",
  "markdown": "# Connection management | Prisma Documentation\n\n`PrismaClient` connects and disconnects from your data source using the following two methods:\n\n*   [`$connect()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect-1)\n*   [`$disconnect()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#disconnect-1)\n\nIn most cases, you **do not need to explicitly call these methods**. `PrismaClient` automatically connects when you run your first query, creates a [connection pool](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-pool), and disconnects when the Node.js process ends.\n\nSee the [connection management guide](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections) for information about managing connections for different deployment paradigms (long-running processes and serverless functions).\n\n## `$connect()`[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#connect \"Direct link to connect\")\n\nIt is not necessary to call [`$connect()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect-1) thanks to the _lazy connect_ behavior: The `PrismaClient` instance connects lazily when the first request is made to the API (`$connect()` is called for you under the hood).\n\n### Calling `$connect()` explicitly[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#calling-connect-explicitly \"Direct link to calling-connect-explicitly\")\n\nIf you need the first request to respond instantly and cannot wait for a lazy connection to be established, you can explicitly call `prisma.$connect()` to establish a connection to the data source:\n\n```\nconst prisma = new PrismaClient()// run inside `async` functionawait prisma.$connect()\n```\n\n## `$disconnect()`[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#disconnect \"Direct link to disconnect\")\n\nWhen you call [`$disconnect()`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#disconnect-1) , Prisma Client:\n\n1.  Runs the [`beforeExit` hook](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#exit-hooks)\n2.  Ends the Query Engine child process and closes all connections\n\nIn a long-running application such as a GraphQL API, which constantly serves requests, it does not make sense to `$disconnect()` after each request - it takes time to establish a connection, and doing so as part of each request will slow down your application.\n\n### Calling `$disconnect()` explicitly[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#calling-disconnect-explicitly \"Direct link to calling-disconnect-explicitly\")\n\nOne scenario where you should call `$disconnect()` explicitly is where a script:\n\n1.  Runs **infrequently** (for example, a scheduled job to send emails each night), which means it does not benefit from a long-running connection to the database _and_\n2.  Exists in the context of a **long-running application**, such as a background service. If the application never shuts down, Prisma Client never disconnects.\n\nThe following script creates a new instance of `PrismaClient`, performs a task, and then disconnects - which closes the connection pool:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()const emailService = new EmailService()async function main() {  const allUsers = await prisma.user.findMany()  const emails = allUsers.map((x) => x.email)  await emailService.send(emails, 'Hello!')}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nIf the above script runs multiple times in the context of a long-running application _without_ calling `$disconnect()`, a new connection pool is created with each new instance of `PrismaClient`.\n\n## Exit hooks[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/connection-management#exit-hooks \"Direct link to Exit hooks\")\n\nThe `beforeExit` hook runs when Prisma ORM is triggered externally (e.g. via a `SIGINT` signal) to shut down, and allows you to run code _before_ Prisma Client disconnects - for example, to issue queries as part of a graceful shutdown of a service:\n\n```\nconst prisma = new PrismaClient()prisma.$on('beforeExit', async () => {  console.log('beforeExit hook')  // PrismaClient still available  await prisma.message.create({    data: {      message: 'Shutting down server',    },  })})\n```",
  "title": "Connection management | Prisma Documentation",
  "description": "This page explains how database connections are handled with Prisma Client and how to manually connect and disconnect your database.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields",
  "markdown": "# Working with Json fields (Concepts)\n\nUse the [`Json`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#json) Prisma ORM field type to read, write, and perform basic filtering on JSON types in the underlying database. In the following example, the `User` model has an optional `Json` field named `extendedPetsData`:\n\n```\nmodel User {  id               Int     @id @default(autoincrement())  email            String  @unique  name             String?  posts            Post[]  extendedPetsData Json?}\n```\n\nExample field value:\n\n```\n{  \"pet1\": {    \"petName\": \"Claudine\",    \"petType\": \"House cat\"  },  \"pet2\": {    \"petName\": \"Sunny\",    \"petType\": \"Gerbil\"  }}\n```\n\n> **Note**: The `Json` field is only supported if the [underlying database](https://www.prisma.io/docs/orm/overview) has a corresponding JSON data type.\n\nThe `Json` field supports a few additional types, such as `string` and `boolean`. These additional types exist to match the types supported by [`JSON.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse):\n\n```\nexport declare type JsonValue =  | string  | number  | boolean  | null  | JsonObject  | JsonArray\n```\n\n## Use cases for JSON fields[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#use-cases-for-json-fields \"Direct link to Use cases for JSON fields\")\n\nReasons to store data as JSON rather than representing data as related models include:\n\n*   You need to store data that does not have a consistent structure\n*   You are importing data from another system and do not want to map that data to Prisma models\n\n## Reading a `Json` field[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#reading-a-json-field \"Direct link to reading-a-json-field\")\n\nYou can use the `Prisma.JsonArray` and `Prisma.JsonObject` utility classes to work with the contents of a `Json` field:\n\n```\nconst { PrismaClient, Prisma } = require('@prisma/client')const user = await prisma.user.findFirst({  where: {    id: 9,  },})// Example extendedPetsData data:// [{ name: 'Bob the dog' }, { name: 'Claudine the cat' }]if (  user?.extendedPetsData &&  typeof user?.extendedPetsData === 'object' &&  Array.isArray(user?.extendedPetsData)) {  const petsObject = user?.extendedPetsData as Prisma.JsonArray  const firstPet = petsObject[0]}\n```\n\nSee also: [Advanced example: Update a nested JSON key value](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#advanced-example-update-a-nested-json-key-value)\n\n## Writing to a `Json` field[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#writing-to-a-json-field \"Direct link to writing-to-a-json-field\")\n\nThe following example writes a JSON object to the `extendedPetsData` field:\n\n```\nvar json = [  { name: 'Bob the dog' },  { name: 'Claudine the cat' },] as Prisma.JsonArrayconst createUser = await prisma.user.create({  data: {    email: 'birgitte@prisma.io',    extendedPetsData: json,  },})\n```\n\n> **Note**: JavaScript objects (for example, `{ extendedPetsData: \"none\"}`) are automatically converted to JSON.\n\nSee also: [Advanced example: Update a nested JSON key value](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#advanced-example-update-a-nested-json-key-value)\n\n## Filter on a `Json` field (simple)[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-a-json-field-simple \"Direct link to filter-on-a-json-field-simple\")\n\nYou can filter rows of `Json` type.\n\n### Filter on exact field value[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-exact-field-value \"Direct link to Filter on exact field value\")\n\nThe following query returns all users where the value of `extendedPetsData` matches the `json` variable exactly:\n\n```\nvar json = { [{ name: 'Bob the dog' }, { name: 'Claudine the cat' }] }const getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      equals: json,    },  },})\n```\n\nThe following query returns all users where the value of `extendedPetsData` does **not** match the `json` variable exactly:\n\n```\nvar json = {  extendedPetsData: [{ name: 'Bob the dog' }, { name: 'Claudine the cat' }],}const getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      not: json,    },  },})\n```\n\n## Filter on a `Json` field (advanced)[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-a-json-field-advanced \"Direct link to filter-on-a-json-field-advanced\")\n\nYou can also filter rows by the data inside a `Json` field. We call this **advanced `Json` filtering**. This functionality is supported by [PostgreSQL](https://www.prisma.io/docs/orm/overview/databases/postgresql) and [MySQL](https://www.prisma.io/docs/orm/overview/databases/mysql) only with [different syntaxes for the `path` option](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#path-syntax-depending-on-database).\n\ninfo\n\nThe availability of advanced `Json` filtering depends on your Prisma version:\n\n*   v4.0.0 or later: advanced `Json` filtering is [generally available](https://www.prisma.io/docs/orm/more/releases#generally-available-ga).\n*   From v2.23.0, but before v4.0.0: advanced `Json` filtering is a [preview feature](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features). Add `previewFeatures = [\"filterJson\"]` to your schema. [Learn more](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature).\n*   Before v2.23.0: you can [filter on the exact `Json` field value](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-exact-field-value), but you cannot use the other features described in this section.\n\n### `path` syntax depending on database[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#path-syntax-depending-on-database \"Direct link to path-syntax-depending-on-database\")\n\nThe filters below use a `path` option to select specific parts of the `Json` value to filter on. The implementation of that filtering differs between connectors:\n\n*   The [MySQL connector](https://www.prisma.io/docs/orm/overview/databases/mysql) uses [MySQL's implementation of JSON path](https://dev.mysql.com/doc/refman/8.0/en/json.html#json-path-syntax)\n*   The [PostgreSQL connector](https://www.prisma.io/docs/orm/overview/databases/postgresql) uses the custom JSON functions and operators [supported in version 12 _and earlier_](https://www.postgresql.org/docs/11/functions-json.html)\n\nFor example, the following is a valid MySQL `path` value:\n\nThe following is a valid PostgreSQL `path` value:\n\n```\n[\"petFeatures\", \"petName\"]\n```\n\n### Filter on object property[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-object-property \"Direct link to Filter on object property\")\n\nYou can filter on a specific property inside a block of JSON. In the following examples, the value of `extendedPetsData` is a one-dimensional, unnested JSON object:\n\n```\n{  \"petName\": \"Claudine\",  \"petType\": \"House cat\"}\n```\n\nThe following query returns all users where the value of `petName` is `\"Claudine\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['petName'],      equals: 'Claudine',    },  },})\n```\n\nThe following query returns all users where the value of `petType` _contains_ `\"cat\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['petType'],      string_contains: 'cat',    },  },})\n```\n\nThe following string filters are available:\n\n*   [`string_contains`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#string_contains)\n*   [`string_starts_with`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#string_starts_with)\n*   [`string_ends_with`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#string_ends_with) .\n\n### Filter on nested object property[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-nested-object-property \"Direct link to Filter on nested object property\")\n\nYou can filter on nested JSON properties. In the following examples, the value of `extendedPetsData` is a JSON object with several levels of nesting.\n\n```\n{  \"pet1\": {    \"petName\": \"Claudine\",    \"petType\": \"House cat\"  },  \"pet2\": {    \"petName\": \"Sunny\",    \"petType\": \"Gerbil\",    \"features\": {      \"eyeColor\": \"Brown\",      \"furColor\": \"White and black\"    }  }}\n```\n\nThe following query returns all users where `\"pet2\"` → `\"petName\"` is `\"Sunny\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['pet2', 'petName'],      equals: 'Sunny',    },  },})\n```\n\nThe following query returns all users where:\n\n*   `\"pet2\"` → `\"petName\"` is `\"Sunny\"`\n*   `\"pet2\"` → `\"features\"` → `\"furColor\"` contains `\"black\"`\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    AND: [      {        extendedPetsData: {          path: ['pet2', 'petName'],          equals: 'Sunny',        },      },      {        extendedPetsData: {          path: ['pet2', 'features', 'furColor'],          string_contains: 'black',        },      },    ],  },})\n```\n\n### Filtering on an array value[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filtering-on-an-array-value \"Direct link to Filtering on an array value\")\n\nYou can filter on the presence of a specific value in a scalar array (strings, integers). In the following example, the value of `extendedPetsData` is an array of strings:\n\nThe following query returns all users with a pet named `\"Claudine\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      array_contains: ['Claudine'],    },  },})\n```\n\ninfo\n\n**Note**: In PostgreSQL, the value of `array_contains` must be an array and not a string, even if the array only contains a single value.\n\nThe following array filters are available:\n\n*   [`array_contains`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#array_contains)\n*   [`array_starts_with`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#array_starts_with)\n*   [`array_ends_with`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#array_ends_with)\n\n### Filtering on nested array value[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filtering-on-nested-array-value \"Direct link to Filtering on nested array value\")\n\nYou can filter on the presence of a specific value in a scalar array (strings, integers). In the following examples, the value of `extendedPetsData` includes nested scalar arrays of names:\n\n```\n{  \"cats\": { \"owned\": [\"Bob\", \"Sunny\"], \"fostering\": [\"Fido\"] },  \"dogs\": { \"owned\": [\"Ella\"], \"fostering\": [\"Prince\", \"Empress\"] }}\n```\n\n#### Scalar value arrays[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#scalar-value-arrays \"Direct link to Scalar value arrays\")\n\nThe following query returns all users that foster a cat named `\"Fido\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['cats', 'fostering'],      array_contains: ['Fido'],    },  },})\n```\n\ninfo\n\n**Note**: In PostgreSQL, the value of `array_contains` must be an array and not a string, even if the array only contains a single value.\n\nThe following query returns all users that foster cats named `\"Fido\"` _and_ `\"Bob\"`:\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['cats', 'fostering'],      array_contains: ['Fido', 'Bob'],    },  },})\n```\n\n#### JSON object arrays[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#json-object-arrays \"Direct link to JSON object arrays\")\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst json = [{ status: 'expired', insuranceID: 92 }]const checkJson = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['insurances'],      array_contains: json,    },  },})\n```\n\n*   If you are using PostgreSQL, you must pass in an array of objects to match, even if that array only contains one object:\n    \n    ```\n    [{ status: 'expired', insuranceID: 92 }]// PostgreSQL\n    ```\n    \n    If you are using MySQL, you must pass in a single object to match:\n    \n    ```\n    { status: 'expired', insuranceID: 92 }// MySQL\n    ```\n    \n*   If your filter array contains multiple objects, PostgreSQL will only return results if _all_ objects are present - not if at least one object is present.\n    \n*   You must set `array_contains` to a JSON object, not a string. If you use a string, Prisma Client escapes the quotation marks and the query will not return results. For example:\n    \n    ```\n    array_contains: '[{\"status\": \"expired\", \"insuranceID\": 92}]'\n    ```\n    \n    is sent to the database as:\n    \n    ```\n    [{\\\"status\\\": \\\"expired\\\", \\\"insuranceID\\\": 92}]\n    ```\n    \n\n### Targeting an array element by index[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#targeting-an-array-element-by-index \"Direct link to Targeting an array element by index\")\n\nYou can filter on the value of an element in a specific position.\n\n```\n{ \"owned\": [\"Bob\", \"Sunny\"], \"fostering\": [\"Fido\"] }\n```\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    comments: {      path: ['owned', '1'],      string_contains: 'Bob',    },  },})\n```\n\n### Filtering on object key value inside array[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filtering-on-object-key-value-inside-array \"Direct link to Filtering on object key value inside array\")\n\nDepending on your provider, you can filter on the key value of an object inside an array.\n\nIn the following example, the value of `extendedPetsData` is an array of objects with a nested `insurances` array, which contains two objects:\n\n```\n[  {    \"petName\": \"Claudine\",    \"petType\": \"House cat\",    \"insurances\": [      { \"insuranceID\": 92, \"status\": \"expired\" },      { \"insuranceID\": 12, \"status\": \"active\" }    ]  },  {    \"petName\": \"Sunny\",    \"petType\": \"Gerbil\"  },  {    \"petName\": \"Gerald\",    \"petType\": \"Corn snake\"  },  {    \"petName\": \"Nanna\",    \"petType\": \"Moose\"  }]\n```\n\nThe following query returns all users where at least one pet is a moose:\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: '$[*].petType',      array_contains: 'Moose',    },  },})\n```\n\n*   `$[*]` is the root array of pet objects\n*   `petType` matches the `petType` key in any pet object\n\nThe following query returns all users where at least one pet has an expired insurance:\n\n```\nconst getUsers = await prisma.user.findMany({  where: {    extendedPetsData: {      path: '$[*].insurances[*].status',      array_contains: 'expired',    },  },})\n```\n\n*   `$[*]` is the root array of pet objects\n*   `insurances[*]` matches any `insurances` array inside any pet object\n*   `status` matches any `status` key in any insurance object\n\n## Advanced example: Update a nested JSON key value[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#advanced-example-update-a-nested-json-key-value \"Direct link to Advanced example: Update a nested JSON key value\")\n\nThe following example assumes that the value of `extendedPetsData` is some variation of the following:\n\n```\n{  \"petName\": \"Claudine\",  \"petType\": \"House cat\",  \"insurances\": [    { \"insuranceID\": 92, \"status\": \"expired\" },    { \"insuranceID\": 12, \"status\": \"active\" }  ]}\n```\n\nThe following example:\n\n1.  Gets all users\n2.  Change the `\"status\"` of each insurance object to `\"expired\"`\n3.  Get all users that have an expired insurance where the ID is `92`\n\n*   PostgreSQL\n*   MySQL\n\n```\nconst userQueries: string | any[] = []getUsers.forEach((user) => {  if (    user.extendedPetsData &&    typeof user.extendedPetsData === 'object' &&    !Array.isArray(user.extendedPetsData)  ) {    const petsObject = user.extendedPetsData as Prisma.JsonObject    const i = petsObject['insurances']    if (i && typeof i === 'object' && Array.isArray(i)) {      const insurancesArray = i as Prisma.JsonArray      insurancesArray.forEach((i) => {        if (i && typeof i === 'object' && !Array.isArray(i)) {          const insuranceObject = i as Prisma.JsonObject          insuranceObject['status'] = 'expired'        }      })      const whereClause = Prisma.validator<Prisma.UserWhereInput>()({        id: user.id,      })      const dataClause = Prisma.validator<Prisma.UserUpdateInput>()({        extendedPetsData: petsObject,      })      userQueries.push(        prisma.user.update({          where: whereClause,          data: dataClause,        })      )    }  }})if (userQueries.length > 0) {  console.log(userQueries.length + ' queries to run!')  await prisma.$transaction(userQueries)}const json = [{ status: 'expired', insuranceID: 92 }]const checkJson = await prisma.user.findMany({  where: {    extendedPetsData: {      path: ['insurances'],      array_contains: json,    },  },})console.log(checkJson.length)\n```\n\n## Using `null` Values[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#using-null-values \"Direct link to using-null-values\")\n\nThere are two types of `null` values possible for a `JSON` field in an SQL database.\n\n*   Database `NULL`: The value in the database is a `NULL`.\n*   JSON `null`: The value in the database contains a JSON value that is `null`.\n\nTo differentiate between these possibilities, we've introduced three _null enums_ you can use:\n\n*   `JsonNull`: Represents the `null` value in JSON.\n*   `DbNull`: Represents the `NULL` value in the database.\n*   `AnyNull`: Represents both `null` JSON values and `NULL` database values. (Only when filtering)\n\ninfo\n\nFrom v4.0.0, `JsonNull`, `DbNull`, and `AnyNull` are objects. Before v4.0.0, they were strings.\n\ninfo\n\n*   When filtering using any of the _null enums_ you can not use a shorthand and leave the `equals` operator off.\n*   These _null enums_ do not apply to MongoDB because there the difference between a JSON `null` and a database `NULL` does not exist.\n*   The _null enums_ do not apply to the `array_contains` operator in all databases because there can only be a JSON `null` within a JSON array. Since there cannot be a database `NULL` within a JSON array, `{ array_contains: null }` is not ambiguous.\n\nFor example:\n\n```\nmodel Log {  id   Int  @id  meta Json}\n```\n\nHere is an example of using `AnyNull`:\n\n```\nimport { Prisma } from '@prisma/client'prisma.log.findMany({  where: {    data: {      meta: {        equals: Prisma.AnyNull,      },    },  },})\n```\n\n### Inserting `null` Values[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#inserting-null-values \"Direct link to inserting-null-values\")\n\nThis also applies to `create`, `update` and `upsert`. To insert a `null` value into a `Json` field, you would write:\n\n```\nimport { Prisma } from '@prisma/client'prisma.log.create({  data: {    meta: Prisma.JsonNull,  },})\n```\n\nAnd to insert a database `NULL` into a `Json` field, you would write:\n\n```\nimport { Prisma } from '@prisma/client'prisma.log.create({  data: {    meta: Prisma.DbNull,  },})\n```\n\n### Filtering by `null` Values[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filtering-by-null-values \"Direct link to filtering-by-null-values\")\n\nTo filter by `JsonNull` or `DbNull`, you would write:\n\n```\nimport { Prisma } from '@prisma/client'prisma.log.findMany({  where: {    meta: {      equals: Prisma.AnyNull,    },  },})\n```\n\ninfo\n\nThese _null enums_ do not apply to MongoDB because MongoDB does not differentiate between a JSON `null` and a database `NULL`. They also do not apply to the `array_contains` operator in all databases because there can only be a JSON `null` within a JSON array. Since there cannot be a database `NULL` within a JSON array, `{ array_contains: null }` is not ambiguous.\n\n## Typed `Json`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#typed-json \"Direct link to typed-json\")\n\nBy default, `Json` fields are not typed in Prisma models. To accomplish strong typing inside of these fields, you will need to use an external package like [prisma-json-types-generator](https://www.npmjs.com/package/prisma-json-types-generator) to accomplish this.\n\n### Using `prisma-json-types-generator`[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#using-prisma-json-types-generator \"Direct link to using-prisma-json-types-generator\")\n\nFirst, install and configure `prisma-json-types-generator` [according to the package's instructions](https://www.npmjs.com/package/prisma-json-types-generator#using-it).\n\nThen, assuming you have a model like the following:\n\n```\nmodel Log {  id   Int  @id  meta Json}\n```\n\nYou can update it and type it by using [abstract syntax tree comments](https://www.prisma.io/docs/orm/prisma-schema/overview#comments)\n\nschema.prisma\n\n```\nmodel Log {  id Int @id  /// [LogMetaType]  meta Json}\n```\n\nThen, make sure you define the above type in a type declaration file included in your `tsconfig.json`\n\ntypes.ts\n\n```\ndeclare global {  namespace PrismaJson {    type LogMetaType = { timestamp: number; host: string }  }}\n```\n\nNow, when working with `Log.meta` it will be strongly typed!\n\n## `Json` FAQs[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#json-faqs \"Direct link to json-faqs\")\n\n### Can you select a subset of JSON key/values to return?[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#can-you-select-a-subset-of-json-keyvalues-to-return \"Direct link to Can you select a subset of JSON key/values to return?\")\n\nNo - it is not yet possible to [select which JSON elements to return](https://github.com/prisma/prisma/issues/2431). Prisma Client returns the entire JSON object.\n\n### Can you filter on the presence of a specific key?[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#can-you-filter-on-the-presence-of-a-specific-key \"Direct link to Can you filter on the presence of a specific key?\")\n\nNo - it is not yet possible to filter on the presence of a specific key.\n\n### Is case insensitive filtering supported?[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#is-case-insensitive-filtering-supported \"Direct link to Is case insensitive filtering supported?\")\n\nNo - [case insensitive filtering](https://github.com/prisma/prisma/issues/7390) is not yet supported.\n\n### How to set a default value for JSON fields?[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#how-to-set-a-default-value-for-json-fields \"Direct link to How to set a default value for JSON fields?\")\n\nWhen you want to set a `@default` value the `Json` type, you need to enclose it with double-quotes inside the `@default` attribute (and potentially escape any \"inner\" double-quotes using a backslash), for example:\n\n```\nmodel User {  id    Int  @id @default(autoincrement())  json1 Json @default(\"[]\")  json2 Json @default(\"{ \\\"hello\\\": \\\"world\\\" }\")}\n```",
  "title": "Working with Json fields (Concepts) | Prisma Documentation",
  "description": "How to read, write, and filter by Json fields.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/query",
  "markdown": "# Prisma Client extensions: query component\n\n## \\`query\\`: Create custom Prisma Client queries\n\ninfo\n\nPrisma Client extensions are Generally Available from versions 4.16.0 and later. They were introduced in Preview in version 4.7.0. Make sure you enable the `clientExtensions` Preview feature flag if you are running on a version earlier than 4.16.0.\n\nYou can use the `query` [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) component type to hook into the query life-cycle and modify an incoming query or its result.\n\nYou can use Prisma Client extensions `query` component to create independent clients. This provides an alternative to [middlewares](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware). You can bind one client to a specific filter or user, and another client to another filter or user. For example, you might do this to get [user isolation](https://www.prisma.io/docs/orm/prisma-client/client-extensions#extended-clients) in a row-level security (RLS) extension. In addition, unlike middlewares the `query` extension component gives you end-to-end type safety. [Learn more about `query` extensions versus middlewares](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#query-extensions-versus-middlewares).\n\n## Extend Prisma Client query operations[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#extend-prisma-client-query-operations \"Direct link to Extend Prisma Client query operations\")\n\nUse the `$extends` [client-level method](https://www.prisma.io/docs/orm/reference/prisma-client-reference#client-methods) to create an [extended client](https://www.prisma.io/docs/orm/prisma-client/client-extensions#about-prisma-client-extensions). An extended client is a variant of the standard Prisma Client that is wrapped by one or more extensions.\n\nUse the `query` extension component to modify queries. You can modify a custom query in the following:\n\n*   [A specific operation in a specific model](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-specific-operation-in-a-specific-model)\n*   [A specific operation in all models of your schema](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-specific-operation-in-all-models-of-your-schema)\n*   [All Prisma Client operations](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-prisma-client-operations)\n*   [All operations in a specific model](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-operations-in-a-specific-model)\n*   [All operations in all models of your schema](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-operations-in-all-models-of-your-schema)\n*   [A specific top-level raw query operation](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-top-level-raw-query-operation)\n\nTo create a custom query, use the following structure:\n\n```\nconst prisma = new PrismaClient().$extends({  name?: 'name',  query?: {    user: { ... } // in this case, we add a query to the `user` model  },});\n```\n\nThe properties are as follows:\n\n*   `name`: (optional) specifies a name for the extension that appears in error logs.\n*   `query`: defines a custom query.\n\n### Modify a specific operation in a specific model[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-specific-operation-in-a-specific-model \"Direct link to Modify a specific operation in a specific model\")\n\nThe `query` object can contain functions that map to the names of the [Prisma Client operations](https://www.prisma.io/docs/orm/reference/prisma-client-reference#model-queries), such as `findUnique()`, `findFirst`, `findMany`, `count`, and `create`. The following example modifies `user.findMany` to a use a customized query that finds only users who are older than 18 years:\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    user: {      async findMany({ model, operation, args, query }) {        // take incoming `where` and set `age`        args.where = { ...args.where, age: { gt: 18 } }        return query(args)      },    },  },})await prisma.user.findMany() // returns users whose age is greater than 18\n```\n\nIn the above example, a call to `prisma.user.findMany` triggers `query.user.findMany`. Each callback receives a type-safe `{ model, operation, args, query }` object that describes the query. This object has the following properties:\n\n*   `model`: the name of the containing model for the query that we want to extend.\n    \n    In the above example, the `model` is a string of type `\"User\"`.\n    \n*   `operation`: the name of the operation being extended and executed.\n    \n    In the above example, the `operation` is a string of type `\"findMany\"`.\n    \n*   `args`: the specific query input information to be extended.\n    \n    This is a type-safe object that you can mutate before the query happens. You can mutate any of the properties in `args`. Exception: you cannot mutate `include` or `select` because that would change the expected output type and break type safety.\n    \n*   `query`: a promise for the result of the query.\n    \n    *   You can use `await` and then mutate the result of this promise, because its value is type-safe. TypeScript catches any unsafe mutations on the object.\n\n### Modify a specific operation in all models of your schema[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-specific-operation-in-all-models-of-your-schema \"Direct link to Modify a specific operation in all models of your schema\")\n\nTo extend the queries in all the models of your schema, use `$allModels` instead of a specific model name. For example:\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    $allModels: {      async findMany({ model, operation, args, query }) {        // set `take` and fill with the rest of `args`        args = { ...args, take: 100 }        return query(args)      },    },  },})\n```\n\n### Modify all operations in a specific model[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-operations-in-a-specific-model \"Direct link to Modify all operations in a specific model\")\n\nUse `$allOperations` to extend all operations in a specific model.\n\nFor example, the following code applies a custom query to all operations on the `user` model:\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    user: {      $allOperations({ model, operation, args, query }) {        /* your custom logic here */        return query(args)      },    },  },})\n```\n\n### Modify all Prisma Client operations[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-prisma-client-operations \"Direct link to Modify all Prisma Client operations\")\n\nUse the `$allOperations` method to modify all query methods present in Prisma Client. The `$allOperations` can be used on both model operations and raw queries.\n\nYou can modify all methods as follows:\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    $allOperations({ model, operation, args, query }) {      /* your custom logic for modifying all Prisma Client operations here */      return query(args)    },  },})\n```\n\nIn the event a [raw query](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries) is invoked, the `model` argument passed to the callback will be `undefined`.\n\nFor example, you can use the `$allOperations` method to log queries as follows:\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    async $allOperations({ operation, model, args, query }) {      const start = performance.now()      const result = await query(args)      const end = performance.now()      const time = end - start      console.log(        util.inspect(          { model, operation, args, time },          { showHidden: false, depth: null, colors: true }        )      )      return result    },  },})\n```\n\n### Modify all operations in all models of your schema[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-operations-in-all-models-of-your-schema \"Direct link to Modify all operations in all models of your schema\")\n\nUse `$allModels` and `$allOperations` to extend all operations in all models of your schema.\n\nTo apply a custom query to all operations on all models of your schema:\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    $allModels: {      $allOperations({ model, operation, args, query }) {        /* your custom logic for modifying all operations on all models here */        return query(args)      },    },  },})\n```\n\n### Modify a top-level raw query operation[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-top-level-raw-query-operation \"Direct link to Modify a top-level raw query operation\")\n\nTo apply custom behavior to a specific top-level raw query operation, use the name of a top-level raw query function instead of a model name:\n\n*   Relational databases\n*   MongoDB\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    $queryRaw({ args, query, operation }) {      // handle $queryRaw operation      return query(args)    },    $executeRaw({ args, query, operation }) {      // handle $executeRaw operation      return query(args)    },    $queryRawUnsafe({ args, query, operation }) {      // handle $queryRawUnsafe operation      return query(args)    },    $executeRawUnsafe({ args, query, operation }) {      // handle $executeRawUnsafe operation      return query(args)    },  },})\n```\n\n### Mutate the result of a query[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#mutate-the-result-of-a-query \"Direct link to Mutate the result of a query\")\n\nYou can use `await` and then mutate the result of the `query` promise.\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    user: {      async findFirst({ model, operation, args, query }) {        const user = await query(args)        if (user.password !== undefined) {          user.password = '******'        }        return user      },    },  },})\n```\n\ninfo\n\nWe include the above example to show that this is possible. However, for performance reasons we recommend that you use the [`result` component type](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result) to override existing fields. The `result` component type usually gives better performance in this situation because it computes only on access. The `query` component type computes after query execution.\n\n## Wrap a query into a batch transaction[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#wrap-a-query-into-a-batch-transaction \"Direct link to Wrap a query into a batch transaction\")\n\nYou can wrap your extended queries into a [batch transaction](https://www.prisma.io/docs/orm/prisma-client/queries/transactions). For example, you can use this to enact row-level security (RLS).\n\nThe following example extends `findFirst` so that it runs in a batch transaction.\n\n```\nconst prisma = new PrismaClient().$extends({  query: {    user: {      // Get the input `args` and a callback to `query`      async findFirst({ args, query, operation }) {        const [result] = await prisma.$transaction([query(args)]) // wrap the query in a batch transaction, and destructure the result to return an array        return result // return the first result found in the array      },    },  },})\n```\n\n## Query extensions versus middlewares[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#query-extensions-versus-middlewares \"Direct link to Query extensions versus middlewares\")\n\nYou can use query extensions or [middlewares](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware) to hook into the query life-cycle and modify an incoming query or its result. Client extensions and middlewares differ in the following ways:\n\n*   Middlewares always apply globally to the same client. Client extensions are isolated, unless you deliberately combine them. [Learn more about client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions#about-prisma-client-extensions).\n    *   For example, in a row-level security (RLS) scenario, you can keep each user in an entirely separate client. With middlewares, all users are active in the same client.\n*   During application execution, with extensions you can choose from one or more extended clients, or the standard Prisma Client. With middlewares, you cannot choose which client to use, because there is only one global client.\n*   Extensions benefit from end-to-end type safety and inference, but middlewares don't.\n\nYou can use Prisma Client extensions in all scenarios where middlewares can be used.\n\n### If you use the `query` extension component and middlewares[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#if-you-use-the-query-extension-component-and-middlewares \"Direct link to if-you-use-the-query-extension-component-and-middlewares\")\n\nIf you use the `query` extension component and middlewares in your project, then the following rules and priorities apply:\n\n*   In your application code, you must declare all your middlewares on the main Prisma Client instance. You cannot declare them on an extended client.\n*   In situations where middlewares and extensions with a `query` component execute, Prisma Client executes the middlewares before it executes the extensions with the `query` component. Prisma Client executes the individual middlewares and extensions in the order in which you instantiated them with `$use` or `$extends`.",
  "title": "Prisma Client extensions: query component | Prisma Documentation",
  "description": "Extend the functionality of Prisma Client, query component",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics",
  "markdown": "# Metrics (Preview) | Prisma Documentation\n\n```\n{  \"counters\": [    {      \"key\": \"prisma_client_queries_total\",      \"labels\": {},      \"value\": 2,      \"description\": \"Total number of Prisma Client queries executed\"    },    {      \"key\": \"prisma_datasource_queries_total\",      \"labels\": {},      \"value\": 5,      \"description\": \"Total number of Datasource Queries executed\"    },    {      \"key\": \"prisma_pool_connections_open\",      \"labels\": {},      \"value\": 1,      \"description\": \"Number of currently open Pool Connections\"    }  ],  \"gauges\": [    {      \"key\": \"prisma_client_queries_active\",      \"labels\": {},      \"value\": 0,      \"description\": \"Number of currently active Prisma Client queries\"    },    {      \"key\": \"prisma_client_queries_wait\",      \"labels\": {},      \"value\": 0,      \"description\": \"Number of Prisma Client queries currently waiting for a connection\"    },    {      \"key\": \"prisma_pool_connections_busy\",      \"labels\": {},      \"value\": 0,      \"description\": \"Number of currently busy Pool Connections (executing a datasource query)\"    },    {      \"key\": \"prisma_pool_connections_idle\",      \"labels\": {},      \"value\": 21,      \"description\": \"Number of currently unused Pool Connections (waiting for the next datasource query to run)\"    },    {      \"key\": \"prisma_pool_connections_open\",      \"labels\": {},      \"value\": 1,      \"description\": \"Number of currently open Pool Connections\"    }  ],  \"histograms\": [    {      \"key\": \"prisma_client_queries_duration_histogram_ms\",      \"labels\": {},      \"value\": {        \"buckets\": [          [0, 0],          [1, 0],          [5, 0],          [10, 1],          [50, 1],          [100, 0],          [500, 0],          [1000, 0],          [5000, 0],          [50000, 0]        ],        \"sum\": 47.430541000000005,        \"count\": 2      },      \"description\": \"Histogram of the duration of all executed Prisma Client queries in ms\"    },    {      \"key\": \"prisma_client_queries_wait_histogram_ms\",      \"labels\": {},      \"value\": {        \"buckets\": [          [0, 0],          [1, 3],          [5, 0],          [10, 0],          [50, 0],          [100, 0],          [500, 0],          [1000, 0],          [5000, 0],          [50000, 0]        ],        \"sum\": 0.0015830000000000002,        \"count\": 3      },      \"description\": \"Histogram of the wait time of all Prisma Client Queries in ms\"    },    {      \"key\": \"prisma_datasource_queries_duration_histogram_ms\",      \"labels\": {},      \"value\": {        \"buckets\": [          [0, 0],          [1, 0],          [5, 2],          [10, 2],          [50, 1],          [100, 0],          [500, 0],          [1000, 0],          [5000, 0],          [50000, 0]        ],        \"sum\": 47.134498,        \"count\": 5      },      \"description\": \"Histogram of the duration of all executed Datasource Queries in ms\"    }  ]}\n```",
  "title": "Metrics (Preview) | Prisma Documentation",
  "description": "Diagnose application performance with insights into Prisma Client database activity.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features",
  "markdown": "# Prisma Client & Prisma schema\n\nWhen we release a new Prisma Client or Prisma schema feature, it often starts in Preview so that you can test it and submit your feedback. After we improve the feature with your feedback and are satisfied with the internal test results, we promote the feature to general availability.\n\nFor more information, see [ORM releases and maturity levels](https://www.prisma.io/docs/orm/more/releases).\n\n## Currently active Preview features[​](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#currently-active-preview-features \"Direct link to Currently active Preview features\")\n\nThe following [Preview](https://www.prisma.io/docs/orm/more/releases#preview) feature flags are available for Prisma Client and Prisma schema:\n\n| Feature | Released into Preview | Feedback issue |\n| --- | --- | --- |\n| [`fullTextSearch`](https://www.prisma.io/docs/orm/prisma-client/queries/full-text-search) | [2.30.0](https://github.com/prisma/prisma/releases/tag/2.30.0) | [Submit feedback](https://github.com/prisma/prisma/issues/8877) |\n| [`fullTextIndex`](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes#full-text-indexes-mysql-and-mongodb) | [3.6.0](https://github.com/prisma/prisma/releases/tag/3.6.0) | [Submit feedback](https://github.com/prisma/prisma/issues/10539) |\n| [`metrics`](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics) | [3.15.0](https://github.com/prisma/prisma/releases/tag/3.15.0) | [Submit feedback](https://github.com/prisma/prisma/issues/13579) |\n| [`tracing`](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing) | [4.2.0](https://github.com/prisma/prisma/releases/tag/4.2.0) | [Submit feedback](https://github.com/prisma/prisma/issues/14640) |\n| [`multiSchema`](https://github.com/prisma/prisma/issues/1122#issuecomment-1231773471) | [4.3.0](https://github.com/prisma/prisma/releases/tag/4.3.0) | [Submit feedback](https://github.com/prisma/prisma/issues/15077) |\n| [`postgresqlExtensions`](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions) | [4.5.0](https://github.com/prisma/prisma/releases/tag/4.5.0) | [Submit feedback](https://github.com/prisma/prisma/issues/15835) |\n| [`deno`](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy) | [4.5.0](https://github.com/prisma/prisma/releases/tag/4.5.0) | [Submit feedback](https://github.com/prisma/prisma/issues/15844) |\n| [`views`](https://www.prisma.io/docs/orm/prisma-schema/data-model/views) | [4.9.0](https://github.com/prisma/prisma/releases/tag/4.9.0) | [Submit feedback](https://github.com/prisma/prisma/issues/17335) |\n| `driverAdapters` | [5.4.0](https://github.com/prisma/prisma/releases/tag/5.4.0) | [Submit feedback](https://github.com/prisma/prisma/issues/3108) |\n| `relationJoins` | [5.7.0](https://github.com/prisma/prisma/releases/tag/5.7.0) | [Submit feedback](https://github.com/prisma/prisma/discussions/22288) |\n| `nativeDistinct` | [5.7.0](https://github.com/prisma/prisma/releases/tag/5.7.0) | [Submit feedback](https://github.com/prisma/prisma/discussions/22287) |\n| `omitApi` | [5.13.0](https://github.com/prisma/prisma/releases/tag/5.13.0) | [Submit feedback](https://github.com/prisma/prisma/discussions/23924) |\n| `prismaSchemaFolder` | [5.15.0](https://github.com/prisma/prisma/releases/tag/5.15.0) | [Submit feedback](https://github.com/prisma/prisma/discussions/24413) |\n\nTo enable a Preview feature, [add the feature flag to the `generator` block](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature) in your `schema.prisma` file. [Share your feedback on all Preview features on GitHub](https://github.com/prisma/prisma/issues/3108).\n\n## Enabling a Prisma Client Preview feature[​](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#enabling-a-prisma-client-preview-feature \"Direct link to Enabling a Prisma Client Preview feature\")\n\nTo enable a Prisma Client Preview feature:\n\n1.  Add the Preview feature flag to the `generator` block:\n    \n    ```\n    generator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"fullTextSearch\"]}\n    ```\n    \n2.  Re-generate Prisma Client:\n    \n    ```\n    npx prisma generate\n    ```\n    \n3.  If you are using Visual Studio Code and the Preview feature is not available in your `.ts` file after generating Prisma Client, run the **TypeScript: Restart TS server** command.\n    \n\n## Preview features promoted to general availability[​](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features#preview-features-promoted-to-general-availability \"Direct link to Preview features promoted to general availability\")\n\nIn the list below, you can find a history of Prisma Client and Prisma schema features that were in Preview and are now in general availability. The features are sorted by the most recent version in which they were promoted to general availability.\n\n| Feature | Released into Preview | Released into General Availability |\n| --- | --- | --- |\n| `jsonProtocol` | [4.11.0](https://github.com/prisma/prisma/releases/tag/4.11.0) | [5.0.0](https://github.com/prisma/prisma/releases/tag/5.0.0) |\n| [`extendedWhereUnique`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-on-non-unique-fields-with-userwhereuniqueinput) | [4.5.0](https://github.com/prisma/prisma/releases/tag/4.5.0) | [5.0.0](https://github.com/prisma/prisma/releases/tag/5.0.0) |\n| [`fieldReference`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#compare-columns-in-the-same-table) | [4.3.0](https://github.com/prisma/prisma/releases/tag/4.3.0) | [5.0.0](https://github.com/prisma/prisma/releases/tag/5.0.0) |\n| [`clientExtensions`](https://www.prisma.io/docs/orm/prisma-client/client-extensions) | [4.7.0](https://github.com/prisma/prisma/releases/tag/4.7.0) | [4.16.0](https://github.com/prisma/prisma/releases/tag/4.16.0) |\n| [`filteredRelationCount`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#filter-the-relation-count) | [4.3.0](https://github.com/prisma/prisma/releases/tag/4.3.0) | [4.16.0](https://github.com/prisma/prisma/releases/tag/4.16.0) |\n| [`orderByNulls`](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-with-null-records-first-or-last) | [4.1.0](https://github.com/prisma/prisma/releases/tag/4.1.0) | [4.16.0](https://github.com/prisma/prisma/releases/tag/4.16.0) |\n| [`referentialIntegrity`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode) | [3.1.1](https://github.com/prisma/prisma/releases/tag/3.1.1) | [4.7.0](https://github.com/prisma/prisma/releases/tag/4.7.0) |\n| [`interactiveTransactions`](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions) | [2.29.0](https://github.com/prisma/prisma/releases/tag/2.29.0) | *   [4.7.0](https://github.com/prisma/prisma/releases/tag/4.7.0)<br>*   with Prisma Accelerate [5.1.1](https://github.com/prisma/prisma/releases/tag/5.1.1) |\n| [`extendedIndexes`](https://www.prisma.io/docs/orm/prisma-schema/data-model/indexes) | [3.5.0](https://github.com/prisma/prisma/releases/tag/3.5.0) | [4.0.0](https://github.com/prisma/prisma/releases/tag/4.0.0) |\n| [`filterJson`](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-a-json-field-simple) | [2.23.0](https://github.com/prisma/prisma/releases/tag/2.23.0) | [4.0.0](https://github.com/prisma/prisma/releases/tag/4.0.0) |\n| [`improvedQueryRaw`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries#raw-query-type-mapping) | [3.14.0](https://github.com/prisma/prisma/releases/tag/3.14.0) | [4.0.0](https://github.com/prisma/prisma/releases/tag/4.0.0) |\n| [`cockroachdb`](https://www.prisma.io/docs/orm/overview/databases/cockroachdb) | *   [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0)<br>*   migrations in CockroachDB in [3.11.0](https://github.com/prisma/prisma/releases/tag/3.11.0) | [3.14.0](https://github.com/prisma/prisma/releases/tag/3.14.0) |\n| [`mongodb`](https://www.prisma.io/docs/orm/overview/databases/mongodb) | *   [2.27.0](https://github.com/prisma/prisma/releases/tag/2.27.0)<br>*   introspection of MongoDB in [3.2.0](https://github.com/prisma/prisma/releases/tag/3.2.0)<br>*   introspection of embedded documents in [3.4.0](https://github.com/prisma/prisma/releases/tag/3.4.0)<br>*   MongoDB embedded documents in [3.10.0](https://github.com/prisma/prisma/releases/tag/3.10.0)<br>*   introspection of embedded documents in [3.10.0](https://github.com/prisma/prisma/releases/tag/3.10.0)<br>*   raw query support for MongoDB in [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0)<br>*   filters in embedded documents as an Experimental Feature in [3.11.0](https://github.com/prisma/prisma/releases/tag/3.11.0)<br>*   order by embedded documents in [3.11.0](https://github.com/prisma/prisma/releases/tag/3.11.0) | [3.12.0](https://github.com/prisma/prisma/releases/tag/3.12.0) |\n| [`microsoftSqlServer`](https://www.prisma.io/docs/orm/overview/databases/sql-server) | [2.10.0](https://github.com/prisma/prisma/releases/tag/2.10.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| [`namedConstraints`](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping#constraint-and-index-names) | [2.29.0](https://github.com/prisma/prisma/releases/tag/2.29.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| [`referentialActions`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions) | [2.26.0](https://github.com/prisma/prisma/releases/tag/2.26.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| [`orderByAggregateGroup`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#order-by-aggregate-group) | [2.21.0](https://github.com/prisma/prisma/releases/tag/2.21.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| [`orderByRelation`](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#sort-by-relation) | *   [2.16.0](https://github.com/prisma/prisma/releases/tag/2.16.0)<br>*   order by aggregates of relations in [2.19.0](https://github.com/prisma/prisma/releases/tag/2.19.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| [`selectRelationCount`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#count-relations) | [2.20.0](https://github.com/prisma/prisma/releases/tag/2.20.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| `napi` | [2.20.0](https://github.com/prisma/prisma/releases/tag/2.20.0) | [3.0.1](https://github.com/prisma/prisma/releases/tag/3.0.1) |\n| [`groupBy`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#groupby) | [2.14.0](https://github.com/prisma/prisma/releases/tag/2.14.0) | [2.20.0](https://github.com/prisma/prisma/releases/tag/2.20.0) |\n| [`createMany`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany) | [2.16.0](https://github.com/prisma/prisma/releases/tag/2.16.0) | [2.20.0](https://github.com/prisma/prisma/releases/tag/2.20.0) |\n| [`nativeTypes`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#native-types-mapping) | [2.11.0](https://github.com/prisma/prisma/releases/tag/2.11.0) | [2.17.0](https://github.com/prisma/prisma/releases/tag/2.17.0) |\n| [`uncheckedScalarInputs`](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#create-a-single-record-and-multiple-related-records) | [2.11.0](https://github.com/prisma/prisma/releases/tag/2.11.0) | [2.15.0](https://github.com/prisma/prisma/releases/tag/2.15.0) |\n| [`transactionApi`](https://www.prisma.io/docs/orm/prisma-client/queries/transactions#the-transaction-api) | [2.1.0](https://github.com/prisma/prisma/releases/tag/2.1.0) | [2.11.0](https://github.com/prisma/prisma/releases/tag/2.11.0) |\n| [`connectOrCreate`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connectorcreate) | [2.1.0](https://github.com/prisma/prisma/releases/tag/2.1.0) | [2.11.0](https://github.com/prisma/prisma/releases/tag/2.11.0) |\n| [`atomicNumberOperations`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#atomic-number-operations) | [2.6.0](https://github.com/prisma/prisma/releases/tag/2.6.0) | [2.10.0](https://github.com/prisma/prisma/releases/tag/2.10.0) |\n| [`insensitiveFilters` (PostgreSQL)](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#case-insensitive-filtering) | [2.5.0](https://github.com/prisma/prisma/releases/tag/2.5.0) | [2.8.0](https://github.com/prisma/prisma/releases/tag/2.8.0) |\n| [`middlewares`](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware) | [2.3.0](https://github.com/prisma/prisma/releases/tag/2.3.0) | [2.5.0](https://github.com/prisma/prisma/releases/tag/2.5.0) |\n| [`aggregateApi`](https://www.prisma.io/docs/orm/prisma-client/queries/aggregation-grouping-summarizing#aggregate) | [2.2.0](https://github.com/prisma/prisma/releases/tag/2.2.0) | [2.5.0](https://github.com/prisma/prisma/releases/tag/2.5.0) |\n| [`distinct`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#distinct) | [2.3.0](https://github.com/prisma/prisma/releases/tag/2.3.0) | [2.5.0](https://github.com/prisma/prisma/releases/tag/2.5.0) |",
  "title": "Prisma Client & Prisma schema | Prisma Documentation",
  "description": "Prisma Client and Prisma schema features that are currently in Preview.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations",
  "markdown": "# One-to-one relations | Prisma Documentation\n\nThis page introduces one-to-one relations and explains how to use them in your Prisma schema.\n\n## Overview[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#overview \"Direct link to Overview\")\n\nOne-to-one (1-1) relations refer to relations where at most **one** record can be connected on both sides of the relation. In the example below, there is a one-to-one relation between `User` and `Profile`:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  profile Profile?}model Profile {  id     Int  @id @default(autoincrement())  user   User @relation(fields: [userId], references: [id])  userId Int  @unique // relation scalar field (used in the `@relation` attribute above)}\n```\n\nThe `userId` relation scalar is a direct representation of the foreign key in the underlying database. This one-to-one relation expresses the following:\n\n*   \"a user can have zero profiles or one profile\" (because the `profile` field is [optional](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) on `User`)\n*   \"a profile must always be connected to one user\"\n\nIn the previous example, the `user` relation field of the `Profile` model references the `id` field of the `User` model. You can also reference a different field. In this case, you need to mark the field with the `@unique` attribute, to guarantee that there is only a single `User` connected to each `Profile`. In the following example, the `user` field references an `email` field in the `User` model, which is marked with the `@unique` attribute:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  email   String   @unique // <-- add unique attribute  profile Profile?}model Profile {  id        Int    @id @default(autoincrement())  user      User   @relation(fields: [userEmail], references: [email])  userEmail String @unique // relation scalar field (used in the `@relation` attribute above)}\n```\n\nwarning\n\nIn MySQL, you can create a foreign key with only an index on the referenced side, and not a unique constraint. In Prisma ORM versions 4.0.0 and later, if you introspect a relation of this type it will trigger a validation error. To fix this, you will need to add a `@unique` constraint to the referenced field.\n\n## Multi-field relations in relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#multi-field-relations-in-relational-databases \"Direct link to Multi-field relations in relational databases\")\n\nIn **relational databases only**, you can also use [multi-field IDs](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1) to define a 1-1 relation:\n\n```\nmodel User {  firstName String  lastName  String  profile   Profile?  @@id([firstName, lastName])}model Profile {  id            Int    @id @default(autoincrement())  user          User   @relation(fields: [userFirstName, userLastName], references: [firstName, lastName])  userFirstName String // relation scalar field (used in the `@relation` attribute above)  userLastName  String // relation scalar field (used in the `@relation` attribute above)  @@unique([userFirstName, userLastName])}\n```\n\n## 1-1 relations in the database[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#1-1-relations-in-the-database \"Direct link to 1-1 relations in the database\")\n\n### Relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#relational-databases \"Direct link to Relational databases\")\n\nThe following example demonstrates how to create a 1-1 relation in SQL:\n\n```\nCREATE TABLE \"User\" (    id SERIAL PRIMARY KEY);CREATE TABLE \"Profile\" (    id SERIAL PRIMARY KEY,    \"userId\" INTEGER NOT NULL UNIQUE,    FOREIGN KEY (\"userId\") REFERENCES \"User\"(id));\n```\n\nNotice that there is a `UNIQUE` constraint on the foreign key `userId`. If this `UNIQUE` constraint was missing, the relation would be considered a [1-n relation](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations).\n\nThe following example demonstrates how to create a 1-1 relation in SQL using a composite key (`firstName` and `lastName`):\n\n```\nCREATE TABLE \"User\" (    firstName TEXT,    lastName TEXT,    PRIMARY KEY (\"firstName\",\"lastName\"));CREATE TABLE \"Profile\" (    id SERIAL PRIMARY KEY,    \"userFirstName\" TEXT NOT NULL,    \"userLastName\" TEXT NOT NULL,    UNIQUE (\"userFirstName\", \"userLastName\")    FOREIGN KEY (\"userFirstName\", \"userLastName\") REFERENCES \"User\"(\"firstName\", \"lastName\"));\n```\n\n### MongoDB[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#mongodb \"Direct link to MongoDB\")\n\nFor MongoDB, Prisma ORM currently uses a [normalized data model design](https://docs.mongodb.com/manual/core/data-model-design/), which means that documents reference each other by ID in a similar way to relational databases.\n\nThe following MongoDB document represents a `User`:\n\n```\n{ \"_id\": { \"$oid\": \"60d58e130011041800d209e1\" }, \"name\": \"Bob\" }\n```\n\nThe following MongoDB document represents a `Profile` - notice the `userId` field, which references the `User` document's `$oid`:\n\n```\n{  \"_id\": { \"$oid\": \"60d58e140011041800d209e2\" },  \"bio\": \"I'm Bob, and I like drawing.\",  \"userId\": { \"$oid\": \"60d58e130011041800d209e1\" }}\n```\n\n## Required and optional 1-1 relation fields[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#required-and-optional-1-1-relation-fields \"Direct link to Required and optional 1-1 relation fields\")\n\nIn a one-to-one relation, the side of the relation _without_ a relation scalar (the field representing the foreign key in the database) _must_ be optional:\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  profile Profile? // No relation scalar - must be optional}\n```\n\nThis restriction was introduced in 2.12.0.\n\nHowever, you can choose if the side of the relation _with_ a relation scalar should be optional or mandatory.\n\n### Mandatory 1-1 relation[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#mandatory-1-1-relation \"Direct link to Mandatory 1-1 relation\")\n\nIn the following example, `profile` and `profileId` are mandatory. This means that you cannot create a `User` without connecting or creating a `Profile`:\n\n```\nmodel User {  id        Int     @id @default(autoincrement())  profile   Profile @relation(fields: [profileId], references: [id]) // references `id` of `Profile`  profileId Int     @unique // relation scalar field (used in the `@relation` attribute above)}model Profile {  id   Int   @id @default(autoincrement())  user User?}\n```\n\n### Optional 1-1 relation[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#optional-1-1-relation \"Direct link to Optional 1-1 relation\")\n\nIn the following example, `profile` and `profileId` are optional. This means that you can create a user without connecting or creating a `Profile`:\n\n```\nmodel User {  id        Int      @id @default(autoincrement())  profile   Profile? @relation(fields: [profileId], references: [id]) // references `id` of `Profile`  profileId Int?     @unique // relation scalar field (used in the `@relation` attribute above)}model Profile {  id   Int   @id @default(autoincrement())  user User?}\n```\n\n## Choosing which side should store the foreign key in a 1-1 relation[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations#choosing-which-side-should-store-the-foreign-key-in-a-1-1-relation \"Direct link to Choosing which side should store the foreign key in a 1-1 relation\")\n\nIn **1-1 relations**, you can decide yourself which side of the relation you want to annotate with the `@relation` attribute (and therefore holds the foreign key).\n\nIn the following example, the relation field on the `Profile` model is annotated with the `@relation` attribute. `userId` is a direct representation of the foreign key in the underlying database:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  profile Profile?}model Profile {  id     Int  @id @default(autoincrement())  user   User @relation(fields: [userId], references: [id])  userId Int  @unique // relation scalar field (used in the `@relation` attribute above)}\n```\n\nYou can also annotate the other side of the relation with the `@relation` attribute. The following example annotates the relation field on the `User` model. `profileId` is a direct representation of the foreign key in the underlying database:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        Int      @id @default(autoincrement())  profile   Profile? @relation(fields: [profileId], references: [id])  profileId Int?     @unique // relation scalar field (used in the `@relation` attribute above)}model Profile {  id   Int   @id @default(autoincrement())  user User?}\n```",
  "title": "One-to-one relations | Prisma Documentation",
  "description": "How to define and work with one-to-one relations in Prisma.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/reference/preview-features/cli-preview-features",
  "markdown": "# Prisma CLI Preview features | Prisma Documentation\n\nWhen we release a new Prisma CLI feature, it often starts in Preview so that you can test it and submit your feedback. After we improve the feature with your feedback and are satisfied with the internal test results, we promote the feature to general availability.\n\nFor more information, see [ORM releases and maturity levels](https://www.prisma.io/docs/orm/more/releases).\n\n## Currently active Preview features[​](https://www.prisma.io/docs/orm/reference/preview-features/cli-preview-features#currently-active-preview-features \"Direct link to Currently active Preview features\")\n\nThere are currently no [Preview](https://www.prisma.io/docs/orm/more/releases#preview) features for Prisma CLI.\n\nIn the list below, you can find a history of Prisma CLI features that were in Preview and are now in general availability. The features are sorted by the most recent version in which they were promoted to general availability.\n\n| Features | Released in Preview | Released in general availability |\n| --- | --- | --- |\n| [`prisma migrate diff`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#fixing-failed-migrations-with-migrate-diff-and-db-execute) | [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0) | [3.13.0](https://github.com/prisma/prisma/releases/tag/3.13.0) |\n| [`prisma db execute`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#fixing-failed-migrations-with-migrate-diff-and-db-execute) | [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0) | [3.13.0](https://github.com/prisma/prisma/releases/tag/3.13.0) |\n| [`prisma db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) | [2.10.0](https://github.com/prisma/prisma/releases/tag/2.10.0) | [2.22.0](https://github.com/prisma/prisma/releases/tag/2.22.0) |\n| [`prisma migrate`](https://www.prisma.io/docs/orm/prisma-migrate) | [2.13.0](https://github.com/prisma/prisma/releases/tag/2.13.0) | [2.19.0](https://github.com/prisma/prisma/releases/tag/2.19.0) |",
  "title": "Prisma CLI Preview features | Prisma Documentation",
  "description": "Prisma CLI features that are currently in Preview.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions",
  "markdown": "# Upgrading versions (Guides) | Prisma Documentation\n\nThe `dev` [Npm distribution tag](https://docs.npmjs.com/adding-dist-tags-to-packages) points to the most recent development version of the package, which is published for each commit to the main branch of `prisma/prisma`. You can use the `dev` distribution tag to verify a fix or test a feature before it is officially released.\n\n```\nnpm install @prisma/client@dev prisma@dev\n```\n\ndanger\n\nDo not use the `dev` distribution tag in production - wait until the official release that contains the features and fixes you are interested in is released. For example, fixes present `@prisma/client@2.23.0-dev.25` will eventually be released as part of `@prisma/client@2.23.0`.",
  "title": "Upgrading versions (Guides) | Prisma Documentation",
  "description": "Upgrading your project to the latest version of Prisma ORM.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-to-use-preview-features",
  "markdown": "# Upgrading to use Preview features (Guides)\n\nPreview features are new features that can only be used by opting in using a corresponding feature flag.\n\n## Enabling preview features[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-to-use-preview-features#enabling-preview-features \"Direct link to Enabling preview features\")\n\nSome releases include Preview features that are not considered production-ready, and must be enabled before you can use them. For more information about enabling Preview features, refer to the following documentation:\n\n*   [Enable Prisma Client and schema preview features](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features)\n*   [Enable Prisma CLI preview features](https://www.prisma.io/docs/orm/reference/preview-features/cli-preview-features)\n\nwarning\n\nWe do not recommend using Preview features in production.",
  "title": "Upgrading to use Preview features (Guides) | Prisma Documentation",
  "description": "Upgrading your project to use a Preview feature.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1",
  "markdown": "# Upgrade from Prisma 1 to Prisma ORM 2\n\n## In this section[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1#in-this-section \"Direct link to In this section\")\n\n[\n\n## How to upgrade\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade)\n\n[\n\n## Schema incompatibilities\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-mysql)\n\n[\n\n## Schema incompatibilities\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql)\n\n[\n\n## Upgrading the Prisma ORM layer\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-mysql)\n\n[\n\n## Upgrading the Prisma ORM layer\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql)\n\n[\n\n## Old to new Nexus\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus)\n\n[\n\n## prisma-binding to Nexus\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus)\n\n[\n\n## prisma-binding to SDL-first\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first)\n\n[\n\n## REST API\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api)\n\n[\n\n## Upgrade from MongoDB Beta\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta)",
  "title": "Upgrade from Prisma 1 to Prisma ORM 2 | Prisma Documentation",
  "description": "Upgrading your project from Prisma 1 to Prisma ORM 2",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles",
  "markdown": "# Help articles | Prisma Documentation\n\nThis section provides a number of common problems that developers might encounter when using Prisma ORM and provides short, practical solutions to resolve them.\n\n## Help articles[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles#help-articles \"Direct link to Help articles\")\n\n[\n\n## Autocompletion in GraphQL resolvers with JavaScript\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/autocompletion-in-graphql-resolvers-with-js)\n\n[\n\n## Modeling and querying many-to-many relations\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/working-with-many-to-many-relations)\n\n[\n\n## Best practice for instantiating Prisma Client with Next.js\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dev-practices)\n\n[\n\n## Using Prisma Client in a Next.js project in a monorepo setup\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-monorepo)\n\n[\n\n## Best practices for using Prisma Client with Next.js and Next.js Data Cache\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dynamic)\n\n[\n\n## Solve package error with vercel/pkg\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/pkg-issue)\n\n[\n\n## Compare columns of the same table with raw queries\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/comparing-columns-through-raw-queries)\n\n[\n\n## Vercel build dependency caching workaround\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/vercel-caching-issue)\n\n[\n\n## Netlify build dependency caching workaround\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/netlify-caching-issue)\n\n[\n\n## Data validation with CHECK constraints (PostgreSQL)\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints)\n\n[\n\n## Using the Nuxt Prisma Module\n\n](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module)",
  "title": "Help articles | Prisma Documentation",
  "description": "Common problems and how to solve them.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports",
  "markdown": "# Creating bug reports for Prisma ORM\n\n## Overview[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#overview \"Direct link to Overview\")\n\nYou can help us improve Prisma ORM by creating **bug reports**. When creating a bug report, it's important that you include as much information as possible about your issue. That way, it's easier to reproduce.\n\nNote that you can also create **feature requests** or ask a **question** via the issue templates on GitHub.\n\n## Where to open the bug report on GitHub?[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#where-to-open-the-bug-report-on-github \"Direct link to Where to open the bug report on GitHub?\")\n\nPrisma ORM's tools are spread across different repositories in the [`prisma`](https://github.com/prisma/) organization on GitHub. You can open a new issue in the repo of the respective tool.\n\nIf you're unsure where to open the GitHub issue, you can use the main [`prisma/prisma`](https://github.com/prisma/prisma) repo as a default. Our engineering team is regularly triaging new issues and will move the issue to another repo if necessary.\n\nIn an ideal scenario, you're able to reproduce the bug in an isolated environment and put it into a GitHub repository that you can share in your report. That way, we already have a reproduction and the problem can be tackled without further triaging.\n\nThis [StackOverflow guide](https://stackoverflow.com/help/minimal-reproducible-example) has a lot of helpful information for creating minimal, reproducible examples.\n\n## Best practices for writing a bug report[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#best-practices-for-writing-a-bug-report \"Direct link to Best practices for writing a bug report\")\n\nIf you don't have the time to create a full reproduction of the issue, please include as much information as possible about the problem. The [bug report template](https://pris.ly/prisma-prisma-bug-report) helps you with that.\n\n### Include logging and debugging output[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#include-logging-and-debugging-output \"Direct link to Include logging and debugging output\")\n\nPlease make sure to include _any_ [logging](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging) and [debugging](https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/debugging) output in the issue that may help to identify the problem.\n\n**Setting the `DEBUG` env var**\n\nTo get additional output from Prisma ORM, you can set `DEBUG` to `*`:\n\n**Print logs of Prisma Client**\n\nYou can enable additional logs in Prisma Client by instantiating it with the `log` option:\n\n```\nconst prisma = new PrismaClient({ log: ['query', 'info', 'warn'] })\n```\n\n### Include a bug description, reproduction and expected behavior[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#include-a-bug-description-reproduction-and-expected-behavior \"Direct link to Include a bug description, reproduction and expected behavior\")\n\nWhen describing the bug, it's helpful to include the following information:\n\n*   A clear and concise description of what the bug is\n*   Steps to reproduce the bug\n*   A clear and concise description of what you expected to happen\n*   Screenshots (if applicable)\n\nExpand for an example for a hypothetical bug report\n\n**Example**\n\n**Describe the bug**\n\n`@unique` attribute on `email` field doesn't work on my model. I can create duplicate records with the same `email`.\n\n**To reproduce**:\n\nI have this Prisma schema (removed all unnecessary models and fields):\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  email String @unique}\n```\n\nI then run `prisma generate` to generate Prisma Client.\n\nI then have a Node.js script that creates two `User` records with the same `email`:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()// A `main` function so that we can use async/awaitasync function main() {  const user1 = await prisma.create({    data: { email: 'alice@prisma.io' },  })  const user2 = await prisma.create({    data: { email: 'alice@prisma.io' },  })  console.log(user1, user2)}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\n**Expected behavior**\n\nI expected an exception when trying to create `user2` with the same `email` as `user1` because this violates the `@unique` constraint defined in the Prisma schema.\n\n### Include environment and setup information[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#include-environment-and-setup-information \"Direct link to Include environment and setup information\")\n\nPlease include any information about your environment and setup. Specifically it's important to include:\n\n*   Which **operating system** you use (e.g. macOS, Windows, Debian, CentOS, ...)\n*   Which **database** you use with Prisma ORM (PostgreSQL, MySQL, MariaDB, SQLite or Microsoft SQL Server)\n*   Which **version of Prisma ORM** you use (run `prisma -v` to see your Prisma ORM version)\n*   Which **version of Node.js** you use (run `node -v` to see your Node.js version)\n\nHere's an example of what this could look like in your bug report:\n\n*   OS: macOS Catalina 10.15.7\n*   Database: PostgreSQL v11\n*   Node.js version: `v14.16.1`\n*   Prisma ORM version:\n\n```\nprisma               : 2.22.0@prisma/client       : Not foundCurrent platform     : darwinQuery Engine         : query-engine 60cc71d884972ab4e897f0277c4b84383dddaf6c (at ../../../../../.npm/_npx/31227/lib/node_modules/prisma/node_modules/@prisma/engines/query-engine-darwin)Migration Engine     : migration-engine-cli 60cc71d884972ab4e897f0277c4b84383dddaf6c (at ../../../../../.npm/_npx/31227/lib/node_modules/prisma/node_modules/@prisma/engines/migration-engine-darwin)Format Binary        : prisma-fmt 60cc71d884972ab4e897f0277c4b84383dddaf6c (at ../../../../../.npm/_npx/31227/lib/node_modules/prisma/node_modules/@prisma/engines/prisma-fmt-darwin)Default Engines Hash : 60cc71d884972ab4e897f0277c4b84383dddaf6cStudio               : 0.379.0\n```\n\nAdditionally, you can use the [`prisma debug`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#debug) command to retrieve debugging information. The `prisma debug` command provides debugging information that compliments the output of the `prisma -v` command. The information includes [environment variables](https://www.prisma.io/docs/orm/reference/environment-variables-reference) used for Prisma Client, Prisma Migrate, Prisma CLI, and Prisma Studio.\n\ninfo\n\nThe `prisma debug` command is available from version 5.6.0 and newer. If you're using an older version of Prisma ORM, you can use this command by running:\n\n### Include relevant Prisma ORM info (e.g. the Prisma schema, Prisma Client queries, ...)[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/creating-bug-reports#include-relevant-prisma-orm-info-eg-the-prisma-schema-prisma-client-queries- \"Direct link to Include relevant Prisma ORM info (e.g. the Prisma schema, Prisma Client queries, ...)\")\n\nTo help us reproduce your problem, it is helpful to include your Prisma schema in the bug report. **Please remove any database credentials before sharing your Prisma schema in a bug report**. If you're sure about which parts of the schema is causing the issue, please strip out the irrelevant parts of it and only show the parts that are related to the problem. If you're not sure, please include your entire schema.\n\nIf you have an issue with Prisma Client, please also include which Prisma Client query is causing the issue.",
  "title": "Creating bug reports for Prisma ORM | Prisma Documentation",
  "description": "This page explains best practices for creating bug reports for Prisma ORM, including sharing additional debugging output and other recommendations.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm",
  "markdown": "# Prisma ORM vs TypeORM | Prisma Documentation\n\nThis page compares Prisma ORM and [TypeORM](https://typeorm.io/#/). If you want to learn how to migrate from TypeORM to Prisma ORM, check out this [guide](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-typeorm).\n\n## TypeORM vs Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#typeorm-vs-prisma-orm \"Direct link to TypeORM vs Prisma ORM\")\n\nWhile Prisma ORM and TypeORM solve similar problems, they work in very different ways.\n\n**TypeORM** is a traditional ORM which maps _tables_ to _model classes_. These model classes can be used to generate SQL migrations. Instances of the model classes then provide an interface for CRUD queries to an application at runtime.\n\n**Prisma ORM** is a new kind of ORM that mitigates many problems of traditional ORMs, such as bloated model instances, mixing business with storage logic, lack of type-safety or unpredictable queries caused e.g. by lazy loading.\n\nIt uses the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) to define application models in a declarative way. Prisma Migrate then allows to generate SQL migrations from the Prisma schema and executes them against the database. CRUD queries are provided by Prisma Client, a lightweight and entirely type-safe database client for Node.js and TypeScript.\n\n## API design & Level of abstraction[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#api-design--level-of-abstraction \"Direct link to API design & Level of abstraction\")\n\nTypeORM and Prisma ORM operate on different levels of abstraction. TypeORM is closer to mirroring SQL in its API while Prisma Client provides a higher-level abstraction that was carefully designed with the common tasks of application developers in mind. Prisma ORM's API design heavily leans on the idea of [making the right thing easy](https://jason.energy/right-thing-easy-thing/).\n\nWhile Prisma Client operates on a higher-level of abstraction, it strives to expose the full power of the underlying database and lets you drop down to [raw SQL](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries) at any time if your use case requires it.\n\nThe following sections examine a few examples for how Prisma ORM's and TypeORM's APIs differ in certain scenarios and what the rationale of Prisma ORM's API design is in these cases.\n\n### Filtering[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#filtering \"Direct link to Filtering\")\n\nTypeORM primarily leans on SQL operators for filtering lists or records, e.g. with the `find` method. Prisma ORM on the other hand, provides a more [generic set of operators](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting#filter-conditions-and-operators) that are intuitive to use. It should also be noted that, as explained in the type-safety section [below](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#filtering-1), TypeORM loses type-safety in filter queries in many scenarios.\n\nA good example of how the filtering APIs of both TypeORM and Prisma ORM differ is by looking at `string` filters. While TypeORM primarily provides the filter based on the `ILike` operator which comes directly from SQL, Prisma ORM provides more specific operators that developers can use, e.g.: `contains`, `startsWith` and `endsWith`.\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: 'Hello World',  },})\n```\n\n**TypeORM**\n\n```\nconst posts = await postRepository.find({  where: {    title: ILike('Hello World'),  },})\n```\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: { contains: 'Hello World' },  },})\n```\n\n**TypeORM**\n\n```\nconst posts = await postRepository.find({  where: {    title: ILike('%Hello World%'),  },})\n```\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: { startsWith: 'Hello World' },  },})\n```\n\n**TypeORM**\n\n```\nconst posts = await postRepository.find({  where: {    title: ILike('Hello World%'),  },})\n```\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: { endsWith: 'Hello World' },  },})\n```\n\n**TypeORM**\n\n```\nconst posts = await postRepository.find({  where: {    title: ILike('%Hello World'),  },})\n```\n\nTypeORM only offers limit-offset pagination while Prisma ORM conveniently provides dedicated APIs for both limit-offset but also cursor-based. You can learn more about both approaches in the [Pagination](https://www.prisma.io/docs/orm/prisma-client/queries/pagination) section of the docs or in the API comparison [below](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#pagination-1).\n\n### Relations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#relations \"Direct link to Relations\")\n\nWorking with records that are connected via foreign keys can become very complex in SQL. Prisma ORM's concept of [virtual relation field](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) enables an intuitive and convenient way for application developers to work with related data. Some benefits of Prisma ORM's approach are:\n\n*   traversing relationships via the fluent API ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#fluent-api))\n*   nested writes that enable updating/creating connected records ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes))\n*   applying filters on related records ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#relation-filters))\n*   easy and type-safe querying of nested data without worrying about JOINs ([docs](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-reads))\n*   creating nested TypeScript typings based on models and their relations ([docs](https://www.prisma.io/docs/orm/prisma-client/type-safety))\n*   intuitive modeling of relations in the data model via relation fields ([docs](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations))\n*   implicit handling of relation tables (also sometimes called JOIN, link, pivot or junction tables) ([docs](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations))\n\n### Data modeling and migrations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#data-modeling-and-migrations \"Direct link to Data modeling and migrations\")\n\nPrisma models are defined in the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) while TypeORM uses classes and experimental TypeScript decorators for model definitions. With the Active Record ORM pattern, TypeORM's approach often leads to complex model instances that are becoming hard to maintain as an application grows.\n\nPrisma ORM on the other hand generates a lightweight database client that exposes a tailored and fully type-safe API to read and write data for the models that are defined in the Prisma schema, following the DataMapper ORM pattern rather than Active Record.\n\nPrisma ORM's DSL for data modeling is lean, simple and intuitive to use. When modeling data in VS Code, you can further take advantage of Prisma ORM's powerful VS Code extension with features like autocompletion, quick fixes, jump to definition and other benefits that increase developer productivity.\n\n**Prisma ORM**\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  name  String?  email String  @unique  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  authorId  Int?  author    User?   @relation(fields: [authorId], references: [id])}\n```\n\n**TypeORM**\n\n```\nimport {  Entity,  PrimaryGeneratedColumn,  Column,  OneToMany,  ManyToOne,} from 'typeorm'@Entity()export class User {  @PrimaryGeneratedColumn()  id: number  @Column({ nullable: true })  name: string  @Column({ unique: true })  email: string  @OneToMany((type) => Post, (post) => post.author)  posts: Post[]}@Entity()export class Post {  @PrimaryGeneratedColumn()  id: number  @Column()  title: string  @Column({ nullable: true })  content: string  @Column({ default: false })  published: boolean  @ManyToOne((type) => User, (user) => user.posts)  author: User}\n```\n\nMigrations work in similar fashions in TypeORM and Prisma ORM. Both tools follow the approach of generating SQL files based on the provided model definitions and provide a CLI to execute them against the database. The SQL files can be modified before the migrations are executed so that any custom database operation can be performed with either migration system.\n\n## Type safety[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#type-safety \"Direct link to Type safety\")\n\nTypeORM has been one of the first ORMs in the Node.js ecosystem to fully embrace TypeScript and has done a great job in enabling developers to get a certain level of type safety for their database queries.\n\nHowever, there are numerous situations where the type safety guarantees of TypeORM fall short. The following sections describe the scenarios where Prisma ORM can provide stronger guarantees for the types of query results.\n\n### Selecting fields[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#selecting-fields \"Direct link to Selecting fields\")\n\nThis section explains the differences in type safety when selecting a subset of a model's fields in a query.\n\n#### TypeORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#typeorm \"Direct link to TypeORM\")\n\nTypeORM provides a `select` option for its [`find`](https://typeorm.io/#/find-options) methods (e.g. `find`, `findByIds`, `findOne`, ...), for example:\n\n*   \\`find\\` with \\`select\\`\n*   Model\n\n```\nconst postRepository = getManager().getRepository(Post)const publishedPosts: Post[] = await postRepository.find({  where: { published: true },  select: ['id', 'title'],})\n```\n\nWhile each object in the returned `publishedPosts` array only carries the selected `id` and `title` properties at runtime, the TypeScript compiler doesn't have any knowledge of this. It will allow you to access any other properties defined on the `Post` entity after the query, for example:\n\n```\nconst post = publishedPosts[0]// The TypeScript compiler has no issue with thisif (post.content.length > 0) {  console.log(`This post has some content.`)}\n```\n\nThis code will result in an error at runtime:\n\n```\nTypeError: Cannot read property 'length' of undefined\n```\n\nThe TypeScript compiler only sees the `Post` type of the returned objects, but it doesn't know about the fields that these objects _actually_ carry at runtime. It therefore can't protect you from accessing fields that have not been retrieved in the database query, resulting in a runtime error.\n\n#### Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#prisma-orm \"Direct link to Prisma ORM\")\n\nPrisma Client can guarantee full type safety in the same situation and protects you from accessing fields that were not retrieved from the database.\n\nConsider the same example with a Prisma Client query:\n\n*   \\`findMany\\` with \\`select\\`\n*   Model\n\n```\nconst publishedPosts = await prisma.post.findMany({  where: { published: true },  select: {    id: true,    title: true,  },})const post = publishedPosts[0]// The TypeScript compiler will not allow thisif (post.content.length > 0) {  console.log(`This post has some content.`)}\n```\n\nIn this case, the TypeScript compiler will throw the following error already at compile-time:\n\n```\n[ERROR] 14:03:39 ⨯ Unable to compile TypeScript:src/index.ts:36:12 - error TS2339: Property 'content' does not exist on type '{ id: number; title: string; }'.42   if (post.content.length > 0) {\n```\n\nThis is because Prisma Client generates the return type for its queries _on the fly_. In this case, `publishedPosts` is typed as follows:\n\n```\nconst publishedPosts: {  id: number  title: string}[]\n```\n\nIt therefore is impossible for you to accidentally access a property on a model that has not been retrieved in a query.\n\n### Loading relations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#loading-relations \"Direct link to Loading relations\")\n\nThis section explains the differences in type safety when loading relations of a model in a query. In traditional ORMs, this is sometimes called _eager loading_.\n\n#### TypeORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#typeorm-1 \"Direct link to TypeORM\")\n\nTypeORM allows to eagerly load relations from the database via the `relations` option that can be passed to its [`find`](https://typeorm.io/#/find-options) methods.\n\nConsider this example:\n\n*   \\`find\\` with \\`relations\\`\n*   Models\n\n```\nconst postRepository = getManager().getRepository(Post)const publishedPosts: Post[] = await postRepository.find({  where: { published: true },  relations: ['author'],})\n```\n\nUnlike with `select`, TypeORM does _not_ provide autocompletion, nor any type-safety for the strings that are passed to the `relations` option. This means, the TypeScript compiler is not able to catch any typos that are made when querying these relations. For example, it would allow for the following query:\n\n```\nconst publishedPosts: Post[] = await postRepository.find({  where: { published: true },  // this query would lead to a runtime error because of a typo  relations: ['authors'],})\n```\n\nThis subtle typo would now lead to the following runtime error:\n\n```\nUnhandledPromiseRejectionWarning: Error: Relation \"authors\" was not found; please check if it is correct and really exists in your entity.\n```\n\n#### Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#prisma-orm-1 \"Direct link to Prisma ORM\")\n\nPrisma ORM protects you from mistakes like this and thus eliminates a whole class of errors that can occur in your application at runtime. When using `include` to load a relation in a Prisma Client query, you can not only take advantage of autocompletion to specify the query, but the result of the query will also be properly typed:\n\n*   \\`find\\` with \\`relations\\`\n*   Models\n\n```\nconst publishedPosts = await prisma.post.findMany({  where: { published: true },  include: { author: true },})\n```\n\nAgain, the type of `publishedPosts` is generated on the fly and looks as follows:\n\n```\nconst publishedPosts: (Post & {  author: User})[]\n```\n\nFor reference, this is what the `User` and `Post` types look like that Prisma Client generates for your Prisma models:\n\n*   \\`User\\`\n*   \\`Post\\`\n\n```\n// Generated by Prisma ORMexport type User = {  id: number  name: string | null  email: string}\n```\n\n### Filtering[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#filtering-1 \"Direct link to Filtering\")\n\nThis section explains the differences in type safety when filtering a list of records using `where`.\n\n#### TypeORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#typeorm-2 \"Direct link to TypeORM\")\n\nTypeORM allows to pass a `where` option to its [`find`](https://typeorm.io/#/find-options) methods to filter the list of returned records according to specific criteria. These criteria can be defined with respect to a model's properties.\n\n##### Loosing type-safety using operators[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#loosing-type-safety-using-operators \"Direct link to Loosing type-safety using operators\")\n\nConsider this example:\n\n*   \\`find\\` with \\`select\\`\n*   Model\n\n```\nconst postRepository = getManager().getRepository(Post)const publishedPosts: Post[] = await postRepository.find({  where: {    published: true,    title: ILike('Hello World'),    views: MoreThan(0),  },})\n```\n\nThis code runs properly and produces a valid query at runtime. However, the `where` option is not really type-safe in various different scenarios. When using a `FindOperator` like `ILike` or `MoreThan` that only work for specific types (`ILike` works for strings, `MoreThan` for numbers), you're losing the guarantee of providing the correct type for the model's field.\n\nFor example, you can provide a string to the `MoreThan` operator. The TypeScript compiler will not complain and your application will only fail at runtime:\n\n```\nconst postRepository = getManager().getRepository(Post)const publishedPosts: Post[] = await postRepository.find({  where: {    published: true,    title: ILike('Hello World'),    views: MoreThan('test'),  },})\n```\n\nThe code above results in a runtime error that the TypeScript compiler doesn't catch for you:\n\n```\nerror: error: invalid input syntax for type integer: \"test\"\n```\n\n##### Specifying non-existing properties[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#specifying-non-existing-properties \"Direct link to Specifying non-existing properties\")\n\nAlso note that the TypeScript compiler allows you to specify properties on the `where` option that don't exist on your models – again resulting in runtime errors:\n\n```\nconst publishedPosts: Post[] = await postRepository.find({  where: {    published: true,    title: ILike('Hello World'),    viewCount: 1,  },})\n```\n\nIn this case, your application again fails at runtime with the following error:\n\n```\nEntityColumnNotFound: No entity column \"viewCount\" was found.\n```\n\n#### Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#prisma-orm-2 \"Direct link to Prisma ORM\")\n\nBoth filtering scenarios that are problematic with TypeORM in terms of type-safety are covered by Prisma ORM in a fully type-safe way.\n\n##### Type-safe usage of operators[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#type-safe-usage-of-operators \"Direct link to Type-safe usage of operators\")\n\nWith Prisma ORM, the TypeScript compiler enforces the correct usage of an operator per field:\n\n```\nconst publishedPosts = await prisma.post.findMany({  where: {    published: true,    title: { contains: 'Hello World' },    views: { gt: 0 },  },})\n```\n\nIt would not be allowed to specify the same problematic query shown above with Prisma Client:\n\n```\nconst publishedPosts = await prisma.post.findMany({  where: {    published: true,    title: { contains: 'Hello World' },    views: { gt: 'test' }, // Caught by the TypeScript compiler  },})\n```\n\nThe TypeScript compiler would catch this and throw the following error to protect you from a runtime failure of the app:\n\n```\n[ERROR] 16:13:50 ⨯ Unable to compile TypeScript:src/index.ts:39:5 - error TS2322: Type '{ gt: string; }' is not assignable to type 'number | IntNullableFilter'.  Type '{ gt: string; }' is not assignable to type 'IntNullableFilter'.    Types of property 'gt' are incompatible.      Type 'string' is not assignable to type 'number'.42     views: { gt: \"test\" }\n```\n\n##### Type-safe definition of filters as model properties[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#type-safe-definition-of-filters-as-model-properties \"Direct link to Type-safe definition of filters as model properties\")\n\nWith TypeORM, you are able to specify a property on the `where` option that doesn't map to a model's field. In the above example, filtering for `viewCount` therefore led to a runtime error because the field actually is called `views`.\n\nWith Prisma ORM, the TypeScript compiler will not allow to reference any properties inside of `where` that don't exist on the model:\n\n```\nconst publishedPosts = await prisma.post.findMany({  where: {    published: true,    title: { contains: 'Hello World' },    viewCount: { gt: 0 }, // Caught by the TypeScript compiler  },})\n```\n\nAgain, the TypeScript compiler complains with the following message to protect you from your own mistakes:\n\n```\n[ERROR] 16:16:16 ⨯ Unable to compile TypeScript:src/index.ts:39:5 - error TS2322: Type '{ published: boolean; title: { contains: string; }; viewCount: { gt: number; }; }' is not assignable to type 'PostWhereInput'.  Object literal may only specify known properties, and 'viewCount' does not exist in type 'PostWhereInput'.42     viewCount: { gt: 0 }\n```\n\n### Creating new records[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#creating-new-records \"Direct link to Creating new records\")\n\nThis section explains the differences in type safety when creating new records.\n\n#### TypeORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#typeorm-3 \"Direct link to TypeORM\")\n\nWith TypeORM, there are two main ways to create new records in the database: `insert` and `save`. Both methods allow developers to submit data that can lead to runtime errors when _required_ fields are not provided.\n\nConsider this example:\n\n*   Create with \\`save\\`\n*   Create with \\`insert\\`\n*   Model\n\n```\nconst userRepository = getManager().getRepository(User)const newUser = new User()newUser.name = 'Alice'userRepository.save(newUser)\n```\n\nNo matter if you're using `save` or `insert` for record creation with TypeORM, you will get the following runtime error if you forget to provide the value for a required field:\n\n```\nQueryFailedError: null value in column \"email\" of relation \"user\" violates not-null constraint\n```\n\nThe `email` field is defined as required on the `User` entity (which is enforced by a `NOT NULL` constraint in the database).\n\n### Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#prisma-orm-3 \"Direct link to Prisma ORM\")\n\nPrisma ORM protects you from these kind of mistakes by enforcing that you submit values for _all_ required fields of a model.\n\nFor example, the following attempt to create a new `User` where the required `email` field is missing would be caught by the TypeScript compiler:\n\n*   Create with \\`create\\`\n*   Model\n\n```\nconst newUser = await prisma.user.create({  data: {    name: 'Alice',  },})\n```\n\nIt would lead to the following compile-time error:\n\n```\n[ERROR] 10:39:07 ⨯ Unable to compile TypeScript:src/index.ts:39:5 - error TS2741: Property 'email' is missing in type '{ name: string; }' but required in type 'UserCreateInput'.\n```\n\n## API comparison[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#api-comparison \"Direct link to API comparison\")\n\n### Fetching single objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#fetching-single-objects \"Direct link to Fetching single objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.findUnique({  where: {    id: 1,  },})\n```\n\n**TypeORM**\n\n```\nconst userRepository = getRepository(User)const user = await userRepository.findOne(id)\n```\n\n### Fetching selected scalars of single objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#fetching-selected-scalars-of-single-objects \"Direct link to Fetching selected scalars of single objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.findUnique({  where: {    id: 1,  },  select: {    name: true,  },})\n```\n\n**TypeORM**\n\n```\nconst userRepository = getRepository(User)const user = await userRepository.findOne(id, {  select: ['id', 'email'],})\n```\n\n### Fetching relations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#fetching-relations \"Direct link to Fetching relations\")\n\n**Prisma ORM**\n\n*   Using include\n*   Fluent API\n\n```\nconst posts = await prisma.user.findUnique({  where: {    id: 2,  },  include: {    post: true,  },})\n```\n\n> **Note**: `select` return a `user` object that includes a `post` array, whereas the fluent API only returns a `post` array.\n\n**TypeORM**\n\n*   Using \\`relations\\`\n*   Using \\`JOIN\\`\n*   Using earger relations\n\n```\nconst userRepository = getRepository(User)const user = await userRepository.findOne(id, {  relations: ['posts'],})\n```\n\n### Filtering for concrete values[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#filtering-for-concrete-values \"Direct link to Filtering for concrete values\")\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: {      contains: 'Hello',    },  },})\n```\n\n**TypeORM**\n\n```\nconst userRepository = getRepository(User)const users = await userRepository.find({  where: {    name: 'Alice',  },})\n```\n\n### Other filter criteria[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#other-filter-criteria \"Direct link to Other filter criteria\")\n\n**Prisma ORM**\n\nPrisma ORM generates many [additional filters](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting) that are commonly used in modern application development.\n\n**TypeORM**\n\nTypeORM provides [built-in operators](https://typeorm.io/#/find-options/advanced-options) that can be used to create more complex comparisons\n\n### Relation filters[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#relation-filters \"Direct link to Relation filters\")\n\n**Prisma ORM**\n\nPrisma ORM lets you filter a list based on a criteria that applies not only to the models of the list being retrieved, but to a _relation_ of that model.\n\nFor example, the following query returns users with one or more posts with \"Hello\" in the title:\n\n```\nconst posts = await prisma.user.findMany({  where: {    Post: {      some: {        title: {          contains: 'Hello',        },      },    },  },})\n```\n\n**TypeORM**\n\nTypeORM doesn't offer a dedicated API for relation filters. You can get similar functionality by using the `QueryBuilder` or writing the queries by hand.\n\n**Prisma ORM**\n\nCursor-style pagination:\n\n```\nconst page = await prisma.post.findMany({  before: {    id: 242,  },  last: 20,})\n```\n\nOffset pagination:\n\n```\nconst cc = await prisma.post.findMany({  skip: 200,  first: 20,})\n```\n\n**TypeORM**\n\n```\nconst postRepository = getRepository(Post)const posts = await postRepository.find({  skip: 5,  take: 10,})\n```\n\n### Creating objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#creating-objects \"Direct link to Creating objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.create({  data: {    email: 'alice@prisma.io',  },})\n```\n\n**TypeORM**\n\n*   Using \\`save\\`\n*   Using \\`create\\`\n*   Using \\`insert\\`\n\n```\nconst user = new User()user.name = 'Alice'user.email = 'alice@prisma.io'await user.save()\n```\n\n### Updating objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#updating-objects \"Direct link to Updating objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.update({  data: {    name: 'Alicia',  },  where: {    id: 2,  },})\n```\n\n**TypeORM**\n\n```\nconst userRepository = getRepository(User)const updatedUser = await userRepository.update(id, {  name: 'James',  email: 'james@prisma.io',})\n```\n\n### Deleting objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#deleting-objects \"Direct link to Deleting objects\")\n\n**Prisma ORM**\n\n```\nconst deletedUser = await prisma.user.delete({  where: {    id: 10,  },})\n```\n\n**TypeORM**\n\n*   Using \\`delete\\`\n*   Using \\`remove\\`\n\n```\nconst userRepository = getRepository(User)await userRepository.delete(id)\n```\n\n### Batch updates[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#batch-updates \"Direct link to Batch updates\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.updateMany({  data: {    name: 'Published author!',  },  where: {    Post: {      some: {        published: true,      },    },  },})\n```\n\n**TypeORM**\n\nYou can use the [query builder to update entities in your database](https://typeorm.io/#/update-query-builder).\n\n### Batch deletes[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#batch-deletes \"Direct link to Batch deletes\")\n\n**Prisma ORM**\n\n```\nconst users = await prisma.user.deleteMany({  where: {    id: {      in: [1, 2, 6, 6, 22, 21, 25],    },  },})\n```\n\n**TypeORM**\n\n*   Using \\`delete\\`\n*   Using \\`remove\\`\n\n```\nconst userRepository = getRepository(User)await userRepository.delete([id1, id2, id3])\n```\n\n### Transactions[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#transactions \"Direct link to Transactions\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.create({  data: {    email: 'bob.rufus@prisma.io',    name: 'Bob Rufus',    Post: {      create: [        { title: 'Working at Prisma' },        { title: 'All about databases' },      ],    },  },})\n```\n\n**TypeORM**\n\n```\nawait getConnection().$transaction(async (transactionalEntityManager) => {  const user = getRepository(User).create({    name: 'Bob',    email: 'bob@prisma.io',  })  const post1 = getRepository(Post).create({    title: 'Join us for GraphQL Conf in 2019',  })  const post2 = getRepository(Post).create({    title: 'Subscribe to GraphQL Weekly for GraphQL news',  })  user.posts = [post1, post2]  await transactionalEntityManager.save(post1)  await transactionalEntityManager.save(post2)  await transactionalEntityManager.save(user)})\n```",
  "title": "Prisma ORM vs TypeORM | Prisma Documentation",
  "description": "Learn how Prisma compares to TypeORM.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize",
  "markdown": "# Prisma ORM vs Sequelize | Prisma Documentation\n\nThis page compares the Prisma ORM and [Sequelize](https://sequelize.org/master/) APIs.\n\n## Sequelize vs Prisma ORM[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#sequelize-vs-prisma-orm \"Direct link to Sequelize vs Prisma ORM\")\n\nWhile Prisma ORM and Sequelize solve similar problems, they work in very different ways.\n\n**Sequelize** is a traditional ORM which maps _tables_ to _model classes_. Instances of the model classes then provide an interface for CRUD queries to an application at runtime.\n\n**Prisma ORM** is a new kind of ORM that mitigates many problems of traditional ORMs, such as bloated model instances, mixing business with storage logic, lack of type-safety or unpredictable queries caused e.g. by lazy loading.\n\nIt uses the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) to define application models in a declarative way. Prisma Migrate then allows to generate SQL migrations from the Prisma schema and executes them against the database. CRUD queries are provided by Prisma Client, a lightweight and entirely type-safe database client for Node.js and TypeScript.\n\n## API comparison[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#api-comparison \"Direct link to API comparison\")\n\n### Fetching single objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#fetching-single-objects \"Direct link to Fetching single objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.findUnique({  where: {    id: 1,  },})\n```\n\n**Sequelize**\n\n```\nconst user = await User.findByPk(id)\n```\n\n### Fetching selected scalars of single objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#fetching-selected-scalars-of-single-objects \"Direct link to Fetching selected scalars of single objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.findUnique({  where: {    id: 1,  },  select: {    name: true,  },})\n```\n\n**Sequelize**\n\n```\nconst user = await User.findByPk(1, { attributes: ['name'], raw: true })\n```\n\ntip\n\nUse the `raw: true` query option to return plain JavaScript objects.\n\n### Fetching relations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#fetching-relations \"Direct link to Fetching relations\")\n\n**Prisma ORM**\n\n*   Using \\`include\\`\n*   Fluent API\n\n```\nconst posts = await prisma.user.findUnique({  where: {    id: 2,  },  include: {    post: true,  },})\n```\n\n> **Note**: `select` returns a `user` object that includes a `post` array, whereas the fluent API only returns a `post` array.\n\n**Sequelize**\n\n```\nconst user = await User.findByPk(id, {  include: [    {      model: Post,    },  ],})\n```\n\ntip\n\nUse `model: Post as \"Post\"` if you used an alias to define the relationship between `User` and `Post` - for example: `User.hasMany(Post, { as: \"Post\", foreignKey: \"authorId\" });`\n\n### Filtering for concrete values[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#filtering-for-concrete-values \"Direct link to Filtering for concrete values\")\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: {      contains: 'Hello',    },  },})\n```\n\n**Sequelize**\n\n```\nconst post = await Post.findAll({  raw: true,  where: {    title: {      [Op.like]: '%Hello%',    },  },})\n```\n\n### Other filter criteria[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#other-filter-criteria \"Direct link to Other filter criteria\")\n\n**Prisma ORM**\n\nPrisma ORM generates many [additional filters](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting) that are commonly used in modern application development.\n\n**Sequelize**\n\nSequelize has an [extensive set of operators](https://sequelize.org/master/manual/querying.html#operators).\n\n### Relation filters[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#relation-filters \"Direct link to Relation filters\")\n\n**Prisma ORM**\n\nPrisma ORM lets you filter a list based on a criteria that applies not only to the models of the list being retrieved, but to a _relation_ of that model.\n\nFor example, the following query returns users with one or more posts with \"Hello\" in the title:\n\n```\nconst posts = await prisma.user.findMany({  where: {    Post: {      some: {        title: {          contains: 'Hello',        },      },    },  },})\n```\n\n**Sequelize**\n\nSequelize [doesn't offer a dedicated API for relation filters](https://github.com/sequelize/sequelize/issues/10943). You can get similar functionality by sending a raw SQL query to the database.\n\n**Prisma ORM**\n\nCursor-style pagination:\n\n```\nconst page = await prisma.post.findMany({  before: {    id: 242,  },  last: 20,})\n```\n\nOffset pagination:\n\n```\nconst cc = await prisma.post.findMany({  skip: 200,  first: 20,})\n```\n\n**Sequelize**\n\nCursor pagination:\n\n```\nconst posts = await Post.findAll({  limit: 20,  where: {    id: {      [Op.gt]: 242,    },  },})\n```\n\n> **Note**: Sequelize use the [Sequelize operators](https://sequelize.org/docs/v6/core-concepts/model-querying-basics/#operators) to perform cursor pagination.\n\nOffset pagination:\n\n```\nconst posts = await Post.findAll({  offset: 5,  limit: 10,})\n```\n\n### Creating objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#creating-objects \"Direct link to Creating objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.create({  data: {    email: 'alice@prisma.io',  },})\n```\n\n**Sequelize**\n\n*   Using \\`save\\`\n*   Using \\`create\\`\n\n```\nconst user = User.build({  name: 'Alice',  email: 'alice@prisma,io',})await user.save()\n```\n\n### Updating objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#updating-objects \"Direct link to Updating objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.update({  data: {    name: 'Alicia',  },  where: {    id: 2,  },})\n```\n\n**Sequelize**\n\n*   Using \\`save\\`\n*   Using \\`update\\`\n\n```\nuser.name = 'James'user.email = ' alice@prisma.com'await user.save()\n```\n\n### Deleting objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#deleting-objects \"Direct link to Deleting objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.delete({  where: {    id: 10,  },})\n```\n\n**Sequelize**\n\n### Batch updates[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#batch-updates \"Direct link to Batch updates\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.updateMany({  data: {    name: 'Published author!',  },  where: {    email: {      contains: 'prisma.io',    },  },})\n```\n\n**Sequelize**\n\n```\nconst updatedUsers = await User.update({  { role: \"Admin\" },  where: {    email: {      [Op.like]: \"%@prisma.io\"    }  },})\n```\n\n### Batch deletes[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#batch-deletes \"Direct link to Batch deletes\")\n\n**Prisma ORM**\n\n```\nconst users = await prisma.user.deleteMany({  where: {    id: {      in: [1, 2, 6, 6, 22, 21, 25],    },  },})\n```\n\n**Sequelize**\n\n```\nawait User.destroy({  where: {    id: {      [Op.in]: [id1, id2, id3],    },  },})\n```\n\n### Transactions[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-sequelize#transactions \"Direct link to Transactions\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.create({  data: {    email: 'bob.rufus@prisma.io',    name: 'Bob Rufus',    Post: {      create: [        { title: 'Working at Prisma' },        { title: 'All about databases' },      ],    },  },})\n```\n\n**Sequelize**\n\n*   Manual\n*   Automatic\n\n```\nreturn sequelize.$transaction(async (t) => {  const user = await User.create(    {      name: 'Alice',      email: 'alice@prisma,io',    },    {      transaction: t,    }  )  const post1 = await Post.create(    {      title: 'Join us for GraphQL Conf in 2019',    },    {      transaction: t,    }  )  const post2 = await Post.create(    {      title: 'Subscribe to GraphQL Weekly for GraphQL news',    },    {      transaction: t,    }  )  await user.setPosts([post1, post2])})\n```",
  "title": "Prisma ORM vs Sequelize | Prisma Documentation",
  "description": "Learn how Prisma ORM compares to Sequelize.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/development-environment/editor-setup",
  "markdown": "# Editor and IDE setup | Prisma Documentation\n\nThis page describes how you can configure your editor for an optimal developer experience when using Prisma ORM.\n\nIf you don't see your editor here, please [open a feature request](https://github.com/prisma/prisma/issues/new?assignees=&labels=&template=feature_request.md&title=) and ask for dedicated support for your editor (e.g. for syntax highlighting and auto-formatting).\n\nYou can get IDE-style autocompletion for Prisma CLI using [`inshellisense`](https://github.com/microsoft/inshellisense/tree/main). It supports: bash, zsh, fish, pwsh, powershell (Windows Powershell).\n\n```\nnpm install -g @microsoft/inshellisense\n```\n\n`inshellisense` is built on top of [Fig](https://fig.io/) which you can also use directly. It works in bash, zsh, and fish.",
  "title": "Editor and IDE setup | Prisma Documentation",
  "description": "Learn how to configure your editor and IDEs for an optimal developer experience with Prisma ORM.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose",
  "markdown": "# Prisma ORM vs Mongoose | Prisma Documentation\n\nThis page compares the Prisma ORM and [Mongoose](https://mongoosejs.com/docs/guide.html) APIs. If you want to learn how to migrate from Mongoose to Prisma, check out this [guide](https://www.prisma.io/docs/orm/more/migrating-to-prisma/migrate-from-mongoose).\n\n## Fetching single objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#fetching-single-objects \"Direct link to Fetching single objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.findUnique({  where: {    id: 1,  },})\n```\n\n**Mongoose**\n\n```\nconst result = await User.findById(1)\n```\n\n## Fetching selected scalars of single objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#fetching-selected-scalars-of-single-objects \"Direct link to Fetching selected scalars of single objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.findUnique({  where: {    id: 1,  },  select: {    name: true,  },})\n```\n\n**Mongoose**\n\n```\nconst user = await User.findById(1).select(['name'])\n```\n\n## Fetching relations[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#fetching-relations \"Direct link to Fetching relations\")\n\n**Prisma ORM**\n\n*   Using \\`include\\`\n*   Fluent API\n\n```\nconst userWithPost = await prisma.user.findUnique({  where: {    id: 2,  },  include: {    post: true,  },})\n```\n\n**Mongoose**\n\n```\nconst userWithPost = await User.findById(2).populate('post')\n```\n\n## Filtering for concrete values[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#filtering-for-concrete-values \"Direct link to Filtering for concrete values\")\n\n**Prisma ORM**\n\n```\nconst posts = await prisma.post.findMany({  where: {    title: {      contains: 'Hello World',    },  },})\n```\n\n**Mongoose**\n\n```\nconst posts = await Post.find({  title: 'Hello World',})\n```\n\n## Other filter criteria[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#other-filter-criteria \"Direct link to Other filter criteria\")\n\n**Prisma ORM**\n\nPrisma ORM generates many [additional filters](https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting) that are commonly used in modern application development.\n\n**Mongoose**\n\nMongoose exposes the [MongoDB query selectors](https://docs.mongodb.com/manual/reference/operator/query/#query-selectors) as filter criteria.\n\n## Relation filters[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#relation-filters \"Direct link to Relation filters\")\n\n**Prisma ORM**\n\nPrisma ORM lets you filter a list based on a criteria that applies not only to the models of the list being retrieved, but to a _relation_ of that model.\n\nFor example, the following query returns users with one or more posts with \"Hello\" in the title:\n\n```\nconst posts = await prisma.user.findMany({  where: {    Post: {      some: {        title: {          contains: 'Hello',        },      },    },  },})\n```\n\n**Mongoose**\n\nMongoose doesn't offer a dedicated API for relation filters. You can get similar functionality by adding an additional step to filter the results returned by the query.\n\n**Prisma ORM**\n\nCursor-style pagination:\n\n```\nconst page = prisma.post.findMany({  before: {    id: 242,  },  last: 20,})\n```\n\nOffset pagination:\n\n```\nconst cc = prisma.post.findMany({  skip: 200,  first: 20,})\n```\n\n**Mongoose**\n\n```\nconst posts = await Post.find({  skip: 200,  limit: 20,})\n```\n\n## Creating objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#creating-objects \"Direct link to Creating objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.create({  data: {    name: 'Alice',    email: 'alice@prisma.io',  },})\n```\n\n**Mongoose**\n\n*   Using \\`create\\`\n*   Using \\`save\\`\n\n```\nconst user = await User.create({  name: 'Alice',  email: 'alice@prisma.io',})\n```\n\n## Updating objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#updating-objects \"Direct link to Updating objects\")\n\n**Prisma ORM**\n\n```\nconst user = await prisma.user.update({  data: {    name: 'Alicia',  },  where: {    id: 2,  },})\n```\n\n**Mongoose**\n\n*   Using \\`findOneAndUpdate\\`\n*   Using \\`save\\`\n\n```\nconst updatedUser = await User.findOneAndUpdate(  { _id: 2 },  {    $set: {      name: 'Alicia',    },  })\n```\n\n## Deleting objects[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#deleting-objects \"Direct link to Deleting objects\")\n\n**Prisma ORM**\n\n```\nconst user = prisma.user.delete({  where: {    id: 10,  },})\n```\n\n**Mongoose**\n\n```\nawait User.deleteOne({ _id: 10 })\n```\n\n## Batch deletes[​](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-mongoose#batch-deletes \"Direct link to Batch deletes\")\n\n**Prisma ORM**\n\n```\nconst users = await prisma.user.deleteMany({  where: {    id: {      in: [1, 2, 6, 6, 22, 21, 25],    },  },})\n```\n\n**Mongoose**\n\n```\nawait User.deleteMany({ id: { $in: [1, 2, 6, 6, 22, 21, 25] } })\n```",
  "title": "Prisma ORM vs Mongoose | Prisma Documentation",
  "description": "Learn how Prisma ORM compares to Mongoose.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module",
  "markdown": "# Add Prisma ORM Easily to Your Nuxt Apps\n\n## Using the Nuxt Prisma Module\n\nThe Nuxt Prisma module simplifies the integration of Prisma ORM into your Nuxt applications.\n\n[Prisma ORM](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma) is a database library that lets you model your database schema, provides auto-generated migrations and lets you query the database in an intuitive and type-safe way.\n\nThis module provides several features to streamline the setup and usage of Prisma ORM in a Nuxt application, making it easier to interact with your database.\n\n## Features[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#features \"Direct link to Features\")\n\n*   **Project initialization**: Automatically sets up a Prisma ORM project with a SQLite database within your Nuxt project.\n*   **Composable**: Provides an auto-imported `usePrismaClient()` composable for use in your Vue files.\n*   **API route integration**: Automatically imports an instance of `PrismaClient` for use in API routes to query your DB.\n*   **Prisma Studio access**: Enables access to Prisma Studio through Nuxt Devtools for viewing and manually editing data.\n\n## Getting started[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#getting-started \"Direct link to Getting started\")\n\n1.  Create a [new Nuxt Project](https://nuxt.com/docs/getting-started/installation#new-project):\n    \n    ```\n    npx nuxi@latest init test-nuxt-app\n    ```\n    \n2.  Navigate to project directory and install `@prisma/nuxt` using the Nuxt CLI:\n    \n    ```\n    cd test-nuxt-appnpx nuxi@latest module add @prisma/nuxt\n    ```\n    \n3.  Start the development server:\n    \n    Starting the development server will:\n    \n    1.  Automatically install the [Prisma CLI](https://www.prisma.io/docs/orm/reference/prisma-cli-reference)\n    2.  Initialize a Prisma project with SQLite\n    3.  Create an `User` and `Post` example model in the Prisma Schema file:\n        \n        prisma/schema.prisma\n        \n        ```\n         // This is your Prisma schema file, // learn more about it in the docs: https://pris.ly/d/prisma-schema generator client {   provider = \"prisma-client-js\" } datasource db {   provider = \"sqlite\"   url      = env(\"DATABASE_URL\") } model User {   id    Int     @id @default(autoincrement())   email String  @unique   name  String?   posts Post[] } model Post {   id        Int     @id @default(autoincrement())   title     String   content   String?   published Boolean @default(false)   author    User    @relation(fields: [authorId], references: [id])   authorId  Int }\n        ```\n        \n    4.  Prompt you to run a migration to create database tables with [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/overview)\n        \n        note\n        \n        The database migrates automatically the first time you start the module if there isn't a `migrations` folder. After that, you need to run `npx prisma migrate dev` manually in the CLI to apply any schema changes. Running the `npx prisma migrate dev` command manually makes it easier and safer to manage migrations and also to [troubleshoot](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting) any migration-related errors.\n        \n    5.  Install and generate a [Prisma Client](https://www.prisma.io/docs/orm/reference/prisma-client-reference) which enables you to query your DB\n    6.  Prompt you to start the [Prisma Studio](https://www.prisma.io/docs/orm/tools/prisma-studio)\n4.  You can now use Prisma ORM in your project. If you accepted the prompt to add Prisma Studio, you can access Prisma Studio through the Nuxt Devtools. See the [usage section](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#usage) to learn how to use Prisma Client in your app.\n    \n\n## Using a different database provider[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-a-different-database-provider \"Direct link to Using a different database provider\")\n\nThe `@prisma/nuxt` module works with any [database provider that Prisma ORM supports](https://www.prisma.io/docs/orm/reference/supported-databases). You can configure the [getting started example](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#getting-started) to use a database of your choice. The steps would be different for a [database without existing data](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-a-database-without-existing-data) and a [database with pre-existing data](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-a-database-with-pre-existing-data).\n\n### Using a database without existing data[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-a-database-without-existing-data \"Direct link to Using a database without existing data\")\n\nTo configure [the getting started example](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#getting-started) to use a PostgreSQL database without any existing data:\n\n1.  Stop the Nuxt development server and Prisma Studio (if they are still running):\n    \n    ```\n    npx kill-port 3000  # Stops Nuxt dev server (default port)npx kill-port 5555  # Stops Prisma Studio (default port)\n    ```\n    \n2.  Navigate to the `schema.prisma` file and update the `datasource` block to specify the `postgresql` provider:\n    \n    prisma/schema.prisma\n    \n    ```\n    // This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemagenerator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  author    User    @relation(fields: [authorId], references: [id])  authorId  Int}\n    ```\n    \n3.  Update the `DATABASE_URL` environment variable in the `.env` file with your PostgreSQL database URL:\n    \n    .env\n    \n    ```\n    ## This is a sample database URL, please use a valid URLDATABASE_URL=\"postgresql://janedoe:mypassword@localhost:5432/mydb?schema=sample\"\n    ```\n    \n4.  Delete the SQLite database file and the migrations folder:\n    \n    ```\n    rm prisma/dev.db # Delete SQLite database filerm -r prisma/migrations # Delete the pre-existing migrations folder\n    ```\n    \n5.  Run the development server: Starting the development server will prompt you to migrate the schema changes to the database, to which you should agree. Then agree to the prompt to install and access Prisma Studio from the Nuxt Devtools.\n6.  The `@prisma/nuxt` module is ready to use with your PostgreSQL database. See the [usage section](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#usage) to learn how to use Prisma Client in your app.\n\n### Using a database with pre-existing data[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-a-database-with-pre-existing-data \"Direct link to Using a database with pre-existing data\")\n\nTo configure [the getting started example](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#getting-started) to use a PostgreSQL database that already has data in it:\n\n1.  Stop the dev server and Prisma Studio (if they are still running):\n    \n    ```\n    // stops Nuxt dev server from running incase it's still runningnpx kill-port 3000// stops Prisma Studio instance incase it's still runningnpx kill-port 5555\n    ```\n    \n2.  Delete the Prisma folder:\n3.  Update the `DATABASE_URL` environment variable in the `.env` file with your PostgreSQL database URL:\n    \n    .env\n    \n    ```\n    ## This is a sample database URL, please use a valid URLDATABASE_URL=\"postgresql://janedoe:mypassword@localhost:5432/mydb?schema=sample\"\n    ```\n    \n4.  To generate a Prisma Schema and migrations folder from the existing database, you have to [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) the database. Complete **step 1** to **step 4** from the [introspection guide](https://www.prisma.io/docs/orm/prisma-migrate/getting-started#adding-prisma-migrate-to-an-existing-project) and continue.\n5.  Starting the development server will skip the prompt to migrate the schema changes to the database, as the migrations folder already exists. Agree to the prompt to install and access Prisma Studio from the Nuxt Devtools.\n6.  The `@prisma/nuxt` module is ready to be used with your PostgreSQL database. See the [usage section](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#usage) to learn how to use Prisma Client in your app.\n\n## Usage[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#usage \"Direct link to Usage\")\n\n### Option A: `usePrismaClient` composable[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#option-a-useprismaclient-composable \"Direct link to option-a-useprismaclient-composable\")\n\n#### Using the composable in your Nuxt server component[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-the-composable-in-your-nuxt-server-component \"Direct link to Using the composable in your Nuxt server component\")\n\nIf you're using [Nuxt server components](https://nuxt.com/docs/guide/directory-structure/components#server-components), you can use the global instance of the Prisma Client in your `.server.vue` files:\n\n```\n<script setup>  const prisma = usePrismaClient()  const user = await prisma.user.findFirst()</script><template>  <p>{{ user.name }}</p></template>\n```\n\n#### Using the auto-imported Prisma Client instance in your API route[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-the-auto-imported-prisma-client-instance-in-your-api-route \"Direct link to Using the auto-imported Prisma Client instance in your API route\")\n\nYou can use the auto-imported Prisma Client instance, prisma, in your Nuxt API route as follows:\n\n```\nexport default defineEventHandler(async (event) => {  return {    user: await prisma.user.findFirst(),  };});\n```\n\n### Option B: `lib/prisma.ts`[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#option-b-libprismats \"Direct link to option-b-libprismats\")\n\nAfter running through the initial setup prompts, this module creates the `lib/prisma.ts` file which contains a global instance of Prisma Client.\n\nlib/prisma.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prismaClientSingleton = () => {  return new PrismaClient()}declare const globalThis: {  prismaGlobal: ReturnType<typeof prismaClientSingleton>;} & typeof global;const prisma = globalThis.prismaGlobal ?? prismaClientSingleton()export default prismaif (process.env.NODE_ENV !== 'production') globalThis.prismaGlobal = prisma\n```\n\nYou can customize Prisma Client's capabilities by using client extensions in your `lib/prisma.ts` file. Here is an example using the [Pulse client extension](https://www.npmjs.com/package/@prisma/extension-pulse):\n\nlib/prisma.ts\n\n```\nimport { PrismaClient } from '@prisma/client'import { withPulse } from '@prisma/extension-pulse'const prismaClientSingleton = () => {  return new PrismaClient().$extends(withPulse({    apiKey: process.env.PULSE_API_KEY  }))}declare const globalThis: {  prismaGlobal: ReturnType<typeof prismaClientSingleton>;} & typeof global;const prisma = globalThis.prismaGlobal ?? prismaClientSingleton()export default prismaif (process.env.NODE_ENV !== 'production') globalThis.prismaGlobal = prisma\n```\n\n#### Using the global Prisma Client instance in your API route[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-the-global-prisma-client-instance-in-your-api-route \"Direct link to Using the global Prisma Client instance in your API route\")\n\nYou can use the global instance of the Prisma Client in your Nuxt API route as follows:\n\n```\nimport prisma from \"~/lib/prisma\";export default defineEventHandler(async (event) => {  return {    user: await prisma.user.findFirst(),  };});\n```\n\n#### Using the global Prisma Client instance in your Nuxt server component[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#using-the-global-prisma-client-instance-in-your-nuxt-server-component \"Direct link to Using the global Prisma Client instance in your Nuxt server component\")\n\nIf you're using [Nuxt server components](https://nuxt.com/docs/guide/directory-structure/components#server-components), you can use the global instance of the Prisma Client `.server.vue` files:\n\n```\n<script setup>  import prisma from '~/lib/prisma';  const user = await prisma.user.findFirst()</script><template>  <p>{{ user.name }}</p></template>\n```\n\n## Configuration[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#configuration \"Direct link to Configuration\")\n\nYou can configure the `@prisma/nuxt` module by using the `prisma` key in `nuxt.config.ts`:\n\nnuxt.config.ts\n\n```\nexport default defineNuxtConfig({  // ...  prisma: {    // Options  }})\n```\n\n  \n\nnote\n\nThe `prisma` key is available in `nuxt.config.ts` after successfully setting up the module by running `npm run dev`\n\n| Option | Type | Default | Description |\n| --- | --- | --- | --- |\n| **installCLI** | `boolean` | true | Whether to install the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli). |\n| **installClient** | `boolean` | true | Whether to install the [Prisma Client](https://www.prisma.io/docs/orm/prisma-client) library in the project. |\n| **generateClient** | `boolean` | true | Whether to [generate](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client) the `PrismaClient` instance. Executes `npx prisma generate` on every run to update the client based on the schema changes. |\n| **formatSchema** | `boolean` | true | Whether to [format](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#format) the [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file. |\n| **installStudio** | `boolean` | true | Whether to install and start [Prisma Studio](https://www.prisma.io/studio) in the Nuxt Devtools. |\n| **autoSetupPrisma** | `boolean` | false | Whether to skip all prompts during setup. This option is useful for automating Prisma setup in scripts or CI/CD pipelines. |\n\n## Limitations[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#limitations \"Direct link to Limitations\")\n\n### `PrismaClient` constructor options are not configurable in the `usePrismaClient` composable[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#prismaclient-constructor-options-are-not-configurable-in-the-useprismaclient-composable \"Direct link to prismaclient-constructor-options-are-not-configurable-in-the-useprismaclient-composable\")\n\nThe `usePrismaClient` module does not currently allow for configuration of `PrismaClient` [constructor options](https://www.prisma.io/docs/orm/reference/prisma-client-reference#prismaclient).\n\n### The `usePrismaClient` composable is not supported in edge runtimes[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/prisma-nuxt-module#the-useprismaclient-composable-is-not-supported-in-edge-runtimes \"Direct link to the-useprismaclient-composable-is-not-supported-in-edge-runtimes\")\n\nThe `usePrismaClient` composable currently relies on a `PrismaClient` instance that does not work in edge runtimes. If you require edge support for the composable, please let us know on [Discord](https://pris.ly/discord) or [GitHub](https://github.com/prisma/nuxt-prisma).",
  "title": "Add Prisma ORM Easily to Your Nuxt Apps | Prisma Documentation",
  "description": "Learn how to easily add Prisma ORM to your Nuxt apps, use its features, and understand its limitations.",
  "languageCode": "en"
},
{
  "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta",
  "markdown": "# Upgrade from the Prisma 1 MongoDB Beta to Prisma ORM 2 or later\n\n## Introduction[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#introduction \"Direct link to Introduction\")\n\nThis guide helps you migrate from the Prisma 1 MongoDB Beta to MongoDB on Prisma ORM 2 or later. To learn more about the differences between Prisma 1 and Prisma ORM 2.x and later, refer to [this document](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#main-differences-between-prisma-1-and-prisma-orm-version-2x-and-later).\n\nThe scope of this guide is to give you the workflow necessary to perform the migration and highlight some of the problems you might encounter.\n\nWe unfortunately can't cover all possible scenarios or changes required, but this guide should help you on your journey. Join [our Discord](https://pris.ly/discord) or create an issue [on Github](https://github.com/prisma/prisma1/issues/new/choose) with any questions.\n\nwarning\n\nPerform this migration on your staging environment before trying this in production!\n\n## Requirements[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#requirements \"Direct link to Requirements\")\n\n*   Must be running MongoDB 4.2+ as a replica set (MongoDB Atlas does this for you automatically)\n*   Node.js: see [system requirements](https://www.prisma.io/docs/orm/reference/system-requirements)\n*   TypeScript: see [system requirements](https://www.prisma.io/docs/orm/reference/system-requirements)\n\n## Installing Prisma ORM 3.12.0 or later[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#installing-prisma-orm-3120-or-later \"Direct link to Installing Prisma ORM 3.12.0 or later\")\n\nIn your project directory run the following commands:\n