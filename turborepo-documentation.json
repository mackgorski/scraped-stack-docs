[{
  "url": "https://turbo.build/repo/docs",
  "markdown": "# Introduction | TurborepoTurborepoTurborepoTurborepoVercel\n\nWelcome to the Turborepo documentation!\n\n* * *\n\nTurborepo is a high-performance build system for JavaScript and TypeScript codebases. It is designed for scaling monorepos and also makes workflows in [single-package workspaces](https://turbo.build/repo/docs/guides/single-package-workspaces) faster, too.\n\nFrom individual developers to the largest enterprise engineering organizations in the world, Turborepo is saving years of engineering time and millions of dollars in compute costs through a lightweight approach to optimizing the tasks you need to run in your repository.\n\nMonorepos have many advantages - but **they struggle to scale**. Each workspace has its own test suite, its own linting, and its own build process. A single monorepo might have **thousands of tasks to execute**.\n\n![A representation of a typical monorepo. The first application took 110 seconds to complete its tasks. The second application took 140 seconds to complete its tasks. The shared package between them took 90 seconds to complete its tasks.](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fwhy-turborepo-problem.02c393fb.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nThese slowdowns can dramatically affect the way your teams build software, especially at scale. Feedback loops need to be fast so developers can deliver high-quality code quickly.\n\n![The monorepo from before using Turborepo, showing how it can hit cache to complete tasks for all three packages in 80 milliseconds.](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fwhy-turborepo-solution.02448c98.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\n**Turborepo solves your monorepo's scaling problem**. [Remote Cache](https://turbo.build/repo/docs/core-concepts/remote-caching) stores the result of all your tasks, meaning that **your CI never needs to do the same work twice**.\n\nAdditionally, task scheduling can be difficult in a monorepo. You may need to build, _then_ test, _then_ lint...\n\nTurborepo **schedules your tasks for maximum speed**, parallelizing work across all available cores.\n\nTurborepo can be **adopted incrementally** and you can **add it to any repository in just a few minutes**. It uses the `package.json` scripts you've already written, the dependencies you've already declared, and a single `turbo.json` file. You can **use it with any package manager**, like `npm`, `yarn` or `pnpm` since Turborepo leans on the conventions of the npm ecosystem.\n\nWe will do our best to keep jargon to a minimum - but there are some need-to-know words that will be important to understand as you read through the docs. We've created [a glossary page](https://vercel.com/docs/vercel-platform/glossary) to help you out in case you're learning about these terms.\n\nIf you have questions about anything related to Turborepo, you're always welcome to ask the community on [GitHub Discussions](https://github.com/vercel/turbo/discussions), [Discord](https://turbo.build/discord), and [Twitter](https://twitter.com/turborepo).",
  "title": "Introduction | Turborepo",
  "description": "Welcome to the Turborepo documentation!",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/multi-language",
  "markdown": "# Multi-language support | TurborepoTurborepoTurborepoTurborepoVercel\n\nTurborepo is built on the conventions of the JavaScript ecosystem to find scripts and tasks to execute - but it doesn't care what those scripts do. Following [the guidance for specifying a package in a JavaScript workspace](https://turbo.build/repo/docs/crafting-your-repository/structuring-a-repository#specifying-packages-in-a-monorepo), you can add any other language or toolchain to Turborepo.\n\nAs an example, you may have a Rust project in the `./cli` directory in your repository. To add this directory as a package to your JavaScript package manager's workspace, add the directory to the workspace definition:\n\nThen, add a `package.json` to the directory:\n\n./cli/package.json\n\nNow, when you use `turbo build`, the `\"build\"` script in `./cli/package.json` will be included into the tasks that `turbo` runs.\n\nEnsure that the outputs for your builds are being cached with [the outputs key](https://turbo.build/repo/docs/reference/configuration#outputs) in `turbo.json`. In the case of a Rust CLI being compiled with cargo, a release build would be created in the `target/release` directory and we can cache it using:\n\n./turbo.json\n\nBecause the directory is now a part of the package manager's workspace, you can create dependencies exactly the same as you do for your JavaScript packages.\n\nFor instance, if you wanted to make sure that the `rust-cli` \"package\" from above is built before your `web` application, install it into the dependencies for the `web` application:\n\nGiven a `turbo.json` with a `build` task like:\n\n./turbo.json\n\n`turbo build` will first create the artifacts for the Rust CLI and then build the `web` application.",
  "title": "Multi-language support | Turborepo",
  "description": "Learn how to use multiple languages with Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/handling-platforms",
  "markdown": "# Handling platforms | TurborepoTurborepoTurborepoTurborepoVercel\n\nTo account for Node.js versions, use [the engines key in package.json](https://docs.npmjs.com/cli/v10/configuring-npm/package-json#engines). Turborepo will account for changes to this field and miss cache accordingly.\n\nFor advanced use cases, you may want the operating system (OS), architecture, or other external factors to contribute to your hash.\n\n### [1\\. Write an arbitrary file to disk](#1-write-an-arbitrary-file-to-disk)\n\nFirst, create a script that accounts for the hash contributors that you are interested in. For example, here is a Node.js script that identifies platform and architecture and writes those details to a file (`turbo-cache-key.json`):\n\n./scripts/create-turbo-cache-key.js\n\n### [2\\. Add the file to your .gitignore](#2-add-the-file-to-your-gitignore)\n\nYou won't want to commit this file to source control since it's dependent on environment. Add it to your `.gitignore`:\n\n.gitignore\n\n### [3\\. Add the file to the hash](#3-add-the-file-to-the-hash)\n\nNow, make sure that `turbo` is aware of the file by adding it to task inputs. You can do this two ways:\n\n*   **For specific tasks**: Include the file in [the `inputs` array](https://turbo.build/repo/docs/reference/configuration#inputs) of the task(s):\n\n./turbo.json\n\n*   **For all tasks**: Add the file to [`globalDependencies`](https://turbo.build/repo/docs/reference/configuration#globaldependencies)\n\n./turbo.json\n\n### [4\\. Generate the file before running `turbo`](#4-generate-the-file-before-running-turbo)\n\nLast, you'll want to ensure that you run the script before running `turbo`. For example:\n\n./package.json\n\n`turbo run build` will now take into account the contents of `turbo-cache-key.json` when calculating the hash for the `build` task.",
  "title": "Handling platforms | Turborepo",
  "description": "Learn how to handle caching around operating systems, architectures, and other arbitrary conditions for Turborepo tasks.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/community",
  "markdown": "# Community | TurborepoTurborepoTurborepoTurborepoVercel\n\nWith over 2 million weekly downloads, Turborepo has a large and active community of developers across the world. Here's how you can get involved.\n\n*   [Documentation](https://github.com/vercel/turbo/tree/main/docs): Suggest improvements or even write new sections to help build understanding of how to use Turborepo.\n*   [Examples](https://github.com/vercel/turbo/tree/main/examples): Help developers integrate Turborepo with other tools and services by improving an example.\n*   [Code](https://github.com/vercel/turbo/blob/main/CONTRIBUTING.md): Learn more about the underlying architecture, contribute bug fixes, and suggest new features.\n\nIf you have a question about Turborepo or want to help others, join the conversation:\n\n*   [GitHub Discussions](https://github.com/vercel/turbo/discussions)\n*   [Discord](https://turbo.build/discord)\n\nTurborepo was originally created by [Jared Palmer](https://x.com/jaredpalmer) as a closed-source enterprise software offering. In late 2021, [Vercel acquired Turborepo](https://vercel.com/blog/vercel-acquires-turborepo) and open sourced the codebase.\n\nToday, Turborepo has dedicated full-time team working on it as well as a growing list of [open source contributors](https://github.com/vercel/turbo/graphs/contributors).\n\n### [Inspiration / Prior Art](#inspiration--prior-art)\n\nAt [Vercel](https://vercel.com/), we believe deeply in the open source movement and in the power of open collaboration. To that end, it's important to provide meaningful attribution to the projects and people that inspire(d) us and our work.\n\nWe'd like to make a special shoutout to other build systems, monorepo tools, and prior art:\n\n*   Bazel - [https://bazel.build](https://bazel.build/)\n*   Buck - [https://buck.build](https://buck.build/)\n*   Please - [https://please.build](https://please.build/)\n*   Pants - [https://www.pantsbuild.org](https://www.pantsbuild.org/)\n*   Scoot - [https://github.com/twitter/scoot](https://github.com/twitter/scoot)\n*   TSDX - [https://tsdx.io](https://tsdx.io/)\n*   Lerna - [https://lerna.js.org](https://lerna.js.org/)\n*   Lage - [https://microsoft.github.io/lage](https://microsoft.github.io/lage)\n*   Backfill - [https://github.com/microsoft/backfill](https://github.com/microsoft/backfill)\n*   Bolt - [https://github.com/boltpkg/bolt](https://github.com/boltpkg/bolt)\n*   Rush - [https://rushjs.io](https://rushjs.io/)\n*   Preconstruct - [https://preconstruct.tools](https://preconstruct.tools/)\n*   Nx - [https://nx.dev](https://nx.dev/)\n*   Yarn - [https://yarnpkg.com](https://yarnpkg.com/)\n*   npm - [https://www.npmjs.com](https://www.npmjs.com/)\n*   pnpm - [https://pnpm.js.org](https://pnpm.js.org/)\n\n### [Additional Thanks](#additional-thanks)\n\nAdditionally, we're grateful to:\n\n*   [Rick Button](https://x.com/rickbutton) for donating the `turbo` package name on npm\n*   [Iheanyi Ekechukwu](https://x.com/kwuchu) for helping Jared pick up Golang during the Pandemic!\n*   [Kenneth Chau](https://x.com/kenneth_chau) for Lage's Scope and Pipeline API and docs\n*   [Miguel Oller](https://mobile.x.com/ollermi) and [MakeSwift.com](https://www.makeswift.com/) for piloting Turborepo\n*   [Eric Koslow](https://x.com/ekosz1), [Jack Hanford](https://x.com/jackhanford), and [Lattice.com](https://lattice.com/) for piloting Turborepo",
  "title": "Community | Turborepo",
  "description": "Learn about the Turbo community.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/telemetry",
  "markdown": "# Telemetry | TurborepoTurborepoTurborepoTurborepoVercel\n\nVercel Inc. (Vercel) may collect telemetry data about your use of Turborepo as explained below. Telemetry data allows us to monitor and improve Turborepo and the Vercel platform by collecting anonymous data about its usage and host information. The data may be used to broadly identify, troubleshoot, or respond to issues that impact users.\n\nCollection of telemetry data is optional. If you do not want telemetry data collected, you may [opt-out](#how-do-i-opt-out).\n\nTelemetry allows us to accurately gauge Turborepo feature usage, pain points, and customization across all users. This data enables us to better tailor Turborepo to the masses, ensuring its continued growth, relevance, and best-in-class developer experience. Furthermore, this data allows us to verify if improvements are improving the baseline of all applications.\n\nWe track general usage information, specifically, we track the following with anonymized telemetry data using random identifiers:\n\n*   Command invoked ([turbo run](https://turbo.build/repo/docs/reference/run), [turbo prune](https://turbo.build/repo/docs/reference/prune), [turbo gen](https://turbo.build/repo/docs/reference/generate), etc.)\n*   Version of `turbo`\n*   General machine information (e.g. number of CPUs, macOS/Windows/Linux, whether or not the command was run within CI)\n*   Size of application (total number of workspaces)\n*   We **DO NOT** collect any metrics which may contain sensitive data. This includes, but is not limited to: task names, package names, sensitive argument or flag values, environment variables, file paths, or contents of files.\n\n**Note**: This list is regularly audited to ensure its accuracy.\n\nYou can view exactly what is being collected by setting the following environment variable: `TURBO_TELEMETRY_DEBUG=1`.\n\nAdditionally, all possible events can be viewed by browsing the [events](https://github.com/vercel/turbo/blob/main/crates/turborepo-telemetry/src/events) file directly.\n\n### [Disable](#disable)\n\nYou may opt out-by running:\n\nTerminal\n\nYou can also opt out by setting any of the following environment variables:\n\n*   `TURBO_TELEMETRY_DISABLED=1`\n*   `DO_NOT_TRACK=1` (Learn more about [Console Do Not Track (DNT)](https://consoledonottrack.com/))\n\n### [Status](#status)\n\nYou may check the status of telemetry collection at any time by running:\n\nTerminal\n\n### [Enable](#enable)\n\nYou may re-enable telemetry if you'd like to re-join the program by running the following:\n\nTerminal",
  "title": "Telemetry | Turborepo",
  "description": "Learn more about Turborepo's anonymous telemetry.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/login",
  "markdown": "# login | TurborepoTurborepoTurborepoTurborepoVercel\n\nLog in to your Remote Cache provider.\n\nThe default provider is [Vercel](https://vercel.com/). To specify a different provider, use the `--api` option.\n\n## [Flag options](#flag-options)\n\n### [\\--api <url>](#--api-url)\n\nSet the API URL of the Remote Cache provider.\n\nTerminal\n\n```\nturbo login --api=https://acme.com/api\n```\n\n### [\\--login <url>](#--login-url)\n\nSet the URL for login requests. This is only required for platforms with robust login features.\n\nTerminal\n\n```\nturbo login --login=https://acme.com\n```\n\n### [\\--sso-team <team>](#--sso-team-team)\n\nConnect to an SSO-enabled team by providing your team slug.\n\nTerminal\n\n```\nturbo login --sso-team=slug-for-team\n```",
  "title": "login | Turborepo",
  "description": "API reference for the `turbo login` command",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/scan",
  "markdown": "# scan | TurborepoTurborepoTurborepoTurborepoVercel\n\nEnable faster tooling for your Turborepo locally with one, interactive command.\n\nYou'll be taken through a short series of steps to enable the fastest settings for your Turborepo. These optimizations include:\n\n*   **Git FS Monitor**: `turbo` leans on Git to do file change discovery. Since we have to wait for `git` to tell us about changes, we can use [Git's built-in filesystem monitor](https://git-scm.com/docs/git-fsmonitor--daemon) to get those notifications sooner.\n*   **Turbo Daemon**: Turborepo's daemon optimistically understands your repository in the background. By doing shared, common work that `turbo` will need to do when running tasks beforehand, `turbo` will run your tasks faster.\n*   **Remote Caching**: While Turborepo can cache your work locally, it can also share a cache across all of your machines. Enabling [Remote Caching](https://turbo.build/repo/docs/core-concepts/remote-caching) makes your caching **multiplayer**, ensuring that you, your teammates, and your CI machines, never do the same work twice.\n*   **Check `turbo` version**: We're always working towards making `turbo` better. To ensure you are using the latest version of Turborepo, we'll check your version and remind you to install `latest` if you aren't using it yet.\n*   **Check for Turborepo LSP**: Visit the [VSCode Extension Marketplace](https://marketplace.visualstudio.com/items?itemName=Vercel.turbo-vsc) and install the Turborepo LSP extension for your IDE.",
  "title": "scan | Turborepo",
  "description": "API reference for the `turbo scan` command",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/logout",
  "markdown": "# logout | TurborepoTurborepoTurborepoTurborepoVercel\n\n[API reference](https://turbo.build/repo/docs/reference)\n\nLog out of the account associated with your Remote Cache provider.\n\nWas this helpful?\n\nsupported.\n\n[\n\nPrevious\n\nlogin\n\n](https://turbo.build/repo/docs/reference/login)[\n\nNext\n\nlink\n\n](https://turbo.build/repo/docs/reference/link)\n\n[\n\nhours\n\nTotal Compute Saved\n\nGet started with  \nRemote Caching →\n\n\n\n](https://turbo.build/repo/docs/core-concepts/remote-caching)\n\n### On this page\n\nNo Headings",
  "title": "logout | Turborepo",
  "description": "API reference for the `turbo logout` command",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/getting-started",
  "markdown": "# Getting started | TurborepoTurborepoTurborepoTurborepoVercel\n\nIf you're new to Turborepo, you can follow these steps to get started.\n\nInstall `turbo` globally so you can conveniently run `turbo` commands in your terminal from anywhere in your repository.\n\nTo learn more about installing `turbo`, see the [installation guide](https://turbo.build/repo/docs/getting-started/installation).",
  "title": "Getting started | Turborepo",
  "description": "Get started with Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/link",
  "markdown": "# link | TurborepoTurborepoTurborepoTurborepoVercel\n\nLink the repository to a Remote Cache provider.\n\nThe selected owner (either a user or an organization) will be able to share [cache artifacts](https://turbo.build/repo/docs/core-concepts/remote-caching) through [Remote Caching](https://turbo.build/repo/docs/core-concepts/remote-caching).\n\n### [`--api <url>`](#--api-url)\n\nSpecifies the URL to logout of your Remote Cache provider.\n\nTerminal",
  "title": "link | Turborepo",
  "description": "API reference for the `turbo link` command",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/getting-started/installation",
  "markdown": "# Installation | TurborepoTurborepoTurborepoTurborepoVercel\n\nGet started with Turborepo in a few moments using:\n\nThe starter repository will have:\n\n*   Two deployable applications\n*   Three shared libraries for use in the rest of the monorepo\n\nFor more details on the starter, [visit the README for the basic starter on GitHub](https://github.com/vercel/turbo/tree/main/examples/basic). You can also [use an example](https://turbo.build/repo/docs/getting-started/installation#start-with-an-example) that more closely fits your tooling interests.\n\n`turbo` can be installed both globally **and** in your repository. We highly recommend installing both ways so you can take advantage of fast, convenient workflows _and_ a stable version of `turbo` for all developers working in your repository.\n\n### [Global installation](#global-installation)\n\nA global install of `turbo` brings flexibility and speed to your local workflows.\n\nOnce installed globally, you can run your scripts through `turbo` from your terminal, quickly running one-off commands to use within your repository. For example:\n\n*   `turbo build`: Run `build` scripts following your repository's dependency graph\n*   `turbo build --filter=docs --dry`: Quickly print an outline of the `build` task for your `docs` package (without running it)\n*   `turbo generate`: Run [Generators](https://turbo.build/repo/docs/guides/generating-code) to add new code to your repository\n*   `cd apps/docs && turbo build`: Run the `build` script in the `docs` package and its dependencies. For more, visit the [Automatic Package Scoping section](https://turbo.build/repo/docs/crafting-your-repository/running-tasks#automatic-package-scoping).\n\nGood to know:\n\n`turbo` is an alias for [`turbo run`](https://turbo.build/repo/docs/reference/run). For example, `turbo build` and `turbo run build` will both run your `build` task.\n\nAvoid multiple global installations\n\nIf you've installed global `turbo` before, make sure you use the same package manager as your existing installation to avoid unexpected behaviors. You can quickly check which package manager you previously used with [`turbo bin`](https://turbo.build/repo/docs/reference/bin).\n\n#### [Using global `turbo` in CI](#using-global-turbo-in-ci)\n\nYou can also take advantage of global `turbo` when creating your CI pipelines. Visit the [Constructing CI](https://turbo.build/repo/docs/crafting-your-repository/constructing-ci#global-turbo-in-ci) guide for more information.\n\n### [Repository installation](#repository-installation)\n\nWhen collaborating with other developers in a repository, it's a good idea to pin versions of dependencies. You can do this with `turbo` by adding it as a `devDependency` in the root of your repository:\n\nYou can continue to use your global installation of `turbo` to run commands. Global `turbo` will defer to the local version of your repository if it exists.\n\nThis lets you to get the best of both installations: easily run commands in your terminal while maintaining a pinned version for consistent usage for all developers in the repository.\n\nThe community curates a set of examples to showcase ways to use common tools and libraries with Turborepo. To bootstrap your monorepo with one of the examples, use the `--example` flag:\n\nUse any of the example's names below:\n\n| Name | Description |\n| --- | --- |\n| [basic](https://github.com/vercel/turbo/tree/main/examples/basic) | Minimal Turborepo example for learning the fundamentals. |\n| [design-system](https://github.com/vercel/turbo/tree/main/examples/design-system) | Unify your site's look and feel by sharing a design system across multiple apps. |\n| [kitchen-sink](https://github.com/vercel/turbo/tree/main/examples/kitchen-sink) | Want to see a more in-depth example? Includes multiple frameworks, both frontend and backend. |\n| [non-monorepo](https://github.com/vercel/turbo/tree/main/examples/non-monorepo) | Example of using Turborepo in a single project without workspaces |\n| [with-changesets](https://github.com/vercel/turbo/tree/main/examples/with-changesets) | Simple Next.js monorepo preconfigured to publish packages via Changesets |\n| [with-docker](https://github.com/vercel/turbo/tree/main/examples/with-docker) | Monorepo with an Express API and a Next.js App deployed with Docker utilizing turbo prune |\n| [with-gatsby](https://github.com/vercel/turbo/tree/main/examples/with-gatsby) | Monorepo with a Gatsby.js and a Next.js app both sharing a UI Library |\n| [with-prisma](https://github.com/vercel/turbo/tree/main/examples/with-prisma) | Monorepo with a Next.js App fully configured with Prisma |\n| [with-react-native-web](https://github.com/vercel/turbo/tree/main/examples/with-react-native-web) | Simple React Native & Next.js monorepo with a shared UI library |\n| [with-rollup](https://github.com/vercel/turbo/tree/main/examples/with-rollup) | Monorepo with a single Next.js app sharing a UI library bundled with Rollup |\n| [with-svelte](https://github.com/vercel/turbo/tree/main/examples/with-svelte) | Monorepo with multiple SvelteKit apps sharing a UI Library |\n| [with-tailwind](https://github.com/vercel/turbo/tree/main/examples/with-tailwind) | Monorepo with multiple Next.js apps sharing a UI Library all using Tailwind CSS with a shared config |\n| [with-vite](https://github.com/vercel/turbo/tree/main/examples/with-vite) | Monorepo with multiple Vanilla JS apps bundled with Vite, sharing a UI Library |\n| [with-vue-nuxt](https://github.com/vercel/turbo/tree/main/examples/with-vue-nuxt) | Monorepo with Vue and Nuxt, sharing a UI Library |",
  "title": "Installation | Turborepo",
  "description": "Learn how to get started with Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/bin",
  "markdown": "# bin | TurborepoTurborepoTurborepoTurborepoVercel\n\nGet the path to the `turbo` binary.\n\nWhen using [**global `turbo`**](https://turbo.build/repo/docs/getting-started/installation#installing-globally), this will be the path to the global `turbo` binary. You're likely to see a path to the global directory of the package manager you used to install `turbo`.\n\nWhen using [**local `turbo`**](https://turbo.build/repo/docs/getting-started/installation#installing-per-repository), this will be the path to the local `turbo` binary. When `turbo` is installed in your repository, it is likely to be a path to `node_modules`.",
  "title": "bin | Turborepo",
  "description": "API reference for the `turbo bin` command",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/unlink",
  "markdown": "# unlink | TurborepoTurborepoTurborepoTurborepoVercel\n\n[API reference](https://turbo.build/repo/docs/reference)\n\nDisconnect the repository from Remote Cache.\n\nWas this helpful?\n\nsupported.\n\n[\n\nPrevious\n\nlink\n\n](https://turbo.build/repo/docs/reference/link)[\n\nNext\n\nbin\n\n](https://turbo.build/repo/docs/reference/bin)\n\n[\n\nhours\n\nTotal Compute Saved\n\nGet started with  \nRemote Caching →\n\n\n\n](https://turbo.build/repo/docs/core-concepts/remote-caching)\n\n### On this page\n\nNo Headings",
  "title": "unlink | Turborepo",
  "description": "API reference for the `turbo unlink` command",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/getting-started/add-to-existing-repository",
  "markdown": "# Add to an existing repository\n\nTurborepo can be incrementally adopted in **any repository, single or multi-package**, to speed up the developer and CI workflows of the repository.\n\nAfter installing `turbo` and configuring your tasks in `turbo.json`, you'll notice how [caching](https://turbo.build/repo/docs/crafting-your-repository/caching) helps you run tasks much faster.\n\nA [single-package workspace](https://vercel.com/docs/vercel-platform/glossary#single-package-workspace) is, for example, what you get after running `npx create-next-app` or `npm create vite`. You don't need to do any extra work for Turborepo to handle your repo so you can jump to the first step below.\n\nTo learn more about Turborepo in single-package workspaces, visit [the dedicated guide](https://turbo.build/repo/docs/guides/single-package-workspaces).\n\n`turbo` is built on top of Workspaces, a feature of the major package managers in the JavaScript ecosystem. This makes it easy to adopt in your existing codebase.\n\nGood to know:\n\nIf you're finding that `turbo` is having issues like not being able to discover packages in your workspace or not following your dependency graph, visit our [Structuring a repository](https://turbo.build/repo/docs/crafting-your-repository/structuring-a-repository) page for tips.\n\nNote that you don't have to start running _all_ your tasks for _all_ your packages using `turbo` right away. You can start with a single task in just a few packages and incrementally add more tasks and packages as you get more familiar with Turborepo.\n\n### [Install `turbo`](#install-turbo)\n\nWe recommend you install `turbo` both globally and into your repository's root for the best developer experience.\n\nTo learn more about why we recommend both installations, visit the [Installation page](https://turbo.build/repo/docs/getting-started/installation).\n\n### [Add a `turbo.json` file](#add-a-turbojson-file)\n\nIn the root of your repository, create a `turbo.json` file.\n\nWe'll be using `build` and `check-types` tasks in this guide but you can replace these with other tasks that interest you, like `lint` or `test`.\n\nIn a multi-package workspace, you may also want to add a `check-types` script to one or more of your library packages to see how multiple scripts across different packages run with one `turbo` command.\n\n### [Edit `.gitignore`](#edit-gitignore)\n\nAdd `.turbo` to your `.gitignore` file. The `turbo` CLI uses these folders for persisting logs, outputs, and other functionality.\n\n.gitignore\n\n### [Run the `build` and `check-types` tasks with `turbo`](#run-the-build-and-check-types-tasks-with-turbo)\n\nTerminal\n\nThis runs `build` and `check-types` at the same time.\n\n**Without making any changes to the code, try running `build` and `check-types` again:**\n\nTerminal\n\nYou should see terminal output like this:\n\nTerminal\n\nCongratulations! **You just built and type checked your code in milliseconds**.\n\nTo learn more about how `turbo` makes this possible, check out [the caching documentation](https://turbo.build/repo/docs/crafting-your-repository/caching).\n\n### [Begin developing by running `dev` with `turbo`](#begin-developing-by-running-dev-with-turbo)\n\nIn a multi-package workspace, you can run `turbo dev` to start the development tasks for all your packages at once.\n\nTerminal\n\nYou can also [use a filter](https://turbo.build/repo/docs/crafting-your-repository/running-tasks#using-filters) to focus on a specific package and its dependencies.\n\nNote that this step doesn't provide much value in a single-package workspace since:\n\n*   You don't cache the outputs for a development task.\n*   There's only one development script so there's nothing to run in parallel.",
  "title": "Add to an existing repository | Turborepo",
  "description": "Using Turborepo with your existing repository",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/getting-started/editor-integration",
  "markdown": "# Editor integration | TurborepoTurborepoTurborepoTurborepoVercel\n\nTo get the best experience with `turbo`, Turborepo provides a few utilities for integrating with your editor.\n\nTurborepo uses [JSON Schema](https://json-schema.org/) to give you auto-complete in your `turbo.json` file. By including the `$schema` key in your `turbo.json`, your editor is able to provide full documentation and linting in case you have invalid shapes or missing keys.\n\n./turbo.json\n\n### [Older versions](#older-versions)\n\nIf you are using Turborepo v1, use `schema.v1.json`.\n\n./turbo.json\n\nHandling environment variables is an important part of building applications in a Turborepo.\n\n[The `eslint-config-turbo` package](https://turbo.build/repo/docs/reference/eslint-config-turbo) extends your ESLint setup to help you make sure you've taken care of all of your environment variables.\n\nEnable even more auto-complete and linting than provided by JSON Schema, with in-editor hinting for invalid globs, references to non-existent tasks or packages, and extra repository visibility tools.\n\nVisit the [VSCode Extension Marketplace](https://marketplace.visualstudio.com/items?itemName=Vercel.turbo-vsc) to install.",
  "title": "Editor integration | Turborepo",
  "description": "Making the most of Turborepo",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/telemetry",
  "markdown": "# telemetry | TurborepoTurborepoTurborepoTurborepoVercel\n\n`turbo telemetry [argument]`\n\nManage telemetry for this machine.\n\n[→](https://turbo.build/repo/docs/telemetry)\n\n[Learn more about Turborepo's telemetry.](https://turbo.build/repo/docs/telemetry)\n\n## [Arguments](#arguments)\n\n### [`status`](#status)\n\nRetrieve the current state of telemetry for this machine.\n\nTerminal\n\n```\nturbo telemetry status\n```\n\n### [`enable`](#enable)\n\nEnable telemetry for this machine.\n\nTerminal\n\n```\nturbo telemetry enable\n```\n\n### [`disable`](#disable)\n\nDisable telemetry for this machine.\n\nTerminal\n\n```\nturbo telemetry disable\n```",
  "title": "telemetry | Turborepo",
  "description": "API reference for the `turbo telemetry` command",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/create-turbo",
  "markdown": "# create-turbo | TurborepoTurborepoTurborepoTurborepoVercel\n\n```\n-m, --package-manager to use (choices: \"npm\", \"yarn\", \"pnpm\", \"bun\")\n\n--skip-install: Do not run a package manager install after creating the project (Default: false)\n\n--skip-transforms: Do not run any code transformation after creating the project (Default: false)\n\n--turbo-version <version>: Use a specific version of turbo (default: latest)\n\n-e, --example [name]|[github-url]: An example to bootstrap the app with. You can use an example name from the official Turborepo repo or a GitHub URL. The URL can use any branch and/or subdirectory\n\n-p, --example-path <path-to-example>: In a rare case, your GitHub URL might contain a branch name with a slash (e.g. bug/fix-1) and the path to the example (e.g. foo/bar). In this case, you must specify the path to the example separately: --example-path foo/bar\n\n-v, --version:  Output the current version\n\n-h, --help: Display help for command\n```",
  "title": "create-turbo | Turborepo",
  "description": "Quickly set up a new Turborepo repository from scratch.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/crafting-your-repository",
  "markdown": "# Crafting your repository | TurborepoTurborepoTurborepoTurborepoVercel\n\nArchitecting a monorepo is a careful process. Through these guides, you'll learn how to design and build a monorepo that will make every team faster - no matter the size.\n\nThe guides in this section will take you through building a multi-package workspace, commonly referred to as a monorepo. They are meant to be read in order as they build on top of the knowledge from previous guides, but you can read them in any order or skip to the pages specific to your use case.\n\nBy the time you've read through all of this section, you should have a good understanding of how to design and build a monorepo with Turborepo.\n\nTurborepo can also be used to speed up single-package workspaces. Visit the [single-package workspace](https://turbo.build/repo/docs/guides/single-package-workspaces) section for more information.\n\nWe also have more guides centered around [specific tools, use cases, and other topics](https://turbo.build/repo/docs/guides).",
  "title": "Crafting your repository | Turborepo",
  "description": "Design and build your Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/crafting-your-repository/structuring-a-repository",
  "markdown": "# Structuring a repository | TurborepoTurborepoTurborepoTurborepoVercel\n\n`turbo` is built on top of [Workspaces](https://vercel.com/docs/vercel-platform/glossary#workspace), a feature of package managers in the JavaScript ecosystem that allows you to group multiple packages in one repository.\n\nFollowing these conventions is important because it allows you to:\n\n*   Lean on those conventions for all your repo's tooling\n*   Quickly, incrementally adopt Turborepo into an existing repository\n\nIn this guide, we'll walk through setting up a multi-package workspace (monorepo) so we can set the groundwork for `turbo`.\n\nSetting up a workspace's structure can be tedious to do by hand. If you're new to monorepos, we recommend [using `create-turbo` to get started](https://turbo.build/repo/docs/getting-started/installation) with a valid workspace structure right away.\n\nTerminal\n\nYou can then review the repository for the characteristics described in this guide.\n\nIn JavaScript, a workspace can either be [a single package](https://turbo.build/repo/docs/guides/single-package-workspaces) or a collection of packages. In these guides, we'll be focusing on [a multi-package workspace](https://vercel.com/docs/vercel-platform/glossary#monorepo), often called a \"monorepo\".\n\nBelow, the structural elements of `create-turbo` that make it a valid workspace are highlighted.\n\n### [Minimum requirements](#minimum-requirements)\n\n*   [Packages as described by your package manager](#specifying-packages-in-a-monorepo)\n*   [A package manager lockfile](#package-manager-lockfile)\n*   [Root `package.json`](#root-packagejson)\n*   [Root `turbo.json`](#root-turbojson)\n*   [`package.json` in each package](#packagejson-in-each-package)\n\n### [Specifying packages in a monorepo](#specifying-packages-in-a-monorepo)\n\n#### [Declaring directories for packages](#declaring-directories-for-packages)\n\nFirst, your package manager needs to describe the locations of your packages. We recommend starting with splitting your packages into `apps/` for applications and services and `packages/` for everything else, like libraries and tooling.\n\nUsing this configuration, every directory **with a `package.json`** in the `apps` or `packages` directories will be considered a package.\n\nTurborepo does not support nested packages like `apps/**` or `packages/**`. Using a structure that would put a package at `apps/a` and another at `apps/a/b` will result in an error.\n\nIf you'd like to group packages by directory, you can do this using globs like `packages/*` and `packages/group/*` and **not** creating a `packages/group/package.json` file.\n\n#### [`package.json` in each package](#packagejson-in-each-package)\n\nIn the directory of the package, there must be a `package.json` to make the package discoverable to your package manager and `turbo`. The [requirements for the `package.json` of a package](#anatomy-of-a-package) are below.\n\n### [Root `package.json`](#root-packagejson)\n\nThe root `package.json` is the base for your workspace. Below is a common example of what you would find in a root `package.json`:\n\n### [Root `turbo.json`](#root-turbojson)\n\n`turbo.json` is used to configure the behavior of `turbo`. To learn more about how to configure your tasks, visit the [Configuring tasks](https://turbo.build/repo/docs/crafting-your-repository/configuring-tasks) page.\n\n### [Package manager lockfile](#package-manager-lockfile)\n\nA lockfile is key to reproducible behavior for both your package manager and `turbo`. Additionally, Turborepo uses the lockfile to understand the dependencies between your [Internal Packages](https://turbo.build/repo/docs/core-concepts/internal-packages) within your Workspace.\n\nIf you do not have a lockfile present when you run `turbo`, you may see unpredictable behavior.\n\nIt's often best to start thinking about designing a package as its own unit within the Workspace. At a high-level, each package is almost like its own small \"project\", with its own `package.json`, tooling configuration, and source code. There are limits to this idea—but its a good mental model to _start_ from.\n\nAdditionally, a package has specific entrypoints that other packages in your Workspace can use to access the package, specified by [`exports`](#exports).\n\n### [`package.json` for a package](#packagejson-for-a-package)\n\n#### [`name`](#name)\n\n[The `name` field](https://nodejs.org/api/packages.html#name) is used to identify the package. It should be unique within your workspace.\n\nIt's best practice to use a namespace prefix for your [Internal Packages](https://turbo.build/repo/docs/core-concepts/internal-packages) to avoid conflicts with other packages on the npm registry. For example, if your organization is named `acme`, you might name your packages `@acme/package-name`.\n\nWe use `@repo` in our docs and examples because it is an unused, unclaimable namespace on the npm registry. You can choose to keep it or use your own prefix.\n\n#### [`scripts`](#scripts)\n\nThe `scripts` field is used to define scripts that can be run in the package's context. Turborepo will use the name of these scripts to identify what scripts to run (if any) in a package. We talk more about these scripts on the [Running Tasks](https://turbo.build/repo/docs/crafting-your-repository/running-tasks) page.\n\n#### [`exports`](#exports)\n\n[The `exports` field](https://nodejs.org/api/packages.html#exports) is used to specify the entrypoints for other packages that want to use the package. When you want to use code from one package in another package, you'll import from that entrypoint.\n\nFor example, if you had a `@repo/math` package, you might have the following `exports` field:\n\n./packages/math/package.json\n\nThe `exports` field in this example requires modern versions of Node.js and TypeScript.\n\nThis would allow you to import `add` and `subtract` functions from the `@repo/math` package like so:\n\n./apps/my-app/src/index.ts\n\nUsing exports this way provides three major benefits:\n\n*   **Avoiding barrel files**: Barrel files are files that re-export other files in the same package, creating one entrypoint for the entire package. While they might appear convenient, they're [difficult for compilers and bundlers to handle](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js#what's-the-problem-with-barrel-files) and can quickly lead to performance problems.\n*   **More powerful features**: `exports` also has other powerful features compared to [the `main` field](https://nodejs.org/api/packages.html#main) like [Conditional Exports](https://nodejs.org/api/packages.html#conditional-exports). In general, we recommend using `exports` over `main` whenever possible as it is the more modern option.\n*   **IDE autocompletion**: By specifying the entrypoints for your package using `exports`, you can ensure that your code editor can provide auto-completion for the package's exports.\n\nGood to know:\n\nYou may also specify `exports` using a wildcard. However, you will lose IDE autocompletion due to performance tradeoffs with the TypeScript compiler. For more information, visit [the TypeScript guide](https://turbo.build/repo/docs/guides/tools/typescript#package-entrypoint-wildcards).\n\n#### [`imports` (optional)](#imports-optional)\n\n[The `imports` field](https://nodejs.org/api/packages.html#imports) gives you a way to create subpaths to other modules within your package. You can think of these like \"shortcuts\" to get to other modules within your package.\n\nThis can be useful for concisely importing other modules within the package and can make refactors easier to manage.\n\nYou may be more familiar with TypeScript's `compilerOptions#paths` option, which accomplishes a similar goal. As of Typescript 5.4, TypeScript can infer subpaths from `imports`, making it a better option since you'll be working with Node.js conventions. For more information, visit [our Typescript guide](https://turbo.build/repo/docs/guides/tools/typescript#use-nodejs-subpath-imports-instead-of-typescript-compiler-paths).\n\n### [Source code](#source-code)\n\nOf course, you'll want some source code in your package. Packages commonly use an `src` directory to store their source code and compile to a `dist` directory (that should also be located within the package), although this is not a requirement.\n\n*   If you're using TypeScript, you likely don't need a `tsconfig.json` in the root of your workspace. Packages should independently specify their own configurations, usually building off of a shared `tsconfig.json` from a separate package in the workspace. For more information, visit [the TypeScript guide](https://turbo.build/repo/docs/guides/tools/typescript#you-likely-dont-need-a-tsconfigjson-file-in-the-root-of-your-project).\n*   You want to avoid accessing files across package boundaries as much as possible. If you ever find yourself writing `../` to get from one package to another, you likely have an opportunity to re-think your approach by installing the package where it's needed and importing it into your code.\n\nWith your Workspace configured, you can now use your package manager to [install dependencies into your packages](https://turbo.build/repo/docs/crafting-your-repository/managing-dependencies).",
  "title": "Structuring a repository | Turborepo",
  "description": "Start by creating a repository using the conventions of the ecosystem.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/eslint-config-turbo",
  "markdown": "# eslint-config-turbo | TurborepoTurborepoTurborepoTurborepoVercel\n\n[The `eslint-config-turbo` package](https://www.npmjs.com/package/eslint-config-turbo) helps you find environment variables that are used in your code that are not a part of Turborepo's hashing. Environment variables used in your source code that are not accounted for in `turbo.json` will be highlighted in your editor and errors will show as ESLint output.\n\n## [Installation](#installation)\n\nInstall `eslint-config-turbo` into the location where your ESLint configuration is held:\n\nTerminal\n\n```\nnpm i --save-dev eslint-config-turbo -w @acme/eslint-config\n```\n\n## [Usage](#usage)\n\nIn your ESLint configuration file, add the package:\n\n./packages/config-eslint/index.js\n\n```\n{\n  \"extends\": [\"turbo\"]\n}\n```",
  "title": "eslint-config-turbo | Turborepo",
  "description": "Learn more about eslint-config-turbo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/turbo-ignore",
  "markdown": "# turbo-ignore | TurborepoTurborepoTurborepoTurborepoVercel\n\nUse `turbo` to determine of a package or its dependencies have changes. This can be useful for quickly skipping tasks in CI.\n\nTerminal\n\nTo learn more, visit:\n\n*   [The introductory guide to skipping tasks](https://turbo.build/repo/docs/crafting-your-repository/constructing-ci#skipping-tasks-and-other-unnecessary-work)\n*   [The advanced guide for skipping tasks](https://turbo.build/repo/docs/guides/skipping-tasks)\n*   [Documentation for `turbo-ignore` on npm](https://www.npmjs.com/package/turbo-ignore)\n\nBecause `turbo-ignore` is most often used before installing dependencies into the repository, there won't be a `turbo` binary available when you run `turbo-ignore`. Instead `turbo-ignore` will search for the correct version to use with your repository with the following strategy:\n\n*   First, check for a `turbo` entry in root `package.json#devDependencies` or `package.json#dependencies`. If a version is found there, it will be used.\n*   If no `entry` is found in `package.json`, `turbo.json` will be read for its schema. If [the `tasks` key](https://turbo.build/repo/docs/reference/configuration#tasks) is found, use `turbo@^2`. If the `pipeline` from Turborepo v1 is found, use `turbo@^1`.",
  "title": "turbo-ignore | Turborepo",
  "description": "Learn how to use turbo-ignore to skip tasks in CI.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/turbo-codemod",
  "markdown": "# @turbo/codemod | TurborepoTurborepoTurborepoTurborepoVercel\n\nTurborepo provides codemod transformations and automatic migration scripts to help upgrade your Turborepo codebase when a feature is deprecated.\n\nCodemods are transformations that run on your codebase programmatically. This allows for a large amount of changes to be applied without having to manually manage repetitive changes.\n\nFirst, ensure that you've ran your package manager's install command.\n\nTerminal\n\n*   `transform` - name of transform, see available transforms below.\n*   `path` - files or directory to transform\n*   `--dry` - Do a dry-run (Code will not be edited)\n*   `--print` - Prints the changed output for comparison\n\nIn most cases, you can run:\n\nTerminal\n\nAll the codemods you need to upgrade will be ran for you.\n\n### [Turborepo 2.x](#turborepo-2x)\n\nThe codemods below are used for migration paths in the second major version of Turborepo.\n\n### [Turborepo 1.x](#turborepo-1x)\n\nThe codemods below are used for migration paths in the first major version of Turborepo.",
  "title": "@turbo/codemod | Turborepo",
  "description": "Learn more about how Turborepo uses codemods to make version migrations easy.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/crafting-your-repository/managing-dependencies",
  "markdown": "# Managing dependencies | TurborepoTurborepoTurborepoTurborepoVercel\n\n*   **External dependencies** come from [the npm registry](https://www.npmjs.com/), allowing you to leverage valuable code from the ecosystem to build your applications and libraries faster.\n*   **Internal dependencies** let you share functionality within your repository, dramatically improving discoverability and usability of shared code. We will discuss how to build an Internal Package in [the next guide](https://turbo.build/repo/docs/crafting-your-repository/creating-an-internal-package).\n\n### [Install dependencies where they're used](#install-dependencies-where-theyre-used)\n\nWhen you install a dependency in your repository, you should install it directly in the package that uses it. The package's `package.json` will have every dependency that the package needs. This is true for both external and internal dependencies.\n\nGood to know:\n\nNote that your package manager may choose to [use a different node\\_modules location than the package](#node_modules-locations).\n\nTo quickly install dependencies in multiple packages, you can use your package manager:\n\nThis practice has several benefits:\n\n*   **Improved clarity**: It's easier to understand what a package depends on when its dependencies are listed in its `package.json`. Developers working in the repository can see at a glance what dependencies are used within the package.\n*   **Enhanced flexibility**: In a monorepo at scale, it can be unrealistic to expect each package to use the same version of an external dependency. When there are many teams working in the same codebase, there will be differing priorities, timelines, and needs due to the realities of [operating at scale](https://vercel.com/blog/how-to-scale-a-large-codebase). By installing dependencies in the package that uses them, you can enable your `ui` team to bump to the latest version of TypeScript, while your `web` team can prioritize shipping new features and bumping TypeScript later. Additionally, if you still want to keep dependency versions in sync, [you can do that, too](https://turbo.build/repo/docs/crafting-your-repository/managing-dependencies#keeping-dependencies-on-the-same-version).\n*   **Better caching ability**: If you install too many dependencies in the root of your repository, you'll be changing the workspace root whenever you add, update, or delete a dependency, leading to unnecessary cache misses.\n*   **Pruning unused dependencies**: For Docker users, [Turborepo's pruning feature](https://turbo.build/repo/docs/reference/prune) can remove unused dependencies from Docker images to create lighter images. When dependencies are installed in the packages that they are meant for, Turborepo can read your lockfile and remove dependencies that aren't used in the packages you need.\n\n### [Few dependencies in the root](#few-dependencies-in-the-root)\n\nFollowing the first principle above to [install dependencies in the package where they're used](#install-dependencies-where-theyre-used), you'll find that you naturally end up with few dependencies in the root of your workspace.\n\nThe only dependencies that belong in the workspace root are **tools for managing the repository** whereas dependencies for building applications and libraries are installed in their respective packages. Some examples of dependencies that make sense to install in the root are [`turbo`](https://www.npmjs.com/package/turbo), [`husky`](https://www.npmjs.com/package/husky), or [`lint-staged`](https://www.npmjs.com/package/lint-staged).\n\n### [Turborepo does not manage dependencies](#turborepo-does-not-manage-dependencies)\n\nNote that Turborepo does not play a role in managing your dependencies, leaving that work up to your package manager of choice.\n\nIt's up to the package manager to handle things like downloading the right external dependency version, symlinking, and resolving modules. The recommendations on this page are best practices for managing dependencies in a Workspace, and are not enforced by Turborepo.\n\n### [node\\_modules locations](#node_modules-locations)\n\nDepending on your choice of package manager, version, settings, and where your dependencies are installed in your Workspace, you may see `node_modules` and the dependencies inside it in various locations within the Workspace. Dependencies could be found in the root `node_modules`, in packages' `node_modules`, or both.\n\nAs long as your scripts and tasks are able to find the dependencies they need, your package manager is working correctly.\n\nReferencing \\`node\\_modules\\` in your code\n\nThe specific locations for `node_modules` within the Workspace are not a part of the public API of package managers. This means that referencing `node_modules` directly (like `node ./node_modules/a-package/dist/index.js`) can be brittle, since the location of the dependency on disk can change with other dependency changes around the Workspace.\n\nInstead, rely on conventions of the Node.js ecosystem for accessing dependency modules whenever possible.\n\n### [Keeping dependencies on the same version](#keeping-dependencies-on-the-same-version)\n\nSome monorepo maintainers prefer to keep dependencies on the same version across all packages by rule. There are several ways to achieve this:\n\n#### [Using purpose-built tooling](#using-purpose-built-tooling)\n\nTools like [`syncpack`](https://www.npmjs.com/package/syncpack), [`manypkg`](https://www.npmjs.com/package/@manypkg/cli), and [`sherif`](https://www.npmjs.com/package/sherif) can be used for this specific purpose.\n\n#### [Using your package manager](#using-your-package-manager)\n\nYou can use your package manager to update dependency versions in one command.\n\n#### [Using an IDE](#using-an-ide)\n\nYour IDE's refactoring tooling can find and replace the version of a dependency across all `package.json` files in your repository at once. Try using a regex like `\"next\": \".*\"` on `package.json` files to find all instances of the `next` package and replace them with the version you want. When you're done, make sure to run your package manager's install command to update your lockfile.\n\nNow that you know how to manage dependencies effectively in a workspace, let's [create an Internal Package](https://turbo.build/repo/docs/crafting-your-repository/creating-an-internal-package) to be used as a dependency in your monorepo.",
  "title": "Managing dependencies | Turborepo",
  "description": "Learn how to manage dependencies in your monorepo's workspace.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/turbo-gen",
  "markdown": "# @turbo/gen | TurborepoTurborepoTurborepoTurborepoVercel\n\n```\nimport type { PlopTypes } from \"@turbo/gen\"; \n \nexport default function generator(plop: PlopTypes.NodePlopAPI): void {\n  // Create a generator\n  plop.setGenerator(\"Generator name\", {\n    description: \"Generator description\",\n    // Gather information from the user\n    prompts: [\n      ...\n    ],\n    // Perform actions based on the prompts\n    actions: [\n      ...\n    ],\n  });\n}\n```",
  "title": "@turbo/gen | Turborepo",
  "description": "Quickly generate new code in your Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/crafting-your-repository/creating-an-internal-package",
  "markdown": "# Creating an Internal Package | TurborepoTurborepoTurborepoTurborepoVercel\n\n[Internal Packages](https://turbo.build/repo/docs/core-concepts/internal-packages) are the building blocks of your workspace, giving you a powerful way to share code and functionality across your repo. Turborepo automatically understands the relationships between Internal Packages using the dependencies in `package.json`, creating a [Package Graph](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#package-graph) under the hood to optimize your repository's workflows.\n\n![Visual representation of a Package Graph in a Turborepo.](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fpackage-graph.3b11ffd3.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nLet's create your first Internal Package to share math utilities in your repo using the guidance in the [Anatomy of a package](https://turbo.build/repo/docs/crafting-your-repository/structuring-a-repository#anatomy-of-a-package) section. In the steps below, we assume you've [created a new repository using `create-turbo`](https://turbo.build/repo/docs/getting-started/installation) or are using a similarly structured repository.\n\n### [Create an empty directory](#create-an-empty-directory)\n\nYou'll need a directory to put the package in. Let's create one at `./packages/math`.\n\n### [Add a package.json](#add-a-packagejson)\n\nNext, create the `package.json` for the package. By adding this file, you'll fulfill [the two requirements for an Internal Package](https://turbo.build/repo/docs/crafting-your-repository/structuring-a-repository#specifying-packages-in-a-monorepo), making it discoverable to Turborepo and the rest of your Workspace:\n\nLet's break down this `package.json` piece-by-piece:\n\n*   **`scripts`**: The `dev` and `build` script compile the package using [the TypeScript compiler](https://www.typescriptlang.org/docs/handbook/compiler-options.html). The `dev` script will watch for changes to source code and automatically recompile the package.\n*   **`devDependencies`**: `typescript` and `@repo/typescript-config` are `devDependencies` so you can use those packages in the `@repo/math` package. In a real-world package, you will likely have more `devDependencies` and `dependencies` - but we can keep it simple for now.\n*   **`exports`**: Defines multiple entrypoints for the package so it can be used in other packages (`import { add } from '@repo/math'`).\n\nNotably, this `package.json` declares an Internal Package, `@repo/typescript-config`, as a dependency. Turborepo will recognize `@repo/math` as a dependent of `@repo/typescript-config` for ordering your tasks.\n\n### [Add a `tsconfig.json`](#add-a-tsconfigjson)\n\nSpecify the TypeScript configuration for this package by adding a `tsconfig.json` file to **the root of the package**. TypeScript has [an `extends` key](https://www.typescriptlang.org/tsconfig#extends), allowing you to use a base configuration throughout your repository and overwrite with different options as needed.\n\n./packages/math/tsconfig.json\n\nYou've done four important things here:\n\n*   The `@repo/typescript-config/base.json` configuration that lives in `./packages/typescript-config` has all the configuration you need so you extend from it.\n*   [The `outDir` key](https://www.typescriptlang.org/tsconfig/#outDir) in `compilerOptions` tells TypeScript where to put the compiled output. It matches the directory specified in your `exports` in `package.json`.\n*   [The `rootDir` key in `compilerOptions`](https://www.typescriptlang.org/tsconfig/#rootDir) ensures that the output in `outDir` uses the same structure as the `src` directory.\n*   The [`include`](https://www.typescriptlang.org/tsconfig/#include) and [`exclude`](https://www.typescriptlang.org/tsconfig/#exclude) keys are not inherited from the base configuration, [according to the TypeScript specification](https://www.typescriptlang.org/tsconfig#include), so you've included them here.\n\n### [Add a `src` directory with source code](#add-a-src-directory-with-source-code)\n\nYou can now write some code for your package. Create two files inside a `src` directory:\n\nThese files map to the outputs that will be created by `tsc` when you run `turbo build` in a moment.\n\n### [Add the package to an application](#add-the-package-to-an-application)\n\nYou're ready to use your new package in an application. Let's add it to the `web` application.\n\nYou just changed the dependencies in your repo. Make sure to run your package manager's installation command to update your lockfile.\n\n`@repo/math` is now available in the `web` application, you can use it in your code:\n\napps/web/src/app/page.tsx\n\n### [Edit `turbo.json`](#edit-turbojson)\n\nAdd the artifacts for the new `@repo/math` library to the `outputs` for the `build` task in `turbo.json`. This ensure that its build outputs will be cached by Turborepo, so they can be restored instantly when you start running builds.\n\n./turbo.json\n\n### [Run `turbo build`](#run-turbo-build)\n\nIf you've [installed `turbo` globally](https://turbo.build/repo/docs/getting-started/installation#global-installation), run `turbo build` in your terminal at the root of your Workspace. You can also run the `build` script from `package.json` with your package manager, which will use `turbo run build`.\n\nThe `@repo/math` package built before the `web` application built so that the runtime code in `./packages/math/dist` is available to the `web` application when it bundles.\n\nYou can run `turbo build` again to see your `web` application rebuild in **milliseconds**. We'll discuss this at length in [the Caching guide](https://turbo.build/repo/docs/crafting-your-repository/caching).\n\n### [One \"purpose\" per package](#one-purpose-per-package)\n\nWhen you're creating Internal Packages, it's recommended to create packages that have a single \"purpose\". This isn't a strict science or rule, but a best practice depending on your repository, your scale, your organization, what your teams need, and more. This strategy has several advantages:\n\n*   **Easier to understand**: As a repository scales, developers working in the repository will more easily be able to find the code they need.\n*   **Reducing dependencies per package**: Using fewer dependencies per package makes it so Turborepo can more effectively [prune the dependencies of your package graph](https://turbo.build/repo/docs/reference/prune).\n\nSome examples include:\n\n*   **`@repo/ui`**: A package containing all of your shared UI components\n*   **`@repo/tool-specific-config`**: A package for managing configuration of a specific tool\n*   **`@repo/graphs`**: A domain-specific library for creating and manipulating graphical data\n\n### [Application Packages do not contain shared code](#application-packages-do-not-contain-shared-code)\n\nWhen you're creating [Application Packages](https://turbo.build/repo/docs/core-concepts/package-types#application-packages), it's best to avoid putting shared code in those packages. Instead, you should create a separate package for the shared code and have the application packages depend on that package.\n\nAdditionally, Application Packages are not meant to be installed into other packages. Instead, they should be thought of as an entrypoint to your [Package Graph](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#package-graph).\n\nWith a new Internal Package in place, you can start [configuring tasks](https://turbo.build/repo/docs/crafting-your-repository/configuring-tasks).",
  "title": "Creating an Internal Package | Turborepo",
  "description": "Learn how to create an Internal Package for your monorepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/crafting-your-repository/configuring-tasks",
  "markdown": "# Configuring tasks | TurborepoTurborepoTurborepoTurborepoVercel\n\nTurborepo will always run tasks in the order described in your [`turbo.json` configuration](https://turbo.build/repo/docs/reference/configuration) and [Package Graph](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#package-graph), parallelizing work whenever possible to ensure everything runs as fast as possible. This is faster than running tasks one at a time, and it's a part of what makes Turborepo so fast.\n\nFor example, `yarn workspaces run lint && yarn workspaces run test && yarn workspaces run build` would look like this:\n\n![A graphical representation of `turbo run lint test build`. It shows all tasks running in parallel, with much less empty space where scripts are not being ran.](https://turbo.build/_next/image?url=%2Fimages%2Fdocs%2Fslow-tasks-dark.png&w=1920&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)![A graphical representation of `turbo run lint test build`. It shows all tasks running in parallel, with much less empty space where scripts are not being ran.](https://turbo.build/_next/image?url=%2Fimages%2Fdocs%2Fslow-tasks-light.png&w=1920&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nBut, to get the same work done **faster** with Turborepo, you can use `turbo run lint test build`:\n\n![A graphical representation of `turbo run lint test build`. It shows all tasks running in parallel, with much less empty space where scripts are not being ran.](https://turbo.build/_next/image?url=%2Fimages%2Fdocs%2Fturborepo-tasks-fast-dark.png&w=1920&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)![A graphical representation of `turbo run lint test build`. It shows all tasks running in parallel, with much less empty space where scripts are not being ran.](https://turbo.build/_next/image?url=%2Fimages%2Fdocs%2Fturborepo-tasks-fast-light.png&w=1920&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nThe root `turbo.json` file is where you'll register the tasks that Turborepo will run. Once you have your tasks defined, you'll be able to run one or more tasks using [`turbo run`](https://turbo.build/repo/docs/reference/run).\n\n*   If you're starting fresh, we recommend [creating a new repository using `create-turbo`](https://turbo.build/repo/docs/getting-started/installation) and editing the `turbo.json` file to try out the snippets in this guide.\n*   If you're adopting Turborepo in an existing repository, create a `turbo.json` file in the root of your repository. You'll be using it to learn about the rest of the configuration options in this guide.\n\nEach key in the `tasks` object is a task that can be executed by `turbo run`. Turborepo will search your packages for **scripts in their `package.json` that have the same name as the task**.\n\nTo define a task, use [the `tasks` object](https://turbo.build/repo/docs/reference/configuration#tasks) in `turbo.json`. For example, a basic task with no dependencies and no outputs named `build` might look like this:\n\n./turbo.json\n\nIf you run `turbo run build` at this point, Turborepo will run all `build` scripts in your packages in parallel and won't cache any file outputs. **This will quickly lead to errors.** You're missing a few important pieces to make this work how you'd expect.\n\n### [Running tasks in the right order](#running-tasks-in-the-right-order)\n\n[The `dependsOn` key](https://turbo.build/repo/docs/reference/configuration#dependson) is used to specify the tasks that must complete before a different task begins running. For example, in most cases, you want the `build` script for your libraries to complete before your application's `build` script runs. To do this, you'd use the following `turbo.json`:\n\n./turbo.json\n\nYou now have the build order you would expect, building _dependencies_ before _dependents_.\n\n**But be careful.** At this point, you haven't marked the build outputs for caching. To do so, jump to the [Specifying outputs](#specifying-options) section.\n\n#### [Depending on tasks in dependencies with `^`](#depending-on-tasks-in-dependencies-with-)\n\nThe `^` microsyntax tells Turborepo to run the task starting at the bottom of the dependency graph. If your application depends on a library named `ui` and the library has a `build` task, the `build` script in `ui` will run **first**. Once it has successfully completed, the `build` task in your application will run.\n\nThis is an important pattern as it ensures that your application's `build` task will have all of the necessary dependencies that it needs to compile. This concept also applies as your dependency graph grows to a more complex structure with many levels of task dependencies.\n\n#### [Depending on tasks in the same package](#depending-on-tasks-in-the-same-package)\n\nSometimes, you may need to ensure that two tasks in the same package run in a specific order. For example, you may need to run a `build` task in your library before running a `test` task in the same library. To do this, specify the script in the `dependsOn` key as a plain string (without the `^`).\n\n./turbo.json\n\n#### [Depending on a specific task in a specific package](#depending-on-a-specific-task-in-a-specific-package)\n\nYou can also specify an individual task in a specific package to depend on. In the example below, the `build` task in `utils` must be ran before any `lint` tasks.\n\n./turbo.json\n\nYou can also be more specific about the dependent task, limiting it to a certain package:\n\n./turbo.json\n\nWith this configuration, the `lint` task in your `web` package can only be ran after the `build` task in the `utils` package is complete.\n\n#### [No dependencies](#no-dependencies)\n\nSome tasks may not have any dependencies. For example, a task for finding typos in Markdown files likely doesn't need to care about the status of your other tasks. In this case, you can omit the `dependsOn` key or provide an empty array.\n\n./turbo.json\n\n### [Specifying `outputs`](#specifying-outputs)\n\nTurborepo caches the outputs of your tasks so that you never do the same work twice. We'll discuss this in depth in [the Caching guide](https://turbo.build/repo/docs/crafting-your-repository/caching), but let's make sure your tasks are properly configured first.\n\nThe `outputs` key tells Turborepo **files and directories** it should cache when the task has successfully completed. **Without this key defined, Turborepo will not cache any files. Hitting cache on subsequent runs will not restore any file outputs.**\n\nBelow are a few examples of outputs for common tools:\n\nFor more on building globbing patterns for the `outputs` key, see [the globbing specification](https://turbo.build/repo/docs/reference/globs).\n\n### [Specifying `inputs`](#specifying-inputs)\n\nThe `inputs` key is used to specify the files that you want to include in the task's hash for [caching](https://turbo.build/repo/docs/crafting-your-repository/caching). By default, Turborepo will include all files in the package that are tracked by Git. However, you can be more specific about which files are included in the hash using the `inputs` key.\n\nAs an example, a task for finding typos in Markdown files could be defined like this:\n\n./turbo.json\n\nNow, **only** changes in Markdown files will cause the `spell-check` task to miss cache.\n\nThis feature opts out of all of Turborepo's default `inputs` behavior, including following along with changes tracked by source control. This means that your `.gitignore` file will no longer be respected, and you will need to ensure that you do not capture those files with your globs.\n\nTo restore the default behavior, use [the `$TURBO_DEFAULT$` microsyntax](#restoring-defaults-with-turbo_default).\n\n#### [Restoring defaults with `$TURBO_DEFAULT$`](#restoring-defaults-with-turbo_default)\n\n[The default `inputs` behavior](https://turbo.build/repo/docs/reference/configuration#inputs) is often what you will want for your tasks. However, you can increase your cache hit ratios for certain tasks by fine-tuning your `inputs` to ignore changes to files that are known to not affect the task's output.\n\nFor this reason, you can use the `$TURBO_DEFAULT$` microsyntax to fine-tune the default `inputs` behavior:\n\n./turbo.json\n\nIn this task definition, Turborepo will use the default `inputs` behavior for the `build` task, but will ignore changes to the `README.md` file. If the `README.md` file is changed, the task will still hit cache.\n\n### [Registering Root Tasks](#registering-root-tasks)\n\nYou can also run scripts in the `package.json` in the Workspace root using `turbo`. For example, you may want to run a `lint` task for the files in your Workspace's root directory in addition to the `lint` task in each package:\n\n#### [When to use Root Tasks](#when-to-use-root-tasks)\n\n*   **Linting and formatting of the Workspace root**: You might have code in your Workspace root that you want to lint and format. For example, you might want to run ESLint or Prettier in your root directory.\n*   **Incremental migration**: While you're migrating to Turborepo, you might have an in-between step where you have some scripts that you haven't moved to packages yet. In this case, you can create a Root Task to start migrating and fan the tasks out to packages later.\n*   **Scripts without a package scope**: You may have some scripts that don't make sense in the context of specific packages. Those scripts can be registered as Root Tasks so you can still run them with `turbo` for caching, parallelization, and workflow purposes.\n\n### [Using Package Configurations](#using-package-configurations)\n\n[Package Configurations](https://turbo.build/repo/docs/reference/package-configurations) are `turbo.json` files that are placed directly into a package. This allows a package to define specific behavior for its own tasks without affecting the rest of the repository.\n\nIn large monorepos with many teams, this allows teams greater control over their own tasks. To learn more, visit [the Package Configurations documentation](https://turbo.build/repo/docs/reference/package-configurations)\n\n### [Performing side-effects](#performing-side-effects)\n\nSome tasks should always be ran no matter what, like a deployment script after a cached build. For these tasks, add `\"cache\": false` to your task definition.\n\n./turbo.json\n\n### [Dependent tasks that can be ran in parallel](#dependent-tasks-that-can-be-ran-in-parallel)\n\nSome tasks can be ran in parallel despite being dependent on other packages. An example of tasks that fit this description are linters, since a linter doesn't need to wait for outputs in dependencies to run successfully.\n\nBecause of this, you may be tempted to define your `check-types` task like this:\n\n./turbo.json\n\nThis runs your tasks in parallel - but doesn't account for source code changes in dependencies. This means you can:\n\n1.  Make a breaking change to the interface of your `ui` package.\n2.  Run `turbo check-types`, hitting cache in an application package that depends on `ui`.\n\nThis is incorrect, since the application package will show a successful cache hit, despite not being updated to use the new interface. Checking for TypeScript errors in your application package manually in your editor is likely to reveal errors.\n\nBecause of this, you make a small change to your `check-types` task definition:\n\n./turbo.json\n\nIf you test out making breaking changes in your `ui` package again, you'll notice that the caching behavior is now correct. However, tasks are no longer running in parallel.\n\nTo meet both requirements (correctness and parallelism), you can introduce [Transit Nodes](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#transit-nodes) to your Task Graph:\n\n./turbo.json\n\nThese Transit Nodes create a relationship between your package dependencies using a task that doesn't do anything because it doesn't match a script in any `package.json`s. Because of this, your tasks can run in parallel **and** be aware of changes to their internal dependencies.\n\nIn this example, we used the name `transit` - but you can name the task anything that isn't already a script in your Workspace.\n\nThere are more options available in [the Configuring `turbo.json` documentation](https://turbo.build/repo/docs/reference/configuration) that you will explore in the coming guides. For now, you can start running a few tasks to see how the basics work.",
  "title": "Configuring tasks | Turborepo",
  "description": "Learn how to describe the workflows in your repository to get them done as fast as possible.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/getting-started/support-policy",
  "markdown": "# Support policy | TurborepoTurborepoTurborepoTurborepoVercel\n\nCore `turbo` functionality depends on the package managers in the JavaScript ecosystem and their implementations of Workspaces and lockfiles formats.\n\n| Package manager | Supported |\n| --- | --- |\n| pnpm 8+ | Yes |\n| npm 8+ | Yes |\n| yarn 1+ | Yes (Includes Yarn Plug'n'Play) |\n| bun 1+ | Experimental, based on Bun's experimental Workspace support |\n\nPackage managers have their own release schedules, bugs, and features. While we intend to keep up with new major versions, we likely will not be able to release support immediately.\n\n`turbo` is generally supported on Debian-based Linux distributions, macOS, and Windows on both x86\\_64 and ARM 64 architectures. Specifically, we build and ship the following binaries via npm:\n\n*   `turbo-darwin-64` (macOS with Intel chips)\n*   `turbo-darwin-arm64` (macOS with Apple Silicon)\n*   `turbo-linux-64`\n*   `turbo-linux-arm64`\n*   `turbo-windows-64`\n*   `turbo-windows-arm64`\n\nCore `turbo` functionality does not depend on the active Node.js version on your system, but [some packages in the Turborepo ecosystem](https://turbo.build/repo/docs/reference#packages) such as [`create-turbo`](https://turbo.build/repo/docs/reference/create-turbo), [`turbo-ignore`](https://turbo.build/repo/docs/reference/turbo-ignore), and [`eslint-config-turbo`](https://turbo.build/repo/docs/reference/eslint-config-turbo) do. For these features, we intend to support the [Active and Maintenance LTS versions of Node.js](https://nodejs.org/en/about/previous-releases).\n\nTurborepo's [examples](https://turbo.build/repo/docs/getting-started/installation#start-with-an-example) are also expected to work with these Node.js versions.\n\nWe support repositories that are version controlled with Git and repositories that don't have version control at all. Any other version control system will be ignored.\n\nNote that we use Git to hash files, so repositories without git may perform and behave differently.\n\nMajor versions of Turborepo will be supported for two years from the release date of the next major version.\n\nChanges required for critical security fixes in older versions will be backported. Such situations will be rare and will land as semver-minor releases, even if they are breaking changes.\n\nWe highly encourage you to use the most current version of Turborepo whenever possible.\n\n| Major version | Release date | End-of-life date |\n| --- | --- | --- |\n| 2.x | Jun. 4, 2024 |     |\n| 1.x | Dec. 9, 2021 | Jun. 4, 2026 |",
  "title": "Support policy | Turborepo",
  "description": "Learn about Turborepo's Support policy.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/core-concepts",
  "markdown": "# Core concepts | TurborepoTurborepoTurborepoTurborepoVercel\n\nLearn more about the core concepts of Turborepo:",
  "title": "Core concepts | Turborepo",
  "description": "Learn about the core concepts behind Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/core-concepts/package-types",
  "markdown": "# Package types | TurborepoTurborepoTurborepoTurborepoVercel\n\nIn Turborepo, we talk about two types of packages:\n\n*   [Application Packages](#application-packages)\n*   [Library Packages](#library-packages)\n\nAn Application Package is a package in your workspace that will be deployed from your workspace. Examples of Application Packages are Next.js, Svelte, Vite, or CLI applications that are commonly found in the `./apps` directory.\n\nIt's best practice that your Application Packages are the \"end\" of your [Package Graph](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#package-graph), not being installed into other packages of your repository. Your CI/CD pipelines will most often finalize at these nodes of your Package and Task Graphs.\n\n### [Installing an application package into another package](#installing-an-application-package-into-another-package)\n\nIn rare cases, you may need to install an Application Package into another package. This should be the exception. If you find you are doing this often, you may want to rethink your package structure.\n\nAn example of an exception for this rule is installing your Application Package into a package that handles end-to-end testing. Once installed, you can depend on the Application Package in your end-to-end testing package so it is aware of re-deploys of the application.\n\nLibrary Packages contain code that you intend to share around your workspace. They aren't independently deployable. Instead, they support the Application Packages to create the final deployables from your repository. You might also refer to these packages as [Internal Packages](https://turbo.build/repo/docs/core-concepts/internal-packages), which have their own sub-types.",
  "title": "Package types | Turborepo",
  "description": "Learn about the different types of packages in a workspace.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/crafting-your-repository/running-tasks",
  "markdown": "# Running tasks | TurborepoTurborepoTurborepoTurborepoVercel\n\nTurborepo optimizes the developer workflows in your repository by automatically parallelizing and caching tasks. Once a task is [registered in `turbo.json`](https://turbo.build/repo/docs/crafting-your-repository/configuring-tasks), you have a powerful new toolset for running the scripts in your repository:\n\n*   [Use `scripts` in `package.json` for tasks you need to run often](#using-scripts-in-packagejson)\n*   [Use global `turbo` to quickly run custom tasks on-demand](#using-global-turbo)\n*   [Filter tasks by directories, package names, source control changes, and more](#using-filters)\n\nRunning tasks through `turbo` is powerful because you get one model for executing workflows throughout your repository in development and in your CI pipelines.\n\nFor tasks that you run frequently, you can write your `turbo` commands directly into your root `package.json`.\n\n./package.json\n\nGood to know:\n\n`turbo` is an alias for `turbo run` - but we recommend using `turbo run` in `package.json` and CI workflows to avoid potential collisions with possible `turbo` subcommands that could be added in the future.\n\nThese scripts can then be run using your package manager.\n\nYou only want to write `turbo` commands in your root `package.json`. Writing `turbo` commands into the `package.json` of packages can lead to recursively calling `turbo`.\n\n[Installing `turbo` globally](https://turbo.build/repo/docs/getting-started/installation#installing-globally) lets you run commands directly from your terminal. This improves your local development experience since it makes it easier to run exactly what you need, when you need it.\n\nAdditionally, global `turbo` is useful in your CI pipelines, giving you maximum control of exactly which tasks to run at each point in your pipeline.\n\n### [Automatic Package Scoping](#automatic-package-scoping)\n\nWhen you're in a package's directory, `turbo` will automatically scope commands to the [Package Graph](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#package-graph) for that package. This means you can quickly write commands without having to [write filters](https://turbo.build/repo/docs/reference/run#--filter-string) for the package.\n\nTerminal\n\nIn the example above, the `turbo build` command will run the `build` task for the `docs` package using the `build` task registered in `turbo.json`.\n\nGood to know:\n\n[Using a filter](#using-filters) will override Automatic Package Scoping.\n\n### [Customizing behavior](#customizing-behavior)\n\nIn [the documentation for the `run` subcommand](https://turbo.build/repo/docs/reference/run), you'll find many useful flags to tailor the behavior of `turbo run` for what you need. When running global `turbo`, you can go faster using workflows like:\n\n*   **Variations of your most common commands**: The `build` script in `package.json` has the most utility when it is `turbo build` - but you might only be interested in a specific package at the moment. You can quickly filter for the specific package you're interested in using `turbo build --filter=@repo/ui`.\n*   **One-off commands**: Commands like `turbo build --dry` aren't needed often so you likely won't create a script in your `package.json` for it. Instead, you can run it directly in your terminal whenever you need it.\n*   **Overriding `turbo.json` configuration**: Some CLI flags have an equivalent in `turbo.json` that you can override. For instance, you may have a `turbo build` command configured to use [`\"outputLogs\": \"full\"` in `turbo.json`](https://turbo.build/repo/docs/reference/configuration#outputmode) - but you're only interested in seeing errors at the moment. Using global `turbo`, you can use `turbo lint --output-logs=errors-only` to only show errors.\n\n`turbo` is able to run multiple tasks, parallelizing whenever possible.\n\nTerminal\n\nThis command will run all of the tasks, automatically detecting where it can run a script as early as possible, according to your task definitions.\n\nOrdering of tasks\n\n`turbo test lint` will run tasks exactly the same as `turbo lint test`.\n\nIf you want to ensure that one task blocks the execution of another, express that relationship in your [task configurations](https://turbo.build/repo/docs/crafting-your-repository/configuring-tasks#defining-tasks).\n\nWhile [caching](https://turbo.build/repo/docs/crafting-your-repository/running-tasks) ensures you stay fast by never doing the same work twice, you can also filter tasks to run only a subset of [the Task Graph](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#task-graph), according to your needs.\n\nThere are many advanced use cases for filtering in [the `--filter` API reference](https://turbo.build/repo/docs/reference/run#--filter-string) but the most common use cases are discussed below.\n\n### [Filtering by package name](#filtering-by-package-name)\n\nFiltering by package is a simple way to only run tasks for the packages you're currently working on.\n\nTerminal\n\n### [Filtering by directory](#filtering-by-directory)\n\nYour repository might have a directory structure where related packages are grouped together. In this case, you can capture the glob for that directory to focus `turbo` on those packages.\n\nTerminal\n\n### [Filtering to include dependents](#filtering-to-include-dependents)\n\nWhen you're working on a specific package, you might want to run tasks for the package and its dependents. The `...` microsyntax is useful when you're making changes to a package and want to ensure that the changes don't break any of its dependents.\n\nTerminal\n\n### [Filtering by source control changes](#filtering-by-source-control-changes)\n\nUsing filters to run tasks based on changes in source control is a great way to run only the tasks for packages that are affected by your changes. **Source control filters must be wrapped in `[]`**.\n\n*   **Comparing to the previous commit**: `turbo build --filter=[HEAD^1]`\n*   **Comparing to the main branch**: `turbo build --filter=[main...my-feature]`\n*   **Comparing specific commits using SHAs**: `turbo build --filter=[a1b2c3d...e4f5g6h]`\n*   **Comparing specific commits using branch names**: `turbo build --filter=[your-feature...my-feature]`\n\nIn general, you can rely on caching to keep your repository fast. When you're using [Remote Caching](https://turbo.build/repo/docs/core-concepts/remote-caching), you can count on hitting cache for unchanged packages.\n\n### [Combining filters](#combining-filters)\n\nFor even more specificity, you can combine filters to further refine the entrypoints into your [Task Graph](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#task-graph).\n\nTerminal\n\nMultiple filters are combined as a **union**, meaning that the [Task Graph](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#task-graph) will include tasks that match any of the filters. For more information on advanced usage of filters, see [the `--filter` API reference](https://turbo.build/repo/docs/reference/run#--filter-string).\n\nWhen you start running tasks in your repository, you might start noticing that your tasks get faster. Next, you'll explore [caching](https://turbo.build/repo/docs/crafting-your-repository/caching) and how `turbo` makes it so you never do the same work twice.",
  "title": "Running tasks | Turborepo",
  "description": "Learn how to run tasks in your repository through the `turbo` CLI.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/core-concepts/remote-caching",
  "markdown": "# Remote Caching | TurborepoTurborepoTurborepoTurborepoVercel\n\nTurborepo's [task cache](https://turbo.build/repo/docs/crafting-your-repository/caching) saves time by never doing the same work twice.\n\nBut there's a problem: **the cache is local to your machine**. When you're working with a Continuous Integration system, this can result in a lot of duplicated work:\n\n![Local caching creates a cache on each system.](https://turbo.build/_next/image?url=%2Fimages%2Fdocs%2Flocal-caching-dark.png&w=1920&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)![Local caching creates a cache on each system.](https://turbo.build/_next/image?url=%2Fimages%2Fdocs%2Flocal-caching-light.png&w=1920&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nSince Turborepo only caches to the local filesystem by default, the same task (`turbo run build`) must be **re-executed on each machine** (by you, by your teammates, by your CI, by your PaaS, etc.) even when all of the task inputs are identical — which **wastes time and resources**.\n\nGood to know:\n\nYou don't have to use Remote Caching to use Turborepo. While Remote Caching will bring the most significant speedups, you can make your existing workflows faster without Remote Caching, too.\n\nWhat if you could share a single Turborepo cache across your entire team (and even your CI)?\n\n![Remote caching creates a shared cache for your entire team.](https://turbo.build/_next/image?url=%2Fimages%2Fdocs%2Fremote-caching-dark.png&w=1920&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)![Remote caching creates a shared cache for your entire team.](https://turbo.build/_next/image?url=%2Fimages%2Fdocs%2Fremote-caching-light.png&w=1920&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nBy working with providers like [Vercel](#vercel), Turborepo can securely communicate with a remote cache - a cloud server that stores the results of your tasks.\n\nThis can save enormous amounts of time by **preventing duplicated work across your entire organization**.\n\nRemote Caching is a powerful feature of Turborepo, but, with great power, comes great responsibility. Make sure you are caching correctly first and double check [handling of environment variables](https://turbo.build/repo/docs/crafting-your-repository/using-environment-variables). Please also remember Turborepo treats logs as artifacts, so be aware of what you are printing to the console.\n\n### [For Local Development](#for-local-development)\n\nTo link your local Turborepo to your Remote Cache, authenticate the Turborepo CLI with your Vercel account:\n\nTerminal\n\nYou can also use your package manager if you do not have [global `turbo`](https://turbo.build/repo/docs/getting-started/installation#global-installation) installed:\n\nIf your Remote Cache is configured to use single-sign-on you will need to run `npx turbo login --sso-team=team-name` in order to get a cache token with the correct privileges.\n\nNow, link your Turborepo to your Remote Cache:\n\nTerminal\n\nOnce enabled, make some changes to a package you are currently caching and run tasks against it with `turbo run`. Your cache artifacts will now be stored locally _and_ in your Remote Cache.\n\nTo verify, delete your local Turborepo cache with:\n\nThen, run the same build again. If things are working properly, `turbo` should not execute tasks locally. Instead, it will download the logs and artifacts from your Remote Cache and replay them back to you.\n\n### [Remote Caching on Vercel](#remote-caching-on-vercel)\n\nIf you are building and hosting your apps on Vercel, Remote Caching will be automatically set up on your behalf once you use `turbo`. Refer to the [Vercel documentation](https://vercel.com/docs/concepts/monorepos/remote-caching?utm_source=turbo.build&utm_medium=referral&utm_campaign=docs-link) for more information.\n\n### [Artifact Integrity and Authenticity Verification](#artifact-integrity-and-authenticity-verification)\n\nTurborepo can sign artifacts with a secret key before uploading them to the Remote Cache. Turborepo uses `HMAC-SHA256` signatures on artifacts using a secret key you provide. Turborepo will verify the Remote Cache artifacts' integrity and authenticity when they're downloaded. Any artifacts that fail to verify will be ignored and treated as a cache miss by Turborepo.\n\nTo enable this feature, set the `remoteCache` options on your `turbo.json` config to include `signature: true`. Then specify your secret key by declaring the `TURBO_REMOTE_CACHE_SIGNATURE_KEY` environment variable.\n\n./turbo.json\n\nA Remote Cache can be implemented by any HTTP server that meets Turborepo's Remote Caching API specification.\n\n### [Managed Remote Cache with Vercel](#managed-remote-cache-with-vercel)\n\n[Vercel](https://vercel.com/), the creators and maintainers of Turborepo, provide a managed Remote Cache that is fully compatible with Turborepo.\n\nUsing [Vercel Remote Cache](https://vercel.com/docs/monorepos/remote-caching) is zero-configuration and automatically integrates with [Vercel deployments](https://vercel.com/docs/deployments/overview) through the open-source [Vercel Remote Cache SDK](https://github.com/vercel/remote-cache).\n\nLearn more about [Turborepo on Vercel](https://vercel.com/docs/monorepos/turborepo) or [deploy a template for free](https://vercel.com/templates?search=turborepo) to try it out.\n\n### [Self-hosting](#self-hosting)\n\nYou can also self-host your own Remote Cache and set the remote caching domain by specifying the `--api` and `--token` flags, where `--api` is the hostname and `--token` is a bearer token.\n\nTerminal\n\nYou can [find the OpenAPI specification for the API here](https://turbo.build/api/remote-cache-spec). At this time, all versions of `turbo` are compatible with the `v8` endpoints.",
  "title": "Remote Caching | Turborepo",
  "description": "Share cache artifacts across machines for even faster builds.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/crafting-your-repository/caching",
  "markdown": "# Caching | TurborepoTurborepoTurborepoTurborepoVercel\n\nTurborepo uses caching to speed up builds, ensuring you **never do the same work twice**. When your task is cacheable, Turborepo will restore the results of your task from cache using a fingerprint from the first time the task was ran.\n\n![12 tasks are being ran in 3 packages, resulting in a \">>> FULL TURBO\" cache hit. The total time it takes to restore these tasks from cache is 80 milliseconds.](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fwhy-turborepo-solution.02448c98.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nTurborepo's caching results in significant time savings when working locally - and is even more powerful when [Remote Caching](https://turbo.build/repo/docs/core-concepts/remote-caching) is enabled, sharing a cache among your entire team and CI.\n\nOn this page, you'll learn:\n\n*   [How to hit your first Turborepo cache](#hit-your-first-turborepo-cache)\n*   [How to enable Remote Caching](https://turbo.build/repo/docs/core-concepts/remote-caching)\n*   [What Turborepo uses for the inputs and outputs to a hash](https://turbo.build/repo/docs/crafting-your-repository/caching#task-inputs)\n*   [How to troubleshoot caching issues](#troubleshooting)\n\nGood to know:\n\nTurborepo assumes that your tasks are **deterministic**. If a task is able to produce different outputs given the set of inputs that Turborepo is aware of, caching may not work as expected.\n\nYou can try out Turborepo's caching behavior in three steps:\n\n### [Create a new Turborepo project](#create-a-new-turborepo-project)\n\nUse `npx create-turbo@latest` and follow the prompts to create a new Turborepo.\n\nTerminal\n\n### [Run a build for the first time](#run-a-build-for-the-first-time)\n\nIf you have [`turbo` installed globally](https://turbo.build/repo/docs/getting-started/installation#installing-globally), run `turbo build` in your repository.\n\nAlternatively, you can run the `build` script in `package.json` using your package manager.\n\nThis will result in a cache miss, since you've never ran `turbo` before with this [set of inputs](https://turbo.build/repo/docs/crafting-your-repository/caching#task-inputs) in this repository. The inputs are turned into a hash to check for in your local filesystem cache or in [the Remote Cache](https://turbo.build/repo/docs/core-concepts/remote-caching).\n\n### [Hit the cache](#hit-the-cache)\n\nRun `turbo build` again. You will see a message like this:\n\n![A terminal window showing two tasks that have been ran through turbo. They successfully complete in 116 milliseconds.](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffull-turbo.0fd6323e.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nBecause the inputs' fingerprint is already in the cache, there's no reason to rebuild your applications from zero again. You can restore the results of the previous build from cache, saving resources and time.\n\nTurborepo stores the results of tasks in the `.turbo/cache` directory on your machine. However, you can make your entire organization even faster by sharing this cache with your teammates and CI.\n\nTo learn more about Remote Caching and its benefits, visit the [Remote Caching page](https://turbo.build/repo/docs/core-concepts/remote-caching).\n\n### [Enabling Remote Cache](#enabling-remote-cache)\n\nFirst, authenticate with your Remote Cache provider:\n\nTerminal\n\nThen, link the repository on your machine to Remote Cache:\n\nTerminal\n\nNow, when you run a task, Turborepo will automatically send the outputs of the task to Remote Cache. If you run the same task on a different machine that is also authenticated to your Remote Cache, it will hit cache the first time it runs the task.\n\nFor information on how to connect your CI machines to Remote Cache, visit [the Constructing CI guide](https://turbo.build/repo/docs/crafting-your-repository/constructing-ci#enable-remote-caching).\n\n### [Task outputs](#task-outputs)\n\nTurborepo caches the file outputs of a task that are defined in [the `outputs` key](https://turbo.build/repo/docs/reference/configuration#outputs) of `turbo.json`. When there's a cache hit, Turborepo will restore the files from the cache.\n\nProviding file outputs\n\nIf you do not declare file outputs for a task, Turborepo will not cache them. This might be okay for some tasks (like linters) - but many tasks produce files that you will want to be cached.\n\nIf you're running into errors with files not being available when you hit cache, make sure that you have defined the outputs for your task.\n\n### [Logs](#logs)\n\nTurborepo always captures the terminal outputs of your tasks, restoring those logs to your terminal from the first time that the task was ran.\n\nYou can configure the verbosity of the replayed logs using [the `--output-logs` flag](https://turbo.build/repo/docs/reference/run#--output-logs-option) or [`outputLogs` configuration option](https://turbo.build/repo/docs/reference/configuration#outputmode).\n\nInputs are hashed by Turborepo, creating a \"fingerprint\" for the task run. When \"fingerprints\" match, running the task will hit the cache.\n\nUnder the hood, Turborepo creates two hashes: a global hash and a task hash. If either of the hashes change, the task will miss cache.\n\n### [Global hash inputs](#global-hash-inputs)\n\n| Input | Example |\n| --- | --- |\n| Resolved task definition from root `turbo.json`  <br>and package `turbo.json` | Changing [`outputs`](https://turbo.build/repo/docs/reference/configuration#outputs) in either root `turbo.json` or [Package Configuration](https://turbo.build/repo/docs/reference/package-configurations) |\n| Lockfile changes that affect the Workspace root | Updating dependencies in root `package.json` will cause **all** tasks to miss cache |\n| [`globalDependencies`](https://turbo.build/repo/docs/reference/configuration#globaldependencies) file contents | Changing `./.env` when it is listed in `globalDependencies` will cause **all** tasks to miss cache |\n| Values of variables listed in [`globalEnv`](https://turbo.build/repo/docs/reference/configuration#globalenv) | Changing the value of `GITHUB_TOKEN` when it is listed in `globalEnv` |\n| Flag values that affect task runtime | Using behavior-changing flags like `--cache-dir`, `--framework-inference`, or `--env-mode` |\n| Arbitrary passthrough arguments | `turbo build -- --arg=value` will miss cache compared to `turbo build` or `turbo build -- --arg=diff` |\n\n### [Package hash inputs](#package-hash-inputs)\n\n| Input | Example |\n| --- | --- |\n| [Package Configuration](https://turbo.build/repo/docs/reference/package-configurations) changes | Changing a package's `turbo.json` |\n| Lockfile changes that affect the package | Updating dependencies in a package's `package.json` |\n| Package's `package.json` changes | Updating the `name` field in a package's `package.json` |\n| File changes in source control | Writing new code in `src/index.ts` |\n\n### [Using dry runs](#using-dry-runs)\n\nTurborepo has a [`--dry` flag](https://turbo.build/repo/docs/reference/run#--dry----dry-run) that can be used to see what would happen if you ran a task without actually running it. This can be useful for debugging caching issues when you're not sure which tasks you're running.\n\nFor more details, visit the [`--dry` API reference](https://turbo.build/repo/docs/reference/run#--dry----dry-run).\n\n### [Using Run Summaries](#using-run-summaries)\n\nTurborepo has a [`--summarize` flag](https://turbo.build/repo/docs/reference/run#--summarize) that can be used to get an overview of all of a task's inputs, outputs, and more. Comparing two summaries will show why two task's hashes are different. This can be useful for:\n\n*   Debugging inputs: There are many inputs to a task in Turborepo. If a task is missing cache when you expect it to hit, you can use a Run Summary to check which inputs are different that you weren't expecting.\n*   Debugging outputs: If cache hits aren't restoring the files you're expecting, a Run Summary can help you understand what outputs are being restored from cache.\n\n### [Turning off caching](#turning-off-caching)\n\nSometimes, you may not want to write the output of tasks to the cache. This can be set permanently for a task using [`\"cache\": false`](https://turbo.build/repo/docs/reference/configuration#cache) or for a whole run using [the `--no-cache` flag](https://turbo.build/repo/docs/reference/run#--no-cache).\n\n### [Overwriting a cache](#overwriting-a-cache)\n\nIf you want to force `turbo` to re-execute a task that has been cached, use [the `--force` flag](https://turbo.build/repo/docs/reference/run#--force). Note that this disables **reading** the cache, **not writing**.\n\n### [Caching a task is slower than executing the task](#caching-a-task-is-slower-than-executing-the-task)\n\nIt's possible to create scenarios where caching ends up being slower than not caching. These cases are rare, but a few examples include:\n\n*   **Tasks that execute extremely fast**: If a task executes faster than a network round-trip to the [Remote Cache](https://turbo.build/repo/docs/core-concepts/remote-caching), you should consider not caching the task.\n*   **Tasks whose output assets are enormous**: It's possible to create an artifact that is so big that the time to upload or download it exceeds the time to regenerate it, like a complete Docker Container. In these cases, you should consider not caching the task.\n*   **Scripts that have their own caching**: Some tasks have their own internal caching behavior. In these cases, configuration can quickly become complicated to make Turborepo's cache and the application cache work together.\n\nWhile these situations are rare, be sure to test the behavior of your projects to determine if disabling caching in specific places provides a performance benefit.\n\nNow that you've seen how Turborepo's caching makes your repository faster, let's take a look at how to develop applications and libraries in your Turborepo.",
  "title": "Caching | Turborepo",
  "description": "Learn about caching in Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/core-concepts/internal-packages",
  "markdown": "# Internal Packages | TurborepoTurborepoTurborepoTurborepoVercel\n\nInternal Packages are libraries whose source code is inside your Workspace. You can quickly make Internal Packages to share code within your monorepo and choose to [publish them to the npm registry](https://turbo.build/repo/docs/guides/publishing-libraries) if you need to later.\n\nInternal Packages are used in your repository by installing them in `package.json` similar to an external package coming from the npm registry. However, instead of marking a version to install, you can reference the package using your package manager's workspace installation syntax:\n\nIn the [Creating an Internal Package guide](https://turbo.build/repo/docs/crafting-your-repository/creating-an-internal-package), you can build an Internal Package from the beginning using [the Compiled Package strategy](#compiled-packages). On this page, we'll describe other strategies for creating Internal Packages and their tradeoffs, including [publishing the package to the npm registry](#publishable-packages) to create an External Package.\n\nYou can then import the package into your code like you're used to doing with an external package:\n\n./apps/web/app/page.tsx\n\nDepending on what you need from your library, you can choose one of three compilation strategies:\n\n*   [**Just-in-Time Packages**](#just-in-time-packages): Create minimal configuration for your package by allowing application bundlers to compile the package as it uses it.\n*   [**Compiled Packages**](#compiled-packages): With a moderate amount of configuration, compile your package using a build tool like `tsc` or a bundler.\n*   [**Publishable Packages**](#publishable-packages): Compile and prepare a package to publish to the npm registry. This approach requires the most configuration.\n\n### [Just-in-Time Packages](#just-in-time-packages)\n\nA Just-in-Time package is compiled by the application that uses it. This means you can use your TypeScript (or uncompiled JavaScript) files directly, requiring much less configuration than the other strategies on this page.\n\nThis strategy is most useful when:\n\n*   Your applications are built using a modern bundler like Turbopack, webpack, or Vite.\n*   You want to avoid configuration and setup steps.\n*   You're satisfied with your applications' build times, even when you can't hit cache for the package.\n\nA `package.json` for a Just-in-Time package may look like this one:\n\n./packages/ui/package.json\n\nThere are a few important things to notice in this `package.json`:\n\n*   **Directly exporting TypeScript**: The `exports` field marks the entrypoints for the package and, in this case, you're **referencing TypeScript files directly**. This is possible because the bundler for the application will compile the code as it uses it in its build process.\n*   **No `build` script**: Because this package is exporting TypeScript, it doesn't need a build step for transpiling the package. This means you don't have to configure a build tool in this package to make it work in your Workspace.\n\n#### [Limitations and tradeoffs](#limitations-and-tradeoffs)\n\n*   **Only applicable when consumers do transpiling**: This strategy can only be used when the package is going to be used in tooling that uses a bundler or natively understands TypeScript. The consumer's bundler is responsible for transpiling the TypeScript packages to JavaScript. If your builds or other usages of the package are not able to consume TypeScript, you will need to move to the [Compiled Packages](#compiled-packages) strategy.\n*   **No TypeScript `paths`**: A library that is being transpiled by its consumer cannot use the `compilerOptions.paths` configuration because TypeScript assumes that source code is being transpiled in the package where it is written. If you're using Typescript 5.4 or later, we recommend [using Node.js subpath imports](https://devblogs.microsoft.com/typescript/announcing-typescript-5-4/#auto-import-support-for-subpath-imports).\n*   **Turborepo cannot cache a build for a Just-in-Time Package**: Because the package doesn't have its own `build` step, it can't be cached by Turborepo. This tradeoff may make sense for you if you want to keep configuration to a minimum and are okay with the build times for your applications.\n\n### [Compiled Packages](#compiled-packages)\n\nA Compiled Package is a package that handles its own compilation using a build tool, like [`tsc` (the TypeScript compiler)](https://www.typescriptlang.org/docs/handbook/compiler-options.html#handbook-content).\n\n./packages/ui/package.json\n\nCompiling your library produces compiled JavaScript outputs into a directory (`dist`, `build`, etc.) that you will use for the entrypoints for your package. The build outputs will be cached by Turborepo once they're added to the [`outputs` key of the task](https://turbo.build/repo/docs/reference/configuration#outputs), allowing you to have faster build times.\n\n#### [Limitations and tradeoffs](#limitations-and-tradeoffs-1)\n\n*   **Using the TypeScript compiler**: The majority of Compiled Packages should use `tsc`. Since the package is highly likely to be consumed by an application that is using a bundler, the application's bundler will prepare the library package for distribution in the application's final bundles, handling polyfilling, downleveling, and other concerns. A bundler should only be used if you have a specific use case that requires it, like bundling static assets into your package's outputs.\n*   **More configuration**: Compiled Packages require deeper knowledge and configuration to create build outputs. There are [many configurations for the TypeScript compiler](https://www.typescriptlang.org/docs/handbook/compiler-options.html#compiler-options) that can be difficult to manage and understand. You can find some of our recommendations in [our dedicated TypeScript guide](https://turbo.build/repo/docs/guides/tools/typescript).\n\n### [Publishable packages](#publishable-packages)\n\nPublishing a package to the npm registry comes with the most strict requirements of the packaging strategies on this page. Because you don't know anything about how your package will be used by consumers who download the package from the registry, you may find it difficult due to the numerous configurations required for a robust package.\n\nAdditionally, the process of publishing a package to the npm registry requires specialized knowledge and tooling. We recommend [`changesets`](https://github.com/changesets/changesets) for managing versioning, changelogs, and the publishing process.\n\nFor a detailed guide, visit [our Publishing packages guide](https://turbo.build/repo/docs/guides/publishing-libraries).",
  "title": "Internal Packages | Turborepo",
  "description": "Learn how to build Internal Packages in your monorepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/crafting-your-repository/developing-applications",
  "markdown": "# Developing applications | TurborepoTurborepoTurborepoTurborepoVercel\n\nDeveloping applications in a monorepo unlocks powerful workflows, enabling you to make atomic commits to source control with easy access to code.\n\nMost development tasks are long-running tasks that watch for changes to your code. Turborepo enhances this experience with a powerful terminal UI and other capabilities like:\n\n*   [Configuration for `dev` tasks](#configuring-development-tasks)\n*   [Interacting with tasks](#using-the-terminal-ui)\n*   [Watch Mode](#watch-mode)\n*   [Running setup scripts](#running-setup-tasks-before-dev)\n*   [Filtering tasks to run a subset of your packages](#running-a-specific-application)\n\nDefining a development task in `turbo.json` tells Turborepo that you'll be running a long-lived task. This is useful for things like running a development server, running tests, or building your application.\n\nTo register a `dev` task, add it to your `turbo.json` with two properties:\n\n./turbo.json\n\n*   **\"cache\": false**: Tells Turborepo to not attempt to cache the results of the task. Since this is a development task, you're likely to be making frequent changes to your code, so caching the results is not useful.\n*   **\"persistent\": true**: Tells Turborepo to keep the task running until you stop it. This key serves as a signal for your terminal UI to treat the task as long-running and interactive. Additionally, it prevents you from accidentally depending on a task that will not exit.\n\nYou can now run your `dev` task to start your development scripts in parallel:\n\nTerminal\n\n### [Running setup tasks before `dev`](#running-setup-tasks-before-dev)\n\nYou may also want to run scripts that set up your development environment or pre-build packages. You can make sure those tasks run before the `dev` task with `dependsOn`:\n\n./turbo.json\n\nIn this example, we're using a [Root Task](https://turbo.build/repo/docs/crafting-your-repository/configuring-tasks#registering-root-tasks) but you can use the same idea for [arbitrary tasks in packages](https://turbo.build/repo/docs/crafting-your-repository/configuring-tasks#depending-on-a-specific-task-in-a-specific-package).\n\n### [Running a specific application](#running-a-specific-application)\n\nThe `--filter` flag allows you to pick a subset of your [Package Graph](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#package-graph) so you can run your `dev` task for a specific application and its dependencies:\n\nTerminal\n\n→ `watch` reference\n\nMany tools have a built-in watcher, like [`tsc --watch`](https://www.typescriptlang.org/docs/handbook/compiler-options.html#compiler-options), that will respond to changes in your source code. However, some don't.\n\n`turbo watch` adds a dependency-aware watcher to any tool. Changes to source code will follow [the Task Graph](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#task-graph) that you've described in `turbo.json`, just like all your other tasks.\n\nFor example, using a package structure like [`create-turbo`](https://turbo.build/repo/docs/reference/create-turbo) with the following tasks and scripts:\n\nWhen you run `turbo watch dev lint`, you'll see the `lint` scripts are re-run whenever you make source code changes, despite ESLint not having a built-in watcher. `turbo watch` is also aware of internal dependencies, so a code change in `@repo/ui` will re-run the task in both `@repo/ui` and `web`.\n\nThe Next.js development server in `web` and the TypeScript Compiler's built-in watcher in `@repo/ui` will continue to work as usual, since they are marked with `persistent`.\n\n### [Teardown tasks](#teardown-tasks)\n\nIn some cases, you may want to run a script when the `dev` task is stopped. Turborepo is unable to run those teardown scripts when exiting because `turbo` exits when your `dev` tasks exit.\n\nInstead, create a `turbo dev:teardown` script that you run separately after you've exited your primary `turbo dev` task.\n\nOnce you have a version of your application that you'd like to deploy, it's time to learn how to configure environment variables in Turborepo.",
  "title": "Developing applications | Turborepo",
  "description": "Learn how to develop applications in your repository.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/crafting-your-repository/using-environment-variables",
  "markdown": "# Using environment variables | TurborepoTurborepoTurborepoTurborepoVercel\n\nEnvironment variable inputs are a vital part of your applications that you'll need to account for in your Turborepo configuration.\n\nThere are three important questions when working with environment variables in Turborepo:\n\n*   [Are my environment variables accounted for in the task hash?](#adding-environment-variables-to-task-hashes)\n*   [Which Environment Mode will `turbo` use?](#environment-modes)\n*   [Have I handled my `.env` files?](#handling-env-files)\n\nFailing to account for environment variables in your configuration can result in shipping your application with the wrong configuration. This can cause serious issues like shipping your preview deployments to production.\n\nGood to know:\n\nTurborepo also uses [System Environment Variables](https://turbo.build/repo/docs/reference/system-environment-variables) to configure its own behavior. Below, you'll find information about environment variables for your task's runtime and how they affect task hashing.\n\nTurborepo needs to be aware your environment variables to account for changes in application behavior. To do this, use the `env` and `globalEnv` keys in your `turbo.json` file.\n\n./turbo.json\n\n*   **globalEnv**: Changes to the values of any environment variables in this list will change the hash for all tasks.\n*   **env**: Includes changes to the values of environment variables that affect the task, allowing for better granularity. For example, a `lint` task probably doesn't need to miss cache when the value of `API_KEY` changes, but a `build` task likely should.\n\nGood to know:\n\nTurborepo supports wildcards for environment variables so you can easily account for all environment variables with a given prefix. Visit [the API reference for `env`](https://turbo.build/repo/docs/reference/configuration#wildcards) for more.\n\n### [Framework Inference](#framework-inference)\n\nTurborepo automatically adds prefix wildcards to your [`env`](https://turbo.build/repo/docs/reference/configuration#env) key for common frameworks. If you're using one of the frameworks below in a package, you don't need to specify environment variables with these prefixes:\n\n| Framework | `env` wildcard |\n| --- | --- |\n| Astro | `PUBLIC_*` |\n| Blitz | `NEXT_PUBLIC_*` |\n| Create React App | `REACT_APP_*` |\n| Gatsby | `GATSBY_*` |\n| Next.js | `NEXT_PUBLIC_*` |\n| Nuxt.js | `NUXT_*` |\n| RedwoodJS | `REDWOOD_ENV_*` |\n| Sanity Studio | `SANITY_STUDIO_*` |\n| Solid | `VITE_*` |\n| SvelteKit | `VITE_*` |\n| Vite | `VITE_*` |\n| Vue | `VUE_APP_*` |\n\nGood to know:\n\nFramework inference is per-package.\n\nIf you'd like to opt out of Framework Inference, you can do so by:\n\n*   Running your tasks with `--framework-inference=false`\n*   Adding a negative wildcard to the `env` key (for example, `\"env\": [\"!NEXT_PUBLIC_*\"]`)\n\nTurborepo's Environment Modes allow you to control which environment variables are available to a task at runtime:\n\n*   [Strict Mode](#strict-mode) (Default): Filter environment variables to **only** those that are specified in the `env` and `globalEnv` keys in `turbo.json`.\n*   [Loose Mode](#loose-mode): Allow all environment variables for the process to be available.\n\n### [Strict Mode](#strict-mode)\n\nStrict Mode filters the environment variables available to a task's runtime to **only** those that are specified in the `globalEnv` and `env` keys in `turbo.json`.\n\nThis means that tasks that do not account for all of the environment variables that they need are likely to fail. This is a good thing, since you don't want to cache a task that can potentially have different behavior in a different environment.\n\nCache safety with Strict Mode\n\nWhile Strict Mode makes it much more likely for your task to fail when you haven't accounted for all of your environment variables, it doesn't guarantee task failure. If your applicaton is able to gracefully handle a missing environment variable, you could still successfully complete tasks and get unintended cache hits.\n\n#### [Passthrough variables](#passthrough-variables)\n\nIn advanced use cases, you may want to make some environment variables available to a task without including them in the hash. Changes to these variables don't affect task outputs but still need to be available for the task to run successfully.\n\nFor these cases, add those environment variables to [`globalPassThroughEnv`](https://turbo.build/repo/docs/reference/configuration#globalpassthroughenv) and [`passThroughEnv`](https://turbo.build/repo/docs/reference/configuration#passthroughenv).\n\n#### [CI vendor compatibility](#ci-vendor-compatibility)\n\nStrict Mode will filter out environment variables that come from your CI vendors until you've accounted for them using `env` or `globalEnv`.\n\nIf any of these variables are important to your build and aren't included by [Framework Inference](#framework-inference), make sure they are in your `turbo.json` configuration.\n\n### [Loose Mode](#loose-mode)\n\nLoose Mode does not filter your environment variables according to your `globalEnv` and `env` keys. This makes it easier to get started with incrementally migrating to Strict Mode.\n\nUse [the `--env-mode` flag](https://turbo.build/repo/docs/reference/run#--env-mode-option) to enable Loose Mode on any invocation where you're seeing environment variables cannot be found by your scripts:\n\nTerminal\n\nAs long as the environment variable is available when `turbo` is ran, your script will be able to use it. However, this also **lets you accidentally forget to account for an environment variable in your configuration much more easily**, allowing the task to hit cache when it shouldn't.\n\nFor example, you may have some code in your application that fetches data from an API, using an environment variable for the base URL:\n\n./apps/web/data-fetcher.ts\n\nYou then build your application using a value for `MY_API_URL` that targets your preview environment. When you're ready to ship your application, you build for production and see a cache hit - even though the value of the `MY_API_URL` variable has changed! `MY_API_URL` changed - but Turborepo restored a version of your application from cache that uses the preview environment's `MY_API_URL` rather than production's.\n\nWhen you're using Loose Mode, `MY_API_URL` is available in the task runtime **even though it isn't accounted for in the task hash**. To make this task more likely to fail and protect you from this misconfiguration, we encourage you to opt for [Strict Mode](#strict-mode).\n\n`.env` files are great for working on an application locally. **Turborepo does not load .env files into your task's runtime**, leaving them to be handled by your framework, or tools like [`dotenv`](https://www.npmjs.com/package/dotenv).\n\nHowever, it's important that `turbo` knows about changes to values in your `.env` files so that it can use them for hashing. If you change a variable in your `.env` files between builds, the `build` task should miss cache.\n\nTo do this, add the files to the [`inputs`](https://turbo.build/repo/docs/reference/configuration#inputs) key:\n\n./turbo.json\n\n`.env` files can load variables into the task runtime even when the environment variables have not been added to [the `env` key](https://turbo.build/repo/docs/reference/configuration#env). Ensure that you add your environment variables for your builds the `env` key for CI and production builds.\n\n### [Use `.env` files in packages](#use-env-files-in-packages)\n\nUsing a `.env` file at the root of the repository is not recommended. Instead, we recommend placing your `.env` files into the packages where they're used.\n\nThis practice more closely models the runtime behavior of your applications since environment variables exist in each application's runtime individually. Additionally, as your monorepo scales, this practice makes it easier to manage each application's environment, preventing environment variable leakage across applications.\n\n### [Use `eslint-config-turbo`](#use-eslint-config-turbo)\n\n[The `eslint-config-turbo` package](https://turbo.build/repo/docs/reference/eslint-config-turbo) helps you find environment variables that are used in your code that aren't listed in your `turbo.json`. This helps ensure that all your environment variables are accounted for in your configuration.\n\n### [Avoid creating or mutating environment variables at runtime](#avoid-creating-or-mutating-environment-variables-at-runtime)\n\nTurborepo hashes the environment variables for your task at the beginning of the task. If you create or mutate environment variables during the task, Turborepo will not know about these changes and will not account for them in the task hash.\n\nFor instance, Turborepo will not be able to detect the inline variable in the example below:\n\n./apps/web/package.json\n\n`MY_VARIABLE` is being added to the environment _after_ the `dev` task has started, so `turbo` will not be able to use it for hashing.\n\nBelow are examples of proper environment variable configuration for a few popular frameworks:\n\n### [Use `--summarize`](#use---summarize)\n\n[The `--summarize` flag](https://turbo.build/repo/docs/reference/run#--summarize) can be added to your `turbo run` command to produce a JSON file summarizing data about your task. Checking the diff for the `globalEnv` and `env` key can help you identify any environment variables that may be missing from your configuration.\n\nOnce you've accounted for your environment variables, you're ready to start building the CI pipelines that build, check, and deploy your applications, at the speed of `turbo`.",
  "title": "Using environment variables | Turborepo",
  "description": "Learn how to handle environments for your applications.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/core-concepts/package-and-task-graph",
  "markdown": "# Package and Task Graphs | TurborepoTurborepoTurborepoTurborepoVercel\n\nThe Package Graph is the structure of your monorepo created by your package manager. When you install [Internal Packages](https://turbo.build/repo/docs/core-concepts/internal-packages) into each other, Turborepo will automatically identify those dependency relationships to build a foundational understanding of your Workspace.\n\nThis sets the groundwork for the Task Graph, where you'll define how **tasks** relate to each other.\n\nIn `turbo.json`, you express how tasks relate to each other. You can think of these relationships as dependencies between tasks, but we have a more formal name for them: the Task Graph.\n\nTurborepo uses a data structure called a [directed acyclic graph (DAG)](https://en.wikipedia.org/wiki/Directed_acyclic_graph) to understand your repository and its tasks. A graph is made up of \"nodes\" and \"edges\". In the Task Graph, the nodes are tasks and the edges are the dependencies between tasks. A _directed_ graph indicates that the edges connecting each node have a direction, so if Task A points to Task B, we can say that Task A depends on Task B. The direction of the edge depends on which task depends on which.\n\nFor example, let's say you have a monorepo with an application in `./apps/web` that depends on two packages: `@repo/ui` and `@repo/utils`:\n\nYou also have a `build` task that depends on `^build`:\n\n./turbo.json\n\nTurborepo will build a task graph like this:\n\n![Task graph visualization. The diagram has one node at the top named \"apps/web\" with two lines that connect to other nodes, \"packages/ui\" and \"packages/utils\" respectively.](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fsimple-task-graph.c5703ea4.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\n### [Transit Nodes](#transit-nodes)\n\nA challenge when building a Task Graph is handling nested dependencies. For example, let's say your monorepo has a `docs` app that depends on the `ui` package, which depends on the `core` package:\n\nLet's assume the `docs` app and the `core` package each have a `build` task, but the `ui` package does not. You also have a `turbo.json` that configures the `build` task the same way as above with `\"dependsOn\": [\"^build\"]`. When you run `turbo run build`, what would you expect to happen?\n\nTurborepo will build this Task Graph:\n\n![A Task Graph visualization with a Transit Node. The diagram has one node at the top named \"apps/doc\" with a line that connects to a \"packages/ui\" node. This node does not have a \"build\" task. The \"packages/ui\" node has another line to a \"packages/core\" node that does have a \"build\" task.](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftransitive-nodes.abfdfc63.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nYou can think of this graph in a series of steps:\n\n*   The `docs` app only depends on `ui`.\n*   The `ui` package does **not** have a build script.\n*   The `ui` package's _dependencies_ have a `build` script, so the task graph knows to include those.\n\nTurborepo calls the `ui` package a Transit Node in this scenario, because it doesn't have its own `build` script. Since it doesn't have a `build` script, Turborepo won't execute anything for it, but it's still part of the graph for the purpose of including its own dependencies.\n\n#### [Transit Nodes as entry points](#transit-nodes-as-entry-points)\n\nWhat if the `docs/` package didn't implement the `build` task? What would you expect to happen in this case? Should the `ui` and `core` packages still execute their build tasks? Should _anything_ happen here?\n\nTurborepo's mental model is that all nodes in the Task Graph are the same. In other words, Transit Nodes are included in the graph regardless of where they appear in the graph. This model can have unexpected consequences. For example, let's say you've configured your `build` task to depend on `^test`:\n\n./turbo.json\n\nLet's say your monorepo has many apps and many packages. All packages have `test` tasks, but only one app has a `build` task. Turborepo's mental model says that when you run `turbo run build`, even if an app doesn't implement `build` the `test` task of all packages that are dependencies will show up in the graph.",
  "title": "Package and Task Graphs | Turborepo",
  "description": "Turborepo builds a Task Graph based on your configuration and repository structure.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides",
  "markdown": "# Guides | TurborepoTurborepoTurborepoTurborepoVercel\n\nTurborepo works with your favorite frameworks, CI providers, tools, and use cases.\n\nIn our community-supported guides, you'll find examples of how to use `turbo` with the rest of your tooling.",
  "title": "Guides | Turborepo",
  "description": "Learn how to use your favorite tooling in a Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/crafting-your-repository/constructing-ci",
  "markdown": "# Constructing CI | TurborepoTurborepoTurborepoTurborepoVercel\n\nTurborepo speeds up builds, lints, tests, and any other tasks that you need to do in your Continuous Integration pipelines. Through parallelization and [Remote Caching](https://turbo.build/repo/docs/core-concepts/remote-caching), Turborepo makes your CI dramatically faster.\n\nFor examples of how to connect your CI vendor to Remote Cache and run tasks, visit our [CI guides](https://turbo.build/repo/docs/guides/ci-vendors).\n\nTo enable Remote Caching for your CI, setup the environment variables for Turborepo to access your Remote Cache.\n\n| Environment Variable | Description |\n| --- | --- |\n| `TURBO_TOKEN` | The Bearer token to access the Remote Cache |\n| `TURBO_TEAM` | The account name associated with your repository |\n\nWhen you run tasks through `turbo`, your CI will be able to hit cache, speeding up your pipelines.\n\nBy [installing `turbo` globally](https://turbo.build/repo/docs/getting-started/installation#global-installation) onto your development and CI machines, you can use one mental model to run your entire repository, from development to ship. The tasks that you've registered in your `turbo.json` will work exactly the same in CI.\n\n*   For more information on how to set up tasks, visit the [Configuring Tasks](https://turbo.build/repo/docs/crafting-your-repository/configuring-tasks) page.\n*   For examples of running tasks in CI, visit our [CI guides](https://turbo.build/repo/docs/guides/ci-vendors).\n\n### [Filtering for entry points](#filtering-for-entry-points)\n\nYou can filter your tasks using [the `--filter` flag](https://turbo.build/repo/docs/reference/run#--filter-string) exactly the same as when you're working with `turbo` locally. Filtering by packages, directories, and Git history are all supported in CI.\n\nUsing Git history in CI\n\nFiltering using source control changes is only possible when history is available on the machine. If you are using shallow clones, history will not be available.\n\nDocker is an important part of many deployment pipelines. [Turborepo's `prune` subcommand](https://turbo.build/repo/docs/reference/prune) helps you ship lightweight images by removing unnecessary dependencies and code from your images.\n\nFor more on how to deploy from a Turborepo with Docker, visit [the dedicated Docker guide](https://turbo.build/repo/docs/guides/tools/docker).\n\nUsing Turborepo's built-in caching is a great way to speed up your CI. We encourage you to start by relying on Turborepo's caching and parallelization when you're starting out with Turborepo.\n\nAs your codebase and CI grow, you may start to look for more ways to get even faster. While hitting cache is useful, you also may be able to skip work entirely. Using `turbo-ignore`, you can skip lengthy container preparation steps like dependency installation that will end up resulting in a cache hit, anyway.\n\n### [Checkout the repository](#checkout-the-repository)\n\nStart by cloning your repository. Note that a clone with history to the cloning depth you plan on using is necessary for comparisons.\n\n### [Run `turbo-ignore` for the package and task](#run-turbo-ignore-for-the-package-and-task)\n\nBy default, `turbo-ignore` will use the `build` task in the current working directory.\n\n*   To check for changes to a different task, use the `--task` flag.\n*   To check for changes for a specific package and its dependencies, add the package's name as an argument.\n\n### [Handle the result](#handle-the-result)\n\nIf changes are detected in the package or its [Internal Dependencies](https://turbo.build/repo/docs/core-concepts/internal-packages), `turbo` will exit with a `1` status code. If no changes are detected, it will exit with `0`.\n\nUsing this status code, you can choose what the rest of your CI pipeline should do. For instance, a `1` exit code likely means that you should move forward with installing dependencies and running tasks.\n\nFor more advanced use cases, see the [`turbo-ignore` reference](https://turbo.build/repo/docs/reference/turbo-ignore).\n\n### [Rely on caching](#rely-on-caching)\n\nTurborepo's caching abilities allow you to create fast CI pipelines with minimal complexity. Through [Remote Caching](https://turbo.build/repo/docs/core-concepts/remote-caching) and using the `--filter` flag to target packages for builds, Turborepo will handle change detection for large monorepos with little overhead.\n\nFor example, your CI could run these two commands to quickly handle quality checks and build your target application:\n\n*   `turbo run lint check-types test`: Run quality checks for your entire repository. Any packages that haven't changed will hit cache.\n*   `turbo build --filter=web`: Build the `web` package using the `build` task you've registered in `turbo.json`. If the `web` package or its dependencies haven't changed, the build will also hit cache.\n\nAs your codebase scales, you may find more specific opportunities to optimize your CI - but relying on caching is a great place to start.\n\n### [Global `turbo` in CI](#global-turbo-in-ci)\n\nUsing global `turbo` is convenient in CI workflows, allowing you to easily run commands specific to your CI and take advantage of [Automatic Workspace Scoping](https://turbo.build/repo/docs/crafting-your-repository/running-tasks#automatic-package-scoping).\n\nHowever, in some cases, you may be running `turbo` commands or scripts that use `turbo` **before installing packages with your package manager**. One example of this is [using `turbo prune` to create a Docker image](https://turbo.build/repo/docs/guides/tools/docker#example). In this situation, global `turbo` will not be able to use the version from `package.json` because the binary for that version hasn't been installed yet.\n\nFor this reason, we encourage you to **pin your global installation of `turbo` in CI to the major version in `package.json`** since breaking changes will not be introduced within a major version. You could additionally opt for added stability by pinning an exact version, trading off for maintenance burden to receive bug fixes in patch releases.\n\n### [Use `turbo run` in CI](#use-turbo-run-in-ci)\n\n`turbo run` is the most common command you will use when working in your Turborepo so it is aliased to `turbo` for convenience. While this is great for working locally, there are other subcommands for `turbo` like [`turbo prune`](https://turbo.build/repo/docs/reference/prune) and [`turbo generate`](https://turbo.build/repo/docs/reference/generate).\n\nWe're always working to make `turbo` better so we may add more subcommands in the future. For this reason, you can prevent naming collisions by using `turbo run` in your CI.\n\nAs an example, if you have a `turbo deploy` command in your CI pipelines, it may conflict with a potential `deploy` subcommand built directly into the `turbo` CLI. To avoid this, use `turbo run deploy` in your CI pipeline instead.\n\n### [Hitting cache results in broken builds](#hitting-cache-results-in-broken-builds)\n\nIf your task is **passing when you miss cache but failing when you hit cache**, you likely haven't configured [the `outputs` key](https://turbo.build/repo/docs/reference/configuration#outputs) for your task correctly.\n\n### [Deployment using the wrong environment variables](#deployment-using-the-wrong-environment-variables)\n\nIf you haven't defined the `env` or `globalEnv` keys for your task, Turborepo will not be able to use them when creating hashes. This means your task can hit cache despite being in a different environment.\n\nCheck your configuration for the `env` and `globalEnv` keys.\n\nYou now have everything you need to ship applications with Turborepo. To learn more about specific use cases, [check the Guides](https://turbo.build/repo/docs/guides) or [dive deeper into core concepts](https://turbo.build/repo/docs/core-concepts).",
  "title": "Constructing CI | Turborepo",
  "description": "Learn how Turborepo can help you efficiently complete all the necessary tasks and accelerate your development workflow.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/ci-vendors",
  "markdown": "# Continuous Integration | TurborepoTurborepoTurborepoTurborepoVercel\n\nTurborepo not only speeds up builds, but also the rest of your Continuous Integration pipeline by using [Remote Caching](https://turbo.build/repo/docs/core-concepts/remote-caching). Below are a few platform recipes to use Turborepo with your CI providers.\n\n## [General Setup](#general-setup)\n\nTo enable Remote Caching for your CI:\n\n1.  Setup the environment variables for Turborepo in your CI to access your Remote Cache.\n    \n    | Variable | Description |\n    | --- | --- |\n    | `TURBO_TOKEN` | The Bearer token to access the Remote Cache |\n    | `TURBO_TEAM` | The account name associated with your repository |\n    \n2.  Clone your repository.\n    \n3.  Install your dependencies through your package manager.\n    \n4.  Run your tasks through `turbo`.",
  "title": "Continuous Integration | Turborepo",
  "description": "Recipes for using Turborepo with Vercel, GitHub Actions, and other continuous integration providers.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/crafting-your-repository/upgrading",
  "markdown": "# Upgrading | TurborepoTurborepoTurborepoTurborepoVercel\n\n### [Update `turbo.json`](#update-turbojson)\n\nGet started upgrading from 1.x to 2.0 by running:\n\nThis will update your `turbo.json`(s) for many of the breaking changes from 1.x to 2.0.\n\nAdditionally, a `name` field will be added to any `package.json` in the Workspace that doesn't have one.\n\nGood to know:\n\nYou may also manually run each codemod individually. Visit [the codemods page](https://turbo.build/repo/docs/reference/turbo-codemod#turborepo-2x) for more information.\n\n### [Add a `packageManager` field to root `package.json`](#add-a-packagemanager-field-to-root-packagejson)\n\n[The `packageManager` field](https://nodejs.org/api/packages.html#packagemanager) is a convention from the Node.js ecosystem that defines which package manager is expected to be used in the Workspace.\n\nTurborepo 2.0 requires that your Workspace define this field as a way to improve the stability and behavioral predictability of your codebase. If you do not have one already, add this field to your root `package.json`:\n\n### [Update `turbo run` commands](#update-turbo-run-commands)\n\nTurborepo 2.0 includes behavioral and correctness improvements with behavior of `turbo run` commands. Listed below is the summary of changes, which may or may not have an affect on your codebase:\n\n*   Strict Mode for environment variables is now the default, moving from Loose Mode ([PR](https://github.com/vercel/turbo/pull/8182))\n    *   → If it appears that the scripts in your tasks are missing environment variables, you can opt back out of this behavior using [the `--env-mode` option](https://turbo.build/repo/docs/reference/run#--env-mode-option) on a per-command basis to incrementally migrate. We encourage you to update [the `env` key](https://turbo.build/repo/docs/reference/configuration#env) in your task to account for all of its environment variables so you can drop the `--env-mode` option as soon as possible.\n*   Workspace root directory is now an implicit dependency of all packages ([PR](https://github.com/vercel/turbo/pull/8202))\n    *   → The repository should have as little code in the root as possible, since changes to the root can affect all tasks in your repository. Additionally, if you're using Internal Packages in the Workspace root, changes to those dependencies will also cause cache misses for all tasks. In both cases, consider moving the code out of the root and [into a package](https://turbo.build/repo/docs/crafting-your-repository/structuring-a-repository).\n*   `--ignore` removed in favor of `--filter` and graph correctness changes below ([PR](https://github.com/vercel/turbo/pull/8201))\n*   Removed `--scope` flag (deprecated since 1.2) ([PR](https://github.com/vercel/turbo/pull/7970))\n*   `engines` field in root `package.json` is now used in hashing ([PR](https://github.com/vercel/turbo/pull/8173))\n*   `--filter` no longer infers namespaces for package names ([PR](https://github.com/vercel/turbo/pull/8137))\n*   `--filter` now errors when no package names or directories are matched ([PR](https://github.com/vercel/turbo/pull/8142))\n*   `--only` restricts task dependencies instead of package dependencies ([PR](https://github.com/vercel/turbo/pull/8163))",
  "title": "Upgrading | Turborepo",
  "description": "Learn how to upgrade `turbo` to get the latest improvements to your repository.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/frameworks",
  "markdown": "# Frameworks | TurborepoTurborepoTurborepoTurborepoVercel\n\nTurborepo works with **any framework**. Below, you'll find guides for the most common frameworks being used with Turborepo.",
  "title": "Frameworks | Turborepo",
  "description": "Integrate your favorite framework into Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/configuration",
  "markdown": "# Configuring turbo.json | TurborepoTurborepoTurborepoTurborepoVercel\n\nConfigure the behavior of `turbo` by adding a `turbo.json` file in your Workspace's root directory.\n\nChanging your root `turbo.json` file will invalidate the cache for all tasks because it's considered in [the global hash](https://turbo.build/repo/docs/crafting-your-repository/caching#global-hash-inputs). If you'd like the flexibility to change configuration without impacting the global hash, use [Package Configurations](https://turbo.build/repo/docs/reference/package-configurations).\n\n### [`extends`](#extends)\n\n./apps/web/turbo.json\n\nExtend from the root `turbo.json` to create specific configuration for a package using [Package Configurations](https://turbo.build/repo/docs/reference/package-configurations).\n\n*   The only valid value for `extends` is `[\"//\"]` to inherit configuration from the root `turbo.json`.\n*   If `extends` is used in the root `turbo.json`, it will be ignored.\n\n### [`globalDependencies`](#globaldependencies)\n\n./turbo.json\n\nA list of globs that you want to include in all task hashes. **If any file matching these globs changes, all tasks will miss cache.** Globs are relative to the location of `turbo.json`.\n\nBy default, all files in source control in the Workspace root are included in the global hash.\n\nGlobs must be in the repository's source control root. Globs outside of the repository aren't supported.\n\n### [`globalEnv`](#globalenv)\n\n./turbo.json\n\nA list of environment variables that you want to impact the hash of all tasks. Any change to these environment variables will cause all tasks to miss cache.\n\nFor more on wildcard and negation syntax, [see the `env` section](#env).\n\n### [`globalPassThroughEnv`](#globalpassthroughenv)\n\n./turbo.json\n\nA list of environment variables that you want to make available to tasks. Using this key opts all tasks into [Strict Environment Variable Mode](https://turbo.build/repo/docs/crafting-your-repository/using-environment-variables#strict-mode).\n\nAdditionally, Turborepo has a built-in set of global passthrough variables for common cases, like operating system environment variables. This includes variables like `HOME`, `PATH`, `APPDATA`, `SHELL`, `PWD`, and more. The full list can be found [in the source code](https://github.com/vercel/turbo/blob/main/crates/turborepo-lib/src/task_hash.rs).\n\nPassthrough values do not contribute to hashes for caching\n\nIf you want changes in these variables to cause cache misses, you will need to include them in [`env`](#env) or [`globalEnv`](#globalenv).\n\n### [ui](#ui)\n\nDefault: `\"stream\"`\n\nSelect a terminal UI for the repository.\n\n`\"tui\"` allows for viewing each log at once and interacting with the task. `\"stream\"` outputs logs as they come in and is not interactive.\n\nTerminal\n\n### [`tasks`](#tasks)\n\nEach key in the `tasks` object is the name of a task that can be executed by [`turbo run`](https://turbo.build/repo/docs/reference/run). Turborepo will search the packages described in your [Workspace's configuration](https://turbo.build/repo/docs/crafting-your-repository/structuring-a-repository#specifying-packages-in-a-monorepo) for scripts in `package.json` with the name of the task.\n\nUsing the rest of the configuration described in the task, Turborepo will run the scripts in the described order, caching logs and file outputs in [the `outputs` key](#outputs) when provided.\n\nIn the example below, we've defined three tasks under the `tasks` key: `build`, `test`, and `dev`.\n\n./turbo.json\n\nUsing the options available in the tasks you define in `tasks`, you can describe how `turbo` will run your tasks.\n\n### [`dependsOn`](#dependson)\n\nA list of tasks that are required to complete before the task begins running.\n\nThere are three types of `dependsOn` relationships: [dependency relationships](#dependency-relationships), [same-package relationships](#same-package-relationships), and [arbitrary task relationships](#arbitrary-task-relationships).\n\n#### [Dependency relationships](#dependency-relationships)\n\nPrefixing a string in `dependsOn` with a `^` tells `turbo` that the task must wait for tasks in the package's dependencies to complete first. For example, in the `turbo.json` below:\n\n./turbo.json\n\n`turbo` starts at the \"bottom\" of the package graph and recursively visits each package until it finds a package with no internal dependencies. It will then run the `build` task at the end of the dependency chain first, working its way back to the \"top\" until all `build` tasks are completed in order.\n\n#### [Same package relationships](#same-package-relationships)\n\nTask names without the `^` prefix describe a task that depends on a different task within the same package. For example, in the `turbo.json` below:\n\n./turbo.json\n\nThe `test` task will only run after the `lint` and `build` tasks have completed **in the same package**.\n\n#### [Arbitrary task relationships](#arbitrary-task-relationships)\n\nSpecify a task dependency between specific package tasks.\n\n./turbo.json\n\nIn this `turbo.json`, the `web#lint` task will wait for the `utils#build` task to complete.\n\n### [`env`](#env)\n\nThe list of environment variables a task depends on.\n\n./turbo.json\n\nGood to know:\n\nTurborepo automatically includes environment variables prefixed by common frameworks through [Framework Inference](https://turbo.build/repo/docs/crafting-your-repository/using-environment-variables#framework-inference). For example, if your package is a Next.js project, you do not need to specify any environment variables that [start with `NEXT_PUBLIC_`](https://nextjs.org/docs/basic-features/environment-variables#exposing-environment-variables-to-the-browser).\n\n#### [Wildcards](#wildcards)\n\nTurborepo supports wildcards for environment variables so you can easily account for all environment variables with a given prefix. For example, the `turbo.json` below include all environment variables that start with `MY_API_` into the hash:\n\n./turbo.json\n\n#### [Negation](#negation)\n\nA leading `!` means that the entire pattern will be negated. For instance, the `turbo.json` below will ignore the `MY_API_URL` variable.\n\n./turbo.json\n\n#### [Examples](#examples)\n\n| Pattern | Description |\n| --- | --- |\n| `\"*\"` | Matches every environment variable. |\n| `\"!*\"` | Excludes every environment variable. |\n| `\"FOO*\"` | Matches `FOO`, `FOOD`, `FOO_FIGHTERS`, etc. |\n| `\"FOO\\*\"` | Resolves to `\"FOO*\"` and matches `FOO`, `FOOD`, and `FOO_FIGHTERS`. |\n| `\"FOO\\\\*\"` | Matches a single environment variable named `FOO*`. |\n| `\"!FOO*\"` | Excludes all environment variables that start with `FOO`. |\n| `\"\\!FOO\"` | Resolves to `\"!FOO\"`, and excludes a single environment variable named `!FOO`. |\n| `\"\\\\!FOO\"` | Matches a single environment variable named `!FOO`. |\n| `\"FOO!\"` | Matches a single environment variable named `FOO!`. |\n\n### [`passThroughEnv`](#passthroughenv)\n\nAn allowlist of environment variables that should be made available to this task's runtime, even when in [Strict Environment Mode](https://turbo.build/repo/docs/crafting-your-repository/using-environment-variables#strict-mode).\n\n./turbo.json\n\nValues provided in `passThroughEnv` do not contribute to the cache key for the task. If you'd like changes to these variables to cause cache misses, you will need to include them in [`env`](#env) or [`globalEnv`](#globalenv).\n\n### [`outputs`](#outputs)\n\nA list of file glob patterns relative to the package's `package.json` to cache when the task is successfully completed.\n\nOmitting this key or passing an empty array tells `turbo` to cache nothing (except logs, which are always cached when caching is enabled).\n\n./turbo.json\n\n### [`cache`](#cache)\n\nDefault: `true`\n\nDefines if task outputs should be cached. Setting `cache` to false is useful for long-running development tasks and ensuring that a task always runs when it is in the task's execution graph.\n\n./turbo.json\n\n### [`inputs`](#inputs)\n\nDefault: `[]`, all files in the package that are checked into source control\n\nA list of file glob patterns relative to the package's `package.json` to consider when determining if a package has changed. `turbo.json` is **always** considered an input.\n\nVisit the [file glob specification](https://turbo.build/repo/docs/reference/globs) for more information on globbing syntax.\n\n./turbo.json\n\nUsing the `inputs` key opts you out of `turbo`'s default behavior of considering `.gitignore`. You must reconstruct the globs from `.gitignore` as desired or use `$TURBO_DEFAULT$` to build off of the default behavior.\n\n#### [`$TURBO_DEFAULT$`](#turbo_default)\n\nBecause specifying an `inputs` key immediately opts out of the default behavior, you may use the special string `$TURBO_DEFAULT$` within the `inputs` array to restore `turbo`'s default behavior. This allows you to tweak the default behavior for more granularity.\n\n./turbo.json\n\n### [`outputLogs`](#outputlogs)\n\nDefault: `full`\n\nSet output logging verbosity. Can be overridden by the [`--output-logs`](https://turbo.build/repo/docs/reference/run#--output-logs) CLI option.\n\n| Option | Description |\n| --- | --- |\n| `full` | Displays all logs |\n| `hash-only` | Only show the hashes of the tasks |\n| `new-only` | Only show logs from cache misses |\n| `errors-only` | Only show logs from task failures |\n| `none` | Hides all task logs |\n\n./turbo.json\n\n### [`persistent`](#persistent)\n\nDefault: `false`\n\nLabel a task as `persistent` to prevent other tasks from depending on long-running processes. Persistent tasks are made [interactive](#interactive) by default.\n\nBecause a long-running process won't exit, tasks that would depend on it would never run. Once you've labeled the task as persistent, `turbo` will throw an error if other tasks depend on it.\n\nThis option is most useful for development servers or other \"watch\" tasks.\n\n./turbo.json\n\nTasks marked with `persistent` are also `interactive` by default.\n\n### [`interactive`](#interactive)\n\nDefault: `false` (Defaults to `true` for tasks marked as `persistent`)\n\nLabel a task as `interactive` to make it accept inputs from `stdin` in the terminal UI. Must be used with `persistent`.\n\nThis task is most useful for scripts that can be manipulated while they are running, like Jest or Vitest.\n\n./turbo.json",
  "title": "Configuring turbo.json | Turborepo",
  "description": "Learn how to configure Turborepo through `turbo.json`.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference",
  "markdown": "# Turborepo API reference | TurborepoTurborepoTurborepoTurborepoVercel\n\nTurborepo's API reference is broken up into the following sections:\n\nOptions that require a value can be passed with an equals sign, using quotes when spaces are needed.\n\nTerminal\n\n### [`--color`](#--color)\n\nForces the use of color, even in non-interactive terminals. This is useful for enabling color output in CI environments like GitHub Actions that have support for rendering color.\n\n### [`--no-color`](#--no-color)\n\nSuppresses color in terminal output, even in interactive terminals.\n\n### [`--no-update-notifier`](#--no-update-notifier)\n\nDisables the update notification. This notification will be automatically disabled when running in CI environments, but can also be disabled manually via this flag.\n\nAlternatively, you can disable the notification using [the `TURBO_NO_UPDATE_NOTIFIER` environment variable](https://turbo.build/repo/docs/reference/system-environment-variables).",
  "title": "Turborepo API reference | Turborepo",
  "description": "Learn about Turborepo's APIs using the reference.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/tools",
  "markdown": "# Tools | TurborepoTurborepoTurborepoTurborepoVercel\n\nTurborepo works with **all of your favorite tooling**. Below, you'll find guides for the most common tools being used with Turborepo.",
  "title": "Tools | Turborepo",
  "description": "Learn how to use your favorite tools in a monorepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/system-environment-variables",
  "markdown": "# System environment variables | TurborepoTurborepoTurborepoTurborepoVercel\n\nBy setting certain environment variables, you can change Turborepo's behavior. This can be useful for creating specific configurations for different environments and machines.\n\nSystem environment variables are always overridden by flag values provided directly to your `turbo` commands.\n\n| Variable | Description |\n| --- | --- |\n| `TURBO_API` | Set the base URL for [Remote Cache](https://turbo.build/repo/docs/core-concepts/remote-caching). |\n| `TURBO_BINARY_PATH` | Manually set the path to the `turbo` binary. By default, `turbo` will automatically discover the binary so you should only use this in rare circumstances. |\n| `TURBO_CACHE_DIR` | Sets the cache directory, similar to using [`--cache-dir`](https://turbo.build/repo/docs/reference/run#--cache-dir-path) flag |\n| `TURBO_CI_VENDOR_ENV_KEY` | Set a prefix for environment variables that you want **excluded** from [Framework Inference](https://turbo.build/repo/docs/crafting-your-repository/using-environment-variables#framework-inference). |\n| `TURBO_DOWNLOAD_LOCAL_ENABLED` | Enables global `turbo` to install the correct local version if one is not found. |\n| `TURBO_FORCE` | Always force all tasks to run in full, opting out of all caching. |\n| `TURBO_GLOBAL_WARNING_DISABLED` | Disable warning when global `turbo` cannot find a local version to use. |\n| `TURBO_LOG_ORDER` | Set the [log order](https://turbo.build/repo/docs/reference/run#--log-order-option). Allowed values are `grouped` and `default`. |\n| `TURBO_LOGIN` | Set the URL used to log in to [Remote Cache](https://turbo.build/repo/docs/core-concepts/remote-caching). |\n| `TURBO_NO_UPDATE_NOTIFIER` | Remove the update notifier that appears when a new version of `turbo` is available. You can also use `NO_UPDATE_NOTIFIER` per ecosystem convention. |\n| `TURBO_PREFLIGHT` | Enables sending a preflight request before every cache artifact and analytics request. The follow-up upload and download will follow redirects. Only applicable when [Remote Caching](https://turbo.build/repo/docs/core-concepts/remote-caching) is configured. |\n| `TURBO_REMOTE_CACHE_READ_ONLY` | Prevent writing to the [Remote Cache](https://turbo.build/repo/docs/core-concepts/remote-caching) - but still allow reading. |\n| `TURBO_REMOTE_CACHE_SIGNATURE_KEY` | Sign artifacts with a secret key. For more information, visit [the Artifact Integrity section](https://turbo.build/repo/docs/core-concepts/remote-caching#artifact-integrity-and-authenticity-verification). |\n| `TURBO_REMOTE_CACHE_TIMEOUT` | Set a timeout in seconds for `turbo` to get artifacts from [Remote Cache](https://turbo.build/repo/docs/core-concepts/remote-caching). |\n| `TURBO_REMOTE_ONLY` | Always ignore the local filesystem cache for all tasks. |\n| `TURBO_RUN_SUMMARY` | Generate a [Run Summary](https://turbo.build/repo/docs/reference/run#--summarize) when you run tasks. |\n| `TURBO_TEAM` | The account name associated with your repository. When using [Vercel Remote Cache](https://vercel.com/docs/monorepos/remote-caching#vercel-remote-cache), this is your team's slug. |\n| `TURBO_TEAMID` | The account identifier associated with your repository. When using [Vercel Remote Cache](https://vercel.com/docs/monorepos/remote-caching#vercel-remote-cache), this is your team's ID. |\n| `TURBO_TELEMETRY_MESSAGE_DISABLED` | Disable the message notifying you that [Telemetry](https://turbo.build/repo/docs/telemetry) is enabled. |\n| `TURBO_TOKEN` | The Bearer token for authentication to access [Remote Cache](https://turbo.build/repo/docs/core-concepts/remote-caching). |\n| `TURBO_UI` | Enables TUI when passed true or 1, disables when passed false or 0. |\n\nTurborepo will make the following environment variables available within your tasks while they are executing:",
  "title": "System environment variables | Turborepo",
  "description": "Learn about system variables used by Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/generating-code",
  "markdown": "# Generating code | TurborepoTurborepoTurborepoTurborepoVercel\n\nSplitting your monorepo into packages is a great way to organize your code, speed up tasks, and improve the local development experience. With Turborepo's code generation, it's easy to generate new source code for packages, modules, and even individual UI components in a structured way that integrates with the rest of your repository.\n\nAdd a new, empty app or package to your monorepo.\n\nTerminal\n\nView all available [options](https://turbo.build/repo/docs/reference/generate#workspace) for `gen workspace`.\n\nYou can use an existing workspace as a template for your new app or package. This works for both workspaces within your existing monorepo, and remote workspaces from other repositories (specified via GitHub URL).\n\n### [Examples](#examples)\n\nCreate a new package in your monorepo by copying from an existing package in your repo.\n\nTerminal\n\nCreate a new workspace in your monorepo by copying from a remote package.\n\nTerminal\n\n**Note**: When adding from a remote source, Turborepo is unable to verify that your repo has all of the required dependencies, and is using the correct package manager. In this case, some manual modifications may be required to get the new workspace working as expected within your repository.\n\nView all available [options](https://turbo.build/repo/docs/reference/generate#workspace) for `gen workspace --copy`.\n\nIf a built-in generator does not fit your needs, you can create your own custom generator using [Plop](https://plopjs.com/) configurations. Turborepo will automatically detect any generator configurations within your repo, and make them available to run from the command line.\n\nWhile Turborepo Generators are built on top of Plop, they don't require `plop` to be installed as a dependency in your repo.\n\nWhile Turborepo understands all Plop configuration options and features, it provides a few additional features to improve the experience of writing generators within a repo configured with Turborepo.\n\n1.  Generators are automatically discovered, loaded, and organized per workspace (no need to manually `load` them within a single configuration file)\n2.  Generators are automatically run from the root of the workspace where they are defined\n3.  Generators can be invoked from anywhere within your repo (or outside out it via the [`--root`](https://turbo.build/repo/docs/reference/generate#--root-path) flag)\n4.  Typescript generators are supported with zero configuration\n5.  `plop` is not required to be installed as a dependency of your repo\n\nKnown issue\n\nESM dependencies are not currently supported within custom generators.\n\n### [Getting started](#getting-started)\n\nTo build and run a custom generator, run the following command from anywhere within your monorepo using Turborepo.\n\nTerminal\n\nYou'll be prompted to select an existing generator or to create one if you don't have any yet. You can also create your configuration manually at `turbo/generators/config.ts` (or `config.js`) at the root of your repo - or within _any_ workspace.\n\nIf you are using Typescript, you will need to install [the `@turbo/gen` package](https://github.com/vercel/turbo/tree/main/packages/turbo-gen) as a `devDependency` to access the required TS types.\n\nFor example, the following illustrates a monorepo with three locations for generators:\n\nGenerators created within workspaces are automatically run from the workspace root, **not** the repo root, nor the location of the generator configuration.\n\nThis makes your generators more simple to write. Creating a file at `[workspace-root]` only needs to be specified as `<file>` rather than `../../<file>`.\n\nLearn more about [creating custom generators using Plop](https://plopjs.com/documentation/#creating-a-generator).\n\n### [Writing generators](#writing-generators)\n\nA generator configuration file is a function that returns a [Plop](https://plopjs.com/) configuration object. The configuration object is used to define the generator's prompts, and actions.\n\nIn its simplest form, a generator configuration file looks like:\n\nturbo/generators/config.ts\n\n#### [Prompts](#prompts)\n\nPrompts are written using [Plop prompts](https://plopjs.com/documentation/#using-prompts) and are used to gather information from the user.\n\n#### [Actions](#actions)\n\nActions can use [built-in Plop actions](https://plopjs.com/documentation/#built-in-actions), or [custom action functions](https://plopjs.com/documentation/#functionsignature-custom-action) that you define yourself:\n\nturbo/generators/config.ts\n\n### [Running generators](#running-generators)\n\nOnce you have created your generator configuration file, you can skip the selection prompt and directly run a specified generator with:\n\nTerminal\n\nArguments can also be passed directly to the generator prompts using `--args`\n\nTerminal\n\nSee [bypassing prompts](https://plopjs.com/documentation/#bypassing-prompts) in the Plop documentation for more information.\n\nView all available [options](https://turbo.build/repo/docs/reference/generate#run-generator-name) for `gen`.",
  "title": "Generating code | Turborepo",
  "description": "Learn how to generate code using Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/package-configurations",
  "markdown": "# Package Configurations | TurborepoTurborepoTurborepoTurborepoVercel\n\nMany monorepos can declare a `turbo.json` in the root directory with a [task description](https://turbo.build/repo/docs/reference/configuration#tasks) that applies to all packages. But, sometimes, a monorepo can contain packages that need to configure their tasks differently.\n\nTo accommodate this, Turborepo enables you to extend the root configuration with a `turbo.json` in any package. This flexibility enables a more diverse set of apps and packages to co-exist in a Workspace, and allows package owners to maintain specialized tasks and configuration without affecting other apps and packages of the monorepo.\n\nTo override the configuration for any task defined in the root `turbo.json`, add a `turbo.json` file in any package of your monorepo with a top-level `extends` key:\n\n./apps/my-app/turbo.json\n\nFor now, the only valid value for the `extends` key is `[\"//\"]`. `//` is a special name used to identify the root directory of the monorepo.\n\nConfiguration in a package can override any of [the configurations for a task](https://turbo.build/repo/docs/reference/configuration#defining-tasks). Any keys that are not included are inherited from the extended `turbo.json`.\n\n### [Different frameworks in one Workspace](#different-frameworks-in-one-workspace)\n\nLet's say your monorepo has multiple [Next.js](https://nextjs.org/) apps, and one [SvelteKit](https://kit.svelte.dev/) app. Both frameworks create their build output with a `build` script in their respective `package.json`. You _could_ configure Turborepo to run these tasks with a single `turbo.json` at the root like this:\n\n./turbo.json\n\nNotice that both `.next/**` and `.svelte-kit/**` need to be specified as [`outputs`](https://turbo.build/repo/docs/reference/configuration#outputs), even though Next.js apps do not generate a `.svelte-kit` directory, and vice versa.\n\nWith Package Configurations, you can instead add custom configuration in the SvelteKit package in `apps/my-svelte-kit-app/turbo.json`:\n\n./apps/my-svelte-kit-app/turbo.json\n\nand remove the SvelteKit-specific [`outputs`](https://turbo.build/repo/docs/reference/configuration#outputs) from the root configuration:\n\n./turbo.json\n\nThis not only makes each configuration easier to read, it puts the configuration closer to where it is used.\n\n### [Specialized tasks](#specialized-tasks)\n\nIn another example, say that the `build` task in one package `dependsOn` a `compile` task. You could universally declare it as `dependsOn: [\"compile\"]`. This means that your root `turbo.json` has to have an empty `compile` task entry:\n\n./turbo.json\n\nWith Package Configurations, you can move that `compile` task into the `apps/my-custom-app/turbo.json`,\n\n./apps/my-app/turbo.json\n\nand remove it from the root:\n\n./turbo.json\n\nNow, the owners of `my-app`, can have full ownership over their `build` task, but continue to inherit any other tasks defined at the root.\n\nAt first glance, Package Configurations may sound a lot like the [`package#task` syntax](https://turbo.build/repo/docs/crafting-your-repository/configuring-tasks#depending-on-a-specific-task-in-a-specific-package) in the root `turbo.json`. The features are similar, but have one significant difference: when you declare a package-specific task in the root `turbo.json`, it _completely_ overwrites the baseline task configuration. With a Package Configuration, the task configuration is merged instead.\n\nConsider the example of the monorepo with multiple Next.js apps and a Sveltekit app again. Without a package-specific task, you might configure your root `turbo.json` like this:\n\n./turbo.json\n\nIn this example, `my-sveltekit-app#build` completely overwrites `build` for the Sveltekit app, so `outputLogs` and `inputs` also need to be duplicated.\n\nWith Package Configurations, `outputLogs` and `inputs` are inherited, so you don't need to duplicate them. You only need to override `outputs` in `my-sveltekit-app` config.\n\nAlthough there are no plans to remove package-specific task configurations, we expect that Package Configurations can be used for most use cases instead.\n\nAlthough the general idea is the same as the root `turbo.json`, Package Configurations come with a set of guardrails that can prevent packages from creating potentially confusing situations.\n\n### [Package Configurations cannot use](#package-configurations-cannot-use-the-workspacetask-syntax-as-task-entries) [the `workspace#task` syntax](https://turbo.build/repo/docs/crafting-your-repository/running-tasks) as task entries\n\nThe `package` is inferred based on the location of the configuration, and it is not possible to change configuration for another package. For example, in a Package Configuration for `my-nextjs-app`:\n\n./apps/my-nextjs-app/turbo.json\n\nNote that the `build` task can still depend on a package-specific task:\n\n./apps/my-nextjs-app/turbo.json\n\n### [Package Configurations can only override values in the `tasks` key](#package-configurations-can-only-override-values-in-the-tasks-key)\n\nIt is not possible to override [global configuration](https://turbo.build/repo/docs/reference/configuration#global-options) like `globalEnv` or `globalDependencies` in a Package Configuration. Configuration that would need to be altered in a Package Configuration is not truly global and should be configured differently.\n\n### [Root turbo.json cannot use the `extends` key](#root-turbojson-cannot-use-the-extends-key)\n\nTo avoid creating circular dependencies on packages, the root `turbo.json` cannot extend from anything. The `extends` key will be ignored.\n\nIn large monorepos, it can sometimes be difficult to understand how Turborepo is interpreting your configuration. To help, we've added a `resolvedTaskDefinition` to the [Dry Run](https://turbo.build/repo/docs/reference/run#--dry----dry-run) output. If you run `turbo run build --dry-run`, for example, the output will include the combination of all `turbo.json` configurations that were considered before running the `build` task.",
  "title": "Package Configurations | Turborepo",
  "description": "Learn how to use Package Configurations to bring greater task flexibility to your monorepo's package.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/skipping-tasks",
  "markdown": "# Skipping tasks | TurborepoTurborepoTurborepoTurborepoVercel\n\n[Caching](https://turbo.build/repo/docs/crafting-your-repository/caching) dramatically speeds up your tasks - but you may be able to go even faster by using `npx turbo-ignore`. If a workspace is unaffected by your code changes, you can completely skip executing a task altogether.\n\nLet's say you want to skip the unit tests for your `web` workspace when there aren't any changes to your `web` application (or its package dependencies). If you are already using [Remote Caching](https://turbo.build/repo/docs/core-concepts/remote-caching), you will probably get a cache hit - but you would still spend time provisioning the CI container, installing `npm` dependencies, and other things that can take a while.\n\nIdeally, you would do a quick check to see if any of that work needs to happen in the first place.\n\n* * *\n\nAfter you've checked out the repo, but **before** any other work, you can take a few seconds to check that your `web` tests have changed since the parent commit.\n\nTerminal\n\nThis command will:\n\n1.  Filter for the `web` workspace.\n2.  Create the `dry` output for your `test` task compared to your parent commit.\n3.  Parse the output to determine which packages have changed.\n4.  Exit with a `1` code if changes are detected. Otherwise, exits with a `0`.\n\nWhile you may have been able to hit a `>>> FULL TURBO` cache for this task, you just saved time with all of the other setup tasks required to run your CI.\n\nTo skip unaffected work, first ensure that your Git history is available on the machine. Then, run `npx turbo-ignore`.\n\n`turbo-ignore` uses a combination of the `--filter` and `--dry=json` flags to find changes from the parent commit to the current commit to identify affected packages. By default, `turbo-ignore` finds the difference for the **build task in the current working directory**, but you can [customize this behavior with flags](#customizing-behavior).\n\nHere's an example of the command that will be built and run:\n\nTerminal\n\nNote that a dry run does not _execute_ the build task. Instead, it checks your packages to see if your code changes will affect your build (or other task) in only a few seconds.\n\nIf `turbo-ignore` finds that the task can be skipped, it will exit the process with a `0` code. If changes have been found, the process will exit with `1`.\n\nOn Vercel, the previously deployed SHA will be used instead of the parent commit.\n\nTo specify a workspace, you can add it to your command like:\n\nTerminal\n\nwhere `web` is your workspace's name running the default `build` task.\n\nIf you'd like to change the task, use the `--task` flag to specify the task for the command that `turbo-ignore` will invoke.\n\nTo use `npx turbo-ignore` on Vercel, you can use the [Ignored Build Step](https://vercel.com/docs/concepts/projects/overview#ignored-build-step) feature. Vercel will automatically infer the correct arguments to successfully run `turbo-ignore`.\n\nWhen not on Vercel, specify a commit for comparison using the `--fallback` flag.\n\nOn Vercel, you can specify the `--fallback` flag to give Vercel a git ref to compare against when the default comparison is not available. By default, Vercel compares to the most recently deployed SHA so this is useful for use cases like avoiding a deploy for the first commit to a branch.",
  "title": "Skipping tasks | Turborepo",
  "description": "Never do the same work twice.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/globs",
  "markdown": "# File glob specification | TurborepoTurborepoTurborepoTurborepoVercel\n\nFile globs are used throughout Turborepo for configuring which files to include or exclude in various contexts, allowing you to specifically define the files you want `turbo` to use.\n\n| Pattern | Description |\n| --- | --- |\n| `dist/**` | Match all files in the `dist` directory, its contents, and all sub-directories |\n| `dist/` | Match the `dist` directory and its contents |\n| `dist` | Match a file named `dist` or a `dist` directory, its contents, and all sub-directories |\n| `dist/some-dir/**` | Match all files in the `dist/some-dir` directory and all sub-directories in the current directory |\n| `!dist` | Ignore the `dist` directory and all of its contents |\n| `dist*` | Match files and directories that start with `dist` |\n| `dist/*.js` | Match all `.js` files in the `dist` directory |\n| `!dist/*.js` | Ignore all `.js` files in the `dist` directory |\n| `dist/**/*.js` | Recursively match all `.js` files in the `dist` directory and its sub-directories |\n| `../scripts/**` | Up one directory, match all files and sub-directories in the `scripts` directory |",
  "title": "File glob specification | Turborepo",
  "description": "Learn about the file glob specification used by `turbo`.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/run",
  "markdown": "# run | TurborepoTurborepoTurborepoTurborepoVercel\n\nRun tasks specified in `turbo.json`.\n\nTerminal\n\n*   **\\[tasks\\]**: Turborepo can run one or many tasks at the same time. To run a task through `turbo`, it must be specified in `turbo.json`.\n*   **\\[options\\]**: Options are used to control the behavior of the `turbo run` command. Available flag options are described below.\n*   **\\[-- \\[args passed to tasks\\]\\]**: You may also pass arguments to the underlying scripts. Note that all arguments will be passed to all tasks.\n\n### [`--cache-dir <path>`](#--cache-dir-path)\n\nDefault: `.turbo/cache`\n\nSpecify the filesystem cache directory.\n\nTerminal\n\nEnsure the directory is in your `.gitignore` when changing it.\n\n### [`--concurrency <number | percentage>`](#--concurrency-number--percentage)\n\nDefault: `10`\n\nSet/limit the maximum concurrency for task execution. Must be an integer greater than or equal to `1` or a percentage value like `50%`.\n\n*   Use `1` to force serial execution (one task at a time).\n*   Use `100%` to use all available logical processors.\n*   This option is ignored if the [`--parallel`](#--parallel) flag is also passed.\n\nTerminal\n\n### [`--continue`](#--continue)\n\nDefault: `false`\n\nContinue with task execution in the presence of an error (e.g. non-zero exit code from a task).\n\nWhen `--continue` is `true`, `turbo` will exit with the highest exit code value encountered during execution.\n\nGood to know:\n\nSpecifying [the `--parallel` flag](#--parallel) will automatically set `--continue` to `true` unless explicitly set to `false`.\n\nTerminal\n\n### [`--cwd <path>`](#--cwd-path)\n\nDefault: Directory of root `turbo.json`\n\nSet the working directory of the command.\n\nTerminal\n\n### [`--dry / --dry-run`](#--dry----dry-run)\n\nInstead of executing tasks, display details about the packages and tasks that would be run.\n\nSpecify `--dry=json` to get the output in JSON format.\n\nTask details include useful information like (list is non-exhaustive):\n\n| Field | Description |\n| --- | --- |\n| `taskId` | ID for the task, in the format of `package-name#task-name` |\n| `task` | The name of the task to be executed |\n| `package` | The package in which to run the task |\n| `hash` | The hash of the task (used for caching) |\n| `hashOfExternalDependencies` | The global hash |\n| `command` | The command used to run the task |\n| `inputs` | List of file inputs considered for hashing |\n| `outputs` | List of file outputs that were cached |\n| `dependencies` | Tasks that must run **before** this task |\n| `dependents` | Tasks that must run **after** this task |\n| `environmentVariables` | Lists of environment variables specified in `env` and `passThroughEnv` |\n\n### [`--env-mode <option>`](#--env-mode-option)\n\n`type: string`\n\nControls the available environment variables in the task's runtime.\n\nGood to know:\n\n`PATH`, `SHELL`, and `SYSTEMROOT` are always available to the task.\n\n| option | description |\n| --- | --- |\n| [strict](#strict) (Default) | Only allow explicitly listed environment variables to be available |\n| [loose](#loose) | Allow **all** environment variables to be available |\n\nTerminal\n\n#### [`strict`](#strict)\n\nOnly environment variables specified in the following keys are available to the task:\n\n*   [`env`](https://turbo.build/repo/docs/reference/configuration#env)\n*   [`passThroughEnv`](https://turbo.build/repo/docs/reference/configuration#passthroughenv)\n*   [`globalEnv`](https://turbo.build/repo/docs/reference/configuration#globalenv)\n*   [`globalPassThroughEnv`](https://turbo.build/repo/docs/reference/configuration#globalpassthroughenv)\n\nIf Strict Mode is specified or inferred, **all** tasks are run in `strict` mode, regardless of their configuration.\n\n#### [`loose`](#loose)\n\nAll environment variables on the machine are made available to the task's runtime.\n\nThis can be dangerous when environment variables are not accounted for in caching with the keys listed in `strict` above. You're much more likely to restore a version of your package with wrong environment variables from cache in `loose` mode.\n\n### [`--filter <string>`](#--filter-string)\n\nSpecify targets to execute from your repository's graph. Multiple filters can be combined to select distinct sets of targets.\n\nFilters can be combined to create combinations of packages, directories, and git commits.\n\n| Target type | Description | Example |\n| --- | --- | --- |\n| Package | Select a package by its name in `package.json`. | `turbo run build --filter=ui` |\n| Directory | Specify directories to capture a list of packages to run tasks. **When used with other filters, must be wrapped in `{}`**. | `turbo run build --filter=./apps/*` |\n| Git commits | Using Git specifiers, specify packages with source control changes. **Must be wrapped in `[]`**. | `turbo run build --filter=[HEAD^1]` |\n\nGood to know:\n\n`-F` is an alias for `--filter`.\n\n#### [Microsyntaxes for filtering](#microsyntaxes-for-filtering)\n\n*   `!`: Negate targets from the selection.\n*   `...` using packages: Select all packages in the [Package Graph](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#package-graph) relative to the target. Using `...` **before** the package name will select **dependents** of the target while using `...` **after** the package name will select **dependencies** of the target.\n*   `...` using Git commits: Select a range using `[<from commit>]...[<to commit>]`.\n*   `^`: Omit the target from the selection when using `...`.\n\nFor in-depth discussion and practical use cases of filtering, visit [the Running Tasks page](https://turbo.build/repo/docs/crafting-your-repository/running-tasks).\n\n#### [Advanced filtering examples](#advanced-filtering-examples)\n\nYou can combine multiple filters to further refine your targets. Multiple filters are combined as a **union**, meaning that the [Task Graph](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#task-graph) will include tasks that match any of the filters.\n\nTerminal\n\n### [`--force`](#--force)\n\nIgnore existing cached artifacts and re-execute all tasks.\n\nGood to know:\n\n`--force` will overwrite existing task caches.\n\nTerminal\n\nThe same behavior can also be set via [the `TURBO_FORCE` environment variable](https://turbo.build/repo/docs/reference/system-environment-variables).\n\n### [`--framework-inference`](#--framework-inference)\n\nDefault: `true`\n\nSpecify whether or not to do [Framework Inference](https://turbo.build/repo/docs/crafting-your-repository/using-environment-variables#framework-inference) for tasks.\n\nWhen `false`, [automatic environment variable inclusion](https://turbo.build/repo/docs/crafting-your-repository/using-environment-variables#framework-inference) is disabled.\n\nTerminal\n\n### [`--global-deps <file glob>`](#--global-deps-file-glob)\n\nSpecify glob of global filesystem dependencies to be hashed. Useful for `.env` and files in the root directory that impact multiple packages.\n\nTerminal\n\nWe recommend specifying file globs that you'd like to include your hashes in [the `globalDependencies` key](https://turbo.build/repo/docs/reference/configuration#globaldeps) in `turbo.json` to make sure they are always accounted for.\n\n### [`--graph <file type>`](#--graph-file-type)\n\nDefault: `jpg`\n\nThis command will generate an `svg`, `png`, `jpg`, `pdf`, `json`, `html`, or [other supported output formats](https://graphviz.org/doc/info/output.html) of the current task graph.\n\nIf [Graphviz](https://graphviz.org/) is not installed, or no filename is provided, this command prints the dot graph to `stdout`.\n\nTerminal\n\n**Known Bug**: All possible task nodes will be added to the graph at the moment, even if that script does not actually exist in a given package. This has no impact on execution, but the graph may overstate the number of packages and tasks involved.\n\n### [`--log-order <option>`](#--log-order-option)\n\nDefault: `auto`\n\nSet the ordering for log output.\n\nBy default, `turbo` will use `grouped` logs in CI environments and `stream` logs everywhere else. This flag is not applicable when using [the terminal UI](https://turbo.build/repo/docs/reference/configuration#ui).\n\nTerminal\n\n| Option | Description |\n| --- | --- |\n| `stream` | Show output as soon as it is available |\n| `grouped` | Group output by task |\n| `auto` | Turbo decides based on its own heuristics |\n\n### [`--log-prefix <option>`](#--log-prefix-option)\n\nDefault: `auto`\n\nControl the `<package>:<task>:` prefix for log lines produced when running tasks.\n\nTerminal\n\n| Option | Description |\n| --- | --- |\n| `prefix` | Force prepending the prefix to logs |\n| `none` | No prefixes |\n| `auto` | `turbo` decides based on its own heuristics |\n\n### [`--no-cache`](#--no-cache)\n\nDefault `false`\n\nDo not cache results of the task.\n\nTerminal\n\n### [`--no-daemon`](#--no-daemon)\n\nDefault: `false`\n\n`turbo` can run a background process to pre-calculate values used for determining work that needs to be done. This standalone process (daemon) is an optimization, and not required for proper functioning of `turbo`.\n\nPassing `--no-daemon` instructs `turbo` to avoid using or creating the standalone process.\n\n### [`--output-logs <option>`](#--output-logs-option)\n\nDefault: `full`\n\nSet type of output logging, overriding [`outputLogs`](https://turbo.build/repo/docs/reference/configuration#outputmode) if it's defined in `turbo.json`.\n\nTerminal\n\n| Option | Description |\n| --- | --- |\n| `full` | Displays all logs |\n| `hash-only` | Only show the hashes of the tasks |\n| `new-only` | Only show logs from cache misses |\n| `errors-only` | Only show logs from task failures |\n| `none` | Hides all task logs |\n\n### [`--only`](#--only)\n\nDefault: `false`\n\nRestricts execution to include specified tasks only.\n\n#### [Example](#example)\n\nGiven this `turbo.json`:\n\n./turbo.json\n\nTerminal\n\nThe command will _only_ execute the `test` tasks in each package. It will not run `build`.\n\nAdditionally, `--only` will only run tasks in specified packages, excluding dependencies. For example, `turbo run build --filter=web --only`, will **only** run the `build` script in the `web` package.\n\n### [`--parallel`](#--parallel)\n\nDefault: `false`\n\nRun commands in parallel across packages, ignoring the task dependency graph.\n\nTerminal\n\nThe `--parallel` flag is typically used for long-running \"dev\" or \"watch\" tasks that don't exit. Starting in `turbo@1.7`, we recommend configuring these tasks using [`persistent`](https://turbo.build/repo/docs/reference/configuration#persistent) instead.\n\n### [`--preflight`](#--preflight)\n\nOnly applicable when Remote Caching is configured. Enables sending a preflight request before every cache artifact and analytics request. The follow-up upload and download will follow redirects.\n\nTerminal\n\nThe same behavior can also be set via the `TURBO_PREFLIGHT=true` system variable.\n\n### [`--profile`](#--profile)\n\nGenerates a trace of the run in Chrome Tracing format that you can use to analyze performance.\n\nYou must provide a verbosity flag (`-v`, `-vv`, or `-vvv`) with `--profile` to produce a trace.\n\nTerminal\n\nProfiles can be viewed in a tool like [Perfetto](https://ui.perfetto.dev/).\n\n### [`--remote-cache-timeout`](#--remote-cache-timeout)\n\nDefault: `30`\n\nSet the timeout for Remote Cache operations in seconds.\n\nTerminal\n\n### [`--remote-only`](#--remote-only)\n\nDefault: `false`\n\nIgnore the local filesystem cache for all tasks, using Remote Cache for reading and caching task outputs.\n\nTerminal\n\n### [`--summarize`](#--summarize)\n\nGenerates a JSON file in `.turbo/runs` containing metadata about the run, including:\n\n*   Affected packages\n*   Executed tasks (including their timings and hashes)\n*   All the files included in the cached artifact\n\nTerminal\n\nThis flag can be helpful for debugging to determine things like:\n\n*   How `turbo` interpreted your glob syntax for `inputs` and `outputs`\n*   What inputs changed between two task runs to produce a cache miss\n*   How task timings changed over time\n\n### [`--token`](#--token)\n\nA bearer token for Remote Caching. Useful for running in non-interactive shells in combination with the `--team` flag.\n\nTerminal\n\nThis value can also be set using [the `TURBO_TOKEN` system variable](https://turbo.build/repo/docs/reference/system-environment-variables). If both are present, the flag value will override the system variable.\n\nGood to know:\n\nIf you are using [Vercel Remote Cache](https://vercel.com/docs/monorepos/remote-caching) and building your project on Vercel, you do not need to use this flag. This value will be automatically set for you.\n\n### [`--team`](#--team)\n\nThe slug of the Remote Cache team. Useful for running in non-interactive shells in combination with the `--token` flag.\n\nTerminal\n\nThis value can also be set using [the `TURBO_TEAM` system variable](https://turbo.build/repo/docs/reference/system-environment-variables). If both are present, the flag value will override the system variable.\n\n### [`--verbosity`](#--verbosity)\n\nTo specify log level, use `--verbosity=<num>` or `-v, -vv, -vvv`.\n\n| Level | Flag value | Shorthand |\n| --- | --- | --- |\n| Info | `--verbosity=1` | `-v` |\n| Debug | `--verbosity=2` | `-vv` |\n| Trace | `--verbosity=3` | `-vvv` |\n\nTerminal",
  "title": "run | Turborepo",
  "description": "API reference for the `turbo run` command",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/watch",
  "markdown": "# watch | TurborepoTurborepoTurborepoTurborepoVercel\n\nRe-run tasks in your repository, based on code changes.\n\nTerminal\n\n`turbo watch` is dependency-aware, meaning tasks will re-run in the order [configured in `turbo.json`](https://turbo.build/repo/docs/reference/configuration).\n\nWhen your script has a built-in watcher, you likely don't need to use `turbo watch`. Instead, use your script's built-in watcher and mark the task as long-running using [`\"persistent\": true`](https://turbo.build/repo/docs/reference/configuration#persistent).\n\nPersistent tasks will continue to run as usual with `turbo watch`, allowing persistent and non-persistent tasks to be run at the same time.\n\n### [Task outputs](#task-outputs)\n\nIf you have tasks that write to files checked into source control, there is a possibility that Watch Mode will run in an infinite loop. This is because Watch Mode watches your files for changes and will re-run tasks in packages that have changed. If a task creates a change, then that will trigger the task again.\n\nWatch Mode has some logic to prevent this from happening using file hashes, but it isn't foolproof. To avoid this issue, we recommend removing any task outputs from git.",
  "title": "watch | Turborepo",
  "description": "API reference for the `watch` command",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/generate",
  "markdown": "# generate | TurborepoTurborepoTurborepoTurborepoVercel\n\nExtend your Turborepo with new apps and packages.\n\nTerminal\n\n*   [`turbo generate run [generator-name]`](#run-generator-name): Run custom generators defined in your repository.\n*   [`turbo generate workspace [options]`](#workspace): Create a new package in your repository by copying an existing one or from the start.\n\nFor more information and practical use cases for writing custom generators, visit [the \"Generating code\" guide](https://turbo.build/repo/docs/guides/generating-code).\n\nGood to know:\n\n`turbo gen` is an alias for `turbo generate`. Additionally, `run` is the default command so `turbo gen` is equivalent to `turbo generate run`.\n\nRun custom generators defined in your repository.\n\nTerminal\n\n### [Flag options](#flag-options)\n\n#### [`--args`](#--args)\n\nAnswers to pass directly to the generator's prompts.\n\n#### [`--config <path>`](#--config-path)\n\nGenerator configuration file.\n\nDefault: `turbo/generators/config.js`\n\n#### [`--root <path>`](#--root-path)\n\nThe root of your repository\n\nDefault: directory with root `turbo.json`\n\nCreate a new workspace.\n\nTerminal\n\n### [Flag options](#flag-options-1)\n\n#### [`--name <name>`](#--name-name)\n\nThe name for the new workspace to be used in the `package.json` `name` key. The `name` key is the unique identifier for the package in your repository.\n\n#### [`--empty`](#--empty)\n\nCreates an empty workspace. Defaults to `true`.\n\n#### [`--copy <name>/<url>`](#--copy-nameurl)\n\nName of local workspace within your monorepo or a fully qualified GitHub URL with any branch and/or subdirectory.\n\n#### [`--destination <path>`](#--destination-path)\n\nWhere the new workspace should be created.\n\n#### [`--type <app/package>`](#--type-apppackage)\n\nThe type of workspace to create (`app` or `package`).\n\n#### [`--root <path>`](#--root-path-1)\n\nThe root of your repository. Defaults to the directory of the root `turbo.json`.\n\n#### [`--show-all-dependencies`](#--show-all-dependencies)\n\nPrevent filtering dependencies by workspace type when selecting dependencies to add.\n\n#### [`--example-path <path>`, `-p <path>`](#--example-path-path--p-path)\n\nIn a rare case, your GitHub URL might contain a branch name with a slash (e.g. `bug/fix-1`) and the path to the example (e.g. `foo/bar`). In this case, you must specify the path to the example separately.",
  "title": "generate | Turborepo",
  "description": "API reference for the `turbo generate` command",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/publishing-libraries",
  "markdown": "# Publishing libraries | TurborepoTurborepoTurborepoTurborepoVercel\n\nPublishing a package to the npm registry from a monorepo can be a smooth experience, with the right tools.\n\nWhile this guide cannot solve for every possible compiling, bundling, and publishing configuration needed for robust packages, it will explain some of the basics.\n\nYou should follow this setup if you want to publish some of your monorepo's packages to npm. If you don't need to publish to npm, you should use an [Internal Package](https://turbo.build/repo/docs/crafting-your-repository/creating-an-internal-package) instead. They're much easier to set up and use.\n\nUnlike [Internal Packages](https://turbo.build/repo/docs/crafting-your-repository/creating-an-internal-package), external packages can be deployed to [npm](https://www.npmjs.com/) _and_ used locally. In this guide, we'll bundle a package to both [ECMAScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) (`esm`) and [CommonJS modules](https://en.wikipedia.org/wiki/CommonJS) (`cjs`), the most commonly used formats on npm.\n\nLet's start with a package created using the [Internal Packages](https://turbo.build/repo/docs/crafting-your-repository/creating-an-internal-package) tutorial.\n\nThere, we created a `@repo/math` package which contained a few helper functions for adding and subtracting numbers. We've decided that this package is good enough for npm, so we're going to bundle it.\n\nWe're going to add a `build` script to `@repo/math`, using a bundler. If you're unsure which one to choose, we recommend [`tsup`](https://tsup.egoist.dev/).\n\nInstall `tsup` inside the `./packages/math` package using your package manager and then create a build script for it:\n\n./packages/math/package.json\n\n`tsup` outputs files to the `dist` directory by default, so you should:\n\n1.  Add `dist` to your `.gitignore` files to make sure they aren't committed to source control.\n2.  Add `dist` to the outputs of `build` in your `turbo.json`.\n\n./turbo.json\n\nThat way, when `tsup` is run the outputs can be [cached](https://turbo.build/repo/docs/crafting-your-repository/caching) by Turborepo.\n\nFinally, we should update our package entrypoints. Inside `package.json`, change `main` to point at `./dist/index.js` for clients using CommonJS modules (`cjs`), `module` to point at `./dist/index.mjs` for clients using ECMAScript modules (`esm`), and `types` to the type definition file - `./dist/index.d.ts`:\n\n./packages/math/package.json\n\nIt is not required to bundle to both `cjs` and `esm`. However, it is recommended, as it allows your package to be used in a wider variety of environments.\n\nIf you run into errors by using `main`, `module` and `types`, take a look at the [tsup docs](https://tsup.egoist.dev/#bundle-formats).\n\nBundling is a complicated topic, and we don't have space here to cover everything!\n\n### [Building our package before our app](#building-our-package-before-our-app)\n\nBefore we can run `turbo run build`, there's one thing we need to consider. We've just added a [task dependency](https://turbo.build/repo/docs/crafting-your-repository/running-tasks) into our monorepo. The `build` of `packages/math` needs to run **before** the `build` of `apps/web`.\n\nFortunately, we can use [`dependsOn`](https://turbo.build/repo/docs/reference/configuration#dependson) to easily configure this.\n\n./turbo.json\n\nNow, we can run `turbo run build`, and it'll automatically build our packages _before_ it builds our app.\n\n### [Setting up a dev script](#setting-up-a-dev-script)\n\nThere's a small issue with our setup. We are building our package just fine, but it's not working great in dev. Changes that we make to our `@repo/math` package aren't being reflected in our app.\n\nThat's because we don't have a `dev` script to rebuild our packages while we're working. We can add one easily:\n\n./packages/math/package.json\n\nThis passes the `--watch` flag to `tsup`, meaning it will watch for file changes.\n\nIf we've already set up [dev scripts](https://turbo.build/repo/docs/crafting-your-repository/developing-applications#configuring-development-tasks) in our `turbo.json`, running `turbo run dev` will run our `packages/math` dev task in parallel with our `apps/web` dev task.\n\nOur package is now in a spot where we can consider deploying to npm. In our [versioning and publishing](#versioning-and-publishing) section, we'll do just that.\n\nManually versioning and publishing packages in a monorepo can be tiresome. Luckily, there's a tool that makes things easy - the [Changesets](https://github.com/changesets/changesets) CLI.\n\nWe recommend Changesets because it's intuitive to use, and - just like Turborepo - fits with the monorepo tools you're already used to.\n\nSome alternatives are:\n\n*   [intuit/auto](https://github.com/intuit/auto) - Generate releases based on semantic version labels on pull requests\n*   [microsoft/beachball](https://github.com/microsoft/beachball) - The Sunniest Semantic Version Bumper\n\nOnce your package has been bundled, you can then publish it to the npm registry.\n\nWe recommend taking a look at the Changesets docs. Here's our recommended reading order:\n\n1.  [Why use changesets?](https://github.com/changesets/changesets/blob/main/docs/intro-to-using-changesets.md) - an intro that takes you through the fundamentals.\n2.  [Installation instructions](https://github.com/changesets/changesets/blob/main/packages/cli/README.md)\n3.  If you're using GitHub, consider using the [Changeset GitHub bot](https://github.com/apps/changeset-bot) - a bot to nudge you to add changesets to PR's.\n4.  You should also consider adding the [Changesets GitHub action](https://github.com/changesets/action) - a tool which makes publishing extremely easy.\n\nOnce you've started using Changesets, you'll gain access to three useful commands:\n\nTerminal\n\nLinking your publishing flow into Turborepo can make organizing your deploy a lot simpler and faster.\n\nOur recommendation is to add a `publish-packages` script into your root `package.json`:\n\n./package.json\n\nWe recommend `publish-packages` so that it doesn't conflict with npm's built-in `publish` script.\n\nThis means that when you run `publish-packages`, your monorepo gets built, linted, tested and published - and you benefit from all of Turborepo's speedups.",
  "title": "Publishing libraries | Turborepo",
  "description": "Learn how to publish libraries to the npm registry from a monorepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/reference/prune",
  "markdown": "# prune | TurborepoTurborepoTurborepoTurborepoVercel\n\nGenerate a partial monorepo for a target package. The output will be placed into a directory named `out` containing the following:\n\n*   The full source code of all internal packages needed to build the target.\n*   A pruned lockfile containing the subset of the original lockfile needed to build the target.\n*   A copy of the root `package.json`.\n\nTerminal\n\n```\nturbo prune [package]\n```\n\n### [Example](#example)\n\nStarting with a repository with the following structure:\n\npackage.json\n\npnpm-lock.yaml\n\nRun `turbo prune frontend` to generate a pruned workspace for the `frontend` application in an `out` directory:\n\npackage.json\n\npnpm-lock.yaml (partial)\n\n### [Options](#options)\n\n#### [`--docker`](#--docker)\n\nDefaults to `false`.\n\nAlter the output directory to make it easier to use with [Docker best practices and layer caching](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/). The directory will contain:\n\n*   A folder named `json` with the pruned workspace's `package.json` files.\n*   A folder named `full` with the pruned workspace's full source code for the internal packages needed to build the target.\n*   A pruned lockfile containing the subset of the original lockfile needed to build the target.\n\nUsing the same example from above, running `turbo prune frontend --docker` will generate the following:\n\npnpm-lock.yaml (partial)\n\npackage.json (from repo root)\n\npackage.json (from repo root)\n\n#### [`--out-dir <path>`](#--out-dir-path)\n\nDefaults to `./out`.\n\nCustomize the directory the pruned output is generated in.",
  "title": "prune | Turborepo",
  "description": "API reference for the `turbo prune` command",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/single-package-workspaces",
  "markdown": "# Single-package workspaces | TurborepoTurborepoTurborepoTurborepoVercel\n\nWhile Turborepo is highly effective in [multi-package workspaces](https://vercel.com/docs/vercel-platform/glossary#multi-package-workspace) (commonly referred to as monorepos), it can also be used to make [single-package workspaces](https://vercel.com/docs/vercel-platform/glossary#single-package-workspace) faster.\n\nTurborepo's most important features work in single-package workspaces including local and [Remote Caching](https://turbo.build/repo/docs/core-concepts/remote-caching) and task parallelization. Features that don't work are ones that don't make sense in the context of a single package, like package tasks (`app#build`).\n\nGood to know:\n\nExamples of single-package workspaces are the output of `npx create-next-app` or `npm create vite`.\n\nInstall `turbo` into your application:\n\n### [Running a `package.json` script using global `turbo` (optional)](#running-a-packagejson-script-using-global-turbo-optional)\n\nFor even faster developer workflows, you can [install `turbo` globally](https://turbo.build/repo/docs/getting-started/installation#installing-globally), too, and run commands directly from the command line.\n\nOnce installed, you can run `turbo build` and Turborepo will run your `build` script from `package.json`. Running `turbo build` again will hit the cache.\n\nAt this point, `turbo` is providing much value since you're likely to only be rebuilding your application when code changes and, when your code changes, `turbo` will miss the cache. In two short steps, you can get more out of `turbo`.\n\nIn many repositories, there are setup tasks or pre-build steps to run. These tasks are often run one at a time - but you can easily turn them into one script with `turbo`.\n\nFor example, let's say you have a project where we always have to set up a development environment whenever you start working. You need to:\n\n1.  Start a Docker container for a database.\n2.  Push a database schema to the database.\n3.  Seed the database with data.\n4.  Start the development server.\n\nYou can schedule these tasks into one command using Turborepo. First, create scripts in your `package.json`:\n\npackage.json\n\nThen, create tasks in `turbo.json` to run these scripts in order:\n\n./turbo.json\n\nThe `dependsOn` arrays in the tasks above create a sequential order for the tasks. When you run `turbo dev` (either as a `package.json` script or in your terminal),\n\nUsing `turbo` to parallelize tasks results in speeding up tasks by running all at once, when they can be. For instance, you can run your ESLint, TypeScript, and Prettier checks at the same time. Given scripts like:\n\n./package.json\n\nYou can create a configuration like this one:\n\nturbo.json\n\nThen, to run all tasks at the same time:\n\nTerminal\n\nBecause Turborepo will treat a single-package workspace as one package, it can help to optimize inputs to tasks to make sure unrelated changes don't create cache misses.\n\nFor instance, a script for checking types using `tsc --noEmit` can be configured with inputs that only include TypeScript files:\n\n./turbo.json",
  "title": "Single-package workspaces | Turborepo",
  "description": "Learn how to use Turborepo in a single-package workspace.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/tools/docker",
  "markdown": "# Docker | TurborepoTurborepoTurborepoTurborepoVercel\n\nBuilding a [Docker](https://www.docker.com/) image is a common way to deploy all sorts of applications. However, doing so from a monorepo has several challenges.\n\nGood to know:\n\nThis guide assumes you're using\n\n[create-turbo](https://turbo.build/repo/docs/getting-started/installation)\n\nor a repository with a similar structure.\n\n**In a monorepo, unrelated changes can make Docker do unnecessary work when deploying your app.**\n\nLet's imagine you have a monorepo that looks like this:\n\npackage.json\n\npackage-lock.json\n\nYou want to deploy `apps/api` using Docker, so you create a Dockerfile:\n\n./apps/api/Dockerfile\n\nThis will copy the root `package.json` and the root lockfile to the Docker image. Then, it'll install dependencies, copy the app source and start the app.\n\nYou should also create a `.dockerignore` file to prevent node\\_modules from being copied in with the app's source.\n\n.dockerignore\n\n### [The lockfile changes too often](#the-lockfile-changes-too-often)\n\nDocker is pretty smart about how it deploys your apps. Just like Turborepo, it tries to do as [little work as possible](https://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/).\n\nIn our Dockerfile's case, it will only run `npm install` if the files it has in its image are _different_ from the previous run. If not, it'll restore the `node_modules` directory it had before.\n\nThis means that whenever `package.json`, `apps/api/package.json` or `package-lock.json` change, the Docker image will run `npm install`.\n\nThis sounds great - until we realize something. The `package-lock.json` is _global_ for the monorepo. That means that **if we install a new package inside `apps/web`, we'll cause `apps/api` to redeploy**.\n\nIn a large monorepo, this can result in a huge amount of lost time, as any change to a monorepo's lockfile cascades into tens or hundreds of deploys.\n\nThe solution is to prune the inputs to the Dockerfile to only what is strictly necessary. Turborepo provides a simple solution - `turbo prune`.\n\nTerminal\n\nRunning this command creates a **pruned version of your monorepo** inside an `./out` directory. It only includes workspaces which `api` depends on. It also **prunes the lockfile** so that only the relevant `node_modules` will be downloaded.\n\n### [The `--docker` flag](#the---docker-flag)\n\nBy default, `turbo prune` puts all relevant files inside `./out`. But to optimize caching with Docker, we ideally want to copy the files over in two stages.\n\nFirst, we want to copy over only what we need to install the packages. When running `--docker`, you'll find this inside `./out/json`.\n\nAfterwards, you can copy the files in `./out/full` to add the source files.\n\nSplitting up **dependencies** and **source files** in this way lets us **only run `npm install` when dependencies change** - giving us a much larger speedup.\n\nWithout `--docker`, all pruned files are placed inside `./out`.\n\n### [Example](#example)\n\nOur detailed [`with-docker` example](https://github.com/vercel/turbo/tree/main/examples/with-docker) goes into depth on how to use `prune` to its full potential. Here's the Dockerfile, copied over for convenience.\n\n./apps/api/Dockerfile\n\nTo take advantage of remote caches during Docker builds, you will need to make sure your build container has credentials to access your [Remote Cache](https://turbo.build/repo/docs/core-concepts/remote-caching).\n\nThere are many ways to take care of secrets in a Docker image. We will use a simple strategy here with multi-stage builds using secrets as build arguments that will get hidden for the final image.\n\nAssuming you are using a Dockerfile similar to the one above, we will bring in some environment variables from build arguments right before `turbo build`:\n\n./apps/api/Dockerfile\n\n`turbo` will now be able to hit your Remote Cache. To see a Turborepo cache hit for a non-cached Docker build image, run a command like this one from your project root:\n\nTerminal",
  "title": "Docker | Turborepo",
  "description": "Learn how to use Docker in a monorepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/tools/typescript",
  "markdown": "# TypeScript | TurborepoTurborepoTurborepoTurborepoVercel\n\nTypeScript is an excellent tool in monorepos, allowing teams to safely add types to their JavaScript code. While there is some complexity to getting set up, this guide will walk you through the important parts of a TypeScript setup for most use cases.\n\n*   [Sharing TypeScript configuration](#sharing-tsconfigjson)\n*   [Building a TypeScript package](#building-a-typescript-package)\n*   [Making type checking faster across your workspace](https://turbo.build/repo/docs/guides/tools/typescript#linting-your-codebase)\n\nThis guide assumes you are using a recent version of TypeScript and uses some features that are only available in those versions. You may need to adjust the guidance on this page if you are unable to features from those versions.\n\nYou want to build consistency into your TypeScript configurations so that your entire repo can use great defaults and your fellow developers can know what to expect when writing code in the Workspace.\n\nTypeScript's `tsconfig.json` sets the configuration for the TypeScript compiler and features an [`extends` key](https://www.typescriptlang.org/tsconfig#extends) that you'll use to share configuration across your workspace.\n\nThis guide will use [`create-turbo`](https://turbo.build/repo/docs/reference/create-turbo) as an example.\n\n### [Use a base `tsconfig` file](#use-a-base-tsconfig-file)\n\nInside `packages/tsconfig`, we have a few `json` files which represent different ways you might want to configure TypeScript in various packages. The `base.json` file is extended by every other `package.json` in the workspace and looks like this:\n\n./packages/tsconfig/base.json\n\n[→](https://www.typescriptlang.org/tsconfig)\n\n[`tsconfig` options reference](https://www.typescriptlang.org/tsconfig)\n\n### [Creating the rest of the package](#creating-the-rest-of-the-package)\n\nThe other `tsconfig` files in this package use the `extends` key to start with the base configuration and customize for specific types of projects, like for Next.js (`nextjs.json`) and a React library (`react-library.json`).\n\nInside `package.json`, name the package so it can be referenced in the rest of the Workspace:\n\npackages/tsconfig/package.json\n\n### [Using the configuration package](#using-the-configuration-package)\n\nFirst, install the `@repo/typescript-config` package into your package:\n\nThen, extend the `tsconfig.json` for the package from the `@repo/typescript-config` package. In this example, the `web` package is a Next.js application:\n\n./apps/web/tsconfig.json\n\n### [Creating entrypoints to the package](#creating-entrypoints-to-the-package)\n\nFirst, make sure your code gets compiled with `tsc` so there will be a `dist` directory. You'll need a `build` script as well as a `dev` script:\n\n./packages/ui/package.json\n\nThen, set up the entrypoints for your package in `package.json` so that other packages can use the compiled code:\n\n./packages/ui/package.json\n\nSetting up `exports` this way has several advantages:\n\n*   Using the `types` field allows `tsserver` to use the code in `src` as the source of truth for your code's types. Your editor will always be up-to-date with the latest interfaces from your code.\n*   You can quickly add new entrypoints to your package without creating [dangerous barrel files](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js#what's-the-problem-with-barrel-files).\n*   You'll receive auto-importing suggestions for your imports across package boundaries in your editor. For more information about why you may not want to wildcard the entrypoints, see the [limitations section](https://turbo.build/repo/docs/guides/tools/typescript#package-entrypoint-wildcards).\n\nIf you're publishing the package, you cannot use references to source code in `types` since only the compiled code will be published to npm. You'll need to generate and reference declaration files and source maps.\n\nTo use TypeScript as a linter, you can check the types across your workspace **fast** using Turborepo's caching and parallelization.\n\nFirst, add a `check-types` script to any package that you want to check the types for:\n\n./apps/web/package.json\n\nThen, create a `check-types` task in `turbo.json`. From the [Configuring tasks guide](https://turbo.build/repo/docs/crafting-your-repository/configuring-tasks#dependent-tasks-that-can-be-ran-in-parallel), we can make the task run in parallel while respecting source code changes from other packages using a [Transit Node](https://turbo.build/repo/docs/core-concepts/package-and-task-graph#transit-nodes):\n\n./turbo.json\n\nThen, run your task using `turbo check-types`.\n\n### [Use `tsc` to compile your packages](#use-tsc-to-compile-your-packages)\n\nFor [Internal Packages](https://turbo.build/repo/docs/core-concepts/internal-packages), we recommend that you use `tsc` to compile your TypeScript libraries whenever possible. While you can use a bundler, it's not necessary and adds extra complexity to your build process. Additionally, bundling a library can mangle the code before it makes it to your applications' bundlers, causing hard to debug issues.\n\n### [Use Node.js subpath imports instead of TypeScript compiler `paths`](#use-nodejs-subpath-imports-instead-of-typescript-compiler-paths)\n\nIt's possible to create absolute imports in your packages using [the TypeScript compiler's `paths` option](https://www.typescriptlang.org/tsconfig#paths). However, [as of TypeScript 5.4](https://devblogs.microsoft.com/typescript/announcing-typescript-5-4/#auto-import-support-for-subpath-imports), you can use [Node.js subpath imports](https://nodejs.org/api/packages.html#imports) instead.\n\nAdditionally, Node.js subpath imports are usable in [Just-in-Time Packages](https://turbo.build/repo/docs/core-concepts/internal-packages#just-in-time-packages) while TypeScript's `compilerOptions#paths` are not.\n\nThis strategy brings your Node.js and TypeScript configurations closer together, making your project's configuration simpler.\n\n### [You likely don't need a `tsconfig.json` file in the root of your project](#you-likely-dont-need-a-tsconfigjson-file-in-the-root-of-your-project)\n\nAs mentioned in the [Structuring your repository guide](https://turbo.build/repo/docs/crafting-your-repository/structuring-a-repository#anatomy-of-a-package), you want to treat each package in your tooling as its own unit. This means each package should have its own `tsconfig.json` to use instead of referencing a `tsconfig.json` in the root of your project. Following this practice will make it easier for Turborepo to cache your type checking tasks, simplifying your configuration.\n\nThe only case in which you may want to have a `tsconfig.json` in the Workspace root is to set configuration for TypeScript files that are not in packages. For example, if you have a script written with TypeScript that you need to run from the root, you may need a `tsconfig.json` for that file.\n\nHowever, this practice is also discouraged since any changes in the Workspace root will cause all tasks to miss cache. Instead, move those scripts to a different directory in the repository.\n\n### [You likely don't need TypeScript Project References](#you-likely-dont-need-typescript-project-references)\n\nWe don't recommend using TypeScript Project References as they introduce both another point of configuration as well as another caching layer to your workspace. Both of these can cause problems in your repository with little benefit, so we suggest avoiding them when using Turborepo.\n\n### [Your editor won't use a package's TypeScript version](#your-editor-wont-use-a-packages-typescript-version)\n\n`tsserver` is not able to use different Typescript versions for different packages in your code editor. Instead, it will discover a specific version and use that everywhere.\n\nThis can result in differences between the linting errors that show in your editor and when you run `tsc` scripts to check types. If this is an issue for you, consider [keeping the TypeScript dependency on the same version](https://turbo.build/repo/docs/crafting-your-repository/managing-dependencies#keeping-dependencies-on-the-same-version).\n\n### [Package entrypoint wildcards](#package-entrypoint-wildcards)\n\nWe recommend [listing the entrypoints to your package explicitly](https://turbo.build/repo/docs/guides/tools/typescript#creating-entrypoints-to-the-package) - but, to some, this feels too verbose. Instead, you can use wildcards to capture entrypoints:\n\n./packages/ui/package.json\n\nWhile this will work, it comes with the tradeoff of not being able to auto-import across package boundaries [due to performance reasons with the TypeScript compiler](https://github.com/microsoft/TypeScript/issues/53116#issuecomment-1458887175). This tradeoff may or may not be worth it to you depending on your use case.",
  "title": "TypeScript | Turborepo",
  "description": "Learn how to use TypeScript in a monorepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/ci-vendors/circleci",
  "markdown": "# CircleCI | TurborepoTurborepoTurborepoTurborepoVercel\n\nThe following example shows how to use Turborepo with [CircleCI](https://circleci.com/).\n\nTTY on CircleCI\n\nCircleCI [uses interactive terminals (TTY)](https://discuss.circleci.com/t/reprise-allow-for-using-circle-ci-tooling-without-a-tty/23309) that crash Turborepo's terminal UI. To workaround this, set the `TURBO_UI=false` environment variable in your CircleCI configuration.\n\nFor a given root `package.json`:\n\n./package.json\n\n```\n{\n  \"name\": \"my-turborepo\",\n  \"scripts\": {\n    \"build\": \"turbo run build\",\n    \"test\": \"turbo run test\"\n  },\n  \"devDependencies\": {\n    \"turbo\": \"latest\"\n  }\n}\n```\n\nAnd a `turbo.json`:\n\n./turbo.json\n\n```\n{\n  \"$schema\": \"https://turbo.build/schema.json\",\n  \"tasks\": {\n    \"build\": {\n      \"outputs\": [\".next/**\", \"!.next/cache/**\"],\n      \"dependsOn\": [\"^build\"]\n    },\n    \"test\": {\n      \"dependsOn\": [\"^build\"]\n    }\n  }\n}\n```\n\nCreate a file called `.circleci/config.yml` in your repository with the following contents:\n\n.circleci/config.yml\n\n```\nversion: 2.1\norbs:\n  node: circleci/node@5.0.2\nworkflows:\n  test:\n    jobs:\n      - test\njobs:\n  test:\n    docker:\n      - image: cimg/node:lts\n    steps:\n      - checkout\n      - node/install-packages\n      - run:\n        command: npm run build\n        environment:\n          TURBO_UI: \"false\"\n \n      - run:\n        command: npm run test\n        environment:\n          TURBO_UI: \"false\"\n```\n\n## [Remote Caching](#remote-caching)\n\nTo use Remote Caching, retrieve the team and token for the Remote Cache for your provider. In this example, we'll use [Vercel Remote Cache](https://vercel.com/docs/monorepos/remote-caching):\n\n*   `TURBO_TOKEN` - The Bearer token to access the Remote Cache\n*   `TURBO_TEAM` - The account to which the monorepo belongs\n\nTo use Vercel Remote Caching, you can get the value of these variables in a few steps:\n\n1.  Create a Scoped Access Token to your account in the [Vercel Dashboard](https://vercel.com/account/tokens)\n\n![Vercel Access Tokens](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fvercel-create-token.fc78a20c.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nCopy the value to a safe place. You'll need it in a moment.\n\n2.  Go to your CircleCI project settings and click on the **Environment Variables** tab. Create a new secret called `TURBO_TOKEN` and enter the value of your Scoped Access Token.\n\n![CircleCI Environment Variables](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcircleci-environment-variables.77521c79.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1) ![CircleCI Create Environment Variables](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcircleci-create-environment-variables.90ea0fd3.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\n3.  Make a second secret called `TURBO_TEAM` and enter the value of your team's Vercel URL _without_ the `vercel.com/`. Your Team URL can be found inside your team's general project settings from the dashboard.\n    \n    If you're using a Hobby Plan, you can use your username. Your username can be found in your [Vercel Personal Account Settings](https://vercel.com/account)\n    \n\n![Vercel Account Slug](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fvercel-slug.adfd5060.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\n4.  CircleCI automatically loads environment variables stored in project settings into the CI environment. No modifications are necessary for the CI file.",
  "title": "CircleCI | Turborepo",
  "description": "Learn how to use CircleCI with Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/ci-vendors/vercel",
  "markdown": "# Vercel | TurborepoTurborepoTurborepoTurborepoVercel\n\n![](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fturborepo-x-vercel.fcba5df7.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nVercel's zero-config integration with Turborepo automatically understands your monorepo.\n\nTo deploy your Turborepo on Vercel, [create a new project](https://vercel.com/new) and import your code. Your projects will be pre-configured with the correct settings to use the [Vercel Remote Cache](https://vercel.com/docs/monorepos/remote-caching).\n\nFor more information about deploying your Turborepo to Vercel, [visit the Vercel documentation](https://vercel.com/docs/concepts/monorepos/turborepo).",
  "title": "Vercel | Turborepo",
  "description": "Learn how to use Turborepo on Vercel.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/ci-vendors/gitlab-ci",
  "markdown": "# GitLab CI | TurborepoTurborepoTurborepoTurborepoVercel\n\nThe following example shows how to use Turborepo with [GitLab CI](https://docs.gitlab.com/ee/ci/).\n\nFor a given root `package.json`:\n\n./package.json\n\n```\n{\n  \"name\": \"my-turborepo\",\n  \"scripts\": {\n    \"build\": \"turbo run build\",\n    \"test\": \"turbo run test\"\n  },\n  \"devDependencies\": {\n    \"turbo\": \"latest\"\n  }\n}\n```\n\nAnd a `turbo.json`:\n\n./turbo.json\n\n```\n{\n  \"$schema\": \"https://turbo.build/schema.json\",\n  \"tasks\": {\n    \"build\": {\n      \"outputs\": [\".svelte-kit/**\"],\n      \"dependsOn\": [\"^build\"]\n    },\n    \"test\": {\n      \"dependsOn\": [\"^build\"]\n    }\n  }\n}\n```\n\nCreate a file called `.gitlab-ci.yml` in your repository with the following contents:\n\n.gitlab-ci.yml\n\n```\nimage: node:latest\nstages:\n  - build\nbuild:\n  stage: build\n  script:\n    - npm install\n    - npm run build\n    - npm run test\n```\n\n## [Remote Caching](#remote-caching)\n\nTo use Remote Caching, retrieve the team and token for the Remote Cache for your provider. In this example, we'll use [Vercel Remote Cache](https://vercel.com/docs/monorepos/remote-caching):\n\n*   `TURBO_TOKEN` - The Bearer token to access the Remote Cache\n*   `TURBO_TEAM` - The account to which the monorepo belongs\n\nTo use Vercel Remote Caching, you can get the value of these variables in a few steps:\n\n1.  Create a Scoped Access Token to your account in the [Vercel Dashboard](https://vercel.com/account/tokens)\n\n![Vercel Access Tokens](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fvercel-create-token.fc78a20c.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nCopy the value to a safe place. You'll need it in a moment.\n\n2.  Go to your GitLab repository settings and click on the **Settings** and then **CI/CD** tab. Create a new variable called `TURBO_TOKEN` and enter the value of your Scoped Access Token.\n\n![GitLab CI Variables](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgitlab-ci-variables.c3272305.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1) ![GitLab CI Create Variable](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgitlab-ci-create-variable.86fd61d8.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\n3.  Make a second secret called `TURBO_TEAM` and enter the value of your team's Vercel URL _without_ the `vercel.com/`. Your Team URL can be found inside your team's general project settings from the dashboard.\n    \n    If you're using a Hobby Plan, you can use your username. Your username can be found in your [Vercel Personal Account Settings](https://vercel.com/account)\n    \n\n![Vercel Account Slug](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fvercel-slug.adfd5060.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)",
  "title": "GitLab CI | Turborepo",
  "description": "Learn how to use GitLab CI with Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/frameworks/nextjs",
  "markdown": "# Next.js | TurborepoTurborepoTurborepoTurborepoVercel\n\n[Next.js](https://nextjs.org/) is the React framework for the web. Used by some of the world's largest companies, Next.js enables you to create high-quality web applications with the power of React components.\n\nTo get started with Next.js in a Turborepo quickly, follow the [quickstart](https://turbo.build/repo/docs/getting-started/installation) to create a repository with two Next.js applications:\n\nUse [`create-next-app`](https://nextjs.org/docs/app/api-reference/create-next-app) to set up a new Next.js application in a package. From the root of your repository, run:\n\nTo add [Internal Packages](https://turbo.build/repo/docs/core-concepts/internal-packages) to your new application, install them into the app with your package manager:\n\nMake sure to run your package manager's install command. You also may need to update `scripts` in `package.json` to fit your use case in your repository.\n\n### [Customizing tasks](#customizing-tasks)\n\nBy default, the new application will use the tasks defined in the root `turbo.json`. If you'd like to configure tasks differently for the new application, use [Package Configurations](https://turbo.build/repo/docs/reference/package-configurations).",
  "title": "Next.js | Turborepo",
  "description": "Learn how to use Next.js in a monorepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/ci-vendors/github-actions",
  "markdown": "# GitHub Actions | TurborepoTurborepoTurborepoTurborepoVercel\n\nThe following example shows how to use Turborepo with [GitHub Actions](https://github.com/features/actions).\n\nFor a given root `package.json`:\n\n./package.json\n\n```\n{\n  \"name\": \"my-turborepo\",\n  \"scripts\": {\n    \"build\": \"turbo run build\",\n    \"test\": \"turbo run test\"\n  },\n  \"devDependencies\": {\n    \"turbo\": \"latest\"\n  }\n}\n```\n\nAnd a `turbo.json`:\n\n./turbo.json\n\n```\n{\n  \"$schema\": \"https://turbo.build/schema.json\",\n  \"tasks\": {\n    \"build\": {\n      \"outputs\": [\".next/**\", \"!.next/cache/**\", \"other-output-dirs/**\"],\n      \"dependsOn\": [\"^build\"]\n    },\n    \"test\": {\n      \"dependsOn\": [\"^build\"]\n    }\n  }\n}\n```\n\nCreate a file called `.github/workflows/ci.yml` in your repository with the following contents:\n\n.github/workflows/ci.yml\n\n```\nname: CI\n \non:\n  push:\n    branches: [\"main\"]\n  pull_request:\n    types: [opened, synchronize]\n \njobs:\n  build:\n    name: Build and Test\n    timeout-minutes: 15\n    runs-on: ubuntu-latest\n    # To use Remote Caching, uncomment the next lines and follow the steps below.\n    # env:\n    #  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}\n    #  TURBO_TEAM: ${{ vars.TURBO_TEAM }}\n    #  TURBO_REMOTE_ONLY: true\n \n    steps:\n      - name: Check out code\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 2\n \n      - name: Setup Node.js environment\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: 'npm'\n \n      - name: Install dependencies\n        run: npm install\n \n      - name: Build\n        run: npm run build\n \n      - name: Test\n        run: npm run test\n```\n\n## [Remote Caching](#remote-caching)\n\nTo use Remote Caching with GitHub Actions, add the following environment variables to your GitHub Actions workflow to make them available to your `turbo` commands.\n\n*   `TURBO_TOKEN` - The Bearer token to access the Remote Cache\n*   `TURBO_TEAM` - The account to which the monorepo belongs\n\nTo use Remote Caching, retrieve the team and token for the Remote Cache for your provider. In this example, we'll use [Vercel Remote Cache](https://vercel.com/docs/monorepos/remote-caching).\n\nCreate a Scoped Access Token to your account in the [Vercel Dashboard](https://vercel.com/account/tokens)\n\n![Vercel Access Tokens](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fvercel-create-token.fc78a20c.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nCopy the value to a safe place. You'll need it in a moment.\n\nGo to your GitHub repository settings and click on the **Secrets** and then **Actions** tab. Create a new secret called `TURBO_TOKEN` and enter the value of your Scoped Access Token.\n\n![GitHub Secrets](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgithub-actions-secrets.acdb7492.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1) ![GitHub Secrets Create](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgithub-actions-create-secret.30a18944.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nCreate a new repository variable (click the **Variables** tab) called `TURBO_TEAM` and enter the value of your team's Vercel URL _without_ the `vercel.com/`. Using a repository variable rather than a secret will keep GitHub Actions from censoring your team name in log output.\n\n![GitHub Repository Variables](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fvercel-team-repo-var.5ce92158.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nYour Team URL can be found inside your team's general project settings from the dashboard. If you're using a Hobby Plan, you can use your username. Your username can be found in your [Vercel Personal Account Settings](https://vercel.com/account)\n\n![Vercel Account Slug](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fvercel-slug.adfd5060.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nAt the top of your GitHub Actions workflow, provide the following environment variables to jobs that use `turbo`:\n\n.github/workflows/ci.yml\n\n```\n# ...\n \njobs:\n  build:\n    name: Build and Test\n    timeout-minutes: 15\n    runs-on: ubuntu-latest\n    # To use Turborepo Remote Caching, set the following environment variables for the job.\n    env:\n      TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}\n      TURBO_TEAM: ${{ vars.TURBO_TEAM }}\n \n    steps:\n      - name: Check out code\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 2\n    # ...\n```\n\n## [Caching with GitHub actions/cache](#caching-with-github-actionscache)\n\nThe following steps exemplify how you could use [actions/cache](https://github.com/actions/cache) to cache your monorepo artifacts on GitHub.\n\nSupply a package.json script that will run tasks using Turbo.\n\nExample `package.json` with a `build` script:\n\n./package.json\n\n```\n{\n  \"name\": \"my-turborepo\",\n  \"scripts\": {\n    \"build\": \"turbo run build\"\n  },\n  \"devDependencies\": {\n    \"turbo\": \"1.2.5\"\n  }\n}\n```\n\nConfigure your GitHub pipeline with a step which utilizes the `actions/cache@v4` action before the build steps of your CI file.\n\n*   Make sure that the `path` attribute set within the `actions/cache` action matches the output location above. In the example below, `path` was set to `.turbo`.\n*   State the cache key for the current run under the `key` attribute. In the example below, we used a combination of the runner os and GitHub sha as the cache key.\n*   State the desired cache prefix pattern under the `restore-keys` attribute. Make sure this pattern will remain valid for future ci runs. In the example below, we used the `${{ runner.os }}-turbo-` as the cache key prefix pattern to search against. This allows us to hit the cache on any subsequent ci runs despite `github.sha` changing.\n\nExample `ci` yaml with `.turbo` as chosen cache folder:\n\n.github/workflows/ci.yml\n\n```\n  jobs:\n    build:\n      runs-on: ubuntu-latest\n      steps:\n        - name: Check out code\n          uses: actions/checkout@v4\n \n        - name: Cache turbo build setup\n          uses: actions/cache@v4\n          with: \n            path: .turbo\n            key: ${{ runner.os }}-turbo-${{ github.sha }}\n            restore-keys: |\n              ${{ runner.os }}-turbo-\n \n        - name: Setup Node.js environment\n          uses: actions/setup-node@v4\n          with:\n            node-version: 20\n            cache: 'npm'\n \n        - name: Install dependencies\n          run: npm install\n \n        - name: Build\n          run: npm run build\n```",
  "title": "GitHub Actions | Turborepo",
  "description": "Learn how to use GitHub Actions with Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/frameworks/nuxt",
  "markdown": "# Nuxt | TurborepoTurborepoTurborepoTurborepoVercel\n\n[Nuxt](https://nuxt.com/) is an open source framework that makes web development intuitive and powerful.\n\nTo get started with Nuxt in a Turborepo quickly, use [the `with-vue-nuxt` example](https://github.com/vercel/turbo/tree/main/examples/with-vue-nuxt):\n\nUse [Nuxi](https://www.npmjs.com/package/nuxi), Nuxt's CLI, to set up a new Nuxt application in a package. From the root of your repository, run:\n\nTo add [Internal Packages](https://turbo.build/repo/docs/core-concepts/internal-packages) to your new application, install them into the app with your package manager:\n\nMake sure to run your package manager's install command. You also may need to update `scripts` in `package.json` to fit your use case in your repository.\n\n### [Customizing tasks](#customizing-tasks)\n\nBy default, the new application will use the tasks defined in the root `turbo.json`. If you'd like to configure tasks differently for the new application, use [Package Configurations](https://turbo.build/repo/docs/reference/package-configurations).",
  "title": "Nuxt | Turborepo",
  "description": "Learn more about using Nuxt in your monorepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/ci-vendors/travis-ci",
  "markdown": "# Travis CI | TurborepoTurborepoTurborepoTurborepoVercel\n\nThe following example shows how to use Turborepo with [Travis CI](https://www.travis-ci.com/).\n\nFor a given root `package.json`:\n\n./package.json\n\n```\n{\n  \"name\": \"my-turborepo\",\n  \"scripts\": {\n    \"build\": \"turbo run build\",\n    \"test\": \"turbo run test\"\n  },\n  \"devDependencies\": {\n    \"turbo\": \"latest\"\n  }\n}\n```\n\nAnd a `turbo.json`:\n\n./turbo.json\n\n```\n{\n  \"$schema\": \"https://turbo.build/schema.json\",\n  \"tasks\": {\n    \"build\": {\n      \"outputs\": [\".svelte-kit/**\"],\n      \"dependsOn\": [\"^build\"]\n    },\n    \"test\": {\n      \"dependsOn\": [\"^build\"]\n    }\n  }\n}\n```\n\nCreate a file called `.travis.yml` in your repository with the following contents:\n\n.travis.yml\n\n```\nlanguage: node_js\nnode_js:\n  - lts/*\ninstall:\n  - npm install\nscript:\n  - npm run build\nscript:\n  - npm run test\n```\n\n## [Remote Caching](#remote-caching)\n\nTo use Remote Caching, retrieve the team and token for the Remote Cache for your provider. In this example, we'll use [Vercel Remote Cache](https://vercel.com/docs/monorepos/remote-caching):\n\n*   `TURBO_TOKEN` - The Bearer token to access the Remote Cache\n*   `TURBO_TEAM` - The account to which the monorepo belongs\n\nTo use Vercel Remote Caching, you can get the value of these variables in a few steps:\n\n1.  Create a Scoped Access Token to your account in the [Vercel Dashboard](https://vercel.com/account/tokens)\n\n![Vercel Access Tokens](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fvercel-create-token.fc78a20c.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\nCopy the value to a safe place. You'll need it in a moment.\n\n2.  Go to your Travis repository settings and scroll down to the _Environment Variables_ section. Create a new variable called `TURBO_TOKEN` and enter the value of your Scoped Access Token.\n\n![Travis CI Variables](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftravis-ci-environment-variables.537da6d2.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\n3.  Make a second secret called `TURBO_TEAM` and enter the value of your team's Vercel URL _without_ the `vercel.com/`. Your Team URL can be found inside your team's general project settings from the dashboard.\n    \n    If you're using a Hobby Plan, you can use your username. Your username can be found in your [Vercel Personal Account Settings](https://vercel.com/account)\n    \n\n![Vercel Account Slug](https://turbo.build/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fvercel-slug.adfd5060.png&w=3840&q=75&dpl=dpl_FPQQUUKYSLEp2ERu38dXVBrpCHW1)\n\n4.  Travis CI automatically loads environment variables stored in project settings into the CI environment. No modifications are necessary for the CI file.",
  "title": "Travis CI | Turborepo",
  "description": "How to use Travis CI with Turborepo to optimize your CI workflow",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/frameworks/vite",
  "markdown": "# Vite | TurborepoTurborepoTurborepoTurborepoVercel\n\n[Vite](https://vitejs.dev/) is a build tool that aims to provide a faster and leaner development experience for modern web projects.\n\nTo get started with Vite in a Turborepo quickly, use [the `with-vite` example](https://github.com/vercel/turbo/tree/main/examples/with-vite):\n\nUse [`npm create vite`](https://vitejs.dev/guide/#scaffolding-your-first-vite-project) to set up a new Vite application in a package. From the root of your repository, run:\n\nTo add [Internal Packages](https://turbo.build/repo/docs/core-concepts/internal-packages) to your new application, install them into the app with your package manager:\n\nMake sure to run your package manager's install command. You also may need to update `scripts` in `package.json` to fit your use case in your repository.\n\n### [Customizing tasks](#customizing-tasks)\n\nBy default, the new application will use the tasks defined in the root `turbo.json`. If you'd like to configure tasks differently for the new application, use [Package Configurations](https://turbo.build/repo/docs/reference/package-configurations).",
  "title": "Vite | Turborepo",
  "description": "Learn more about using Vite in your monorepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/frameworks/sveltekit",
  "markdown": "# SvelteKit | TurborepoTurborepoTurborepoTurborepoVercel\n\n[SvelteKit](https://kit.svelte.dev/) is a framework for rapidly developing robust, performant web applications using Svelte.\n\nTo get started with SvelteKit in a Turborepo quickly, use [the `with-svelte` example](https://github.com/vercel/turbo/tree/main/examples/with-svelte):\n\nUse [`npm create svelte`](https://kit.svelte.dev/docs/creating-a-project) to set up a new SvelteKit application in a package. From the root of your repository, run:\n\nTo add [Internal Packages](https://turbo.build/repo/docs/core-concepts/internal-packages) to your new application, install them into the app with your package manager:\n\nMake sure to run your package manager's install command. You also may need to update `scripts` in `package.json` to fit your use case in your repository.\n\n### [Customizing tasks](#customizing-tasks)\n\nBy default, the new application will use the tasks defined in the root `turbo.json`. If you'd like to configure tasks differently for the new application, use [Package Configurations](https://turbo.build/repo/docs/reference/package-configurations).",
  "title": "SvelteKit | Turborepo",
  "description": "Learn more about using SvelteKit in your monorepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/tools/eslint",
  "markdown": "# ESLint | TurborepoTurborepoTurborepoTurborepoVercel\n\nESLint is a static analysis tool for quickly finding and fixing problems in your JavaScript code.\n\nGood to know:\n\nThis guide assumes you're using\n\n[create-turbo](https://turbo.build/repo/docs/getting-started/installation)\n\nor a repository with a similar structure.\n\nThis page is written for ESLint v8. If you'd like to contribute to add a version for v9, the core team is happy to review your pull request.\n\nInstall ESLint into each package where you'd like to run it:\n\nSharing an ESLint config across packages makes their source code more consistent. Let's imagine a Workspace like this:\n\nWe've got a package called `@repo/eslint-config`, and two applications, each with their own `.eslintrc.js`.\n\n### [Our `@repo/eslint-config` package](#our-repoeslint-config-package)\n\nOur `@repo/eslint-config` file contains two files, `next.js`, and `library.js`. These are two different ESLint configs, which we can use in different workspaces, depending on our needs.\n\nLet's investigate the `next.js` lint configuration:\n\n./packages/eslint-config/next.js\n\nIt's a typical ESLint config that extends the [Vercel style guide](https://github.com/vercel/style-guide), nothing fancy.\n\nThe `package.json` looks like this:\n\n./packages/eslint-config/package.json\n\nNote that the ESLint dependencies are all listed here. This is useful, since it means we don't need to re-specify the dependencies inside the apps which import `@repo/eslint-config`.\n\n### [How to use the `@repo/eslint-config` package](#how-to-use-the-repoeslint-config-package)\n\nIn our `web` app, we first need to add `@repo/eslint-config` as a dependency.\n\nWe can then import the config like this:\n\n./apps/web/.eslintrc.js\n\nBy adding `@repo/eslint-config/next.js` to our `extends` array, we're telling ESLint to look for a package called `@repo/eslint-config`, and reference the file `next.js`.\n\n### [Summary](#summary)\n\nThis setup ships by default when you [create a new monorepo](https://turbo.build/repo/docs/getting-started/create-new) with `npx create-turbo@latest`. You can also look at [our basic example](https://github.com/vercel/turbo/tree/main/examples/basic) to see a working version.\n\nThe `package.json` for each package where you'd like to run ESLint should look like this:\n\n./packages/\\*/package.json\n\nWith your scripts prepared, you can then create your Turborepo task:\n\n./turbo.json\n\nYou can now run `turbo lint` with [global `turbo`](https://turbo.build/repo/docs/getting-started/installation#global-installation) or create a script in your root `package.json`:\n\n./package.json",
  "title": "ESLint | Turborepo",
  "description": "Learn how to use ESLint in a monorepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/tools/jest",
  "markdown": "# Jest | TurborepoTurborepoTurborepoTurborepoVercel\n\n[Jest](https://jestjs.io/) is a common test runner with a vast ecosystem. Integrating with Turborepo will lead to enormous speed-ups.\n\nGood to know:\n\nThis guide assumes you're using\n\n[create-turbo](https://turbo.build/repo/docs/getting-started/installation)\n\nor a repository with a similar structure.\n\nLet's say we have a monorepo that looks like this:\n\nInstall `jest` into the packages where you plan on having test suites. For this example, we will have tests in `web` and `@repo/ui`:\n\nBoth the `apps/web` and `packages/ui` have their own test suites, so we'll add a `test` script to their `package.json`:\n\nInside the root `turbo.json`, create a `test` task:\n\n./turbo.json\n\nNow, `turbo test` can parallelize and cache all of the test suites from each package, only testing code that has changed.\n\nWhen you run your test suite normally, it completes and outputs to `stdout`. This means you can [cache it](https://turbo.build/repo/docs/crafting-your-repository/caching) with Turborepo.\n\nBut when you run your tests in a watched mode, the process never exits. This makes a watch task more like a [development task](https://turbo.build/repo/docs/crafting-your-repository/developing-applications).\n\nBecause of this difference, we recommend specifying **two separate Turborepo tasks**: one for running your tests, and one for running them in Jest's watch mode. Inside your each `package.json` file for each workspace:\n\nInside the root `turbo.json`:\n\n./turbo.json\n\nYou can now either run this task using [global `turbo`](https://turbo.build/repo/docs/getting-started/installation#installing-globally) as `turbo test:watch` or from a script in your root `package.json`:",
  "title": "Jest | Turborepo",
  "description": "Learn how to use Jest in a Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/tools/vitest",
  "markdown": "# Vitest | TurborepoTurborepoTurborepoTurborepoVercel\n\n[Vitest](https://vitest.dev/) is a test runner from the Vite ecosystem. Integrating it with Turborepo will lead to enormous speed-ups.\n\nGood to know:\n\nThis guide assumes you're using\n\n[create-turbo](https://turbo.build/repo/docs/getting-started/installation)\n\nor a repository with a similar structure.\n\nLet's say we have a monorepo that looks like this:\n\nBoth `apps/web` and `packages/ui` have their own test suite. Their `package.json` files include a `test` script that runs Vitest:\n\n./apps/web/package.json\n\nInside the root `turbo.json`, create a `test` task:\n\n./turbo.json\n\nNow, `turbo test` can parallelize and cache all of the test suites from each package, only testing code that has changed.\n\nWhen you run your test suite normally, it completes and outputs to `stdout`. This means you can [cache it](https://turbo.build/repo/docs/crafting-your-repository/caching) with Turborepo.\n\nBut when you run your tests in a watched mode, the process never exits. This makes a watch task more like a [development task](https://turbo.build/repo/docs/crafting-your-repository/developing-applications).\n\nBecause of this difference, we recommend specifying **two separate Turborepo tasks**: one for running your tests, and one for running them in watch mode. Inside your each `package.json` file for each workspace:\n\n./apps/web/package.json\n\nInside the root `turbo.json`:\n\n./turbo.json\n\nYou can now either run this task using [global `turbo`](https://turbo.build/repo/docs/getting-started/installation#installing-globally) as `turbo test:watch` or from a script in your root `package.json`:",
  "title": "Vitest | Turborepo",
  "description": "Learn how to use Vitest in a monorepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/tools/storybook",
  "markdown": "# Storybook | TurborepoTurborepoTurborepoTurborepoVercel\n\n[Storybook](https://storybook.js.org/) is a popular way to build UI components in an isolated environment. By putting Storybook into your Turborepo, you can easily develop your design system right alongside your applications.\n\nIf you'd rather use a template, this guide is walking through how to build [this Storybook/Turborepo template](https://vercel.com/templates/react/turborepo-design-system) on Vercel.\n\n### [Create a monorepo](#create-a-monorepo)\n\nIf you don't have an existing project, use [create-turbo](https://turbo.build/repo/docs/getting-started/installation) to create a new monorepo:\n\n### [Create a directory for the app](#create-a-directory-for-the-app)\n\nYou'll need a directory for the Storybook application:\n\nTerminal\n\n### [Add the Storybook application](#add-the-storybook-application)\n\nIn the `apps/storybook` directory, initialize a new Storybook application:\n\nFollow the prompts to create an application. For the rest of this guide, we'll assume React and TypeScript.\n\n### [Add your UI kit to Storybook](#add-your-ui-kit-to-storybook)\n\nNow, install your UI package into Storybook.\n\n### [Set up a story for your Button component](#set-up-a-story-for-your-button-component)\n\nDelete the stories and components found in `src/stories` that were created by the Storybook scaffolding tool. You will be making your own.\n\nAs an example, here is a story for the `Button` component from `@repo/ui/button`.\n\n./apps/storybook/src/stories/Button.stories.tsx\n\n### [Align scripts to your tasks](#align-scripts-to-your-tasks)\n\nLast, integrate the new Storybook application into your Turborepo:\n\napps/storybook/package.json\n\nThese scripts will now run with the `turbo dev` and `turbo build` tasks in your `turbo.json`.\n\nTo ensure file outputs are cached when you run `build`, add `storybook-static` to the outputs of your `turbo.json` build task:\n\nturbo.json\n\n### [Add Storybook build outputs to `.gitignore`](#add-storybook-build-outputs-to-gitignore)\n\nEnsure that the build outputs for Storybook are not committed to source control\n\n.gitignore\n\n### [Verify your configuration](#verify-your-configuration)\n\nRun `turbo build` to build the Storybook application alongside the rest of your applications.\n\nYou can also run `turbo build` again to see cache hits for your builds.\n\n### [Co-locating stories](#co-locating-stories)\n\nIf you'd prefer to co-locate your stories to their source code (rather than having them in the Storybook application), you'll need some extra configuration.\n\n#### [Re-configure Storybook sources](#re-configure-storybook-sources)\n\nIn `.storybook/main.ts`, change the `stories` paths in `config` to the directories you'd like to capture. For instance, if you'd like to write stories in the UI package:\n\n./apps/storybook/.storybook/main.ts\n\n#### [Move story files to the UI package](#move-story-files-to-the-ui-package)\n\nFollowing along with [the guide above](https://turbo.build/repo/docs/guides/tools/storybook#set-up-a-story-for-your-button-component), move the `./apps/storybook/src/stories/Button.stories.tsx` file to `./packages/ui/src/Button.stories.tsx`.\n\nUpdate components imports so that they reference the now co-located modules. For instance, in the story's imports:\n\n./packages/ui/src/Button.stories.tsx\n\nYou'll also need to install any Storybook packages required for writing stories. For example, moving the story from above would require that you install `@storybook/react` into your `@repo/ui` package.\n\n#### [Configure caching](#configure-caching)\n\nBecause stories are now in the UI package, changes to those stories can cause cache misses for any builds that depend on your UI package. However, changing a story doesn't mean your production applications should miss cache.\n\nTo prevent this, exclude stories from the inputs to your `build` task in your root `turbo.json`. You'll also need to create a `build:storybook` task, which you'll need in a moment:\n\n./turbo.json\n\nAdditionally, create a [Package Configuration](https://turbo.build/repo/docs/reference/package-configurations) in the `storybook` application so stories are **accounted for in building the Storybook application, specifically**:\n\n./apps/storybook/turbo.json\n\n#### [Rename the build script](#rename-the-build-script)\n\nLast, make sure your script to build Storybook uses the configuration we just wrote by renaming it to the name of the task:\n\napps/storybook/package.json\n\nThe script that was once `\"build\"` is now `\"build:storybook\"` to ensure the stories are included in hashes for caching.\n\n#### [Verify your configuration](#verify-your-configuration-1)\n\nTo ensure your setup is correct:\n\n1.  Run `turbo build:storybook build`. You should see cache misses.\n2.  Run `turbo build:storybook build` again. You should see all cache hits.\n3.  Make a code change **to a story** in your `@repo/ui` package.\n4.  Run `turbo build:storybook build` again. You should **only** see a cache miss for the Storybook application. All others should hit cache.\n\n### [Adding CSS](#adding-css)\n\nIf your UI package exports its own CSS, you'll need to add it to the renders in the Storybook app, similar to how you would add it to your applications. [The Storybook documentation](https://storybook.js.org/docs/configure/styling-and-css#css) recommends you add it to the `.storybook/preview.ts` file.",
  "title": "Storybook | Turborepo",
  "description": "Learn how to use Storybook in a Turborepo.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/tools/biome",
  "markdown": "# Biome | TurborepoTurborepoTurborepoTurborepoVercel\n\n[Biome](https://biomejs.dev/) is a fast formatter for JavaScript, TypeScript, JSX, and JSON that saves CI and developer time.\n\nGood to know:\n\nThis guide assumes you're using\n\n[create-turbo](https://turbo.build/repo/docs/getting-started/installation)\n\nor a repository with a similar structure.\n\nBiome is a rare exception to most tools that are used with Turborepo because it is **so extraordinarily fast**. For this reason, we recommend using a [Root Task](https://turbo.build/repo/docs/crafting-your-repository/configuring-tasks#registering-root-tasks) rather than creating separate scripts in each of your packages.\n\nCaching behavior\n\nUsing Biome at the root of the project will result in cache misses for all tasks when you upgrade Biome versions or change configuration. If you prefer the tradeoff of higher cache hit ratios in these situations over less configuration, you can still use Biome in separate scripts like the other recommendations in our guides.\n\n### [Initialize Biome](#initialize-biome)\n\nFirst, [follow the installation documentation to set up Biome](https://biomejs.dev/guides/getting-started/) in your repository. You'll then be able to create a script to use Biome in the root of your repository:\n\n./package.json\n\n### [Create a root task](#create-a-root-task)\n\nIn practice, Biome is unlikely to be a bottleneck in the iteration speed of your repository. For this reason, we can have less configuration to manage in our repository by using Biome in a [Root Task](https://turbo.build/repo/docs/crafting-your-repository/configuring-tasks#registering-root-tasks).\n\nIf you believe Biome may be faster in your repository split up into tasks in packages, you are free to do so. We encourage you to experiment with what's best for your use case.\n\nTo create a Root Task, register the scripts to Turborepo:\n\n./turbo.json\n\nYou'll now be able to run these scripts using `turbo run format-and-lint` and `turbo run format-and-lint:fix`.",
  "title": "Biome | Turborepo",
  "description": "Learn how to use Biome in your Turborepo projects.",
  "languageCode": "en"
},
{
  "url": "https://turbo.build/repo/docs/guides/tools/prisma",
  "markdown": "# Prisma | TurborepoTurborepoTurborepoTurborepoVercel\n\n[Prisma](https://www.prisma.io/) unlocks a new level of developer experience when working with databases thanks to its intuitive data model, automated migrations, type-safety & auto-completion.\n\nGood to know:\n\nThis guide assumes you're using\n\n[create-turbo](https://turbo.build/repo/docs/getting-started/installation)\n\nor a repository with a similar structure.\n\nIf you don't have an existing project, use our [quickstart](https://turbo.build/repo/docs/getting-started/installation) to create a new monorepo.\n\nCreate a new folder called `database` inside packages with a `package.json` inside:\n\npackages/database/package.json\n\nRun your package manager's install step to install the new dependencies.\n\n`cd` into `packages/database`:\n\nTerminal\n\nRun `npx prisma init`.\n\nThis should create several files inside `packages/database`:\n\n*   `schema.prisma` is where your [Prisma schema](https://www.prisma.io/docs/concepts/components/prisma-schema) lives. Here, you'll be able to modify the shape of your database.\n*   `.gitignore` adds some ignored files to git\n*   `.env` lets you manually specify your `DATABASE_URL` for prisma.\n\nAt this point, you should refer to the Prisma docs for [connecting your database to Prisma](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-typescript-postgres).\n\nOnce you've got a database connected and have a few data tables to work with, you can move on.\n\nLet's add some scripts to the `package.json` inside `packages/database`:\n\npackages/database/package.json\n\nLet's also add these scripts to `turbo.json` in the root:\n\n./turbo.json\n\nNow, run `turbo db:push db:generate` from the root of our repository to automatically migrate our database and generate our type-safe Prisma client.\n\nUse the `--skip-generate` flag on `db:push` to ensure it doesn't automatically run `prisma generate` after migrating the database. This ends up being faster when using Turborepo because it automatically parallelizes the tasks.\n\nNext, export the `@prisma/client` so it can used in your applications. Let's add an `index.ts` file to `packages/database`:\n\npackages/database/src/index.ts\n\nFollowing the [Just-in-Time packaging pattern](https://turbo.build/repo/docs/core-concepts/internal-packages#just-in-time-packages), you'll also create an entrypoint to the package inside `packages/database/package.json`.\n\npackages/database/package.json\n\nNote that you're using [the Just-in-Time Package pattern](https://turbo.build/repo/docs/core-concepts/internal-packages#just-in-time-packages) here, which assumes your application can consume TypeScript directly. You may need to adjust to a different strategy as if needed.\n\n### [Importing `database`](#importing-database)\n\nImport the database package into one of our apps.\n\nLet's say you have an app at `apps/web`. Add the dependency to `apps/web/package.json`:\n\nRun your package manager's install command.\n\nYou can now import `PrismaClient` from `database` anywhere in your app:\n\n./apps/web/app/page.tsx\n\nYou now have a reusable `@repo/db` package that you can import into any of your applications and a `turbo db:push` script to push schema changes\n\nHowever, your `db:generate` scripts aren't optimized yet. They provide crucial code to our `dev` and `build` tasks. If a new developer runs `turbo dev` on an application without running `db:generate` first, they'll get errors.\n\nSo, let's make sure that `db:generate` is always run _before_ you run `dev`:\n\n./turbo.json\n\nCheck out the section on [running tasks](https://turbo.build/repo/docs/crafting-your-repository/running-tasks) to learn more about the `^db:generate` syntax.\n\n### [Caching the results of `prisma generate`](#caching-the-results-of-prisma-generate)\n\n`prisma generate` outputs files to the filesystem, usually inside `node_modules`. In theory, it should be possible to cache the output of `prisma generate` with Turborepo to save a few seconds.\n\nHowever, Prisma behaves differently with different package managers. This can lead to unpredictable results, which might lead to broken deployments in some situations. Instead of documenting the intricacies of each approach, we recommend _not_ caching the results of `prisma generate`. Since `prisma generate` usually only takes 5-6 seconds, and tends not to take longer with larger `schema` files, this seems like a fine trade-off.\n\nYou may also wish to experiment with caching the generated files in a way that satisfies the constraints for your repository.\n\nNow that you've made it this far, you're ready to deploy your application. Depending on where your database lives, you'll want to design your deployment pipeline according to the documentation for your database's setup.\n\nThere are many factors to take into consideration from this point on, so we can't provide a one-size-fits-all solution. You likely want to visit the documentation for your database and its deployment platform to learn more.",
  "title": "Prisma | Turborepo",
  "description": "Learn how to use Prisma in a Turborepo.",
  "languageCode": "en"
}]