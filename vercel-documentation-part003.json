[
  {
    "url": "https://vercel.com/docs/beginner-sveltekit/context-api",
    "markdown": "# Context API\n\n[**Context API**View the code for this module.](https://github.com/vercel/beginner-sveltekit/tree/main/course/10-context-api)\n\n**Course Version History**  \n\n*   **Nov. 21, 2022** - Updated to SvelteKit v1.0.0-next.549. Changed `index.svelte` to `+page.svelte`.\n    \n\nIn this module, we will learn about the context API. The context API provides a mechanism for components to communicate data without passing it through the component tree as props. Let's start by reviewing _when_ we would use the context API, and then we will go over _how_ to use it.\n\nImagine we have an application built with components like this.\n\n![](https://vercel.com/_next/image?url=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Fv1689795055%2Fdocs-assets%2Fstatic%2Fdocs%2Fbeginner-sveltekit%2Fcomponent-tree.png&w=1920&q=75&dpl=dpl_6RGLzPaeBNhuWHRxN1xTYtAhKUa3)\n\nYou can see we have our root component, `homepage`, and within that component are three child components: `header`, `article`, and `footer`. The header component has its own child components, `logo`, `title`, and `nav`. And nav also uses a child component, `link`. This example visualizes nested components as they may appear in a project.\n\nLet's assume that we want one of the link components to display the value of `pageTitle` which is declared in the root component, `homePage`. Using the knowledge we have from previous videos, we can achieve this by passing `pageTitle` as a prop to each component. For example, to get `pageTitle` to the link component, we will have to first pass it to the header, then to the nav component, and finally into the link component. Even though header and nav components do not need `pageTitle`, we have to send it to them in order for them to pass it to components further down in the tree. If you've worked with other component libraries before, you may have heard of this as Prop drilling or Middleman components. Now, in this example that may not seem so bad, but imagine if this were nested 10 levels deep, or even more, as it may be in a real project. That would become a headache to implement, and will make debugging very confusing in the future.\n\nWouldn't it be nice if we could make `pageTitle` directly available to the component without having to forward it through the component tree as props? This is where the context API comes in handy. The context API provides us with a way to pass data through the component tree without having to pass it manually as props. The context API offers two methods, `setContext` and `getContext`, which can access data associated with a key on the context. The context is just an arbitrary object with some set of keys and values, so anything that can be stored in an object can go in the context. A component can call `setContext`, passing in the key and some data as params, and this context becomes available to any of its child components through the use of `getContext`.\n\nLet's learn how to use the context API in a real life example.\n\nHere in our index page, we see we are importing a new component, `CollectionCard` that displays a highlighted collection, in this case `newItems`, which is an array of products that we are then passing into the `CollectionCard` component as a prop.\n\n```\n<script>\n  import GridTile from '$lib/GridTile.svelte';\n  import CollectionCard from '$lib/CollectionCard.svelte';\n \n  let products = [\n    {\n      title: 'Cup',\n      cost: '$10',\n      src: 'https://cdn.shopify.com/s/files/1/0434/0285/4564/products/Cup-front-black.png?v=1623159405',\n    },\n    {\n      title: 'Shirt',\n      cost: '$10',\n      src: 'https://cdn.shopify.com/s/files/1/0434/0285/4564/products/short-sleeve-t-shirt-0.png?v=1622902418',\n    },\n  ];\n  let newItems = [\n    {\n      name: 'Graphic T',\n      src: 'https://cdn.shopify.com/s/files/1/0434/0285/4564/products/Front-NoModel_ec3be051-d579-4c03-b55b-64449d0b0445.png?v=1623255893',\n      price: '$60.00',\n    },\n    {\n      name: 'Jacket',\n      src: 'https://cdn.shopify.com/s/files/1/0434/0285/4564/products/bomber-jacket-0.png?v=1622902777',\n      price: '$80.00',\n    },\n  ];\n</script>\n \n<main>\n  <CollectionCard collection=\"{newItems}\" />\n  {#each products as product}\n  <GridTile {product} />\n  {/each}\n</main>\n```\n\nIf we migrate into the `CollectionCard` component, we see we are importing another component, `ItemsGrid`, which we are again passing our items into as a prop.\n\n```\n<script>\n  import ItemsGrid from '$lib/ItemsGrid.svelte';\n  export let collection;\n</script>\n \n<ItemsGrid items=\"{collection}\" />\n```\n\nFinally, we are actually using the value of our `items` prop in this `ItemsGrid` component.\n\n```\n<script>\n  export let items;\n</script>\n \n<div class=\"flex items-center\">\n  {#each items as item}\n  <div\n    class=\"relative m-2 flex h-40 w-1/2 items-center justify-center overflow-hidden bg-white/20\"\n  >\n    <img src=\"{item.src}\" class=\"h-full\" alt=\"\" />\n    <div class=\"absolute bottom-0 right-0 bg-black p-2\">{item.name}</div>\n  </div>\n  {/each}\n</div>\n```\n\nNow let’s use the context API to set the value of items in our root component, and get that data in our `ItemsGrid` component, without forwarding it through the component tree.\n\nNow in order to get the value of `newItems` from our root component into this component, we first need to provide the context value in our root component. Next move back to `+page.svelte` and import the `setContext` function that is provided to us by Svelte.\n\nNow in our script we can invoke `setContext` which accepts two arguments, the `key` and `value`. The context object can be anything, so let’s set our newItems context like this,\n\n```\nimport { setContext } from 'svelte';\nsetContext('newItemsContext', newItems);\n```\n\nWhere the string `newItemsContext` is our key and we are setting its value to that of `newItems`. Now the context is set, so we can go back to our `ItemsGrid` component and get the `newItemsContext` value. To do this, we will import the `getContext` method from Svelte. We can then use this method to get the value of our `newItemsContext`. To do this we write:\n\n```\nimport { getContext } from 'svelte';\nlet items = getContext('newItemsContext');\n```\n\nNow, let’s go through each component and remove their props. If we check out our browser, we can see the value of `newItems` is successfully being displayed. To double check, we can change the value of `newItems` in our root component. Let’s move into `+page.svelte` and change the title from ‘T-Shirt’ to ‘Graphic T’. Looking back in our browser we see that our component updated with the new value.\n\nWe now have an efficient way to pass data down the component tree, even a deeply nested one! It is important to remember that using the context API only passes data downstream, so from parent to child. Now, eventually, most apps will have values that need to be accessed by multiple unrelated components. In the next module we will learn how to share state between all components using stores.\n\n[](https://vercel.com/docs/beginner-sveltekit/svelte-stores)\n\n#### [Svelte Stores](https://vercel.com/docs/beginner-sveltekit/svelte-stores)\n\n[In this module, we will learn how to share state between unrelated components through the use of Svelte stores.](https://vercel.com/docs/beginner-sveltekit/svelte-stores)",
    "title": "Context API",
    "description": "In this module, we will learn how to pass data to deeply nested components using the Context API.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/PACKAGE_JSON_TYPE_REQUIRED",
    "markdown": "# PACKAGE\\_JSON\\_TYPE\\_REQUIRED\n\nRequires that every package.json file has the type field set to encourage using ES Modules since commonjs is the default.\n\nConformance Rules\n\nThis check ensures that every `package.json` has a `type` field. This field determines how files within the workspace are treated by default. Files are treated as [CommonJS](https://nodejs.org/api/modules.html) by default. However, the new recommendation is to use [ES Modules](https://nodejs.org/api/esm.html).\n\nThis field is required so that packages explicitly choose which module format to use, preferring ES Modules when possible.\n\nSee the [Node.js docs](https://nodejs.org/api/packages.html#type) for more information.\n\nThe `type` field should be set to `module` when possible, although there are still situations where `commonjs` has to be used.\n\nLast updated on\n\nJuly 12, 2024\n\n* * *",
    "title": "PACKAGE_JSON_TYPE_REQUIRED",
    "description": "Requires that every package.json file has the type field set to encourage using ES Modules since commonjs is the default.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/PACKAGE_JSON_DESCRIPTION_REQUIRED",
    "markdown": "# PACKAGE\\_JSON\\_DESCRIPTION\\_REQUIRED\n\nRequires that every package.json file has the description field set.\n\nConformance Rules\n\nThis check ensures that every `package.json` has a `description` field. This field is used to describe the workspace's purpose within the monorepo.\n\nSee the [Node.js docs](https://nodejs.org/api/packages.html#description) for more information.\n\nAdd the `description` field to the `package.json` file that explains what the package does and when it should be used.\n\nLast updated on\n\nJuly 12, 2024\n\n* * *",
    "title": "PACKAGE_JSON_DESCRIPTION_REQUIRED",
    "description": "Requires that every package.json file has the description field set.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/TESTS_NO_ONLY",
    "markdown": "# TESTS\\_NO\\_ONLY\n\nConformance Rules\n\nFocusing tests can help to write and debug test suites, but focused tests should be unfocused before committing changes.\n\nThis rule disallows focused tests so that they can't be committed without an allowlist entry.\n\n```\ndescribe('button', () => {\n  it.only('should render', () => {\n    // ...\n  });\n});\n```\n\nNote that the following patterns (and variants of these patterns) will be reported as errors by this test. These should cover popular test frameworks and runners, including:\n\n```\n// Most test frameworks and runners\ndescribe.only(/* ... */);\nit.concurrent.only(/* ... */);\ntest.only.each([])(/* ... */);\n// Jest - supported in addition to the above\nfdescribe(/* ... */);\nfit.each([])(/* ... */);\nftest(/* ... */);\n```\n\nThis error will be resolved when debugging is complete and the test has been unfocused.\n\nThe default pattern matches the default patterns for Jest and Vitest, however you can provide your own patterns through the `paths` property.\n\nThe default configuration is:\n\n```\n{\n  \"configuration\": [\n    \"testPatterns\": [\"**/unit-tests/**/*.{js,jsx}\"]\n  ]\n}\n```",
    "title": "TESTS_NO_ONLY",
    "description": "Requires that focused tests (i.e. it.only()) are unfocused.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/PACKAGE_JSON_SIDE_EFFECTS_REQUIRED",
    "markdown": "# PACKAGE\\_JSON\\_PRIVATE\\_REQUIREDPACKAGE\\_JSON\\_SIDE\\_EFFECTS\\_REQUIRED\n\nRequires that every package.json file has the sideEffects field set to ensure tree-shaking works optimally.\n\nConformance Rules\n\nThis check ensures that every `package.json` has a `sideEffects` field. The `sideEffects` field is required for shared packages. This field helps bundlers make assumptions about packages that improve tree shaking, or pruning files that aren't used and don't have any global side effects.\n\nSee [https://webpack.js.org/guides/tree-shaking/](https://webpack.js.org/guides/tree-shaking/) for more information.\n\nThe `sideEffects` field should be set to `false` unless the code in that workspace has global side effects, in which case it should be set to `true` or an array of glob patterns for files that do have side effects.\n\nLast updated on\n\nJuly 12, 2024\n\n* * *",
    "title": "PACKAGE_JSON_PRIVATE_REQUIREDPACKAGE_JSON_SIDE_EFFECTS_REQUIRED",
    "description": "Requires that every package.json file has the sideEffects field set to ensure tree-shaking works optimally.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/PACKAGE_JSON_PRIVATE_REQUIRED",
    "markdown": "# PACKAGE\\_JSON\\_PRIVATE\\_REQUIRED\n\nRequires that every package.json file has the private field set to prevent accidental publishing to npm.\n\nConformance Rules\n\nThis check ensures that every `package.json` has the `private` field set to true or false. This field ensures that the workspace is not accidentally published to npm. In a monorepo, this should be the default to prevent packages from being accidentally published and can be explicitly set to `false` to indicate that the package can be published.\n\nPackages should set `private` to `true` unless the package is intended to be published in which case it can be explicitly set to `false`.\n\nLast updated on\n\nJuly 12, 2024\n\n* * *",
    "title": "PACKAGE_JSON_PRIVATE_REQUIRED",
    "description": "Requires that every package.json file has the private field set to prevent accidental publishing to npm.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/PACKAGE_JSON_NAME_REQUIRED",
    "markdown": "# PACKAGE\\_JSON\\_NAME\\_REQUIRED\n\nRequires that every package.json file has the name field set to ensure each workspace has a unique identifier.\n\nConformance Rules\n\nThis check ensures that every `package.json` has a `name` field. This field is important because it used to identify the workspace in the monorepo.\n\nSee the [Node.js docs](https://nodejs.org/api/packages.html#name) for more information.\n\nAdd the `name` field to the `package.json` file that contains a unique name for this package. The name should be understandable by someone viewing or using the package as to what it does.\n\nLast updated on\n\nJuly 12, 2024\n\n* * *",
    "title": "PACKAGE_JSON_NAME_REQUIRED",
    "description": "Requires that every package.json file has the name field set to ensure each workspace has a unique identifier.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/NO_VARIABLE_IMPORT_REFERENCES",
    "markdown": "# NO\\_VARIABLE\\_IMPORT\\_REFERENCES\n\nConformance Rules\n\n`import` and `require` statements load code from another file. When the location of the import is influenced by user input, the user may be able to load code that would otherwise be inaccessible to them. Such imports should protect against this by adding guards to make sure that arbitrary code can not be loaded from the import statement.\n\nThe following code would be flagged by this rule:\n\n```\nfunction loadDynamicCode(moduleName: string) {\n  return import(moduleName);\n}\n```\n\nIn this example, it can not be guaranteed that the `moduleName` that is provided would not be arbitrary input that could load unintended code.\n\nInstances of this rule should be reviewed by a knowledgeable security person. If user input is used to select which module is loaded, guards against arbitrary strings should be added, such as only allowing access to a list of valid options. If no user input is involved in the import, then this code could be allowlisted after being reviewed by a security team member, but developers should be careful to ensure that only the desired code can be loaded.",
    "title": "NO_VARIABLE_IMPORT_REFERENCES",
    "description": "import and require statements must be passed string literals to avoid arbitrary user access to code.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/PACKAGE_JSON_DUPLICATE_DEPENDENCIES",
    "markdown": "# PACKAGE\\_JSON\\_DUPLICATE\\_DEPENDENCIES\n\nConformance Rules\n\nPackages that are listed in the `dependencies` section of `package.json` should not be listed in `devDependencies` or `peerDependencies`. A package in the `dependencies` section says that the package are required for the functionality of your workspace, in which case there is no reason to also list it in `devDependencies` or `peerDependencies`.\n\nThis `package.json` file would cause the check to fail:\n\n```\n{\n  \"name\": \"workspace\",\n  \"dependencies\": {\n    \"@next/mdx\": \"13.1.5\"\n  },\n  \"devDependencies\": {\n    \"@next/mdx\": \"13.1.5\"\n  }\n}\n```\n\nIf the package is needed to use the package from your workspace, you can remove the package from the `devDependencies` and `peerDependencies` sections. If the package is only needed for development of your workspace or if the package is only needed to express version compatibility requirements and it is not needed for the functionality of your workspace when people use your package, then it can be left in `devDependencies` or `peerDependencies` and be removed from `dependencies`.",
    "title": "PACKAGE_JSON_DUPLICATE_DEPENDENCIES",
    "description": "Found duplicate dependencies between the list of dependencies and devDependencies or peerDependencies in a package.json file..",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/NO_CORS_HEADERS",
    "markdown": "# NO\\_CORS\\_HEADERS\n\nConformance Rules\n\nMisconfiguring CORS ([Cross Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)) headers can introduce security risks, potentially exposing private and/or secure information such as API keys and user data.\n\nThis rule is not meant to block usage of CORS. Instead, it is designed to flag potentially risky configuration for review by the appropriate engineer(s) or team(s).\n\nFor more information around the risks associated with CORS, including testing for potential vulnerabilities, see:\n\nThe examples below are common approaches to settings CORS headers in JavaScript applications. All of these examples will be caught by this rule.\n\n```\nresponse.headers.set('Access-Control-Allow-Origin', '*');\n \nconst headers = {\n  'Access-Control-Allow-Credentials': true,\n};\n \nconst options = {\n  headers: [\n    {\n      key: 'Access-Control-Max-Age',\n      value: 600,\n    },\n  ],\n};\n \nconst headers = new Headers();\nheaders.append('Access-Control-Allow-Methods', '*');\n```\n\nAdditionally, this rule will catch partial matches, such as a template literal. In this example, the rule will match the `\"Access-Control-\"` part of the template literal.\n\n```\nconst headers = new Headers();\nheaders.append(`Access-Control-${HEADER_TYPE}`, '*');\n```\n\nEngineers should reach out to the appropriate engineer(s) or team(s) for a security review of the configuration.\n\nWhen requesting a review, please provide as much information as possible around the proposed CORS configuration. Where applicable, include information around alternative approaches, and why this approach is preferable.\n\nAs there are many ways to configure CORS headers in applications, this rule will match any string that looks like a possible CORS header. We've tried to mitigate the risk of false-positives, but if they occur they will need to be added to the allowlists.",
    "title": "NO_CORS_HEADERS",
    "description": "Warns when CORS header (or header-like) configuration is detected, requiring that configuration to be allowlisted.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/NO_SERIAL_ASYNC_CALLS",
    "markdown": "# NO\\_SERIAL\\_ASYNC\\_CALLS\n\nConformance Rules\n\nSequential execution of async/await calls can significantly impact performance because each await call prevents further execution until resolving its Promise. This rule aims to refactor sequential async/await calls into parallel executions to enhance performance.\n\nYou should note that this rule might not flag some async/await usage patterns. For example:\n\n*   Patterns involving conditional statements\n*   Call expressions\n*   Patterns that await in a manner that suggests non-serial dependencies between calls\n\nFor instance, scenarios where async calls depend conditionally on each other or are part of complex expressions are not flagged. This includes cases where one async call's outcome is necessary for subsequent calls, requiring serial execution due to logical or dependency reasons.\n\nThe following example will not be flagged by this rule:\n\n```\nasync function updateDatabase() {\n  const result1 = await async1();\n  const result2 = await async2();\n  doSomething(result1, result2);\n}\n```\n\nThese patterns fall outside the scope of this rule because safely suggesting parallelization requires more context, and the rule uses conservative heuristics to avoid false positives.\n\nInstead, of executing async logic sequentially, opt to refactor the logic so it can be run parallel.\n\nThis can be fixed using `Promise.all`:\n\n```\nexport async function getStaticProps() {\n  const firstThing = await getFirstThing();\n  const secondThing = await getSecondThing();\n \n  return {\n    props: {\n      firstThing,\n      secondThing,\n    },\n  };\n}\n```\n\nWe can extract both `await` expressions into a single `Promise.all`, as follows:\n\n```\nexport async function getStaticProps() {\n  const [firstThing, secondThing] = await Promise.all([\n    getFirstThing(),\n    getSecondThing(),\n  ]);\n \n  return {\n    props: {\n      firstThing,\n      secondThing,\n    },\n  };\n}\n```",
    "title": "NO_SERIAL_ASYNC_CALLS",
    "description": "Prevent blocking serial async await calls in your applications.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/NO_DANGEROUS_HTML",
    "markdown": "# NO\\_DANGEROUS\\_HTML\n\nPrevent the unsafe creation of DOM via HTML methods in your application.\n\nConformance Rules\n\nUnsafe creation of DOM can be done a variety of ways:\n\n*   `element.innerHTML`\n*   `element.outerHTML`\n*   `DOMParser.parseFromString()`\n*   `element.insertAdjacentHTML()`\n*   `srcdoc` on iframe elements\n*   `dangerouslySetInnerHTML` prop in React apps\n\nUsage of these methods is deemed an unsafe coding practice as the HTML might result in security vulnerabilities.\n\nIt is recommended to instead use alternative approaches for HTML construction - such as `document.createElement()` or a HTML sanitizer.\n\nLast updated on\n\nJuly 12, 2024\n\n* * *",
    "title": "NO_DANGEROUS_HTML",
    "description": "Prevent the unsafe creation of DOM via HTML methods in your application.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/NO_MIXED_ASYNC_MODULES",
    "markdown": "# NO\\_MIXED\\_ASYNC\\_MODULES\n\nConformance Rules\n\nTop-level await expressions in modules that are imported by other modules in sync prevent possible lazy module optimizations from being deployed on the module containing the top-level await.\n\nOne such optimization this prevents is inline lazy imports. Inline lazy imports allow for modules to be lazily evaluated and executed when they're used, rather than at initialization time of the module that uses them, improving initialization performance.\n\nThis is particularly impactful for modules that might only be used conditionally or given a user's interaction which might happen much latter in an application. Without this optimization, the module initialization times, such as for cold boots on serverless functions, could be slowed down for every request.\n\nConsider refactoring the import to a dynamic import instead, or removing the top-level await in favor of standard import.\n\nIf a top-level await is important, then it's important that any other modules importing the module with the top-level await do so dynamically, as to avoid affecting initialization performance.\n\nFor example, this can be refactored:\n\n```\n// Contains a top-level await\nimport { asyncConfig } from 'someModule';\n \nfunction doSomething(data) {\n  processData(data, asyncConfig);\n}\n```\n\nTo this:\n\n```\nfunction doSomething(data) {\n  import('someModule').then(({ asyncConfig }) => {\n    processData(data, asyncConfig);\n  });\n}\n```\n\nOr this:\n\n```\nimport { asyncConfig } from 'someModule';\n \n// Note the async keyword on the function\nasync function doSomething(data) {\n  processData(data, asyncConfig);\n}\n```",
    "title": "NO_MIXED_ASYNC_MODULES",
    "description": "Prevent imports to modules that contain top-level awaits in your applications.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/cli/env",
    "markdown": "# vercel env\n\nThe `vercel env` command is used to manage [Environment Variables](https://vercel.com/docs/projects/environment-variables) of a Project, providing functionality to list, add, remove, and export.\n\nTo leverage environment variables in local tools (like `next dev` or `gatsby dev`) that want them in a file (like `.env`), run `vercel env pull <file>`. This will export your Project's environment variables to that file. After updating environment variables on Vercel (through the dashboard, `vercel env add`, or `vercel env rm`), you will have to run `vercel env pull <file>` again to get the updated values.\n\nSome frameworks make use of environment variables during local development through CLI commands like `next dev` or `gatsby dev`. The `vercel env pull` sub-command will export development environment variables to a local `.env` file or a different file of your choice.\n\nTo override environment variable values temporarily, use:\n\n```\nMY_ENV_VAR=\"temporary value\" next dev\n```\n\n  \n\nIf you are using [`vercel build`](https://vercel.com/docs/cli/build) or [`vercel dev`](https://vercel.com/docs/cli/dev), you should use [`vercel pull`](https://vercel.com/docs/cli/pull) instead. Those commands operate on a local copy of environment variables and Project settings that are saved under `.vercel/`, which `vercel pull` provides.\n\nUsing the `vercel env` command to list all Environment Variables in a Vercel Project.\n\nUsing the `vercel env` command to add an Environment Variable to a Vercel Project.\n\nUsing the `vercel env` command to remove an Environment Variable from a Vercel Project.\n\n```\nvercel env ls [environment]\n```\n\nUsing the `vercel env` command to list Environment Variables for a specific Environment in a Vercel Project.\n\n```\nvercel env ls [environment] [gitbranch]\n```\n\nUsing the `vercel env` command to list Environment Variables for a specific Environment and Git branch.\n\nUsing the `vercel env` command to add an Environment Variable to all Environments to a Vercel Project.\n\n```\nvercel env add [name] [environment]\n```\n\nUsing the `vercel env` command to add an Environment Variable for a specific Environment to a Vercel Project.\n\n```\nvercel env add [name] [environment] [gitbranch]\n```\n\nUsing the `vercel env` command to add an Environment Variable to a specific Git branch.\n\n```\nvercel env add [name] [environment] < [file]\n```\n\nUsing the `vercel env` command to add an Environment Variable to a Vercel Project using a local file's content as the value.\n\n```\necho [value] | vercel env add [name] [environment]\n```\n\nUsing the `echo` command to generate the value of the Environment Variable and piping that value into the `vercel dev` command. Warning: this will save the value in bash history, so this is not recommend for secrets.\n\n```\nvercel env add [name] [environment] [gitbranch] < [file]\n```\n\nUsing the `vercel env` command to add an Environment Variable with Git branch to a Vercel Project using a local file's content as the value.\n\n```\nvercel env rm [name] [environment]\n```\n\nUsing the `vercel env` command to remove an Environment Variable from a Vercel Project.\n\nUsing the `vercel env` command to download Development Environment Variables from the cloud and write to a specific file.\n\n```\nvercel env pull --environment=preview\n```\n\nUsing the `vercel env` command to download Preview Environment Variables from the cloud and write to the `.env.local` file.\n\n```\nvercel env pull --environment=preview --git-branch=feature-branch\n```\n\nUsing the `vercel env` command to download \"feature-branch\" Environment Variables from the cloud and write to the `.env.local` file.\n\nThese are options that only apply to the `vercel env` command.\n\nThe `--yes` option can be used to bypass the confirmation prompt when overwriting an environment file or removing an environment variable.\n\nUsing the `vercel env pull` command with the `--yes` option to overwrite an existing environment file.\n\n```\nvercel env rm [name] --yes\n```\n\nUsing the `vercel env rm` command with the `--yes` option to skip the remove confirmation.\n\nThe following [global options](https://vercel.com/docs/cli/global-options) can be passed when using the `vercel env` command:\n\nFor more information on global options and their usage, refer to the [options section](https://vercel.com/docs/cli/global-options).",
    "title": "vercel env",
    "description": "Learn how to manage your environment variables in your Vercel Projects using the vercel env CLI command.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/cli/logs",
    "markdown": "# vercel logs\n\nThe `vercel logs` command is used to retrieve logs data for a specific deployment. You can find more detailed logs on the Deployment Overview page from the Vercel Dashboard.\n\n```\nvercel logs [deployment-url]\n```\n\nUsing the `vercel logs` command to retrieve logs for a specific deployment.\n\nThese are options that only apply to the `vercel logs` command.\n\nThe `--follow` option, shorthand `-f`, can be used to watch for additional logs output.\n\nUsing the `vercel logs` command with the `--follow` option.\n\nThe `--number` option, shorthand `-n`, can be used to specify the number of log lines to output.\n\nUsing the `vercel logs` command with the `--number` option.\n\nThe `--output` option, shorthand `-o`, can be used to specify the format of the logs output, this can be either `short` (default) or `raw`.\n\nUsing the `vercel logs` command with the `--output` option.\n\nThe `--since` option can be used to return logs only after a specific date, using the ISO 8601 format.\n\n```\nvercel logs --since 2019-09-04T07:05:43+00:00\n```\n\nUsing the `vercel logs` command with the `--since` option.\n\nThe `--query` option, shorthand `-q`, can be used to return logs against a search query.\n\nUsing the `vercel logs` command with the `--query` option.\n\nThe `--until` option can be used to return logs only up until a specific date, using the ISO 8601 format.\n\n```\nvercel logs --until 2019-09-04T07:05:43+00:00\n```\n\nUsing the `vercel logs` command with the `--until` option.\n\nThe following [global options](https://vercel.com/docs/cli/global-options) can be passed when using the `vercel logs` command:\n\nFor more information on global options and their usage, refer to the [options section](https://vercel.com/docs/cli/global-options).",
    "title": "vercel logs",
    "description": "Learn how to list out all logs for a specific deployment using the vercel logs CLI command.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/NO_EXTERNAL_CSS_AT_IMPORTS",
    "markdown": "# NO\\_EXTERNAL\\_CSS\\_AT\\_IMPORTS\n\nConformance Rules\n\nImporting CSS through ([`@import`](https://developer.mozilla.org/en-US/docs/Web/CSS/@import)) is render blocking, causing browsers to sequentially download and parse the imported CSS (a [critical request chain](https://developer.chrome.com/en/docs/lighthouse/performance/critical-request-chains/)).\n\n```\n@import url('https://fonts.googleapis.com/css2?family=Inter');\n```\n\nThis can result in a [flash of unstyled content (FOUC)](https://en.wikipedia.org/wiki/Flash_of_unstyled_content), where page content is briefly shown without complete styles until all required CSS has been downloaded and parsed, along with slower page load times.\n\nImports to relative paths are processed by frameworks like Next.js, and will not be affected by this issue.\n\n```\n/* This import is safe. */\n@import './globals.css';\n```\n\nNote that this rule currently only parses CSS and not CSS written in Less, Sass, or other CSS preprocessor syntaxes.\n\nIf you're importing a font, you can use [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) which will automatically optimize your fonts (including custom fonts) and remove external network requests.\n\nIf you're importing CSS, such as Bootstrap, avoid loading it from external sources, such as a CDN or the [Next.js public folder](https://nextjs.org/docs/basic-features/static-file-serving). Instead, you can import that CSS relatively, or from a package.\n\n```\n// CSS imported relatively from a local file.\nimport './globals.css';\n// CSS from a package in `node_modules`.\nimport 'bootstrap/dist/css/bootstrap.css';\n \ninterface RootLayoutProps {\n  children: React.ReactNode;\n}\n \nexport default function RootLayout({ children }: RootLayoutProps) {\n  return (\n    <html lang=\"en\">\n      <head />\n      <body>{children}</body>\n    </html>\n  );\n}\n```",
    "title": "NO_EXTERNAL_CSS_AT_IMPORTS",
    "description": "Disallows @import at-rules that import from URLs.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/beginner-sveltekit/svelte-stores",
    "markdown": "# Svelte Stores\n\n[**Svelte Stores**View the code for this module.](https://github.com/vercel/beginner-sveltekit/tree/main/course/11-stores)\n\n**Course Version History**  \n\n*   **Nov. 21, 2022** - Updated to SvelteKit v1.0.0-next.549. Changed `index.svelte` to `+page.svelte`.\n    \n\nAt this point in the course, we are familiar with how data can be passed between components, even deeply nested components with the Context API, but not all application state belongs inside the application's component hierarchy. The app is bound to have values that need to be accessed by multiple unrelated components, or a regular JavaScript module.\n\n![](https://vercel.com/_next/image?url=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Fv1689795055%2Fdocs-assets%2Fstatic%2Fdocs%2Fbeginner-sveltekit%2Fnested-components.png&w=1920&q=75&dpl=dpl_6RGLzPaeBNhuWHRxN1xTYtAhKUa3)\n\nIn this diagram of nested components, we may have some state gathered in component E that component D also needs to have access to. In this case, since the two components are not related, the only way to do this would be to pass data up and down through the tree. This method, however, will quickly become messy and hard to manage as the component tree grows. Wouldn’t it be nice to store the data in a single centralized location? Svelte comes with built in state management, so we can do this by creating a Svelte store without having to install an additional package. A store is a global object with a subscribe method that allows components to be notified whenever the store value changes. We can create a central store of data where we can register data, and then any component that needs access to this data can subscribe to this store. We can even update this data directly from the subscribed components, and any other subscribed component will automatically get the updated data. This makes it much easier to manage our data, especially as the application grows.\n\nCurrently in our project, within our layout file we are importing our shopping cart component which accepts a bound property, `cartItems`. Since it is bound, any time we change the quantity of an item in our cart, the parent is also updated. We can also add a new item to our cart. Clicking the 'add to cart' button in our shopping cart dispatches an event to the layout which adds the `newItem` to our `catItems` array. In this case we have a single source of truth, `cartItems`, which lives in our layout component.\n\nNow, I’ve added a new button to our `GridTile` component, so now we can add items to our cart from this component as well. The issue here is, this component is not being imported in our layout, it being used in our root page. How can we update our cart when we click these new 'add to cart' buttons while maintaining a single source of truth? This is where stores come in handy.\n\nIn our project, let’s create a store. First, create a new file called `Store.js` in out `src` root. Notice this is a `.js` file, not `.svelte`. We are not creating a Svelte component here, we are just creating a store to store our data. Now in this file, the first thing we need to do is import `writable` from `svelte/store` like this.\n\n```\nimport { writable } from svelte/store\n```\n\nWritable means we can both write and read from this store, and is probably the most common type of store. `writable` has three methods, `subscribe`, `set`, and `update`. `subscribe` will subscribe a component to the store so that the component can read and write to it. `set` takes one argument which is the value to be set, and `update` takes one argument which is a callback. The callback takes the existing store value as its argument and returns the new value to be set to the store.\n\nNow that we have `writable` imported, we need to actually create the store. We can do this by invoking `writable` like this.\n\n```\nimport { writable } from svelte/store\n \nconst cart = writable();\n```\n\nNow we have a writable store of data. We can pass in some initial data into this store if we’d like. Let’s go ahead and paste in our `carItems` array.\n\n```\nimport { writable } from 'svelte/store';\n \nconst CartItemsStore = writable([\n  {\n    name: 'Sticker',\n    src: 'https://cdn.shopify.com/s/files/1/0434/0285/4564/products/Sticker-mock.png?v=1623256356',\n    price: '$8.00',\n    quantity: 1,\n  },\n]);\n \nexport default CartItemsStore;\n```\n\nNow this writable store is storing this array of data. Next, we need to export this cart items store. Now we can subscribe to this from any component. Let’s first move into our `ShoppingCart` component, and we can import this store like this.\n\n```\nimport CartItemsStore from '../Store.js';\n```\n\nNow that we are importing the store, we can use the `subscribe` method to subscribe to the data within it. Below where we import the store we can just say `CartItemsStore.subscribe()` which will fire a callback function. This callback takes the data we get from the store as a parameter. This parameter, `data`, will be whatever data is currently in the store. We can test this out by logging it in the console for now. Now, if we check this out in the browser, we’ll see that we have successfully subscribed to this store and the data is being logged in the console. Whenever this data changes from anywhere in the app, this callback function will be re-fired, and the new updated data will be passed to it.\n\nNow, instead of accepting `cartItems` as a prop, let’s instead set `cartItems` equal to the array returned from our store.\n\n```\nimport CartItemsStore from '../Store.js';\n \nlet cartItems;\nCartItemsStore.subscribe((data) => {\n  cartItems = data;\n});\n```\n\nNow, we need to update the store when the cart changes. Currently we are using the `subscribe` method to read from the store, but in this case we want to write to it. We can do this using the `update` method.\n\nRight now when we click our ‘add to cart’ button, we are dispatching an event with our `newItem` data to our parent component where the `newItem` was then being added to the cart. Instead, let’s use the update method to update our store with the new item directly from the shopping cart component. We can say `CartItemsStore.update()` and this will once again fire a callback function that takes in the current data in our store as a param, and from this callback we need to return the value of the updated data. For example, if we were to return an empty array, the whole value of our Store will become an empty array, and we would see our cart is empty.\n\n```\nCartItemsStore.update((currentData) => {\n  return [];\n});\n```\n\nThat’s not what we want to do here. Instead, we want to return an array with all the current items, as well as the new one. Let’s return an array with our new item as well as all the current items in our store like this.\n\n```\n<script>\n  function addItemToCart() {\n    CartItemsStore.update((currentData) => {\n      return [newItem, ...currentData];\n    });\n  }\n</script>\n```\n\nNow when we click the 'add to cart' button, our store will be updated with the new item. It’s important to remember that anytime our store is updated, the callback will be fired and this data will be updated wherever the store is being subscribed to. When we updated our store, our subscribe method that we added earlier is called again, so our cart will update automatically.\n\nThe header, however, is not updated with the new car item. This is because we are not using a single source of truth right now. The header component is still getting `cartItems` from our layout component, which the cart is no longer bound to. Back in our layout file, let’s once again import and subscribe to our store and set `cartItems` to our stores data like this.\n\n```\nimport CartItemsStore from '../Store.js';\n \nlet cartItems;\nCartItemsStore.subscribe((data) => {\n  cartItems = data;\n});\n```\n\nNow, when we add the new item to our cart, the header will also be updated. Remember, anytime the store changes, every component that is subscribed to it will automatically be updated.\n\nFinally, we can head into our `GridTile` component and update our store when we click the 'add to cart' button here as well. Now, a new item can be added to our cart from this component, and both the header and shopping cart components will be updated even though they are unrelated to our GridTile component.\n\nThere is, however, a subtle bug in our current code. The store is subscribed to, but never unsubscribed. If the component was instantiated and destroyed many times, this would result in a memory leak, so we need to unsubscribe from the store. Calling a `subscribe` method returns an `unsubscribe` function, so let’s go ahead and declare `unsubscribe` in our layout page, and set it to your subscribe method. Now, we can call this on through the `onDestroy` lifecycle hook.\n\n```\nimport CartItemsStore from '../Store.js';\n \nlet cartItems;\nconst unsubscribe = CartItemsStore.subscribe((data) => {\n  cartItems = data;\n});\nimport BlogStore from '../../Store.js';\n \nonDestroy(unsubscribe);\n```\n\nThis works, but it starts to resemble a boilerplate, especially if your component subscribes to multiple stores. Instead, Svelte has a nifty trick we can use. We can reference a store value by prefixing the store name with a dollar sign. Instead we can say:\n\n```\ncartItems = $CartItemsStore;\n```\n\nMuch simpler! We call this auto-subscribing to the store, and it works because any name beginning with `$` is assumed to refer to a store value. This simplifies our code a lot, and also fixes our bug! Anywhere we subscript to the store, we can update it with this shorthand!\n\nNow that we know how to manage our applications state with stores, let’s learn how to dynamically change component templates through the use of slots in the next module.\n\n[](https://vercel.com/docs/beginner-sveltekit/slots)\n\n#### [Slots](https://vercel.com/docs/beginner-sveltekit/slots)\n\n[In this module, we will learn how to dynamically change a component's markup using the slot tag.](https://vercel.com/docs/beginner-sveltekit/slots)",
    "title": "Svelte Stores",
    "description": "In this module, we will learn how to share state between unrelated components through the use of Svelte stores.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/NO_DOCUMENT_WRITE",
    "markdown": "# NO\\_DOCUMENT\\_WRITE\n\nPrevent unsafe usage of document.write() in your application.\n\nConformance Rules\n\nCalls to `document.write()` or `document.writeln()` manipulate DOM directly without any sanitization and should be avoided.\n\nFurthermore, these APIs can also cause performance issues and trigger will clear the page contents if used after page load.\n\nAvoid usage of `document.write()` entirely in your application, and instead either use UI framework like React to handle writing to the document, or use safer DOM APIs, such as `document.createElement()` instead.\n\nLast updated on\n\nJuly 12, 2024\n\n* * *",
    "title": "NO_DOCUMENT_WRITE",
    "description": "Prevent unsafe usage of document.write() in your application.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/NO_EVAL",
    "markdown": "# NO\\_EVAL\n\nConformance Rules\n\nJavaScript's `eval()` function is potentially dangerous, is often misused, and might cause security issues. Using `eval()` on untrusted code can open an application up to several different injection attacks.\n\nThis rule will also catch eval-like function usage (or _implied eval_), such as passing a string as the first argument to `setTimeout`.\n\nThis is especially dangerous when working with data from external sources.\n\n```\nconst dontDoThis = req.body;\nsetTimeout(dontDoThis, 1000);\n```\n\nFor more information on why you should never use evaluation, see the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_eval!).\n\nThe lines below (and variations of those) will all be caught by this rule.\n\n```\neval('() => console.log(\"DROP TABLE\")');\n \nsetTimeout('() => console.log(\"DROP TABLE\")', 1000);\n \nwindow.setInterval('() => console.log(\"DROP TABLE\")', 1000);\n \nnew Function('() => console.log(\"DROP TABLE\")');\n```\n\nConformance rules are not type-aware, but will follow variable references within the current module (or file).\n\n```\nimport { importedVar } from 'foo';\n \n// No error reported, as this rule doesn't have access to the value.\nsetTimeout(importedVar, 100);\n \nconst localVar = 'bar';\n \n// An error will be reported, as the variable was declared in this file.\nsetTimeout(localVar, 100);\n```\n\nAvoid usage of this type of evaluation entirely in your application. Instead, you should write the same functionality as raw code (not within a string).\n\n```\nsetTimeout(() => {\n  console.log('Safe usage');\n});\n```",
    "title": "NO_EVAL",
    "description": "Prevent unsafe usage of eval() in your application.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/NEXTJS_NO_ASYNC_PAGE",
    "markdown": "# NEXTJS\\_NO\\_ASYNC\\_PAGE\n\nConformance Rules\n\nThis rule is in preview, please give us your feedback!\n\n  \n\nThis rule is available from version 1.1.0.\n\nThis rule examines all Next.js app router page files and their transitive dependencies to ensure none are asynchronous or return new Promise instances. Even if the page component itself is not asynchronous, importing an asynchronous component somewhere in the page's dependency tree can silently cause the page to render dynamically. This can cause a blank page to be displayed to the user while Next.js waits for long promises to resolve.\n\nThis rule will not error if it detects a sibling [loading.js](https://nextjs.org/docs/app/api-reference/file-conventions/loading) file beside the page.\n\nBy default, this rule is disabled. To enable it, refer to [customizing Conformance](https://vercel.com/docs/workflow-collaboration/conformance/customize).\n\nFor further reading, you may find these resources helpful:\n\n*   [Loading UI and Streaming in Next.js](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming): This guide discusses strategies for loading UI components and streaming content in Next.js applications.\n*   [Next.js Loading File Conventions](https://nextjs.org/docs/app/api-reference/file-conventions/loading): This document provides an overview of file conventions related to loading in Next.js.\n*   [Next.js Route Segment Config](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamic): This document provides an overview of the `dynamic` export and how it can be used to force the dynamic behaviour of a layout.\n\nThis rule will catch the following code.\n\n```\nexport default async function Page() {\n  const data = await fetch();\n  return <div>{data}</div>;\n}\n```\n\n```\nasync function AuthButton() {\n  const isAuthorized = await auth();\n  return <div>{isAuthorized ? 'Authorized' : 'Unauthorized'}</div>;\n}\n \nexport default function Page() {\n  return <AuthButton />;\n}\n```\n\nYou can fix this error by wrapping your async component with a `<Suspense/>` boundary that has a fallback UI to indicate to Next.js that it should use the fallback until the promise resolves.\n\nAlternatively, you can manually force the dynamic behaviour of the page by exporting a `dynamic` value. This rule will only error if `dynamic` is not specified or is set to `auto`. Read more [here](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamic).\n\n```\nexport const dynamic = 'force-static';\n \nexport default async function Page() {\n  const data = await fetch();\n  return <div>{data}</div>;\n}\n```",
    "title": "NEXTJS_NO_ASYNC_PAGE",
    "description": "Ensures that the exported Next.js page component and its transitive dependencies are not asynchronous, as that blocks the rendering of the page.",
    "languageCode": "en"
  },
  {
    "url": "https://vercel.com/docs/workflow-collaboration/conformance/rules/NEXTJS_NO_ASYNC_PAGE",
    "markdown": "# NEXTJS\\_NO\\_ASYNC\\_PAGE\n\nConformance Rules\n\nThis rule is in preview, please give us your feedback!\n\n  \n\nThis rule is available from version 1.1.0.\n\nThis rule examines all Next.js app router page files and their transitive dependencies to ensure none are asynchronous or return new Promise instances. Even if the page component itself is not asynchronous, importing an asynchronous component somewhere in the page's dependency tree can silently cause the page to render dynamically. This can cause a blank page to be displayed to the user while Next.js waits for long promises to resolve.\n\nThis rule will not error if it detects a sibling [loading.js](https://nextjs.org/docs/app/api-reference/file-conventions/loading) file beside the page.\n\nBy default, this rule is disabled. To enable it, refer to [customizing Conformance](https://vercel.com/docs/workflow-collaboration/conformance/customize).\n\nFor further reading, you may find these resources helpful:\n\n*   [Loading UI and Streaming in Next.js](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming): This guide discusses strategies for loading UI components and streaming content in Next.js applications.\n*   [Next.js Loading File Conventions](https://nextjs.org/docs/app/api-reference/file-conventions/loading): This document provides an overview of file conventions related to loading in Next.js.\n*   [Next.js Route Segment Config](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamic): This document provides an overview of the `dynamic` export and how it can be used to force the dynamic behaviour of a layout.\n\nThis rule will catch the following code.\n\n```\nexport default async function Page() {\n  const data = await fetch();\n  return <div>{data}</div>;\n}\n```\n\n```\nasync function AuthButton() {\n  const isAuthorized = await auth();\n  return <div>{isAuthorized ? 'Authorized' : 'Unauthorized'}</div>;\n}\n \nexport default function Page() {\n  return <AuthButton />;\n}\n```\n\nYou can fix this error by wrapping your async component with a `<Suspense/>` boundary that has a fallback UI to indicate to Next.js that it should use the fallback until the promise resolves.\n\nAlternatively, you can manually force the dynamic behaviour of the page by exporting a `dynamic` value. This rule will only error if `dynamic` is not specified or is set to `auto`. Read more [here](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamic).\n\n```\nexport const dynamic = 'force-static';\n \nexport default async function Page() {\n  const data = await fetch();\n  return <div>{data}</div>;\n}\n```",
    "title": "NEXTJS_NO_ASYNC_PAGE",
    "description": "Ensures that the exported Next.js page component and its transitive dependencies are not asynchronous, as that blocks the rendering of the page.",
    "languageCode": "en"
  }
]