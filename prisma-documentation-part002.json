[
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta",
    "markdown": "# Upgrade from the Prisma 1 MongoDB Beta to Prisma ORM 2 or later\n\n## Introduction[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#introduction \"Direct link to Introduction\")\n\nThis guide helps you migrate from the Prisma 1 MongoDB Beta to MongoDB on Prisma ORM 2 or later. To learn more about the differences between Prisma 1 and Prisma ORM 2.x and later, refer to [this document](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#main-differences-between-prisma-1-and-prisma-orm-version-2x-and-later).\n\nThe scope of this guide is to give you the workflow necessary to perform the migration and highlight some of the problems you might encounter.\n\nWe unfortunately can't cover all possible scenarios or changes required, but this guide should help you on your journey. Join [our Discord](https://pris.ly/discord) or create an issue [on Github](https://github.com/prisma/prisma1/issues/new/choose) with any questions.\n\nwarning\n\nPerform this migration on your staging environment before trying this in production!\n\n## Requirements[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#requirements \"Direct link to Requirements\")\n\n*   Must be running MongoDB 4.2+ as a replica set (MongoDB Atlas does this for you automatically)\n*   Node.js: see [system requirements](https://www.prisma.io/docs/orm/reference/system-requirements)\n*   TypeScript: see [system requirements](https://www.prisma.io/docs/orm/reference/system-requirements)\n\n## Installing Prisma ORM 3.12.0 or later[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#installing-prisma-orm-3120-or-later \"Direct link to Installing Prisma ORM 3.12.0 or later\")\n\nIn your project directory run the following commands:\n\n```\n$ npm install prisma@latest$ npx prisma init --datasource-provider=mongodb\n```\n\nThis should create the following files:\n\n*   `prisma/schema.prisma`: An initial Prisma schema\n*   `.env`: Environment file where you'll store your connection string\n\ninfo\n\nIf you see the following error:\n\n```\nERROR  File schema.prisma already exists in your project.Please try again in a project that is not yet using Prisma.\n```\n\nYou have likely a `prisma/` directory in your project already. Rename that directory to something like `_prisma/` and try again\n\n## Find the Connection String to your MongoDB Database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#find-the-connection-string-to-your-mongodb-database \"Direct link to Find the Connection String to your MongoDB Database\")\n\nNext you'll want to find the connection string to your MongoDB database. You should be able to find it in your `docker-compose.yml` file or on MongoDB Atlas. It's what you'd pass to MongoDB Compass. The connection string should look something like this:\n\n```\nmongodb://<user>:<pass>@<host>:27017\n```\n\nThe database that stores application data in Prisma 1 is called `default_default`, so we'll add that to the end of the connection string and update the `DATABASE_URL` key in the `.env` file\n\n.env\n\n```\nDATABASE_URL=\"mongodb://prisma:prisma@localhost:27017/default_default\"\n```\n\n## Introspect your MongoDB Database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#introspect-your-mongodb-database \"Direct link to Introspect your MongoDB Database\")\n\nYou're now ready to pull the structure of your database down into your Prisma Schema.\n\nAnd you should see your Prisma schema in `prisma/schema.prisma` populated with your models.\n\ninfo\n\nIf you see the following error: `Error in connector: SCRAM failure: Authentication failed.`, try adding `?authSource=admin` to the end of your connection string and trying again.\n\n## Touching up your Prisma Schema[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#touching-up-your-prisma-schema \"Direct link to Touching up your Prisma Schema\")\n\nThe generated Prisma Client from a freshly introspected Prisma 1 based MongoDB database may not have the best API. You can adjust the model names and fields, just be sure to `@map` and `@@map` the original name to the underlying database collection and field names:\n\n```\n- model posts {+ model Post {    id        String  @id @default(auto()) @map(\"_id\") @db.ObjectId    published Boolean    title     String+    @@map(\"posts\")  }- model users {+ model User {    id    String   @id @default(auto()) @map(\"_id\") @db.ObjectId    email String   @unique(map: \"email_U\")    name  String-    posts String[] @db.ObjectId+    postIds String[] @db.ObjectId @map(\"posts\")    @@index([posts], map: \"posts_R\")+    @@map(\"users\")  }\n```\n\nTake caution in doing these renames because you need to make sure the Prisma Schema still maps properly to the underlying database collections and field names.\n\nUnlike SQL databases, MongoDB doesn't have an explicit understanding of relationships between data. This means that Prisma ORM's introspection is unable to infer those relationships for you.\n\nWe typically recommend adding the relationships by hand with the help of [this documentation](https://www.prisma.io/docs/orm/overview/databases/mongodb#how-to-add-in-missing-relations-after-introspection). However, Prisma 1 stores foreign keys is different than where Prisma ORM 2 and later expects foreign keys, so if you want to take advantage of relationships, you'll need to shift where the foreign keys are on your database before adding the relationships.\n\ntip\n\n💡 Download the Prisma VSCode Extension to provide autocomplete and helpful error messages as you transition your Prisma schema.\n\n## Generating a Prisma Client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#generating-a-prisma-client \"Direct link to Generating a Prisma Client\")\n\nWith the Prisma schema populated with the schema of your data, you're now ready to generate a Typescript Client to read and write to your MongoDB database.\n\n## Testing Reads[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#testing-reads \"Direct link to Testing Reads\")\n\nCreate a simple `test.ts` script to verify that Prisma Client can read and write to your application. Note that this guide is using the example in the [Prisma 1 examples repository](https://github.com/prisma/prisma1-examples/tree/master/typescript/docker-mongodb), but the code will change depending on your application.\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  await prisma.$connect()  const posts = await prisma.post.findMany()  console.log(posts)}main()  .catch(console.error)  .finally(() => prisma.$disconnect())\n```\n\nMake sure `ts-node` is installed globally and run:\n\nYou should see a list of your data:\n\n```\n[  {    comments: [],    id: '62435a83fca136000996ba16',    content: 'https://www.prisma.io/day/',    published: true,    title: 'Join us for Prisma Day 2019 in Berlin',    wasCreated: 2022-03-29T19:14:11.172Z,    wasUpdated: 2022-03-29T19:14:11.172Z  },  {    comments: [ [Object] ],    id: '62435a83fca136000996ba18',    content: 'https://graphqlweekly.com/',    published: true,    title: 'Subscribe to GraphQL Weekly for community news',    wasCreated: 2022-03-29T19:14:11.369Z,    wasUpdated: 2022-03-29T19:14:11.369Z  },  {    comments: [],    id: '62435a83fca136000996ba1a',    content: 'https://twitter.com/prisma',    published: false,    title: 'Follow Prisma on Twitter',    wasCreated: 2022-03-29T19:14:11.375Z,    wasUpdated: 2022-03-29T19:14:11.375Z  }]\n```\n\n## Testing Writes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#testing-writes \"Direct link to Testing Writes\")\n\nYou can then alter your `test.ts` to try writes:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  await prisma.$connect()  const user = await prisma.user.create({    data: {      email: 'alice@prisma.io',      name: 'Alice',    },  })  console.log(user)}main()  .catch(console.error)  .finally(() => prisma.$disconnect())\n```\n\nAnd you should see a user was created.\n\nwarning\n\nIf you see the following error:\n\n```\nPrisma needs to perform transactions, which requires your MongoDB server to be run as a replica set. https://pris.ly/d/mongodb-replica-set\n```\n\nThis means that your MongoDB database isn't running as a replica set. Refer to [the link above](https://pris.ly/d/mongodb-replica-set) for steps to resolve this issue.\n\n## Upgrading your Application[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#upgrading-your-application \"Direct link to Upgrading your Application\")\n\nNow that you have a working Prisma Client, you can start replacing Prisma Client 1 queries with the latest Prisma Client queries. The [Prisma Client Reference](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions-and-operators) is a helpful resource for learning how to use the latest Prisma Client.\n\n## Conclusion[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrade-from-mongodb-beta#conclusion \"Direct link to Conclusion\")\n\nI hope this brief guide was helpful in getting you started on the right path. Let us know if you have any questions or issues. We really appreciate your support over the years.",
    "title": "Upgrade from the Prisma 1 MongoDB Beta to Prisma ORM 2 or later | Prisma Documentation",
    "description": "Learn how to upgrade your MongoDB application running Prisma 1 to Prisma ORM 2 or later.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/views",
    "markdown": "# How to include views in your Prisma schema\n\nwarning\n\nSupport for views is currently a very early [Preview](https://www.prisma.io/docs/orm/more/releases#preview) feature. You can add a view to your Prisma schema with the `view` keyword or introspect the views in your database schema with `db pull`. You cannot yet apply views in your schema to your database with Prisma Migrate and `db push` unless the changes are added manually to your migration file using the `--create-only` flag.\n\nFor updates on progress with this feature, follow [our GitHub issue](https://github.com/prisma/prisma/issues/17335).\n\nDatabase views allow you to name and store queries. In relational databases, views are [stored SQL queries](https://www.postgresql.org/docs/current/sql-createview.html) that might include columns in multiple tables, or calculated values such as aggregates. In MongoDB, views are queryable objects where the contents are defined by an [aggregation pipeline](https://www.mongodb.com/docs/manual/core/aggregation-pipeline) on other collections.\n\nThe `views` preview feature allows you to represent views in your Prisma schema with the `view` keyword. To use views in Prisma ORM, follow these steps:\n\n*   [Enable the `views` preview feature](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#enable-the-views-preview-feature)\n*   [Create a view in the underlying database](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#create-a-view-in-the-underlying-database), either directly or as a [manual addition to a Prisma Migrate migration file](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#use-views-with-prisma-migrate-and-db-push), or use an existing view\n*   [Represent the view in your Prisma schema](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#add-views-to-your-prisma-schema)\n*   [Query the view in Prisma Client](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#query-views-in-prisma-client)\n\n## Enable the `views` preview feature[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#enable-the-views-preview-feature \"Direct link to enable-the-views-preview-feature\")\n\nSupport for views is currently in an early preview. To enable the `views` preview feature, add the `views` feature flag to the `previewFeatures` field of the `generator` block in your Prisma Schema:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"views\"]}\n```\n\nPlease leave feedback about this preview feature in our dedicated [preview feature feedback issue for `views`](https://github.com/prisma/prisma/issues/17335).\n\n## Create a view in the underlying database[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#create-a-view-in-the-underlying-database \"Direct link to Create a view in the underlying database\")\n\nCurrently, you cannot apply views that you define in your Prisma schema to your database with Prisma Migrate and `db push`. Instead, you must first create the view in the underlying database, either manually or [as part of a migration](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#use-views-with-prisma-migrate-and-db-push).\n\nFor example, take the following Prisma schema with a `User` model and a related `Profile` model:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  profile Profile?}model Profile {  id     Int    @id @default(autoincrement())  bio    String  user   User   @relation(fields: [userId], references: [id])  userId Int    @unique}\n```\n\nNext, take a `UserInfo` view in the underlying database that combines the `email` and `name` fields from the `User` model and the `bio` field from the `Profile` model.\n\nFor a relational database, the SQL statement to create this view is:\n\n```\nCREATE VIEW \"UserInfo\" AS    SELECT u.id, email, name, bio    FROM \"User\" u    LEFT JOIN \"Profile\" p ON u.id = p.\"userId\";\n```\n\nFor MongoDB, you can [create a view](https://www.mongodb.com/docs/manual/core/views/join-collections-with-view/) with the following command:\n\n```\ndb.createView('UserInfo', 'User', [  {    $lookup: {      from: 'Profile',      localField: '_id',      foreignField: 'userId',      as: 'ProfileData',    },  },  {    $project: {      _id: 1,      email: 1,      name: 1,      bio: '$ProfileData.bio',    },  },  { $unwind: '$bio' },])\n```\n\n## Use views with Prisma Migrate and `db push`[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#use-views-with-prisma-migrate-and-db-push \"Direct link to use-views-with-prisma-migrate-and-db-push\")\n\nIf you apply changes to your Prisma schema with Prisma Migrate or `db push`, Prisma ORM does not create or run any SQL related to views.\n\nTo include views in a migration, run `migrate dev --create-only` and then manually add the SQL for views to your migration file. Alternatively, you can create views manually in the database.\n\n## Add views to your Prisma schema[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#add-views-to-your-prisma-schema \"Direct link to Add views to your Prisma schema\")\n\nTo add a view to your Prisma schema, use the `view` keyword.\n\nYou can represent the `UserInfo` view from the example above in your Prisma schema as follows:\n\n*   Relational databases\n*   MongoDB\n\n```\nview UserInfo {  id    Int    @unique  email String  name  String  bio   String}\n```\n\n### Write by hand[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#write-by-hand \"Direct link to Write by hand\")\n\nA `view` block is comprised of two main pieces:\n\n*   The `view` block definition\n*   The view's field definitions\n\nThese two pieces allow you to define the name of your view in the generated Prisma Client and the columns present in your view's query results.\n\n#### Define a `view` block[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#define-a-view-block \"Direct link to define-a-view-block\")\n\nTo define the `UserInfo` view from the example above, begin by using the `view` keyword to define a `view` block in your schema named `UserInfo`:\n\n```\nview UserInfo {  // Fields}\n```\n\n#### Define fields[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#define-fields \"Direct link to Define fields\")\n\nThe properties of a view are called _fields_, which consist of:\n\n*   A field name\n*   A field type\n\nThe fields of the `UserInfo` example view can be defined as follows:\n\n*   Relational databases\n*   MongoDB\n\n```\nview UserInfo {  id    Int    @unique  email String  name  String  bio   String}\n```\n\nEach _field_ of a `view` block represents a column in the query results of the view in the underlying database.\n\n### Use introspection[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#use-introspection \"Direct link to Use introspection\")\n\nwarning\n\nCurrently only available for PostgreSQL, MySQL, SQL Server and CockroachDB.\n\nIf you have an existing view or views defined in your database, [introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection) will automatically generate `view` blocks in your Prisma schema that represent those views.\n\nAssuming the example `UserInfo` view exists in your underlying database, running the following command will generate a `view` block in your Prisma schema representing that view:\n\nThe resulting `view` block will be defined as follows:\n\n```\n/// The underlying view does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.view UserInfo {  id    Int?  email String?  name  String?  bio   String?  @@ignore}\n```\n\nThe `view` block is generated initially with a `@@ignore` attribute because [there is no unique identifier defined](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#unique-identifier) (which is currently a [limitation](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#unique-identifier) of the views preview feature).\n\nwarning\n\nPlease note for now `db pull` will only introspect views in your schema when using PostgreSQL, MySQL, SQL Server or CockroachDB. Support for this workflow will be extended to other database providers.\n\n#### Adding a unique identifier to an introspected view[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#adding-a-unique-identifier-to-an-introspected-view \"Direct link to Adding a unique identifier to an introspected view\")\n\nTo be able to use the introspected view in Prisma Client, you will need to select and define one or multiple of the fields as the unique identifier.\n\nIn the above view's case, the `id` column refers to a uniquely identifiable field in the underlying `User` table so that field can also be used as the uniquely identifiable field in the `view` block.\n\nIn order to make this `view` block valid you will need to:\n\n*   Remove the _optional_ flag `?` from the `id` field\n*   Add the `@unique` attribute to the `id` field\n*   Remove the `@@ignore` attribute\n*   Remove the generated comment warning about an invalid view\n\n```\n/// The underlying view does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.view UserInfo {  id    Int?  id    Int    @unique  email String?  name  String?  bio   String?    @@ignore}\n```\n\nWhen re-introspecting your database, any custom changes to your view definitions will be preserved.\n\n#### The `views` directory[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#the-views-directory \"Direct link to the-views-directory\")\n\nIntrospection of a database with one or more existing views will also create a new `views` directory within your `prisma` directory (starting with Prisma version 4.12.0). This directory will contain a subdirectory named after your database's schema which contains a `.sql` file for each view that was introspected in that schema. Each file will be named after an individual view and will contain the query the related view defines.\n\nFor example, after introspecting a database with the default `public` schema using the model used above you will find a `prisma/views/public/UserInfo.sql` file was created with the following contents:\n\n```\nSELECT  u.id,  u.email,  u.name,  p.bioFROM  (    \"User\" u    LEFT JOIN \"Profile\" p ON ((u.id = p.\"userId\"))  );\n```\n\n### Limitations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#limitations \"Direct link to Limitations\")\n\n#### Unique Identifier[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#unique-identifier \"Direct link to Unique Identifier\")\n\nCurrently, Prisma ORM treats views in the same way as models. This means that a view needs to have at least one _unique identifier_, which can be represented by any of the following:\n\n*   A unique constraint denoted with [`@unique`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-a-unique-field)\n*   A composite unique constraint denoted with [`@@unique`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-a-unique-field)\n*   An [`@id`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-an-id-field) field\n*   A composite identifier denoted with [`@@id`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#composite-ids)\n\nIn relational databases, a view's unique identifier can be defined as a `@unique` attribute on one field, or a `@@unique` attribute on multiple fields. When possible, it is preferable to use a `@unique` or `@@unique` constraint over an `@id` or `@@id` field.\n\nIn MongoDB, however, the unique identifier must be an `@id` attribute that maps to the `_id` field in the underlying database with `@map(\"_id\")`.\n\nIn the example above, the `id` field has a `@unique` attribute. If another column in the underlying `User` table had been defined as uniquely identifiable and made available in the view's query results, that column could have been used as the unique identifier instead.\n\n#### Introspection[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#introspection \"Direct link to Introspection\")\n\nCurrently, introspection of views is only available for PostgreSQL, MySQL, SQL Server and CockroachDB. If you are using another database provider, your views must be added manually.\n\nThis is a temporary limitation and support for introspection will be extended to the other supported datasource providers.\n\n## Query views in Prisma Client[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#query-views-in-prisma-client \"Direct link to Query views in Prisma Client\")\n\nYou can query views in Prisma Client in the same way that you query models. For example, the following query finds all users with a `name` of `'Alice'` in the `UserInfo` view defined above.\n\n```\nconst userinfo = await prisma.userInfo.findMany({  where: {    name: 'Alice',  },})\n```\n\nCurrently, Prisma Client allows you to update a view if the underlying database allows it, without any additional validation.\n\n## Special types of views[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#special-types-of-views \"Direct link to Special types of views\")\n\nThis section describes how to use Prisma ORM with updatable and materialized views in your database.\n\n### Updatable views[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#updatable-views \"Direct link to Updatable views\")\n\nSome databases support updatable views (e.g. [PostgreSQL](https://www.postgresql.org/docs/current/sql-createview.html#SQL-CREATEVIEW-UPDATABLE-VIEWS), [MySQL](https://dev.mysql.com/doc/refman/8.0/en/view-updatability.html) and [SQL Server](https://learn.microsoft.com/en-us/sql/t-sql/statements/create-view-transact-sql?view=sql-server-ver16#updatable-views)). Updatable views allow you to create, update or delete entries.\n\nCurrently Prisma ORM treats all `view`s as updatable views. If the underlying database supports this functionality for the view, the operation should succeed. If the view is not marked as updatable, the database will return an error, and Prisma Client will then throw this error.\n\nIn the future, Prisma Client might support marking individual views as updatable or not updatable. Please comment on our [`views` feedback issue](https://github.com/prisma/prisma/issues/17335) with your use case.\n\n### Materialized views[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#materialized-views \"Direct link to Materialized views\")\n\nSome databases support materialized views, e.g. [PostgreSQL](https://www.postgresql.org/docs/current/rules-materializedviews.html), [CockroachDB](https://www.cockroachlabs.com/docs/stable/views.html#materialized-views), [MongoDB](https://www.mongodb.com/docs/manual/core/materialized-views/), and [SQL Server](https://learn.microsoft.com/en-us/sql/relational-databases/views/create-indexed-views?view=sql-server-ver16) (where they're called \"indexed views\").\n\nMaterialized views persist the result of the view query for faster access and only update it on demand.\n\nCurrently Prisma ORM has no understanding of materialized views, but when you [manually create a view](https://www.prisma.io/docs/orm/prisma-schema/data-model/views#create-a-view-in-the-underlying-database) you can also create a materialized view by using the corresponding command in the underlying database. You can then use Prisma Client's [raw query functionality](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access) to execute the command to refresh the view manually.\n\nIn the future Prisma Client might support marking individual views as materialized and add a Prisma Client method to refresh the materialized view. Please comment on our [`views` feedback issue](https://github.com/prisma/prisma/issues/17335) with your use case.",
    "title": "How to include views in your Prisma schema | Prisma Documentation",
    "description": "How to include views in your Prisma schema",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance",
    "markdown": "# Table inheritance | Prisma Documentation\n\n## Overview[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#overview \"Direct link to Overview\")\n\nTable inheritance is a software design pattern that allows the modeling of hierarchical relationships between entities. Using table inheritance on the database level can also enable the use of union types in your JavaScript/TypeScript application or share a set of common properties across multiple models.\n\nThis page introduces two approaches to table inheritance and explains how to use them with Prisma ORM.\n\nA common use case for table inheritance may be when an application needs to display a _feed_ of some kind of _content activities_. A content activity in this case, could be a _video_ or an _article_. As an example, let's assume that:\n\n*   a content activity always has an `id` and a `url`\n*   in addition to `id` and a `url`, a video also has a `duration` (modeled as an `Int`)\n*   in addition to `id` and a `url`, an article also a `body` (modeled as a `String`)\n\n### Use cases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#use-cases \"Direct link to Use cases\")\n\n#### Union types[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#union-types \"Direct link to Union types\")\n\nUnion types are a convenient feature in TypeScript that allows developers to work more flexibly with the types in their data model.\n\nIn TypeScript, union types look as follows:\n\n```\ntype Activity = Video | Article\n```\n\nWhile [it's currently not possible to model union types in the Prisma schema](https://github.com/prisma/prisma/issues/2505), you can use them with Prisma ORM by using table inheritance and some additional type definitions.\n\n#### Sharing properties across multiple models[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#sharing-properties-across-multiple-models \"Direct link to Sharing properties across multiple models\")\n\nIf you have a use case where multiple models should share a particular set of properties, you can model this using table inheritance as well.\n\nFor example, if both the `Video` and `Article` models from above should have a shared `title` property, you can achieve this with table inheritance as well.\n\n### Example[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#example \"Direct link to Example\")\n\nIn a simple Prisma schema, this would look as follows. Note that we're adding a `User` model as well to illustrate how this can work with relations:\n\nschema.prisma\n\n```\nmodel Video {  id       Int    @id  url      String @unique  duration Int  user   User @relation(fields: [userId], references: [id])  userId Int}model Article {  id   Int    @id  url  String @unique  body String  user   User @relation(fields: [userId], references: [id])  userId Int}model User {  id       Int       @id  name     String  videos   Video[]  articles Article[]}\n```\n\nLet's investigate how we can model this using table inheritance.\n\n### Single-table vs multi-table inheritance[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#single-table-vs-multi-table-inheritance \"Direct link to Single-table vs multi-table inheritance\")\n\nHere is a quick comparison of the two main approaches for table inheritance:\n\n*   **Single-table inheritance (STI)**: Uses a _single_ table to store data of _all_ the different entities in one location. In our example, there'd be a single `Activity` table with the `id`, `url` as well as the `duration` and `body` column. It also uses a `type` column that indicates whether an _activity_ is a _video_ or an _article_.\n*   **Multi-table inheritance (MTI)**: Uses _multiple_ tables to store the data of the different entities separately and links them via foreign keys. In our example, there'd be an `Activity` table with the `id`, `url` column, a `Video` table with the `duration` and a foreign key to `Activity` as well as an `Article` table with the `body` and a foreign key. There is also a `type` column that acts as a discriminator and indicates whether an _activity_ is a _video_ or an _article_. Note that multi-table inheritance is also sometimes called _delegated types_.\n\nYou can learn about the tradeoffs of both approaches [below](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#tradeoffs-between-sti-and-mti).\n\n## Single-table inheritance (STI)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#single-table-inheritance-sti \"Direct link to Single-table inheritance (STI)\")\n\n### Data model[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#data-model \"Direct link to Data model\")\n\nUsing STI, the above scenario can be modeled as follows:\n\n```\nmodel Activity {  id       Int          @id // shared  url      String       @unique // shared  duration Int? // video-only  body     String? // article-only  type     ActivityType // discriminator  owner   User @relation(fields: [ownerId], references: [id])  ownerId Int}enum ActivityType {  Video  Article}model User {  id         Int        @id @default(autoincrement())  name       String?  activities Activity[]}\n```\n\nA few things to note:\n\n*   The model-specific properties `duration` and `body` must be marked as optional (i.e., with `?`). That's because a record in the `Activity` table that represents a _video_ must not have a value for `body`. Conversely, an `Activity` record representing an _article_ can never have a `duration` set.\n*   The `type` discriminator column indicates whether each record represents a _video_ or an _article_ item.\n\n### Prisma Client API[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#prisma-client-api \"Direct link to Prisma Client API\")\n\nDue to how Prisma ORM generates types and an API for the data model, there will only to be an `Activity` type and the CRUD queries that belong to it (`create`, `update`, `delete`, ...) available to you.\n\n#### Querying for videos and articles[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#querying-for-videos-and-articles \"Direct link to Querying for videos and articles\")\n\nYou can now query for only _videos_ or _articles_ by filtering on the `type` column. For example:\n\n```\n// Query all videosconst videos = await prisma.activity.findMany({  where: { type: 'Video' },})// Query all articlesconst articles = await prisma.activity.findMany({  where: { type: 'Article' },})\n```\n\n#### Defining dedicated types[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#defining-dedicated-types \"Direct link to Defining dedicated types\")\n\nWhen querying for videos and articles like that, TypeScript will still only recognize an `Activity` type. That can be annoying because even the objects in `videos` will have (optional) `body` and the objects in `articles` will have (optional) `duration` fields.\n\nIf you want to have type safety for these objects, you need to define dedicated types for them. You can do this, for example, by using the generated `Activity` type and the TypeScript `Omit` utility type to remove properties from it:\n\n```\nimport { Activity } from '@prisma/client'type Video = Omit<Activity, 'body' | 'type'>type Article = Omit<Activity, 'duration' | 'type'>\n```\n\nIn addition, it will be helpful to create mapping functions that convert an object of type `Activity` to the `Video` and `Article` types:\n\n```\nfunction activityToVideo(activity: Activity): Video {  return {    url: activity.url,    duration: activity.duration ? activity.duration : -1,    ownerId: activity.ownerId,  } as Video}function activityToArticle(activity: Activity): Article {  return {    url: activity.url,    body: activity.body ? activity.body : '',    ownerId: activity.ownerId,  } as Article}\n```\n\nNow you can turn an `Activity` into a more specific type (i.e., `Article` or `Video`) after querying:\n\n```\nconst videoActivities = await prisma.activity.findMany({  where: { type: 'Video' },})const videos: Video[] = videoActivities.map(activityToVideo)\n```\n\n#### Using Prisma Client extension for a more convenient API[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#using-prisma-client-extension-for-a-more-convenient-api \"Direct link to Using Prisma Client extension for a more convenient API\")\n\nYou can use [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) to create a more convenient API for the table structures in your database.\n\n## Multi-table inheritance (MTI)[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#multi-table-inheritance-mti \"Direct link to Multi-table inheritance (MTI)\")\n\n### Data model[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#data-model-1 \"Direct link to Data model\")\n\nUsing MTI, the above scenario can be modeled as follows:\n\n```\nmodel Activity {  id   Int          @id @default(autoincrement())  url  String // shared  type ActivityType // discriminator  video   Video? // model-specific 1-1 relation  article Article? // model-specific 1-1 relation  owner   User @relation(fields: [ownerId], references: [id])  ownerId Int}model Video {  id         Int      @id @default(autoincrement())  duration   Int // video-only  activityId Int      @unique  activity   Activity @relation(fields: [activityId], references: [id])}model Article {  id         Int      @id @default(autoincrement())  body       String // article-only   activityId Int      @unique  activity   Activity @relation(fields: [activityId], references: [id])}enum ActivityType {  Video  Article}model User {  id         Int        @id @default(autoincrement())  name       String?  activities Activity[]}\n```\n\nA few things to note:\n\n*   A 1-1 relation is needed between `Activity` and `Video` as well as `Activity` and `Article`. This relationship is used to fetch the specific information about a record when needed.\n*   The model-specific properties `duration` and `body` can be made _required_ with this approach.\n*   The `type` discriminator column indicates whether each record represents a _video_ or an _article_ item.\n\n### Prisma Client API[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#prisma-client-api-1 \"Direct link to Prisma Client API\")\n\nThis time, you can query for videos and articles directly via the `video` and `article` properties on your `PrismaClient` instance.\n\n#### Querying for videos and articles[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#querying-for-videos-and-articles-1 \"Direct link to Querying for videos and articles\")\n\nIf you want to access the shared properties, you need to use `include` to fetch the relation to `Activity`.\n\n```\n// Query all videosconst videos = await prisma.video.findMany({  include: { activity: true },})// Query all articlesconst articles = await prisma.article.findMany({  include: { activity: true },})\n```\n\nDepending on your needs, you may also query the other way around by filtering on the `type` discriminator column:\n\n```\n// Query all videosconst videoActivities = await prisma.activity.findMany({  where: { type: 'Video' }  include: { video: true }})\n```\n\n#### Defining dedicated types[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#defining-dedicated-types-1 \"Direct link to Defining dedicated types\")\n\nWhile a bit more convenient in terms of types compared to STI, the generated typings likely still won't fit all your needs.\n\nHere's how you can define `Video` and `Article` types by combining Prisma ORM's generated `Video` and `Article` types with the `Activity` type. These combinations create a new type with the desired properties. Note that we're also omitting the `type` discriminator column because that's not needed anymore on the specific types:\n\n```\nimport {  Video as VideoDB,  Article as ArticleDB,  Activity,} from '@prisma/client'type Video = Omit<VideoDB & Activity, 'type'>type Article = Omit<ArticleDB & Activity, 'type'>\n```\n\nOnce these types are defined, you can define mapping functions to convert the types you receive from the queries above into the desired `Video` and `Article` types. Here's the example for the `Video` type:\n\n```\nimport { Prisma, Video as VideoDB, Activity } from '@prisma/client'type Video = Omit<VideoDB & Activity, 'type'>// Create `VideoWithActivity` typings for the objects returned aboveconst videoWithActivity = Prisma.validator<Prisma.VideoDefaultArgs>()({  include: { activity: true },})type VideoWithActivity = Prisma.VideoGetPayload<typeof videoWithActivity>// Map to `Video` typefunction toVideo(a: VideoWithActivity): Video {  return {    id: a.id,    url: a.activity.url,    ownerId: a.activity.ownerId,    duration: a.duration,    activityId: a.activity.id,  }}\n```\n\nNow you can take the objects returned by the queries above and transform them using `toVideo`:\n\n```\nconst videoWithActivities = await prisma.video.findMany({  include: { activity: true },})const videos: Video[] = videoWithActivities.map(toVideo)\n```\n\n#### Using Prisma Client extension for a more convenient API[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#using-prisma-client-extension-for-a-more-convenient-api-1 \"Direct link to Using Prisma Client extension for a more convenient API\")\n\nYou can use [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) to create a more convenient API for the table structures in your database.\n\n## Tradeoffs between STI and MTI[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#tradeoffs-between-sti-and-mti \"Direct link to Tradeoffs between STI and MTI\")\n\n*   **Data model**: The data model may feel more clean with MTI. With STI, you may end up with very wide rows and lots of columns that have `NULL` values in them.\n*   **Performance**: MTI may come with a performance cost because you need to join the parent and child tables to access _all_ properties relevant for a model.\n*   **Typings**: With Prisma ORM, MTI gives you proper typings for the specific models (i.e., `Article` and `Video` in the examples above) already, while you need to create these from scratch with STI.\n*   **IDs / Primary keys**: With MTI, records have two IDs (one on the parent and another on the child table) that may not match. You need to consider this in the business logic of your application.\n\n## Third-party solutions[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/table-inheritance#third-party-solutions \"Direct link to Third-party solutions\")\n\nWhile Prisma ORM doesn't natively support union types or polymorphism at the moment, you can check out [Zenstack](https://github.com/zenstackhq/zenstack) which is adding an extra layer of features to the Prisma schema. Read their [blog post about polymorphism in Prisma ORM](https://zenstack.dev/blog/polymorphism) to learn more.",
    "title": "Table inheritance | Prisma Documentation",
    "description": "Learn about the use cases and patterns for table inheritance in Prisma ORM that enable usage of union types or polymorphic structures in your application.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types",
    "markdown": "# Operating against partial structures of your model types\n\nWhen using Prisma Client, every model from your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) is translated into a dedicated TypeScript type. For example, assume you have the following `User` and `Post` models:\n\n```\nmodel User {  id    Int     @id  email String  @unique  name  String?  posts Post[]}model Post {  id        Int     @id  author    User    @relation(fields: [userId], references: [id])  title     String  published Boolean @default(false)  userId    Int}\n```\n\nThe Prisma Client code that's generated from this schema contains this representation of the `User` type:\n\n```\nexport declare type User = {  id: string  email: string  name: string | null}\n```\n\n## Problem: Using variations of the generated model type[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types#problem-using-variations-of-the-generated-model-type \"Direct link to Problem: Using variations of the generated model type\")\n\n### Description[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types#description \"Direct link to Description\")\n\nIn some scenarios, you may need a _variation_ of the generated `User` type. For example, when you have a function that expects an instance of the `User` model that carries the `posts` relation. Or when you need a type to pass only the `User` model's `email` and `name` fields around in your application code.\n\n### Solution[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types#solution \"Direct link to Solution\")\n\nAs a solution, you can customize the generated model type using Prisma Client's helper types.\n\nThe `User` type only contains the model's [scalar](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) fields, but doesn't account for any relations. That's because [relations are not included by default](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#return-the-default-selection-set) in Prisma Client queries.\n\nHowever, sometimes it's useful to have a type available that **includes a relation** (i.e. a type that you'd get from an API call that uses [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields)). Similarly, another useful scenario could be to have a type available that **includes only a subset of the model's scalar fields** (i.e. a type that you'd get from an API call that uses [`select`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#select-specific-fields)).\n\nOne way of achieving this would be to define these types manually in your application code:\n\n```\n// 1: Define a type that includes the relation to `Post`type UserWithPosts = {  id: string  email: string  name: string | null  posts: Post[]}// 2: Define a type that only contains a subset of the scalar fieldstype UserPersonalData = {  email: string  name: string | null}\n```\n\nWhile this is certainly feasible, this approach increases the maintenance burden upon changes to the Prisma schema as you need to manually maintain the types. A cleaner solution to this is to use the `UserGetPayload` type that is generated and exposed by Prisma Client under the `Prisma` namespace in combination with the [`validator`](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-validator).\n\nThe following example uses the `Prisma.validator` to create two type-safe objects and then uses the `Prisma.UserGetPayload` utility function to create a type that can be used to return all users and their posts.\n\n```\nimport { Prisma } from '@prisma/client'// 1: Define a type that includes the relation to `Post`const userWithPosts = Prisma.validator<Prisma.UserDefaultArgs>()({  include: { posts: true },})// 2: Define a type that only contains a subset of the scalar fieldsconst userPersonalData = Prisma.validator<Prisma.UserDefaultArgs>()({  select: { email: true, name: true },})// 3: This type will include a user and all their poststype UserWithPosts = Prisma.UserGetPayload<typeof userWithPosts>\n```\n\nThe main benefits of the latter approach are:\n\n*   Cleaner approach as it leverages Prisma Client's generated types\n*   Reduced maintenance burden and improved type safety when the schema changes\n\n## Problem: Getting access to the return type of a function[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types#problem-getting-access-to-the-return-type-of-a-function \"Direct link to Problem: Getting access to the return type of a function\")\n\n### Description[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types#description-1 \"Direct link to Description\")\n\nWhen doing [`select`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#select) or [`include`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#include) operations on your models and returning these variants from a function, it can be difficult to gain access to the return type, e.g:\n\n```\n// Function definition that returns a partial structureasync function getUsersWithPosts() {  const users = await prisma.user.findMany({ include: { posts: true } })  return users}\n```\n\nExtracting the type that represents \"users with posts\" from the above code snippet requires some advanced TypeScript usage:\n\n```\n// Function definition that returns a partial structureasync function getUsersWithPosts() {  const users = await prisma.user.findMany({ include: { posts: true } })  return users}// Extract `UsersWithPosts` type withtype ThenArg<T> = T extends PromiseLike<infer U> ? U : Ttype UsersWithPosts = ThenArg<ReturnType<typeof getUsersWithPosts>>// run inside `async` functionconst usersWithPosts: UsersWithPosts = await getUsersWithPosts()\n```\n\n### Solution[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types#solution-1 \"Direct link to Solution\")\n\nWith the `PromiseReturnType` that is exposed by the `Prisma` namespace, you can solve this more elegantly:\n\n```\nimport { Prisma } from '@prisma/client'type UsersWithPosts = Prisma.PromiseReturnType<typeof getUsersWithPosts>\n```",
    "title": "Operating against partial structures of your model types | Prisma Documentation",
    "description": "This page documents various scenarios for using the generated types from the Prisma namespace",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations",
    "markdown": "# One-to-many relations | Prisma Documentation\n\nThis page introduces one-to-many relations and explains how to use them in your Prisma schema.\n\n## Overview[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations#overview \"Direct link to Overview\")\n\nOne-to-many (1-n) relations refer to relations where one record on one side of the relation can be connected to zero or more records on the other side. In the following example, there is one one-to-many relation between the `User` and `Post` models:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  posts Post[]}model Post {  id       Int  @id @default(autoincrement())  author   User @relation(fields: [authorId], references: [id])  authorId Int}\n```\n\n> **Note** The `posts` field does not \"manifest\" in the underlying database schema. On the other side of the relation, the [annotated relation field](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) `author` and its relation scalar `authorId` represent the side of the relation that stores the foreign key in the underlying database.\n\nThis one-to-many relation expresses the following:\n\n*   \"a user can have zero or more posts\"\n*   \"a post must always have an author\"\n\nIn the previous example, the `author` relation field of the `Post` model references the `id` field of the `User` model. You can also reference a different field. In this case, you need to mark the field with the `@unique` attribute, to guarantee that there is only a single `User` connected to each `Post`. In the following example, the `author` field references an `email` field in the `User` model, which is marked with the `@unique` attribute:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  email String @unique // <-- add unique attribute  posts Post[]}model Post {  id          Int    @id @default(autoincrement())  authorEmail String  author      User   @relation(fields: [authorEmail], references: [email])}\n```\n\nwarning\n\nIn MySQL, you can create a foreign key with only an index on the referenced side, and not a unique constraint. In Prisma ORM versions 4.0.0 and later, if you introspect a relation of this type it will trigger a validation error. To fix this, you will need to add a `@unique` constraint to the referenced field.\n\n## Multi-field relations in relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations#multi-field-relations-in-relational-databases \"Direct link to Multi-field relations in relational databases\")\n\nIn **relational databases only**, you can also define this relation using [multi-field IDs](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1)/composite key:\n\n```\nmodel User {  firstName String  lastName  String  post      Post[]  @@id([firstName, lastName])}model Post {  id              Int    @id @default(autoincrement())  author          User   @relation(fields: [authorFirstName, authorLastName], references: [firstName, lastName])  authorFirstName String // relation scalar field (used in the `@relation` attribute above)  authorLastName  String // relation scalar field (used in the `@relation` attribute above)}\n```\n\n## 1-n relations in the database[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations#1-n-relations-in-the-database \"Direct link to 1-n relations in the database\")\n\n### Relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations#relational-databases \"Direct link to Relational databases\")\n\nThe following example demonstrates how to create a 1-n relation in SQL:\n\n```\nCREATE TABLE \"User\" (    id SERIAL PRIMARY KEY);CREATE TABLE \"Post\" (    id SERIAL PRIMARY KEY,    \"authorId\" integer NOT NULL,    FOREIGN KEY (\"authorId\") REFERENCES \"User\"(id));\n```\n\nSince there's no `UNIQUE` constraint on the `authorId` column (the foreign key), you can create **multiple `Post` records that point to the same `User` record**. This makes the relation a one-to-many rather than a one-to-one.\n\nThe following example demonstrates how to create a 1-n relation in SQL using a composite key (`firstName` and `lastName`):\n\n```\nCREATE TABLE \"User\" (    firstName TEXT,    lastName TEXT,    PRIMARY KEY (\"firstName\",\"lastName\"));CREATE TABLE \"Post\" (    id SERIAL PRIMARY KEY,    \"authorFirstName\" TEXT NOT NULL,    \"authorLastName\" TEXT NOT NULL,    FOREIGN KEY (\"authorFirstName\", \"authorLastName\") REFERENCES \"User\"(\"firstName\", \"lastName\"));\n```\n\n#### Comparing one-to-one and one-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations#comparing-one-to-one-and-one-to-many-relations \"Direct link to Comparing one-to-one and one-to-many relations\")\n\nIn relational databases, the main difference between a 1-1 and a 1-n-relation is that in a 1-1-relation the foreign key must have a `UNIQUE` constraint defined on it.\n\n### MongoDB[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations#mongodb \"Direct link to MongoDB\")\n\nFor MongoDB, Prisma ORM currently uses a [normalized data model design](https://docs.mongodb.com/manual/core/data-model-design/), which means that documents reference each other by ID in a similar way to relational databases.\n\nThe following MongoDB document represents a `User`:\n\n```\n{ \"_id\": { \"$oid\": \"60d5922d00581b8f0062e3a8\" }, \"name\": \"Ella\" }\n```\n\nEach of the following `Post` MongoDB documents has an `authorId` field which references the same user:\n\n```\n[  {    \"_id\": { \"$oid\": \"60d5922e00581b8f0062e3a9\" },    \"title\": \"How to make sushi\",    \"authorId\": { \"$oid\": \"60d5922d00581b8f0062e3a8\" }  },  {    \"_id\": { \"$oid\": \"60d5922e00581b8f0062e3aa\" },    \"title\": \"How to re-install Windows\",    \"authorId\": { \"$oid\": \"60d5922d00581b8f0062e3a8\" }  }]\n```\n\n#### Comparing one-to-one and one-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations#comparing-one-to-one-and-one-to-many-relations-1 \"Direct link to Comparing one-to-one and one-to-many relations\")\n\nIn MongoDB, the only difference between a 1-1 and a 1-n is the number of documents referencing another document in the database - there are no constraints.\n\n## Required and optional relation fields in one-to-many relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations#required-and-optional-relation-fields-in-one-to-many-relations \"Direct link to Required and optional relation fields in one-to-many relations\")\n\nA 1-n-relation always has two relation fields:\n\n*   a [list](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) relation field which is _not_ annotated with `@relation`\n*   the [annotated relation field](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#annotated-relation-fields) (including its relation scalar)\n\nThe annotated relation field and relation scalar of a 1-n relation can either _both_ be optional, or _both_ be mandatory. On the other side of the relation, the list is **always mandatory**.\n\n### Optional one-to-many relation[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations#optional-one-to-many-relation \"Direct link to Optional one-to-many relation\")\n\nIn the following example, you can create a `Post` without assigning a `User`:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  posts Post[]}model Post {  id       Int   @id @default(autoincrement())  author   User? @relation(fields: [authorId], references: [id])  authorId Int?}\n```\n\n### Mandatory one-to-many relation[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-many-relations#mandatory-one-to-many-relation \"Direct link to Mandatory one-to-many relation\")\n\nIn the following example, you must assign a `User` when you create a `Post`:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  posts Post[]}model Post {  id       Int  @id @default(autoincrement())  author   User @relation(fields: [authorId], references: [id])  authorId Int}\n```",
    "title": "One-to-many relations | Prisma Documentation",
    "description": "How to define and work with one-to-many relations in Prisma.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-composite-ids-and-constraints",
    "markdown": "# Working with compound IDs and unique constraints (Concepts)\n\nComposite IDs and compound unique constraints can be defined in your Prisma schema using the [`@@id`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1) and [`@@unique`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique-1) attributes.\n\nwarning\n\n**MongoDB does not support `@@id`**  \nMongoDB does not support composite IDs, which means you cannot identify a model with a `@@id` attribute.\n\nA composite ID or compound unique constraint uses the combined values of two fields as a primary key or identifier in your database table. In the following example, the `postId` field and `userId` field are used as a composite ID for a `Like` table:\n\n```\nmodel User {  id    Int    @id @default(autoincrement())  name  String  post  Post[]  likes Like[]}model Post {  id      Int    @id @default(autoincrement())  content String  User    User?  @relation(fields: [userId], references: [id])  userId  Int?  likes   Like[]}model Like {  postId Int  userId Int  User   User @relation(fields: [userId], references: [id])  Post   Post @relation(fields: [postId], references: [id])  @@id([postId, userId])}\n```\n\nQuerying for records from the `Like` table (e.g. using `prisma.like.findMany()`) would return objects that look as follows:\n\n```\n{  \"postId\": 1,  \"userId\": 1}\n```\n\nAlthough there are only two fields in the response, those two fields make up a compound ID named `postId_userId`.\n\nYou can also create a named compound ID or compound unique constraint by using the `@@id` or `@@unique` attributes' `name` field. For example:\n\n```\nmodel Like {  postId Int  userId Int  User   User @relation(fields: [userId], references: [id])  Post   Post @relation(fields: [postId], references: [id])  @@id(name: \"likeId\", [postId, userId])}\n```\n\n## Where you can use compound IDs and unique constraints[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-composite-ids-and-constraints#where-you-can-use-compound-ids-and-unique-constraints \"Direct link to Where you can use compound IDs and unique constraints\")\n\nCompound IDs and compound unique constraints can be used when working with _unique_ data.\n\nBelow is a list of Prisma Client functions that accept a compound ID or compound unique constraint in the `where` filter of the query:\n\n*   `findUnique()`\n*   `findUniqueOrThrow`\n*   `delete`\n*   `update`\n*   `upsert`\n\nA composite ID and a composite unique constraint is also usable when creating relational data with `connect` and `connectOrCreate`.\n\n## Filtering records by a compound ID or unique constraint[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-composite-ids-and-constraints#filtering-records-by-a-compound-id-or-unique-constraint \"Direct link to Filtering records by a compound ID or unique constraint\")\n\nAlthough your query results will not display a compound ID or unique constraint as a field, you can use these compound values to filter your queries for unique records:\n\n```\nconst like = await prisma.like.findUnique({  where: {    likeId: {      userId: 1,      postId: 1,    },  },})\n```\n\ninfo\n\nNote composite ID and compound unique constraint keys are only available as filter options for _unique_ queries such as `findUnique()` and `findUniqueOrThrow`. See the [section](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-composite-ids-and-constraints#where-you-can-use-compound-ids-and-unique-constraints) above for a list of places these fields may be used.\n\n## Deleting records by a compound ID or unique constraint[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-composite-ids-and-constraints#deleting-records-by-a-compound-id-or-unique-constraint \"Direct link to Deleting records by a compound ID or unique constraint\")\n\nA compound ID or compound unique constraint may be used in the `where` filter of a `delete` query:\n\n```\nconst like = await prisma.like.delete({  where: {    likeId: {      userId: 1,      postId: 1,    },  },})\n```\n\n## Updating and upserting records by a compound ID or unique constraint[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-composite-ids-and-constraints#updating-and-upserting-records-by-a-compound-id-or-unique-constraint \"Direct link to Updating and upserting records by a compound ID or unique constraint\")\n\nA compound ID or compound unique constraint may be used in the `where` filter of an `update` query:\n\n```\nconst like = await prisma.like.update({  where: {    likeId: {      userId: 1,      postId: 1,    },  },  data: {    postId: 2,  },})\n```\n\nThey may also be used in the `where` filter of an `upsert` query:\n\n```\nawait prisma.like.upsert({  where: {    likeId: {      userId: 1,      postId: 1,    },  },  update: {    userId: 2,  },  create: {    userId: 2,    postId: 1,  },})\n```\n\n## Filtering relation queries by a compound ID or unique constraint[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-composite-ids-and-constraints#filtering-relation-queries-by-a-compound-id-or-unique-constraint \"Direct link to Filtering relation queries by a compound ID or unique constraint\")\n\nCompound IDs and compound unique constraint can also be used in the `connect` and `connectOrCreate` keys used when connecting records to create a relationship.\n\nFor example, consider this query:\n\n```\nawait prisma.user.create({  data: {    name: 'Alice',    likes: {      connect: {        likeId: {          postId: 1,          userId: 2,        },      },    },  },})\n```\n\nThe `likeId` compound ID is used as the identifier in the `connect` object that is used to locate the `Like` table's record that will be linked to the new user: `\"Alice\"`.\n\nSimilarly, the `likeId` can be used in `connectOrCreate`'s `where` filter to attempt to locate an existing record in the `Like` table:\n\n```\nawait prisma.user.create({  data: {    name: 'Alice',    likes: {      connectOrCreate: {        create: {          postId: 1,        },        where: {          likeId: {            postId: 1,            userId: 1,          },        },      },    },  },})\n```",
    "title": "Working with compound IDs and unique constraints (Concepts) | Prisma Documentation",
    "description": "How to read, write, and filter by compound IDs and unique constraints.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations",
    "markdown": "# Self-relations | Prisma Documentation\n\nA relation field can also reference its own model, in this case the relation is called a _self-relation_. Self-relations can be of any cardinality, 1-1, 1-n and m-n.\n\nNote that self-relations always require the `@relation` attribute.\n\n## One-to-one self-relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#one-to-one-self-relations \"Direct link to One-to-one self-relations\")\n\nThe following example models a one-to-one self-relation:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id          Int     @id @default(autoincrement())  name        String?  successorId Int?    @unique  successor   User?   @relation(\"BlogOwnerHistory\", fields: [successorId], references: [id])  predecessor User?   @relation(\"BlogOwnerHistory\")}\n```\n\nThis relation expresses the following:\n\n*   \"a user can have one or zero predecessors\" (for example, Sarah is Mary's predecessor as blog owner)\n*   \"a user can have one or zero successors\" (for example, Mary is Sarah's successor as blog owner)\n\n> **Note**: One-to-one self-relations cannot be made required on both sides. One or both sides must be optional, otherwise it becomes impossible to create the first `User` record.\n\nTo create a one-to-one self-relation:\n\n*   Both sides of the relation must define a `@relation` attribute that share the same name - in this case, **BlogOwnerHistory**.\n*   One relation field must be a [fully annotated](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields). In this example, the `successor` field defines both the `field` and `references` arguments.\n*   One relation field must be backed by a foreign key. The `successor` field is backed by the `successorId` foreign key, which references a value in the `id` field. The `successorId` scalar relation field also requires a `@unique` attribute to guarantee a one-to-one relation.\n\n> **Note**: One-to-one self relations require two sides even if both sides are equal in the relationship. For example, to model a 'best friends' relation, you would need to create two relation fields: `bestfriend1` and a `bestfriend2`.\n\nEither side of the relation can be backed by a foreign key. In the previous example, repeated below, `successor` is backed by `successorId`:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id          Int     @id @default(autoincrement())  name        String?  successorId Int?    @unique  successor   User?   @relation(\"BlogOwnerHistory\", fields: [successorId], references: [id])  predecessor User?   @relation(\"BlogOwnerHistory\")}\n```\n\nAlternatively, you could rewrite this so that `predecessor` is backed by `predecessorId`:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id            Int     @id @default(autoincrement())  name          String?  successor     User?   @relation(\"BlogOwnerHistory\")  predecessorId Int?    @unique  predecessor   User?   @relation(\"BlogOwnerHistory\", fields: [predecessorId], references: [id])}\n```\n\nNo matter which side is backed by a foreign key, Prisma Client surfaces both the `predecessor` and `successor` fields:\n\n```\nconst x = await prisma.user.create({  data: {    name: \"Bob McBob\",      successor: {      connect: {        id: 2,      },    },      predecessor: {      connect: {        id: 4,      },    },  },});\n```\n\n### One-to-one self relations in the database[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#one-to-one-self-relations-in-the-database \"Direct link to One-to-one self relations in the database\")\n\n### Relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#relational-databases \"Direct link to Relational databases\")\n\nIn **relational databases only**, a one-to-one self-relation is represented by the following SQL:\n\n```\nCREATE TABLE \"User\" (    id SERIAL PRIMARY KEY,    \"name\" TEXT,    \"successorId\" INTEGER);ALTER TABLE \"User\" ADD CONSTRAINT fk_successor_user FOREIGN KEY (\"successorId\") REFERENCES \"User\" (id);ALTER TABLE \"User\" ADD CONSTRAINT successor_unique UNIQUE (\"successorId\");\n```\n\n### MongoDB[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#mongodb \"Direct link to MongoDB\")\n\nFor MongoDB, Prisma ORM currently uses a [normalized data model design](https://docs.mongodb.com/manual/core/data-model-design/), which means that documents reference each other by ID in a similar way to relational databases.\n\nThe following MongoDB documents represent a one-to-one self-relation between two users:\n\n```\n{ \"_id\": { \"$oid\": \"60d97df70080618f000e3ca9\" }, \"name\": \"Elsa the Elder\" }\n```\n\n```\n{  \"_id\": { \"$oid\": \"60d97df70080618f000e3caa\" },  \"name\": \"Elsa\",  \"successorId\": { \"$oid\": \"60d97df70080618f000e3ca9\" }}\n```\n\n## One-to-many self relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#one-to-many-self-relations \"Direct link to One-to-many self relations\")\n\nA one-to-many self-relation looks as follows:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id        Int     @id @default(autoincrement())  name      String?  teacherId Int?  teacher   User?   @relation(\"TeacherStudents\", fields: [teacherId], references: [id])  students  User[]  @relation(\"TeacherStudents\")}\n```\n\nThis relation expresses the following:\n\n*   \"a user has zero or one _teachers_ \"\n*   \"a user can have zero or more _students_\"\n\nNote that you can also require each user to have a teacher by making the `teacher` field [required](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#optional-and-mandatory-fields).\n\n### One-to-many self-relations in the database[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#one-to-many-self-relations-in-the-database \"Direct link to One-to-many self-relations in the database\")\n\n### Relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#relational-databases-1 \"Direct link to Relational databases\")\n\nIn relational databases, a one-to-many self-relation is represented by the following SQL:\n\n```\nCREATE TABLE \"User\" (    id SERIAL PRIMARY KEY,    \"name\" TEXT,    \"teacherId\" INTEGER);ALTER TABLE \"User\" ADD CONSTRAINT fk_teacherid_user FOREIGN KEY (\"teacherId\") REFERENCES \"User\" (id);\n```\n\nNotice the lack of `UNIQUE` constraint on `teacherId` - multiple students can have the same teacher.\n\n### MongoDB[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#mongodb-1 \"Direct link to MongoDB\")\n\nFor MongoDB, Prisma ORM currently uses a [normalized data model design](https://docs.mongodb.com/manual/core/data-model-design/), which means that documents reference each other by ID in a similar way to relational databases.\n\nThe following MongoDB documents represent a one-to-many self-relation between three users - one teacher and two students with the same `teacherId`:\n\n```\n{  \"_id\": { \"$oid\": \"60d9b9e600fe3d470079d6f9\" },  \"name\": \"Ms. Roberts\"}\n```\n\n```\n{  \"_id\": { \"$oid\": \"60d9b9e600fe3d470079d6fa\" },  \"name\": \"Student 8\",  \"teacherId\": { \"$oid\": \"60d9b9e600fe3d470079d6f9\" }}\n```\n\n```\n{  \"_id\": { \"$oid\": \"60d9b9e600fe3d470079d6fb\" },  \"name\": \"Student 9\",  \"teacherId\": { \"$oid\": \"60d9b9e600fe3d470079d6f9\" }}\n```\n\n## Many-to-many self relations[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#many-to-many-self-relations \"Direct link to Many-to-many self relations\")\n\nA many-to-many self-relation looks as follows:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id         Int     @id @default(autoincrement())  name       String?  followedBy User[]  @relation(\"UserFollows\")  following  User[]  @relation(\"UserFollows\")}\n```\n\nThis relation expresses the following:\n\n*   \"a user can be followed by zero or more users\"\n*   \"a user can follow zero or more users\"\n\nNote that for relational databases, this many-to-many-relation is [implicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations). This means Prisma ORM maintains a [relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables) for it in the underlying database.\n\nIf you need the relation to hold other fields, you can create an [explicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations) many-to-many self relation as well. The explicit version of the self relation shown previously is as follows:\n\n```\nmodel User {  id         Int       @id @default(autoincrement())  name       String?  followedBy Follows[] @relation(\"followedBy\")  following  Follows[] @relation(\"following\")}model Follows {  followedBy   User @relation(\"followedBy\", fields: [followedById], references: [id])  followedById Int  following    User @relation(\"following\", fields: [followingId], references: [id])  followingId  Int  @@id([followingId, followedById])}\n```\n\n### Many-to-many self-relations in the database[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#many-to-many-self-relations-in-the-database \"Direct link to Many-to-many self-relations in the database\")\n\n### Relational databases[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#relational-databases-2 \"Direct link to Relational databases\")\n\nIn relational databases, a many-to-many self-relation (implicit) is represented by the following SQL:\n\n```\nCREATE TABLE \"User\" (    id integer DEFAULT nextval('\"User_id_seq\"'::regclass) PRIMARY KEY,    name text);CREATE TABLE \"_UserFollows\" (    \"A\" integer NOT NULL REFERENCES \"User\"(id) ON DELETE CASCADE ON UPDATE CASCADE,    \"B\" integer NOT NULL REFERENCES \"User\"(id) ON DELETE CASCADE ON UPDATE CASCADE);\n```\n\n### MongoDB[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#mongodb-2 \"Direct link to MongoDB\")\n\nFor MongoDB, Prisma ORM currently uses a [normalized data model design](https://docs.mongodb.com/manual/core/data-model-design/), which means that documents reference each other by ID in a similar way to relational databases.\n\nThe following MongoDB documents represent a many-to-many self-relation between five users - two users that follow `\"Bob\"`, and two users that follow him:\n\n```\n{  \"_id\": { \"$oid\": \"60d9866f00a3e930009a6cdd\" },  \"name\": \"Bob\",  \"followedByIDs\": [    { \"$oid\": \"60d9866f00a3e930009a6cde\" },    { \"$oid\": \"60d9867000a3e930009a6cdf\" }  ],  \"followingIDs\": [    { \"$oid\": \"60d9867000a3e930009a6ce0\" },    { \"$oid\": \"60d9867000a3e930009a6ce1\" }  ]}\n```\n\n```\n{  \"_id\": { \"$oid\": \"60d9866f00a3e930009a6cde\" },  \"name\": \"Follower1\",  \"followingIDs\": [{ \"$oid\": \"60d9866f00a3e930009a6cdd\" }]}\n```\n\n```\n{  \"_id\": { \"$oid\": \"60d9867000a3e930009a6cdf\" },  \"name\": \"Follower2\",  \"followingIDs\": [{ \"$oid\": \"60d9866f00a3e930009a6cdd\" }]}\n```\n\n```\n{  \"_id\": { \"$oid\": \"60d9867000a3e930009a6ce0\" },  \"name\": \"CoolPerson1\",  \"followedByIDs\": [{ \"$oid\": \"60d9866f00a3e930009a6cdd\" }]}\n```\n\n```\n{  \"_id\": { \"$oid\": \"60d9867000a3e930009a6ce1\" },  \"name\": \"CoolPerson2\",  \"followedByIDs\": [{ \"$oid\": \"60d9866f00a3e930009a6cdd\" }]}\n```\n\n## Defining multiple self-relations on the same model[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations#defining-multiple-self-relations-on-the-same-model \"Direct link to Defining multiple self-relations on the same model\")\n\nYou can also define multiple self-relations on the same model at once. Taking all relations from the previous sections as example, you could define a `User` model as follows:\n\n*   Relational databases\n*   MongoDB\n\n```\nmodel User {  id         Int     @id @default(autoincrement())  name       String?  teacherId  Int?  teacher    User?   @relation(\"TeacherStudents\", fields: [teacherId], references: [id])  students   User[]  @relation(\"TeacherStudents\")  followedBy User[]  @relation(\"UserFollows\")  following  User[]  @relation(\"UserFollows\")}\n```",
    "title": "Self-relations | Prisma Documentation",
    "description": "How to define and work with self-relations in Prisma.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/troubleshooting-relations",
    "markdown": "# Troubleshooting relations | Prisma Documentation\n\nModelling your schema can sometimes offer up some unexpected results. This section aims to cover the most prominent of those.\n\n## Implicit many-to-many self-relations return incorrect data if order of relation fields change[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/troubleshooting-relations#implicit-many-to-many-self-relations-return-incorrect-data-if-order-of-relation-fields-change \"Direct link to Implicit many-to-many self-relations return incorrect data if order of relation fields change\")\n\n### Problem[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/troubleshooting-relations#problem \"Direct link to Problem\")\n\nIn the following implicit many-to-many self-relation, the lexicographic order of relation fields in `a_eats` (1) and `b_eatenBy` (2):\n\n```\nmodel Animal {  id        Int      @id @default(autoincrement())  name      String  a_eats    Animal[] @relation(name: \"FoodChain\")  b_eatenBy Animal[] @relation(name: \"FoodChain\")}\n```\n\nThe resulting relation table in SQL looks as follows, where `A` represents prey (`a_eats`) and `B` represents predators (`b_eatenBy`):\n\n| A   | B   |\n| --- | --- |\n| 8 (Plankton) | 7 (Salmon) |\n| 7 (Salmon) | 9 (Bear) |\n\nThe following query returns a salmon's prey and predators:\n\n```\nconst getAnimals = await prisma.animal.findMany({  where: {    name: 'Salmon',  },  include: {    b_eats: true,    a_eatenBy: true,  },})\n```\n\nNow change the order of the relation fields:\n\n```\nmodel Animal {  id        Int      @id @default(autoincrement())  name      String  b_eats    Animal[] @relation(name: \"FoodChain\")  a_eatenBy Animal[] @relation(name: \"FoodChain\")}\n```\n\nMigrate your changes and re-generate Prisma Client. When you run the same query with the updated field names, Prisma Client returns incorrect data (salmon now eats bears and gets eaten by plankton):\n\n```\nconst getAnimals = await prisma.animal.findMany({  where: {    name: 'Salmon',  },  include: {    b_eats: true,    a_eatenBy: true,  },})\n```\n\nAlthough the lexicographic order of the relation fields in the Prisma schema changed, columns `A` and `B` in the database **did not change** (they were not renamed and data was not moved). Therefore, `A` now represents predators (`a_eatenBy`) and `B` represents prey (`b_eats`):\n\n| A   | B   |\n| --- | --- |\n| 8 (Plankton) | 7 (Salmon) |\n| 7 (Salmon) | 9 (Bear) |\n\n### Solution[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/troubleshooting-relations#solution \"Direct link to Solution\")\n\nIf you rename relation fields in an implicit many-to-many self-relations, make sure that you maintain the alphabetic order of the fields - for example, by prefixing with `a_` and `_b`.\n\n## How to use a relation table with a many-to-many relationship[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/troubleshooting-relations#how-to-use-a-relation-table-with-a-many-to-many-relationship \"Direct link to How to use a relation table with a many-to-many relationship\")\n\nThere are a couple of ways to define a m-n relationship, implicitly or explicitly. Implicitly means letting Prisma ORM handle the relation table (JOIN table) under the hood, all you have to do is define an array/list for the non scalar types on each model, see [implicit many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations).\n\nWhere you might run into trouble is when creating an [explicit m-n relationship](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations), that is, to create and handle the relation table yourself. **It can be overlooked that Prisma ORM requires both sides of the relation to be present**.\n\nTake the following example, here a relation table is created to act as the JOIN between the `Post` and `Category` tables. This will not work however as the relation table (`PostCategories`) must form a 1-to-many relationship with the other two models respectively.\n\nThe back relation fields are missing from the `Post` to `PostCategories` and `Category` to `PostCategories` models.\n\n```\n// This example schema shows how NOT to define an explicit m-n relationmodel Post {  id             Int              @id @default(autoincrement())  title          String  categories     Category[] // This should refer to PostCategories}model PostCategories {  post       Post     @relation(fields: [postId], references: [id])  postId     Int  category   Category @relation(fields: [categoryId], references: [id])  categoryId Int  @@id([postId, categoryId])}model Category {  id             Int              @id @default(autoincrement())  name           String  posts          Post[] // This should refer to PostCategories}\n```\n\nTo fix this the `Post` model needs to have a many relation field defined with the relation table `PostCategories`. The same applies to the `Category` model.\n\nThis is because the relation model forms a 1-to-many relationship with the other two models its joining.\n\n```\nmodel Post {  id             Int              @id @default(autoincrement())  title          String  categories     Category[]  postCategories PostCategories[]}model PostCategories {  post       Post     @relation(fields: [postId], references: [id])  postId     Int  category   Category @relation(fields: [categoryId], references: [id])  categoryId Int  @@id([postId, categoryId])}model Category {  id             Int              @id @default(autoincrement())  name           String  posts          Post[]  postCategories PostCategories[]}\n```\n\n## Using the `@relation` attribute with a many-to-many relationship[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/troubleshooting-relations#using-the-relation-attribute-with-a-many-to-many-relationship \"Direct link to using-the-relation-attribute-with-a-many-to-many-relationship\")\n\nIt might seem logical to add a `@relation(\"Post\")` annotation to a relation field on your model when composing an implicit many-to-many relationship.\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  title      String  categories Category[] @relation(\"Category\")  Category   Category?  @relation(\"Post\", fields: [categoryId], references: [id])  categoryId Int?}model Category {  id     Int    @id @default(autoincrement())  name   String  posts  Post[] @relation(\"Post\")  Post   Post?  @relation(\"Category\", fields: [postId], references: [id])  postId Int?}\n```\n\nThis however tells Prisma ORM to expect **two** separate one-to-many relationships. See [disambiguating relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#disambiguating-relations) for more information on using the `@relation` attribute.\n\nThe following example is the correct way to define an implicit many-to-many relationship.\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  title      String  categories Category[] @relation(\"Category\")  categories Category[]}model Category {  id    Int    @id @default(autoincrement())  name  String  posts Post[] @relation(\"Post\")  posts Post[]}\n```\n\nThe `@relation` annotation can also be used to [name the underlying relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#configuring-the-name-of-the-relation-table-in-implicit-many-to-many-relations) created on a implicit many-to-many relationship.\n\n```\nmodel Post {  id         Int        @id @default(autoincrement())  title      String  categories Category[] @relation(\"CategoryPostRelation\")}model Category {  id    Int    @id @default(autoincrement())  name  String  posts Post[] @relation(\"CategoryPostRelation\")}\n```\n\n## Using m-n relations in databases with enforced primary keys[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/troubleshooting-relations#using-m-n-relations-in-databases-with-enforced-primary-keys \"Direct link to Using m-n relations in databases with enforced primary keys\")\n\n### Problem[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/troubleshooting-relations#problem-1 \"Direct link to Problem\")\n\nSome cloud providers enforce the existence of primary keys in all tables. However, any relation tables (JOIN tables) created by Prisma ORM (expressed via `@relation`) for many-to-many relations using implicit syntax do not have primary keys.\n\n### Solution[​](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/troubleshooting-relations#solution-1 \"Direct link to Solution\")\n\nYou need to use [explicit relation syntax](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations), manually create the join model, and verify that this join model has a primary key.",
    "title": "Troubleshooting relations | Prisma Documentation",
    "description": "Modelling your schema can sometimes offer up some unexpected results. This section aims to cover the most prominent of those.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/introduction/why-prisma",
    "markdown": "# Why Prisma ORM? Comparison with SQL query builders & ORMs\n\nOn this page, you'll learn about the motivation for Prisma ORM and how it compares to other database tools like traditional ORMs and SQL query builders.\n\nWorking with relational databases is a major bottleneck in application development. Debugging SQL queries or complex ORM objects often consume hours of development time.\n\nPrisma ORM makes it easy for developers to reason about their database queries by providing a clean and type-safe API for submitting database queries which returns _plain old JavaScript objects_.\n\n## TLDR[​](https://www.prisma.io/docs/orm/overview/introduction/why-prisma#tldr \"Direct link to TLDR\")\n\nPrisma ORM's main goal is to make application developers more productive when working with databases. Here are a few examples of how Prisma ORM achieves this:\n\n*   **Thinking in objects** instead of mapping relational data\n*   **Queries not classes** to avoid complex model objects\n*   **Single source of truth** for database and application models\n*   **Healthy constraints** that prevent common pitfalls and anti-patterns\n*   **An abstraction that makes the right thing easy** (\"pit of success\")\n*   **Type-safe database queries** that can be validated at compile time\n*   **Less boilerplate** so developers can focus on the important parts of their app\n*   **Auto-completion in code editors** instead of needing to look up documentation\n\nThe remaining parts of this page discuss how Prisma ORM compares to existing database tools.\n\nThe main problem with the database tools that currently exist in the Node.js and TypeScript ecosystem is that they require a major tradeoff between _productivity_ and _control_.\n\n![Productivity vs Control in ORMs, SQL query builders, and SQL](https://www.prisma.io/docs/assets/images/node-js-db-tools-tradeoffs-c36f06c912ebbf87b8a8d88125b4366c.png)\n\n### Raw SQL: Full control, low productivity[​](https://www.prisma.io/docs/orm/overview/introduction/why-prisma#raw-sql-full-control-low-productivity \"Direct link to Raw SQL: Full control, low productivity\")\n\nWith raw SQL (e.g. using the native [`pg`](https://node-postgres.com/) or [`mysql`](https://github.com/mysqljs/mysql#readme) Node.js database drivers) you have full control over your database operations. However, productivity suffers as sending plain SQL strings to the database is cumbersome and comes with a lot of overhead (manual connection handling, repetitive boilerplate, ...).\n\nAnother major issue with this approach is that you don't get any type safety for your query results. Of course, you can type the results manually but this is a huge amount of work and requires major refactorings each time you change your database schema or queries to keep the typings in sync.\n\nFurthermore, submitting SQL queries as plain strings means you don't get any autocompletion in your editors.\n\n### SQL query builders: High control, medium productivity[​](https://www.prisma.io/docs/orm/overview/introduction/why-prisma#sql-query-builders-high-control-medium-productivity \"Direct link to SQL query builders: High control, medium productivity\")\n\nA common solution that retains a high level of control and provides better productivity is to use a SQL query builder (e.g. [knex.js](https://knexjs.org/)). These sort of tools provide a programmatic abstraction to construct SQL queries.\n\nThe biggest drawback with SQL query builders is that application developers still need to think about their data in terms of SQL. This incurs a cognitive and practical cost of translating relational data into objects. Another issue is that it's too easy to shoot yourself in the foot if you don't know exactly what you're doing in your SQL queries.\n\n### Traditional ORMs: Less control, better productivity[​](https://www.prisma.io/docs/orm/overview/introduction/why-prisma#traditional-orms-less-control-better-productivity \"Direct link to Traditional ORMs: Less control, better productivity\")\n\nTraditional ORMs abstract away from SQL by letting you _define your application models as classes_, these classes are mapped to tables in the database.\n\n> \"Object relational mappers\" (ORMs) exist to bridge the gap between the programmers' friend (the object), and the database's primitive (the relation). The reasons for these differing models are as much cultural as functional: programmers like objects because they encapsulate the state of a single thing in a running program. Databases like relations because they better suit whole-dataset constraints and efficient access patterns for the entire dataset.\n> \n> [The Troublesome Active Record Pattern, Cal Paterson (2020)](https://calpaterson.com/activerecord.html)\n\nYou can then read and write data by calling methods on the instances of your model classes.\n\nThis is way more convenient and comes closer to the mental model developers have when thinking about their data. So, what's the catch?\n\n> ORM represents a quagmire which starts well, gets more complicated as time passes, and before long entraps its users in a commitment that has no clear demarcation point, no clear win conditions, and no clear exit strategy.\n> \n> [The Vietnam of Computer Science, Ted Neward (2006)](https://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/)\n\nAs an application developer, the mental model you have for your data is that of an _object_. The mental model for data in SQL on the other hand are _tables_.\n\nThe divide between these two different representations of data is often referred to as the [object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch). The object-relational impedance mismatch also is a major reason why many developers don't like working with traditional ORMs.\n\nAs an example, consider how data is organized and relationships are handled with each approach:\n\n*   **Relational databases**: Data is typically normalized (flat) and uses foreign keys to link across entities. The entities then need to be JOINed to manifest the actual relationships.\n*   **Object-oriented**: Objects can be deeply nested structures where you can traverse relationships simply by using dot notation.\n\nThis alludes to one of the major pitfalls with traditional ORMs: While they make it _seem_ that you can simply traverse relationships using familiar dot notation, under the hood the ORM generates SQL JOINs which are expensive and have the potential to drastically slow down your application (one symptom of this is the [n+1 problem](https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping)).\n\nTo conclude: The appeal of traditional ORMs is the premise of abstracting away the relational model and thinking about your data purely in terms of objects. While the premise is great, it's based on the wrong assumption that relational data can easily be mapped to objects which leads to lots of complications and pitfalls.\n\n## Application developers should care about data – not SQL[​](https://www.prisma.io/docs/orm/overview/introduction/why-prisma#application-developers-should-care-about-data--not-sql \"Direct link to Application developers should care about data – not SQL\")\n\nDespite being developed in the 1970s(!), SQL has stood the test of time in an impressive manner. However, with the advancement and modernization of developers tools, it's worth asking if SQL really is the best abstraction for application developers to work with?\n\nAfter all, **developers should only care about the _data_ they need to implement a feature** and not spend time figuring out complicated SQL queries or massaging query results to fit their needs.\n\nThere's another argument to be made against SQL in application development. The power of SQL can be a blessing if you know exactly what you're doing, but its complexity can be a curse. There are a lot of [anti-patterns](https://www.slideshare.net/billkarwin/sql-antipatterns-strike-back) and pitfalls that even experienced SQL users struggle to anticipate, often at the cost of performance and hours of debugging time.\n\nDevelopers should be able to ask for the data they need instead of having to worry about \"doing the right thing\" in their SQL queries. They should be using an abstraction that makes the right decisions for them. This can mean that the abstraction imposes certain \"healthy\" constraints that prevent developers from making mistakes.\n\n## Prisma ORM makes developers productive[​](https://www.prisma.io/docs/orm/overview/introduction/why-prisma#prisma-orm-makes-developers-productive \"Direct link to Prisma ORM makes developers productive\")\n\nPrisma ORM's main goal is to make application developers more productive when working with databases. Considering the tradeoff between productivity and control again, this is how Prisma ORM fits in:\n\n![Prisma ORM makes developers productive](https://www.prisma.io/docs/assets/images/prisma-makes-devs-productive-b18ac4ab360d4e3d2b48cfe1b4218b99.png)",
    "title": "Why Prisma ORM? Comparison with SQL query builders & ORMs | Prisma Documentation",
    "description": "Learn about the motivation for Prisma ORM and how it compares to other Node.js and TypeScript database tools like ORMs and SQL query builders.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma",
    "markdown": "# Should you use Prisma ORM as a Node.js/TypeScript ORM?\n\nPrisma ORM is a new kind of ORM that - like any other tool - comes with its own tradeoffs. This page explains when Prisma ORM would be a good fit, and provides alternatives for other scenarios.\n\n## Prisma ORM likely _is_ a good fit for you if ...[​](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma#prisma-orm-likely-is-a-good-fit-for-you-if- \"Direct link to prisma-orm-likely-is-a-good-fit-for-you-if-\")\n\n### ... you are building a server-side application that talks to a database[​](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma#-you-are-building-a-server-side-application-that-talks-to-a-database \"Direct link to ... you are building a server-side application that talks to a database\")\n\nThis is the main use case for Prisma ORM. Server-side applications typically are API servers that expose data operations via technologies like REST, GraphQL or gRPC. They are commonly built as microservices or monolithic apps and deployed via long-running servers or serverless functions. Prisma ORM is a great fit for all of these application and deployment models.\n\nRefer to the full list of databases (relational, NoSQL, and NewSQL) that Prisma ORM [supports](https://www.prisma.io/docs/orm/reference/supported-databases).\n\n### ... you care about productivity and developer experience[​](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma#-you-care-about-productivity-and-developer-experience \"Direct link to ... you care about productivity and developer experience\")\n\nProductivity and developer experience are core to how we're building our tools. We're looking to build developer-friendly abstractions for tasks that are complex, error-prone and time-consuming when performed manually.\n\nNo matter if you're a SQL newcomer or veteran, Prisma ORM will give you a significant productivity boost for the most common database workflows.\n\nHere are a couple of the guiding principles and general practices we apply when designing and building our tools:\n\n*   [make the right thing easy](https://jason.energy/right-thing-easy-thing/)\n*   [pit of success](https://blog.codinghorror.com/falling-into-the-pit-of-success/)\n*   offer intelligent autocompletion where possible\n*   build powerful editor extensions (e.g. for [VS Code](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma))\n*   go the extra mile to achieve full type-safety\n\n### ... you are working in a team[​](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma#-you-are-working-in-a-team \"Direct link to ... you are working in a team\")\n\nPrisma ORM shines especially when used in collaborative environments.\n\nThe declarative [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) provides an overview of the current state of the database that's easy to understand for everyone. This is a major improvement to traditional workflows where developers have to dig through migration files to understand the current table structure.\n\n[Prisma Client](https://www.prisma.io/docs/orm/prisma-client)'s minimal API surface enables developers to pick it up quickly without much learning overhead, so onboarding new developers to a team becomes a lot smoother.\n\nThe [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) workflows are designed in a way to cover database schema changes in collaborative environments. From the initial schema creation up to the point of deploying schema changes to production and resolving conflicts that were introduced by parallel modifications, Prisma Migrate has you covered.\n\n### ... you want a tool that holistically covers your database workflows[​](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma#-you-want-a-tool-that-holistically-covers-your-database-workflows \"Direct link to ... you want a tool that holistically covers your database workflows\")\n\nPrisma ORM is a lot more than \"just another ORM\". We are building a database toolkit that covers the daily workflows of application developers that interact with databases. A few examples are:\n\n*   querying (with [Prisma Client](https://www.prisma.io/docs/orm/prisma-client))\n*   data modeling (in the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema))\n*   migrations (with [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate))\n*   prototyping (via [`prisma db push`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-push))\n*   seeding (via [`prisma db seed`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-seed))\n*   visual viewing and editing (with [Prisma Studio](https://www.prisma.io/studio))\n\n### ... you value type-safety[​](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma#-you-value-type-safety \"Direct link to ... you value type-safety\")\n\nPrisma ORM is the only _fully_ type-safe ORM in the TypeScript ecosystem. The generated Prisma Client ensures typed query results even for partial queries and relations. You can learn more about this in the [type-safety comparison with TypeORM](https://www.prisma.io/docs/orm/more/comparisons/prisma-and-typeorm#type-safety).\n\n### ... you want an ORM with a transparent development process, proper maintenance & support[​](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma#-you-want-an-orm-with-a-transparent-development-process-proper-maintenance--support \"Direct link to ... you want an ORM with a transparent development process, proper maintenance & support\")\n\nDevelopment of Prisma ORM's open source tools is happening in the open. Most of it happens directly on GitHub in the main [`prisma/prisma`](https://github.com/prisma/prisma) repo:\n\n*   issues and PRs in our repos are triaged and prioritized (usually within 1-2 days)\n*   there is a public [roadmap](https://pris.ly/roadmap) that is kept up to date with our plans\n*   new [releases](https://github.com/prisma/prisma/releases) with new features and improvements are issued every three weeks\n*   we have a dedicated support team that responds to questions in [GitHub Discussions](https://github.com/prisma/prisma/discussions)\n\nPrisma has a lively [community](https://www.prisma.io/community) that you can find on [Discord](https://pris.ly/discord). We also regularly host Meetups, conferences and other developer-focused events. Join us!\n\n## Prisma ORM likely is _not_ a good fit for you if ...[​](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma#prisma-orm-likely-is-not-a-good-fit-for-you-if- \"Direct link to prisma-orm-likely-is-not-a-good-fit-for-you-if-\")\n\n### ... you need _full_ control over all database queries[​](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma#-you-need-full-control-over-all-database-queries \"Direct link to -you-need-full-control-over-all-database-queries\")\n\nPrisma ORM is an abstraction. As such, an inherent tradeoff of Prisma ORM is a reduced amount of control in exchange for higher productivity. This means, the [Prisma Client API](https://www.prisma.io/docs/orm/prisma-client) might have less capabilities in some scenarios than you get with plain SQL.\n\nIf your application has requirements for database queries that Prisma ORM does not provide and the workarounds are too costly, you might be better off with a tool that allows you to exercise full control over your database operations using plain SQL.\n\n> **Note**: If you can work around a certain limitation but still would like to see an improvement in the way how Prisma ORM handles the situation, we encourage you to create a [feature request](https://github.com/prisma/prisma/issues/new?assignees=&labels=&template=feature_request.md&title=) on GitHub so that our Product and Engineering teams can look into it.\n\n_Alternatives_: SQL drivers (e.g. [`node-postgres`](https://node-postgres.com/), [`mysql`](https://github.com/mysqljs/mysql#readme), [`sqlite3`](https://github.com/mapbox/node-sqlite3#README), ...)\n\n### ... you do not want to write any code for your backend[​](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma#-you-do-not-want-to-write-any-code-for-your-backend \"Direct link to ... you do not want to write any code for your backend\")\n\nIf you don't want to write any code for your backend and just be able to generate your API server and the database out-of-the-box, you might rather choose a Backend-as-a-Service (BaaS) for your project.\n\nWith a BaaS, you can typically configure your data model via a high-level API (e.g. [GraphQL SDL](https://www.prisma.io/blog/graphql-sdl-schema-definition-language-6755bcb9ce51)) or a visual editor. Based on this data model, the BaaS generates a CRUD API and provisions a database for you. With this setup, you typically don't have control over the infrastructure the API server and database are running on.\n\nWith Prisma ORM, you are building the backend yourself using Node.js or TypeScript. This means you'll have to do a lot more coding work compared to using a BaaS. The benefit of this approach is that you have full flexibility for building, deploying, scaling and maintaining your backend and are not dependent on 3rd party software for a crucial part of your stack.\n\n_Alternatives_: [AWS AppSync](https://aws.amazon.com/appsync/), [8base](https://www.8base.com/), [Nhost](https://nhost.io/), [Supabase](https://supabase.com/), [Firebase](https://firebase.google.com/), [Amplication](https://amplication.com/)\n\n### ... you want a CRUD GraphQL API without writing any code[​](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma#-you-want-a-crud-graphql-api-without-writing-any-code \"Direct link to ... you want a CRUD GraphQL API without writing any code\")\n\nWhile tools like the [`nexus-plugin-prisma`](https://nexusjs.org/docs/plugins/prisma/overview) and [`typegraphql-prisma`](https://github.com/MichalLytek/typegraphql-prisma#readme) allow you to quickly generate CRUD operations for your Prisma ORM models in a GraphQL API, these approaches still require you to set up your GraphQL server manually and do some work to expose GraphQL queries and mutations for the models defined in your Prisma schema.\n\nIf you want to get a GraphQL endpoint for your database out-of-the box, other tools might be better suited for your use case.\n\n_Alternatives_: [Hasura](https://hasura.io/), [Postgraphile](https://www.graphile.org/postgraphile/)\n\n### ... you want to use raw, type-safe SQL for querying your database[​](https://www.prisma.io/docs/orm/overview/introduction/should-you-use-prisma#-you-want-to-use-raw-type-safe-sql-for-querying-your-database \"Direct link to ... you want to use raw, type-safe SQL for querying your database\")\n\nWhile Prisma ORM does allow you to [send plain SQL queries](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries) to your database, it might not be the best fit if you prefer to work with a SQL-based abstraction that you want to be type-safe. Prisma ORM's main benefit is to provide an abstraction layer that makes you more productive compared to writing SQL.\n\nIf you're a solo developer that is very comfortable with SQL, and you just want to be sure that your database layer is type-safe, a lower-level TypeScript database library might be better for you.\n\n_Alternatives_: [Slonik](https://github.com/gajus/slonik), [pgtyped](https://github.com/adelsz/pgtyped), [Zapatos](https://jawj.github.io/zapatos/), [postgres-schema-builder](https://github.com/yss14/postgres-schema-builder)",
    "title": "Should you use Prisma ORM as a Node.js/TypeScript ORM? | Prisma Documentation",
    "description": "Prisma ORM is a new kind of ORM. This page explains when Prisma ORM would be a good fit, and provides alternatives for other scenarios.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions",
    "markdown": "# Referential actions upgrade path | Prisma Documentation\n\nPrisma ORM version 2.x prevents deletion of connected records in some Prisma Client functions, and does not let you configure referential actions in your Prisma Schema to change that behavior.\n\nPrisma ORM version 3.x and later lets you control what should happen when deleting or updating records by explicitly setting referential actions on your models' relations. After the upgrade, Prisma Client will not enforce any referential actions anymore, and any action written to the database foreign keys will define the behavior when deleting or updating records.\n\nPrisma Migrate 3.x will use the actions previously done by Prisma Client as the new default when writing the foreign key constraints to the database.\n\n## Prisma ORM 2.x behavior[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions#prisma-orm-2x-behavior \"Direct link to Prisma ORM 2.x behavior\")\n\nWhen invoking the [`delete()`](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete-a-single-record) or [`deleteAll()`](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete-all-records) methods using Prisma Client on required relations, a runtime check is performed and the deletion of records prevented if they are referencing related objects. **This prevents cascade behavior, no matter how the foreign key is defined**.\n\nThe behavior in Prisma ORM 2, without upgrading, does not allow setting referential actions at all. [See Prisma ORM 2.x default referential actions](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions#prisma-orm-2x-default-referential-actions)\n\nIf you need to actually use the cascade behavior configured in the database, you _can_ use [`raw`](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries) SQL queries to [delete multiple referenced records](https://www.prisma.io/docs/orm/prisma-client/queries/crud#deleting-all-data-with-raw-sql--truncate). This is because Prisma Client will **not** perform runtime checks on raw queries.\n\n### Prisma ORM 2.x default referential actions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions#prisma-orm-2x-default-referential-actions \"Direct link to Prisma ORM 2.x default referential actions\")\n\nBelow are the default referential actions written to the database foreign keys when using Prisma Migrate versions 2.x:\n\n| Clause | Optional relations | Mandatory relations |\n| --- | --- | --- |\n| `onDelete` | `SetNull` | `Cascade` |\n| `onUpdate` | `Cascade` | `Cascade` |\n\nOn top of the database referential actions, the following actions are enforced in Prisma Client versions 2.x:\n\n| Clause | Optional relations | Mandatory relations |\n| --- | --- | --- |\n| `onDelete` | `SetNull` | `Restrict` |\n| `onUpdate` | `Cascade` | `Cascade` |\n\n## Upgrade paths[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions#upgrade-paths \"Direct link to Upgrade paths\")\n\nThere are a couple of paths you can take when upgrading which will give different results depending on the desired outcome.\n\nIf you currently use the migration workflow, you can run `prisma db pull` to check how the defaults are reflected in your schema. You can then manually update your database if you need to.\n\nYou can also decide to skip checking the defaults and run a migration to update your database with the new default values.\n\n### Using Introspection[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions#using-introspection \"Direct link to Using Introspection\")\n\nIf you [Introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) your database, the referential actions configured at the database level will be reflected in your Prisma Schema. If you have been using Prisma Migrate or `prisma db push` to manage the database schema, these are likely to be the [<=2.25.0 default values](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions#prisma-orm-2x-default-referential-actions).\n\nWhen you run an Introspection, Prisma ORM compares all the foreign keys in the database with the schema, if the SQL statements `ON DELETE` and `ON UPDATE` do **not** match the default values, they will be explicitly set in the schema file.\n\nAfter introspecting, you can review the non-default clauses in your schema. The most important clause to review is `onDelete`, which defaults to `Cascade` in version 2.25.0 and earlier.\n\ndanger\n\nIf you are using either the [`delete()`](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete-a-single-record) or [`deleteAll()`](https://www.prisma.io/docs/orm/prisma-client/queries/crud#delete-all-records) methods, **cascading deletes will now be performed, as the safety net in Prisma Client that previously prevented cascading deletes at runtime is removed**. Be sure to check your code and make any adjustments accordingly.\n\nMake sure you are happy with every case of `onDelete: Cascade` in your schema. If not, either:\n\n*   Modify your Prisma schema and `db push` or `dev migrate` to change the database _or_\n*   Manually update the underlying database if you only use `prisma db pull` in your workflow\n\nThe following example would result in a cascading delete, meaning that if the `User` is deleted then all of their `Post`'s will be deleted too.\n\n#### A blog schema example[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions#a-blog-schema-example \"Direct link to A blog schema example\")\n\n```\nmodel Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)  authorId Int}model User {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\n### Using Migration[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions#using-migration \"Direct link to Using Migration\")\n\nWhen running a [Migration](https://www.prisma.io/docs/orm/prisma-migrate) (or the [`prisma db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) command) the [new defaults](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#referential-action-defaults) will be applied to your database.\n\ninfo\n\nUnlike when you run `prisma db pull` for the first time, the new referential actions clause and property will **not** automatically be added to your Prisma schema by the Prisma VSCode extension. You will have to manually add them if you wish to use anything other than the new defaults.\n\nExplicitly defining referential actions in your Prisma schema is optional. If you do not explicitly define a referential action for a relation, Prisma ORM uses the [new defaults](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#referential-action-defaults).\n\nNote that referential actions can be added on a case by case basis. This means that you can add them to one single relation and leave the rest set to the defaults by not manually specifying anything.\n\n### Checking for errors[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions#checking-for-errors \"Direct link to Checking for errors\")\n\n**Before** upgrading to version 3.0.1 (or versions 2.26.0 and above with the `referentialActions` feature flag enabled), Prisma ORM prevented the deletion of records while using `delete()` or `deleteMany()` to preserve referential integrity. A custom runtime error would be thrown by Prisma Client with the error code `P2014`.\n\n**After** upgrading, Prisma ORM no longer performs runtime checks. You can instead specify a custom referential action to preserve the referential integrity between relations.\n\nWhen you use [`NoAction`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#noaction) or [`Restrict`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#restrict) to prevent the deletion of records, the error messages will be different in versions 3.0.1 and above (or 2.26.0 with the `referentialActions` feature flag enabled) compared to versions prior to that. This is because they are now triggered by the database and **not** Prisma Client. The new error code that can be expected is `P2003`, so you should check your code to make adjustments accordingly.\n\n#### Example of catching errors[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions#example-of-catching-errors \"Direct link to Example of catching errors\")\n\nThe following example uses the below blog schema with a 1-m relationship between `Post` and `User` and sets a [`Restrict`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions#restrict) referential actions on the `author` field.\n\nThis means that if a user has a post, that user (and their posts) **cannot** be deleted.\n\nschema.prisma\n\n```\nmodel Post {  id       Int    @id @default(autoincrement())  title    String  author   User   @relation(fields: [authorId], references: [id], onDelete: Restrict)  authorId String}model User {  id    Int    @id @default(autoincrement())  posts Post[]}\n```\n\nPrior to upgrading, the error code you would receive when trying to delete a user which has posts would be `P2014` and it's message:\n\n> \"The change you are trying to make would violate the required relation '{relation\\_name}' between the {model\\_a\\_name} and {model\\_b\\_name} models.\"\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  try {    await prisma.user.delete({      where: {        id: 'some-long-id',      },    })  } catch (error) {    if (error instanceof Prisma.PrismaClientKnownRequestError) {      if (error.code === 'P2014') {        console.log(error.message)      }    }  }}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nTo make sure you are checking for the correct errors in your code, modify your check to look for `P2003`, which will deliver the message:\n\n> \"Foreign key constraint failed on the field: {field\\_name}\"\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  try {    await prisma.user.delete({      where: {        id: 'some-long-id'      }    })  } catch (error) {    if (error instanceof Prisma.PrismaClientKnownRequestError) {      if (error.code === 'P2014') {      if (error.code === 'P2003') {        console.log(error.message)      }    }  }}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```",
    "title": "Referential actions upgrade path | Prisma Documentation",
    "description": "Guides on how to deal with referential actions using Prisma Introspect or Prisma Migrate when upgrading to Prisma 3",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-schema/overview/location",
    "markdown": "# Prisma Schema Location and Configuration\n\nThe default name for the Prisma Schema is a single file `schema.prisma` in your `prisma` folder. When your schema is named like this, the Prisma CLI will detect it automatically.\n\n> If you are using the [`prismaSchemaFolder` preview feature](https://www.prisma.io/docs/orm/prisma-schema/overview/location#multi-file-prisma-schema) any files in the `prisma/schema` directory are detected automatically.\n\n## Prisma Schema location[​](https://www.prisma.io/docs/orm/prisma-schema/overview/location#prisma-schema-location \"Direct link to Prisma Schema location\")\n\nThe Prisma CLI looks for the Prisma Schema in the following locations, in the following order:\n\n1.  The location specified by the [`--schema` flag](https://www.prisma.io/docs/orm/reference/prisma-cli-reference), which is available when you `introspect`, `generate`, `migrate`, and `studio`:\n    \n    ```\n    prisma generate --schema=./alternative/schema.prisma\n    ```\n    \n2.  The location specified in the `package.json` file (version 2.7.0 and later):\n    \n    ```\n    \"prisma\": {  \"schema\": \"db/schema.prisma\"}\n    ```\n    \n3.  Default locations:\n    \n    *   `./prisma/schema.prisma`\n    *   `./schema.prisma`\n\nThe Prisma CLI outputs the path of the schema that will be used. The following example shows the terminal output for `prisma db pull`:\n\n```\nEnvironment variables loaded from .envPrisma Schema loaded from prisma/schema.prismaIntrospecting based on datasource defined in prisma/schema.prisma …✔ Introspected 4 models and wrote them into prisma/schema.prisma in 239msRun prisma generate to generate Prisma Client.\n```\n\n## Multi-file Prisma Schema[​](https://www.prisma.io/docs/orm/prisma-schema/overview/location#multi-file-prisma-schema \"Direct link to Multi-file Prisma Schema\")\n\ntip\n\nMulti-file Prisma Schema is available via the `prismaSchemaFolder` preview feature in Prisma versions 5.15.0 and later.\n\nTo use multiple Prisma Schema files, add a `schema` folder inside of your current `prisma` directory. With the `prismaSchemaFolder` Preview feature enabled, you can add as many files as you want to the `prisma/schema` directory.\n\n```\nmy-app/├─ ...├─ prisma/│  ├─ schema/│  │  ├─ post.prisma│  │  ├─ schema.prisma│  │  ├─ user.prisma├─ ...\n```\n\n### How to enable multi-file Prisma schema support[​](https://www.prisma.io/docs/orm/prisma-schema/overview/location#how-to-enable-multi-file-prisma-schema-support \"Direct link to How to enable multi-file Prisma schema support\")\n\nSupport for multiple Prisma Schema files is currently in preview. To enable the feature, add the `prismaSchemaFolder` feature flag to the `previewFeatures` field of the `generator` block in your Prisma Schema:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"prismaSchemaFolder\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\ninfo\n\nWhen first updating to Prisma ORM 5.15.0 or later, your IDE may not recognize the new multi-file format immediately. Be sure to restart your IDE to confirm you have the latest version of the Prisma VS Code Extension installed.\n\n### How to use existing Prisma CLI commands with multiple Prisma schema files[​](https://www.prisma.io/docs/orm/prisma-schema/overview/location#how-to-use-existing-prisma-cli-commands-with-multiple-prisma-schema-files \"Direct link to How to use existing Prisma CLI commands with multiple Prisma schema files\")\n\nFor most Prisma CLI commands, no changes will be necessary to work with a multi-file Prisma schema. Only in the specific cases where you need to supply a schema via an option will a command need to be changed. In these cases, simply replace references to a file with a directory. As an example, the following `prisma db push` command:\n\n```\nnpx prisma db push --schema custom/path/to/my/schema.prisma\n```\n\nbecomes the following:\n\n```\nnpx prisma db push --schema custom/path/to/my/schema  # note this is now a directory!\n```\n\n### Tips for multi-file Prisma Schema[​](https://www.prisma.io/docs/orm/prisma-schema/overview/location#tips-for-multi-file-prisma-schema \"Direct link to Tips for multi-file Prisma Schema\")\n\nWe’ve found that a few patterns work well with this feature and will help you get the most out of it:\n\n*   Organize your files by domain: group related models into the same file. For example, keep all user-related models in `user.prisma` while post-related models go in `post.prisma`. Try to avoid having “kitchen sink” schema files.\n    \n*   Use clear naming conventions: schema files should be named clearly and succinctly. Use names like `user.prisma` and `post.prisma` and not `myModels.prisma` or `CommentFeaturesSchema.prisma`.\n    \n*   Have an obvious “main” schema file: while you can now have as many schema files as you want, you’ll still need a place where you define `datasource` and `generator` blocks. We recommend having a single schema file that’s obviously the “main” file so that these blocks are easy to find. `main.prisma`, `schema.prisma`, and `base.prisma` are a few we’ve seen that work well.\n    \n\n### Examples[​](https://www.prisma.io/docs/orm/prisma-schema/overview/location#examples \"Direct link to Examples\")\n\nOur fork of [`dub` by dub.co](https://github.com/prisma/dub) is a great example of a real world project adapted to use a multi-file Prisma Schema.\n\n### Learn more about the `prismaSchemaFolder` preview feature[​](https://www.prisma.io/docs/orm/prisma-schema/overview/location#learn-more-about-the-prismaschemafolder-preview-feature \"Direct link to learn-more-about-the-prismaschemafolder-preview-feature\")\n\nTo give feedback on the `prismaSchemaFolder` Preview feature, please refer to [our dedicated Github discussion](https://github.com/prisma/prisma/discussions/24413).",
    "title": "Prisma Schema Location and Configuration | Prisma Documentation",
    "description": "Documentation regarding proper location of Prisma Schema including default naming and multiple files.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/introduction",
    "markdown": "# Introduction to Prisma Client | Prisma Documentation\n\nPrisma Client is an auto-generated and type-safe query builder that's _tailored_ to your data. The easiest way to get started with Prisma Client is by following the **[Quickstart](https://www.prisma.io/docs/getting-started/quickstart)**.\n\n[\n\nQuickstart (5 min)\n\n](https://www.prisma.io/docs/getting-started/quickstart)\n\nThe setup instructions [below](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/introduction#set-up) provide a high-level overview of the steps needed to set up Prisma Client. If you want to get started using Prisma Client with your own database, follow one of these guides:\n\n[\n\nSet up a new project from scratch\n\n](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-postgresql)[\n\nAdd Prisma to an existing project\n\n](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-typescript-postgresql)\n\n## Set up[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/introduction#set-up \"Direct link to Set up\")\n\n### 1\\. Prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/introduction#1-prerequisites \"Direct link to 1. Prerequisites\")\n\nIn order to set up Prisma Client, you need a [Prisma schema file](https://www.prisma.io/docs/orm/prisma-schema) with your database connection, the Prisma Client generator, and at least one model:\n\nschema.prisma\n\n```\ndatasource db {  url      = env(\"DATABASE_URL\")  provider = \"postgresql\"}generator client {  provider = \"prisma-client-js\"}model User {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  email     String   @unique  name      String?}\n```\n\nAlso make sure to [install the Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli#installation):\n\n```\nnpm install prisma --save-devnpx prisma\n```\n\n### 2\\. Installation[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/introduction#2-installation \"Direct link to 2. Installation\")\n\nInstall Prisma Client in your project with the following command:\n\n```\nnpm install @prisma/client\n```\n\nThis command also runs the `prisma generate` command, which generates Prisma Client into the [`node_modules/.prisma/client`](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) directory.\n\n### 3\\. Importing Prisma Client[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/introduction#3-importing-prisma-client \"Direct link to 3. Importing Prisma Client\")\n\nThere are multiple ways to import Prisma Client in your project depending on your use case:\n\n*   TypeScript\n*   JavaScript\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()// use `prisma` in your application to read and write data in your DB\n```\n\nFor edge environments, you can import Prisma Client as follows:\n\n*   TypeScript\n*   JavaScript\n\n```\nimport { PrismaClient } from '@prisma/client/edge'const prisma = new PrismaClient()// use `prisma` in your application to read and write data in your DB\n```\n\nFor Deno, you can import Prisma Client as follows:\n\nlib/prisma.ts\n\n```\nimport { PrismaClient } from './generated/client/deno/edge.ts'const prisma = new PrismaClient()// use `prisma` in your application to read and write data in your DB\n```\n\nThe import path will depend on the custom `output` specified in Prisma Client's [`generator`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fields-1) block in your Prisma schema.\n\n### 4\\. Use Prisma Client to send queries to your database[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/introduction#4-use-prisma-client-to-send-queries-to-your-database \"Direct link to 4. Use Prisma Client to send queries to your database\")\n\nOnce you have instantiated `PrismaClient`, you can start sending queries in your code:\n\n```\n// run inside `async` functionconst newUser = await prisma.user.create({  data: {    name: 'Alice',    email: 'alice@prisma.io',  },})const users = await prisma.user.findMany()\n```\n\ninfo\n\nAll Prisma Client methods return an instance of [`PrismaPromise`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#prismapromise-behavior) which only executes when you call `await` or `.then()` or `.catch()`.\n\n### 5\\. Evolving your application[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/introduction#5-evolving-your-application \"Direct link to 5. Evolving your application\")\n\nWhenever you make changes to your database that are reflected in the Prisma schema, you need to manually re-generate Prisma Client to update the generated code in the `node_modules/.prisma/client` directory:",
    "title": "Introduction to Prisma Client | Prisma Documentation",
    "description": "Learn how to set up Prisma Client.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/error-formatting",
    "markdown": "# Configuring error formatting (Concepts) | Prisma Documentation\n\nBy default, Prisma Client uses [ANSI escape characters](https://en.wikipedia.org/wiki/ANSI_escape_code) to pretty print the error stack and give recommendations on how to fix a problem. While this is very useful when using Prisma Client from the terminal, in contexts like a GraphQL API, you only want the minimal error without any additional formatting.\n\nThis page explains how error formatting can be configured with Prisma Client.\n\nIn order to configure these different error formatting levels, there are two options:\n\nAlternatively, use the `PrismaClient` [`errorFormat`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#errorformat) parameter to set the error format:\n\n```\nconst prisma = new PrismaClient({  errorFormat: 'pretty',})\n```",
    "title": "Configuring error formatting (Concepts) | Prisma Documentation",
    "description": "This page explains how to configure the formatting of errors when using Prisma Client.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/instantiate-prisma-client",
    "markdown": "# Instantiating Prisma Client | Prisma Documentation\n\nToo many connections may start to **slow down your database** and eventually lead to errors such as:\n\n```\nError in connector: Error querying the database: db error: FATAL: sorry, too many clients already    at PrismaClientFetcher.request\n```",
    "title": "Instantiating Prisma Client | Prisma Documentation",
    "description": "How to create and use an instance of PrismaClient in your app.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/read-replicas",
    "markdown": "# Read replicas | Prisma Documentation\n\nRead replicas enable you to distribute workloads across database replicas for high-traffic workloads. The [read replicas extension](https://github.com/prisma/extension-read-replicas), `@prisma/extension-read-replicas`, adds support for read-only database replicas to Prisma Client.\n\nThe read replicas extension supports Prisma ORM versions [5.2.0](https://github.com/prisma/prisma/releases/tag/5.2.0) and higher. If you run into a bug or have feedback, create a GitHub issue [here](https://github.com/prisma/extension-read-replicas/issues/new).\n\n## Setup the read replicas extension[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/read-replicas#setup-the-read-replicas-extension \"Direct link to Setup the read replicas extension\")\n\nInstall the extension:\n\n```\nnpm install @prisma/extension-read-replicas\n```\n\nInitialize the extension by extending your Prisma Client instance and provide the extension a connection string that points to your read replica in the `url` option of the extension.\n\n```\nimport { PrismaClient } from '@prisma/client'import { readReplicas } from '@prisma/extension-read-replicas'const prisma = new PrismaClient().$extends(  readReplicas({    url: process.env.DATABASE_URL_REPLICA,  }))// Query is run against the database replicaawait prisma.post.findMany()// Query is run against the primary databaseawait prisma.post.create({   data: {/** */},})\n```\n\nAll read operations, e.g. `findMany`, will be executed against the database replica with the above setup. All write operations — e.g. `create`, `update` — and `$transaction` queries, will be executed against your primary database.\n\nIf you run into a bug or have feedback, create a GitHub issue [here](https://github.com/prisma/extension-read-replicas/issues/new).\n\n## Configure multiple database replicas[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/read-replicas#configure-multiple-database-replicas \"Direct link to Configure multiple database replicas\")\n\nThe `url` property also accepts an array of values, i.e. an array of all your database replicas you would like to configure:\n\n```\nconst prisma = new PrismaClient().$extends(  readReplicas({    url: [      process.env.DATABASE_URL_REPLICA_1,      process.env.DATABASE_URL_REPLICA_2,    ],  }))\n```\n\nIf you have more than one read replica configured, a database replica will be randomly selected to execute your query.\n\n## Executing read operations against your primary database[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/read-replicas#executing-read-operations-against-your-primary-database \"Direct link to Executing read operations against your primary database\")\n\nYou can use the `$primary()` method to explicitly execute a read operation against your primary database:\n\n```\nconst posts = await prisma.$primary().post.findMany()\n```\n\n## Executing operations against a database replica[​](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/read-replicas#executing-operations-against-a-database-replica \"Direct link to Executing operations against a database replica\")\n\nYou can use the `$replica()` method to explicitly execute your query against a replica instead of your primary database:\n\n```\nconst result = await prisma.$replica().$queryRaw`SELECT ...`\n```",
    "title": "Read replicas | Prisma Documentation",
    "description": "Learn how to set up and use read replicas with Prisma Client",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/database-polyfills",
    "markdown": "# Database polyfills (Concepts) | Prisma Documentation\n\nPrisma Client provides features that are typically either not achievable with particular databases or require extensions. These features are referred to as _polyfills_. For all databases, this includes:\n\n*   Initializing [ID](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-an-id-field) values with `cuid` and `uuid` values\n*   Using [`@updatedAt`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-attributes) to store the time when a record was last updated\n\nFor relational databases, this includes:\n\n*   [Implicit many-to-many relations](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations)\n\nFor MongoDB, this includes:\n\n*   [Relations in general](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations) - foreign key relations between documents are not enforced in MongoDB",
    "title": "Database polyfills (Concepts) | Prisma Documentation",
    "description": "Prisma Client provides features that are not achievable with relational databases. These features are referred to as \"polyfills\" and explained on this page.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/null-and-undefined",
    "markdown": "# Null and undefined (Reference) | Prisma Documentation\n\nPrisma Client differentiates between `null` and `undefined`:\n\n*   `null` is a **value**\n*   `undefined` means **do nothing**\n\nThe data below represents a `User` table. This set of data will be used in all of the examples below:\n\n| id  | name | email |\n| --- | --- | --- |\n| 1   | Nikolas | [nikolas@gmail.com](mailto:nikolas@gmail.com) |\n| 2   | Martin | [martin@gmail.com](mailto:martin@gmail.com) |\n| 3   | _empty_ | [sabin@gmail.com](mailto:sabin@gmail.com) |\n| 4   | Tyler | [tyler@gmail.com](mailto:tyler@gmail.com) |\n\n## `null` and `undefined` in queries that affect _many_ records[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/null-and-undefined#null-and-undefined-in-queries-that-affect-many-records \"Direct link to null-and-undefined-in-queries-that-affect-many-records\")\n\nThis section will cover how `undefined` and `null` values affect the behavior of queries that interact with or create multiple records in a database.\n\n### Null[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/null-and-undefined#null \"Direct link to Null\")\n\nConsider the following Prisma Client query which searches for all users whose `name` value matches the provided `null` value:\n\n```\nconst users = await prisma.user.findMany({  where: {    name: null,  },})\n```\n\nBecause `null` was provided as the filter for the `name` column, Prisma Client will generate a query that searches for all records in the `User` table whose `name` column is _empty_.\n\n### Undefined[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/null-and-undefined#undefined \"Direct link to Undefined\")\n\nNow consider the scenario where you run the same query with `undefined` as the filter value on the `name` column:\n\n```\nconst users = await prisma.user.findMany({  where: {    name: undefined,  },})\n```\n\nUsing `undefined` as a value in a filter essentially tells Prisma Client you have decided _not to define a filter_ for that column.\n\nAn equivalent way to write the above query would be:\n\n```\nconst users = await prisma.user.findMany()\n```\n\nThis query will select every row from the `User` table.\n\ninfo\n\n**Note**: Using `undefined` as the value of any key in a Prisma Client query's parameter object will cause Prisma ORM to act as if that key was not provided at all.\n\nAlthough this section's examples focused on the `findMany` function, the same concepts apply to any function that can affect multiple records, such as `updateMany` and `deleteMany`.\n\n## `null` and `undefined` in queries that affect _one_ record[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/null-and-undefined#null-and-undefined-in-queries-that-affect-one-record \"Direct link to null-and-undefined-in-queries-that-affect-one-record\")\n\nThis section will cover how `undefined` and `null` values affect the behavior of queries that interact with or create a single record in a database.\n\nwarning\n\n**Note**: `null` is not a valid filter value in a `findUnique()` query.\n\nThe query behavior when using `null` and `undefined` in the filter criteria of a query that affects a single record is very similar to the behaviors described in the previous section.\n\n### Null[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/null-and-undefined#null-1 \"Direct link to Null\")\n\nConsider the following query where `null` is used to filter the `name` column:\n\n```\nconst user = await prisma.user.findFirst({  where: {    name: null,  },})\n```\n\nBecause `null` was used as the filter on the `name` column, Prisma Client will generate a query that searches for the first record in the `User` table whose `name` value is _empty_.\n\n### Undefined[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/null-and-undefined#undefined-1 \"Direct link to Undefined\")\n\nIf `undefined` is used as the filter value on the `name` column instead, _the query will act as if no filter criteria was passed to that column at all_.\n\nConsider the query below:\n\n```\nconst user = await prisma.user.findFirst({  where: {    name: undefined,  },})\n```\n\nIn this scenario, the query will return the very first record in the database.\n\nAnother way to represent the above query is:\n\n```\nconst user = await prisma.user.findFirst()\n```\n\nAlthough this section's examples focused on the `findFirst` function, the same concepts apply to any function that affects a single record.\n\n## `null` and `undefined` in a GraphQL resolver[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/null-and-undefined#null-and-undefined-in-a-graphql-resolver \"Direct link to null-and-undefined-in-a-graphql-resolver\")\n\nFor this example, consider a database based on the following Prisma schema:\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?}\n```\n\nIn the following GraphQL mutation that updates a user, both `authorEmail` and `name` accept `null`. From a GraphQL perspective, this means that fields are **optional**:\n\n```\ntype Mutation {  // Update author's email or name, or both - or neither!  updateUser(id: Int!, authorEmail: String, authorName: String): User!}\n```\n\nHowever, if you pass `null` values for `authorEmail` or `authorName` on to Prisma Client, the following will happen:\n\n*   If `args.authorEmail` is `null`, the query will **fail**. `email` does not accept `null`.\n*   If `args.authorName` is `null`, Prisma Client changes the value of `name` to `null`. This is probably not how you want an update to work.\n\n```\nupdateUser: (parent, args, ctx: Context) => {  return ctx.prisma.user.update({    where: { id: Number(args.id) },    data: {      email: args.authorEmail, // email cannot be null      name: args.authorName // name set to null - potentially unwanted behavior    },  })},\n```\n\nInstead, set the value of `email` and `name` to `undefined` if the input value is `null`. Doing this is the same as not updating the field at all:\n\n```\nupdateUser: (parent, args, ctx: Context) => {  return ctx.prisma.user.update({    where: { id: Number(args.id) },    data: {      email: args.authorEmail != null ? args.authorEmail : undefined, // If null, do nothing      name: args.authorName != null ? args.authorName : undefined // If null, do nothing    },  })},\n```\n\n## The effect of `null` and `undefined` on conditionals[​](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/null-and-undefined#the-effect-of-null-and-undefined-on-conditionals \"Direct link to the-effect-of-null-and-undefined-on-conditionals\")\n\nThere are some caveats to filtering with conditionals which might produce unexpected results. When filtering with conditionals you might expect one result but receive another given how Prisma Client treats nullable values.\n\nThe following table provides a high-level overview of how the different operators handle 0, 1 and `n` filters.\n\n| Operator | 0 filters | 1 filter | n filters |\n| --- | --- | --- | --- |\n| `OR` | return empty list | validate single filter | validate all filters |\n| `AND` | return all items | validate single filter | validate all filters |\n| `NOT` | return all items | validate single filter | validate all filters |\n\nThis example shows how an `undefined` parameter impacts the results returned by a query that uses the [`OR`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#or) operator.\n\n```\ninterface FormData {  name: string  email?: string}const formData: FormData = {  name: 'Emelie',}const users = await prisma.user.findMany({  where: {    OR: [      {        email: {          contains: formData.email,        },      },    ],  },})// returns: []\n```\n\nThe query receives filters from a formData object, which includes an optional email property. In this instance, the value of the email property is `undefined`. When this query is run no data is returned.\n\nThis is in contrast to the [`AND`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#and) and [`NOT`](https://www.prisma.io/docs/orm/reference/prisma-client-reference#not-1) operators, which will both return all the users if you pass in an `undefined` value.\n\n> This is because passing an `undefined` value to an `AND` or `NOT` operator is the same as passing nothing at all, meaning the `findMany` query in the example will run without any filters and return all the users.\n\n```\ninterface FormData {  name: string  email?: string}const formData: FormData = {  name: 'Emelie',}const users = await prisma.user.findMany({  where: {    AND: [      {        email: {          contains: formData.email,        },      },    ],  },})// returns: { id: 1, email: 'ems@boop.com', name: 'Emelie' }const users = await prisma.user.findMany({  where: {    NOT: [      {        email: {          contains: formData.email,        },      },    ],  },})// returns: { id: 1, email: 'ems@boop.com', name: 'Emelie' }\n```",
    "title": "Null and undefined (Reference) | Prisma Documentation",
    "description": "How Prisma Client handles null and undefined, including a GraphQL use case.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/model",
    "markdown": "# Prisma Client extensions: model component\n\n## \\`model\\`: Add custom methods to your models\n\ninfo\n\nPrisma Client extensions are Generally Available from versions 4.16.0 and later. They were introduced in Preview in version 4.7.0. Make sure you enable the `clientExtensions` Preview feature flag if you are running on a version earlier than 4.16.0.\n\nYou can use the `model` [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) component type to add custom methods to your models.\n\nPossible uses for the `model` component include the following:\n\n*   New operations to operate alongside existing Prisma Client operations, such as `findMany`\n*   Encapsulated business logic\n*   Repetitive operations\n*   Model-specific utilities\n\n## Add a custom method[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model#add-a-custom-method \"Direct link to Add a custom method\")\n\nUse the `$extends` [client-level method](https://www.prisma.io/docs/orm/reference/prisma-client-reference#client-methods) to create an _extended client_. An extended client is a variant of the standard Prisma Client that is wrapped by one or more extensions. Use the `model` extension component to add methods to models in your schema.\n\n### Add a custom method to a specific model[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model#add-a-custom-method-to-a-specific-model \"Direct link to Add a custom method to a specific model\")\n\nTo extend a specific model in your schema, use the following structure. This example adds a method to the `user` model.\n\n```\nconst prisma = new PrismaClient().$extends({  name?: '<name>',  // (optional) names the extension for error logs  model?: {    user: { ... }   // in this case, we extend the `user` model  },});\n```\n\n#### Example[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model#example \"Direct link to Example\")\n\nThe following example adds a method called `signUp` to the `user` model. This method creates a new user with the specified email address.\n\n```\nconst prisma = new PrismaClient().$extends({  model: {    user: {      async signUp(email: string) {        await prisma.user.create({ data: { email } })      },    },  },})\n```\n\nYou would call `signUp` in your application as follows:\n\n```\nconst user = await prisma.user.signUp('john@prisma.io')\n```\n\nWhen you call a method in an extension, use the constant name from your `$extends` statement, not `prisma`. In the above example, `prisma.user.signUp` works, but `prisma.user.signUp` does not, because the original `prisma` is not modified.\n\n### Add a custom method to all models in your schema[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model#add-a-custom-method-to-all-models-in-your-schema \"Direct link to Add a custom method to all models in your schema\")\n\nTo extend _all_ models in your schema, use the following structure:\n\n```\nconst prisma = new PrismaClient().$extends({  name?: '<name>', // `name` is an optional field that you can use to name the extension for error logs  model?: {    $allModels: { ... }  },})\n```\n\n#### Example[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model#example-1 \"Direct link to Example\")\n\nThe following example adds an `exists` method to all models.\n\n```\nconst prisma = new PrismaClient().$extends({  model: {    $allModels: {      async exists<T>(        this: T,        where: Prisma.Args<T, 'findFirst'>['where']      ): Promise<boolean> {        // Get the current model at runtime        const context = Prisma.getExtensionContext(this)        const result = await (context as any).findFirst({ where })        return result !== null      },    },  },})\n```\n\nYou would call `exists` in your application as follows:\n\n```\n// `exists` method available on all modelsawait prisma.user.exists({ name: 'Alice' })await prisma.post.exists({  OR: [{ title: { contains: 'Prisma' } }, { content: { contains: 'Prisma' } }],})\n```\n\n## Call a custom method from another custom method[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model#call-a-custom-method-from-another-custom-method \"Direct link to Call a custom method from another custom method\")\n\nYou can call a custom method from another custom method, if the two methods are declared on the same model. For example, you can call a custom method on the `user` model from another custom method on the `user` model. It does not matter if the two methods are declared in the same extension or in different extensions.\n\nTo do so, use `Prisma.getExtensionContext(this).methodName`. Note that you cannot use `prisma.user.methodName`. This is because `prisma` is not extended yet, and therefore does not contain the new method.\n\nFor example:\n\n```\nconst prisma = new PrismaClient().$extends({  model: {    user: {      firstMethod() {        ...      },      secondMethod() {          Prisma.getExtensionContext(this).firstMethod()      }    }  }})\n```\n\n## Get the current model name at runtime[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model#get-the-current-model-name-at-runtime \"Direct link to Get the current model name at runtime\")\n\ninfo\n\nThis feature is available from version 4.9.0.\n\nYou can get the name of the current model at runtime with `Prisma.getExtensionContext(this).name`. You might use this to write out the model name to a log, to send the name to another service, or to branch your code based on the model.\n\nFor example:\n\n```\n// `context` refers to the current modelconst context = Prisma.getExtensionContext(this)// `context.name` returns the name of the current modelconsole.log(context.name)// Usageawait(context as any).findFirst({ args })\n```\n\nRefer to [Add a custom method to all models in your schema](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model#example-1) for a concrete example for retrieving the current model name at runtime.\n\n## Advanced type safety: type utilities for defining generic extensions[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model#advanced-type-safety-type-utilities-for-defining-generic-extensions \"Direct link to Advanced type safety: type utilities for defining generic extensions\")\n\nYou can improve the type-safety of `model` components in your shared extensions with [type utilities](https://www.prisma.io/docs/orm/prisma-client/client-extensions/type-utilities).",
    "title": "Prisma Client extensions: model component | Prisma Documentation",
    "description": "Extend the functionality of Prisma Client, model component",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/client",
    "markdown": "# Prisma Client extensions: client component\n\nYou can use the `client` [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) component to add top-level methods to Prisma Client.\n\nUse the `$extends` [client-level method](https://www.prisma.io/docs/orm/reference/prisma-client-reference#client-methods) to create an _extended client_. An extended client is a variant of the standard Prisma Client that is wrapped by one or more extensions. Use the `client` extension component to add top-level methods to Prisma Client.\n\nThe following example uses the `client` component to add two methods to Prisma Client:\n\n```\nconst prisma = new PrismaClient().$extends({  client: {    $log: (s: string) => console.log(s),    async $totalQueries() {      const index_prisma_client_queries_total = 0      // Prisma.getExtensionContext(this) in the following block      // returns the current client instance      const metricsCounters = await (        await Prisma.getExtensionContext(this).$metrics.json()      ).counters      return metricsCounters[index_prisma_client_queries_total].value    },  },})async function main() {  prisma.$log('Hello world')  const totalQueries = await prisma.$totalQueries()  console.log(totalQueries)}\n```",
    "title": "Prisma Client extensions: client component | Prisma Documentation",
    "description": "Extend the functionality of Prisma Client, client component",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/result",
    "markdown": "# Prisma Client extensions: result component\n\n## \\`result\\`: Add custom fields and methods to query results\n\ninfo\n\nPrisma Client extensions are Generally Available from versions 4.16.0 and later. They were introduced in Preview in version 4.7.0. Make sure you enable the `clientExtensions` Preview feature flag if you are running on a version earlier than 4.16.0.\n\nYou can use the `result` [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) component type to add custom fields and methods to query results.\n\nUse the `$extends` [client-level method](https://www.prisma.io/docs/orm/reference/prisma-client-reference#client-methods) to create an _extended client_. An extended client is a variant of the standard Prisma Client that is wrapped by one or more extensions.\n\nTo add a custom [field](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result#add-a-custom-field-to-query-results) or [method](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result#add-a-custom-method-to-the-result-object) to query results, use the following structure. In this example, we add the custom field `myComputedField` to the result of a `user` model query.\n\n```\nconst prisma = new PrismaClient().$extends({  name?: 'name',  result?: {    user: {                   // in this case, we extend the `user` model      myComputedField: {      // the name of the new computed field        needs: { ... },        compute() { ... }      },    },  },});\n```\n\nThe parameters are as follows:\n\n*   `name`: (optional) specifies a name for the extension that appears in error logs.\n*   `result`: defines new fields and methods to the query results.\n*   `needs`: an object which describes the dependencies of the result field.\n*   `compute`: a method that defines how the virtual field is computed when it is accessed.\n\n## Add a custom field to query results[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result#add-a-custom-field-to-query-results \"Direct link to Add a custom field to query results\")\n\nYou can use the `result` extension component to add fields to query results. These fields are computed at runtime and are type-safe.\n\nIn the following example, we add a new virtual field called `fullName` to the `user` model.\n\n```\nconst prisma = new PrismaClient().$extends({  result: {    user: {      fullName: {        // the dependencies        needs: { firstName: true, lastName: true },        compute(user) {          // the computation logic          return `${user.firstName} ${user.lastName}`        },      },    },  },})const user = await prisma.user.findFirst()// return the user's full name, such as \"John Doe\"console.log(user.fullName)\n```\n\nIn above example, the input `user` of `compute` is automatically typed according to the object defined in `needs`. `firstName` and `lastName` are of type `string`, because they are specified in `needs`. If they are not specified in `needs`, then they cannot be accessed.\n\n## Re-use a computed field in another computed field[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result#re-use-a-computed-field-in-another-computed-field \"Direct link to Re-use a computed field in another computed field\")\n\nThe following example computes a user's title and full name in a type-safe way. `titleFullName` is a computed field that reuses the `fullName` computed field.\n\n```\nconst prisma = new PrismaClient()  .$extends({    result: {      user: {        fullName: {          needs: { firstName: true, lastName: true },          compute(user) {            return `${user.firstName} ${user.lastName}`          },        },      },    },  })  .$extends({    result: {      user: {        titleFullName: {          needs: { title: true, fullName: true },          compute(user) {            return `${user.title} (${user.fullName})`          },        },      },    },  })\n```\n\n### Considerations for fields[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result#considerations-for-fields \"Direct link to Considerations for fields\")\n\n*   For performance reasons, Prisma Client computes results on access, not on retrieval.\n    \n*   You can only create computed fields that are based on scalar fields.\n    \n*   You can only use computed fields with `select` and you cannot aggregate them. For example:\n    \n    ```\n    const user = await prisma.user.findFirst({  select: { email: true },})console.log(user.fullName) // undefined\n    ```\n    \n\n## Add a custom method to the result object[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result#add-a-custom-method-to-the-result-object \"Direct link to Add a custom method to the result object\")\n\nYou can use the `result` component to add methods to query results. The following example adds a new method, `save` to the result object.\n\n```\nconst prisma = new PrismaClient().$extends({  result: {    user: {      save: {        needs: { id: true },        compute(user) {          return () =>            prisma.user.update({ where: { id: user.id }, data: user })        },      },    },  },})const user = await prisma.user.findUniqueOrThrow({ where: { id: someId } })user.email = 'mynewmail@mailservice.com'await user.save()\n```\n\n## Using `omit` query option with `result` extension component[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result#using-omit-query-option-with-result-extension-component \"Direct link to using-omit-query-option-with-result-extension-component\")\n\nYou can use the [`omit` (Preview) option](https://www.prisma.io/docs/orm/reference/prisma-client-reference#omit-preview) with [custom fields](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result#add-a-custom-field-to-query-results) and fields needed by custom fields.\n\n### `omit` fields needed by custom fields from query result[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result#omit-fields-needed-by-custom-fields-from-query-result \"Direct link to omit-fields-needed-by-custom-fields-from-query-result\")\n\nIf you `omit` a field that is a dependency of a custom field, it will still be read from the database even though it will not be included in the query result.\n\nThe following example omits the `password` field, which is a dependency of the custom field `sanitizedPassword`:\n\n```\nconst xprisma = prisma.$extends({  result: {    user: {      sanitizedPassword: {        needs: { password: true },        compute(user) {          return sanitize(user.password)        },      },    },  },})const user = await xprisma.user.findFirstOrThrow({  omit: {    password: true,  },})\n```\n\nIn this case, although `password` is omitted from the result, it will still be queried from the database because it is a dependency of the `sanitizedPassword` custom field.\n\n### `omit` custom field and dependencies from query result[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/result#omit-custom-field-and-dependencies-from-query-result \"Direct link to omit-custom-field-and-dependencies-from-query-result\")\n\nTo ensure omitted fields are not queried from the database at all, you must omit both the custom field and its dependencies.\n\nThe following example omits both the custom field `sanitizedPassword` and the dependent `password` field:\n\n```\nconst xprisma = prisma.$extends({  result: {    user: {      sanitizedPassword: {        needs: { password: true },        compute(user) {          return sanitize(user.password)        },      },    },  },})const user = await xprisma.user.findFirstOrThrow({  omit: {    sanitizedPassword: true,    password: true,  },})\n```\n\nIn this case, omitting both `password` and `sanitizedPassword` will exclude both from the result as well as prevent the `password` field from being read from the database.",
    "title": "Prisma Client extensions: result component | Prisma Documentation",
    "description": "Extend the functionality of Prisma Client, result component",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/shared-extensions",
    "markdown": "# Shared Prisma Client extensions | Prisma Documentation\n\nYou can share your [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) with other users, either as packages or as modules, and import extensions that other users create into your project.\n\nIf you would like to build a shareable extension, we also recommend using the [`prisma-client-extension-starter`](https://github.com/prisma/prisma-client-extension-starter) template.\n\nIn your project, you can install any Prisma Client extension that another user has published to `npm`. To do so, run the following command:\n\n```\nnpm install prisma-extension-<package-name>\n```\n\nFor example, if the package name for an available extension is `prisma-extension-find-or-create`, you could install it as follows:\n\n```\nnpm install prisma-extension-find-or-create\n```\n\nTo import the `find-or-create` extension from the example above, and wrap your client instance with it, you could use the following code. This example assumes that the extension name is `findOrCreate`.\n\n```\nimport findOrCreate from 'prisma-extension-find-or-create'const prisma = new PrismaClient().$extends(findOrCreate)const user = await prisma.user.findOrCreate()\n```\n\nWhen you call a method in an extension, use the constant name from your `$extends` statement, not `prisma`. In the above example,`xprisma.user.findOrCreate` works, but `prisma.user.findOrCreate` does not, because the original `prisma` is not modified.\n\nWhen you want to create extensions other users can use, and that are not tailored just for your schema, Prisma ORM provides utilities to allow you to create shareable extensions.\n\nTo create a shareable extension:\n\n1.  Define the extension as a module using `Prisma.defineExtension`\n2.  Use one of the methods that begin with the `$all` prefix such as [`$allModels`](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model#add-a-custom-method-to-all-models-in-your-schema) or [`$allOperations`](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-prisma-client-operations)\n\n### Define an extension[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/shared-extensions#define-an-extension \"Direct link to Define an extension\")\n\nUse the `Prisma.defineExtension` method to make your extension shareable. You can use it to package the extension to either separate your extensions into a separate file or share it with other users as an npm package.\n\nThe benefit of `Prisma.defineExtension` is that it provides strict type checks and auto completion for authors of extension in development and users of shared extensions.\n\n### Use a generic method[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/shared-extensions#use-a-generic-method \"Direct link to Use a generic method\")\n\nExtensions that contain methods under `$allModels` apply to every model instead of a specific one. Similarly, methods under `$allOperations` apply to a client instance as a whole and not to a named component, e.g. `result` or `query`.\n\nYou do not need to use the `$all` prefix with the [`client`](https://www.prisma.io/docs/orm/prisma-client/client-extensions/client) component, because the `client` component always applies to the client instance.\n\nFor example, a generic extension might take the following form:\n\n```\nexport default Prisma.defineExtension({  name: 'prisma-extension-find-or-create', //Extension name  model: {    $allModels: {      // new method      findOrCreate(/* args */) {        /* code for the new method */        return query(args)      },    },  },})\n```\n\nRefer to the following pages to learn the different ways you can modify Prisma Client operations:\n\n*   [Modify all Prisma Client operations](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-prisma-client-operations)\n*   [Modify a specific operation in all models of your schema](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-a-specific-operation-in-all-models-of-your-schema)\n*   [Modify all operations in all models of your schema](https://www.prisma.io/docs/orm/prisma-client/client-extensions/query#modify-all-operations-in-all-models-of-your-schema)\n\nFor versions earlier than 4.16.0\n\nThe `Prisma` import is available from a different path shown in the snippet below:\n\n```\nimport { Prisma } from '@prisma/client/scripts/default-index'export default Prisma.defineExtension({  name: 'prisma-extension-<extension-name>',})\n```\n\n### Publishing the shareable extension to npm[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/shared-extensions#publishing-the-shareable-extension-to-npm \"Direct link to Publishing the shareable extension to npm\")\n\nYou can then share the extension on `npm`. When you choose a package name, we recommend that you use the `prisma-extension-<package-name>` convention, to make it easier to find and install.\n\n### Call a client-level method from your packaged extension[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/shared-extensions#call-a-client-level-method-from-your-packaged-extension \"Direct link to Call a client-level method from your packaged extension\")\n\nIn the following situations, you need to refer to a Prisma Client instance that your extension wraps:\n\n*   When you want to use a [client-level method](https://www.prisma.io/docs/orm/reference/prisma-client-reference#client-methods), such as `$queryRaw`, in your packaged extension.\n*   When you want to chain multiple `$extends` calls in your packaged extension.\n\nHowever, when someone includes your packaged extension in their project, your code cannot know the details of the Prisma Client instance.\n\nYou can refer to this client instance as follows:\n\n```\nPrisma.defineExtension((client) => {  // The Prisma Client instance that the extension user applies the extension to  return client.$extends({    name: 'prisma-extension-<extension-name>',  })})\n```\n\nFor example:\n\n```\nexport default Prisma.defineExtension((client) => {  return client.$extends({    name: 'prisma-extension-find-or-create',    query: {      $allModels: {        async findOrCreate({ args, query, operation }) {          return (await client.$transaction([query(args)]))[0]        },      },    },  })})\n```\n\n### Advanced type safety: type utilities for defining generic extensions[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/shared-extensions#advanced-type-safety-type-utilities-for-defining-generic-extensions \"Direct link to Advanced type safety: type utilities for defining generic extensions\")\n\nYou can improve the type-safety of your shared extensions using [type utilities](https://www.prisma.io/docs/orm/prisma-client/client-extensions/type-utilities).",
    "title": "Shared Prisma Client extensions | Prisma Documentation",
    "description": "Share extensions or import shared extensions into your Prisma project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/type-utilities",
    "markdown": "# Prisma Client Extensions: Type utilities\n\nSeveral type utilities exist within Prisma Client that can assist in the creation of highly type-safe extensions.\n\n[Prisma Client type utilities](https://www.prisma.io/docs/orm/prisma-client/type-safety) are utilities available within your application and Prisma Client extensions and provide useful ways of constructing safe and extendable types for your extension.\n\nThe following example creates a new operation, `exists`, based on `findFirst`. It has all of the arguments that `findFirst`.\n\n```\nconst prisma = new PrismaClient().$extends({  model: {    $allModels: {      // Define a new `exists` operation on all models      // T is a generic type that corresponds to the current model      async exists<T>(        // `this` refers to the current type, e.g. `prisma.user` at runtime        this: T,        // The `exists` function will use the `where` arguments from the current model, `T`, and the `findFirst` operation        where: Prisma.Args<T, 'findFirst'>['where']      ): Promise<boolean> {        // Retrieve the current model at runtime        const context = Prisma.getExtensionContext(this)        // Prisma Client query that retrieves data based        const result = await (context as any).findFirst({ where })        return result !== null      },    },  },})async function main() {  const user = await prisma.user.exists({ name: 'Alice' })  const post = await prisma.post.exists({    OR: [      { title: { contains: 'Prisma' } },      { content: { contains: 'Prisma' } },    ],  })}\n```\n\nThe following example illustrates how you can add custom arguments, to a method in an extension:\n\n```\ntype CacheStrategy = {  swr: number  ttl: number}const prisma = new PrismaClient().$extends({  model: {    $allModels: {      findMany<T, A>(        this: T,        args: Prisma.Exact<          A,          // For the `findMany` method, use the arguments from model `T` and the `findMany` method          // and intersect it with `CacheStrategy` as part of `findMany` arguments          Prisma.Args<T, 'findMany'> & CacheStrategy        >      ): Prisma.Result<T, A, 'findMany'> {        // method implementation with the cache strategy      },    },  },})async function main() {  await prisma.post.findMany({    cacheStrategy: {      ttl: 360,      swr: 60,    },  })}\n```\n\nThe example here is only conceptual. For the actual caching to work, you will have to implement the logic. If you're interested in a caching extension/ service, we recommend taking a look at [Prisma Accelerate](https://www.prisma.io/data-platform/accelerate).",
    "title": "Prisma Client Extensions: Type utilities | Prisma Documentation",
    "description": "Advanced type safety: improve type safety in your custom model methods",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-type-system",
    "markdown": "# How to use Prisma ORM's type system\n\nThis guide introduces Prisma ORM's type system and explains how to introspect existing native types in your database, and how to use types when you apply schema changes to your database with Prisma Migrate or `db push`.\n\n## How does Prisma ORM's type system work?[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-type-system#how-does-prisma-orms-type-system-work \"Direct link to How does Prisma ORM's type system work?\")\n\nPrisma ORM uses _types_ to define the kind of data that a field can hold. To make it easy to get started, Prisma ORM provides a small number of core [scalar types](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) that should cover most default use cases. For example, take the following blog post model:\n\nschema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model Post {  id        Int      @id  title     String  createdAt DateTime}\n```\n\nThe `title` field of the `Post` model uses the `String` scalar type, while the `createdAt` field uses the `DateTime` scalar type.\n\nDatabases also have their own type system, which defines the type of value that a column can hold. Most databases provide a large number of data types to allow fine-grained control over exactly what a column can store. For example, a database might provide inbuilt support for multiple sizes of integers, or for XML data. The names of these types vary between databases. For example, in PostgreSQL the column type for booleans is `boolean`, whereas in MySQL the `tinyint(1)` type is typically used.\n\nIn the blog post example above, we are using the PostgreSQL connector. This is specified in the `datasource` block of the Prisma schema.\n\n### Default type mappings[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-type-system#default-type-mappings \"Direct link to Default type mappings\")\n\nTo allow you to get started with our core scalar types, Prisma ORM provides _default type mappings_ that map each scalar type to a default type in the underlying database. For example:\n\n*   by default Prisma ORM's `String` type gets mapped to PostgreSQL's `text` type and MySQL's `varchar` type\n*   by default Prisma ORM's `DateTime` type gets mapped to PostgreSQL's `timestamp(3)` type and SQL Server's `datetime2` type\n\nSee Prisma ORM's [database connector pages](https://www.prisma.io/docs/orm/overview/databases) for the default type mappings for a given database. For example, [this table](https://www.prisma.io/docs/orm/overview/databases/postgresql#type-mapping-between-postgresql-and-prisma-schema) gives the default type mappings for PostgreSQL.  \nTo see the default type mappings for all databases for a specific given Prisma ORM type, see the [model field scalar types section](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) of the Prisma schema reference. For example, [this table](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#float) gives the default type mappings for the `Float` scalar type.\n\n### Native type mappings[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-type-system#native-type-mappings \"Direct link to Native type mappings\")\n\nSometimes you may need to use a more specific database type that is not one of the default type mappings for your Prisma ORM type. For this purpose, Prisma ORM provides [native type attributes](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#native-types-mapping) to refine the core scalar types. For example, in the `createdAt` field of your `Post` model above you may want to use a date-only column in your underlying PostgreSQL database, by using the `date` type instead of the default type mapping of `timestamp(3)`. To do this, add a `@db.Date` native type attribute to the `createdAt` field:\n\nschema.prisma\n\n```\nmodel Post {  id        Int      @id  title     String  createdAt DateTime @db.Date}\n```\n\nNative type mappings allow you to express all the types in your database. However, you do not need to use them if the Prisma ORM defaults satisfy your needs. This leads to a shorter, more readable Prisma schema for common use cases.\n\n## How to introspect database types[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-type-system#how-to-introspect-database-types \"Direct link to How to introspect database types\")\n\nWhen you [introspect](https://www.prisma.io/docs/orm/prisma-schema/introspection) an existing database, Prisma ORM will take the database type of each table column and represent it in your Prisma schema using the correct Prisma ORM type for the corresponding model field. If the database type is not the default database type for that Prisma ORM scalar type, Prisma ORM will also add a native type attribute.\n\nAs an example, take a `User` table in a PostgreSQL database, with:\n\n*   an `id` column with a data type of `serial`\n*   a `name` column with a data type of `text`\n*   an `isActive` column with a data type of `boolean`\n\nYou can create this with the following SQL command:\n\n```\nCREATE TABLE \"public\".\"User\" (  id serial PRIMARY KEY NOT NULL,  name text NOT NULL,  \"isActive\" boolean NOT NULL);\n```\n\nIntrospect your database with the following command run from the root directory of your project:\n\nYou will get the following Prisma schema:\n\nschema.prisma\n\n```\nmodel User {  id       Int     @id @default(autoincrement())  name     String  isActive Boolean}\n```\n\nThe `id`, `name` and `isActive` columns in the database are mapped respectively to the `Int`, `String` and `Boolean` Prisma ORM types. The database types are the _default_ database types for these Prisma ORM types, so Prisma ORM does not add any native type attributes.\n\nNow add a `createdAt` column to your database with a data type of `date` by running the following SQL command:\n\n```\nALTER TABLE \"public\".\"User\"ADD COLUMN \"createdAt\" date NOT NULL;\n```\n\nIntrospect your database again:\n\nYour Prisma schema now includes the new `createdAt` field with a Prisma ORM type of `DateTime`. The `createdAt` field also has a `@db.Date` native type attribute, because PostgreSQL's `date` is not the default type for the `DateTime` type:\n\nschema.prisma\n\n```\nmodel User {  id        Int      @id @default(autoincrement())  name      String  isActive  Boolean  createdAt DateTime @db.Date}\n```\n\n## How to use types when you apply schema changes to your database[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-type-system#how-to-use-types-when-you-apply-schema-changes-to-your-database \"Direct link to How to use types when you apply schema changes to your database\")\n\nWhen you apply schema changes to your database using Prisma Migrate or `db push`, Prisma ORM will use both the Prisma ORM scalar type of each field and any native attribute it has to determine the correct database type for the corresponding column in the database.\n\nAs an example, create a Prisma schema with the following `Post` model:\n\nschema.prisma\n\n```\nmodel Post {  id        Int      @id  title     String  createdAt DateTime  updatedAt DateTime @db.Date}\n```\n\nThis `Post` model has:\n\n*   an `id` field with a Prisma ORM type of `Int`\n*   a `title` field with a Prisma ORM type of `String`\n*   a `createdAt` field with a Prisma ORM type of `DateTime`\n*   an `updatedAt` field with a Prisma ORM type of `DateTime` and a `@db.Date` native type attribute\n\nNow apply these changes to an empty PostgreSQL database with the following command, run from the root directory of your project:\n\nYou will see that the database has a newly created `Post` table, with:\n\n*   an `id` column with a database type of `integer`\n*   a `title` column with a database type of `text`\n*   a `createdAt` column with a database type of `timestamp(3)`\n*   an `updatedAt` column with a database type of `date`\n\nNotice that the `@db.Date` native type attribute modifies the database type of the `updatedAt` column to `date`, rather than the default of `timestamp(3)`.\n\n## More on using Prisma ORM's type system[​](https://www.prisma.io/docs/orm/prisma-client/type-safety/prisma-type-system#more-on-using-prisma-orms-type-system \"Direct link to More on using Prisma ORM's type system\")\n\nFor further reference information on using Prisma ORM's type system, see the following resources:\n\n*   The [database connector](https://www.prisma.io/docs/orm/overview) page for each database provider has a type mapping section with a table of default type mappings between Prisma ORM types and database types, and a table of database types with their corresponding native type attribute in Prisma ORM. For example, the type mapping section for PostgreSQL is [here](https://www.prisma.io/docs/orm/overview/databases/postgresql#type-mapping-between-postgresql-and-prisma-schema).\n*   The [model field scalar types](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) section of the Prisma schema reference has a subsection for each Prisma ORM scalar type. This includes a table of default mappings for that Prisma ORM type in each database, and a table for each database listing the corresponding database types and their native type attributes in Prisma ORM. For example, the entry for the `String` Prisma ORM type is [here](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#string).",
    "title": "How to use Prisma ORM's type system | Prisma Documentation",
    "description": "How to use Prisma ORM's type system",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/extension-examples",
    "markdown": "# Prisma Client extensions | Shared packages & examples\n\n## Extensions made by Prisma[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/extension-examples#extensions-made-by-prisma \"Direct link to Extensions made by Prisma\")\n\nThe following is a list of extensions we've built at Prisma:\n\n| Extension | Description |\n| --- | --- |\n| [`@prisma/extension-accelerate`](https://www.npmjs.com/package/@prisma/extension-accelerate) | Enables [Accelerate](https://www.prisma.io/data-platform/accelerate), a global database cache available in 300+ locations with built-in connection pooling |\n| [`@prisma/extension-pulse`](https://npmjs.com/package/@prisma/extension-pulse) | Enables [Pulse](https://www.prisma.io/data-platform/pulse), a service that captures change events from your database and delivers them instantly to your applications. |\n| [`@prisma/extension-read-replicas`](https://github.com/prisma/extension-read-replicas) | Adds read replica support to Prisma Client |\n\nThe following is a list of extensions created by the community. If you want to create your own package, refer to the [Shared Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions/shared-extensions) documentation.\n\n| Extension | Description |\n| --- | --- |\n| [`prisma-extension-supabase-rls`](https://github.com/dthyresson/prisma-extension-supabase-rls) | Adds support for Supabase Row Level Security with Prisma |\n| [`prisma-extension-bark`](https://github.com/adamjkb/bark) | Implements the Materialized Path pattern that allows you to easily create and interact with tree structures in Prisma |\n| [`prisma-cursorstream`](https://github.com/etabits/prisma-cursorstream) | Adds cursor-based streaming |\n| [`prisma-gpt`](https://github.com/aliyeysides/prisma-gpt) | Lets you query your database using natural language |\n| [`prisma-extension-caching`](https://github.com/isaev-the-poetry/prisma-extension-caching) | Adds the ability to cache complex queries |\n| [`prisma-extension-cache-manager`](https://github.com/random42/prisma-extension-cache-manager) | Caches model queries with any [cache-manager](https://www.npmjs.com/package/cache-manager) compatible cache |\n| [`prisma-extension-random`](https://github.com/nkeil/prisma-extension-random) | Lets you query for random rows in your database |\n| [`prisma-paginate`](https://github.com/sandrewTx08/prisma-paginate) | Adds support for paginating read queries |\n| [`prisma-extension-streamdal`](https://github.com/streamdal/prisma-extension-streamdal) | Adds support for Code-Native data pipelines using Streamdal |\n\nIf you have built an extension and would like to see it featured, feel free to add it to the list by opening a pull request.\n\n## Examples[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/extension-examples#examples \"Direct link to Examples\")\n\ninfo\n\nThe following example extensions are provided as examples only, and without warranty. They are supposed to show how Prisma Client extensions can be created using approaches documented here. We recommend using these examples as a source of inspiration for building your own extensions.\n\n| Example | Description |\n| --- | --- |\n| [`audit-log-context`](https://github.com/prisma/prisma-client-extensions/tree/main/audit-log-context) | Provides the current user's ID as context to Postgres audit log triggers |\n| [`callback-free-itx`](https://github.com/prisma/prisma-client-extensions/tree/main/callback-free-itx) | Adds a method to start interactive transactions without callbacks |\n| [`computed-fields`](https://github.com/prisma/prisma-client-extensions/tree/main/computed-fields) | Adds virtual / computed fields to result objects |\n| [`input-transformation`](https://github.com/prisma/prisma-client-extensions/tree/main/input-transformation) | Transforms the input arguments passed to Prisma Client queries to filter the result set |\n| [`input-validation`](https://github.com/prisma/prisma-client-extensions/tree/main/input-validation) | Runs custom validation logic on input arguments passed to mutation methods |\n| [`instance-methods`](https://github.com/prisma/prisma-client-extensions/tree/main/instance-methods) | Adds Active Record-like methods like `save()` and `delete()` to result objects |\n| [`json-field-types`](https://github.com/prisma/prisma-client-extensions/tree/main/json-field-types) | Uses strongly-typed runtime parsing for data stored in JSON columns |\n| [`model-filters`](https://github.com/prisma/prisma-client-extensions/tree/main/model-filters) | Adds reusable filters that can composed into complex `where` conditions for a model |\n| [`obfuscated-fields`](https://github.com/prisma/prisma-client-extensions/tree/main/obfuscated-fields) | Prevents sensitive data (e.g. `password` fields) from being included in results |\n| [`query-logging`](https://github.com/prisma/prisma-client-extensions/tree/main/query-logging) | Wraps Prisma Client queries with simple query timing and logging |\n| [`readonly-client`](https://github.com/prisma/prisma-client-extensions/tree/main/readonly-client) | Creates a client that only allows read operations |\n| [`retry-transactions`](https://github.com/prisma/prisma-client-extensions/tree/main/retry-transactions) | Adds a retry mechanism to transactions with exponential backoff and jitter |\n| [`row-level-security`](https://github.com/prisma/prisma-client-extensions/tree/main/row-level-security) | Uses Postgres row-level security policies to isolate data a multi-tenant application |\n| [`static-methods`](https://github.com/prisma/prisma-client-extensions/tree/main/static-methods) | Adds custom query methods to Prisma Client models |\n| [`transformed-fields`](https://github.com/prisma/prisma-client-extensions/tree/main/transformed-fields) | Demonstrates how to use result extensions to transform query results and add i18n to an app |\n| [`exists-method`](https://github.com/prisma/prisma-client-extensions/tree/main/exists-fn) | Demonstrates how to add an `exists` method to all your models |\n| [`update-delete-ignore-not-found`](https://github.com/prisma/prisma-client-extensions/tree/main/update-delete-ignore-not-found) | Demonstrates how to add the `updateIgnoreOnNotFound` and `deleteIgnoreOnNotFound` methods to all your models. |\n\n## Going further[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/extension-examples#going-further \"Direct link to Going further\")\n\n*   Learn more about [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions).",
    "title": "Prisma Client extensions | Shared packages & examples | Prisma Documentation",
    "description": "Explore the Prisma Client extensions that have been built by Prisma and its community",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/session-data-middleware",
    "markdown": "# Middleware sample: session data (Reference)\n\nThe following example sets the `language` field of each `Post` to the context language (taken, for example, from session state):\n\n```\nconst prisma = new PrismaClient()const contextLanguage = 'en-us' // Session stateprisma.$use(async (params, next) => {  if (params.model == 'Post' && params.action == 'create') {    params.args.data.language = contextLanguage  }  return next(params)})const create = await prisma.post.create({  data: {    title: 'My post in English',  },})\n```",
    "title": "Middleware sample: session data (Reference) | Prisma Documentation",
    "description": "How to use middleware to set the value taken from session state.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/debugging-and-troubleshooting/debugging",
    "markdown": "# Debugging (Reference) | Prisma Documentation\n\nYou can enable debugging output in Prisma Client and Prisma CLI via the [`DEBUG`](https://www.prisma.io/docs/orm/reference/environment-variables-reference#debug) environment variable. It accepts two namespaces to print debugging output:\n\n```\n# enable only `prisma:engine`-level debugging outputexport DEBUG=\"prisma:engine\"# enable only `prisma:client`-level debugging outputexport DEBUG=\"prisma:client\"# enable both `prisma-client`- and `engine`-level debugging outputexport DEBUG=\"prisma:client,prisma:engine\"\n```",
    "title": "Debugging (Reference) | Prisma Documentation",
    "description": "This page explains how to enable debugging output for Prisma Client by setting the `DEBUG` environment variable.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/testing/unit-testing",
    "markdown": "# Unit testing with Prisma ORM\n\nUnit testing aims to isolate a small portion (unit) of code and test it for logically predictable behaviors. It generally involves mocking objects or server responses to simulate real world behaviors. Some benefits to unit testing include:\n\n*   Quickly find and isolate bugs in code.\n*   Provides documentation for each module of code by way of indicating what certain code blocks should be doing.\n*   A helpful gauge that a refactor has gone well. The tests should still pass after code has been refactored.\n\nIn the context of Prisma ORM, this generally means testing a function which makes database calls using Prisma Client.\n\nA single test should focus on how your function logic handles different inputs (such as a null value or an empty list).\n\nThis means that you should aim to remove as many dependencies as possible, such as external services and databases, to keep the tests and their environments as lightweight as possible.\n\n> **Note**: This [blog post](https://www.prisma.io/blog/testing-series-2-xPhjjmIEsM) provides a comprehensive guide to implementing unit testing in your Express project with Prisma ORM. If you're looking to delve into this topic, be sure to give it a read!\n\n## Prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/testing/unit-testing#prerequisites \"Direct link to Prerequisites\")\n\nThis guide assumes you have the JavaScript testing library [`Jest`](https://jestjs.io/) and [`ts-jest`](https://github.com/kulshekhar/ts-jest) already setup in your project.\n\n## Mocking Prisma Client[​](https://www.prisma.io/docs/orm/prisma-client/testing/unit-testing#mocking-prisma-client \"Direct link to Mocking Prisma Client\")\n\nTo ensure your unit tests are isolated from external factors you can mock Prisma Client, this means you get the benefits of being able to use your schema (**_type-safety_**), without having to make actual calls to your database when your tests are run.\n\nThis guide will cover two approaches to mocking Prisma Client, a singleton instance and dependency injection. Both have their merits depending on your use cases. To help with mocking Prisma Client the [`jest-mock-extended`](https://github.com/marchaos/jest-mock-extended) package will be used.\n\n```\nnpm install jest-mock-extended@2.0.4 --save-dev\n```\n\ndanger\n\nAt the time of writing, this guide uses `jest-mock-extended` version `^2.0.4`.\n\n### Singleton[​](https://www.prisma.io/docs/orm/prisma-client/testing/unit-testing#singleton \"Direct link to Singleton\")\n\nThe following steps guide you through mocking Prisma Client using a singleton pattern.\n\n1.  Create a file at your projects root called `client.ts` and add the following code. This will instantiate a Prisma Client instance.\n    \n    client.ts\n    \n    ```\n    import { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()export default prisma\n    ```\n    \n2.  Next create a file named `singleton.ts` at your projects root and add the following:\n    \n    singleton.ts\n    \n    ```\n    import { PrismaClient } from '@prisma/client'import { mockDeep, mockReset, DeepMockProxy } from 'jest-mock-extended'import prisma from './client'jest.mock('./client', () => ({  __esModule: true,  default: mockDeep<PrismaClient>(),}))beforeEach(() => {  mockReset(prismaMock)})export const prismaMock = prisma as unknown as DeepMockProxy<PrismaClient>\n    ```\n    \n\nThe singleton file tells Jest to mock a default export (the Prisma Client instance in `./client.ts`), and uses the `mockDeep` method from `jest-mock-extended` to enable access to the objects and methods available on Prisma Client. It then resets the mocked instance before each test is run.\n\nNext, add the `setupFilesAfterEnv` property to your `jest.config.js` file with the path to your `singleton.ts` file.\n\njest.config.js\n\n```\nmodule.exports = {  clearMocks: true,  preset: 'ts-jest',  testEnvironment: 'node',  setupFilesAfterEnv: ['<rootDir>/singleton.ts'],}\n```\n\n### Dependency injection[​](https://www.prisma.io/docs/orm/prisma-client/testing/unit-testing#dependency-injection \"Direct link to Dependency injection\")\n\nAnother popular pattern that can be used is dependency injection.\n\n1.  Create a `context.ts` file and add the following:\n    \n    context.ts\n    \n    ```\n    import { PrismaClient } from '@prisma/client'import { mockDeep, DeepMockProxy } from 'jest-mock-extended'export type Context = {  prisma: PrismaClient}export type MockContext = {  prisma: DeepMockProxy<PrismaClient>}export const createMockContext = (): MockContext => {  return {    prisma: mockDeep<PrismaClient>(),  }}\n    ```\n    \n\ntip\n\nIf you find that you're seeing a circular dependency error highlighted through mocking Prisma Client, try adding `\"strictNullChecks\": true` to your `tsconfig.json`.\n\n2.  To use the context, you would do the following in your test file:\n    \n    ```\n    import { MockContext, Context, createMockContext } from '../context'let mockCtx: MockContextlet ctx: ContextbeforeEach(() => {  mockCtx = createMockContext()  ctx = mockCtx as unknown as Context})\n    ```\n    \n\nThis will create a new context before each test is run via the `createMockContext` function. This (`mockCtx`) context will be used to make a mock call to Prisma Client and run a query to test. The `ctx` context will be used to run a scenario query that is tested against.\n\n## Example unit tests[​](https://www.prisma.io/docs/orm/prisma-client/testing/unit-testing#example-unit-tests \"Direct link to Example unit tests\")\n\nA real world use case for unit testing Prisma ORM might be a signup form. Your user fills in a form which calls a function, which in turn uses Prisma Client to make a call to your database.\n\nAll of the examples that follow use the following schema model:\n\nschema.prisma\n\n```\nmodel User {  id                       Int     @id @default(autoincrement())  email                    String  @unique  name                     String?  acceptTermsAndConditions Boolean}\n```\n\nThe following unit tests will mock the process of\n\n*   Creating a new user\n*   Updating a users name\n*   Failing to create a user if terms are not accepted\n\nThe functions that use the dependency injection pattern will have the context injected (passed in as a parameter) into them, whereas the functions that use the singleton pattern will use the singleton instance of Prisma Client.\n\nfunctions-with-context.ts\n\n```\nimport { Context } from './context'interface CreateUser {  name: string  email: string  acceptTermsAndConditions: boolean}export async function createUser(user: CreateUser, ctx: Context) {  if (user.acceptTermsAndConditions) {    return await ctx.prisma.user.create({      data: user,    })  } else {    return new Error('User must accept terms!')  }}interface UpdateUser {  id: number  name: string  email: string}export async function updateUsername(user: UpdateUser, ctx: Context) {  return await ctx.prisma.user.update({    where: { id: user.id },    data: user,  })}\n```\n\nfunctions-without-context.ts\n\n```\nimport prisma from './client'interface CreateUser {  name: string  email: string  acceptTermsAndConditions: boolean}export async function createUser(user: CreateUser) {  if (user.acceptTermsAndConditions) {    return await prisma.user.create({      data: user,    })  } else {    return new Error('User must accept terms!')  }}interface UpdateUser {  id: number  name: string  email: string}export async function updateUsername(user: UpdateUser) {  return await prisma.user.update({    where: { id: user.id },    data: user,  })}\n```\n\nThe tests for each methodology are fairly similar, the difference is how the mocked Prisma Client is used.\n\nThe **_dependency injection_** example passes the context through to the function that is being tested as well as using it to call the mock implementation.\n\nThe **_singleton_** example uses the singleton client instance to call the mock implementation.\n\n\\_\\_tests\\_\\_/with-singleton.ts\n\n```\nimport { createUser, updateUsername } from '../functions-without-context'import { prismaMock } from '../singleton'test('should create new user ', async () => {  const user = {    id: 1,    name: 'Rich',    email: 'hello@prisma.io',    acceptTermsAndConditions: true,  }  prismaMock.user.create.mockResolvedValue(user)  await expect(createUser(user)).resolves.toEqual({    id: 1,    name: 'Rich',    email: 'hello@prisma.io',    acceptTermsAndConditions: true,  })})test('should update a users name ', async () => {  const user = {    id: 1,    name: 'Rich Haines',    email: 'hello@prisma.io',    acceptTermsAndConditions: true,  }  prismaMock.user.update.mockResolvedValue(user)  await expect(updateUsername(user)).resolves.toEqual({    id: 1,    name: 'Rich Haines',    email: 'hello@prisma.io',    acceptTermsAndConditions: true,  })})test('should fail if user does not accept terms', async () => {  const user = {    id: 1,    name: 'Rich Haines',    email: 'hello@prisma.io',    acceptTermsAndConditions: false,  }  prismaMock.user.create.mockImplementation()  await expect(createUser(user)).resolves.toEqual(    new Error('User must accept terms!')  )})\n```\n\n\\_\\_tests\\_\\_/with-dependency-injection.ts\n\n```\nimport { MockContext, Context, createMockContext } from '../context'import { createUser, updateUsername } from '../functions-with-context'let mockCtx: MockContextlet ctx: ContextbeforeEach(() => {  mockCtx = createMockContext()  ctx = mockCtx as unknown as Context})test('should create new user ', async () => {  const user = {    id: 1,    name: 'Rich',    email: 'hello@prisma.io',    acceptTermsAndConditions: true,  }  mockCtx.prisma.user.create.mockResolvedValue(user)  await expect(createUser(user, ctx)).resolves.toEqual({    id: 1,    name: 'Rich',    email: 'hello@prisma.io',    acceptTermsAndConditions: true,  })})test('should update a users name ', async () => {  const user = {    id: 1,    name: 'Rich Haines',    email: 'hello@prisma.io',    acceptTermsAndConditions: true,  }  mockCtx.prisma.user.update.mockResolvedValue(user)  await expect(updateUsername(user, ctx)).resolves.toEqual({    id: 1,    name: 'Rich Haines',    email: 'hello@prisma.io',    acceptTermsAndConditions: true,  })})test('should fail if user does not accept terms', async () => {  const user = {    id: 1,    name: 'Rich Haines',    email: 'hello@prisma.io',    acceptTermsAndConditions: false,  }  mockCtx.prisma.user.create.mockImplementation()  await expect(createUser(user, ctx)).resolves.toEqual(    new Error('User must accept terms!')  )})\n```",
    "title": "Unit testing with Prisma ORM | Prisma Documentation",
    "description": "Learn how to setup and run unit tests with Prisma Client",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing",
    "markdown": "# OpenTelemetry tracing (Preview) | Prisma Documentation\n\nTracing provides a detailed log of the activity that Prisma Client carries out, at an operation level, including the time taken to execute each query. It helps you analyze your application's performance and identify bottlenecks. Tracing is fully compliant with [OpenTelemetry](https://opentelemetry.io/), so you can use it as part of your end-to-end application tracing system.\n\ninfo\n\nTracing gives you a highly detailed, operation-level insight into your Prisma ORM project. If you want aggregated numerical reporting, such as query counts, connection counts, and total query execution times, see [Metrics](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/metrics).\n\n## About tracing[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#about-tracing \"Direct link to About tracing\")\n\nWhen you enable tracing, Prisma Client outputs the following:\n\n*   One trace for each operation (e.g. findMany) that Prisma Client makes.\n*   In each trace, one or more [spans](https://www.opentelemetry.io/docs/reference/specification/trace/api/#span). Each span represents the length of time that one stage of the operation takes, such as serialization, or a database query. Spans are represented in a tree structure, where child spans indicate that execution is happening within a larger parent span.\n\nThe number and type of spans in a trace depends on the type of operation the trace covers, but an example is as follows:\n\n![image](https://www.prisma.io/docs/assets/images/trace-diagram-685d4bc0c98df6b7c0349a9ac4655e34.png)\n\nYou can [send tracing output to the console](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#send-tracing-output-to-the-console), or analyze it in any OpenTelemetry-compatible tracing system, such as [Jaeger](https://www.jaegertracing.io/), [Honeycomb](https://www.honeycomb.io/trace/) and [Datadog](https://www.datadoghq.com/). On this page, we give an example of how to send tracing output to Jaeger, which you can [run locally](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#visualize-traces-with-jaeger).\n\n## Trace output[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#trace-output \"Direct link to Trace output\")\n\nFor each trace, Prisma Client outputs a series of spans. The number and type of these spans depends on the Prisma Client operation. A typical Prisma trace has the following spans:\n\n*   `prisma:client:operation`: Represents the entire Prisma Client operation, from Prisma Client to the database and back. It contains details such as the model and method called by Prisma Client. Depending on the Prisma operation, it contains one or more of the following spans:\n    *   `prisma:client:connect`: Represents how long it takes for Prisma Client to connect to the database.\n    *   `prisma:client:serialize`: Represents how long it takes to validate and transform a Prisma Client operation into a query for the [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines).\n    *   `prisma:engine`: Represents how long a query takes in the query engine.\n        *   `prisma:engine:connection`: Represents how long it takes for Prisma Client to get a database connection.\n        *   `prisma:engine:db_query`: Represents the database query that was executed against the database. It includes the query in the tags, and how long the query took to run.\n        *   `prisma:engine:serialize`: Represents how long it takes to transform a database query result into a Prisma Client result.\n\nFor example, given the following Prisma Client code:\n\n```\nprisma.user.findMany({  where: {    email: email,  },  include: {    posts: true,  },})\n```\n\nThe trace is structured as follows:\n\n*   `prisma:client:operation`\n    *   `prisma:client:serialize`\n    *   `prisma:engine`\n        *   `prisma:engine:connection`\n        *   `prisma:engine:db_query`: details of the first SQL query or command...\n        *   `prisma:engine:db_query`: ...details of the next SQL query or command...\n        *   `prisma:engine:serialize`\n\n## Considerations and prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#considerations-and-prerequisites \"Direct link to Considerations and prerequisites\")\n\nIf your application sends a large number of spans to a [collector](https://opentelemetry.io/docs/collector/), this can have a significant performance impact. For information on how to minimize this impact, see [Reducing performance impact](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#reduce-performance-impact).\n\nTo use tracing, you must do the following:\n\n1.  [Install the appropriate dependencies](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#step-1-install-up-to-date-prisma-orm-dependencies).\n2.  [Enable the `tracing` feature flag in your Prisma schema file](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#step-2-enable-the-feature-flag-in-your-prisma-schema-file).\n3.  [Install OpenTelemetry packages](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#step-3-install-opentelemetry-packages).\n\n## Get started with tracing in Prisma ORM[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#get-started-with-tracing-in-prisma-orm \"Direct link to Get started with tracing in Prisma ORM\")\n\nThis section explains how to install and register tracing in your application.\n\n### Step 1. Install up-to-date Prisma ORM dependencies[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#step-1-install-up-to-date-prisma-orm-dependencies \"Direct link to Step 1. Install up-to-date Prisma ORM dependencies\")\n\nUse version `4.2.0` or later of the `prisma`, `@prisma/client`, and `@prisma/instrumentation` npm packages.\n\n```\nnpm install prisma@latest --save-devnpm install @prisma/client@latest --savenpm install @prisma/instrumentation@latest --save\n```\n\n### Step 2: Enable the feature flag in your Prisma schema file[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#step-2-enable-the-feature-flag-in-your-prisma-schema-file \"Direct link to Step 2: Enable the feature flag in your Prisma schema file\")\n\nIn the `generator` block of your `schema.prisma` file, enable the `tracing` feature flag:\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"tracing\"]}\n```\n\n### Step 3: Install OpenTelemetry packages[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#step-3-install-opentelemetry-packages \"Direct link to Step 3: Install OpenTelemetry packages\")\n\nFinally, install the appropriate OpenTelemetry packages, as follows:\n\n```\nnpm install @opentelemetry/semantic-conventions @opentelemetry/exporter-trace-otlp-http @opentelemetry/instrumentation @opentelemetry/sdk-trace-base @opentelemetry/sdk-trace-node @opentelemetry/resources\n```\n\n### Register tracing in your application[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#register-tracing-in-your-application \"Direct link to Register tracing in your application\")\n\nThe following code provides a minimal tracing configuration. You need to customize this configuration for your specific application.\n\nsetup.ts\n\n```\n// Importsimport { SEMRESATTRS_SERVICE_NAME, SEMRESATTRS_SERVICE_VERSION } from '@opentelemetry/semantic-conventions'import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'import { registerInstrumentations } from '@opentelemetry/instrumentation'import { SimpleSpanProcessor } from '@opentelemetry/sdk-trace-base'import { NodeTracerProvider } from '@opentelemetry/sdk-trace-node'import { PrismaInstrumentation } from '@prisma/instrumentation'import { Resource } from '@opentelemetry/resources'// Configure the trace providerconst provider = new NodeTracerProvider({  resource: new Resource({    [SEMRESATTRS_SERVICE_NAME]: 'example application',    [SEMRESATTRS_SERVICE_VERSION]: '0.0.1',  }),})// Configure how spans are processed and exported. In this case we're sending spans// as we receive them to an OTLP-compatible collector (e.g. Jaeger).provider.addSpanProcessor(new SimpleSpanProcessor(new OTLPTraceExporter()))// Register your auto-instrumentorsregisterInstrumentations({  tracerProvider: provider,  instrumentations: [new PrismaInstrumentation()],})// Register the provider globallyprovider.register()\n```\n\nOpenTelemetry is highly configurable. You can customize the resource attributes, what components gets instrumented, how spans are processed, and where spans are sent.\n\nYou can find a complete example that includes metrics in [this sample application](https://github.com/garrensmith/prisma-metrics-sample).\n\n## Tracing how-tos[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#tracing-how-tos \"Direct link to Tracing how-tos\")\n\n### Visualize traces with Jaeger[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#visualize-traces-with-jaeger \"Direct link to Visualize traces with Jaeger\")\n\n[Jaeger](https://www.jaegertracing.io/) is a free and open source OpenTelemetry collector and dashboard that you can use to visualize your traces.\n\nThe following screenshot shows an example trace visualization:\n\n![Jaeger UI](https://www.prisma.io/docs/assets/images/jaeger-1e0769310122fa6cecbd13b71409a71a.png)\n\nTo run Jaeger locally, use the following [Docker](https://www.docker.com/) command:\n\n```\ndocker run --rm --name jaeger -d -e COLLECTOR_OTLP_ENABLED=true -p 16686:16686 -p 4318:4318 jaegertracing/all-in-one:latest\n```\n\nYou'll now find the tracing dashboard available at `http://localhost:16686/`. When you use your application with tracing enabled, you'll start to see traces in this dashboard.\n\n### Send tracing output to the console[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#send-tracing-output-to-the-console \"Direct link to Send tracing output to the console\")\n\nThe following example sends output tracing to the console with `ConsoleSpanExporter` from `@opentelemetry/sdk-trace-base`.\n\n```\n// Importsimport { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'import { registerInstrumentations } from '@opentelemetry/instrumentation'import {  BasicTracerProvider,  ConsoleSpanExporter,  SimpleSpanProcessor,} from '@opentelemetry/sdk-trace-base'import { AsyncHooksContextManager } from '@opentelemetry/context-async-hooks'import * as api from '@opentelemetry/api'import { PrismaInstrumentation } from '@prisma/instrumentation'import { Resource } from '@opentelemetry/resources'// Export the tracingexport function otelSetup() {  const contextManager = new AsyncHooksContextManager().enable()  api.context.setGlobalContextManager(contextManager)  //Configure the console exporter  const consoleExporter = new ConsoleSpanExporter()  // Configure the trace provider  const provider = new BasicTracerProvider({    resource: new Resource({      [SemanticResourceAttributes.SERVICE_NAME]: 'test-tracing-service',      [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0',    }),  })  // Configure how spans are processed and exported. In this case we're sending spans  // as we receive them to the console  provider.addSpanProcessor(new SimpleSpanProcessor(consoleExporter))  // Register your auto-instrumentors  registerInstrumentations({    tracerProvider: provider,    instrumentations: [new PrismaInstrumentation()],  })  // Register the provider  provider.register()}\n```\n\n### Trace Prisma Client middleware[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#trace-prisma-client-middleware \"Direct link to Trace Prisma Client middleware\")\n\nBy default, tracing does not output spans for [Prisma Client middleware](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware). To include your middleware in your traces, set `middleware` to `true` in your `registerInstrumentations` statement, as follows:\n\n```\nregisterInstrumentations({  instrumentations: [new PrismaInstrumentation({ middleware: true })],})\n```\n\nThis will add the following span type to your traces:\n\n*   `prisma:client:middleware`: Represents how long the operation spent in your [middleware](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware).\n\n### Trace interactive transactions[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#trace-interactive-transactions \"Direct link to Trace interactive transactions\")\n\nWhen you perform an interactive transaction, you'll see the following spans in addition to the [standard spans](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#trace-output):\n\n*   `prisma:client:transaction`: A [root span](https://opentelemetry.io/docs/concepts/observability-primer/#distributed-traces) that wraps the `prisma` span.\n    *   `prisma:engine:itx_runner`: Represents how long an interactive transaction takes in the [query engine](https://www.prisma.io/docs/orm/more/under-the-hood/engines).\n    *   `prisma:engine:itx_query_builder`: Represents the time it takes to build an interactive transaction.\n\nAs an example, take the following Prisma schema:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"tracing\", \"interactiveTransactions\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model User {  id    Int    @id @default(autoincrement())  email String @unique}model Audit {  id     Int    @id  table  String  action String}\n```\n\nGiven the following interactive transaction:\n\n```\nawait prisma.$transaction(async (tx) => {  const user = await tx.user.create({    data: {      email: email,    },  })  await tx.audit.create({    data: {      table: 'user',      action: 'create',      id: user.id,    },  })  return user})\n```\n\nThe trace is structured as follows:\n\n*   `prisma:client:transaction`\n*   `prisma:client:connect`\n*   `prisma:engine:itx_runner`\n    *   `prisma:engine:connection`\n    *   `prisma:engine:db_query`\n    *   `prisma:engine:itx_query_builder`\n        *   `prisma:engine:db_query`\n        *   `prisma:engine:db_query`\n        *   `prisma:engine:serialize`\n    *   `prisma:engine:itx_query_builder`\n        *   `prisma:engine:db_query`\n        *   `prisma:engine:db_query`\n        *   `prisma:engine:serialize`\n*   `prisma:client:operation`\n    *   `prisma:client:serialize`\n*   `prisma:client:operation`\n    *   `prisma:client:serialize`\n\n### Add more instrumentation[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#add-more-instrumentation \"Direct link to Add more instrumentation\")\n\nA nice benefit of OpenTelemetry is the ability to add more instrumentation with only minimal changes to your application code.\n\nFor example, to add HTTP and [ExpressJS](https://expressjs.com/) tracing, add the following instrumentations to your OpenTelemetry configuration. These instrumentations add spans for the full request-response lifecycle. These spans show you how long your HTTP requests take.\n\n```\n// Importsimport { ExpressInstrumentation } from '@opentelemetry/instrumentation-express'import { HttpInstrumentation } from '@opentelemetry/instrumentation-http'// Register your auto-instrumentorsregisterInstrumentations({  tracerProvider: provider,  instrumentations: [    new HttpInstrumentation(),    new ExpressInstrumentation(),    new PrismaInstrumentation(),  ],})\n```\n\nFor a full list of available instrumentation, take a look at the [OpenTelemetry Registry](https://opentelemetry.io/registry/?language=js&component=instrumentation).\n\n### Customize resource attributes[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#customize-resource-attributes \"Direct link to Customize resource attributes\")\n\nYou can adjust how your application's traces are grouped by changing the resource attributes to be more specific to your application:\n\n```\nconst provider = new NodeTracerProvider({  resource: new Resource({    [SemanticResourceAttributes.SERVICE_NAME]: 'weblog',    [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0',  }),})\n```\n\nThere is an ongoing effort to standardize common resource attributes. Whenever possible, it's a good idea to follow the [standard attribute names](https://github.com/open-telemetry/semantic-conventions/blob/main/docs/general/trace.md).\n\n### Reduce performance impact[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#reduce-performance-impact \"Direct link to Reduce performance impact\")\n\nIf your application sends a large number of spans to a collector, this can have a significant performance impact. You can use the following approaches to reduce this impact:\n\n*   [Use the BatchSpanProcessor](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#send-traces-in-batches-using-the-batchspanprocessor)\n*   [Send fewer spans to the collector](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#send-fewer-spans-to-the-collector-with-sampling)\n\n#### Send traces in batches using the `BatchSpanProcessor`[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#send-traces-in-batches-using-the-batchspanprocessor \"Direct link to send-traces-in-batches-using-the-batchspanprocessor\")\n\nIn a production environment, you can use OpenTelemetry's `BatchSpanProcessor` to send the spans to a collector in batches rather than one at a time. However, during development and testing, you might not want to send spans in batches. In this situation, you might prefer to use the `SimpleSpanProcessor`.\n\nYou can configure your tracing configuration to use the appropriate span processor, depending on the environment, as follows:\n\n```\nimport {  SimpleSpanProcessor,  BatchSpanProcessor,} from '@opentelemetry/sdk-trace-base'if (process.env.NODE_ENV === 'production') {  provider.addSpanProcessor(new BatchSpanProcessor(otlpTraceExporter))} else {  provider.addSpanProcessor(new SimpleSpanProcessor(otlpTraceExporter))}\n```\n\n#### Send fewer spans to the collector with sampling[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#send-fewer-spans-to-the-collector-with-sampling \"Direct link to Send fewer spans to the collector with sampling\")\n\nAnother way to reduce the performance impact is to [use probability sampling](https://opentelemetry.io/docs/reference/specification/trace/tracestate-probability-sampling/) to send fewer spans to the collector. This reduces the collection cost of tracing but still gives a good representation of what is happening in your application.\n\nAn example implementation looks like this:\n\n```\nimport { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'import { NodeTracerProvider } from '@opentelemetry/sdk-trace-node'import { TraceIdRatioBasedSampler } from '@opentelemetry/core'import { Resource } from '@opentelemetry/resources'const provider = new NodeTracerProvider({  sampler: new TraceIdRatioBasedSampler(0.1),  resource: new Resource({    // we can define some metadata about the trace resource    [SemanticResourceAttributes.SERVICE_NAME]: 'test-tracing-service',    [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0',  }),})\n```\n\n## Troubleshoot tracing[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#troubleshoot-tracing \"Direct link to Troubleshoot tracing\")\n\n### My traces aren't showing up[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#my-traces-arent-showing-up \"Direct link to My traces aren't showing up\")\n\nThe order in which you set up tracing matters. In your application, ensure that you register tracing and instrumentation before you import any instrumented dependencies. For example:\n\n```\nimport { registerTracing } from './tracing'registerTracing({  name: 'tracing-example',  version: '0.0.1',})// You must import any dependencies after you register tracing.import { PrismaClient } from '@prisma/client'import async from 'express-async-handler'import express from 'express'\n```\n\n### Child traces start before parent traces[​](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/opentelemetry-tracing#child-traces-start-before-parent-traces \"Direct link to Child traces start before parent traces\")\n\nWe're still investigating [this issue](https://github.com/prisma/prisma/issues/14612).",
    "title": "OpenTelemetry tracing (Preview) | Prisma Documentation",
    "description": "Diagnose application performance with detailed traces of each query.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-types",
    "markdown": "# Native database types | Prisma Documentation\n\nPrisma Migrate translates the model defined in your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) into features in your database.\n\n![A diagram that shows a Prisma schema on the left (labeled: Prisma schema, models) and a database on the right (labeled: Database, tables). Two parallel arrows connect the schema and the database, showing how &#39;@unique&#39; maps to &#39;UNIQUE&#39; and &#39;@id&#39; maps to &#39;PRIMARY KEY&#39;.](https://www.prisma.io/docs/assets/images/migrate-mapping-d1c693b64cc2e6b257b91a819e91222a.png)\n\nEvery¹ feature in your [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) maps to a corresponding feature in the underlying database. **If you can define a feature in the Prisma schema, it is supported by Prisma Migrate.**\n\nFor a complete list of Prisma schema features, refer to:\n\n*   [Database features matrix](https://www.prisma.io/docs/orm/reference/database-features) for a list of database features and what they map to in the Prisma schema.\n*   [Prisma schema reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference) for a list of all Prisma schema features, including field types, attributes, and functions.\n\nPrisma Migrate also supports mapping each field to a [specific native type](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-types#mapping-fields-to-a-specific-native-type), and there are ways to [include features without a Prisma schema equivalent in your database](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-types#handling-unsupported-database-features).\n\nnote\n\nComments and Prisma ORM-level functions (`uuid()` and `cuid()`) do not map to database features.\n\n## Mapping fields to a specific native type[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-types#mapping-fields-to-a-specific-native-type \"Direct link to Mapping fields to a specific native type\")\n\nEach Prisma ORM type maps to a default underlying database type - for example, the PostgreSQL connector maps `String` to `text` by default. [Native database type attributes](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#native-types-mapping) determines which _specific_ native type should be created in the database.\n\ninfo\n\n**Note**: Some Prisma ORM types only map to a single native type.\n\nIn the following example, the `name` and `title` fields have a `@db.VarChar(X)` type attribute:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model User {  id    Int    @id @default(autoincrement())  name  String @db.VarChar(200)  posts Post[]}model Post {  id        Int     @id @default(autoincrement())  title     String  @db.VarChar(150)  published Boolean @default(true)  authorId  Int  author    User    @relation(fields: [authorId], references: [id])}\n```\n\nPrisma Migrate uses the specified types when it creates a migration:\n\n```\n  -- CreateTableCREATE TABLE \"User\" (    \"id\" SERIAL,    \"name\" VARCHAR(200) NOT NULL,    PRIMARY KEY (\"id\"));  -- CreateTableCREATE TABLE \"Post\" (    \"id\" SERIAL,    \"title\" VARCHAR(150) NOT NULL,    \"published\" BOOLEAN NOT NULL DEFAULT true,    \"authorId\" INTEGER NOT NULL,    PRIMARY KEY (\"id\"));  -- AddForeignKeyALTER TABLE \"Post\" ADD FOREIGN KEY(\"authorId\")REFERENCES \"User\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;\n```\n\n### Mappings by Prisma ORM type[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-types#mappings-by-prisma-orm-type \"Direct link to Mappings by Prisma ORM type\")\n\nFor type mappings organized by Prisma ORM type, refer to the [Prisma schema reference](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-field-scalar-types) documentation.\n\n### Mappings by database provider[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-types#mappings-by-database-provider \"Direct link to Mappings by database provider\")\n\nFor type mappings organized by database provider, see:\n\n*   [PostgreSQL mappings](https://www.prisma.io/docs/orm/overview/databases/postgresql#type-mapping-between-postgresql-and-prisma-schema)\n*   [MySQL mappings](https://www.prisma.io/docs/orm/overview/databases/mysql#native-type-mappings)\n*   [Microsoft SQL Server mappings](https://www.prisma.io/docs/orm/overview/databases/sql-server#type-mapping-between-microsoft-sql-server-to-prisma-schema)\n*   [SQLite mappings](https://www.prisma.io/docs/orm/overview/databases/sqlite#type-mapping-between-sqlite-to-prisma-schema)\n\n## Handling unsupported database features[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-types#handling-unsupported-database-features \"Direct link to Handling unsupported database features\")\n\nPrisma Migrate cannot automatically create database features that have no equivalent in Prisma Schema Language (PSL). For example, there is currently no way to define a stored procedure or a partial index in PSL. However, there are ways to add unsupported features to your database with Prisma Migrate:\n\n*   [Handle unsupported field types](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#unsupported-field-types) (like `circle`)\n*   [Handle unsupported features](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#unsupported-database-features), like stored procedures\n*   [How to use native database functions](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#native-database-functions)",
    "title": "Native database types | Prisma Documentation",
    "description": "Native database types",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/migration-histories",
    "markdown": "# About migration histories | Prisma Documentation\n\nThis page explains how Prisma ORM uses migration histories to track changes to your schema.\n\n## Migration history[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/migration-histories#migration-history \"Direct link to Migration history\")\n\nYour migration history is the story of the changes to your data model, and is represented by:\n\n*   A `prisma/migrations` folder with a sub-folder and `migration.sql` file for each migration:\n    \n    ```\n    migrations/  └─ 20210313140442_init/    └─ migration.sql  └─ 20210313140442_added_job_title/    └─ migration.sql\n    ```\n    \n    The `migrations` folder is the **source of truth** for the history of your data model.\n    \n*   A `_prisma_migrations` table in the database, which is used to check:\n    \n    *   If a migration was run against the database\n    *   If an applied migration was deleted\n    *   If an applied migration was changed\n    \n    If you change or delete a migration (**not** recommended), the next steps depend on whether you are in a [development environment](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#development-environments) (and therefore using `migrate dev`) or a [production / testing environment](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#production-and-testing-environments) (and therefore using `migrate deploy`).\n    \n\n### Do not edit or delete migrations that have been applied[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/migration-histories#do-not-edit-or-delete-migrations-that-have-been-applied \"Direct link to Do not edit or delete migrations that have been applied\")\n\nIn general, you **should not edit or delete** a migration that has already been applied. Doing so can lead to inconsistencies between development and production environment migration histories, which may have unforeseen consequences - even if the change does not _appear_ to break anything at first.\n\nThe following scenario simulates a change that creates a seemingly harmless inconsistency:\n\n1.  Modify an **existing migration** that has **already been applied** in a development environment by changing the value of `VARCHAR(550)` to `VARCHAR(560)`:\n    \n    ./prisma/migrations/20210310143435\\_default\\_value/migrations.sql\n    \n    ```\n      -- AlterTable ALTER TABLE \"Post\" ALTER COLUMN \"content\" SET DATA TYPE VARCHAR(560);\n    ```\n    \n    After making this change, the end state of the migration history no longer matches the Prisma schema, which still has `@db.VarChar(550)`.\n    \n2.  Run `prisma migrate dev` - Prisma Migrate detects that a migration has changed, and asks to `reset` the database:\n    \n    ```\n    ? The migration `20210310143435_change_type` was modified after it was applied. We need to reset the PostgreSQL database \"migrate-example\" at \"localhost:5432\". Do you want to continue? All data will be lost. » (y/N)\n    ```\n    \n3.  If you accept resetting, Prisma Migrate resets the database and replays all migrations, including the migration you edited.\n    \n4.  After applying all existing migrations, Prisma Migrate compares the end state of the migration history to the Prisma schema and detects a discrepancy:\n    \n    *   Prisma schema has `@db.VarChar(550)`\n    *   Database schema has `VARCHAR(560)`\n5.  Prisma Migrate generates a new migration to change the value back to `550`, because the end state of the migration history should match the Prisma schema.\n    \n6.  From now on, when you use `prisma migrate deploy` to deploy migrations to production and test environments, Prisma Migrate will always **warn you** that migration histories do not match (and continue to warn you each time you run the command ) - even though the schema end states match:\n    \n    ```\n    6 migrations found in prisma/migrationsWARNING The following migrations have been modified since they were applied:20210310143435_change_type\n    ```\n    \n\nA change that does not appear to break anything after a `migrate reset` can hide problems - you may end up with a bug in production that you cannot replicate in development, or the other way around - particularly if the change concerns a highly customized migration.\n\nIf Prisma Migrate reports a missing or edited migration that has already been applied, we recommend fixing the **root cause** (restoring the file or reverting the change) rather than resetting.\n\n### Committing the migration history to source control[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/migration-histories#committing-the-migration-history-to-source-control \"Direct link to Committing the migration history to source control\")\n\nYou must commit the entire `prisma/migrations` folder to source control. This includes the `prisma/migrations/migration_lock.toml` file, which is used to detect if you have [attempted to change providers](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/limitations-and-known-issues#you-cannot-automatically-switch-database-providers).\n\nSource-controlling the `schema.prisma` file is not enough - you must include your migration history. This is because:\n\n*   As you start to [customize migrations](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#customizing-migrations), your migration history contains **information that cannot be represented in the Prisma schema**. For example, you can customize a migration to mitigate data loss that would be caused by a breaking change.\n*   The `prisma migrate deploy` command, which is used to deploy changes to staging, testing, and production environments, _only_ runs migration files. It does not use the Prisma schema to fetch the models.",
    "title": "About migration histories | Prisma Documentation",
    "description": "About migration histories",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/unsupported-database-features",
    "markdown": "# Prisma Migrate: Unsupported database features\n\nOpen the generated `migration.sql` file and add the unsupported feature - for example, a partial index:\n\n```\nCREATE UNIQUE INDEX tests_success_constraint  ON posts (subject, target)  WHERE success;\n```",
    "title": "Prisma Migrate: Unsupported database features | Prisma Documentation",
    "description": "How to include unsupported database features for projects that use Prisma Migrate.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production",
    "markdown": "# Development and production | Prisma Documentation\n\nThis page explains how to use Prisma Migrate commands in development and production environments.\n\n## Development environments[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#development-environments \"Direct link to Development environments\")\n\nIn a development environment, use the `migrate dev` command to generate and apply migrations:\n\n### Create and apply migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#create-and-apply-migrations \"Direct link to Create and apply migrations\")\n\ndanger\n\n`migrate dev` is a development command and should never be used in a production environment.\n\nThis command:\n\n1.  Reruns the existing migration history in the [shadow database](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database) in order to detect schema drift (edited or deleted migration file, or a manual changes to the database schema)\n2.  Applies pending migrations to the shadow database (for example, new migrations created by colleagues)\n3.  If it detects changes to the Prisma schema, it generates a new migration from these changes\n4.  Applies all unapplied migrations to the development database and updates the `_prisma_migrations` table\n5.  Triggers the generation of artifacts (for example, Prisma Client)\n\nThe `migrate dev` command will prompt you to reset the database in the following scenarios:\n\n*   Migration history conflicts caused by [modified or missing migrations](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/migration-histories#do-not-edit-or-delete-migrations-that-have-been-applied)\n*   The database schema has drifted away from the end-state of the migration history\n\n### Reset the development database[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#reset-the-development-database \"Direct link to Reset the development database\")\n\nYou can also `reset` the database yourself to undo manual changes or `db push` experiments by running:\n\nwarning\n\n`migrate reset` is a development command and should never be used in a production environment.\n\nThis command:\n\n1.  Drops the database/schema¹ if possible, or performs a soft reset if the environment does not allow deleting databases/schemas¹\n2.  Creates a new database/schema¹ with the same name if the database/schema¹ was dropped\n3.  Applies all migrations\n4.  Runs seed scripts\n\n¹ For MySQL and MongoDB this refers to the database, for PostgreSQL and SQL Server to the schema, and for SQLite to the database file.\n\n> **Note**: For a simple and integrated way to re-create data in your development database as often as needed, check out our [seeding guide](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding).\n\n### Customizing migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#customizing-migrations \"Direct link to Customizing migrations\")\n\nSometimes, you need to modify a migration **before applying it**. For example:\n\n*   You want to introduce a significant refactor, such as changing blog post tags from a `String[]` to a `Tag[]`\n*   You want to [rename a field](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations#example-rename-a-field) (by default, Prisma Migrate will drop the existing field)\n*   You want to [change the direction of a 1-1 relationship](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations#example-change-the-direction-of-a-1-1-relation)\n*   You want to add features that cannot be represented in Prisma Schema Language - such as a partial index or a stored procedure.\n\nThe `--create-only` command allows you to create a migration without applying it:\n\n```\nnpx prisma migrate dev --create-only\n```\n\nTo apply the edited migration, run `prisma migrate dev` again.\n\nRefer to [Customizing migrations](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations) for examples.\n\n### Team development[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#team-development \"Direct link to Team development\")\n\nSee: [Team development with Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate/workflows/team-development) .\n\n## Production and testing environments[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#production-and-testing-environments \"Direct link to Production and testing environments\")\n\nIn production and testing environments, use the `migrate deploy` command to apply migrations:\n\n```\nnpx prisma migrate deploy\n```\n\n> **Note**: `migrate deploy` should generally be part of an automated CI/CD pipeline, and we do not recommend running this command locally to deploy changes to a production database.\n\nThis command:\n\n1.  Compares applied migrations against the migration history and **warns** if any migrations have been modified:\n    \n    ```\n    WARNING The following migrations have been modified since they were applied:20210313140442_favorite_colors\n    ```\n    \n2.  Applies pending migrations\n    \n\nThe `migrate deploy` command:\n\n*   **Does not** issue a warning if an already applied migration is _missing_ from migration history\n*   **Does not** detect drift (production database schema differs from migration history end state - for example, due to a hotfix\n*   **Does not** reset the database or generate artifacts (such as Prisma Client)\n*   **Does not** rely on a shadow database\n\nSee also:\n\n*   [Prisma Migrate in deployment](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-database-changes-with-prisma-migrate)\n*   [Production troubleshooting](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing)\n\n### Advisory locking[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/development-and-production#advisory-locking \"Direct link to Advisory locking\")\n\nPrisma Migrate makes use of advisory locking when you run production commands such as:\n\n*   `prisma migrate deploy`\n*   `prisma migrate dev`\n*   `prisma migrate resolve`\n\nThis safeguard ensures that multiple commands cannot run at the same time - for example, if you merge two pull requests in quick succession.\n\nAdvisory locking has a **10 second timeout** (not configurable), and uses the default advisory locking mechanism available in the underlying provider:\n\n*   [PostgreSQL](https://www.postgresql.org/docs/9.4/explicit-locking.html#ADVISORY-LOCKS)\n*   [MySQL](https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html)\n*   [Microsoft SQL server](https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql?view=sql-server-ver15)\n\nPrisma Migrate's implementation of advisory locking is purely to avoid catastrophic errors - if your command times out, you will need to run it again.\n\nSince `5.3.0`, the advisory locking can be disabled using the [`PRISMA_SCHEMA_DISABLE_ADVISORY_LOCK` environment variable](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_schema_disable_advisory_lock)",
    "title": "Development and production | Prisma Documentation",
    "description": "Development and production",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/overview",
    "markdown": "# Prisma Migrate Overview | Prisma Documentation\n\nIf you are prototyping, consider using the [`db push`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-push) command - see [Schema prototyping with `db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) for examples.",
    "title": "Prisma Migrate Overview | Prisma Documentation",
    "description": "Learn everything you need to know about Prisma Migrate.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model",
    "markdown": "# A mental model for Prisma Migrate\n\nThis guide provides a conceptual overview of database migrations using Prisma Migrate when working with relational databases. It covers: what database migrations are, their value, and what Prisma Migrate is and how you can evolve your database schema with Prisma Migrate in different environments.\n\n**If you are working with MongoDB, use `prisma db push` to evolve your schema.**\n\n## What are database migrations?[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#what-are-database-migrations \"Direct link to What are database migrations?\")\n\nDatabase migrations are a controlled set of changes that modify and evolve the structure of your database schema. Migrations help you transition your database schema from one state to another. For example, within a migration you can create or remove tables and columns, split fields in a table, or add types and constraints to your database.\n\n### Patterns for evolving database schemas[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#patterns-for-evolving-database-schemas \"Direct link to Patterns for evolving database schemas\")\n\nThis section describes general schema migration patterns for evolving database schemas.\n\nThe two main schema migration patterns are:\n\n*   **Model/Entity-first migration:** with this pattern, you define the structure of the database schema with code and then use a migration tool to generate the SQL, for example, for syncing your application and database schema.\n\n![](https://www.prisma.io/docs/assets/images/entity-first-migration-flow-d2d31eba03a45b765903b594c1843d5a.png)\n\n*   **Database-first migration:** with this pattern, you define the structure of your database and apply it to your database using SQL. You then _introspect_ the database to generate the code that describes the structure of your database to sync your application and database schema.\n\n![](https://www.prisma.io/docs/assets/images/database-first-migration-flow-6ec968ed5262eaa3e641a2a112fcd302.png)\n\ninfo\n\n**Note**\n\nFor simplicity, we chose the terminology above to describe the different patterns for evolving database schemas. Other tools and libraries may use different terminology to describe the different patterns.\n\nThe migration files (SQL) should ideally be stored together with your application code. They should also be tracked in version control and shared with the rest of the team working on the application.\n\nMigrations provide _state management_ which helps you to track the state of the database.\n\nMigrations also allow you to replicate the state of a database at a specific point in time which is useful when collaborating with other members of the team, e.g. switching between different branches.\n\nFor further information on database migrations, see the [Prisma Data Guide](https://www.prisma.io/dataguide/types/relational/what-are-database-migrations).\n\n## What is Prisma Migrate?[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#what-is-prisma-migrate \"Direct link to What is Prisma Migrate?\")\n\nPrisma Migrate is a database migration tool that supports the _model/ entity-first_ migration pattern to manage database schemas in your local environment and in production.\n\nThe workflow when using Prisma Migrate in your project would be iterative and look like this:\n\n**Local development environment (Feature branch)**\n\n1.  Evolve your Prisma schema\n2.  Use either [`prisma migrate dev`](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#track-your-migration-history-with-prisma-migrate-dev) or [`prisma db push`](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#prototype-your-schema) to sync your Prisma schema with the database schema of your local development database\n\n**Preview/ staging environment(Feature pull request)**\n\n1.  Push your changes to the feature pull request\n2.  Use a CI system (e.g. GitHub Actions) to sync your Prisma schema and migration history with your preview database using `prisma migrate deploy`\n\n**Production (main branch)**\n\n1.  Merge your application code from the feature branch to your main branch\n2.  Use a CI system (e.g. GitHub Actions) to sync your Prisma schema and migration history with your production database using `prisma migrate deploy`\n\n![Prisma Migrate workflow](https://www.prisma.io/docs/assets/images/prisma-migrate-lifecycle-225cf148241db936bf0ea6881386bebc.png)\n\n## How Prisma Migrate tracks the migration state[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#how-prisma-migrate-tracks-the-migration-state \"Direct link to How Prisma Migrate tracks the migration state\")\n\nPrisma Migrate uses the following pieces of state to track the state of your database schema:\n\n*   **Prisma schema**: your source of truth that defines the structure of the database schema.\n*   **Migrations history**: SQL files in your `prisma/migrations` folder representing the history of changes made to your database schema.\n*   **Migrations table**: `prisma_migrations` table in the database that stores metadata for migrations that have been applied to the database.\n*   **Database schema**: the state of the database.\n\n![Prisma Migrate &quot;state management&quot;](https://www.prisma.io/docs/assets/images/prisma-migrate-state-mgt-a377a1cce06f4984bce812a2703b337f.png)\n\n## Requirements when working with Prisma Migrate[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#requirements-when-working-with-prisma-migrate \"Direct link to Requirements when working with Prisma Migrate\")\n\n*   Ideally, you should use one database per environment. For example, you might have a separate database for development, preview, and production environments.\n*   The databases you use in development environments are disposable — you can easily create, use, and delete databases on demand.\n*   The database configuration used in each environments should be consistent. This is important to ensure a certain migration that moves across the workflow yields the same changes to the database.\n*   The Prisma schema serves as the source of truth — describing the shape of your [database schema](https://www.prisma.io/dataguide/intro/database-glossary#schema).\n\n## Evolve your database schema with Prisma Migrate[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#evolve-your-database-schema-with-prisma-migrate \"Direct link to Evolve your database schema with Prisma Migrate\")\n\nThis section describes how you can evolve your database schema in different environments: development, staging, and production, using Prisma Migrate.\n\n### Prisma Migrate in a development environment (local)[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#prisma-migrate-in-a-development-environment-local \"Direct link to Prisma Migrate in a development environment (local)\")\n\n#### Track your migration history with `prisma migrate dev`[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#track-your-migration-history-with-prisma-migrate-dev \"Direct link to track-your-migration-history-with-prisma-migrate-dev\")\n\nThe [`prisma migrate dev`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-dev) command allows you to track the changes you make to your database. The `prisma migrate dev` command automatically generates SQL migration files (saved in `/prisma/migrations`) and applies them to the database. When a migration is applied to the database, the migrations table (`_prisma_migrations`) in your database is also updated.\n\n![Prisma Migrate dev flow](https://www.prisma.io/docs/assets/images/prisma-migrate-dev-flow-076cfcd29315434300c48d787976cd7d.png)\n\nThe `prisma migrate dev` command tracks the state of the database using the following pieces of state:\n\n*   the Prisma schema\n*   the migrations history\n*   the migrations table\n*   the database schema\n\n> **Note**: The pieces of state used to track the state of a migration are the same as the ones described in [how Prisma Migrate tracks the migration state](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#how-prisma-migrate-tracks-the-migration-state) section.\n\nYou can customize migrations before you apply them to the database using the `--create-only` flag. For example, you might want to edit a migration if you want to rename columns without incurring any data loss or load database extensions (in PostgreSQL) and database views (currently not supported).\n\nUnder the hood, Prisma Migrate uses a [shadow database](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database) to detect a [schema drift](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database#detecting-schema-drift) and generate new migrations.\n\n> **Note**: `prisma migrate dev` is intended to be used only in development with a disposable database.\n\nIf `prisma migrate dev` detects a schema drift or a migration history conflict, you will be prompted to reset (drop and recreate your database) your database to sync the migration history and the database schema.\n\nExpand to see the shadow database explained using a cartoon\n\n![A cartoon that shows how the shadow database works.](https://www.prisma.io/docs/assets/images/shadow-database-4851f4376ca80c1b94316445aa5bd85b.png)\n\n#### Resolve schema drifts[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#resolve-schema-drifts \"Direct link to Resolve schema drifts\")\n\nA schema drift occurs when the expected database schema is different from what is in the migration history. For example, this can occur when you manually update the database schema without also updating the Prisma schema and `prisma/migrations` accordingly.\n\nFor such instances, you can use the [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) command to compare your migration history and revert changes made to your database schema.\n\n![Revert database schema with migrate diff](https://www.prisma.io/docs/assets/images/prisma-migrate-diff-flow-53e656b8f5bffc7e0671d731ab62dd71.png)\n\nYou can use `migrate diff` to generate the SQL that either:\n\n*   Reverts the changes made in the database schema to synchronize it with the current Prisma schema\n*   Moves your database schema forward to apply missing changes from the Prisma schema and `/migrations`\n\nYou can then apply the changes to your database using [`prisma db execute`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-execute) command.\n\n#### Prototype your schema[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#prototype-your-schema \"Direct link to Prototype your schema\")\n\nThe [`prisma db push`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-push) command allows you to sync your Prisma schema and database schema without persisting a migration (`/prisma/migrations`). The `prisma db push` command tracks the state of the database using the following pieces of state:\n\n*   the Prisma schema\n*   the database schema\n\n![prisma db push development flow](https://www.prisma.io/docs/assets/images/db-push-flow-c49fec8bea7946eb7e54b297862bf3ec.png)\n\nThe `prisma db push` command is useful when:\n\n*   You want to **quickly prototype and iterate** on schema design locally without the need to deploy these changes to other environments such as other developers, or staging and production environments.\n*   You are prioritizing reaching a **desired end-state** and not the changes or steps executed to reach that end-state (there is no way to preview changes made by `prisma db push`)\n*   You do not need to control how schema changes impact data. There is no way to orchestrate schema and data migrations - if `prisma db push` anticipates that changes will result in data loss, you can either accept data loss with the `--accept-data-loss` option or stop the process - there is no way to customize the changes.\n\nIf the `prisma db push` command detects destructive change to your database schema, it will prompt you to reset your database. For example, this will happen when you add a required field to a table with existing content without providing a default value.\n\n> A [schema drift](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting#schema-drift) occurs when your database schema is out of sync with your migrations history and migrations table.\n\n### Prisma Migrate in a staging and production environment[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#prisma-migrate-in-a-staging-and-production-environment \"Direct link to Prisma Migrate in a staging and production environment\")\n\n#### Sync your migration histories[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/mental-model#sync-your-migration-histories \"Direct link to Sync your migration histories\")\n\nThe [`prisma migrate deploy`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-deploy) command allows you to sync your migration history from your development environment with your database in your **staging or production environment**.\n\nUnder the hood, the `migrate deploy` command:\n\n1.  Compares already applied migrations (captured `_prisma_migrations`) and the migration history (`/prisma/migrations`)\n2.  Applies pending migrations\n3.  Updates `_prisma_migrations` table with the new migrations\n\n![](https://www.prisma.io/docs/assets/images/deploy-db-a1c7d74dc72a5747302de25b889a841c.png)\n\nThe command should be run in an automated CI/ CD environment, for example GitHub Actions.\n\nIf you don't have a migration history (`/migrations`), i.e using `prisma db push`, you will have to continue using `prisma db push` in your staging and production environments. Beware of the changes being applied to the database schema as some of them might be destructive. For example, `prisma db push` can't tell when you're performing a column rename. It will prompt a database reset (drop and re-creation).",
    "title": "A mental model for Prisma Migrate | Prisma Documentation",
    "description": "A mental model guide for working with Prisma Migrate in your project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/baselining",
    "markdown": "# Baselining a database | Prisma Documentation\n\nBaselining is the process of initializing a migration history for a database that:\n\n*   ✔ Existed before you started using Prisma Migrate\n*   ✔ Contains data that must be maintained (like production), which means that the database cannot be reset\n\nBaselining tells Prisma Migrate to assume that one or more migrations have **already been applied**. This prevents generated migrations from failing when they try to create tables and fields that already exist.\n\n> **Note**: We assume it is acceptable to reset and seed development databases.\n\nBaselining is part of [adding Prisma Migrate to a project with an existing database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started#adding-prisma-migrate-to-an-existing-project).\n\nwarning\n\nThis guide **does not apply for MongoDB**.  \nInstead of `migrate deploy`, [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) is used for [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb).\n\n## Why you need to baseline[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/baselining#why-you-need-to-baseline \"Direct link to Why you need to baseline\")\n\nWhen you add Prisma Migrate to an existing project, your initial migration contains all the SQL required to recreate the state of the database **before you started using Prisma Migrate**:\n\n![The image shows a database labelled &#39;Existing database&#39;, and a list of existing database features next to it - 24 tables, 13 relationships, 92 fields, 3 indexes. An arrow labelled &#39;represented by&#39; connects the database features list to a box that represents a migration. The existing databases&#39;s features are represented by a single migration.](https://www.prisma.io/docs/assets/images/existing-database-eaef7f777eb29e4ba0b77619ea01c71f.png)\n\ntip\n\nYou can edit the initial migration to include schema elements that cannot be represented in the Prisma schema - such as stored procedures or triggers.\n\nYou need this initial migration to create and reset **development environments**:\n\n![The image shows a migration history with three migrations. Each migration is represented by a file icon and a name, and all migrations are surrounded by a box labelled &#39;migration history&#39;. The first migration has an additional label: &quot;State of database before Prisma Migrate&quot;, and the two remaining migrations are labelled &quot;Generated as part of the Prisma Migrate workflow&quot;. An arrow labelled &quot;prisma migrate dev&quot; connects the migration history box to a database labelled &quot;new development database&quot;, signifying that all three migrations are applied to the development database - none are skipped.](https://www.prisma.io/docs/assets/images/new-dev-db-b89310002ec33e9e149cf0c142246ca7.png)\n\nHowever, when you `prisma migrate deploy` your migrations to databases that already exist and _cannot_ be reset - such as production - you **do not want to include the initial migrations**.\n\nThe target database already contains the tables and columns created by the initial migration, and attempting to create these elements again will most likely result in an error.\n\n![A migration history represented by three migration files (file icon and name), surrounded by a a box labelled &#39;migration history&#39;. The first migration is marked &#39;do not apply&#39;, and the second two migrations are marked &#39;apply&#39;. An arrow labelled with the command &#39;prisma migrate deploy&#39; points from the migration history to a database labelled &#39;production&#39;.](https://www.prisma.io/docs/assets/images/deploy-db-a1c7d74dc72a5747302de25b889a841c.png)\n\nBaselining solves this problem by telling Prisma Migrate to pretend that the initial migration(s) **have already been applied**.\n\n## Baselining a database[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/baselining#baselining-a-database \"Direct link to Baselining a database\")\n\nTo create a baseline migration:\n\n1.  If you have a `prisma/migrations` folder, delete, move, rename, or archive this folder.\n    \n2.  Run the following command to create a `migrations` directory inside with your preferred name. This example will use `0_init` for the migration name:\n    \n    ```\n    mkdir -p prisma/migrations/0_init\n    ```\n    \n    info\n    \n    Then `0_` is important because Prisma Migrate applies migrations in a [lexicographic order](https://en.wikipedia.org/wiki/Lexicographic_order). You can use a different value such as the current timestamp.\n    \n3.  Generate a migration and save it to a file using `prisma migrate diff`\n    \n    ```\n    npx prisma migrate diff \\--from-empty \\--to-schema-datamodel prisma/schema.prisma \\--script > prisma/migrations/0_init/migration.sql\n    ```\n    \n4.  Run the `prisma migrate resolve` command for each migration that should be ignored:\n    \n    ```\n    npx prisma migrate resolve --applied 0_init\n    ```\n    \n\nThis command adds the target migration to the `_prisma_migrations` table and marks it as applied. When you run `prisma migrate deploy` to apply new migrations, Prisma Migrate:\n\n1.  Skips all migrations marked as 'applied', including the baseline migration\n2.  Applies any new migrations that come _after_ the baseline migration",
    "title": "Baselining a database | Prisma Documentation",
    "description": "How to initialize a migration history for an existing database that contains important data.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/limitations-and-known-issues",
    "markdown": "# Limitations and known issues | Prisma Documentation\n\nThe following limitations apply to Prisma Migrate.\n\n## MongoDB connector not supported[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/limitations-and-known-issues#mongodb-connector-not-supported \"Direct link to MongoDB connector not supported\")\n\nPrisma Migrate does not currently support the MongoDB connector.\n\n## You cannot automatically switch database providers[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/limitations-and-known-issues#you-cannot-automatically-switch-database-providers \"Direct link to You cannot automatically switch database providers\")\n\nPrisma Migrate generates SQL files that are specific to your provider. This means that you cannot use the same migration files for PostgreSQL in production and SQLite in development, because the syntax in the migrations will be incompatible.\n\nIn [2.15.0](https://github.com/prisma/prisma/releases/2.15.0) and later, Prisma Migrate detects when the migrations do not match the configured provider and prints a helpful error message. For example, if your migrations are for a PostgreSQL database but you are using a `provider` is set to `mysql`:\n\n```\nError: P3014The datasource provider `postgresql` specified in your schema does not match the one specified in the migration_lock.toml, mysql. Please remove your current migration directory and start a new migration history with prisma migrate dev.\n```\n\nIn order to manually switch the database provider, you must:\n\n*   Change the `provider` and `url` parameters in the `datasource` block in your schema\n*   Archive or remove your existing migration history - there must not be a `./prisma/migrations` folder\n*   Run `prisma migrate dev` to start a new migration history\n\nThe last step creates a new initial migration that goes from an empty database to your current `schema.prisma`. Be aware that:\n\n*   This migration will _only_ contain what is reflected in your `schema.prisma`. If you manually edited your previous migration files to add custom SQL you will need to again add this yourself.\n*   The newly created database using the new provider will not contain any data.\n\n## Data loss when resetting database[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/limitations-and-known-issues#data-loss-when-resetting-database \"Direct link to Data loss when resetting database\")\n\nIn a development environment, Prisma Migrate sometimes prompts you to reset the database. Resetting drops and recreates the database, which results in data loss. The database is reset when:\n\n*   You call `prisma migrate reset` explicitly\n*   You call `prisma migrate dev` and Prisma Migrate detects drift in the database or a migration history conflict\n\nThe `prisma migrate dev` and `prisma migrate reset` commands are designed to be used **in development only**, and should not affect production data.\n\nWhen the database is reset, if Prisma Migrate detects a seed script in `package.json`, it will trigger seeding.\n\n> **Note**: For a simple and integrated way to re-create data when the database is reset, check out our [seeding guide](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding).\n\n## Prisma Migrate and PgBouncer[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/limitations-and-known-issues#prisma-migrate-and-pgbouncer \"Direct link to Prisma Migrate and PgBouncer\")\n\nYou might see the following error if you attempt to run Prisma Migrate commands in an environment that uses PgBouncer for connection pooling:\n\n```\nError: undefined: Database errorError querying the database: db error: ERROR: prepared statement \"s0\" already exists\n```\n\nSee [Prisma Migrate and PgBouncer workaround](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer) for further information and a workaround. Follow [GitHub issue #6485](https://github.com/prisma/prisma/issues/6485) for updates.\n\n## Prisma Migrate in non-interactive environments[​](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/limitations-and-known-issues#prisma-migrate-in-non-interactive-environments \"Direct link to Prisma Migrate in non-interactive environments\")\n\nPrisma ORM detects when you run CLI commands in non-interactive environments, such as Docker, from Node scripts or in bash shells. When this happens a warning displays, indicating that the environment is non-interactive and the `migrate dev` command is not supported.\n\nTo ensure the Docker environment picks up the command, run the image in `interactive` mode so that it reacts to the `migrate dev` command.\n\n```\ndocker run --interactive --tty <image name># ordocker -it <image name># Example usagedocker run -it node\n```",
    "title": "Limitations and known issues | Prisma Documentation",
    "description": "The following limitations apply to Prisma Migrate.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations",
    "markdown": "# Customizing migrations | Prisma Documentation\n\nwarning\n\nThis guide **does not apply for MongoDB**.  \nInstead of `migrate dev`, [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) is used for [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb).\n\nIn some scenarios, you need to edit a migration file before you apply it. For example, to [change the direction of a 1-1 relation](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations#example-change-the-direction-of-a-1-1-relation) (moving the foreign key from one side to another) without data loss, you need to move data as part of the migration - this SQL is not part of the default migration, and must be written by hand.\n\nThis guide explains how to edit migration files and gives some examples of use cases where you may want to do this.\n\n## How to edit a migration file[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations#how-to-edit-a-migration-file \"Direct link to How to edit a migration file\")\n\nTo edit a migration file before applying it, the general procedure is the following:\n\n1.  Make a schema change that requires custom SQL (for example, to preserve existing data)\n    \n2.  Create a draft migration using:\n    \n    ```\n    npx prisma migrate dev --create-only\n    ```\n    \n3.  Modify the generated SQL file.\n    \n4.  Apply the modified SQL by running:\n    \n\n### Example: Rename a field[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations#example-rename-a-field \"Direct link to Example: Rename a field\")\n\nBy default, renaming a field in the schema results in a migration that will:\n\n*   `CREATE` a new column (for example, `fullname`)\n*   `DROP` the existing column (for example, `name`) and the data in that column\n\nTo actually **rename** a field and avoid data loss when you run the migration in production, you need to modify the generated migration SQL before applying it to the database. Consider the following schema fragment - the `biograpy` field is spelled wrong.\n\n```\nmodel Profile {  id       Int    @id @default(autoincrement())  biograpy String  userId   Int    @unique  user     User   @relation(fields: [userId], references: [id])}\n```\n\nTo rename the `biograpy` field to `biography`:\n\n1.  Rename the field in the schema:\n    \n    ```\n    model Profile {  id        Int    @id @default(autoincrement())  biograpy  String  biography String  userId    Int    @unique  user      User   @relation(fields: [userId], references: [id])}\n    ```\n    \n2.  Run the following command to create a **draft migration** that you can edit before applying to the database:\n    \n    ```\n    npx prisma migrate dev --name rename-migration --create-only\n    ```\n    \n3.  Edit the draft migration as shown, changing `DROP` / `DELETE` to a single `RENAME COLUMN`:\n    \n    *   Before\n    *   After\n    \n    ./prisma/migrations/20210308092620\\_rename\\_migration/migration.sql\n    \n    ```\n    ALTER TABLE \"Profile\" DROP COLUMN \"biograpy\",ADD COLUMN  \"biography\" TEXT NOT NULL;\n    ```\n    \n4.  Save and apply the migration:\n    \n\nYou can use the same technique to rename a `model` - edit the generated SQL to _rename_ the table rather than drop and re-create it.\n\n### Example: Use the expand and contract pattern to evolve the schema without downtime[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations#example-use-the-expand-and-contract-pattern-to-evolve-the-schema-without-downtime \"Direct link to Example: Use the expand and contract pattern to evolve the schema without downtime\")\n\nMaking schema changes to existing fields, e.g., renaming a field can lead to downtime. It happens in the time frame between applying a migration that modifies an existing field, and deploying a new version of the application code which uses the modified field.\n\nYou can prevent downtime by breaking down the steps required to alter a field into a series of discrete steps designed to introduce the change gradually. This pattern is known as the _expand and contract pattern_.\n\nThe pattern involves two components: your application code accessing the database and the database schema you intend to alter.\n\nWith the _expand and contract_ pattern, renaming the field `bio` to `biography` would look as follows with Prisma:\n\n1.  Add the new `biography` field to your Prisma schema and create a migration\n    \n    ```\n    model Profile {  id        Int    @id @default(autoincrement())  bio       String  biography String  userId    Int    @unique  user      User   @relation(fields: [userId], references: [id])}\n    ```\n    \n2.  _Expand_: update the application code and write to both the `bio` and `biography` fields, but continue reading from the `bio` field, and deploy the code\n    \n3.  Create an empty migration and copy existing data from the `bio` to the `biography` field\n    \n    ```\n    npx prisma migrate dev --name copy_biography --create-only\n    ```\n    \n    prisma/migrations/20210420000000\\_copy\\_biography/migration.sql\n    \n    ```\n    UPDATE \"Profile\" SET biography = bio;\n    ```\n    \n4.  Verify the integrity of the `biography` field in the database\n    \n5.  Update application code to **read** from the new `biography` field\n    \n6.  Update application code to **stop writing** to the `bio` field\n    \n7.  _Contract_: remove the `bio` from the Prisma schema, and create a migration to remove the `bio` field\n    \n    ```\n    model Profile {  id        Int    @id @default(autoincrement())  bio       String  biography String  userId    Int    @unique  user      User   @relation(fields: [userId], references: [id])}\n    ```\n    \n    ```\n    npx prisma migrate dev --name remove_bio\n    ```\n    \n\nBy using this approach, you avoid potential downtime that altering existing fields that are used in the application code are prone to, and reduce the amount of coordination required between applying the migration and deploying the updated application code.\n\nNote that this pattern is applicable in any situation involving a change to a column that has data and is in use by the application code. Examples include combining two fields into one, or transforming a `1:n` relation to a `m:n` relation.\n\nTo learn more, check out the Data Guide article on [the expand and contract pattern](https://www.prisma.io/dataguide/types/relational/expand-and-contract-pattern)\n\n### Example: Change the direction of a 1-1 relation[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations#example-change-the-direction-of-a-1-1-relation \"Direct link to Example: Change the direction of a 1-1 relation\")\n\nTo change the direction of a 1-1 relation:\n\n1.  Make the change in the schema:\n    \n    ```\n    model User {  id        Int      @id @default(autoincrement())  name      String  posts     Post[]  profile   Profile? @relation(fields: [profileId], references: [id])  profileId Int      @unique}model Profile {  id        Int    @id @default(autoincrement())  biography String  user      User}\n    ```\n    \n2.  Run the following command to create a **draft migration** that you can edit before applying to the database:\n    \n    ```\n    npx prisma migrate dev --name rename-migration --create-only\n    ```\n    \n3.  Edit the draft migration as shown:\n    \n\n*   Before\n*   After\n\n```\n-- DropForeignKeyALTER TABLE \"Profile\" DROP CONSTRAINT \"Profile_userId_fkey\";-- DropIndexDROP INDEX \"Profile_userId_unique\";-- AlterTableALTER TABLE \"Profile\" DROP COLUMN \"userId\";-- AlterTableALTER TABLE \"User\" ADD COLUMN     \"profileId\" INTEGER NOT NULL;-- CreateIndexCREATE UNIQUE INDEX \"User_profileId_unique\" ON \"User\"(\"profileId\");-- AddForeignKeyALTER TABLE \"User\" ADD FOREIGN KEY (\"profileId\") REFERENCES \"Profile\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;\n```\n\n1.  Save and apply the migration:",
    "title": "Customizing migrations | Prisma Documentation",
    "description": "How to edit a migration file before applying it to avoid data loss in production.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/data-migration",
    "markdown": "# Data migrations | Prisma Documentation\n\nPrisma ORM does not yet natively support data migrations, but you can use the [expand and contract pattern](https://www.prisma.io/dataguide/types/relational/expand-and-contract-pattern) to migrate your data. For example from one column into another.\n\nThis guide covers how you can use Prisma ORM with the expand and contract pattern to:\n\n*   Expand your schema with a new column\n*   Create and run the data migration\n*   Contract your schema by dropping the old column\n\n## Overview of the steps[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/data-migration#overview-of-the-steps \"Direct link to Overview of the steps\")\n\nThis tutorial will walk you through the following steps:\n\n1.  Expand your schema with a new column\n2.  Create and run the data migration file\n3.  Contract your schema by dropping the old column\n\nIt also makes the following assumptions:\n\n*   The production database is accessible from the development machine\n*   `prisma migrate dev` is only run against development database\n*   The expanding and contracting steps are handled in separate branches\n\nFor this guide, you will modify the following schema by replacing the `published` boolean field with a `status` enum:\n\nprisma/schema.prisma\n\n```\ngenerator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)}\n```\n\n## Expand your schema with a new column[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/data-migration#expand-your-schema-with-a-new-column \"Direct link to Expand your schema with a new column\")\n\nCheckout to a new branch from your `main` branch:\n\n```\ngit checkout -b create-status-field\n```\n\nMake the following updates to your Prisma schema:\n\n*   Create a `Status` enum with the following values: `Unknown`, `Draft`, `InReview`, and `Published`\n*   Add a `status` column to the `Post` model\n*   Mark the `published` field as optional\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String  content   String?  published Boolean? @default(false)  status    Status}enum Status {  Unknown  Draft  InProgress  InReview  Published}\n```\n\nCreate a new migration to sync the Prisma schema with the database schema:\n\n```\nnpx prisma migrate dev --name add-status-column\n```\n\nPrisma Migrate will give you the following warning because the field being added to the database is non-nullable, and the database contains existing data which require a default value.\n\n```\nPrisma schema loaded from prisma/schema.prismaDatasource \"db\": PostgreSQL database \"data-migration\", schema \"public\" at \"localhost:5401\"Error:⚠️ We found changes that cannot be executed:  • Step 1 Added the required column `status` to the `Post` table without a default value. There are 4 rows in this table, it is not possible to execute this step.You can use prisma migrate dev --create-only to create the migration file, and manually modify it to address the underlying issue(s).Then run prisma migrate dev to apply it and verify it works.\n```\n\nExit from the migration step and update the schema by adding a default value for the `status` field by adding the `@default()` attribute function.\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String  content   String?  published Boolean? @default(false)  status    Status   @default(Unknown)}enum Status {  Unknown  Draft  InProgress  InReview  Published}\n```\n\nGenerate and execute the migration using the following command:\n\n```\nnpx prisma migrate dev --name add-default\n```\n\n## Create and run the data migration file[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/data-migration#create-and-run-the-data-migration-file \"Direct link to Create and run the data migration file\")\n\n### Create a data migration file[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/data-migration#create-a-data-migration-file \"Direct link to Create a data migration file\")\n\nInside the generated migration folder from the previous step, create a file called `data-migration.ts` file. This file will contain a data migration which will be implemented using Prisma Client.\n\nAdd the following code to migrate the data from the `published` field to the `status` field in the file you just created:\n\nUpdate your `package.json` file to include the data migration file:\n\nprisma/migrations/20230417131956\\_add-status-column/data-migration.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  await prisma.$transaction(async (tx) => {    const posts = await tx.post.findMany()    for (const post of posts) {      await tx.post.update({        where: { id: post.id },        data: {          status: post.published ? 'Published' : 'Unknown',        },      })    }  })}main()  .catch(async (e) => {    console.error(e)    process.exit(1)  })  .finally(async () => await prisma.$disconnect())\n```\n\nThe data migration is wrapped in a transaction to ensure that the query is rolled back, allowing you to iterate on your data migration file\n\nNext steps:\n\n1.  Push your changes to a remote origin and create a new pull request.\n2.  Once you’re happy with the changes, merge the changes to your `main` branch.\n\nTo apply the changes to your production database, add `prisma migrate deploy` as part of your deployment/ build step in CI\n\n### Run the data migration[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/data-migration#run-the-data-migration \"Direct link to Run the data migration\")\n\nUpdate the `package.json` file with the script to execute the data-migration file. Be sure to update the `20230417131956_add-status-column` with the name of your migration file.\n\npackage.json\n\n```\n\"scripts\": {    \"dev\": \"ts-node ./script.ts\",    \"data-migration:add-status-column\": \"ts-node ./prisma/migrations/20230417131956_add-status-column/data-migration.ts\"  },\n```\n\nNext steps:\n\n1.  Push your changes to a remote origin and create a new pull request.\n2.  Once you’re happy with the changes, merge the changes to your “main” branch.\n\nTo apply the changes to your production database, add `prisma migrate deploy` as part of your deployment/ build step in CI.\n\n### Run the data migration[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/data-migration#run-the-data-migration-1 \"Direct link to Run the data migration\")\n\nUpdate the `DATABASE_URL` environment variable with your production database's URL. Run the data migration script:\n\n```\nnpm run data-migration:add-status-column\n```\n\n## Contract your schema by dropping the old column[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/data-migration#contract-your-schema-by-dropping-the-old-column \"Direct link to Contract your schema by dropping the old column\")\n\nCheckout to a separate branch on your development machine:\n\n```\ngit checkout -b drop-published-column\n```\n\nDelete the `published` field from your schema and generate a new migration:\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String  content   String?  published Boolean? @default(false)  status    Status   @default(Unknown)}enum Status {  Draft  InProgress  InReview  Published}\n```\n\nGenerate a new migration:\n\n```\nnpx prisma migrate dev --name drop-published-column\n```\n\nNext steps:\n\n1.  Push your changes to a remote origin and create a new pull request.\n2.  Once you’re happy with the changes, merge the changes to your `main` branch.\n\nTo apply the changes to your production database, add `prisma migrate deploy` as part of your deployment/ build step in CI\n\n```\nnpx prisma migrate deploy\n```\n\nYou have successfully:\n\n*   Migrated data from the `published` to `status` column\n*   Dropped the `published` column from your schema",
    "title": "Data migrations | Prisma Documentation",
    "description": "How to migrate data using Prisma ORM with the expand and contract pattern.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations",
    "markdown": "# Squashing migrations | Prisma Documentation\n\nThis guide describes how to squash multiple [migration files](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/migration-histories) into a single migration.\n\n## About squashing migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#about-squashing-migrations \"Direct link to About squashing migrations\")\n\nIt is sometimes useful to squash either some or all migration files into a single migration. This guide will describe two scenarios where you may want to do this:\n\n*   [Migrating cleanly from a development environment](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#migrating-cleanly-from-a-development-environment) by squashing your local migrations into one before merging\n*   [Creating a clean history in a production environment](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#creating-a-clean-history-in-a-production-environment) by squashing all migrations into a single file\n\nIn both cases, Prisma Migrate provides the tools for doing this, by using the [`migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) command to compare two database schemas and output a single SQL file that takes you from one to the other. The rest of this guide gives detailed instructions on how to carry this out in these two scenarios.\n\n### Migrating cleanly from a development environment[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#migrating-cleanly-from-a-development-environment \"Direct link to Migrating cleanly from a development environment\")\n\nSquashing migrations can be useful when developing with a branch-based workflow. During a large local development effort on a feature branch you might generate multiple migrations using `migrate dev`. After the feature is finished, the migration history might contain unnecessary intermediate steps that are unwanted in the final migration history that will be pushed to the `main` branch.\n\nThere could be important reasons to avoid applying the intermediate steps in production — they might lose data or be extremely slow / disruptive). Even when this is not the case, you may want to avoid clutter in your production environment's migrations history.\n\nFor detailed steps on how to achieve this using `migrate dev`, see the section on [how to migrate cleanly from a development environment](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#how-to-migrate-cleanly-from-a-development-environment).\n\n### Creating a clean history in a production environment[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#creating-a-clean-history-in-a-production-environment \"Direct link to Creating a clean history in a production environment\")\n\nSquashing migrations can also be used in a production environment to squash all migration files into one. This can be useful when the production environment has accumulated a longer migration history, and replaying it in new environments has become a burden due to intermediate steps requiring extra time. Since the team is not deriving value from the migration steps (and could get them back from version control history in a pinch) the decision is made to squash the whole history into a single migration.\n\nFor detailed steps on how to achieve this using `migrate diff` and `migrate resolve` see the section on [how to create a clean history in a production environment](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#how-to-create-a-clean-history-in-a-production-environment).\n\n## Considerations when squashing migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#considerations-when-squashing-migrations \"Direct link to Considerations when squashing migrations\")\n\nwarning\n\nWhen squashing migrations, be aware that any manually changed or added SQL in your `migration.sql` files will not be retained. If you have migration files with custom additions such as a view or a trigger, ensure to re-add them after your migrations were squashed.\n\n## How to squash migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#how-to-squash-migrations \"Direct link to How to squash migrations\")\n\nThis section provides step-by-step instructions on how to squash migrations in the two scenarios discussed above:\n\n*   [Migrating cleanly from a development environment](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#how-to-migrate-cleanly-from-a-development-environment)\n*   [Creating a clean history in a production environment](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#how-to-create-a-clean-history-in-a-production-environment)\n\n### How to migrate cleanly from a development environment[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#how-to-migrate-cleanly-from-a-development-environment \"Direct link to How to migrate cleanly from a development environment\")\n\nBefore squashing your migrations, make sure you have the following starting conditions:\n\n*   The contents of the migrations to be squashed are not yet applied on the production database\n*   All migrations applied to production are part of the local migration history already\n*   There is no custom SQL in any of the new migration files that you have added to your branch\n\ninfo\n\nIf the migration history on the production database has diverged after you created your feature branch, then you would need to first merge the migrations history and the datamodel changes from production into your local history.\n\nThen follow these steps:\n\n1.  Reset the contents of your local `./prisma/migrations` folder to match the migration history on the `main` branch\n    \n2.  Create a new migration:\n    \n    ```\n    npx prisma migrate dev --name squashed_migrations\n    ```\n    \n    This creates a single migration that takes you:\n    \n    *   from the state of the `main` branch as described in your reset migration history\n    *   to the state of your local feature as described in your `./prisma/schema.prisma` file\n    *   and outputs this to a new `migration.sql` file in a new directory ending with `squashed_migrations` (specified with the `--name` flag)\n\nThis single migration file can now be applied to production using `migrate deploy`.\n\n### How to create a clean history in a production environment[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/squashing-migrations#how-to-create-a-clean-history-in-a-production-environment \"Direct link to How to create a clean history in a production environment\")\n\nBefore squashing your migrations, make sure you have the following starting conditions:\n\n*   All migrations in the migration history are applied on the production database\n*   The datamodel matches the migration history\n*   The datamodel and the migration history are in sync\n\nThen follow these steps, either on your `main` branch or on a newly checked out branch that gets merged back to `main` before anything else changes there:\n\n1.  Delete all contents of the `./prisma/migrations` directory\n    \n2.  Create a new empty directory in the `./prisma/migrations` directory. In this guide this will be called `000000000000_squashed_migrations`. Inside this, add a new empty `migration.sql` file.\n    \n    info\n    \n    We name the migration `000000000000_squashed_migrations` with all the leading zeroes because we want it to be the first migration in the migrations directory. Migrate runs the migrations in the directory in lexicographic (alphabetical) order. This is why it generates migrations with the date and time as a prefix when you use `migrate dev`. You can give the migration another name, as long as it it sorts lower than later migrations, for example `0_squashed` or `202207180000_squashed`.\n    \n3.  Create a single migration that takes you:\n    \n    *   from an empty database\n    *   to the current state of the production database schema as described in your `./prisma/schema.prisma` file\n    *   and outputs this to the `migration.sql` file created above\n    \n    You can do this using the `migrate diff` command. From the root directory of your project, run the following command:\n    \n    ```\n    npx prisma migrate diff \\ --from-empty \\ --to-schema-datamodel ./prisma/schema.prisma \\ --script > ./prisma/migrations/000000000000_squashed_migrations/migration.sql\n    ```\n    \n4.  Mark this migration as having been applied on production, to prevent it from being run there:\n    \n    You can do this using the [`migrate resolve`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-resolve) command to mark the migration in the `000000000000_squashed_migrations` directory as already applied:\n    \n    ```\n    npx prisma migrate resolve \\ --applied 000000000000_squashed_migrations\n    ```\n    \n\nYou should now have a single migration file that is marked as having been applied on production. New checkouts only get one single migration taking them to the state of the production database schema.\n\nThe production database still contains the history of applied migrations in the migrations table. The history of the migrations folder and data models is also still available in source control.",
    "title": "Squashing migrations | Prisma Documentation",
    "description": "How to squash multiple migration files into a single migration",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/generating-down-migrations",
    "markdown": "# Generating down migrations | Prisma Documentation\n\nThis guide describes how to generate a down migration SQL file that reverses a given [migration file](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/migration-histories).\n\n## About down migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/generating-down-migrations#about-down-migrations \"Direct link to About down migrations\")\n\nWhen generating a migration SQL file, you may wish to also create a \"down migration\" SQL file that reverses the schema changes in the corresponding \"up migration\" file. Note that \"down migrations\" are also sometimes called \"migration rollbacks\".\n\nThis guide explains how to use Prisma Migrate's [`migrate diff` command](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) to create a down migration, and how to apply it to your production database with the [`db execute`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-execute) command in the case of a failed up migration.\n\nwarning\n\nThis guide applies to generating SQL down migrations for relational databases only. It does not apply to MongoDB.\n\ninfo\n\nThe `migrate diff` and `db execute` commands are available in Preview in versions `3.9.0` and later, and are generally available in versions `3.13.0` and later.\n\n## Considerations when generating down migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/generating-down-migrations#considerations-when-generating-down-migrations \"Direct link to Considerations when generating down migrations\")\n\nWhen generating a down migration file, there are some considerations to be aware of:\n\n*   The down migration can be used to revert your database schema after a failed migration using the steps in [How to apply your down migration to a failed migration](https://www.prisma.io/docs/orm/prisma-migrate/workflows/generating-down-migrations#how-to-apply-your-down-migration-to-a-failed-migration). This requires the use of the `migrate resolve` command, which can only be used on failed migrations. If your up migration was successful and you want to revert it, you will instead need to revert your `schema.prisma` file to its state before the up migration, and generate a new migration with the `migrate dev` command.\n*   The down migration will revert your database schema, but other changes to data and application code that are carried out as part of the up migration will not be reverted. For example, if you have a script that changes data during the migration, this data will not be changed back when you run the down migration.\n*   You will not be able to use `migrate diff` to revert manually changed or added SQL in your migration files. If you have any custom additions, such as a view or trigger, you will need to:\n    *   Create the down migration following [the instructions below](https://www.prisma.io/docs/orm/prisma-migrate/workflows/generating-down-migrations#how-to-generate-and-run-down-migrations)\n    *   Create the up migration using [`migrate dev --create-only`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#options-6), so that it can be edited before it is applied to the database\n    *   Manually add your custom SQL to the up migration (e.g. adding a view)\n    *   Manually add the inverted custom SQL to the down migration (e.g. dropping the view)\n\n## How to generate and run down migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/generating-down-migrations#how-to-generate-and-run-down-migrations \"Direct link to How to generate and run down migrations\")\n\nThis section describes how to generate a down migration SQL file along with the corresponding up migration, and then run it to revert your database schema after a failed up migration on production.\n\nAs an example, take the following Prisma schema with a `User` and `Post` model as a starting point:\n\nschema.prisma\n\n```\nmodel Post {  id       Int     @id @default(autoincrement())  title    String  @db.VarChar(255)  content  String?  author   User    @relation(fields: [authorId], references: [id])  authorId Int}model User {  id    Int     @id @default(autoincrement())  name  String?  posts Post[]}\n```\n\nYou will need to create the down migration first, before creating the corresponding up migration.\n\n### Generating the migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/generating-down-migrations#generating-the-migrations \"Direct link to Generating the migrations\")\n\n1.  Edit your Prisma schema to make the changes you require for your up migration. In this example, you will add a new `Profile` model:\n    \n    schema.prisma\n    \n    ```\n    model Post {  id       Int     @id @default(autoincrement())  title    String  @db.VarChar(255)  content  String?  author   User    @relation(fields: [authorId], references: [id])  authorId Int}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId Int     @unique}model User {  id      Int      @id @default(autoincrement())  name    String?  posts   Post[]  profile Profile?}\n    ```\n    \n2.  Generate the SQL file for the down migration. To do this, you will use `migrate diff` to make a comparison:\n    \n    *   from the newly edited schema\n    *   to the state of the schema after the last migration\n    \n    and output this to a SQL script, `down.sql`.\n    \n    There are two potential options for specifying the 'to' state:\n    \n    *   Using `--to-migrations`: this makes a comparison to the state of the migrations given in the migrations directory. This is the preferred option, as it is more robust, but it requires a [shadow database](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database). To use this option, run:\n        \n        ```\n        npx prisma migrate diff \\ --from-schema-datamodel prisma/schema.prisma \\ --to-migrations prisma/migrations \\ --shadow-database-url $SHADOW_DATABASE_URL \\ --script > down.sql\n        ```\n        \n    *   Using `--to-schema-datasource`: this makes a comparison to the state of the database. This does not require a shadow database, but it does rely on the database having an up-to-date schema. To use this option, run:\n        \n        ```\n        npx prisma migrate diff \\ --from-schema-datamodel prisma/schema.prisma \\ --to-schema-datasource prisma/schema.prisma \\ --script > down.sql\n        ```\n        \n3.  Generate and apply the up migration with a name of `add_profile`:\n    \n    ```\n    npx prisma migrate dev --name add_profile\n    ```\n    \n    This will create a new `<timestamp>_add_profile` directory inside the `prisma/migrations` directory, with your new `migration.sql` up migration file inside.\n    \n4.  Copy your `down.sql` file into the new directory along with the up migration file.\n    \n\n### How to apply your down migration to a failed migration[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/generating-down-migrations#how-to-apply-your-down-migration-to-a-failed-migration \"Direct link to How to apply your down migration to a failed migration\")\n\nIf your previous up migration failed, you can apply your down migration on your production database with the following steps:\n\nTo apply the down migration on your production database after a failed up migration:\n\n1.  Use `db execute` to run your `down.sql` file on the database server:\n    \n    ```\n    npx prisma db execute --file ./down.sql --schema prisma/schema.prisma\n    ```\n    \n2.  Use `migrate resolve` to record that you rolled back the up migration named `add_profile`:\n    \n    ```\n    npx prisma migrate resolve --rolled-back add_profile\n    ```",
    "title": "Generating down migrations | Prisma Documentation",
    "description": "How to generate down migrations",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/team-development",
    "markdown": "# Team development | Prisma Documentation\n\nTo incorporate changes from collaborators:\n\n1.  Pull the changed Prisma schema and `./prisma/migrations` folder\n    \n2.  Run the `migrate dev` command to apply new migrations:\n    \n\nMigrations are **applied in the same order as they were created**. The creation date is part of the migration subfolder name - for example, `20210316081837-updated-fields` was created on `2021-03-16-08:08:37`.\n\nwarning\n\nThis guide **does not apply for MongoDB**.  \nInstead of `migrate dev`, [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) is used for [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb).\n\n## Example: Incorporating your team's changes[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/team-development#example-incorporating-your-teams-changes \"Direct link to Example: Incorporating your team's changes\")\n\nThe following sample scenario demonstrates how a team of three developers share and incorporate changes to the Prisma schema and the migration history.\n\nThe following tabs show the team's Prisma schema before and after a round of changes:\n\n*   Before\n*   After\n\nschema.prisma\n\n```\nmodel Post {  id        Int     @id @default(autoincrement())  title     String  content   String?  published Boolean @default(false)  author    User?   @relation(fields: [authorId], references: [id])  authorId  Int?}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?  posts Post[]}\n```\n\n### The team's changes[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/team-development#the-teams-changes \"Direct link to The team's changes\")\n\nYour team members Ania and Javier make additive changes to the schema in their local environment and generate migrations.\n\n**Ania** makes the following changes:\n\n1.  Adds a model field:\n    \n    ```\n    model User {  /* ... */  favoriteColor String?}\n    ```\n    \n2.  Generates a migration:\n    \n    ```\n    npx prisma migrate dev --name new-field\n    ```\n    \n3.  Commits the changed schema and the new migration:\n    \n    *   `./prisma/schema.prisma`\n    *   `./prisma/migrations/20210316081837-new-field/migration.sql`\n\n**Javier** makes the following changes:\n\n1.  Adds a new model to the schema:\n    \n    ```\n    model Tag {  tagName     String   @id  tagCategory Category}\n    ```\n    \n2.  Generates a migration:\n    \n    ```\n    npx prisma migrate dev --name new-model\n    ```\n    \n3.  Commits the changed schema and the new migration:\n    \n    *   `./prisma/schema.prisma`\n    *   `./prisma/migrations/20210316091837-new-model/migration.sql`\n\nThe migration history now has **two** new migrations:\n\n![A diagram showing changes by two separate developers converging in a single migration history.](https://www.prisma.io/docs/assets/images/migrate-team-dev-67fee0857c7f229cc4fb06010314e229.png)\n\n### Integrating changes[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/team-development#integrating-changes \"Direct link to Integrating changes\")\n\n**You** want to incorporate your team's changes. To do that, you:\n\n1.  Pull the most recent changes from your team, including:\n    \n    *   Two new migrations:\n        \n        *   `./prisma/migrations/20210316081837-new-field/migration.sql`\n        *   `./prisma/migrations/20210316091837-new-model/migration.sql`\n    *   An updated schema file. Git automatically merges the updated schema with _your_ local schema changes (a new `bestPacmanScore` field):\n        \n        ```\n        model User {  /* ... */  favoriteColor   String?  bestPacmanScore Int?}model Tag {  tagName     String   @id  tagCategory Category  posts       Post[]}\n        ```\n        \n2.  Run the `migrate dev` command:\n    \n    1.  Applies Ania and Javier's migrations to your local database.\n        \n        *   `./prisma/migrations/20210316081837-new-field/migration.sql`\n        *   `./prisma/migrations/20210316091837-new-model/migration.sql`\n    2.  Creates a new migration with your changes, prompts you to name it (`pacman-field`), and applies the new migration to your local database:\n        \n        *   `./prisma/migrations/20210322081837-pacman-field/migration.sql`\n3.  Commit the merged `schema.prisma` and your new migration: `./prisma/migrations/20210322081837-pacman-field/migration.sql`\n    \n\nYour `schema.prisma` and local database now include your team's changes, and the migration history includes your migration:\n\n![A migration history with 5 migrations.](https://www.prisma.io/docs/assets/images/migration-history-c87e29e73d55f7289d70c3fbc3aefd11.png)\n\n## Source control[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/team-development#source-control \"Direct link to Source control\")\n\nYou should commit the following files to source control:\n\n*   The contents of the `.prisma/migrations` folder, including the `migration_lock.toml` file\n*   The Prisma Schema (`schema.prisma`)\n\nSource-controlling the `schema.prisma` file is not enough - you must include your migration history. This is because:\n\n*   As you start to [customize migrations](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations), your migration history contains **information that cannot be represented in the Prisma schema**. For example, you can customize a migration to mitigate data loss that would be caused by a breaking change.\n*   The `prisma migrate deploy` command, which is used to deploy changes to staging, testing, and production environments, _only_ runs migration files. Prisma Migrate only uses the schema to read the `url` and `provider` fields, not models and fields.",
    "title": "Team development | Prisma Documentation",
    "description": "How to use Prisma Migrate when collaborating on a project as a team.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-functions",
    "markdown": "# Native database functions | Prisma Documentation\n\nIn PostgreSQL, some [native database functions](https://www.prisma.io/docs/orm/prisma-schema/data-model/unsupported-database-features#native-database-functions) are part of optional extensions. For example, in PostgreSQL versions 12.13 and earlier the `gen_random_uuid()` function is part of the [`pgcrypto`](https://www.postgresql.org/docs/10/pgcrypto.html) extension.\n\nTo use a PostgreSQL extension, you must install it on the file system of your database server and then activate the extension. If you use Prisma Migrate, this must be done as part of a migration.\n\nwarning\n\nDo not activate extensions outside a migration file if you use Prisma Migrate. The [shadow database](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database) requires the same extensions. Prisma Migrate creates and deletes the shadow database automatically, so the only way to activate an extension is to include it in a migration file.\n\nIn Prisma ORM versions 4.5.0 and later, you can activate the extension by declaring it in your Prisma schema with the [`postgresqlExtensions` preview feature](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions):\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"postgresqlExtensions\"]}datasource db {  provider   = \"postgresql\"  url        = env(\"DATABASE_URL\")  extensions = [pgcrypto]}\n```\n\nYou can then apply these changes to your database with Prisma Migrate. See [How to migrate PostgreSQL extensions](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions#how-to-migrate-postgresql-extensions) for details.\n\nIn earlier versions of Prisma ORM, you must instead add a SQL command to your migration file to activate the extension. See [How to install a PostgreSQL extension as part of a migration](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-functions#how-to-install-a-postgresql-extension-as-part-of-a-migration).\n\n## How to install a PostgreSQL extension as part of a migration[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/native-database-functions#how-to-install-a-postgresql-extension-as-part-of-a-migration \"Direct link to How to install a PostgreSQL extension as part of a migration\")\n\nThis section describes how to add a SQL command to a migration file to activate a PostgreSQL extension. If you manage PostgreSQL extensions in your Prisma Schema with the `postgresqlExtensions` preview feature instead, see [How to migrate PostgreSQL extensions](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions#how-to-migrate-postgresql-extensions).\n\nThe following example demonstrates how to install the `pgcrypto` extension as part of a migration:\n\n1.  Add the field with the native database function to your schema:\n    \n    ```\n    model User {  id String @id @default(dbgenerated(\"gen_random_uuid()\")) @db.Uuid}\n    ```\n    \n    If you include a cast operator (such as `::TEXT`), you must surround the entire function with parentheses:\n    \n    ```\n    @default(dbgenerated(\"(gen_random_uuid()::TEXT)\"))\n    ```\n    \n2.  Use the `--create-only` flag to generate a new migration without applying it:\n    \n    ```\n    npx prisma migrate dev --create-only\n    ```\n    \n3.  Open the generated `migration.sql` file and enable the `pgcrypto` module:\n    \n    ```\n    CREATE EXTENSION IF NOT EXISTS pgcrypto;ADD COLUMN \"id\" UUID NOT NULL DEFAULT gen_random_uuid(),ADD PRIMARY KEY (\"id\");\n    ```\n    \n4.  Apply the migration:\n    \n\nEach time you reset the database or add a new member to your team, all required functions are part of the migration history.",
    "title": "Native database functions | Prisma Documentation",
    "description": "How to enable PostgreSQL native database functions for projects that use Prisma Migrate.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-node-mysql",
    "markdown": "# Start from scratch with Prisma ORM using JavaScript and MySQL (15 min)\n\n## Relational databases\n\nLearn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-node-mysql#prerequisites \"Direct link to Prerequisites\")\n\nIn order to successfully complete this guide, you need:\n\n*   [Node.js](https://nodejs.org/en/) installed on your machine\n*   a [MySQL](https://www.mysql.com/) database server running\n\n> See [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for exact version requirements.\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) at hand. If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n## Create project setup[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-node-mysql#create-project-setup \"Direct link to Create project setup\")\n\nAs a first step, create a project directory and navigate into it:\n\n```\nmkdir hello-prismacd hello-prisma\n```\n\nNext, initialize a Node.js project and add the Prisma CLI as a development dependency to it:\n\n```\nnpm init -ynpm install prisma --save-dev\n```\n\nThis creates a `package.json` with an initial setup for a Node.js app.\n\nYou can now invoke the Prisma CLI by prefixing it with `npx`:\n\nNext, set up your Prisma ORM project by creating your [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file with the following command:\n\nThis command does two things:\n\n*   creates a new directory called `prisma` that contains a file called `schema.prisma`, which contains the Prisma schema with your database connection variable and schema models\n*   creates the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) in the root directory of the project, which is used for defining environment variables (such as your database connection)",
    "title": "Start from scratch with Prisma ORM using JavaScript and MySQL (15 min) | Prisma Documentation",
    "description": "Learn how to create a new Node.js project from scratch by connecting Prisma ORM to your MySQL database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-node-postgresql",
    "markdown": "# Start from scratch with Prisma ORM using JavaScript and PostgreSQL (15 min)\n\n## Relational databases\n\nLearn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-node-postgresql#prerequisites \"Direct link to Prerequisites\")\n\nIn order to successfully complete this guide, you need:\n\n*   [Node.js](https://nodejs.org/en/) installed on your machine\n*   a [PostgreSQL](https://www.postgresql.org/) database server running\n\n> See [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for exact version requirements.\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) at hand. If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n## Create project setup[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-node-postgresql#create-project-setup \"Direct link to Create project setup\")\n\nAs a first step, create a project directory and navigate into it:\n\n```\nmkdir hello-prismacd hello-prisma\n```\n\nNext, initialize a Node.js project and add the Prisma CLI as a development dependency to it:\n\n```\nnpm init -ynpm install prisma --save-dev\n```\n\nThis creates a `package.json` with an initial setup for a Node.js app.\n\nYou can now invoke the Prisma CLI by prefixing it with `npx`:\n\nNext, set up your Prisma ORM project by creating your [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file with the following command:\n\nThis command does two things:\n\n*   creates a new directory called `prisma` that contains a file called `schema.prisma`, which contains the Prisma schema with your database connection variable and schema models\n*   creates the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) in the root directory of the project, which is used for defining environment variables (such as your database connection)",
    "title": "Start from scratch with Prisma ORM using JavaScript and PostgreSQL (15 min) | Prisma Documentation",
    "description": "Learn how to create a new Node.js project from scratch by connecting Prisma ORM to your PostgreSQL database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/next-steps",
    "markdown": "# Next steps after setting up Prisma ORM with MongoDB\n\nHere are a few suggestions for a number of more queries you can send with Prisma Client:\n\n**Filter all `Post` records that contain `\"hello\"`**\n\n```\nconst filteredPosts = await prisma.post.findMany({  where: {    OR: [{ title: { contains: 'hello' } }, { body: { contains: 'hello' } }],  },})\n```\n\n**Create a new `Post` record and connect it to an existing `User` record**\n\n```\nconst post = await prisma.post.create({  data: {    title: 'Join us for Prisma Day 2020',    slug: 'prisma-day-2020',    body: 'A conference on modern application development and databases.',    user: {      connect: { email: 'hello@prisma.com' },    },  },})\n```\n\n**Use the fluent relations API to retrieve the `Post` records of a `User` by traversing the relations**\n\n```\nconst user = await prisma.comment  .findUnique({    where: { id: '60ff4e9500acc65700ebf470' },  })  .post()  .user()\n```\n\n**Delete a `User` record**\n\n```\nconst deletedUser = await prisma.user.delete({  where: { email: 'sarah@prisma.io' },})\n```",
    "title": "Next steps after setting up Prisma ORM with MongoDB | Prisma Documentation",
    "description": "Next steps to take now that you have successfully added Prisma ORM to your new JavaScript or TypeScript project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-node-cockroachdb",
    "markdown": "# Start from scratch with Prisma ORM using JavaScript and CockroachDB (15 min)\n\nLearn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) at hand. If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n```\nmkdir hello-prismacd hello-prisma\n```\n\nNext, initialize a Node.js project and add the Prisma CLI as a development dependency to it:\n\nThis creates a `package.json` with an initial setup for a Node.js app.",
    "title": "Start from scratch with Prisma ORM using JavaScript and CockroachDB (15 min) | Prisma Documentation",
    "description": "Learn how to create a new Node.js project from scratch by connecting Prisma ORM to your CockroachDB database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-node-sqlserver",
    "markdown": "# Start from scratch with Prisma ORM using JavaScript and SQL Server (15 min)\n\nLearn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) at hand. If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n```\nmkdir hello-prismacd hello-prisma\n```\n\nNext, initialize a Node.js project and add the Prisma CLI as a development dependency to it:\n\nThis creates a `package.json` with an initial setup for a Node.js app.\n\nNext, set up your Prisma ORM project by creating your [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file with the following command:",
    "title": "Start from scratch with Prisma ORM using JavaScript and SQL Server (15 min) | Prisma Documentation",
    "description": "Learn how to create a new Node.js project from scratch by connecting Prisma ORM to your SQL Server database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-node-mysql",
    "markdown": "# Connect your database using JavaScript and MySQL\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL, so you first need to switch the `provider` to `mysql`:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mysql\"  url      = env(\"DATABASE_URL\")}\n```\n\nIn this case, the `url` is [set via an environment variable](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"mysql://johndoe:randompassword@localhost:3306/mydb\"\n```\n\ninfo\n\nWe recommend adding `.env` to your `.gitignore` file to prevent committing your environment variables.\n\nYou now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database typically depends on the database you use. For MySQL, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running (typically `3306` for MySQL)\n*   `DATABASE`: The name of the [database](https://dev.mysql.com/doc/refman/8.0/en/creating-database.html)\n\nAs an example, for a MySQL database hosted on AWS RDS, the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) might look similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://johndoe:XXX@mysql–instance1.123456789012.us-east-1.rds.amazonaws.com:3306/mydb\"\n```\n\nWhen running MySQL locally, your connection URL typically looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://root:randompassword@localhost:3306/mydb\"\n```",
    "title": "Connect your database using JavaScript and MySQL | Prisma Documentation",
    "description": "Connect your database to your project using JavaScript and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting",
    "markdown": "# Troubleshooting | Prisma Documentation\n\nThis guide describes how to resolve issues with Prisma Migrate in a development environment, which often involves resetting your database. For production-focused troubleshooting, see:\n\n*   [Production troubleshooting](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing)\n*   [Patching / hotfixing production databases](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing)\n\nwarning\n\nThis guide **does not apply for MongoDB**.  \nInstead of `migrate dev`, [`db push`](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) is used for [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb).\n\n## Handling migration history conflicts[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting#handling-migration-history-conflicts \"Direct link to Handling migration history conflicts\")\n\nA migration history conflict occurs when there are discrepancies between the **migrations folder in the file system** and the **`_prisma_migrations` table in the database**.\n\n#### Causes of migration history conflict in a development environment[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting#causes-of-migration-history-conflict-in-a-development-environment \"Direct link to Causes of migration history conflict in a development environment\")\n\n*   A migration that has already been applied is later modified\n*   A migration that has already been applied is missing from the file system\n\nIn a development environment, switching between feature branches can result in a history conflict because the `_prisma_migrations` table contains migrations from `branch-1`, and switching to `branch-2` might cause some of those migrations to disappear.\n\n> **Note**: You should [never purposefully delete or edit a migration](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/migration-histories#do-not-edit-or-delete-migrations-that-have-been-applied), as this might result in discrepancies between development and production.\n\n#### Fixing a migration history conflict in a development environment[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting#fixing-a-migration-history-conflict-in-a-development-environment \"Direct link to Fixing a migration history conflict in a development environment\")\n\nIf Prisma Migrate detects a migration history conflict when you run `prisma migrate dev`, the CLI will ask to reset the database and reapply the migration history.\n\n## Schema drift[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting#schema-drift \"Direct link to Schema drift\")\n\nDatabase schema drift occurs when your database schema is out of sync with your migration history - the database schema has 'drifted away' from the source of truth.\n\n#### Causes of schema drift in a development environment[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting#causes-of-schema-drift-in-a-development-environment \"Direct link to Causes of schema drift in a development environment\")\n\nSchema drift can occur if:\n\n*   The database schema was changed _without_ using migrations - for example, by using [`prisma db push`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-push) or manually changing the database schema.\n\n> **Note**: The [shadow database](https://www.prisma.io/docs/orm/prisma-migrate/understanding-prisma-migrate/shadow-database) is required to detect schema drift, and can therefore only be done in a development environment.\n\n#### Fixing schema drift in a development environment[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting#fixing-schema-drift-in-a-development-environment \"Direct link to Fixing schema drift in a development environment\")\n\nIf you made manual changes to the database that you do not want to keep, or can easily replicate in the Prisma schema:\n\n1.  Reset your database:\n    \n2.  Replicate the changes in the Prisma schema and generate a new migration:\n    \n\nIf you made manual changes to the database that you want to keep, you can:\n\n1.  Introspect the database:\n    \n    Prisma will update your schema with the changes made directly in the database.\n    \n2.  Generate a new migration to include the introspected changes in your migration history:\n    \n    ```\n    npx prisma migrate dev --name introspected_change\n    ```\n    \n    Prisma Migrate will prompt you to reset, then applies all existing migrations and a new migration based on the introspected changes. Your database and migration history are now in sync, including your manual changes.\n    \n\n## Failed migrations[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting#failed-migrations \"Direct link to Failed migrations\")\n\n#### Causes of failed migrations in a development environment[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting#causes-of-failed-migrations-in-a-development-environment \"Direct link to Causes of failed migrations in a development environment\")\n\nA migration might fail if:\n\n*   You [modify a migration before running it](https://www.prisma.io/docs/orm/prisma-migrate/workflows/customizing-migrations) and introduce a syntax error\n*   You add a mandatory (`NOT NULL`) column to a table that already has data\n*   The migration process stopped unexpectedly\n*   The database shut down in the middle of the migration process\n\nEach migration in the `_prisma_migrations` table has a `logs` column that stores the error.\n\n#### Fixing failed migrations in a development environment[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting#fixing-failed-migrations-in-a-development-environment \"Direct link to Fixing failed migrations in a development environment\")\n\nThe easiest way to handle a failed migration in a developer environment is to address the root cause and reset the database. For example:\n\n*   If you introduced a SQL syntax error by manually editing the database, update the `migration.sql` file that failed and reset the database:\n    \n*   If you introduced a change in the Prisma schema that cannot be applied to a database with data (for example, a mandatory column in a table with data):\n    \n    1.  Delete the `migration.sql` file.\n        \n    2.  Modify the schema - for example, add a default value to the mandatory field.\n        \n    3.  Migrate:\n        \n        Prisma Migrate will prompt you to reset the database and re-apply all migrations.\n        \n*   If something interrupted the migration process, reset the database:\n    \n\n## Prisma Migrate and PgBouncer[​](https://www.prisma.io/docs/orm/prisma-migrate/workflows/troubleshooting#prisma-migrate-and-pgbouncer \"Direct link to Prisma Migrate and PgBouncer\")\n\nYou might see the following error if you attempt to run Prisma Migrate commands in an environment that uses PgBouncer for connection pooling:\n\n```\nError: undefined: Database errorError querying the database: db error: ERROR: prepared statement \"s0\" already exists\n```\n\nSee [Prisma Migrate and PgBouncer workaround](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections/pgbouncer) for further information and a workaround.",
    "title": "Troubleshooting | Prisma Documentation",
    "description": "Troubleshooting issues with Prisma Migrate in a development environment.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-node-cockroachdb",
    "markdown": "# Connect your database using JavaScript and CockroachDB\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL as the `provider`. For CockroachDB, you need to edit the `datasource` block to use the `cockroachdb` provider instead:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"cockroachdb\"  url      = env(\"DATABASE_URL\")}\n```\n\nThe `url` is [set via an environment variable](https://www.prisma.io/docs/orm/more/development-environment/environment-variables) which is defined in `.env`. You now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database depends on the database you use. CockroachDB uses the PostgreSQL connection URL format, which has the following structure (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?PARAMETERS\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running. The default for CockroachDB is `26257`.\n*   `DATABASE`: The name of the database\n*   `PARAMETERS`: Any additional connection parameters. See the CockroachDB documentation [here](https://www.cockroachlabs.com/docs/stable/connection-parameters.html#additional-connection-parameters).\n\nFor a [CockroachDB Serverless](https://www.cockroachlabs.com/docs/cockroachcloud/quickstart.html) or [Cockroach Dedicated](https://www.cockroachlabs.com/docs/cockroachcloud/quickstart-trial-cluster) database hosted on [CockroachDB Cloud](https://www.cockroachlabs.com/get-started-cockroachdb/), the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://<myusername>:<mypassword>@<short-id>.<region>.cockroachlabs.cloud:26257/defaultdb?sslmode=verify-full&sslrootcert=$HOME/.postgresql/root.crt&options=--<mycluster>\"\n```\n\nTo find your connection string on CockroachDB Cloud, click the 'Connect' button on the overview page for your database cluster, and select the 'Connection string' tab.\n\nFor a [CockroachDB database hosted locally](https://www.cockroachlabs.com/docs/stable/secure-a-cluster.html), the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://root@localhost:26257?sslmode=disable\"\n```\n\nYour connection string is displayed as part of the welcome text when starting CockroachDB from the command line.",
    "title": "Connect your database using JavaScript and CockroachDB | Prisma Documentation",
    "description": "Connect your database to your project using JavaScript and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-node-planetscale",
    "markdown": "# Connect your database using JavaScript and PlanetScale\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL as the `provider`. For PlanetScale, you need to edit the `datasource` block to use the `mysql` provider instead:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mysql\"  url      = env(\"DATABASE_URL\")}\n```\n\nYou will also need to set the relation mode type to `prisma` in order to [emulate foreign key constraints](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client) in the `datasource` block:\n\nschema.prisma\n\n```\ndatasource db {  provider     = \"mysql\"  url          = env(\"DATABASE_URL\")  relationMode = \"prisma\"}\n```\n\n> **Note**: Since February 2024, you can alternatively [use foreign key constraints on a database-level in PlanetScale](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-2-enable-foreign-key-constraints-in-the-planetscale-database-settings), which omits the need for setting `relationMode = \"prisma\"`.\n\nThe `url` is [set via an environment variable](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"mysql://janedoe:mypassword@server.us-east-2.psdb.cloud/mydb?sslaccept=strict\"\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database typically depends on the database you use. PlanetScale uses the MySQL connection URL format, which has the following structure (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running (typically `3306` for MySQL)\n*   `DATABASE`: The name of the [database](https://dev.mysql.com/doc/refman/8.0/en/creating-database.html)\n\nFor a database hosted with PlanetScale, the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://myusername:mypassword@server.us-east-2.psdb.cloud/mydb?sslaccept=strict\"\n```\n\nThe connection URL for a given database branch can be found from your PlanetScale account by going to the overview page for the branch and selecting the 'Connect' dropdown. In the 'Passwords' section, generate a new password and select 'Prisma' to get the Prisma format for the connection URL.\n\nAlternative method: connecting using the PlanetScale CLI\n\nAlternatively, you can connect to your PlanetScale database server using the [PlanetScale CLI](https://docs.planetscale.com/reference/planetscale-environment-setup), and use a local connection URL. In this case the connection URL will look like this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://root@localhost:PORT/mydb\"\n```\n\ninfo\n\nWe recommend adding `.env` to your `.gitignore` file to prevent committing your environment variables.\n\nTo connect to your branch, use the following command:\n\n```\npscale connect prisma-test branchname --port PORT\n```\n\nThe `--port` flag can be omitted if you are using the default port `3306`.",
    "title": "Connect your database using JavaScript and PlanetScale | Prisma Documentation",
    "description": "Connect your database to your project using JavaScript and PlanetScale",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-node-postgresql",
    "markdown": "# Connect your database using JavaScript and PostgreSQL\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nIn this case, the `url` is [set via an environment variable](https://www.prisma.io/docs/orm/more/development-environment/environment-variables) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public\"\n```\n\ninfo\n\nWe recommend adding `.env` to your `.gitignore` file to prevent committing your environment variables.\n\nYou now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database depends on the database you use. For PostgreSQL, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `HOST`: The name of your host name (for the local environment, it is `localhost`)\n*   `PORT`: The port where your database server is running (typically `5432` for PostgreSQL)\n*   `DATABASE`: The name of the [database](https://www.postgresql.org/docs/12/manage-ag-overview.html)\n*   `SCHEMA`: The name of the [schema](https://www.postgresql.org/docs/12/ddl-schemas.html) inside the database\n\nIf you're unsure what to provide for the `schema` parameter for a PostgreSQL connection URL, you can probably omit it. In that case, the default schema name `public` will be used.\n\nAs an example, for a PostgreSQL database hosted on Heroku, the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) might look similar to this:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://opnmyfngbknppm:XXX@ec2-46-137-91-216.eu-west-1.compute.amazonaws.com:5432/d50rgmkqi2ipus?schema=hello-prisma\"\n```\n\nWhen running PostgreSQL locally on macOS, your user and password as well as the database name _typically_ correspond to the current _user_ of your OS, e.g. assuming the user is called `janedoe`:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://janedoe:janedoe@localhost:5432/janedoe?schema=hello-prisma\"\n```",
    "title": "Connect your database using JavaScript and PostgreSQL | Prisma Documentation",
    "description": "Connect your database to your project using JavaScript and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/install-prisma-client-node-planetscale",
    "markdown": "# Install Prisma Client: JavaScript and PlanetScale\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you update your Prisma schema, you will have to update your database schema using either `prisma migrate dev` or `prisma db push`. This will keep your database schema in sync with your Prisma schema. The commands will also regenerate Prisma Client.",
    "title": "Install Prisma Client: JavaScript and PlanetScale | Prisma Documentation",
    "description": "Install and generate Prisma Client in your project using JavaScript and PlanetScale",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/install-prisma-client-node-mysql",
    "markdown": "# Install Prisma Client: JavaScript and MySQL\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you update your Prisma schema, you will have to update your database schema using either `prisma migrate dev` or `prisma db push`. This will keep your database schema in sync with your Prisma schema. The commands will also regenerate Prisma Client.",
    "title": "Install Prisma Client: JavaScript and MySQL | Prisma Documentation",
    "description": "Install and generate Prisma Client in your project using JavaScript and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-node-sqlserver",
    "markdown": "# Connect your database using JavaScript and SQL Server\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\n```\n  DATABASE_URL=\"sqlserver://localhost:1433;database=mydb;user=sa;password=r@ndomP@$$w0rd;trustServerCertificate=true\"\n```",
    "title": "Connect your database using JavaScript and SQL Server | Prisma Documentation",
    "description": "Connect your database to your project using JavaScript and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/install-prisma-client-node-sqlserver",
    "markdown": "# Install Prisma Client: JavaScript and SQL Server\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you update your Prisma schema, you will have to update your database schema using either `prisma migrate dev` or `prisma db push`. This will keep your database schema in sync with your Prisma schema. The commands will also regenerate Prisma Client.",
    "title": "Install Prisma Client: JavaScript and SQL Server | Prisma Documentation",
    "description": "Install and generate Prisma Client in your project using JavaScript and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/install-prisma-client-node-postgresql",
    "markdown": "# Install Prisma Client: JavaScript and PostgreSQL\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you update your Prisma schema, you will have to update your database schema using either `prisma migrate dev` or `prisma db push`. This will keep your database schema in sync with your Prisma schema. The commands will also regenerate Prisma Client.",
    "title": "Install Prisma Client: JavaScript and PostgreSQL | Prisma Documentation",
    "description": "Install and generate Prisma Client in your project using JavaScript and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-typescript-mysql",
    "markdown": "# Connect your database using TypeScript and MySQL\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL, so you first need to switch the `provider` to `mysql`:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mysql\"  url      = env(\"DATABASE_URL\")}\n```\n\nIn this case, the `url` is [set via an environment variable](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"mysql://johndoe:randompassword@localhost:3306/mydb\"\n```\n\ninfo\n\nWe recommend adding `.env` to your `.gitignore` file to prevent committing your environment variables.\n\nYou now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database typically depends on the database you use. For MySQL, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running (typically `3306` for MySQL)\n*   `DATABASE`: The name of the [database](https://dev.mysql.com/doc/refman/8.0/en/creating-database.html)\n\nAs an example, for a MySQL database hosted on AWS RDS, the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) might look similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://johndoe:XXX@mysql–instance1.123456789012.us-east-1.rds.amazonaws.com:3306/mydb\"\n```\n\nWhen running MySQL locally, your connection URL typically looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://root:randompassword@localhost:3306/mydb\"\n```",
    "title": "Connect your database using TypeScript and MySQL | Prisma Documentation",
    "description": "Connect your database to your project using TypeScript and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/install-prisma-client-typescript-cockroachdb",
    "markdown": "# Install Prisma Client: TypeScript and CockroachDB\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you update your Prisma schema, you will have to update your database schema using either `prisma migrate dev` or `prisma db push`. This will keep your database schema in sync with your Prisma schema. The commands will also regenerate Prisma Client.",
    "title": "Install Prisma Client: TypeScript and CockroachDB | Prisma Documentation",
    "description": "Install and generate Prisma Client in your project using TypeScript and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-typescript-cockroachdb",
    "markdown": "# Connect your database using TypeScript and CockroachDB\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL as the `provider`. For CockroachDB, you need to edit the `datasource` block to use the `cockroachdb` provider instead:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"cockroachdb\"  url      = env(\"DATABASE_URL\")}\n```\n\nThe `url` is [set via an environment variable](https://www.prisma.io/docs/orm/more/development-environment/environment-variables) which is defined in `.env`. You now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database depends on the database you use. CockroachDB uses the PostgreSQL connection URL format, which has the following structure (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?PARAMETERS\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running. The default for CockroachDB is `26257`.\n*   `DATABASE`: The name of the database\n*   `PARAMETERS`: Any additional connection parameters. See the CockroachDB documentation [here](https://www.cockroachlabs.com/docs/stable/connection-parameters.html#additional-connection-parameters).\n\nFor a [CockroachDB Serverless](https://www.cockroachlabs.com/docs/cockroachcloud/quickstart.html) or [Cockroach Dedicated](https://www.cockroachlabs.com/docs/cockroachcloud/quickstart-trial-cluster) database hosted on [CockroachDB Cloud](https://www.cockroachlabs.com/get-started-cockroachdb/), the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://<myusername>:<mypassword>@<short-id>.<region>.cockroachlabs.cloud:26257/defaultdb?sslmode=verify-full&sslrootcert=$HOME/.postgresql/root.crt&options=--<mycluster>\"\n```\n\nTo find your connection string on CockroachDB Cloud, click the 'Connect' button on the overview page for your database cluster, and select the 'Connection string' tab.\n\nFor a [CockroachDB database hosted locally](https://www.cockroachlabs.com/docs/stable/secure-a-cluster.html), the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://root@localhost:26257?sslmode=disable\"\n```\n\nYour connection string is displayed as part of the welcome text when starting CockroachDB from the command line.",
    "title": "Connect your database using TypeScript and CockroachDB | Prisma Documentation",
    "description": "Connect your database to your project using TypeScript and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-node-planetscale",
    "markdown": "# Start from scratch with Prisma ORM using JavaScript and PlanetScale (15 min)\n\nLearn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate).\n\nNext, initialize a Node.js project and add the Prisma CLI as a development dependency to it:\n\n```\nnpm init -ynpm install prisma --save-dev\n```\n\nThis creates a `package.json` with an initial setup for a Node.js app.\n\nNext, set up your Prisma ORM project by creating your [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file with the following command:",
    "title": "Start from scratch with Prisma ORM using JavaScript and PlanetScale (15 min) | Prisma Documentation",
    "description": "Learn how to create a new Node.js project from scratch by connecting Prisma ORM to your PlanetScale database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-typescript-postgresql",
    "markdown": "# Connect your database using TypeScript and PostgreSQL\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nIn this case, the `url` is [set via an environment variable](https://www.prisma.io/docs/orm/more/development-environment/environment-variables) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public\"\n```\n\ninfo\n\nWe recommend adding `.env` to your `.gitignore` file to prevent committing your environment variables.\n\nYou now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database depends on the database you use. For PostgreSQL, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `HOST`: The name of your host name (for the local environment, it is `localhost`)\n*   `PORT`: The port where your database server is running (typically `5432` for PostgreSQL)\n*   `DATABASE`: The name of the [database](https://www.postgresql.org/docs/12/manage-ag-overview.html)\n*   `SCHEMA`: The name of the [schema](https://www.postgresql.org/docs/12/ddl-schemas.html) inside the database\n\nIf you're unsure what to provide for the `schema` parameter for a PostgreSQL connection URL, you can probably omit it. In that case, the default schema name `public` will be used.\n\nAs an example, for a PostgreSQL database hosted on Heroku, the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) might look similar to this:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://opnmyfngbknppm:XXX@ec2-46-137-91-216.eu-west-1.compute.amazonaws.com:5432/d50rgmkqi2ipus?schema=hello-prisma\"\n```\n\nWhen running PostgreSQL locally on macOS, your user and password as well as the database name _typically_ correspond to the current _user_ of your OS, e.g. assuming the user is called `janedoe`:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://janedoe:janedoe@localhost:5432/janedoe?schema=hello-prisma\"\n```",
    "title": "Connect your database using TypeScript and PostgreSQL | Prisma Documentation",
    "description": "Connect your database to your project using TypeScript and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/install-prisma-client-typescript-mysql",
    "markdown": "# Install Prisma Client: TypeScript and MySQL\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you update your Prisma schema, you will have to update your database schema using either `prisma migrate dev` or `prisma db push`. This will keep your database schema in sync with your Prisma schema. The commands will also regenerate Prisma Client.",
    "title": "Install Prisma Client: TypeScript and MySQL | Prisma Documentation",
    "description": "Install and generate Prisma Client in your project using TypeScript and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-typescript-sqlserver",
    "markdown": "# Connect your database using TypeScript and SQL Server\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\n```\n  DATABASE_URL=\"sqlserver://localhost:1433;database=mydb;user=sa;password=r@ndomP@$$w0rd;trustServerCertificate=true\"\n```",
    "title": "Connect your database using TypeScript and SQL Server | Prisma Documentation",
    "description": "Connect your database to your project using TypeScript and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/install-prisma-client-typescript-planetscale",
    "markdown": "# Install Prisma Client: TypeScript and PlanetScale\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you update your Prisma schema, you will have to update your database schema using either `prisma migrate dev` or `prisma db push`. This will keep your database schema in sync with your Prisma schema. The commands will also regenerate Prisma Client.",
    "title": "Install Prisma Client: TypeScript and PlanetScale | Prisma Documentation",
    "description": "Install and generate Prisma Client in your project using TypeScript and PlanetScale",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/install-prisma-client-typescript-postgresql",
    "markdown": "# Install Prisma Client: TypeScript and PostgreSQL\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you update your Prisma schema, you will have to update your database schema using either `prisma migrate dev` or `prisma db push`. This will keep your database schema in sync with your Prisma schema. The commands will also regenerate Prisma Client.",
    "title": "Install Prisma Client: TypeScript and PostgreSQL | Prisma Documentation",
    "description": "Install and generate Prisma Client in your project using TypeScript and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/using-prisma-migrate-node-mysql",
    "markdown": "# Using Prisma Migrate with JavaScript and MySQL\n\nIn this guide, you'll use [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) to create the tables in your database. Add the following Prisma data model to your Prisma schema in `prisma/schema.prisma`:\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title     String   @db.VarChar(255)  content   String?  published Boolean  @default(false)  author    User     @relation(fields: [authorId], references: [id])  authorId  Int}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId Int     @unique}model User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  posts   Post[]  profile Profile?}\n```\n\nTo map your data model to the database schema, you need to use the `prisma migrate` CLI commands:",
    "title": "Using Prisma Migrate with JavaScript and MySQL | Prisma Documentation",
    "description": "Create database tables with Prisma Migrate using JavaScript and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/using-prisma-migrate-node-cockroachdb",
    "markdown": "# Using Prisma Migrate with JavaScript and CockroachDB\n\nIn this guide, you'll use [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) to create the tables in your database. Add the following Prisma data model to your Prisma schema in `prisma/schema.prisma`:\n\n```\nmodel Post {  id        BigInt   @id @default(sequence())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title     String     content   String?  published Boolean  @default(false)  author    User     @relation(fields: [authorId], references: [id])  authorId  BigInt}model Profile {  id     BigInt  @id @default(sequence())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId BigInt  @unique}model User {  id      BigInt   @id @default(sequence())  email   String   @unique  name    String?  posts   Post[]  profile Profile?}\n```\n\nTo map your data model to the database schema, you need to use the `prisma migrate` CLI commands:\n\nnote\n\n`generate` is called under the hood by default, after running `prisma migrate dev`. If the `prisma-client-js` generator is defined in your schema, this will check if `@prisma/client` is installed and install it if it's missing.",
    "title": "Using Prisma Migrate with JavaScript and CockroachDB | Prisma Documentation",
    "description": "Create database tables with Prisma Migrate using JavaScript and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/install-prisma-client-typescript-sqlserver",
    "markdown": "# Install Prisma Client: TypeScript and SQL Server\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you update your Prisma schema, you will have to update your database schema using either `prisma migrate dev` or `prisma db push`. This will keep your database schema in sync with your Prisma schema. The commands will also regenerate Prisma Client.",
    "title": "Install Prisma Client: TypeScript and SQL Server | Prisma Documentation",
    "description": "Install and generate Prisma Client in your project using TypeScript and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/using-prisma-migrate-node-postgresql",
    "markdown": "# Using Prisma Migrate with JavaScript and PostgreSQL\n\nIn this guide, you'll use [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) to create the tables in your database. Add the following data model to your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) in `prisma/schema.prisma`:\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title     String   @db.VarChar(255)  content   String?  published Boolean  @default(false)  author    User     @relation(fields: [authorId], references: [id])  authorId  Int}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId Int     @unique}model User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  posts   Post[]  profile Profile?}\n```\n\nTo map your data model to the database schema, you need to use the `prisma migrate` CLI commands:\n\nnote\n\n`generate` is called under the hood by default, after running `prisma migrate dev`. If the `prisma-client-js` generator is defined in your schema, this will check if `@prisma/client` is installed and install it if it's missing.",
    "title": "Using Prisma Migrate with JavaScript and PostgreSQL | Prisma Documentation",
    "description": "Create database tables with Prisma Migrate using JavaScript and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-cockroachdb",
    "markdown": "# Querying the database using JavaScript and CockroachDB\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-cockroachdb#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nCreate a new file named `index.js` and add the following code to it:\n\nindex.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.js\n\n```\nasync function main() {  // ... you will write your Prisma Client queries here  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nThis should print an empty array because there are no `User` records in the database yet:\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-cockroachdb#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.js\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    email: 'alice@prisma.io',    id: 1,    name: 'Alice',    posts: [      {        content: null,        createdAt: 2020-03-21T16:45:01.246Z,        updatedAt: 2020-03-21T16:45:01.246Z,        id: 1,        published: false,        title: 'Hello World',        authorId: 1,      }    ],    profile: {      bio: 'I like turtles',      id: 1,      userId: 1,    }  }]\n```\n\nThe query added new records to the `User` and the `Post` tables:\n\n**User**\n\n| **id** | **email** | **name** |\n| --- | --- | --- |\n| `1` | `\"alice@prisma.io\"` | `\"Alice\"` |\n\n**Post**\n\n| **id** | **createdAt** | **updatedAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- | --- |\n| `1` | `2020-03-21T16:45:01.246Z` | `2020-03-21T16:45:01.246Z` | `\"Hello World\"` | `null` | `false` | `1` |\n\n**Profile**\n\n| **id** | **bio** | **userId** |\n| --- | --- | --- |\n| `1` | `\"I like turtles\"` | `1` |\n\n> **Note**: The numbers in the `authorId` column on `Post` and `userId` column on `Profile` both reference the `id` column of the `User` table, meaning the `id` value `1` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.js\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n{  id: 1,  title: 'Hello World',  content: null,  published: true,  authorId: 1}\n```\n\nThe `Post` record with an `id` of `1` now got updated in the database:\n\n**Post**\n\n| **id** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- |\n| `1` | `\"Hello World\"` | `null` | `true` | `1` |\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database using JavaScript and CockroachDB | Prisma Documentation",
    "description": "Write data to and query the database using JavaScript and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/using-prisma-migrate-node-planetscale",
    "markdown": "# Using Prisma Migrate with JavaScript and PlanetScale\n\nIn this guide, you'll use Prisma's [`db push` command](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) to create the tables in your database. Add the following Prisma data model to your Prisma schema in `prisma/schema.prisma`:\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title     String   @db.VarChar(255)  content   String?  published Boolean  @default(false)  author    User     @relation(fields: [authorId], references: [id])  authorId  Int  @@index(authorId)}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId Int     @unique  @@index(userId)}model User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  posts   Post[]  profile Profile?}\n```\n\nYou are now ready to push your new schema to your database. Connect to your `main` branch using the instructions in [Connect your database](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-typescript-planetscale).\n\nGreat, you now created three tables in your database with Prisma's `db push` command 🚀",
    "title": "Using Prisma Migrate with JavaScript and PlanetScale | Prisma Documentation",
    "description": "Create database tables with Prisma Migrate using JavaScript and PlanetScale",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-mysql",
    "markdown": "# Querying the database using JavaScript and MySQL\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-mysql#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nCreate a new file named `index.js` and add the following code to it:\n\nindex.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.js\n\n```\nasync function main() {  // ... you will write your Prisma Client queries here  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nThis should print an empty array because there are no `User` records in the database yet:\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-mysql#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.js\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    email: 'alice@prisma.io',    id: 1,    name: 'Alice',    posts: [      {        content: null,        createdAt: 2020-03-21T16:45:01.246Z,        updatedAt: 2020-03-21T16:45:01.246Z,        id: 1,        published: false,        title: 'Hello World',        authorId: 1,      }    ],    profile: {      bio: 'I like turtles',      id: 1,      userId: 1,    }  }]\n```\n\nThe query added new records to the `User` and the `Post` tables:\n\n**User**\n\n| **id** | **email** | **name** |\n| --- | --- | --- |\n| `1` | `\"alice@prisma.io\"` | `\"Alice\"` |\n\n**Post**\n\n| **id** | **createdAt** | **updatedAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- | --- |\n| `1` | `2020-03-21T16:45:01.246Z` | `2020-03-21T16:45:01.246Z` | `\"Hello World\"` | `null` | `false` | `1` |\n\n**Profile**\n\n| **id** | **bio** | **userId** |\n| --- | --- | --- |\n| `1` | `\"I like turtles\"` | `1` |\n\n> **Note**: The numbers in the `authorId` column on `Post` and `userId` column on `Profile` both reference the `id` column of the `User` table, meaning the `id` value `1` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.js\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n{  id: 1,  title: 'Hello World',  content: null,  published: true,  authorId: 1}\n```\n\nThe `Post` record with an `id` of `1` now got updated in the database:\n\n**Post**\n\n| **id** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- |\n| `1` | `\"Hello World\"` | `null` | `true` | `1` |\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database using JavaScript and MySQL | Prisma Documentation",
    "description": "Write data to and query the database using JavaScript and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/using-prisma-migrate-typescript-cockroachdb",
    "markdown": "# Using Prisma Migrate with TypeScript and CockroachDB\n\nIn this guide, you'll use [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) to create the tables in your database. Add the following Prisma data model to your Prisma schema in `prisma/schema.prisma`:\n\n```\nmodel Post {  id        BigInt   @id @default(sequence())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title     String     content   String?  published Boolean  @default(false)  author    User     @relation(fields: [authorId], references: [id])  authorId  BigInt}model Profile {  id     BigInt  @id @default(sequence())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId BigInt  @unique}model User {  id      BigInt   @id @default(sequence())  email   String   @unique  name    String?  posts   Post[]  profile Profile?}\n```\n\nTo map your data model to the database schema, you need to use the `prisma migrate` CLI commands:\n\nnote\n\n`generate` is called under the hood by default, after running `prisma migrate dev`. If the `prisma-client-js` generator is defined in your schema, this will check if `@prisma/client` is installed and install it if it's missing.",
    "title": "Using Prisma Migrate with TypeScript and CockroachDB | Prisma Documentation",
    "description": "Create database tables with Prisma Migrate using TypeScript and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-postgresql",
    "markdown": "# Querying the database using JavaScript and PostgreSQL\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-postgresql#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nCreate a new file named `index.js` and add the following code to it:\n\nindex.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.js\n\n```\nasync function main() {  // ... you will write your Prisma Client queries here  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nThis should print an empty array because there are no `User` records in the database yet:\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-postgresql#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.js\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    email: 'alice@prisma.io',    id: 1,    name: 'Alice',    posts: [      {        content: null,        createdAt: 2020-03-21T16:45:01.246Z,        updatedAt: 2020-03-21T16:45:01.246Z,        id: 1,        published: false,        title: 'Hello World',        authorId: 1,      }    ],    profile: {      bio: 'I like turtles',      id: 1,      userId: 1,    }  }]\n```\n\nThe query added new records to the `User` and the `Post` tables:\n\n**User**\n\n| **id** | **email** | **name** |\n| --- | --- | --- |\n| `1` | `\"alice@prisma.io\"` | `\"Alice\"` |\n\n**Post**\n\n| **id** | **createdAt** | **updatedAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- | --- |\n| `1` | `2020-03-21T16:45:01.246Z` | `2020-03-21T16:45:01.246Z` | `\"Hello World\"` | `null` | `false` | `1` |\n\n**Profile**\n\n| **id** | **bio** | **userId** |\n| --- | --- | --- |\n| `1` | `\"I like turtles\"` | `1` |\n\n> **Note**: The numbers in the `authorId` column on `Post` and `userId` column on `Profile` both reference the `id` column of the `User` table, meaning the `id` value `1` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.js\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n{  id: 1,  title: 'Hello World',  content: null,  published: true,  authorId: 1}\n```\n\nThe `Post` record with an `id` of `1` now got updated in the database:\n\n**Post**\n\n| **id** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- |\n| `1` | `\"Hello World\"` | `null` | `true` | `1` |\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database using JavaScript and PostgreSQL | Prisma Documentation",
    "description": "Write data to and query the database using JavaScript and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-planetscale",
    "markdown": "# Querying the database using JavaScript and PlanetScale\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-planetscale#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nCreate a new file named `index.js` and add the following code to it:\n\nindex.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.js\n\n```\nasync function main() {  // ... you will write your Prisma Client queries here  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nThis should print an empty array because there are no `User` records in the database yet:\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-planetscale#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.js\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    email: 'alice@prisma.io',    id: 1,    name: 'Alice',    posts: [      {        content: null,        createdAt: 2020-03-21T16:45:01.246Z,        updatedAt: 2020-03-21T16:45:01.246Z,        id: 1,        published: false,        title: 'Hello World',        authorId: 1,      }    ],    profile: {      bio: 'I like turtles',      id: 1,      userId: 1,    }  }]\n```\n\nThe query added new records to the `User` and the `Post` tables:\n\n**User**\n\n| **id** | **email** | **name** |\n| --- | --- | --- |\n| `1` | `\"alice@prisma.io\"` | `\"Alice\"` |\n\n**Post**\n\n| **id** | **createdAt** | **updatedAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- | --- |\n| `1` | `2020-03-21T16:45:01.246Z` | `2020-03-21T16:45:01.246Z` | `\"Hello World\"` | `null` | `false` | `1` |\n\n**Profile**\n\n| **id** | **bio** | **userId** |\n| --- | --- | --- |\n| `1` | `\"I like turtles\"` | `1` |\n\n> **Note**: The numbers in the `authorId` column on `Post` and `userId` column on `Profile` both reference the `id` column of the `User` table, meaning the `id` value `1` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.js\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n{  id: 1,  title: 'Hello World',  content: null,  published: true,  authorId: 1}\n```\n\nThe `Post` record with an `id` of `1` now got updated in the database:\n\n**Post**\n\n| **id** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- |\n| `1` | `\"Hello World\"` | `null` | `true` | `1` |\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database using JavaScript and PlanetScale | Prisma Documentation",
    "description": "Write data to and query the database using JavaScript and PlanetScale",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/using-prisma-migrate-node-sqlserver",
    "markdown": "# Using Prisma Migrate with JavaScript and SQL Server\n\nIn this guide, you'll use [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) to create the tables in your database. Add the following Prisma data model to your Prisma schema in `prisma/schema.prisma`:\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title     String   @db.VarChar(255)  content   String?  published Boolean  @default(false)  author    User     @relation(fields: [authorId], references: [id])  authorId  Int}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId Int     @unique}model User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  posts   Post[]  profile Profile?}\n```\n\nTo map your data model to the database schema, you need to use the `prisma migrate` CLI commands:",
    "title": "Using Prisma Migrate with JavaScript and SQL Server | Prisma Documentation",
    "description": "Create database tables with Prisma Migrate using JavaScript and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/using-prisma-migrate-typescript-mysql",
    "markdown": "# Using Prisma Migrate with TypeScript and MySQL\n\nIn this guide, you'll use [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) to create the tables in your database. Add the following Prisma data model to your Prisma schema in `prisma/schema.prisma`:\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title     String   @db.VarChar(255)  content   String?  published Boolean  @default(false)  author    User     @relation(fields: [authorId], references: [id])  authorId  Int}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId Int     @unique}model User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  posts   Post[]  profile Profile?}\n```\n\nTo map your data model to the database schema, you need to use the `prisma migrate` CLI commands:",
    "title": "Using Prisma Migrate with TypeScript and MySQL | Prisma Documentation",
    "description": "Create database tables with Prisma Migrate using TypeScript and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/using-prisma-migrate-typescript-planetscale",
    "markdown": "# Using Prisma Migrate with TypeScript and PlanetScale\n\nIn this guide, you'll use Prisma's [`db push` command](https://www.prisma.io/docs/orm/prisma-migrate/workflows/prototyping-your-schema) to create the tables in your database. Add the following Prisma data model to your Prisma schema in `prisma/schema.prisma`:\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title     String   @db.VarChar(255)  content   String?  published Boolean  @default(false)  author    User     @relation(fields: [authorId], references: [id])  authorId  Int  @@index(authorId)}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId Int     @unique  @@index(userId)}model User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  posts   Post[]  profile Profile?}\n```\n\nYou are now ready to push your new schema to your database. Connect to your `main` branch using the instructions in [Connect your database](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/connect-your-database-typescript-planetscale).\n\nGreat, you now created three tables in your database with Prisma's `db push` command 🚀",
    "title": "Using Prisma Migrate with TypeScript and PlanetScale | Prisma Documentation",
    "description": "Create database tables with Prisma Migrate using TypeScript and PlanetScale",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-sqlserver",
    "markdown": "# Querying the database using JavaScript and SQL Server\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-sqlserver#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nCreate a new file named `index.js` and add the following code to it:\n\nindex.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.js\n\n```\nasync function main() {  // ... you will write your Prisma Client queries here  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nThis should print an empty array because there are no `User` records in the database yet:\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-node-sqlserver#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.js\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    email: 'alice@prisma.io',    id: 1,    name: 'Alice',    posts: [      {        content: null,        createdAt: 2020-03-21T16:45:01.246Z,        updatedAt: 2020-03-21T16:45:01.246Z,        id: 1,        published: false,        title: 'Hello World',        authorId: 1,      }    ],    profile: {      bio: 'I like turtles',      id: 1,      userId: 1,    }  }]\n```\n\nThe query added new records to the `User` and the `Post` tables:\n\n**User**\n\n| **id** | **email** | **name** |\n| --- | --- | --- |\n| `1` | `\"alice@prisma.io\"` | `\"Alice\"` |\n\n**Post**\n\n| **id** | **createdAt** | **updatedAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- | --- |\n| `1` | `2020-03-21T16:45:01.246Z` | `2020-03-21T16:45:01.246Z` | `\"Hello World\"` | `null` | `false` | `1` |\n\n**Profile**\n\n| **id** | **bio** | **userId** |\n| --- | --- | --- |\n| `1` | `\"I like turtles\"` | `1` |\n\n> **Note**: The numbers in the `authorId` column on `Post` and `userId` column on `Profile` both reference the `id` column of the `User` table, meaning the `id` value `1` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.js\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n{  id: 1,  title: 'Hello World',  content: null,  published: true,  authorId: 1}\n```\n\nThe `Post` record with an `id` of `1` now got updated in the database:\n\n**Post**\n\n| **id** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- |\n| `1` | `\"Hello World\"` | `null` | `true` | `1` |\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database using JavaScript and SQL Server | Prisma Documentation",
    "description": "Write data to and query the database using JavaScript and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-cockroachdb",
    "markdown": "# Querying the database using TypeScript and CockroachDB\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-cockroachdb#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nCreate a new file named `index.ts` and add the following code to it:\n\nindex.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.ts\n\n```\nasync function main() {  // ... you will write your Prisma Client queries here  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nThis should print an empty array because there are no `User` records in the database yet:\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-cockroachdb#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.ts\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    email: 'alice@prisma.io',    id: 1,    name: 'Alice',    posts: [      {        content: null,        createdAt: 2020-03-21T16:45:01.246Z,        updatedAt: 2020-03-21T16:45:01.246Z,        id: 1,        published: false,        title: 'Hello World',        authorId: 1,      }    ],    profile: {      bio: 'I like turtles',      id: 1,      userId: 1,    }  }]\n```\n\nAlso note that `allUsers` is _statically typed_ thanks to [Prisma Client's generated types](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types). You can observe the type by hovering over the `allUsers` variable in your editor. It should be typed as follows:\n\n```\nconst allUsers: (User & {  posts: Post[]})[]export type Post = {  id: number  title: string  content: string | null  published: boolean  authorId: number | null}\n```\n\nThe query added new records to the `User` and the `Post` tables:\n\n**User**\n\n| **id** | **email** | **name** |\n| --- | --- | --- |\n| `1` | `\"alice@prisma.io\"` | `\"Alice\"` |\n\n**Post**\n\n| **id** | **createdAt** | **updatedAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- | --- |\n| `1` | `2020-03-21T16:45:01.246Z` | `2020-03-21T16:45:01.246Z` | `\"Hello World\"` | `null` | `false` | `1` |\n\n**Profile**\n\n| **id** | **bio** | **userId** |\n| --- | --- | --- |\n| `1` | `\"I like turtles\"` | `1` |\n\n> **Note**: The numbers in the `authorId` column on `Post` and `userId` column on `Profile` both reference the `id` column of the `User` table, meaning the `id` value `1` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.ts\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n{  id: 1,  title: 'Hello World',  content: null,  published: true,  authorId: 1}\n```\n\nThe `Post` record with an `id` of `1` now got updated in the database:\n\n**Post**\n\n| **id** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- |\n| `1` | `\"Hello World\"` | `null` | `true` | `1` |\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database using TypeScript and CockroachDB | Prisma Documentation",
    "description": "Write data to and query the database using TypeScript and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/using-prisma-migrate-typescript-sqlserver",
    "markdown": "# Using Prisma Migrate with TypeScript and SQL Server\n\nIn this guide, you'll use [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) to create the tables in your database. Add the following Prisma data model to your Prisma schema in `prisma/schema.prisma`:\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title     String   @db.VarChar(255)  content   String?  published Boolean  @default(false)  author    User     @relation(fields: [authorId], references: [id])  authorId  Int}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId Int     @unique}model User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  posts   Post[]  profile Profile?}\n```\n\nTo map your data model to the database schema, you need to use the `prisma migrate` CLI commands:",
    "title": "Using Prisma Migrate with TypeScript and SQL Server | Prisma Documentation",
    "description": "Create database tables with Prisma Migrate using TypeScript and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-planetscale",
    "markdown": "# Querying the database using TypeScript and PlanetScale\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-planetscale#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nCreate a new file named `index.ts` and add the following code to it:\n\nindex.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.ts\n\n```\nasync function main() {  // ... you will write your Prisma Client queries here  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nThis should print an empty array because there are no `User` records in the database yet:\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-planetscale#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.ts\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    email: 'alice@prisma.io',    id: 1,    name: 'Alice',    posts: [      {        content: null,        createdAt: 2020-03-21T16:45:01.246Z,        updatedAt: 2020-03-21T16:45:01.246Z,        id: 1,        published: false,        title: 'Hello World',        authorId: 1,      }    ],    profile: {      bio: 'I like turtles',      id: 1,      userId: 1,    }  }]\n```\n\nAlso note that `allUsers` is _statically typed_ thanks to [Prisma Client's generated types](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types). You can observe the type by hovering over the `allUsers` variable in your editor. It should be typed as follows:\n\n```\nconst allUsers: (User & {  posts: Post[]})[]export type Post = {  id: number  title: string  content: string | null  published: boolean  authorId: number | null}\n```\n\nThe query added new records to the `User` and the `Post` tables:\n\n**User**\n\n| **id** | **email** | **name** |\n| --- | --- | --- |\n| `1` | `\"alice@prisma.io\"` | `\"Alice\"` |\n\n**Post**\n\n| **id** | **createdAt** | **updatedAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- | --- |\n| `1` | `2020-03-21T16:45:01.246Z` | `2020-03-21T16:45:01.246Z` | `\"Hello World\"` | `null` | `false` | `1` |\n\n**Profile**\n\n| **id** | **bio** | **userId** |\n| --- | --- | --- |\n| `1` | `\"I like turtles\"` | `1` |\n\n> **Note**: The numbers in the `authorId` column on `Post` and `userId` column on `Profile` both reference the `id` column of the `User` table, meaning the `id` value `1` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.ts\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n{  id: 1,  title: 'Hello World',  content: null,  published: true,  authorId: 1}\n```\n\nThe `Post` record with an `id` of `1` now got updated in the database:\n\n**Post**\n\n| **id** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- |\n| `1` | `\"Hello World\"` | `null` | `true` | `1` |\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database using TypeScript and PlanetScale | Prisma Documentation",
    "description": "Write data to and query the database using TypeScript and PlanetScale",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-mysql",
    "markdown": "# Querying the database using TypeScript and MySQL\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-mysql#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nCreate a new file named `index.ts` and add the following code to it:\n\nindex.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.ts\n\n```\nasync function main() {  // ... you will write your Prisma Client queries here  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nThis should print an empty array because there are no `User` records in the database yet:\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-mysql#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.ts\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    email: 'alice@prisma.io',    id: 1,    name: 'Alice',    posts: [      {        content: null,        createdAt: 2020-03-21T16:45:01.246Z,        updatedAt: 2020-03-21T16:45:01.246Z,        id: 1,        published: false,        title: 'Hello World',        authorId: 1,      }    ],    profile: {      bio: 'I like turtles',      id: 1,      userId: 1,    }  }]\n```\n\nAlso note that `allUsers` is _statically typed_ thanks to [Prisma Client's generated types](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types). You can observe the type by hovering over the `allUsers` variable in your editor. It should be typed as follows:\n\n```\nconst allUsers: (User & {  posts: Post[]})[]export type Post = {  id: number  title: string  content: string | null  published: boolean  authorId: number | null}\n```\n\nThe query added new records to the `User` and the `Post` tables:\n\n**User**\n\n| **id** | **email** | **name** |\n| --- | --- | --- |\n| `1` | `\"alice@prisma.io\"` | `\"Alice\"` |\n\n**Post**\n\n| **id** | **createdAt** | **updatedAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- | --- |\n| `1` | `2020-03-21T16:45:01.246Z` | `2020-03-21T16:45:01.246Z` | `\"Hello World\"` | `null` | `false` | `1` |\n\n**Profile**\n\n| **id** | **bio** | **userId** |\n| --- | --- | --- |\n| `1` | `\"I like turtles\"` | `1` |\n\n> **Note**: The numbers in the `authorId` column on `Post` and `userId` column on `Profile` both reference the `id` column of the `User` table, meaning the `id` value `1` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.ts\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n{  id: 1,  title: 'Hello World',  content: null,  published: true,  authorId: 1}\n```\n\nThe `Post` record with an `id` of `1` now got updated in the database:\n\n**Post**\n\n| **id** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- |\n| `1` | `\"Hello World\"` | `null` | `true` | `1` |\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database using TypeScript and MySQL | Prisma Documentation",
    "description": "Write data to and query the database using TypeScript and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/install-prisma-client-node-cockroachdb",
    "markdown": "# Install Prisma Client: JavaScript and CockroachDB\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you update your Prisma schema, you will have to update your database schema using either `prisma migrate dev` or `prisma db push`. This will keep your database schema in sync with your Prisma schema. The commands will also regenerate Prisma Client.",
    "title": "Install Prisma Client: JavaScript and CockroachDB | Prisma Documentation",
    "description": "Install and generate Prisma Client in your project using JavaScript and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-sqlserver",
    "markdown": "# Querying the database using TypeScript and SQL Server\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-sqlserver#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nCreate a new file named `index.ts` and add the following code to it:\n\nindex.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.ts\n\n```\nasync function main() {  // ... you will write your Prisma Client queries here  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nThis should print an empty array because there are no `User` records in the database yet:\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-sqlserver#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.ts\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    email: 'alice@prisma.io',    id: 1,    name: 'Alice',    posts: [      {        content: null,        createdAt: 2020-03-21T16:45:01.246Z,        updatedAt: 2020-03-21T16:45:01.246Z,        id: 1,        published: false,        title: 'Hello World',        authorId: 1,      }    ],    profile: {      bio: 'I like turtles',      id: 1,      userId: 1,    }  }]\n```\n\nAlso note that `allUsers` is _statically typed_ thanks to [Prisma Client's generated types](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types). You can observe the type by hovering over the `allUsers` variable in your editor. It should be typed as follows:\n\n```\nconst allUsers: (User & {  posts: Post[]})[]export type Post = {  id: number  title: string  content: string | null  published: boolean  authorId: number | null}\n```\n\nThe query added new records to the `User` and the `Post` tables:\n\n**User**\n\n| **id** | **email** | **name** |\n| --- | --- | --- |\n| `1` | `\"alice@prisma.io\"` | `\"Alice\"` |\n\n**Post**\n\n| **id** | **createdAt** | **updatedAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- | --- |\n| `1` | `2020-03-21T16:45:01.246Z` | `2020-03-21T16:45:01.246Z` | `\"Hello World\"` | `null` | `false` | `1` |\n\n**Profile**\n\n| **id** | **bio** | **userId** |\n| --- | --- | --- |\n| `1` | `\"I like turtles\"` | `1` |\n\n> **Note**: The numbers in the `authorId` column on `Post` and `userId` column on `Profile` both reference the `id` column of the `User` table, meaning the `id` value `1` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.ts\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n{  id: 1,  title: 'Hello World',  content: null,  published: true,  authorId: 1}\n```\n\nThe `Post` record with an `id` of `1` now got updated in the database:\n\n**Post**\n\n| **id** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- |\n| `1` | `\"Hello World\"` | `null` | `true` | `1` |\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database using TypeScript and SQL Server | Prisma Documentation",
    "description": "Write data to and query the database using TypeScript and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files",
    "markdown": "# .env files | Prisma Documentation\n\nPrisma ORM creates a default `.env` file at your projects root. You can choose to replace this file or create a new one in the `prisma` folder, or if you choose to relocate your `prisma.schema` file, alongside that.\n\n### `.env` file locations[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files#env-file-locations \"Direct link to env-file-locations\")\n\nThe Prisma CLI looks for `.env` files, in order, in the following locations:\n\n1.  In the root folder of your project (`./.env`)\n2.  From the same folder as the schema specified by the `--schema` argument\n3.  From the same folder as the schema taken from `\"prisma\": {\"schema\": \"/path/to/schema.prisma\"}` in `package.json`\n4.  From the `./prisma` folder\n\nIf a `.env` file is located in step 1., but additional, clashing `.env` variables are located in steps 2. - 4., the CLI will throw an error. For example, if you specify a `DATABASE_URL` variable in two different `.env` files, you will get the following error:\n\n```\nError: There is a conflict between env vars in .env and prisma/.envConflicting env vars:  DATABASE_URLWe suggest to move the contents of prisma/.env to .env to consolidate your env vars.\n```\n\nThe following table describes where the Prisma CLI looks for the `.env` file:\n\n| **Command** | **schema location** | **`.env` file locations checked, in order** |\n| --- | --- | --- |\n| `prisma [command]` | `./prisma/schema.prisma` | `./.env`  <br>`./prisma/.env` |\n| `prisma [command] --schema=./a/b/schema.prisma` | `./a/b/schema.prisma` | `./.env`  <br>`./a/b/.env`  <br>`./prisma/.env` |\n| `prisma [command]` | `\"prisma\": {\"schema\": \"/path/to/schema.prisma\"}` | `.env`  <br>`./path/to/schema/.env`  <br>`./prisma/.env` |\n| `prisma [command]` | No schema (for example, when running `prisma db pull` in an empty directory) | `./.env`  <br>`./prisma/.env` |\n\nAny environment variables defined in that `.env` file will automatically be loaded when running a Prisma CLI command.\n\nwarning\n\n**Do not commit your `.env` files into version control**!\n\nRefer to the `dotenv` documentation for information about [what happens if an environment variable is defined in two places](https://www.npmjs.com/package/dotenv#what-happens-to-environment-variables-that-were-already-set).\n\n### Expanding variables[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files#expanding-variables \"Direct link to Expanding variables\")\n\nVariables stored in `.env` files can be expanded using the format specified by [dotenv-expand](https://github.com/motdotla/dotenv-expand).\n\n.env\n\n```\nDATABASE_URL=postgresql://test:test@localhost:5432/testDATABASE_URL_WITH_SCHEMA=${DATABASE_URL}?schema=public\n```\n\nThis will make the environment variable `DATABASE_URL_WITH_SCHEMA` with value `postgresql://test:test@localhost:5432/test?schema=public` available for Prisma ORM.\n\nYou can also use environment variables in the expansion that are set _outside_ of the `.env` file, for example a database URL that is set on a PaaS like Heroku or similar:\n\n```\n# environment variable already set in the environment of the systemexport DATABASE_URL=postgresql://test:test@localhost:5432/test\n```\n\n.env\n\n```\nDATABASE_URL_WITH_SCHEMA=${DATABASE_URL}?schema=foo\n```\n\nThis will make the environment variable `DATABASE_URL_WITH_SCHEMA` with value `postgresql://test:test@localhost:5432/test?schema=foo` available for Prisma ORM.\n\n### Example: Set the `DATABASE_URL` environment variable in an `.env` file[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files#example-set-the-database_url-environment-variable-in-an-env-file \"Direct link to example-set-the-database_url-environment-variable-in-an-env-file\")\n\nIt is common to load your database connection URL from an environment variable:\n\n```\n// schema.prismadatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nYou can set the `DATABASE_URL` in your `.env` file:\n\n.env\n\n```\nDATABASE_URL=postgresql://test:test@localhost:5432/test?schema=public\n```\n\nWhen you run a command that needs access to the database defined via the `datasource` block (for example, `prisma db pull`), the Prisma CLI automatically loads the `DATABASE_URL` environment variables from the `.env` file and makes it available to the CLI.",
    "title": ".env files | Prisma Documentation",
    "description": "Configure environment variables using .env files in Prisma",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-postgresql",
    "markdown": "# Querying the database using TypeScript and PostgreSQL\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-postgresql#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nCreate a new file named `index.ts` and add the following code to it:\n\nindex.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.ts\n\n```\nasync function main() {  // ... you will write your Prisma Client queries here  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nThis should print an empty array because there are no `User` records in the database yet:\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/querying-the-database-typescript-postgresql#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.ts\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    email: 'alice@prisma.io',    id: 1,    name: 'Alice',    posts: [      {        content: null,        createdAt: 2020-03-21T16:45:01.246Z,        updatedAt: 2020-03-21T16:45:01.246Z,        id: 1,        published: false,        title: 'Hello World',        authorId: 1,      }    ],    profile: {      bio: 'I like turtles',      id: 1,      userId: 1,    }  }]\n```\n\nAlso note that `allUsers` is _statically typed_ thanks to [Prisma Client's generated types](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types). You can observe the type by hovering over the `allUsers` variable in your editor. It should be typed as follows:\n\n```\nconst allUsers: (User & {  posts: Post[]})[]export type Post = {  id: number  title: string  content: string | null  published: boolean  authorId: number | null}\n```\n\nThe query added new records to the `User` and the `Post` tables:\n\n**User**\n\n| **id** | **email** | **name** |\n| --- | --- | --- |\n| `1` | `\"alice@prisma.io\"` | `\"Alice\"` |\n\n**Post**\n\n| **id** | **createdAt** | **updatedAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- | --- |\n| `1` | `2020-03-21T16:45:01.246Z` | `2020-03-21T16:45:01.246Z` | `\"Hello World\"` | `null` | `false` | `1` |\n\n**Profile**\n\n| **id** | **bio** | **userId** |\n| --- | --- | --- |\n| `1` | `\"I like turtles\"` | `1` |\n\n> **Note**: The numbers in the `authorId` column on `Post` and `userId` column on `Profile` both reference the `id` column of the `User` table, meaning the `id` value `1` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.ts\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n{  id: 1,  title: 'Hello World',  content: null,  published: true,  authorId: 1}\n```\n\nThe `Post` record with an `id` of `1` now got updated in the database:\n\n**Post**\n\n| **id** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- |\n| `1` | `\"Hello World\"` | `null` | `true` | `1` |\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database using TypeScript and PostgreSQL | Prisma Documentation",
    "description": "Write data to and query the database using TypeScript and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/using-prisma-migrate-typescript-postgresql",
    "markdown": "# Using Prisma Migrate with TypeScript and PostgreSQL\n\nIn this guide, you'll use [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) to create the tables in your database. Add the following data model to your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) in `prisma/schema.prisma`:\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  createdAt DateTime @default(now())  updatedAt DateTime @updatedAt  title     String   @db.VarChar(255)  content   String?  published Boolean  @default(false)  author    User     @relation(fields: [authorId], references: [id])  authorId  Int}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId Int     @unique}model User {  id      Int      @id @default(autoincrement())  email   String   @unique  name    String?  posts   Post[]  profile Profile?}\n```\n\nTo map your data model to the database schema, you need to use the `prisma migrate` CLI commands:\n\nnote\n\n`generate` is called under the hood by default, after running `prisma migrate dev`. If the `prisma-client-js` generator is defined in your schema, this will check if `@prisma/client` is installed and install it if it's missing.",
    "title": "Using Prisma Migrate with TypeScript and PostgreSQL | Prisma Documentation",
    "description": "Create database tables with Prisma Migrate using TypeScript and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb-node-mongodb",
    "markdown": "# Start from scratch with Prisma ORM using MongoDB and JavaScript (15 min)\n\nLearn how to create a new Node.js or TypeScript project from scratch by connecting Prisma ORM to your MongoDB database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli) and [Prisma Client](https://www.prisma.io/docs/orm/prisma-client).\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb-node-mongodb#prerequisites \"Direct link to Prerequisites\")\n\nIn order to successfully complete this guide, you need:\n\n*   [Node.js](https://nodejs.org/en/) installed on your machine\n    \n*   Access to a MongoDB 4.2+ server with a replica set deployment. We recommend using [MongoDB Atlas](https://www.mongodb.com/cloud/atlas).\n    \n    warning\n    \n    The MongoDB database connector uses transactions to support nested writes. Transactions **require** a [replica set](https://docs.mongodb.com/manual/tutorial/deploy-replica-set/) deployment. The easiest way to deploy a replica set is with [Atlas](https://docs.atlas.mongodb.com/getting-started/). It's free to get started.\n    \n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) at hand. If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n> See [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for exact version requirements.\n\n## Create project setup[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb-node-mongodb#create-project-setup \"Direct link to Create project setup\")\n\nAs a first step, create a project directory and navigate into it:\n\n```\nmkdir hello-prismacd hello-prisma\n```\n\nNext, initialize a Node.js project and add the Prisma CLI as a development dependency to it:\n\n```\nnpm init -ynpm install prisma --save-dev\n```\n\nThis creates a `package.json` with an initial setup for a Node.js app.\n\nYou can now invoke the Prisma CLI by prefixing it with `npx`:\n\nNext, set up your Prisma ORM project by creating your [Prisma Schema](https://www.prisma.io/docs/orm/prisma-schema) file with the following command:\n\nThis command does two things:\n\n*   creates a new directory called `prisma` that contains a file called `schema.prisma`, which contains the Prisma schema with your database connection variable and schema models\n*   creates the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) in the root directory of the project, which is used for defining environment variables (such as your database connection)",
    "title": "Start from scratch with Prisma ORM using MongoDB and JavaScript (15 min) | Prisma Documentation",
    "description": "Learn how to create a new Node.js project from scratch by connecting Prisma ORM to your MongoDB database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/connect-your-database-node-mongodb",
    "markdown": "# Connect your database using JavaScript and MongoDB\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database depends on the database you use. For MongoDB, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):",
    "title": "Connect your database using JavaScript and MongoDB | Prisma Documentation",
    "description": "Connect your database to your project using JavaScript and MongoDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/connect-your-database-typescript-mongodb",
    "markdown": "# Connect your database using TypeScript and MongoDB\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database depends on the database you use. For MongoDB, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):",
    "title": "Connect your database using TypeScript and MongoDB | Prisma Documentation",
    "description": "Connect your database to your project using TypeScript and MongoDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases/next-steps",
    "markdown": "# Next steps after setting up Prisma ORM with your relational database\n\nHere are a few suggestions for a number of more queries you can send with Prisma Client:\n\n**Filter all `Post` records that contain `\"hello\"`**\n\n```\nconst filteredPosts = await prisma.post.findMany({  where: {    OR: [{ title: { contains: 'hello' } }, { content: { contains: 'hello' } }],  },})\n```\n\n**Create a new `Post` record and connect it to an existing `User` record**\n\n```\nconst post = await prisma.post.create({  data: {    title: 'Join us for Prisma Day 2020',    author: {      connect: { email: 'alice@prisma.io' },    },  },})\n```\n\n**Use the fluent relations API to retrieve the `Post` records of a `User` by traversing the relations**\n\n```\nconst posts = await prisma.profile  .findUnique({    where: { id: 1 },  })  .user()  .posts()\n```\n\n**Delete a `User` record**\n\n```\nconst deletedUser = await prisma.user.delete({  where: { email: 'sarah@prisma.io' },})\n```",
    "title": "Next steps after setting up Prisma ORM with your relational database | Prisma Documentation",
    "description": "Next steps to take now that you have successfully added Prisma ORM to your new TypeScript or JavaScript project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/install-prisma-client-node-mongodb",
    "markdown": "# Install Prisma Client: JavaScript and MongoDB\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma Schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you update your Prisma schema, you will need to run the `prisma db push` command to create new indexes and regenerate Prisma Client.",
    "title": "Install Prisma Client: JavaScript and MongoDB | Prisma Documentation",
    "description": "Install and generate Prisma Client in your project using JavaScript and MongoDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/creating-the-prisma-schema-node-mongodb",
    "markdown": "# Creating the Prisma schema using JavaScript and MongoDB\n\nOpen the `prisma/schema.prisma` file and replace the default contents with the following:\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model Post {  id       String    @id @default(auto()) @map(\"_id\") @db.ObjectId  slug     String    @unique  title    String  body     String  author   User      @relation(fields: [authorId], references: [id])  authorId String    @db.ObjectId  comments Comment[]}model User {  id      String   @id @default(auto()) @map(\"_id\") @db.ObjectId  email   String   @unique  name    String?  address Address?  posts   Post[]}model Comment {  id      String @id @default(auto()) @map(\"_id\") @db.ObjectId  comment String  post    Post   @relation(fields: [postId], references: [id])  postId  String @db.ObjectId}// Address is an embedded documenttype Address {  street String  city   String  state  String  zip    String}\n```\n\nThere are also a number of subtle differences in how the schema is setup when compared to relational databases like PostgreSQL.\n\nFor example, the underlying `ID` field name is always `_id` and must be mapped with `@map(\"_id\")`.",
    "title": "Creating the Prisma schema using JavaScript and MongoDB | Prisma Documentation",
    "description": "Update the Prisma schema for MongoDB with JavaScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/creating-the-prisma-schema-typescript-mongodb",
    "markdown": "# Creating the Prisma schema using TypeScript and MongoDB\n\nOpen the `prisma/schema.prisma` file and replace the default contents with the following:\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model Post {  id       String    @id @default(auto()) @map(\"_id\") @db.ObjectId  slug     String    @unique  title    String  body     String  author   User      @relation(fields: [authorId], references: [id])  authorId String    @db.ObjectId  comments Comment[]}model User {  id      String   @id @default(auto()) @map(\"_id\") @db.ObjectId  email   String   @unique  name    String?  address Address?  posts   Post[]}model Comment {  id      String @id @default(auto()) @map(\"_id\") @db.ObjectId  comment String  post    Post   @relation(fields: [postId], references: [id])  postId  String @db.ObjectId}// Address is an embedded documenttype Address {  street String  city   String  state  String  zip    String}\n```\n\nThere are also a number of subtle differences in how the schema is setup when compared to relational databases like PostgreSQL.\n\nFor example, the underlying `ID` field name is always `_id` and must be mapped with `@map(\"_id\")`.",
    "title": "Creating the Prisma schema using TypeScript and MongoDB | Prisma Documentation",
    "description": "Update the Prisma schema for MongoDB with TypeScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/querying-the-database-typescript-mongodb",
    "markdown": "# Querying the database with TypeScript and MongoDB\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/querying-the-database-typescript-mongodb#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nCreate a new file named `index.ts` and add the following code to it:\n\nindex.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .catch(async (e) => {    console.error(e)    process.exit(1)  })  .finally(async () => {    await prisma.$disconnect()  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Connect to the database\n5.  Call the `main` function\n6.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.ts\n\n```\nasync function main() {  // ... you will write your Prisma Client queries here+  const allUsers = await prisma.user.findMany()+  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nThis should print an empty array because there are no `User` records in the database yet:\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/querying-the-database-typescript-mongodb#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post`, `User` and `Comment` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.ts\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Rich',      email: 'hello@prisma.com',      posts: {        create: {          title: 'My first post',          body: 'Lots of really interesting stuff',          slug: 'my-first-post',        },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with a new `Post` using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the other one via the `Post.author` ↔ `User.posts` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    id: '60cc9b0e001e3bfd00a6eddf',    email: 'hello@prisma.com',    name: 'Rich',    address: null,    posts: [      {        id: '60cc9bad005059d6007f45dd',        slug: 'my-first-post',        title: 'My first post',        body: 'Lots of really interesting stuff',        userId: '60cc9b0e001e3bfd00a6eddf',      },    ],  },]\n```\n\nAlso note that `allUsers` is _statically typed_ thanks to [Prisma Client's generated types](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types). You can observe the type by hovering over the `allUsers` variable in your editor. It should be typed as follows:\n\n```\nconst allUsers: (User & {  posts: Post[]})[]export type Post = {  id: number  title: string  body: string | null  published: boolean  authorId: number | null}\n```\n\nThe query added new records to the `User` and the `Post` tables:\n\n**User**\n\n| **id** | **email** | **name** |\n| --- | --- | --- |\n| `60cc9b0e001e3bfd00a6eddf` | `\"hello@prisma.com\"` | `\"Rich\"` |\n\n**Post**\n\n| **id** | **createdAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- |\n| `60cc9bad005059d6007f45dd` | `2020-03-21T16:45:01.246Z` | `\"My first post\"` | `Lots of really interesting stuff` | `false` | `60cc9b0e001e3bfd00a6eddf` |\n\n> **Note**: The unique IDs in the `authorId` column on `Post` reference the `id` column of the `User` table, meaning the `id` value `60cc9b0e001e3bfd00a6eddf` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll add a couple of comments to the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.ts\n\n```\nasync function main() {  await prisma.post.update({    where: {      slug: 'my-first-post',    },    data: {      comments: {        createMany: {          data: [            { comment: 'Great post!' },            { comment: \"Can't wait to read more!\" },          ],        },      },    },  })  const posts = await prisma.post.findMany({    include: {      comments: true,    },  })  console.dir(posts, { depth: Infinity })}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n[  {    id: '60cc9bad005059d6007f45dd',    slug: 'my-first-post',    title: 'My first post',    body: 'Lots of really interesting stuff',    userId: '60cc9b0e001e3bfd00a6eddf',    comments: [      {        id: '60cca420008a21d800578793',        postId: '60cca40300af8bf000f6ca99',        comment: 'Great post!',      },      {        id: '60cca420008a21d800578794',        postId: '60cca40300af8bf000f6ca99',        comment: \"Can't wait to try this!\",      },    ],  },]\n```\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database with TypeScript and MongoDB | Prisma Documentation",
    "description": "Write data to and query the database using TypeScript and MongoDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/install-prisma-client-typescript-mongodb",
    "markdown": "# Install Prisma Client: TypeScript and MongoDB\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you update your Prisma schema, you will need to run the `prisma db push` command to create new indexes and regenerate Prisma Client.",
    "title": "Install Prisma Client: TypeScript and MongoDB | Prisma Documentation",
    "description": "Install and generate Prisma Client in your project using TypeScript and MongoDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-postgresql",
    "markdown": "# Query your existing PostgreSQL database with TypeScript and Prisma ORM\n\n## Querying the database\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-postgresql#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database.\n\nIf you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.\n\nFor the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).\n\nCreate a new file named `index.ts` and add the following code to it:\n\nindex.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nDepending on what your models look like, the Prisma Client API will look different as well. For example, if you have a `User` model, your `PrismaClient` instance exposes a property called `user` on which you can call [CRUD](https://www.prisma.io/docs/orm/prisma-client/queries/crud) methods like `findMany`, `create` or `update`. The property is named after the model, but the first letter is lowercased (so for the `Post` model it's called `post`, for `Profile` it's called `profile`).\n\nThe following examples are all based on the models in the Prisma schema.\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.ts\n\n```\nasync function main() {  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:\n\nIf you created a database using the schema from the database introspection step, the query should print an empty array because there are no `User` records in the database yet.\n\nIf you introspected an existing database with records, the query should return an array of JavaScript objects.\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-postgresql#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database. In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.ts\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.ts\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nRun the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:",
    "title": "Query your existing PostgreSQL database with TypeScript and Prisma ORM | Prisma Documentation",
    "description": "Write data to and query the PostgreSQL database with your TypeScript and Prisma ORM project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/querying-the-database-node-mongodb",
    "markdown": "# Querying the database with JavaScript and MongoDB\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/querying-the-database-node-mongodb#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nCreate a new file named `index.js` and add the following code to it:\n\nindex.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Connect to the database\n5.  Call the `main` function\n6.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.js\n\n```\nasync function main() {-  // ... you will write your Prisma Client queries here+  const allUsers = await prisma.user.findMany()+  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nThis should print an empty array because there are no `User` records in the database yet:\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb/querying-the-database-node-mongodb#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post`, `User` and `Comment` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.js\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Rich',      email: 'hello@prisma.com',      posts: {        create: {          title: 'My first post',          body: 'Lots of really interesting stuff',          slug: 'my-first-post',        },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with a new `Post` using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the other one via the `Post.author` ↔ `User.posts` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    id: '60cc9b0e001e3bfd00a6eddf',    email: 'hello@prisma.com',    name: 'Rich',    address: null,    posts: [      {        id: '60cc9bad005059d6007f45dd',        slug: 'my-first-post',        title: 'My first post',        body: 'Lots of really interesting stuff',        userId: '60cc9b0e001e3bfd00a6eddf',      },    ],  },]\n```\n\nThe query added new records to the `User` and the `Post` tables:\n\n**User**\n\n| **id** | **email** | **name** |\n| --- | --- | --- |\n| `60cc9b0e001e3bfd00a6eddf` | `\"hello@prisma.com\"` | `\"Rich\"` |\n\n**Post**\n\n| **id** | **createdAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- |\n| `60cc9bad005059d6007f45dd` | `2020-03-21T16:45:01.246Z` | `\"My first post\"` | `Lots of really interesting stuff` | `false` | `60cc9b0e001e3bfd00a6eddf` |\n\n> **Note**: The unique IDs in the `authorId` column on `Post` reference the `id` column of the `User` table, meaning the `id` value `60cc9b0e001e3bfd00a6eddf` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll add a couple of comments to the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.js\n\n```\nasync function main() {  await prisma.post.update({    where: {      slug: 'my-first-post',    },    data: {      comments: {        createMany: {          data: [            { comment: 'Great post!' },            { comment: \"Can't wait to read more!\" },          ],        },      },    },  })  const posts = await prisma.post.findMany({    include: {      comments: true,    },  })  console.dir(posts, { depth: Infinity })}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n[  {    id: '60cc9bad005059d6007f45dd',    slug: 'my-first-post',    title: 'My first post',    body: 'Lots of really interesting stuff',    userId: '60cc9b0e001e3bfd00a6eddf',    comments: [      {        id: '60cca420008a21d800578793',        postId: '60cca40300af8bf000f6ca99',        comment: 'Great post!',      },      {        id: '60cca420008a21d800578794',        postId: '60cca40300af8bf000f6ca99',        comment: \"Can't wait to try this!\",      },    ],  },]\n```\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database with JavaScript and MongoDB | Prisma Documentation",
    "description": "Write data to and query the database using JavaScript and MongoDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-sqlserver",
    "markdown": "# Query your existing SQL Server database with TypeScript and Prisma ORM\n\n## Querying the database\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-sqlserver#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database.\n\nIf you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.\n\nFor the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).\n\nCreate a new file named `index.ts` and add the following code to it:\n\nindex.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nDepending on what your models look like, the Prisma Client API will look different as well. For example, if you have a `User` model, your `PrismaClient` instance exposes a property called `user` on which you can call [CRUD](https://www.prisma.io/docs/orm/prisma-client/queries/crud) methods like `findMany`, `create` or `update`. The property is named after the model, but the first letter is lowercased (so for the `Post` model it's called `post`, for `Profile` it's called `profile`).\n\nThe following examples are all based on the models in the Prisma schema.\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.ts\n\n```\nasync function main() {  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:\n\nIf you created a database using the schema from the database introspection step, the query should print an empty array because there are no `User` records in the database yet.\n\nIf you introspected an existing database with records, the query should return an array of JavaScript objects.\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-sqlserver#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database. In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.ts\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.ts\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nRun the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:",
    "title": "Query your existing SQL Server database with TypeScript and Prisma ORM | Prisma Documentation",
    "description": "Write data to and query the SQL Server database with your TypeScript and Prisma ORM project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-node-cockroachdb",
    "markdown": "# Evolve your Prisma schema with Prisma Migrate : JavaScript-CockroachDB\n\nIn this section, you will evolve your Prisma schema and then generate and apply the migration to your database with [`prisma migrate dev`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-dev).\n\nFor the purpose of this guide, we'll make the following changes to the Prisma schema:\n\nOnce you've made the changes to your schema, your schema should resemble the one below:\n\nTo apply your Prisma schema changes to your database, use the `prisma migrate dev` CLI command:\n\nThe following migration will be generated and saved in your `prisma/migrations` folder:\n\n```\n -- CreateTableCREATE TABLE \"Tag\" (    \"id\" SERIAL NOT NULL,    \"name\" VARCHAR(255) NOT NULL,    CONSTRAINT \"Tag_pkey\" PRIMARY KEY (\"id\"));-- CreateTableCREATE TABLE \"_PostToTag\" (    \"A\" INTEGER NOT NULL,    \"B\" INTEGER NOT NULL);-- CreateIndexCREATE UNIQUE INDEX \"_PostToTag_AB_unique\" ON \"_PostToTag\"(\"A\", \"B\");-- CreateIndexCREATE INDEX \"_PostToTag_B_index\" ON \"_PostToTag\"(\"B\");-- AddForeignKeyALTER TABLE \"_PostToTag\" ADD CONSTRAINT \"_PostToTag_A_fkey\" FOREIGN KEY (\"A\") REFERENCES \"Post\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;-- AddForeignKeyALTER TABLE \"_PostToTag\" ADD CONSTRAINT \"_PostToTag_B_fkey\" FOREIGN KEY (\"B\") REFERENCES \"Tag\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;\n```",
    "title": "Evolve your Prisma schema with Prisma Migrate : JavaScript-CockroachDB | Prisma Documentation",
    "description": "Evolve your Prisma schema with Prisma Migrate inside of your JavaScript and CockroachDB project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-node-postgresql",
    "markdown": "# Evolve your Prisma schema with Prisma Migrate : JavaScript-PostgreSQL\n\n## Add a `Tag` model to your schema[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-node-postgresql#add-a-tag-model-to-your-schema \"Direct link to add-a-tag-model-to-your-schema\")\n\nIn this section, you will evolve your Prisma schema and then generate and apply the migration to your database with [`prisma migrate dev`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-dev).\n\nFor the purpose of this guide, we'll make the following changes to the Prisma schema:\n\n1.  Create a new model called `Tag` with the following fields:\n    *   `id`: an auto-incrementing integer that will be the primary key for the model\n    *   `name`: a non-null `String`\n    *   `posts`: an implicit many-to-many relation field that links to the `Post` model\n2.  Update the `Post` model with a `tags` field with an implicit many-to-many relation field that links to the `Tag` model\n\nOnce you've made the changes to your schema, your schema should resemble the one below:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  Int  user      User     @relation(fields: [authorId], references: [id])  tags      Tag[]}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int     @unique  user   User    @relation(fields: [userId], references: [id])}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique @db.VarChar(255)  post    Post[]  profile Profile?}model Tag {  id    Int    @id @default(autoincrement())  name  String  posts Post[]}\n```\n\nTo apply your Prisma schema changes to your database, use the `prisma migrate dev` CLI command:\n\n```\nnpx prisma migrate dev --name tags-model\n```\n\nThis command will:\n\n1.  Create a new SQL migration file for the migration\n2.  Apply the generated SQL migration to the database\n3.  Regenerate Prisma Client\n\nThe following migration will be generated and saved in your `prisma/migrations` folder:\n\nprisma/migrations/TIMESTAMP\\_tags\\_model.sql\n\n```\n -- CreateTableCREATE TABLE \"Tag\" (    \"id\" SERIAL NOT NULL,    \"name\" VARCHAR(255) NOT NULL,    CONSTRAINT \"Tag_pkey\" PRIMARY KEY (\"id\"));-- CreateTableCREATE TABLE \"_PostToTag\" (    \"A\" INTEGER NOT NULL,    \"B\" INTEGER NOT NULL);-- CreateIndexCREATE UNIQUE INDEX \"_PostToTag_AB_unique\" ON \"_PostToTag\"(\"A\", \"B\");-- CreateIndexCREATE INDEX \"_PostToTag_B_index\" ON \"_PostToTag\"(\"B\");-- AddForeignKeyALTER TABLE \"_PostToTag\" ADD CONSTRAINT \"_PostToTag_A_fkey\" FOREIGN KEY (\"A\") REFERENCES \"Post\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;-- AddForeignKeyALTER TABLE \"_PostToTag\" ADD CONSTRAINT \"_PostToTag_B_fkey\" FOREIGN KEY (\"B\") REFERENCES \"Tag\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;\n```\n\nCongratulations, you just evolved your database with Prisma Migrate 🚀",
    "title": "Evolve your Prisma schema with Prisma Migrate : JavaScript-PostgreSQL | Prisma Documentation",
    "description": "Evolve your Prisma schema with Prisma Migrate inside of your JavaScript and PostgreSQL project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-node-mysql",
    "markdown": "# Evolve your Prisma schema with Prisma Migrate : JavaScript-MySQL\n\n## Add a `Tag` model to your schema[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-node-mysql#add-a-tag-model-to-your-schema \"Direct link to add-a-tag-model-to-your-schema\")\n\nIn this section, you will evolve your Prisma schema and then generate and apply the migration to your database with [`prisma migrate dev`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-dev).\n\nFor the purpose of this guide, we'll make the following changes to the Prisma schema:\n\n1.  Create a new model called `Tag` with the following fields:\n    *   `id`: an auto-incrementing integer that will be the primary key for the model\n    *   `name`: a non-null `String`\n    *   `posts`: an implicit many-to-many relation field that links to the `Post` model\n2.  Update the `Post` model with a `tags` field with an implicit many-to-many relation field that links to the `Tag` model\n\nOnce you've made the changes to your schema, your schema should resemble the one below:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  Int  user      User     @relation(fields: [authorId], references: [id])  tags      Tag[]}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int     @unique  user   User    @relation(fields: [userId], references: [id])}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique @db.VarChar(255)  post    Post[]  profile Profile?}model Tag {  id    Int    @id @default(autoincrement())  name  String  posts Post[]}\n```\n\nTo apply your Prisma schema changes to your database, use the `prisma migrate dev` CLI command:\n\n```\nnpx prisma migrate dev --name tags-model\n```\n\nThis command will:\n\n1.  Create a new SQL migration file for the migration\n2.  Apply the generated SQL migration to the database\n3.  Regenerate Prisma Client\n\nThe following migration will be generated and saved in your `prisma/migrations` folder:\n\nprisma/migrations/TIMESTAMP\\_tags\\_model.sql\n\n```\n-- CreateTableCREATE TABLE Tag (    id SERIAL NOT NULL,    name VARCHAR(255) NOT NULL,    CONSTRAINT Tag_pkey PRIMARY KEY (id));-- CreateTableCREATE TABLE _PostToTag (    A INTEGER NOT NULL,    B INTEGER NOT NULL);-- CreateIndexCREATE UNIQUE INDEX _PostToTag_AB_unique ON _PostToTag(A, B);-- CreateIndexCREATE INDEX _PostToTag_B_index ON _PostToTag(B);-- AddForeignKeyALTER TABLE _PostToTag ADD CONSTRAINT _PostToTag_A_fkey FOREIGN KEY (A) REFERENCES Post(id) ON DELETE CASCADE ON UPDATE CASCADE;-- AddForeignKeyALTER TABLE _PostToTag ADD CONSTRAINT _PostToTag_B_fkey FOREIGN KEY (B) REFERENCES Tag(id) ON DELETE CASCADE ON UPDATE CASCADE;\n```\n\nCongratulations, you just evolved your database with Prisma Migrate 🚀",
    "title": "Evolve your Prisma schema with Prisma Migrate : JavaScript-MySQL | Prisma Documentation",
    "description": "Evolve your Prisma schema with Prisma Migrate inside of your JavaScript and MySQL project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-node-postgresql",
    "markdown": "# Add Prisma ORM to an existing project that using JavaScript and PostgreSQL(15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\nAs a first step, navigate into your project directory that contains the `package.json` file.\n\n```\nnpm install prisma --save-dev\n```\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:",
    "title": "Add Prisma ORM to an existing project that using JavaScript and PostgreSQL(15 min) | Prisma Documentation",
    "description": "Learn how to add Prisma ORM to an existing Node.js project by connecting it to your PostgreSQL database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-node-mysql",
    "markdown": "# Add Prisma ORM to an existing project using JavaScript and MySQL (15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\nAs a first step, navigate into your project directory that contains the `package.json` file.\n\n```\nnpm install prisma --save-dev\n```\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:",
    "title": "Add Prisma ORM to an existing project using JavaScript and MySQL (15 min) | Prisma Documentation",
    "description": "Learn how to add Prisma ORM to an existing Node.js project by connecting it to your MySQL database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-node-planetscale",
    "markdown": "# Add Prisma ORM to an existing project using JavaScript and PlanetScale (15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\nAs a first step, navigate into your project directory that contains the `package.json` file.\n\n```\nnpm install prisma --save-dev\n```\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:",
    "title": "Add Prisma ORM to an existing project using JavaScript and PlanetScale (15 min) | Prisma Documentation",
    "description": "Learn how to add Prisma ORM to an existing Node.js project by connecting it to your PlanetScale database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-node-mysql",
    "markdown": "# Baseline with Prisma ORM, JavaScript, and MySQL\n\nTo use Prisma Migrate with the database you introspected in the last section, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nBaselining refers to initializing your migration history for a database that might already contain data and **cannot be reset**, such as your production database. Baselining tells Prisma Migrate to assume that one or more migrations have already been applied to your database.\n\nTo baseline your database, use [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) to compare your schema and database, and save the output into a SQL file.\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n```\n-- CreateTableCREATE TABLE `Post` (    `id` INTEGER NOT NULL AUTO_INCREMENT,    `title` VARCHAR(255) NOT NULL,    `createdAt` TIMESTAMP(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0),    `content` TEXT NULL,    `published` BOOLEAN NOT NULL DEFAULT false,    `authorId` INTEGER NOT NULL,    INDEX `authorId`(`authorId`),    PRIMARY KEY (`id`)) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;-- CreateTableCREATE TABLE `Profile` (    `id` INTEGER NOT NULL AUTO_INCREMENT,    `bio` TEXT NULL,    `userId` INTEGER NOT NULL,    UNIQUE INDEX `userId`(`userId`),    PRIMARY KEY (`id`)) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;-- CreateTableCREATE TABLE `User` (    `id` INTEGER NOT NULL AUTO_INCREMENT,    `name` VARCHAR(255) NULL,    `email` VARCHAR(255) NOT NULL,    UNIQUE INDEX `email`(`email`),    PRIMARY KEY (`id`)) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;-- AddForeignKeyALTER TABLE `Post` ADD CONSTRAINT `Post_ibfk_1` FOREIGN KEY (`authorId`) REFERENCES `User`(`id`) ON DELETE RESTRICT ON UPDATE RESTRICT;-- AddForeignKeyALTER TABLE `Profile` ADD CONSTRAINT `Profile_ibfk_1` FOREIGN KEY (`userId`) REFERENCES `User`(`id`) ON DELETE RESTRICT ON UPDATE RESTRICT;\n```\n\nReview the SQL migration file to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.",
    "title": "Baseline with Prisma ORM, JavaScript, and MySQL | Prisma Documentation",
    "description": "Baseline your database with Prisma ORM, JavaScript, and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-node-sqlserver",
    "markdown": "# Add Prisma to an existing project using JavaScript and SQL Server (15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\nAs a first step, navigate into your project directory that contains the `package.json` file.\n\n```\nnpm install prisma --save-dev\n```\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:",
    "title": "Add Prisma to an existing project using JavaScript and SQL Server (15 min) | Prisma Documentation",
    "description": "Learn how to add Prisma to an existing Node.js project by connecting it to your SQL Server database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-node-postgresql",
    "markdown": "# Baseline with Prisma ORM, JavaScript, and PostgreSQL\n\n## Baseline your database\n\n## Create an initial migration[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-node-postgresql#create-an-initial-migration \"Direct link to Create an initial migration\")\n\nTo use Prisma Migrate with the database you introspected in the last section, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nBaselining refers to initializing your migration history for a database that might already contain data and **cannot be reset**, such as your production database. Baselining tells Prisma Migrate to assume that one or more migrations have already been applied to your database.\n\nTo baseline your database, use [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) to compare your schema and database, and save the output into a SQL file.\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\n```\nmkdir -p prisma/migrations/0_init\n```\n\ninfo\n\n`-p` will recursively create any missing folders in the path you provide.\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n*   `--from-empty`: assumes the data model you're migrating from is empty\n*   `--to-schema-datamodel`: the current database state using the URL in the `datasource` block\n*   `--script`: output a SQL script\n\n```\nnpx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql\n```\n\n## Review the migration[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-node-postgresql#review-the-migration \"Direct link to Review the migration\")\n\nThe command will generate a migration that should resemble the following script:\n\nprisma/migrations/0\\_init/migration.sql\n\n```\n-- CreateTableCREATE TABLE \"Post\" (    \"id\" SERIAL NOT NULL,    \"title\" VARCHAR(255) NOT NULL,    \"createdAt\" TIMESTAMP(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,    \"content\" TEXT,    \"published\" BOOLEAN NOT NULL DEFAULT false,    \"authorId\" INTEGER NOT NULL,    CONSTRAINT \"Post_pkey\" PRIMARY KEY (\"id\"));-- CreateTableCREATE TABLE \"Profile\" (    \"id\" SERIAL NOT NULL,    \"bio\" TEXT,    \"userId\" INTEGER NOT NULL,    CONSTRAINT \"Profile_pkey\" PRIMARY KEY (\"id\"));-- CreateTableCREATE TABLE \"User\" (    \"id\" SERIAL NOT NULL,    \"name\" VARCHAR(255),    \"email\" VARCHAR(255) NOT NULL,    CONSTRAINT \"User_pkey\" PRIMARY KEY (\"id\"));-- CreateIndexCREATE UNIQUE INDEX \"Profile_userId_key\" ON \"Profile\"(\"userId\");-- CreateIndexCREATE UNIQUE INDEX \"User_email_key\" ON \"User\"(\"email\");-- AddForeignKeyALTER TABLE \"Post\" ADD CONSTRAINT \"Post_authorId_fkey\" FOREIGN KEY (\"authorId\") REFERENCES \"User\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION;-- AddForeignKeyALTER TABLE \"Profile\" ADD CONSTRAINT \"Profile_userId_fkey\" FOREIGN KEY (\"userId\") REFERENCES \"User\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION;\n```\n\nReview the SQL migration file to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\n```\nnpx prisma migrate resolve --applied 0_init\n```\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.",
    "title": "Baseline with Prisma ORM, JavaScript, and PostgreSQL | Prisma Documentation",
    "description": "Baseline your database with Prisma ORM, JavaScript, and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-node-sqlserver",
    "markdown": "# Evolve your Prisma schema with Prisma Migrate : JavaScript-sqlserver\n\nIn this section, you will evolve your Prisma schema and then generate and apply the migration to your database with [`prisma migrate dev`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-dev).\n\nFor the purpose of this guide, we'll make the following changes to the Prisma schema:\n\nOnce you've made the changes to your schema, your schema should resemble the one below:\n\nTo apply your Prisma schema changes to your database, use the `prisma migrate dev` CLI command:\n\nThe following migration will be generated and saved in your `prisma/migrations` folder:\n\n```\n -- CreateTableCREATE TABLE [dbo].[Tag] (    [id] SERIAL NOT NULL,    [name] VARCHAR(255) NOT NULL,    CONSTRAINT [Tag_pkey] PRIMARY KEY ([id]));-- CreateTableCREATE TABLE [dbo].[_PostToTag] (    [A] INTEGER NOT NULL,    [B] INTEGER NOT NULL);-- CreateIndexCREATE UNIQUE INDEX [_PostToTag_AB_unique] ON _PostToTag([A], [B]);-- CreateIndexCREATE INDEX [_PostToTag_B_index] ON [_PostToTag]([B]);-- AddForeignKeyALTER TABLE [dbo].[_PostToTag] ADD CONSTRAINT [_PostToTag_A_fkey] FOREIGN KEY ([A]) REFERENCES [dbo].[Post]([id]) ON DELETE CASCADE ON UPDATE CASCADE;-- AddForeignKeyALTER TABLE [dbo].[_PostToTag] ADD CONSTRAINT [_PostToTag_B_fkey] FOREIGN KEY ([B]) REFERENCES [dbo].[Tag]([id]) ON DELETE CASCADE ON UPDATE CASCADE;\n```",
    "title": "Evolve your Prisma schema with Prisma Migrate : JavaScript-sqlserver | Prisma Documentation",
    "description": "Evolve your Prisma schema with Prisma Migrate inside of your JavaScript and SQL Server project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-node-cockroachdb",
    "markdown": "# Add Prisma ORM to an existing project using JavaScript and CockroachDB (15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to the [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\nAs a first step, navigate into your project directory that contains the `package.json` file.\n\n```\nnpm install prisma --save-dev\n```\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:",
    "title": "Add Prisma ORM to an existing project using JavaScript and CockroachDB (15 min) | Prisma Documentation",
    "description": "Learn how to add Prisma ORM to an existing Node.js project by connecting it to your CockroachDB database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-typescript-cockroachdb",
    "markdown": "# Evolve your Prisma schema with Prisma Migrate : TypeScript-cockroachdb\n\n## Add a `Tag` model to your schema[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-typescript-cockroachdb#add-a-tag-model-to-your-schema \"Direct link to add-a-tag-model-to-your-schema\")\n\nIn this section, you will evolve your Prisma schema and then generate and apply the migration to your database with [`prisma migrate dev`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-dev).\n\nFor the purpose of this guide, we'll make the following changes to the Prisma schema:\n\n1.  Create a new model called `Tag` with the following fields:\n    *   `id`: an auto-incrementing integer that will be the primary key for the model\n    *   `name`: a non-null `String`\n    *   `posts`: an implicit many-to-many relation field that links to the `Post` model\n2.  Update the `Post` model with a `tags` field with an implicit many-to-many relation field that links to the `Tag` model\n\nOnce you've made the changes to your schema, your schema should resemble the one below:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  Int  user      User     @relation(fields: [authorId], references: [id])  tags      Tag[]}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int     @unique  user   User    @relation(fields: [userId], references: [id])}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique @db.VarChar(255)  post    Post[]  profile Profile?}model Tag {  id    Int    @id @default(autoincrement())  name  String  posts Post[]}\n```\n\nTo apply your Prisma schema changes to your database, use the `prisma migrate dev` CLI command:\n\n```\nnpx prisma migrate dev --name tags-model\n```\n\nThis command will:\n\n1.  Create a new SQL migration file for the migration\n2.  Apply the generated SQL migration to the database\n3.  Regenerate Prisma Client\n\nThe following migration will be generated and saved in your `prisma/migrations` folder:\n\nprisma/migrations/TIMESTAMP\\_tags\\_model.sql\n\n```\n -- CreateTableCREATE TABLE \"Tag\" (    \"id\" SERIAL NOT NULL,    \"name\" VARCHAR(255) NOT NULL,    CONSTRAINT \"Tag_pkey\" PRIMARY KEY (\"id\"));-- CreateTableCREATE TABLE \"_PostToTag\" (    \"A\" INTEGER NOT NULL,    \"B\" INTEGER NOT NULL);-- CreateIndexCREATE UNIQUE INDEX \"_PostToTag_AB_unique\" ON \"_PostToTag\"(\"A\", \"B\");-- CreateIndexCREATE INDEX \"_PostToTag_B_index\" ON \"_PostToTag\"(\"B\");-- AddForeignKeyALTER TABLE \"_PostToTag\" ADD CONSTRAINT \"_PostToTag_A_fkey\" FOREIGN KEY (\"A\") REFERENCES \"Post\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;-- AddForeignKeyALTER TABLE \"_PostToTag\" ADD CONSTRAINT \"_PostToTag_B_fkey\" FOREIGN KEY (\"B\") REFERENCES \"Tag\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;\n```\n\nCongratulations, you just evolved your database with Prisma Migrate 🚀",
    "title": "Evolve your Prisma schema with Prisma Migrate : TypeScript-cockroachdb | Prisma Documentation",
    "description": "Evolve your Prisma schema with Prisma Migrate inside of your TypeScript and CockroachDB project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-typescript-mysql",
    "markdown": "# Evolve your Prisma schema with Prisma Migrate : TypeScript-mysql\n\n## Add a `Tag` model to your schema[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-typescript-mysql#add-a-tag-model-to-your-schema \"Direct link to add-a-tag-model-to-your-schema\")\n\nIn this section, you will evolve your Prisma schema and then generate and apply the migration to your database with [`prisma migrate dev`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-dev).\n\nFor the purpose of this guide, we'll make the following changes to the Prisma schema:\n\n1.  Create a new model called `Tag` with the following fields:\n    *   `id`: an auto-incrementing integer that will be the primary key for the model\n    *   `name`: a non-null `String`\n    *   `posts`: an implicit many-to-many relation field that links to the `Post` model\n2.  Update the `Post` model with a `tags` field with an implicit many-to-many relation field that links to the `Tag` model\n\nOnce you've made the changes to your schema, your schema should resemble the one below:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  Int  user      User     @relation(fields: [authorId], references: [id])  tags      Tag[]}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int     @unique  user   User    @relation(fields: [userId], references: [id])}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique @db.VarChar(255)  post    Post[]  profile Profile?}model Tag {  id    Int    @id @default(autoincrement())  name  String  posts Post[]}\n```\n\nTo apply your Prisma schema changes to your database, use the `prisma migrate dev` CLI command:\n\n```\nnpx prisma migrate dev --name tags-model\n```\n\nThis command will:\n\n1.  Create a new SQL migration file for the migration\n2.  Apply the generated SQL migration to the database\n3.  Regenerate Prisma Client\n\nThe following migration will be generated and saved in your `prisma/migrations` folder:\n\nprisma/migrations/TIMESTAMP\\_tags\\_model.sql\n\n```\n-- CreateTableCREATE TABLE Tag (    id SERIAL NOT NULL,    name VARCHAR(255) NOT NULL,    CONSTRAINT Tag_pkey PRIMARY KEY (id));-- CreateTableCREATE TABLE _PostToTag (    A INTEGER NOT NULL,    B INTEGER NOT NULL);-- CreateIndexCREATE UNIQUE INDEX _PostToTag_AB_unique ON _PostToTag(A, B);-- CreateIndexCREATE INDEX _PostToTag_B_index ON _PostToTag(B);-- AddForeignKeyALTER TABLE _PostToTag ADD CONSTRAINT _PostToTag_A_fkey FOREIGN KEY (A) REFERENCES Post(id) ON DELETE CASCADE ON UPDATE CASCADE;-- AddForeignKeyALTER TABLE _PostToTag ADD CONSTRAINT _PostToTag_B_fkey FOREIGN KEY (B) REFERENCES Tag(id) ON DELETE CASCADE ON UPDATE CASCADE;\n```\n\nCongratulations, you just evolved your database with Prisma Migrate 🚀",
    "title": "Evolve your Prisma schema with Prisma Migrate : TypeScript-mysql | Prisma Documentation",
    "description": "Evolve your Prisma schema with Prisma Migrate inside of your TypeScript and MySQL project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-node-sqlserver",
    "markdown": "# Baseline with Prisma ORM, JavaScript, and SQL Server\n\nTo use Prisma Migrate with the database you introspected in the last section, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nBaselining refers to initializing your migration history for a database that might already contain data and **cannot be reset**, such as your production database. Baselining tells Prisma Migrate to assume that one or more migrations have already been applied to your database.\n\nTo baseline your database, use [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) to compare your schema and database, and save the output into a SQL file.\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n```\nCREATE TABLE [dbo].[Post] (    [id] INT NOT NULL IDENTITY(1,1),    [createdAt] DATETIME2 NOT NULL CONSTRAINT [Post_createdAt_df] DEFAULT CURRENT_TIMESTAMP,    [updatedAt] DATETIME2 NOT NULL,    [title] VARCHAR(255) NOT NULL,    [content] NVARCHAR(1000),    [published] BIT NOT NULL CONSTRAINT [Post_published_df] DEFAULT 0,    [authorId] INT NOT NULL,    CONSTRAINT [Post_pkey] PRIMARY KEY ([id]));CREATE TABLE [dbo].[Profile] (    [id] INT NOT NULL IDENTITY(1,1),    [bio] NVARCHAR(1000),    [userId] INT NOT NULL,    CONSTRAINT [Profile_pkey] PRIMARY KEY ([id]),    CONSTRAINT [Profile_userId_key] UNIQUE ([userId]));CREATE TABLE [dbo].[User] (    [id] INT NOT NULL IDENTITY(1,1),    [email] NVARCHAR(1000) NOT NULL,    [name] NVARCHAR(1000),    CONSTRAINT [User_pkey] PRIMARY KEY ([id]),    CONSTRAINT [User_email_key] UNIQUE ([email]));ALTER TABLE [dbo].[Post] ADD CONSTRAINT [Post_authorId_fkey] FOREIGN KEY ([authorId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;ALTER TABLE [dbo].[Profile] ADD CONSTRAINT [Profile_userId_fkey] FOREIGN KEY ([userId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;\n```\n\nReview the SQL migration file to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.",
    "title": "Baseline with Prisma ORM, JavaScript, and SQL Server | Prisma Documentation",
    "description": "Baseline your database with Prisma ORM, JavaScript, and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-typescript-cockroachdb",
    "markdown": "# Baseline with Prisma ORM, TypeScript, and CockroachDB\n\nTo use Prisma Migrate with the database you introspected in the last section, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nBaselining refers to initializing your migration history for a database that might already contain data and **cannot be reset**, such as your production database. Baselining tells Prisma Migrate to assume that one or more migrations have already been applied to your database.\n\nTo baseline your database, use [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) to compare your schema and database, and save the output into a SQL file.\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n```\nCREATE TABLE \"User\" (  id INT8 PRIMARY KEY DEFAULT unique_rowid(),  name STRING(255),  email STRING(255) UNIQUE NOT NULL);CREATE TABLE \"Post\" (  id INT8 PRIMARY KEY DEFAULT unique_rowid(),  title STRING(255) UNIQUE NOT NULL,  \"createdAt\" TIMESTAMP NOT NULL DEFAULT now(),  content STRING,  published BOOLEAN NOT NULL DEFAULT false,  \"authorId\" INT8 NOT NULL,  FOREIGN KEY (\"authorId\") REFERENCES \"User\"(id));CREATE TABLE \"Profile\" (  id INT8 PRIMARY KEY DEFAULT unique_rowid(),  bio STRING,  \"userId\" INT8 UNIQUE NOT NULL,  FOREIGN KEY (\"userId\") REFERENCES \"User\"(id));\n```",
    "title": "Baseline with Prisma ORM, TypeScript, and CockroachDB | Prisma Documentation",
    "description": "Baseline your database with Prisma ORM, TypeScript, and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-node-cockroachdb",
    "markdown": "# Connect your existing database using JavaScript and CockroachDB\n\n## Connecting your database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-node-cockroachdb#connecting-your-database \"Direct link to Connecting your database\")\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL as the `provider`. For CockroachDB, you need to edit the `datasource` block to use the `cockroachdb` provider instead:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"cockroachdb\"  url      = env(\"DATABASE_URL\")}\n```\n\nThe `url` is [set via an environment variable](https://www.prisma.io/docs/orm/more/development-environment/environment-variables) which is defined in `.env`. You now need to adjust the connection URL to point to your own database.\n\n### Connection URL\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database depends on the database you use. CockroachDB uses the PostgreSQL connection URL format, which has the following structure (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?PARAMETERS\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running. The default for CockroachDB is `26257`.\n*   `DATABASE`: The name of the database\n*   `PARAMETERS`: Any additional connection parameters. See the CockroachDB documentation [here](https://www.cockroachlabs.com/docs/stable/connection-parameters.html#additional-connection-parameters).\n\nFor a [CockroachDB Serverless](https://www.cockroachlabs.com/docs/cockroachcloud/quickstart.html) or [Cockroach Dedicated](https://www.cockroachlabs.com/docs/cockroachcloud/quickstart-trial-cluster) database hosted on [CockroachDB Cloud](https://www.cockroachlabs.com/get-started-cockroachdb/), the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://<myusername>:<mypassword>@<short-id>.<region>.cockroachlabs.cloud:26257/defaultdb?sslmode=verify-full&sslrootcert=$HOME/.postgresql/root.crt&options=--<mycluster>\"\n```\n\nTo find your connection string on CockroachDB Cloud, click the 'Connect' button on the overview page for your database cluster, and select the 'Connection string' tab.\n\nFor a [CockroachDB database hosted locally](https://www.cockroachlabs.com/docs/stable/secure-a-cluster.html), the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://root@localhost:26257?sslmode=disable\"\n```\n\nYour connection string is displayed as part of the welcome text when starting CockroachDB from the command line.",
    "title": "Connect your existing database using JavaScript and CockroachDB | Prisma Documentation",
    "description": "Connect your database to your existing project using JavaScript and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-typescript-postgresql",
    "markdown": "# Evolve your Prisma schema with Prisma Migrate : TypeScript-postgresql\n\n## Add a `Tag` model to your schema[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-typescript-postgresql#add-a-tag-model-to-your-schema \"Direct link to add-a-tag-model-to-your-schema\")\n\nIn this section, you will evolve your Prisma schema and then generate and apply the migration to your database with [`prisma migrate dev`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-dev).\n\nFor the purpose of this guide, we'll make the following changes to the Prisma schema:\n\n1.  Create a new model called `Tag` with the following fields:\n    *   `id`: an auto-incrementing integer that will be the primary key for the model\n    *   `name`: a non-null `String`\n    *   `posts`: an implicit many-to-many relation field that links to the `Post` model\n2.  Update the `Post` model with a `tags` field with an implicit many-to-many relation field that links to the `Tag` model\n\nOnce you've made the changes to your schema, your schema should resemble the one below:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  Int  user      User     @relation(fields: [authorId], references: [id])  tags      Tag[]}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int     @unique  user   User    @relation(fields: [userId], references: [id])}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique @db.VarChar(255)  post    Post[]  profile Profile?}model Tag {  id    Int    @id @default(autoincrement())  name  String  posts Post[]}\n```\n\nTo apply your Prisma schema changes to your database, use the `prisma migrate dev` CLI command:\n\n```\nnpx prisma migrate dev --name tags-model\n```\n\nThis command will:\n\n1.  Create a new SQL migration file for the migration\n2.  Apply the generated SQL migration to the database\n3.  Regenerate Prisma Client\n\nThe following migration will be generated and saved in your `prisma/migrations` folder:\n\nprisma/migrations/TIMESTAMP\\_tags\\_model.sql\n\n```\n -- CreateTableCREATE TABLE \"Tag\" (    \"id\" SERIAL NOT NULL,    \"name\" VARCHAR(255) NOT NULL,    CONSTRAINT \"Tag_pkey\" PRIMARY KEY (\"id\"));-- CreateTableCREATE TABLE \"_PostToTag\" (    \"A\" INTEGER NOT NULL,    \"B\" INTEGER NOT NULL);-- CreateIndexCREATE UNIQUE INDEX \"_PostToTag_AB_unique\" ON \"_PostToTag\"(\"A\", \"B\");-- CreateIndexCREATE INDEX \"_PostToTag_B_index\" ON \"_PostToTag\"(\"B\");-- AddForeignKeyALTER TABLE \"_PostToTag\" ADD CONSTRAINT \"_PostToTag_A_fkey\" FOREIGN KEY (\"A\") REFERENCES \"Post\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;-- AddForeignKeyALTER TABLE \"_PostToTag\" ADD CONSTRAINT \"_PostToTag_B_fkey\" FOREIGN KEY (\"B\") REFERENCES \"Tag\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;\n```\n\nCongratulations, you just evolved your database with Prisma Migrate 🚀",
    "title": "Evolve your Prisma schema with Prisma Migrate : TypeScript-postgresql | Prisma Documentation",
    "description": "Evolve your Prisma schema with Prisma Migrate inside of your TypeScript and PostgreSQL project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-node-mysql",
    "markdown": "# Connect your existing database using JavaScript and MySQL\n\n## Connecting your database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-node-mysql#connecting-your-database \"Direct link to Connecting your database\")\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL, so you first need to switch the `provider` to `mysql`:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mysql\"  url      = env(\"DATABASE_URL\")}\n```\n\nIn this case, the `url` is [set via an environment variable](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"mysql://johndoe:randompassword@localhost:3306/mydb\"\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\n### Connection URL\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database typically depends on the database you use. For MySQL, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running (typically `3306` for MySQL)\n*   `DATABASE`: The name of the [database](https://dev.mysql.com/doc/refman/8.0/en/creating-database.html)\n\nAs an example, for a MySQL database hosted on AWS RDS, the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) might look similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://johndoe:XXX@mysql–instance1.123456789012.us-east-1.rds.amazonaws.com:3306/mydb\"\n```\n\nWhen running MySQL locally, your connection URL typically looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://root:randompassword@localhost:3306/mydb\"\n```",
    "title": "Connect your existing database using JavaScript and MySQL | Prisma Documentation",
    "description": "Connect your database to your existing project using JavaScript and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-typescript-sqlserver",
    "markdown": "# Evolve your Prisma schema with Prisma Migrate : TypeScript-sql-server\n\n## Add a `Tag` model to your schema[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/evolve-your-schema-typescript-sqlserver#add-a-tag-model-to-your-schema \"Direct link to add-a-tag-model-to-your-schema\")\n\nIn this section, you will evolve your Prisma schema and then generate and apply the migration to your database with [`prisma migrate dev`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-dev).\n\nFor the purpose of this guide, we'll make the following changes to the Prisma schema:\n\n1.  Create a new model called `Tag` with the following fields:\n    *   `id`: an auto-incrementing integer that will be the primary key for the model\n    *   `name`: a non-null `String`\n    *   `posts`: an implicit many-to-many relation field that links to the `Post` model\n2.  Update the `Post` model with a `tags` field with an implicit many-to-many relation field that links to the `Tag` model\n\nOnce you've made the changes to your schema, your schema should resemble the one below:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  Int  user      User     @relation(fields: [authorId], references: [id])  tags      Tag[]}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int     @unique  user   User    @relation(fields: [userId], references: [id])}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique @db.VarChar(255)  post    Post[]  profile Profile?}model Tag {  id    Int    @id @default(autoincrement())  name  String  posts Post[]}\n```\n\nTo apply your Prisma schema changes to your database, use the `prisma migrate dev` CLI command:\n\n```\nnpx prisma migrate dev --name tags-model\n```\n\nThis command will:\n\n1.  Create a new SQL migration file for the migration\n2.  Apply the generated SQL migration to the database\n3.  Regenerate Prisma Client\n\nThe following migration will be generated and saved in your `prisma/migrations` folder:\n\nprisma/migrations/TIMESTAMP\\_tags\\_model.sql\n\n```\n -- CreateTableCREATE TABLE [dbo].[Tag] (    [id] SERIAL NOT NULL,    [name] VARCHAR(255) NOT NULL,    CONSTRAINT [Tag_pkey] PRIMARY KEY ([id]));-- CreateTableCREATE TABLE [dbo].[_PostToTag] (    [A] INTEGER NOT NULL,    [B] INTEGER NOT NULL);-- CreateIndexCREATE UNIQUE INDEX [_PostToTag_AB_unique] ON _PostToTag([A], [B]);-- CreateIndexCREATE INDEX [_PostToTag_B_index] ON [_PostToTag]([B]);-- AddForeignKeyALTER TABLE [dbo].[_PostToTag] ADD CONSTRAINT [_PostToTag_A_fkey] FOREIGN KEY ([A]) REFERENCES [dbo].[Post]([id]) ON DELETE CASCADE ON UPDATE CASCADE;-- AddForeignKeyALTER TABLE [dbo].[_PostToTag] ADD CONSTRAINT [_PostToTag_B_fkey] FOREIGN KEY ([B]) REFERENCES [dbo].[Tag]([id]) ON DELETE CASCADE ON UPDATE CASCADE;\n```\n\nCongratulations, you just evolved your database with Prisma Migrate 🚀",
    "title": "Evolve your Prisma schema with Prisma Migrate : TypeScript-sql-server | Prisma Documentation",
    "description": "Evolve your Prisma schema with Prisma Migrate inside of your TypeScript and SQL Server project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-node-planetscale",
    "markdown": "# Connect your existing database using JavaScript and PlanetScale\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL as the `provider`. For PlanetScale, you need to edit the `datasource` block to use the `mysql` provider instead:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mysql\"  url      = env(\"DATABASE_URL\")}\n```\n\nYou will also need to set the relation mode type to `prisma` in order to [emulate foreign key constraints](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-1-emulate-relations-in-prisma-client) in the `datasource` block:\n\nschema.prisma\n\n```\ndatasource db {  provider     = \"mysql\"  url          = env(\"DATABASE_URL\")  relationMode = \"prisma\"}\n```\n\n> **Note**: Since February 2024, you can alternatively [use foreign key constraints on a database-level in PlanetScale](https://www.prisma.io/docs/orm/overview/databases/planetscale#option-2-enable-foreign-key-constraints-in-the-planetscale-database-settings), which omits the need for setting `relationMode = \"prisma\"`.\n\nThe `url` is [set via an environment variable](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"mysql://janedoe:mypassword@server.us-east-2.psdb.cloud/mydb?sslaccept=strict\"\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database typically depends on the database you use. PlanetScale uses the MySQL connection URL format, which has the following structure (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running (typically `3306` for MySQL)\n*   `DATABASE`: The name of the [database](https://dev.mysql.com/doc/refman/8.0/en/creating-database.html)\n\nFor a database hosted with PlanetScale, the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://myusername:mypassword@server.us-east-2.psdb.cloud/mydb?sslaccept=strict\"\n```\n\nThe connection URL for a given database branch can be found from your PlanetScale account by going to the overview page for the branch and selecting the 'Connect' dropdown. In the 'Passwords' section, generate a new password and select 'Prisma' to get the Prisma format for the connection URL.\n\nAlternative method: connecting using the PlanetScale CLI\n\nAlternatively, you can connect to your PlanetScale database server using the [PlanetScale CLI](https://docs.planetscale.com/reference/planetscale-environment-setup), and use a local connection URL. In this case the connection URL will look like this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://root@localhost:PORT/mydb\"\n```\n\ninfo\n\nWe recommend adding `.env` to your `.gitignore` file to prevent committing your environment variables.\n\nTo connect to your branch, use the following command:\n\n```\npscale connect prisma-test branchname --port PORT\n```\n\nThe `--port` flag can be omitted if you are using the default port `3306`.",
    "title": "Connect your existing database using JavaScript and PlanetScale | Prisma Documentation",
    "description": "Connect your database to your existing project using JavaScript and PlanetScale",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-node-postgresql",
    "markdown": "# Connect your existing database using JavaScript and PostgreSQL\n\n## Connecting your database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-node-postgresql#connecting-your-database \"Direct link to Connecting your database\")\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nIn this case, the `url` is [set via an environment variable](https://www.prisma.io/docs/orm/more/development-environment/environment-variables) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public\"\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\n### Connection URL\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database depends on the database you use. For PostgreSQL, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA\n```\n\n> **Note**: In most cases, you can use the [`postgres://` and `postgresql:// URI scheme designators interchangeably`](https://www.postgresql.org/docs/10/libpq-connect.html#id-1.7.3.8.3.6) - however, depending on how your database is hosted, you might need to be specific.\n\nIf you're unsure what to provide for the `schema` parameter for a PostgreSQL connection URL, you can probably omit it. In that case, the default schema name `public` will be used.\n\nAs an example, for a PostgreSQL database hosted on Heroku, the connection URL might look similar to this:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://opnmyfngbknppm:XXX@ec2-46-137-91-216.eu-west-1.compute.amazonaws.com:5432/d50rgmkqi2ipus?schema=hello-prisma\"\n```\n\nWhen running PostgreSQL locally on macOS, your user and password as well as the database name _typically_ correspond to the current _user_ of your OS, e.g. assuming the user is called `janedoe`:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://janedoe:janedoe@localhost:5432/janedoe?schema=hello-prisma\"\n```",
    "title": "Connect your existing database using JavaScript and PostgreSQL | Prisma Documentation",
    "description": "Connect your database to your existing project using JavaScript and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/next-steps",
    "markdown": "# Next steps after adding Prisma ORM to your existing project\n\nHere are a few suggestions for a number of more queries you can send with Prisma Client:\n\n**Filter all `Post` records that contain `\"hello\"`**\n\n```\nconst filteredPosts = await prisma.post.findMany({  where: {    OR: [      { title: { contains: \"hello\" },      { content: { contains: \"hello\" },    ],  },})\n```\n\n**Create a new `Post` record and connect it to an existing `User` record**\n\n```\nconst post = await prisma.post.create({  data: {    title: 'Join us for Prisma Day 2020',    author: {      connect: { email: 'alice@prisma.io' },    },  },})\n```\n\n**Use the fluent relations API to retrieve the `Post` records of a `User` by traversing the relations**\n\n```\nconst posts = await prisma.profile  .findUnique({    where: { id: 1 },  })  .user()  .posts()\n```\n\n**Delete a `User` record**\n\n```\nconst deletedUser = await prisma.user.delete({  where: { email: 'sarah@prisma.io' },})\n```",
    "title": "Next steps after adding Prisma ORM to your existing project | Prisma Documentation",
    "description": "Next steps to take now that you have successfully added Prisma ORM to your relational database project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-typescript-postgresql",
    "markdown": "# Baseline with Prisma ORM, TypeScript, and PostgreSQL\n\n## Baseline your database\n\n## Create an initial migration[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-typescript-postgresql#create-an-initial-migration \"Direct link to Create an initial migration\")\n\nTo use Prisma Migrate with the database you introspected in the last section, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nBaselining refers to initializing your migration history for a database that might already contain data and **cannot be reset**, such as your production database. Baselining tells Prisma Migrate to assume that one or more migrations have already been applied to your database.\n\nTo baseline your database, use [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) to compare your schema and database, and save the output into a SQL file.\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\n```\nmkdir -p prisma/migrations/0_init\n```\n\ninfo\n\n`-p` will recursively create any missing folders in the path you provide.\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n*   `--from-empty`: assumes the data model you're migrating from is empty\n*   `--to-schema-datamodel`: the current database state using the URL in the `datasource` block\n*   `--script`: output a SQL script\n\n```\nnpx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql\n```\n\n## Review the migration[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-typescript-postgresql#review-the-migration \"Direct link to Review the migration\")\n\nThe command will generate a migration that should resemble the following script:\n\nprisma/migrations/0\\_init/migration.sql\n\n```\n-- CreateTableCREATE TABLE \"Post\" (    \"id\" SERIAL NOT NULL,    \"title\" VARCHAR(255) NOT NULL,    \"createdAt\" TIMESTAMP(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,    \"content\" TEXT,    \"published\" BOOLEAN NOT NULL DEFAULT false,    \"authorId\" INTEGER NOT NULL,    CONSTRAINT \"Post_pkey\" PRIMARY KEY (\"id\"));-- CreateTableCREATE TABLE \"Profile\" (    \"id\" SERIAL NOT NULL,    \"bio\" TEXT,    \"userId\" INTEGER NOT NULL,    CONSTRAINT \"Profile_pkey\" PRIMARY KEY (\"id\"));-- CreateTableCREATE TABLE \"User\" (    \"id\" SERIAL NOT NULL,    \"name\" VARCHAR(255),    \"email\" VARCHAR(255) NOT NULL,    CONSTRAINT \"User_pkey\" PRIMARY KEY (\"id\"));-- CreateIndexCREATE UNIQUE INDEX \"Profile_userId_key\" ON \"Profile\"(\"userId\");-- CreateIndexCREATE UNIQUE INDEX \"User_email_key\" ON \"User\"(\"email\");-- AddForeignKeyALTER TABLE \"Post\" ADD CONSTRAINT \"Post_authorId_fkey\" FOREIGN KEY (\"authorId\") REFERENCES \"User\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION;-- AddForeignKeyALTER TABLE \"Profile\" ADD CONSTRAINT \"Profile_userId_fkey\" FOREIGN KEY (\"userId\") REFERENCES \"User\"(\"id\") ON DELETE NO ACTION ON UPDATE NO ACTION;\n```\n\nReview the SQL migration file to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\n```\nnpx prisma migrate resolve --applied 0_init\n```\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.",
    "title": "Baseline with Prisma ORM, TypeScript, and PostgreSQL | Prisma Documentation",
    "description": "Baseline your database with Prisma ORM, TypeScript, and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-node-sqlserver",
    "markdown": "# Connect your existing database using JavaScript and SQL Server\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\n```\nDATABASE_URL=\"sqlserver://localhost:1433;database=mydb;user=sa;password=r@ndomP@$$w0rd;trustServerCertificate=true\"\n```",
    "title": "Connect your existing database using JavaScript and SQL Server | Prisma Documentation",
    "description": "Connect your existing database to your project using JavaScript and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-typescript-mysql",
    "markdown": "# Baseline with Prisma ORM, TypeScript, and MySQL\n\nTo use Prisma Migrate with the database you introspected in the last section, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nBaselining refers to initializing your migration history for a database that might already contain data and **cannot be reset**, such as your production database. Baselining tells Prisma Migrate to assume that one or more migrations have already been applied to your database.\n\nTo baseline your database, use [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) to compare your schema and database, and save the output into a SQL file.\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n```\n-- CreateTableCREATE TABLE `Post` (    `id` INTEGER NOT NULL AUTO_INCREMENT,    `title` VARCHAR(255) NOT NULL,    `createdAt` TIMESTAMP(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0),    `content` TEXT NULL,    `published` BOOLEAN NOT NULL DEFAULT false,    `authorId` INTEGER NOT NULL,    INDEX `authorId`(`authorId`),    PRIMARY KEY (`id`)) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;-- CreateTableCREATE TABLE `Profile` (    `id` INTEGER NOT NULL AUTO_INCREMENT,    `bio` TEXT NULL,    `userId` INTEGER NOT NULL,    UNIQUE INDEX `userId`(`userId`),    PRIMARY KEY (`id`)) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;-- CreateTableCREATE TABLE `User` (    `id` INTEGER NOT NULL AUTO_INCREMENT,    `name` VARCHAR(255) NULL,    `email` VARCHAR(255) NOT NULL,    UNIQUE INDEX `email`(`email`),    PRIMARY KEY (`id`)) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;-- AddForeignKeyALTER TABLE `Post` ADD CONSTRAINT `Post_ibfk_1` FOREIGN KEY (`authorId`) REFERENCES `User`(`id`) ON DELETE RESTRICT ON UPDATE RESTRICT;-- AddForeignKeyALTER TABLE `Profile` ADD CONSTRAINT `Profile_ibfk_1` FOREIGN KEY (`userId`) REFERENCES `User`(`id`) ON DELETE RESTRICT ON UPDATE RESTRICT;\n```\n\nReview the SQL migration file to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.",
    "title": "Baseline with Prisma ORM, TypeScript, and MySQL | Prisma Documentation",
    "description": "Baseline your database with Prisma ORM, TypeScript, and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-typescript-sqlserver",
    "markdown": "# Baseline with Prisma ORM, TypeScript, and SQL Server\n\nTo use Prisma Migrate with the database you introspected in the last section, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nBaselining refers to initializing your migration history for a database that might already contain data and **cannot be reset**, such as your production database. Baselining tells Prisma Migrate to assume that one or more migrations have already been applied to your database.\n\nTo baseline your database, use [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) to compare your schema and database, and save the output into a SQL file.\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n```\nCREATE TABLE [dbo].[Post] (    [id] INT NOT NULL IDENTITY(1,1),    [createdAt] DATETIME2 NOT NULL CONSTRAINT [Post_createdAt_df] DEFAULT CURRENT_TIMESTAMP,    [updatedAt] DATETIME2 NOT NULL,    [title] VARCHAR(255) NOT NULL,    [content] NVARCHAR(1000),    [published] BIT NOT NULL CONSTRAINT [Post_published_df] DEFAULT 0,    [authorId] INT NOT NULL,    CONSTRAINT [Post_pkey] PRIMARY KEY ([id]));CREATE TABLE [dbo].[Profile] (    [id] INT NOT NULL IDENTITY(1,1),    [bio] NVARCHAR(1000),    [userId] INT NOT NULL,    CONSTRAINT [Profile_pkey] PRIMARY KEY ([id]),    CONSTRAINT [Profile_userId_key] UNIQUE ([userId]));CREATE TABLE [dbo].[User] (    [id] INT NOT NULL IDENTITY(1,1),    [email] NVARCHAR(1000) NOT NULL,    [name] NVARCHAR(1000),    CONSTRAINT [User_pkey] PRIMARY KEY ([id]),    CONSTRAINT [User_email_key] UNIQUE ([email]));ALTER TABLE [dbo].[Post] ADD CONSTRAINT [Post_authorId_fkey] FOREIGN KEY ([authorId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;ALTER TABLE [dbo].[Profile] ADD CONSTRAINT [Profile_userId_fkey] FOREIGN KEY ([userId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;\n```\n\nReview the SQL migration file to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.",
    "title": "Baseline with Prisma ORM, TypeScript, and SQL Server | Prisma Documentation",
    "description": "Baseline your database with Prisma ORM, TypeScript, and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/install-prisma-client-node-cockroachdb",
    "markdown": "# Install Prisma Client in your existing project using JavaScript and CockroachDB\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nNotice that the [`@prisma/client` node module](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) references a folder named `.prisma/client`. The `.prisma/client` folder contains your generated Prisma Client, and is modified each time you change the schema and run the following command:\n\nThe `@prisma/client` node module references a folder named `.prisma/client`, which contains your unique, generated Prisma Client:",
    "title": "Install Prisma Client in your existing project using JavaScript and CockroachDB | Prisma Documentation",
    "description": "Install and generate Prisma Client in your existing JavaScript and CockroachDB project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/install-prisma-client-node-mysql",
    "markdown": "# Install Prisma Client in your existing project using JavaScript and MySQL\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nNotice that the [`@prisma/client` node module](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) references a folder named `.prisma/client`. The `.prisma/client` folder contains your generated Prisma Client, and is modified each time you change the schema and run the following command:\n\nThe `@prisma/client` node module references a folder named `.prisma/client`, which contains your unique, generated Prisma Client:",
    "title": "Install Prisma Client in your existing project using JavaScript and MySQL | Prisma Documentation",
    "description": "Install and generate Prisma Client in your existing JavaScript and MySQL project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-typescript-cockroachdb",
    "markdown": "# Connect your existing database using TypeScript and CockroachDB\n\n## Connecting your database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-typescript-cockroachdb#connecting-your-database \"Direct link to Connecting your database\")\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL as the `provider`. For CockroachDB, you need to edit the `datasource` block to use the `cockroachdb` provider instead:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"cockroachdb\"  url      = env(\"DATABASE_URL\")}\n```\n\nThe `url` is [set via an environment variable](https://www.prisma.io/docs/orm/more/development-environment/environment-variables) which is defined in `.env`. You now need to adjust the connection URL to point to your own database.\n\n### Connection URL\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database depends on the database you use. CockroachDB uses the PostgreSQL connection URL format, which has the following structure (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?PARAMETERS\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running. The default for CockroachDB is `26257`.\n*   `DATABASE`: The name of the database\n*   `PARAMETERS`: Any additional connection parameters. See the CockroachDB documentation [here](https://www.cockroachlabs.com/docs/stable/connection-parameters.html#additional-connection-parameters).\n\nFor a [CockroachDB Serverless](https://www.cockroachlabs.com/docs/cockroachcloud/quickstart.html) or [Cockroach Dedicated](https://www.cockroachlabs.com/docs/cockroachcloud/quickstart-trial-cluster) database hosted on [CockroachDB Cloud](https://www.cockroachlabs.com/get-started-cockroachdb/), the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://<myusername>:<mypassword>@<short-id>.<region>.cockroachlabs.cloud:26257/defaultdb?sslmode=verify-full&sslrootcert=$HOME/.postgresql/root.crt&options=--<mycluster>\"\n```\n\nTo find your connection string on CockroachDB Cloud, click the 'Connect' button on the overview page for your database cluster, and select the 'Connection string' tab.\n\nFor a [CockroachDB database hosted locally](https://www.cockroachlabs.com/docs/stable/secure-a-cluster.html), the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://root@localhost:26257?sslmode=disable\"\n```\n\nYour connection string is displayed as part of the welcome text when starting CockroachDB from the command line.",
    "title": "Connect your existing database using TypeScript and CockroachDB | Prisma Documentation",
    "description": "Connect your existing database to your project using TypeScript and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-typescript-planetscale",
    "markdown": "# Connect your existing database using TypeScript and PlanetScale\n\n## Connecting your database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-typescript-planetscale#connecting-your-database \"Direct link to Connecting your database\")\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL as the `provider`. For PlanetScale, you need to edit the `datasource` block to use the `mysql` provider instead:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mysql\"  url      = env(\"DATABASE_URL\")}\n```\n\nYou will also need to [set the relation mode type to `prisma`](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/relation-mode#emulate-relations-in-prisma-orm-with-the-prisma-relation-mode) in the `datasource` block:\n\nschema.prisma\n\n```\ndatasource db {  provider     = \"mysql\"  url          = env(\"DATABASE_URL\")  relationMode = \"prisma\"}\n```\n\nThe `url` is [set via an environment variable](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"mysql://janedoe:mypassword@server.us-east-2.psdb.cloud/mydb?sslaccept=strict\"\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\n### Connection URL\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database typically depends on the database you use. PlanetScale uses the MySQL connection URL format, which has the following structure (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running (typically `3306` for MySQL)\n*   `DATABASE`: The name of the [database](https://dev.mysql.com/doc/refman/8.0/en/creating-database.html)\n\nFor a database hosted with PlanetScale, the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://myusername:mypassword@server.us-east-2.psdb.cloud/mydb?sslaccept=strict\"\n```\n\nThe connection URL for a given database branch can be found from your PlanetScale account by going to the overview page for the branch and selecting the 'Connect' dropdown. In the 'Passwords' section, generate a new password and select 'Prisma' to get the Prisma format for the connection URL.\n\nAlternative method: connecting using the PlanetScale CLI\n\nAlternatively, you can connect to your PlanetScale database server using the [PlanetScale CLI](https://docs.planetscale.com/reference/planetscale-environment-setup), and use a local connection URL. In this case the connection URL will look like this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://root@localhost:PORT/mydb\"\n```\n\nTo connect to your branch, use the following command:\n\n```\npscale connect prisma-test branchname --port PORT\n```\n\nThe `--port` flag can be omitted if you are using the default port `3306`.",
    "title": "Connect your existing database using TypeScript and PlanetScale | Prisma Documentation",
    "description": "Connect your existing database to your project using TypeScript and PlanetScale",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/install-prisma-client-node-planetscale",
    "markdown": "# Install Prisma Client in your existing project using JavaScript and PlanetScale\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nNotice that the [`@prisma/client` node module](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) references a folder named `.prisma/client`. The `.prisma/client` folder contains your generated Prisma Client, and is modified each time you change the schema and run the following command:\n\nThe `@prisma/client` node module references a folder named `.prisma/client`, which contains your unique, generated Prisma Client:",
    "title": "Install Prisma Client in your existing project using JavaScript and PlanetScale | Prisma Documentation",
    "description": "Install and generate Prisma Client in your existing JavaScript and PlanetScale project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-typescript-postgresql",
    "markdown": "# Connect your existing database using TypeScript and PostgresSQL\n\n## Connecting your database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-typescript-postgresql#connecting-your-database \"Direct link to Connecting your database\")\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nIn this case, the `url` is [set via an environment variable](https://www.prisma.io/docs/orm/more/development-environment/environment-variables) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public\"\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\n### Connection URL\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database depends on the database you use. For PostgreSQL, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\npostgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA\n```\n\n> **Note**: In most cases, you can use the [`postgres://` and `postgresql:// URI scheme designators interchangeably`](https://www.postgresql.org/docs/10/libpq-connect.html#id-1.7.3.8.3.6) - however, depending on how your database is hosted, you might need to be specific.\n\nIf you're unsure what to provide for the `schema` parameter for a PostgreSQL connection URL, you can probably omit it. In that case, the default schema name `public` will be used.\n\nAs an example, for a PostgreSQL database hosted on Heroku, the connection URL might look similar to this:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://opnmyfngbknppm:XXX@ec2-46-137-91-216.eu-west-1.compute.amazonaws.com:5432/d50rgmkqi2ipus?schema=hello-prisma\"\n```\n\nWhen running PostgreSQL locally on macOS, your user and password as well as the database name _typically_ correspond to the current _user_ of your OS, e.g. assuming the user is called `janedoe`:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://janedoe:janedoe@localhost:5432/janedoe?schema=hello-prisma\"\n```",
    "title": "Connect your existing database using TypeScript and PostgresSQL | Prisma Documentation",
    "description": "Connect your existing database to your project using TypeScript and PostgresSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-typescript-mysql",
    "markdown": "# Connect your existing database using TypeScript and MySQL\n\n## Connecting your database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-typescript-mysql#connecting-your-database \"Direct link to Connecting your database\")\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNote that the default schema created by `prisma init` uses PostgreSQL, so you first need to switch the `provider` to `mysql`:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mysql\"  url      = env(\"DATABASE_URL\")}\n```\n\nIn this case, the `url` is [set via an environment variable](https://www.prisma.io/docs/orm/prisma-schema/overview#accessing-environment-variables-from-the-schema) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"mysql://johndoe:randompassword@localhost:3306/mydb\"\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\n### Connection URL\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database typically depends on the database you use. For MySQL, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\nmysql://USER:PASSWORD@HOST:PORT/DATABASE\n```\n\nHere's a short explanation of each component:\n\n*   `USER`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `PORT`: The port where your database server is running (typically `3306` for MySQL)\n*   `DATABASE`: The name of the [database](https://dev.mysql.com/doc/refman/8.0/en/creating-database.html)\n\nAs an example, for a MySQL database hosted on AWS RDS, the [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) might look similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://johndoe:XXX@mysql–instance1.123456789012.us-east-1.rds.amazonaws.com:3306/mydb\"\n```\n\nWhen running MySQL locally, your connection URL typically looks similar to this:\n\n.env\n\n```\nDATABASE_URL=\"mysql://root:randompassword@localhost:3306/mydb\"\n```",
    "title": "Connect your existing database using TypeScript and MySQL | Prisma Documentation",
    "description": "Connect your existing database to your project using TypeScript and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/install-prisma-client-node-sqlserver",
    "markdown": "# Install Prisma Client in your existing project using JavaScript and SQL Server\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nNotice that the [`@prisma/client` node module](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) references a folder named `.prisma/client`. The `.prisma/client` folder contains your generated Prisma Client, and is modified each time you change the schema and run the following command:\n\nThe `@prisma/client` node module references a folder named `.prisma/client`, which contains your unique, generated Prisma Client:",
    "title": "Install Prisma Client in your existing project using JavaScript and SQL Server | Prisma Documentation",
    "description": "Install and generate Prisma Client in your existing JavaScript and SQL Server project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/install-prisma-client-node-postgresql",
    "markdown": "# Install Prisma Client in your existing project using JavaScript and PostgreSQL\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nNotice that the [`@prisma/client` node module](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) references a folder named `.prisma/client`. The `.prisma/client` folder contains your generated Prisma Client, and is modified each time you change the schema and run the following command:\n\nThe `@prisma/client` node module references a folder named `.prisma/client`, which contains your unique, generated Prisma Client:",
    "title": "Install Prisma Client in your existing project using JavaScript and PostgreSQL | Prisma Documentation",
    "description": "Install and generate Prisma Client in your existing JavaScript and PostgreSQL project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/install-prisma-client-typescript-cockroachdb",
    "markdown": "# Install Prisma Client in your existing project using TypeScript and CockroachDB\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nNotice that the [`@prisma/client` node module](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) references a folder named `.prisma/client`. The `.prisma/client` folder contains your generated Prisma Client, and is modified each time you change the schema and run the following command:\n\nThe `@prisma/client` node module references a folder named `.prisma/client`, which contains your unique, generated Prisma Client:",
    "title": "Install Prisma Client in your existing project using TypeScript and CockroachDB | Prisma Documentation",
    "description": "Install and generate Prisma Client in your existing TypeScript and CockroachDB project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/connect-your-database-typescript-sqlserver",
    "markdown": "# Connect your existing database using TypeScript and SQL Server\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\n```\nDATABASE_URL=\"sqlserver://localhost:1433;database=mydb;user=sa;password=r@ndomP@$$w0rd;trustServerCertificate=true\"\n```",
    "title": "Connect your existing database using TypeScript and SQL Server | Prisma Documentation",
    "description": "Connect your existing database to your project using TypeScript and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/install-prisma-client-typescript-planetscale",
    "markdown": "# Install Prisma Client in your existing project using TypeScript and PlanetScale\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nNotice that the [`@prisma/client` node module](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) references a folder named `.prisma/client`. The `.prisma/client` folder contains your generated Prisma Client, and is modified each time you change the schema and run the following command:\n\nThe `@prisma/client` node module references a folder named `.prisma/client`, which contains your unique, generated Prisma Client:",
    "title": "Install Prisma Client in your existing project using TypeScript and PlanetScale | Prisma Documentation",
    "description": "Install and generate Prisma Client in your existing TypeScript and PlanetScale project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/install-prisma-client-typescript-postgresql",
    "markdown": "# Install Prisma Client in your existing project using TypeScript and PostgreSQL\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nNotice that the [`@prisma/client` node module](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) references a folder named `.prisma/client`. The `.prisma/client` folder contains your generated Prisma Client, and is modified each time you change the schema and run the following command:\n\nThe `@prisma/client` node module references a folder named `.prisma/client`, which contains your unique, generated Prisma Client:",
    "title": "Install Prisma Client in your existing project using TypeScript and PostgreSQL | Prisma Documentation",
    "description": "Install and generate Prisma Client in your existing TypeScript and PostgreSQL project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-node-mysql",
    "markdown": "# Introspection with Prisma ORM, JavaScript, and MySQL\n\n## Introspect your database with Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-node-mysql#introspect-your-database-with-prisma-orm \"Direct link to Introspect your database with Prisma ORM\")\n\nFor the purpose of this guide, we'll use a demo SQL schema with three tables:\n\n```\nCREATE TABLE User (  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,  name VARCHAR(255),  email VARCHAR(255) UNIQUE NOT NULL);CREATE TABLE Post (  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,  title VARCHAR(255) NOT NULL,  createdAt TIMESTAMP NOT NULL DEFAULT now(),  content TEXT,  published BOOLEAN NOT NULL DEFAULT false,  authorId INTEGER NOT NULL,  FOREIGN KEY (authorId) REFERENCES User(id));CREATE TABLE Profile (  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,  bio TEXT,  userId INTEGER UNIQUE NOT NULL,  FOREIGN KEY (userId) REFERENCES User(id));\n```\n\nExpand for a graphical overview of the tables\n\n**User**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INTEGER` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `name` | `VARCHAR(255)` | No  | No  | No  | \\-  |\n| `email` | `VARCHAR(255)` | No  | No  | **✔️** | \\-  |\n\n**Post**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INTEGER` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `createdAt` | `DATETIME(3)` | No  | No  | **✔️** | `now()` |\n| `title` | `VARCHAR(255)` | No  | No  | **✔️** | \\-  |\n| `content` | `TEXT` | No  | No  | No  | \\-  |\n| `published` | `BOOLEAN` | No  | No  | **✔️** | `false` |\n| `authorId` | `INTEGER` | No  | **✔️** | **✔️** | `false` |\n\n**Profile**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INTEGER` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `bio` | `TEXT` | No  | No  | No  | \\-  |\n| `userId` | `INTEGER` | No  | **✔️** | **✔️** | \\-  |\n\nAs a next step, you will introspect your database. The result of the introspection will be a [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) inside your Prisma schema.\n\nRun the following command to introspect your database:\n\nThis command reads the `DATABASE_URL` environment variable that's defined in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a Prisma data model.\n\nAfter the introspection is complete, your Prisma schema is updated:\n\n![Introspect your database](https://www.prisma.io/docs/assets/images/prisma-db-pull-generate-schema-8c7216308f1aa7f7117827cba2c96620.png)\n\nThe data model now looks similar to this (note that the fields on the models have been reordered for better readability):\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(0)  content   String?  @db.Text  published Boolean  @default(false)  authorId  Int  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: \"Post_ibfk_1\")  @@index([authorId], map: \"authorId\")}model Profile {  id     Int     @id @default(autoincrement())  bio    String? @db.Text  userId Int     @unique(map: \"userId\")  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: \"Profile_ibfk_1\")}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique(map: \"email\") @db.VarChar(255)  Post    Post[]  Profile Profile?}\n```\n\nPrisma ORM's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.\n\nRight now, there's a few minor \"issues\" with the data model:\n\n*   The `User` relation field is uppercased and therefore doesn't adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) . To express more \"semantics\", it would also be nice if this field was called `author` to _describe_ the relationship between `User` and `Post` better.\n*   The `Post` and `Profile` relation fields on `User` as well as the `User` relation field on `Profile` are all uppercased. To adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) , both fields should be lowercased to `post`, `profile` and `user`.\n*   Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) of posts – a better name therefore would be the plural form: `posts`.\n\nThese changes are relevant for the generated Prisma Client API where using lowercased relation fields `author`, `posts`, `profile` and `user` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).\n\nBecause [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(0)  content   String?  @db.Text  published Boolean  @default(false)  authorId  Int  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: \"Post_ibfk_1\")  @@index([authorId], map: \"authorId\")}model Profile {  id     Int     @id @default(autoincrement())  bio    String? @db.Text  userId Int     @unique(map: \"userId\")  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: \"Profile_ibfk_1\")}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique(map: \"email\") @db.VarChar(255)  posts   Post[]  profile Profile?}\n```\n\nIn this example, the database schema did follow the [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions) for Prisma ORM models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API.\n\nSometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake\\_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.\n\nAssume you obtained the following model from introspection that's based on _snake\\_case_ notation:\n\n```\nmodel my_user {  user_id    Int     @id @default(autoincrement())  first_name String?  last_name  String  @unique}\n```\n\nIf you generated a Prisma Client API for this model, it would pick up the _snake\\_case_ notation in its API:\n\n```\nconst user = await prisma.my_user.create({    data: {        first_name: 'Alice',        last_name: 'Smith',    },})\n```\n\nIf you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):\n\n```\nmodel MyUser {  userId    Int     @id @default(autoincrement()) @map(\"user_id\")  firstName String? @map(\"first_name\")  lastName  String  @unique @map(\"last_name\")  @@map(\"my_user\")}\n```\n\nWith this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:\n\n```\nconst user = await prisma.myUser.create({    data: {        firstName: 'Alice',        lastName: 'Smith',    },})\n```\n\nLearn more about this on the [Configuring your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.",
    "title": "Introspection with Prisma ORM, JavaScript, and MySQL | Prisma Documentation",
    "description": "Introspect your existing project with Prisma ORM, JavaScript, and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/install-prisma-client-typescript-mysql",
    "markdown": "# Install Prisma Client in your existing project using TypeScript and MySQL\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nNotice that the [`@prisma/client` node module](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) references a folder named `.prisma/client`. The `.prisma/client` folder contains your generated Prisma Client, and is modified each time you change the schema and run the following command:\n\nThe `@prisma/client` node module references a folder named `.prisma/client`, which contains your unique, generated Prisma Client:",
    "title": "Install Prisma Client in your existing project using TypeScript and MySQL | Prisma Documentation",
    "description": "Install and generate Prisma Client in your existing TypeScript and MySQL project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-node-planetscale",
    "markdown": "# Introspection with Prisma ORM, JavaScript, and PlanetScale\n\nSometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake\\_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.\n\nAssume you obtained the following model from introspection that's based on _snake\\_case_ notation:\n\n```\nmodel my_user {  user_id    Int     @id @default(autoincrement())  first_name String?  last_name  String  @unique}\n```\n\nIf you generated a Prisma Client API for this model, it would pick up the _snake\\_case_ notation in its API:\n\n```\nconst user = await prisma.my_user.create({  data: {    first_name: 'Alice',    last_name: 'Smith',  },})\n```\n\nIf you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):\n\n```\nmodel MyUser {  userId    Int     @id @default(autoincrement()) @map(\"user_id\")  firstName String? @map(\"first_name\")  lastName  String  @unique @map(\"last_name\")  @@map(\"my_user\")}\n```\n\nWith this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:\n\n```\nconst user = await prisma.myUser.create({  data: {    firstName: 'Alice',    lastName: 'Smith',  },})\n```\n\nLearn more about this on the [Configuring your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.",
    "title": "Introspection with Prisma ORM, JavaScript, and PlanetScale | Prisma Documentation",
    "description": "Introspect your existing project with Prisma ORM, JavaScript, and PlanetScale",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/install-prisma-client-typescript-sqlserver",
    "markdown": "# Install Prisma Client in your existing project using TypeScript and SQL Server\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nNotice that the [`@prisma/client` node module](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#the-prismaclient-npm-package) references a folder named `.prisma/client`. The `.prisma/client` folder contains your generated Prisma Client, and is modified each time you change the schema and run the following command:\n\nThe `@prisma/client` node module references a folder named `.prisma/client`, which contains your unique, generated Prisma Client:",
    "title": "Install Prisma Client in your existing project using TypeScript and SQL Server | Prisma Documentation",
    "description": "Install and generate Prisma Client in your existing TypeScript and SQL Server project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-node-cockroachdb",
    "markdown": "# Introspection with Prisma ORM, JavaScript, and CockroachDB\n\n## Introspect your database with Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-node-cockroachdb#introspect-your-database-with-prisma-orm \"Direct link to Introspect your database with Prisma ORM\")\n\nFor the purpose of this guide, we'll use a demo SQL schema with three tables:\n\n```\nCREATE TABLE \"User\" (  id INT8 PRIMARY KEY DEFAULT unique_rowid(),  name STRING(255),  email STRING(255) UNIQUE NOT NULL);CREATE TABLE \"Post\" (  id INT8 PRIMARY KEY DEFAULT unique_rowid(),  title STRING(255) UNIQUE NOT NULL,  \"createdAt\" TIMESTAMP NOT NULL DEFAULT now(),  content STRING,  published BOOLEAN NOT NULL DEFAULT false,  \"authorId\" INT8 NOT NULL,  FOREIGN KEY (\"authorId\") REFERENCES \"User\"(id));CREATE TABLE \"Profile\" (  id INT8 PRIMARY KEY DEFAULT unique_rowid(),  bio STRING,  \"userId\" INT8 UNIQUE NOT NULL,  FOREIGN KEY (\"userId\") REFERENCES \"User\"(id));\n```\n\n> **Note**: Some fields are written in double quotes to ensure CockroachDB uses proper casing. If no double-quotes were used, CockroachDB would just read everything as _lowercase_ characters.\n\nExpand for a graphical overview of the tables\n\n**User**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INT8` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `name` | `STRING(255)` | No  | No  | No  | \\-  |\n| `email` | `STRING(255)` | No  | No  | **✔️** | \\-  |\n\n**Post**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INT8` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `createdAt` | `TIMESTAMP` | No  | No  | **✔️** | `now()` |\n| `title` | `STRING(255)` | No  | No  | **✔️** | \\-  |\n| `content` | `STRING` | No  | No  | No  | \\-  |\n| `published` | `BOOLEAN` | No  | No  | **✔️** | `false` |\n| `authorId` | `INT8` | No  | **✔️** | **✔️** | \\-  |\n\n**Profile**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INT8` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `bio` | `STRING` | No  | No  | No  | \\-  |\n| `userId` | `INT8` | No  | **✔️** | **✔️** | \\-  |\n\nAs a next step, you will introspect your database. The result of the introspection will be a [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) inside your Prisma schema.\n\nRun the following command to introspect your database:\n\nThis command reads the environment variable used to define the `url` in your `schema.prisma`, `DATABASE_URL`, that in our case is set in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a Prisma data model.\n\nAfter the introspection is complete, your Prisma schema is updated:\n\n![Introspect your database](https://www.prisma.io/docs/assets/images/prisma-db-pull-generate-schema-8c7216308f1aa7f7117827cba2c96620.png)\n\nThe data model now looks similar to this:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        BigInt   @id @default(autoincrement())  title     String   @unique @db.String(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  BigInt  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model Profile {  id     BigInt  @id @default(autoincrement())  bio    String?  userId BigInt  @unique  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model User {  id      BigInt   @id @default(autoincrement())  name    String?  @db.String(255)  email   String   @unique @db.String(255)  Post    Post[]  Profile Profile?}\n```\n\nPrisma ORM's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.\n\nRight now, there's a few minor \"issues\" with the data model:\n\n*   The `User` relation field is uppercased and therefore doesn't adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) . To express more \"semantics\", it would also be nice if this field was called `author` to _describe_ the relationship between `User` and `Post` better.\n*   The `Post` and `Profile` relation fields on `User` as well as the `User` relation field on `Profile` are all uppercased. To adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) , both fields should be lowercased to `post`, `profile` and `user`.\n*   Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) of posts – a better name therefore would be the plural form: `posts`.\n\nThese changes are relevant for the generated Prisma Client API where using lowercased relation fields `author`, `posts`, `profile` and `user` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).\n\nBecause [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        BigInt   @id @default(autoincrement())  title     String   @unique @db.String(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  BigInt  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model Profile {  id     BigInt  @id @default(autoincrement())  bio    String?  userId BigInt  @unique  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model User {  id      BigInt   @id @default(autoincrement())  name    String?  @db.String(255)  email   String   @unique @db.String(255)  posts   Post[]  profile Profile?}\n```\n\nIn this example, the database schema did follow the [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions) for Prisma ORM models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API.\n\nUsing custom model and field names\n\nSometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake\\_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.\n\nAssume you obtained the following model from introspection that's based on _snake\\_case_ notation:\n\n```\nmodel my_user {  user_id    Int     @id @default(sequence())  first_name String?  last_name  String  @unique}\n```\n\nIf you generated a Prisma Client API for this model, it would pick up the _snake\\_case_ notation in its API:\n\n```\nconst user = await prisma.my_user.create({    data: {        first_name: 'Alice',        last_name: 'Smith',    },})\n```\n\nIf you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):\n\n```\nmodel MyUser {  userId    Int     @id @default(sequence()) @map(\"user_id\")  firstName String? @map(\"first_name\")  lastName  String  @unique @map(\"last_name\")  @@map(\"my_user\")}\n```\n\nWith this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:\n\n```\nconst user = await prisma.myUser.create({    data: {        firstName: 'Alice',        lastName: 'Smith',    },})\n```\n\nLearn more about this on the [Configuring your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.",
    "title": "Introspection with Prisma ORM, JavaScript, and CockroachDB | Prisma Documentation",
    "description": "Introspect your existing project with Prisma ORM, JavaScript, and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-node-postgresql",
    "markdown": "# Introspection with Prisma ORM, JavaScript, and PostgreSQL\n\n## Introspect your database with Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-node-postgresql#introspect-your-database-with-prisma-orm \"Direct link to Introspect your database with Prisma ORM\")\n\nFor the purpose of this guide, we'll use a demo SQL schema with three tables:\n\n```\nCREATE TABLE \"public\".\"User\" (  id SERIAL PRIMARY KEY NOT NULL,  name VARCHAR(255),  email VARCHAR(255) UNIQUE NOT NULL);CREATE TABLE \"public\".\"Post\" (  id SERIAL PRIMARY KEY NOT NULL,  title VARCHAR(255) NOT NULL,  \"createdAt\" TIMESTAMP NOT NULL DEFAULT now(),  content TEXT,  published BOOLEAN NOT NULL DEFAULT false,  \"authorId\" INTEGER NOT NULL,  FOREIGN KEY (\"authorId\") REFERENCES \"public\".\"User\"(id));CREATE TABLE \"public\".\"Profile\" (  id SERIAL PRIMARY KEY NOT NULL,  bio TEXT,  \"userId\" INTEGER UNIQUE NOT NULL,  FOREIGN KEY (\"userId\") REFERENCES \"public\".\"User\"(id));\n```\n\n> **Note**: Some fields are written in double-quotes to ensure PostgreSQL uses proper casing. If no double-quotes were used, PostgreSQL would just read everything as _lowercase_ characters.\n\nExpand for a graphical overview of the tables\n\n**User**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `SERIAL` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `name` | `VARCHAR(255)` | No  | No  | No  | \\-  |\n| `email` | `VARCHAR(255)` | No  | No  | **✔️** | \\-  |\n\n**Post**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `SERIAL` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `createdAt` | `TIMESTAMP` | No  | No  | **✔️** | `now()` |\n| `title` | `VARCHAR(255)` | No  | No  | **✔️** | \\-  |\n| `content` | `TEXT` | No  | No  | No  | \\-  |\n| `published` | `BOOLEAN` | No  | No  | **✔️** | `false` |\n| `authorId` | `INTEGER` | No  | **✔️** | **✔️** | \\-  |\n\n**Profile**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `SERIAL` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `bio` | `TEXT` | No  | No  | No  | \\-  |\n| `userId` | `INTEGER` | No  | **✔️** | **✔️** | \\-  |\n\nAs a next step, you will introspect your database. The result of the introspection will be a [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) inside your Prisma schema.\n\nRun the following command to introspect your database:\n\nThis command reads the `DATABASE_URL` environment variable that's defined in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a data model in your Prisma schema.\n\nAfter the introspection is complete, your Prisma schema is updated:\n\n![Introspect your database with Prisma ORM](https://www.prisma.io/docs/assets/images/prisma-db-pull-generate-schema-8c7216308f1aa7f7117827cba2c96620.png)\n\nThe data model now looks similar to this (note that the fields on the models have been reordered for better readability):\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  Int  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int     @unique  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique @db.VarChar(255)  Post    Post[]  Profile Profile?}\n```\n\nPrisma ORM's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.\n\nRight now, there's a few minor \"issues\" with the data model:\n\n*   The `User` relation field is uppercased and therefore doesn't adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) . To express more \"semantics\", it would also be nice if this field was called `author` to _describe_ the relationship between `User` and `Post` better.\n*   The `Post` and `Profile` relation fields on `User` as well as the `User` relation field on `Profile` are all uppercased. To adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) , both fields should be lowercased to `post`, `profile` and `user`.\n*   Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) of posts – a better name therefore would be the plural form: `posts`.\n\nThese changes are relevant for the generated Prisma Client API where using lowercased relation fields `author`, `posts`, `profile` and `user` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).\n\nBecause [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  Int  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int     @unique  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique @db.VarChar(255)  posts   Post[]  profile Profile?}\n```\n\nIn this example, the database schema did follow the [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions) for Prisma ORM models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API.\n\nUsing custom model and field names\n\nSometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake\\_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.\n\nAssume you obtained the following model from introspection that's based on _snake\\_case_ notation:\n\n```\nmodel my_user {  user_id    Int     @id @default(autoincrement())  first_name String?  last_name  String  @unique}\n```\n\nIf you generated a Prisma Client API for this model, it would pick up the _snake\\_case_ notation in its API:\n\n```\nconst user = await prisma.my_user.create({  data: {    first_name: 'Alice',    last_name: 'Smith',  },})\n```\n\nIf you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):\n\n```\nmodel MyUser {  userId    Int     @id @default(autoincrement()) @map(\"user_id\")  firstName String? @map(\"first_name\")  lastName  String  @unique @map(\"last_name\")  @@map(\"my_user\")}\n```\n\nWith this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:\n\n```\nconst user = await prisma.myUser.create({  data: {    firstName: 'Alice',    lastName: 'Smith',  },})\n```\n\nLearn more about this on the [Configuring your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.",
    "title": "Introspection with Prisma ORM, JavaScript, and PostgreSQL | Prisma Documentation",
    "description": "Introspect your existing project with Prisma ORM, JavaScript, and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-mysql",
    "markdown": "# Query your existing MySQL database with JavaScript and Prisma ORM\n\n## Querying the database\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-mysql#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database.\n\nIf you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.\n\nFor the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).\n\nCreate a new file named `index.js` and add the following code to it:\n\nindex.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nindex.js\n\n```\nasync function main() {  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nIf you created a database using the schema from the database introspection step, the query should print an empty array because there are no `User` records in the database yet.\n\nIf you introspected an existing database with records, the query should return an array of JavaScript objects.\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-mysql#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database. In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.js\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.js\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:",
    "title": "Query your existing MySQL database with JavaScript and Prisma ORM | Prisma Documentation",
    "description": "Write data to and query the MySQL database with your JavaScript and Prisma ORM project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-cockroachdb",
    "markdown": "# Query your existing CockroachDB database with JavaScript and Prisma ORM\n\n## Querying the database\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-cockroachdb#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database.\n\nIf you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.\n\nFor the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).\n\nCreate a new file named `index.js` and add the following code to it:\n\nindex.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nindex.js\n\n```\nasync function main() {  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nIf you created a database using the schema from the database introspection step, the query should print an empty array because there are no `User` records in the database yet.\n\nIf you introspected an existing database with records, the query should return an array of JavaScript objects.\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-cockroachdb#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database. In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.js\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.js\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { title: 'Hello World' },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:",
    "title": "Query your existing CockroachDB database with JavaScript and Prisma ORM | Prisma Documentation",
    "description": "Write data to and query the CockroachDB database with your JavaScript and Prisma ORM project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-node-sqlserver",
    "markdown": "# Introspection with Prisma ORM, JavaScript, and SQL Server\n\n## Introspect your database with Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-node-sqlserver#introspect-your-database-with-prisma-orm \"Direct link to Introspect your database with Prisma ORM\")\n\nFor the purpose of this guide, we'll use a demo SQL schema with three tables:\n\n```\nCREATE TABLE [dbo].[Post] (    [id] INT NOT NULL IDENTITY(1,1),    [createdAt] DATETIME2 NOT NULL CONSTRAINT [Post_createdAt_df] DEFAULT CURRENT_TIMESTAMP,    [updatedAt] DATETIME2 NOT NULL,    [title] VARCHAR(255) NOT NULL,    [content] NVARCHAR(1000),    [published] BIT NOT NULL CONSTRAINT [Post_published_df] DEFAULT 0,    [authorId] INT NOT NULL,    CONSTRAINT [Post_pkey] PRIMARY KEY ([id]));CREATE TABLE [dbo].[Profile] (    [id] INT NOT NULL IDENTITY(1,1),    [bio] NVARCHAR(1000),    [userId] INT NOT NULL,    CONSTRAINT [Profile_pkey] PRIMARY KEY ([id]),    CONSTRAINT [Profile_userId_key] UNIQUE ([userId]));CREATE TABLE [dbo].[User] (    [id] INT NOT NULL IDENTITY(1,1),    [email] NVARCHAR(1000) NOT NULL,    [name] NVARCHAR(1000),    CONSTRAINT [User_pkey] PRIMARY KEY ([id]),    CONSTRAINT [User_email_key] UNIQUE ([email]));ALTER TABLE [dbo].[Post] ADD CONSTRAINT [Post_authorId_fkey] FOREIGN KEY ([authorId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;ALTER TABLE [dbo].[Profile] ADD CONSTRAINT [Profile_userId_fkey] FOREIGN KEY ([userId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;\n```\n\nExpand for a graphical overview of the tables\n\n**User**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INT` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `name` | `NVARCHAR(1000)` | No  | No  | No  | \\-  |\n| `email` | `NVARCHAR(1000)` | No  | No  | **✔️** | \\-  |\n\n**Post**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INT` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `createdAt` | `DATETIME2` | No  | No  | **✔️** | `now()` |\n| `updatedAt` | `DATETIME2` | No  | No  | **✔️** |     |\n| `title` | `VARCHAR(255)` | No  | No  | **✔️** | \\-  |\n| `content` | `NVARCHAR(1000)` | No  | No  | No  | \\-  |\n| `published` | `BIT` | No  | No  | **✔️** | `false` |\n| `authorId` | `INT` | No  | **✔️** | **✔️** | \\-  |\n\n**Profile**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INT` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `bio` | `NVARCHAR(1000)` | No  | No  | No  | \\-  |\n| `userId` | `INT` | No  | **✔️** | **✔️** | \\-  |\n\nAs a next step, you will introspect your database. The result of the introspection will be a [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) inside your Prisma schema.\n\nRun the following command to introspect your database:\n\nThis command reads the `DATABASE_URL` environment variable that's defined in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a Prisma data model.\n\nAfter the introspection is complete, your Prisma schema is updated:\n\n![Introspect your database](https://www.prisma.io/docs/assets/images/prisma-db-pull-generate-schema-8c7216308f1aa7f7117827cba2c96620.png)\n\nThe data model now looks similar to this (note that the fields on the models have been reordered for better readability):\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  Int  User      User     @relation(fields: [authorId], references: [id])}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int     @unique  User   User    @relation(fields: [userId], references: [id])}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique @db.VarChar(255)  Post    Post[]  Profile Profile?}\n```\n\nPrisma's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.\n\nRight now, there's a few minor \"issues\" with the data model:\n\n*   The `User` relation field is uppercased and therefore doesn't adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) . To express more \"semantics\", it would also be nice if this field was called `author` to _describe_ the relationship between `User` and `Post` better.\n*   The `Post` and `Profile` relation fields on `User` as well as the `User` relation field on `Profile` are all uppercased. To adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) , both fields should be lowercased to `post`, `profile` and `user`.\n*   Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) of posts – a better name therefore would be the plural form: `posts`.\n\nThese changes are relevant for the generated Prisma Client API where using lowercased relation fields `author`, `posts`, `profile` and `user` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).\n\nBecause [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  author    User     @relation(fields: [authorId], references: [id])  authorId  Int}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId Int     @unique}model User {  id      Int      @id @default(autoincrement())  email   String   @unique @db.VarChar(255)  name    String?  @db.VarChar(255)  posts   Post[]  profile Profile?}\n```\n\nIn this example, the database schema did follow the [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions) for Prisma ORM models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API.\n\nUsing custom model and field names\n\nSometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake\\_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.\n\nAssume you obtained the following model from introspection that's based on _snake\\_case_ notation:\n\n```\nmodel my_user {  user_id    Int     @id @default(autoincrement())  first_name String?  last_name  String  @unique}\n```\n\nIf you generated a Prisma Client API for this model, it would pick up the _snake\\_case_ notation in its API:\n\n```\nconst user = await prisma.my_user.create({  data: {    first_name: 'Alice',    last_name: 'Smith',  },})\n```\n\nIf you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):\n\n```\nmodel MyUser {  userId    Int     @id @default(autoincrement()) @map(\"user_id\")  firstName String? @map(\"first_name\")  lastName  String  @unique @map(\"last_name\")  @@map(\"my_user\")}\n```\n\nWith this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:\n\n```\nconst user = await prisma.myUser.create({  data: {    firstName: 'Alice',    lastName: 'Smith',  },})\n```\n\nLearn more about this on the [Configuring your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.",
    "title": "Introspection with Prisma ORM, JavaScript, and SQL Server | Prisma Documentation",
    "description": "Introspect your database with Prisma ORM, JavaScript, and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-planetscale",
    "markdown": "# Query your existing PlanetScale database with JavaScript and Prisma ORM\n\n## Querying the database\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-planetscale#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database.\n\nIf you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.\n\nFor the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).\n\nCreate a new file named `index.js` and add the following code to it:\n\nindex.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nDepending on what your models look like, the Prisma Client API will look different as well. For example, if you have a `User` model, your `PrismaClient` instance exposes a property called `user` on which you can call [CRUD](https://www.prisma.io/docs/orm/prisma-client/queries/crud) methods like `findMany`, `create` or `update`. The property is named after the model, but the first letter is lowercased (so for the `Post` model it's called `post`, for `Profile` it's called `profile`).\n\nThe following examples are all based on the models in the Prisma schema.\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.js\n\n```\nasync function main() {  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nIf you created a database using the schema from the database introspection step, the query should print an empty array because there are no `User` records in the database yet.\n\nIf you introspected an existing database with records, the query should return an array of JavaScript objects.\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-planetscale#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database. In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.js\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.js\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:",
    "title": "Query your existing PlanetScale database with JavaScript and Prisma ORM | Prisma Documentation",
    "description": "Write data to and query the PlanetScale database with your JavaScript and Prisma ORM project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-typescript-cockroachdb",
    "markdown": "# Introspection with Prisma ORM, TypeScript, and CockroachDB\n\n## Introspect your database with Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-typescript-cockroachdb#introspect-your-database-with-prisma-orm \"Direct link to Introspect your database with Prisma ORM\")\n\nFor the purpose of this guide, we'll use a demo SQL schema with three tables:\n\n```\nCREATE TABLE \"User\" (  id INT8 PRIMARY KEY DEFAULT unique_rowid(),  name STRING(255),  email STRING(255) UNIQUE NOT NULL);CREATE TABLE \"Post\" (  id INT8 PRIMARY KEY DEFAULT unique_rowid(),  title STRING(255) UNIQUE NOT NULL,  \"createdAt\" TIMESTAMP NOT NULL DEFAULT now(),  content STRING,  published BOOLEAN NOT NULL DEFAULT false,  \"authorId\" INT8 NOT NULL,  FOREIGN KEY (\"authorId\") REFERENCES \"User\"(id));CREATE TABLE \"Profile\" (  id INT8 PRIMARY KEY DEFAULT unique_rowid(),  bio STRING,  \"userId\" INT8 UNIQUE NOT NULL,  FOREIGN KEY (\"userId\") REFERENCES \"User\"(id));\n```\n\n> **Note**: Some fields are written in double quotes to ensure CockroachDB uses proper casing. If no double-quotes were used, CockroachDB would just read everything as _lowercase_ characters.\n\nExpand for a graphical overview of the tables\n\n**User**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INT8` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `name` | `STRING(255)` | No  | No  | No  | \\-  |\n| `email` | `STRING(255)` | No  | No  | **✔️** | \\-  |\n\n**Post**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INT8` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `createdAt` | `TIMESTAMP` | No  | No  | **✔️** | `now()` |\n| `title` | `STRING(255)` | No  | No  | **✔️** | \\-  |\n| `content` | `STRING` | No  | No  | No  | \\-  |\n| `published` | `BOOLEAN` | No  | No  | **✔️** | `false` |\n| `authorId` | `INT8` | No  | **✔️** | **✔️** | \\-  |\n\n**Profile**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INT8` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `bio` | `STRING` | No  | No  | No  | \\-  |\n| `userId` | `INT8` | No  | **✔️** | **✔️** | \\-  |\n\nAs a next step, you will introspect your database. The result of the introspection will be a [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) inside your Prisma schema.\n\nRun the following command to introspect your database:\n\nThis command reads the environment variable used to define the `url` in your `schema.prisma`, `DATABASE_URL`, that in our case is set in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a Prisma data model.\n\nAfter the introspection is complete, your Prisma schema is updated:\n\n![Introspect your database](https://www.prisma.io/docs/assets/images/prisma-db-pull-generate-schema-8c7216308f1aa7f7117827cba2c96620.png)\n\nThe data model now looks similar to this:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        BigInt   @id @default(autoincrement())  title     String   @unique @db.String(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  BigInt  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model Profile {  id     BigInt  @id @default(autoincrement())  bio    String?  userId BigInt  @unique  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model User {  id      BigInt   @id @default(autoincrement())  name    String?  @db.String(255)  email   String   @unique @db.String(255)  Post    Post[]  Profile Profile?}\n```\n\nPrisma ORM's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.\n\nRight now, there's a few minor \"issues\" with the data model:\n\n*   The `User` relation field is uppercased and therefore doesn't adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) . To express more \"semantics\", it would also be nice if this field was called `author` to _describe_ the relationship between `User` and `Post` better.\n*   The `Post` and `Profile` relation fields on `User` as well as the `User` relation field on `Profile` are all uppercased. To adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) , both fields should be lowercased to `post`, `profile` and `user`.\n*   Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) of posts – a better name therefore would be the plural form: `posts`.\n\nThese changes are relevant for the generated Prisma Client API where using lowercased relation fields `author`, `posts`, `profile` and `user` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).\n\nBecause [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        BigInt   @id @default(autoincrement())  title     String   @unique @db.String(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  BigInt  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model Profile {  id     BigInt  @id @default(autoincrement())  bio    String?  userId BigInt  @unique  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model User {  id      BigInt   @id @default(autoincrement())  name    String?  @db.String(255)  email   String   @unique @db.String(255)  posts   Post[]  profile Profile?}\n```\n\nIn this example, the database schema did follow the [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions) for Prisma ORM models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API.\n\nUsing custom model and field names\n\nSometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake\\_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.\n\nAssume you obtained the following model from introspection that's based on _snake\\_case_ notation:\n\n```\nmodel my_user {  user_id    Int     @id @default(sequence())  first_name String?  last_name  String  @unique}\n```\n\nIf you generated a Prisma Client API for this model, it would pick up the _snake\\_case_ notation in its API:\n\n```\nconst user = await prisma.my_user.create({  data: {    first_name: 'Alice',    last_name: 'Smith',  },})\n```\n\nIf you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):\n\n```\nmodel MyUser {  userId    Int     @id @default(sequence()) @map(\"user_id\")  firstName String? @map(\"first_name\")  lastName  String  @unique @map(\"last_name\")  @@map(\"my_user\")}\n```\n\nWith this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:\n\n```\nconst user = await prisma.myUser.create({  data: {    firstName: 'Alice',    lastName: 'Smith',  },})\n```\n\nLearn more about this on the [Configuring your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.",
    "title": "Introspection with Prisma ORM, TypeScript, and CockroachDB | Prisma Documentation",
    "description": "Introspect your database with Prisma ORM, TypeScript, and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-typescript-mysql",
    "markdown": "# Introspection with Prisma ORM, TypeScript, and MySQL\n\n## Introspect your database with Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-typescript-mysql#introspect-your-database-with-prisma-orm \"Direct link to Introspect your database with Prisma ORM\")\n\nFor the purpose of this guide, we'll use a demo SQL schema with three tables:\n\n```\nCREATE TABLE User (  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,  name VARCHAR(255),  email VARCHAR(255) UNIQUE NOT NULL);CREATE TABLE Post (  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,  title VARCHAR(255) NOT NULL,  createdAt TIMESTAMP NOT NULL DEFAULT now(),  content TEXT,  published BOOLEAN NOT NULL DEFAULT false,  authorId INTEGER NOT NULL,  FOREIGN KEY (authorId) REFERENCES User(id));CREATE TABLE Profile (  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,  bio TEXT,  userId INTEGER UNIQUE NOT NULL,  FOREIGN KEY (userId) REFERENCES User(id));\n```\n\nExpand for a graphical overview of the tables\n\n**User**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INTEGER` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `name` | `VARCHAR(255)` | No  | No  | No  | \\-  |\n| `email` | `VARCHAR(255)` | No  | No  | **✔️** | \\-  |\n\n**Post**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INTEGER` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `createdAt` | `DATETIME(3)` | No  | No  | **✔️** | `now()` |\n| `title` | `VARCHAR(255)` | No  | No  | **✔️** | \\-  |\n| `content` | `TEXT` | No  | No  | No  | \\-  |\n| `published` | `BOOLEAN` | No  | No  | **✔️** | `false` |\n| `authorId` | `INTEGER` | No  | **✔️** | **✔️** | `false` |\n\n**Profile**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INTEGER` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `bio` | `TEXT` | No  | No  | No  | \\-  |\n| `userId` | `INTEGER` | No  | **✔️** | **✔️** | \\-  |\n\nAs a next step, you will introspect your database. The result of the introspection will be a [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) inside your Prisma schema.\n\nRun the following command to introspect your database:\n\nThis command reads the `DATABASE_URL` environment variable that's defined in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a Prisma data model.\n\nAfter the introspection is complete, your Prisma schema is updated:\n\n![Introspect your database](https://www.prisma.io/docs/assets/images/prisma-db-pull-generate-schema-8c7216308f1aa7f7117827cba2c96620.png)\n\nThe data model now looks similar to this (note that the fields on the models have been reordered for better readability):\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(0)  content   String?  @db.Text  published Boolean  @default(false)  authorId  Int  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: \"Post_ibfk_1\")  @@index([authorId], map: \"authorId\")}model Profile {  id     Int     @id @default(autoincrement())  bio    String? @db.Text  userId Int     @unique(map: \"userId\")  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: \"Profile_ibfk_1\")}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique(map: \"email\") @db.VarChar(255)  Post    Post[]  Profile Profile?}\n```\n\nPrisma ORM's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.\n\nRight now, there's a few minor \"issues\" with the data model:\n\n*   The `User` relation field is uppercased and therefore doesn't adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) . To express more \"semantics\", it would also be nice if this field was called `author` to _describe_ the relationship between `User` and `Post` better.\n*   The `Post` and `Profile` relation fields on `User` as well as the `User` relation field on `Profile` are all uppercased. To adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) , both fields should be lowercased to `post`, `profile` and `user`.\n*   Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) of posts – a better name therefore would be the plural form: `posts`.\n\nThese changes are relevant for the generated Prisma Client API where using lowercased relation fields `author`, `posts`, `profile` and `user` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).\n\nBecause [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(0)  content   String?  @db.Text  published Boolean  @default(false)  authorId  Int  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: \"Post_ibfk_1\")  @@index([authorId], map: \"authorId\")}model Profile {  id     Int     @id @default(autoincrement())  bio    String? @db.Text  userId Int     @unique(map: \"userId\")  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: \"Profile_ibfk_1\")}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique(map: \"email\") @db.VarChar(255)  posts   Post[]  profile Profile?}\n```\n\nIn this example, the database schema did follow the [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions) for Prisma ORM models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API.\n\nSometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake\\_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.\n\nAssume you obtained the following model from introspection that's based on _snake\\_case_ notation:\n\n```\nmodel my_user {  user_id    Int     @id @default(autoincrement())  first_name String?  last_name  String  @unique}\n```\n\nIf you generated a Prisma Client API for this model, it would pick up the _snake\\_case_ notation in its API:\n\n```\nconst user = await prisma.my_user.create({  data: {    first_name: 'Alice',    last_name: 'Smith',  },})\n```\n\nIf you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):\n\n```\nmodel MyUser {  userId    Int     @id @default(autoincrement()) @map(\"user_id\")  firstName String? @map(\"first_name\")  lastName  String  @unique @map(\"last_name\")  @@map(\"my_user\")}\n```\n\nWith this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:\n\n```\nconst user = await prisma.myUser.create({  data: {    firstName: 'Alice',    lastName: 'Smith',  },})\n```\n\nLearn more about this on the [Configuring your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.",
    "title": "Introspection with Prisma ORM, TypeScript, and MySQL | Prisma Documentation",
    "description": "Introspect your existing project with Prisma ORM, TypeScript, and MySQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-typescript-postgresql",
    "markdown": "# Introspection with Prisma ORM, TypeScript, and PostgreSQL\n\n## Introspect your database with Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-typescript-postgresql#introspect-your-database-with-prisma-orm \"Direct link to Introspect your database with Prisma ORM\")\n\nFor the purpose of this guide, we'll use a demo SQL schema with three tables:\n\n```\nCREATE TABLE \"public\".\"User\" (  id SERIAL PRIMARY KEY NOT NULL,  name VARCHAR(255),  email VARCHAR(255) UNIQUE NOT NULL);CREATE TABLE \"public\".\"Post\" (  id SERIAL PRIMARY KEY NOT NULL,  title VARCHAR(255) NOT NULL,  \"createdAt\" TIMESTAMP NOT NULL DEFAULT now(),  content TEXT,  published BOOLEAN NOT NULL DEFAULT false,  \"authorId\" INTEGER NOT NULL,  FOREIGN KEY (\"authorId\") REFERENCES \"public\".\"User\"(id));CREATE TABLE \"public\".\"Profile\" (  id SERIAL PRIMARY KEY NOT NULL,  bio TEXT,  \"userId\" INTEGER UNIQUE NOT NULL,  FOREIGN KEY (\"userId\") REFERENCES \"public\".\"User\"(id));\n```\n\n> **Note**: Some fields are written in double-quotes to ensure PostgreSQL uses proper casing. If no double-quotes were used, PostgreSQL would just read everything as _lowercase_ characters.\n\nExpand for a graphical overview of the tables\n\n**User**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `SERIAL` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `name` | `VARCHAR(255)` | No  | No  | No  | \\-  |\n| `email` | `VARCHAR(255)` | No  | No  | **✔️** | \\-  |\n\n**Post**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `SERIAL` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `createdAt` | `TIMESTAMP` | No  | No  | **✔️** | `now()` |\n| `title` | `VARCHAR(255)` | No  | No  | **✔️** | \\-  |\n| `content` | `TEXT` | No  | No  | No  | \\-  |\n| `published` | `BOOLEAN` | No  | No  | **✔️** | `false` |\n| `authorId` | `INTEGER` | No  | **✔️** | **✔️** | \\-  |\n\n**Profile**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `SERIAL` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `bio` | `TEXT` | No  | No  | No  | \\-  |\n| `userId` | `INTEGER` | No  | **✔️** | **✔️** | \\-  |\n\nAs a next step, you will introspect your database. The result of the introspection will be a [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) inside your Prisma schema.\n\nRun the following command to introspect your database:\n\nThis command reads the `DATABASE_URL` environment variable that's defined in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a data model in your Prisma schema.\n\nAfter the introspection is complete, your Prisma schema is updated:\n\n![Introspect your database with Prisma ORM](https://www.prisma.io/docs/assets/images/prisma-db-pull-generate-schema-8c7216308f1aa7f7117827cba2c96620.png)\n\nThe data model now looks similar to this (note that the fields on the models have been reordered for better readability):\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  Int  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int     @unique  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique @db.VarChar(255)  Post    Post[]  Profile Profile?}\n```\n\nPrisma ORM's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.\n\nRight now, there's a few minor \"issues\" with the data model:\n\n*   The `User` relation field is uppercased and therefore doesn't adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) . To express more \"semantics\", it would also be nice if this field was called `author` to _describe_ the relationship between `User` and `Post` better.\n*   The `Post` and `Profile` relation fields on `User` as well as the `User` relation field on `Profile` are all uppercased. To adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) , both fields should be lowercased to `post`, `profile` and `user`.\n*   Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) of posts – a better name therefore would be the plural form: `posts`.\n\nThese changes are relevant for the generated Prisma Client API where using lowercased relation fields `author`, `posts`, `profile` and `user` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).\n\nBecause [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  Int  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int     @unique  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique @db.VarChar(255)  posts   Post[]  profile Profile?}\n```\n\nIn this example, the database schema did follow the [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions) for Prisma ORM models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API.\n\nUsing custom model and field names\n\nSometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake\\_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.\n\nAssume you obtained the following model from introspection that's based on _snake\\_case_ notation:\n\n```\nmodel my_user {  user_id    Int     @id @default(autoincrement())  first_name String?  last_name  String  @unique}\n```\n\nIf you generated a Prisma Client API for this model, it would pick up the _snake\\_case_ notation in its API:\n\n```\nconst user = await prisma.my_user.create({  data: {    first_name: 'Alice',    last_name: 'Smith',  },})\n```\n\nIf you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):\n\n```\nmodel MyUser {  userId    Int     @id @default(autoincrement()) @map(\"user_id\")  firstName String? @map(\"first_name\")  lastName  String  @unique @map(\"last_name\")  @@map(\"my_user\")}\n```\n\nWith this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:\n\n```\nconst user = await prisma.myUser.create({  data: {    firstName: 'Alice',    lastName: 'Smith',  },})\n```\n\nLearn more about this on the [Configuring your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.",
    "title": "Introspection with Prisma ORM, TypeScript, and PostgreSQL | Prisma Documentation",
    "description": "Introspect your existing project with Prisma ORM, TypeScript, and PostgreSQL",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-postgresql",
    "markdown": "# Query your existing PostgreSQL database with JavaScript and Prisma ORM\n\n## Querying the database\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-postgresql#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database.\n\nIf you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.\n\nFor the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).\n\nCreate a new file named `index.js` and add the following code to it:\n\nindex.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nindex.js\n\n```\nasync function main() {  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nIf you created a database using the schema from the database introspection step, the query should print an empty array because there are no `User` records in the database yet.\n\nIf you introspected an existing database with records, the query should return an array of JavaScript objects.\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-postgresql#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database. In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.js\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.js\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nNow run the code using the same command as before:",
    "title": "Query your existing PostgreSQL database with JavaScript and Prisma ORM | Prisma Documentation",
    "description": "Write data to and query the PostgreSQL database with your JavaScript and Prisma ORM project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-sqlserver",
    "markdown": "# Query your existing SQL Server database with JavaScript and Prisma ORM\n\n## Querying the database\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-sqlserver#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database.\n\nIf you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.\n\nFor the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).\n\nCreate a new file named `index.js` and add the following code to it:\n\nindex.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nDepending on what your models look like, the Prisma Client API will look different as well. For example, if you have a `User` model, your `PrismaClient` instance exposes a property called `user` on which you can call [CRUD](https://www.prisma.io/docs/orm/prisma-client/queries/crud) methods like `findMany`, `create` or `update`. The property is named after the model, but the first letter is lowercased (so for the `Post` model it's called `post`, for `Profile` it's called `profile`).\n\nThe following examples are all based on the models in the Prisma schema.\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.js\n\n```\nasync function main() {  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nIf you created a database using the schema from the database introspection step, the query should print an empty array because there are no `User` records in the database yet.\n\nIf you introspected an existing database with records, the query should return an array of JavaScript objects.\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-node-sqlserver#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database. In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.js\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with this command:\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.js\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```",
    "title": "Query your existing SQL Server database with JavaScript and Prisma ORM | Prisma Documentation",
    "description": "Write data to and query the SQL Server database with your JavaScript and Prisma ORM project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-typescript-sqlserver",
    "markdown": "# Introspection with Prisma ORM, TypeScript, and SQL Server\n\n## Introspect your database with Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-typescript-sqlserver#introspect-your-database-with-prisma-orm \"Direct link to Introspect your database with Prisma ORM\")\n\nFor the purpose of this guide, we'll use a demo SQL schema with three tables:\n\n```\nCREATE TABLE [dbo].[Post] (    [id] INT NOT NULL IDENTITY(1,1),    [createdAt] DATETIME2 NOT NULL CONSTRAINT [Post_createdAt_df] DEFAULT CURRENT_TIMESTAMP,    [updatedAt] DATETIME2 NOT NULL,    [title] VARCHAR(255) NOT NULL,    [content] NVARCHAR(1000),    [published] BIT NOT NULL CONSTRAINT [Post_published_df] DEFAULT 0,    [authorId] INT NOT NULL,    CONSTRAINT [Post_pkey] PRIMARY KEY ([id]));CREATE TABLE [dbo].[Profile] (    [id] INT NOT NULL IDENTITY(1,1),    [bio] NVARCHAR(1000),    [userId] INT NOT NULL,    CONSTRAINT [Profile_pkey] PRIMARY KEY ([id]),    CONSTRAINT [Profile_userId_key] UNIQUE ([userId]));CREATE TABLE [dbo].[User] (    [id] INT NOT NULL IDENTITY(1,1),    [email] NVARCHAR(1000) NOT NULL,    [name] NVARCHAR(1000),    CONSTRAINT [User_pkey] PRIMARY KEY ([id]),    CONSTRAINT [User_email_key] UNIQUE ([email]));ALTER TABLE [dbo].[Post] ADD CONSTRAINT [Post_authorId_fkey] FOREIGN KEY ([authorId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;ALTER TABLE [dbo].[Profile] ADD CONSTRAINT [Profile_userId_fkey] FOREIGN KEY ([userId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;\n```\n\nExpand for a graphical overview of the tables\n\n**User**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INT` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `name` | `NVARCHAR(1000)` | No  | No  | No  | \\-  |\n| `email` | `NVARCHAR(1000)` | No  | No  | **✔️** | \\-  |\n\n**Post**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INT` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `createdAt` | `DATETIME2` | No  | No  | **✔️** | `now()` |\n| `updatedAt` | `DATETIME2` | No  | No  | **✔️** |     |\n| `title` | `VARCHAR(255)` | No  | No  | **✔️** | \\-  |\n| `content` | `NVARCHAR(1000)` | No  | No  | No  | \\-  |\n| `published` | `BIT` | No  | No  | **✔️** | `false` |\n| `authorId` | `INT` | No  | **✔️** | **✔️** | \\-  |\n\n**Profile**\n\n| Column name | Type | Primary key | Foreign key | Required | Default |\n| --- | --- | --- | --- | --- | --- |\n| `id` | `INT` | **✔️** | No  | **✔️** | _autoincrementing_ |\n| `bio` | `NVARCHAR(1000)` | No  | No  | No  | \\-  |\n| `userId` | `INT` | No  | **✔️** | **✔️** | \\-  |\n\nAs a next step, you will introspect your database. The result of the introspection will be a [data model](https://www.prisma.io/docs/orm/prisma-schema/data-model/models) inside your Prisma schema.\n\nRun the following command to introspect your database:\n\nThis command reads the `DATABASE_URL` environment variable that's defined in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a Prisma data model.\n\nAfter the introspection is complete, your Prisma schema is updated:\n\n![Introspect your database](https://www.prisma.io/docs/assets/images/prisma-db-pull-generate-schema-8c7216308f1aa7f7117827cba2c96620.png)\n\nThe data model now looks similar to this (note that the fields on the models have been reordered for better readability):\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  authorId  Int  User      User     @relation(fields: [authorId], references: [id])}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  userId Int     @unique  User   User    @relation(fields: [userId], references: [id])}model User {  id      Int      @id @default(autoincrement())  name    String?  @db.VarChar(255)  email   String   @unique @db.VarChar(255)  Post    Post[]  Profile Profile?}\n```\n\nPrisma's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.\n\nRight now, there's a few minor \"issues\" with the data model:\n\n*   The `User` relation field is uppercased and therefore doesn't adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) . To express more \"semantics\", it would also be nice if this field was called `author` to _describe_ the relationship between `User` and `Post` better.\n*   The `Post` and `Profile` relation fields on `User` as well as the `User` relation field on `Profile` are all uppercased. To adhere to Prisma's [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions-1) , both fields should be lowercased to `post`, `profile` and `user`.\n*   Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers) of posts – a better name therefore would be the plural form: `posts`.\n\nThese changes are relevant for the generated Prisma Client API where using lowercased relation fields `author`, `posts`, `profile` and `user` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).\n\nBecause [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database:\n\nprisma/schema.prisma\n\n```\nmodel Post {  id        Int      @id @default(autoincrement())  title     String   @db.VarChar(255)  createdAt DateTime @default(now()) @db.Timestamp(6)  content   String?  published Boolean  @default(false)  author    User     @relation(fields: [authorId], references: [id])  authorId  Int}model Profile {  id     Int     @id @default(autoincrement())  bio    String?  user   User    @relation(fields: [userId], references: [id])  userId Int     @unique}model User {  id      Int      @id @default(autoincrement())  email   String   @unique @db.VarChar(255)  name    String?  @db.VarChar(255)  posts   Post[]  profile Profile?}\n```\n\nIn this example, the database schema did follow the [naming conventions](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#naming-conventions) for Prisma ORM models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API.\n\nUsing custom model and field names\n\nSometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake\\_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.\n\nAssume you obtained the following model from introspection that's based on _snake\\_case_ notation:\n\n```\nmodel my_user {  user_id    Int     @id @default(autoincrement())  first_name String?  last_name  String  @unique}\n```\n\nIf you generated a Prisma Client API for this model, it would pick up the _snake\\_case_ notation in its API:\n\n```\nconst user = await prisma.my_user.create({  data: {    first_name: 'Alice',    last_name: 'Smith',  },})\n```\n\nIf you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):\n\n```\nmodel MyUser {  userId    Int     @id @default(autoincrement()) @map(\"user_id\")  firstName String? @map(\"first_name\")  lastName  String  @unique @map(\"last_name\")  @@map(\"my_user\")}\n```\n\nWith this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:\n\n```\nconst user = await prisma.myUser.create({  data: {    firstName: 'Alice',    lastName: 'Smith',  },})\n```\n\nLearn more about this on the [Configuring your Prisma Client API](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.",
    "title": "Introspection with Prisma ORM, TypeScript, and SQL Server | Prisma Documentation",
    "description": "Introspect your existing project with Prisma ORM, TypeScript, and SQL Server",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-node-cockroachdb",
    "markdown": "# Baseline with Prisma ORM, JavaScript, and CockroachDB\n\n## Baseline your database\n\n## Create an initial migration[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-node-cockroachdb#create-an-initial-migration \"Direct link to Create an initial migration\")\n\nTo use Prisma Migrate with the database you introspected in the last section, you will need to [baseline your database](https://www.prisma.io/docs/orm/prisma-migrate/getting-started).\n\nBaselining refers to initializing your migration history for a database that might already contain data and **cannot be reset**, such as your production database. Baselining tells Prisma Migrate to assume that one or more migrations have already been applied to your database.\n\nTo baseline your database, use [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) to compare your schema and database, and save the output into a SQL file.\n\nFirst, create a `migrations` directory and add a directory inside with your preferred name for the migration. In this example, we will use `0_init` as the migration name:\n\n```\nmkdir -p prisma/migrations/0_init\n```\n\ninfo\n\n`-p` will recursively create any missing folders in the path you provide.\n\nNext, generate the migration file with `prisma migrate diff`. Use the following arguments:\n\n*   `--from-empty`: assumes the data model you're migrating from is empty\n*   `--to-schema-datamodel`: the current database state using the URL in the `datasource` block\n*   `--script`: output a SQL script\n\n```\nnpx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql\n```\n\n## Review the migration[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-node-cockroachdb#review-the-migration \"Direct link to Review the migration\")\n\nThe command will generate a migration that should resemble the following script:\n\nprisma/migrations/0\\_init/migration.sql\n\n```\nCREATE TABLE \"User\" (  id INT8 PRIMARY KEY DEFAULT unique_rowid(),  name STRING(255),  email STRING(255) UNIQUE NOT NULL);CREATE TABLE \"Post\" (  id INT8 PRIMARY KEY DEFAULT unique_rowid(),  title STRING(255) UNIQUE NOT NULL,  \"createdAt\" TIMESTAMP NOT NULL DEFAULT now(),  content STRING,  published BOOLEAN NOT NULL DEFAULT false,  \"authorId\" INT8 NOT NULL,  FOREIGN KEY (\"authorId\") REFERENCES \"User\"(id));CREATE TABLE \"Profile\" (  id INT8 PRIMARY KEY DEFAULT unique_rowid(),  bio STRING,  \"userId\" INT8 UNIQUE NOT NULL,  FOREIGN KEY (\"userId\") REFERENCES \"User\"(id));\n```\n\nReview the SQL migration file to ensure everything is correct.\n\nNext, mark the migration as applied using `prisma migrate resolve` with the `--applied` argument.\n\n```\nnpx prisma migrate resolve --applied 0_init\n```\n\nThe command will mark `0_init` as applied by adding it to the `_prisma_migrations` table.\n\nYou now have a baseline for your current database schema. To make further changes to your database schema, you can update your Prisma schema and use `prisma migrate dev` to apply the changes to your database.",
    "title": "Baseline with Prisma ORM, JavaScript, and CockroachDB | Prisma Documentation",
    "description": "Baseline your database with Prisma ORM, JavaScript, and CockroachDB",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-mysql",
    "markdown": "# Query your existing MySQL database with TypeScript and Prisma ORM\n\n## Querying the database\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-mysql#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database.\n\nIf you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.\n\nFor the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).\n\nCreate a new file named `index.ts` and add the following code to it:\n\nindex.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nDepending on what your models look like, the Prisma Client API will look different as well. For example, if you have a `User` model, your `PrismaClient` instance exposes a property called `user` on which you can call [CRUD](https://www.prisma.io/docs/orm/prisma-client/queries/crud) methods like `findMany`, `create` or `update`. The property is named after the model, but the first letter is lowercased (so for the `Post` model it's called `post`, for `Profile` it's called `profile`).\n\nThe following examples are all based on the models in the Prisma schema.\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.ts\n\n```\nasync function main() {  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:\n\nIf you created a database using the schema from the database introspection step, the query should print an empty array because there are no `User` records in the database yet.\n\nIf you introspected an existing database with records, the query should return an array of JavaScript objects.\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-mysql#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database. In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.ts\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.ts\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nRun the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:",
    "title": "Query your existing MySQL database with TypeScript and Prisma ORM | Prisma Documentation",
    "description": "Write data to and query the MySQL database with your TypeScript and Prisma ORM project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview",
    "markdown": "# Overview (Deploy Prisma ORM at the Edge)\n\n## Deploying edge functions with Prisma ORM[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview#deploying-edge-functions-with-prisma-orm \"Direct link to Deploying edge functions with Prisma ORM\")\n\nYou can deploy an application that uses Prisma ORM to the edge. Depending on which edge function provider and which database you use, there are different considerations and things to be aware of.\n\nHere is a brief overview of all the edge function providers that are currently supported by Prisma ORM:\n\n| Provider / Product | Supported natively with Prisma ORM | Supported with Prisma Accelerate |\n| --- | --- | --- |\n| Vercel Edge Functions | ✅ (Preview; only compatible drivers) | ✅   |\n| Vercel Edge Middleware | ✅ (Preview; only compatible drivers) | ✅   |\n| Cloudflare Workers | ✅ (Preview; only compatible drivers) | ✅   |\n| Cloudflare Pages | ✅ (Preview; only compatible drivers) | ✅   |\n| Deno Deploy | [Not yet](https://github.com/prisma/prisma/issues/2452) | ✅   |\n\nDeploying edge functions that use Prisma ORM on Cloudflare and Vercel is currently in [Preview](https://www.prisma.io/docs/orm/more/releases#preview).\n\n## Edge-compatibility of database drivers[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview#edge-compatibility-of-database-drivers \"Direct link to Edge-compatibility of database drivers\")\n\n### Why are there limitations around database drivers in edge functions?[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview#why-are-there-limitations-around-database-drivers-in-edge-functions \"Direct link to Why are there limitations around database drivers in edge functions?\")\n\nEdge functions typically don't use the standard Node.js runtime. For example, Vercel Edge Functions and Cloudflare Workers are running code in [V8 isolates](https://v8docs.nodesource.com/node-0.8/d5/dda/classv8_1_1_isolate.html). Deno Deploy is using the [Deno](https://deno.com/) JavaScript runtime. As a consequence, these edge functions only have access to a small subset of the standard Node.js APIs and also have constrained computing resources (CPU and memory).\n\nIn particular, the constraint of not being able to freely open TCP connections makes it difficult to talk to a traditional database from an edge function. While Cloudflare has introduced a [`connect()`](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/) API that enables limited TCP connections, this still only enables database access using specific database drivers that are compatible with that API.\n\n> **Note**: [Prisma Accelerate](https://www.prisma.io/docs/accelerate) enables you to access _any_ database from _any_ edge function provider. No edge-compatible driver is necessary.\n\n### Which database drivers are edge-compatible?[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview#which-database-drivers-are-edge-compatible \"Direct link to Which database drivers are edge-compatible?\")\n\nHere is an overview of the different database drivers and their compatibility with different edge function offerings:\n\n*   [Neon Serverless](https://neon.tech/docs/serverless/serverless-driver) uses HTTP to access the database. It works with Cloudflare Workers and Vercel Edge Functions.\n*   [PlanetScale Serverless](https://planetscale.com/docs/tutorials/planetscale-serverless-driver) uses HTTP to access the database. It works with Cloudflare Workers and Vercel Edge Functions.\n*   [`node-postgres`](https://node-postgres.com/) (`pg`) uses Cloudflare's `connect()` (TCP) to access the database. It is only compatible with Cloudflare Workers, not with Vercel Edge Functions.\n*   [`@libsql/client`](https://github.com/tursodatabase/libsql-client-ts) is used to access Turso databases. It works with Cloudflare Workers and Vercel Edge Functions.\n*   [Cloudflare D1](https://developers.cloudflare.com/d1/) is used to access D1 databases. It is only compatible with Cloudflare Workers, not with Vercel Edge Functions.\n\nThere's [also work being done](https://github.com/sidorares/node-mysql2/pull/2289) on the `node-mysql2` driver which will enable access to traditional MySQL databases from Cloudflare Workers and Pages in the future as well.\n\nYou can use all of these drivers with Prisma ORM using the respective [driver adapters](https://www.prisma.io/docs/orm/overview/databases/database-drivers).\n\nDepending on which deployment provider and database/driver you use, there may be special considerations. Please take a look at the deployment docs for your respective scenario to make sure you can deploy your application successfully:\n\n*   Cloudflare\n    *   [PostgreSQL (traditional)](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#postgresql-traditional)\n    *   [PlanetScale](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#planetscale)\n    *   [Neon](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#neon)\n    *   [Cloudflare D1](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#cloudflare-d1)\n*   Vercel\n    *   [Vercel Postgres](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#vercel-postgres)\n    *   [Neon](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#neon)\n    *   [PlanetScale](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#planetscale)\n\nIf you want to deploy an app using Turso, you can follow the instructions [here](https://www.prisma.io/docs/orm/overview/databases/turso).",
    "title": "Overview (Deploy Prisma ORM at the Edge) | Prisma Documentation",
    "description": "Learn how to deploy your Prisma-backed apps to edge functions like Cloudflare Workers or Vercel Edge Functions",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-cockroachdb",
    "markdown": "# Query your existing CockroachDB database with TypeScript and Prisma ORM\n\n## Querying the database\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-cockroachdb#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database.\n\nIf you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.\n\nFor the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).\n\nCreate a new file named `index.ts` and add the following code to it:\n\nindex.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nDepending on what your models look like, the Prisma Client API will look different as well. For example, if you have a `User` model, your `PrismaClient` instance exposes a property called `user` on which you can call [CRUD](https://www.prisma.io/docs/orm/prisma-client/queries/crud) methods like `findMany`, `create` or `update`. The property is named after the model, but the first letter is lowercased (so for the `Post` model it's called `post`, for `Profile` it's called `profile`).\n\nThe following examples are all based on the models in the Prisma schema.\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.ts\n\n```\nasync function main() {  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:\n\nIf you created a database using the schema from the database introspection step, the query should print an empty array because there are no `User` records in the database yet.\n\nIf you introspected an existing database with records, the query should return an array of JavaScript objects.\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-cockroachdb#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database. In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.ts\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.ts\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { title: 'Hello World' },    data: { published: true },  })  console.log(post)}\n```\n\nRun the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:",
    "title": "Query your existing CockroachDB database with TypeScript and Prisma ORM | Prisma Documentation",
    "description": "Write data to and query the CockroachDB database with your TypeScript and Prisma ORM project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/connect-your-database-typescript-mongodb",
    "markdown": "# Connect your MongoDB database using TypeScript\n\n## Connecting your database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/connect-your-database-typescript-mongodb#connecting-your-database \"Direct link to Connecting your database\")\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}\n```\n\nIn this case, the `url` is [set via an environment variable](https://www.prisma.io/docs/orm/more/development-environment/environment-variables) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"mongodb+srv://test:test@cluster0.ns1yp.mongodb.net/myFirstDatabase\"\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database depends on the database you use. For MongoDB, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\nmongodb://USERNAME:PASSWORD@HOST:PORT/DATABASE\n```\n\nHere's a short explanation of each component:\n\n*   `USERNAME`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `HOST`: The host where a [`mongod`](https://docs.mongodb.com/manual/reference/program/mongod/#mongodb-binary-bin.mongod) (or [`mongos`](https://docs.mongodb.com/manual/reference/program/mongos/#mongodb-binary-bin.mongos)) instance is running\n*   `PORT`: The port where your database server is running (typically `27017` for MongoDB)\n*   `DATABASE`: The name of the database\n\n> If you see the following error: `Error in connector: SCRAM failure: Authentication failed.`, you can specify the source database for the authentication by [adding](https://github.com/prisma/prisma/discussions/9994#discussioncomment-1562283) `?authSource=admin` to the end of the connection string.",
    "title": "Connect your MongoDB database using TypeScript | Prisma Documentation",
    "description": "Connect your MongoDB database to your existing TypeScript project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-planetscale",
    "markdown": "# Query your existing PlanetScale database with TypeScript and Prisma ORM\n\n## Querying the database\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-planetscale#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database.\n\nIf you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.\n\nFor the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).\n\nCreate a new file named `index.ts` and add the following code to it:\n\nindex.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Call the `main` function\n5.  Close the database connections when the script terminates\n\nDepending on what your models look like, the Prisma Client API will look different as well. For example, if you have a `User` model, your `PrismaClient` instance exposes a property called `user` on which you can call [CRUD](https://www.prisma.io/docs/orm/prisma-client/queries/crud) methods like `findMany`, `create` or `update`. The property is named after the model, but the first letter is lowercased (so for the `Post` model it's called `post`, for `Profile` it's called `profile`).\n\nThe following examples are all based on the models in the Prisma schema.\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.ts\n\n```\nasync function main() {  const allUsers = await prisma.user.findMany()  console.log(allUsers)}\n```\n\nNow run the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:\n\nIf you created a database using the schema from the database introspection step, the query should print an empty array because there are no `User` records in the database yet.\n\nIf you introspected an existing database with records, the query should return an array of JavaScript objects.\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/querying-the-database-typescript-planetscale#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database. In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.ts\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Alice',      email: 'alice@prisma.io',      posts: {        create: { title: 'Hello World' },      },      profile: {        create: { bio: 'I like turtles' },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,      profile: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.\n\nRun the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:\n\nBefore moving on to the next section, you'll \"publish\" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.ts\n\n```\nasync function main() {  const post = await prisma.post.update({    where: { id: 1 },    data: { published: true },  })  console.log(post)}\n```\n\nRun the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:",
    "title": "Query your existing PlanetScale database with TypeScript and Prisma ORM | Prisma Documentation",
    "description": "Write data to and query the PlanetScale database with your TypeScript and Prisma ORM project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/connect-your-database-node-mongodb",
    "markdown": "# Connect your MongoDB database | Prisma Documentation\n\n## Connecting your database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/connect-your-database-node-mongodb#connecting-your-database \"Direct link to Connecting your database\")\n\nTo connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls):\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}\n```\n\nIn this case, the `url` is [set via an environment variable](https://www.prisma.io/docs/orm/more/development-environment/environment-variables) which is defined in `.env`:\n\n.env\n\n```\nDATABASE_URL=\"mongodb+srv://test:test@cluster0.ns1yp.mongodb.net/myFirstDatabase\"\n```\n\nYou now need to adjust the connection URL to point to your own database.\n\nThe [format of the connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) for your database depends on the database you use. For MongoDB, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):\n\n```\nmongodb://USERNAME:PASSWORD@HOST:PORT/DATABASE\n```\n\nHere's a short explanation of each component:\n\n*   `USERNAME`: The name of your database user\n*   `PASSWORD`: The password for your database user\n*   `HOST`: The host where a [`mongod`](https://docs.mongodb.com/manual/reference/program/mongod/#mongodb-binary-bin.mongod) (or [`mongos`](https://docs.mongodb.com/manual/reference/program/mongos/#mongodb-binary-bin.mongos)) instance is running\n*   `PORT`: The port where your database server is running (typically `27017` for MongoDB)\n*   `DATABASE`: The name of the database\n\n> If you see the following error: `Error in connector: SCRAM failure: Authentication failed.`, you can specify the source database for the authentication by [adding](https://github.com/prisma/prisma/discussions/9994#discussioncomment-1562283) `?authSource=admin` to the end of the connection string.",
    "title": "Connect your MongoDB database | Prisma Documentation",
    "description": "Connect your MongoDB database to your existing Node.js project",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-node-mongodb",
    "markdown": "# Add Prisma ORM to an existing MongoDB project using JavaScript (15 min)\n\nLearn how to add Prisma ORM to an existing Node.js or TypeScript project by connecting it to your database and generating a Prisma Client for database access. The following tutorial introduces you to [Prisma CLI](https://www.prisma.io/docs/orm/tools/prisma-cli), [Prisma Client](https://www.prisma.io/docs/orm/prisma-client), and [Prisma Introspection](https://www.prisma.io/docs/orm/prisma-schema/introspection).\n\n## Prerequisites[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-node-mongodb#prerequisites \"Direct link to Prerequisites\")\n\nIn order to successfully complete this guide, you need:\n\n*   [Node.js](https://nodejs.org/en/) installed on your machine\n    \n*   Access to a MongoDB 4.2+ server with a replica set deployment. We recommend using [MongoDB Atlas](https://www.mongodb.com/cloud/atlas).\n    \n    warning\n    \n    The MongoDB database connector uses transactions to support nested writes. Transactions **requires** a [replica set](https://docs.mongodb.com/manual/tutorial/deploy-replica-set/) deployment. The easiest way to deploy a replica set is with [Atlas](https://docs.atlas.mongodb.com/getting-started/). It's free to get started.\n    \n\nMake sure you have your database [connection URL](https://www.prisma.io/docs/orm/reference/connection-urls) (that includes your authentication credentials) at hand! If you don't have a database server running and just want to explore Prisma ORM, check out the [Quickstart](https://www.prisma.io/docs/getting-started/quickstart).\n\n> See [System requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for exact version requirements.\n\n## Set up Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-node-mongodb#set-up-prisma-orm \"Direct link to Set up Prisma ORM\")\n\nAs a first step, navigate into it your project directory that contains the `package.json` file.\n\nNext, add the Prisma CLI as a development dependency to your project:\n\n```\nnpm install prisma --save-dev\n```\n\nYou can now invoke the Prisma CLI by prefixing it with `npx`:\n\nNext, set up your Prisma ORM project by creating your [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) file template with the following command:\n\nThis command does two things:\n\n*   creates a new directory called `prisma` that contains a file called `schema.prisma`, which contains the Prisma schema with your database connection variable and schema models\n*   creates the [`.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) in the root directory of the project, which is used for defining environment variables (such as your database connection)",
    "title": "Add Prisma ORM to an existing MongoDB project using JavaScript (15 min) | Prisma Documentation",
    "description": "Learn how to add Prisma ORM to an existing Node.js project by connecting it to your MongoDB database and generating a Prisma Client for database access.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/install-prisma-client-node-mongodb",
    "markdown": "# Install Prisma Client in your existing project: JavaScript and MongoDB\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you make changes to your Prisma schema in the future, you manually need to invoke `prisma generate` in order to accommodate the changes in your Prisma Client API.",
    "title": "Install Prisma Client in your existing project: JavaScript and MongoDB | Prisma Documentation",
    "description": "Install and generate Prisma Client in your existing project using a MongoDB database and Javascript.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/introspection-typescript-mongodb",
    "markdown": "# Introspection: MongoDB and TypeScript | Prisma Documentation\n\nPrisma ORM introspects a MongoDB schema by sampling the data stored in the given database and inferring the schema of that data.\n\nFor the purposes of illustrating introspection, this guide will help you setup a MongoDB from scratch. But if you have a MongoDB database already, feel free to jump to [Initializing Prisma ORM](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/introspection-typescript-mongodb#initializing-prisma-orm) in your project.\n\n## Setting up your Database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/introspection-typescript-mongodb#setting-up-your-database \"Direct link to Setting up your Database\")\n\nTo see this in action, first create a `blog` database with 2 collections: `User` and `Post`. We recommend [MongoDB Compass](https://www.mongodb.com/products/compass) for setting this up:\n\n![Create a blog database using Compass](https://www.prisma.io/docs/assets/images/1-create-database-deea00b13b4f0b2009693f39eec652d6.jpg)\n\nFirst, add a user to our `User` collection:\n\n![Create a user within the User collection](https://www.prisma.io/docs/assets/images/2-create-user-33e1750ccaf3170a908d32ad79ad551d.jpg)\n\nNext, add some posts to our `Post` collection. It's important that the ObjectID in `userId` matches the user you created above.\n\n![Create some posts within the Post collection](https://www.prisma.io/docs/assets/images/3-create-posts-1ac73aca28bd1ec2049bdad176c5e17c.jpg)\n\n## Initializing Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/introspection-typescript-mongodb#initializing-prisma-orm \"Direct link to Initializing Prisma ORM\")\n\nNow that you have a MongoDB database, the next step is to create a new project and initialize Prisma ORM:\n\n```\nmkdir blogcd blognpm init -ynpm install -D prismanpx prisma init\n```\n\nInitializing Prisma ORM will create a `prisma/schema.prisma` file. Edit this file to use MongoDB:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\nNext you'll need to adjust your `.env` file to point the `DATABASE_URL` to your MongoDB database\n\n## Introspecting MongoDB with Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/introspection-typescript-mongodb#introspecting-mongodb-with-prisma-orm \"Direct link to Introspecting MongoDB with Prisma ORM\")\n\nYou're now ready to introspect. Run the following command to introspect your database:\n\nThis command introspects our database and writes the inferred schema into your `prisma/schema.prisma` file:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model Post {  id     String @id @default(auto()) @map(\"_id\") @db.ObjectId  title  String  userId String @db.ObjectId}model User {  id    String @id @default(auto()) @map(\"_id\") @db.ObjectId  email String}\n```\n\n## Tweaking the Schema[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/introspection-typescript-mongodb#tweaking-the-schema \"Direct link to Tweaking the Schema\")\n\nTo be able to join data using Prisma Client, you can add the [`@relation`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relation) attributes to our models:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model Post {  id     String @id @default(auto()) @map(\"_id\") @db.ObjectId  title  String  userId String @db.ObjectId  user   User   @relation(fields: [userId], references: [id])}model User {  id    String @id @default(auto()) @map(\"_id\") @db.ObjectId  email String  posts Post[]}\n```\n\ntip\n\nWe're actively working on MongoDB introspection. Provide feedback for this feature in [this issue](https://github.com/prisma/prisma/issues/8241).\n\nAnd with that, you're ready to generate Prisma Client.",
    "title": "Introspection: MongoDB and TypeScript | Prisma Documentation",
    "description": "Introspection your MongoDB database with Prisma ORM",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/introspection-node-mongodb",
    "markdown": "# Introspection: MongoDB and JavaScript | Prisma Documentation\n\nPrisma ORM introspects a MongoDB schema by sampling the data stored in the given database and inferring the schema of that data.\n\nFor the purposes of illustrating introspection, this guide will help you setup a MongoDB from scratch. But if you have a MongoDB database already, feel free to jump to [Initializing Prisma ORM](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/introspection-node-mongodb#initializing-prisma-orm) in your project.\n\n## Setting up your Database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/introspection-node-mongodb#setting-up-your-database \"Direct link to Setting up your Database\")\n\nTo see this in action, first create a `blog` database with 2 collections: `User` and `Post`. We recommend [MongoDB Compass](https://www.mongodb.com/products/compass) for setting this up:\n\n![Create a blog database using Compass](https://www.prisma.io/docs/assets/images/1-create-database-deea00b13b4f0b2009693f39eec652d6.jpg)\n\nFirst, add a user to our `User` collection:\n\n![Create a user within the User collection](https://www.prisma.io/docs/assets/images/2-create-user-33e1750ccaf3170a908d32ad79ad551d.jpg)\n\nNext, add some posts to our `Post` collection. It's important that the ObjectID in `userId` matches the user you created above.\n\n![Create some posts within the Post collection](https://www.prisma.io/docs/assets/images/3-create-posts-1ac73aca28bd1ec2049bdad176c5e17c.jpg)\n\n## Initializing Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/introspection-node-mongodb#initializing-prisma-orm \"Direct link to Initializing Prisma ORM\")\n\nNow that you have a MongoDB database, the next step is to create a new project and initialize Prisma ORM:\n\n```\nmkdir blogcd blognpm init -ynpm install -D prismanpx prisma init\n```\n\nInitializing Prisma ORM will create a `prisma/schema.prisma` file. Edit this file to use MongoDB:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}\n```\n\nNext you'll need to adjust your `.env` file to point the `DATABASE_URL` to your MongoDB database\n\n## Introspecting MongoDB with Prisma ORM[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/introspection-node-mongodb#introspecting-mongodb-with-prisma-orm \"Direct link to Introspecting MongoDB with Prisma ORM\")\n\nYou're now ready to introspect. Run the following command to introspect your database:\n\nThis command introspects our database and writes the inferred schema into your `prisma/schema.prisma` file:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model Post {  id     String @id @default(auto()) @map(\"_id\") @db.ObjectId  title  String  userId String @db.ObjectId}model User {  id    String @id @default(auto()) @map(\"_id\") @db.ObjectId  email String}\n```\n\n## Tweaking the Schema[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/introspection-node-mongodb#tweaking-the-schema \"Direct link to Tweaking the Schema\")\n\nTo be able to join data using Prisma Client, you can add the [`@relation`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relation) attributes to our models:\n\nprisma/schema.prisma\n\n```\ndatasource db {  provider = \"mongodb\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model Post {  id     String @id @default(auto()) @map(\"_id\") @db.ObjectId  title  String  userId String @db.ObjectId  user   User   @relation(fields: [userId], references: [id])}model User {  id    String @id @default(auto()) @map(\"_id\") @db.ObjectId  email String  posts Post[]}\n```\n\ntip\n\nWe're actively working on MongoDB introspection. Provide feedback for this feature in [this issue](https://github.com/prisma/prisma/issues/8241).\n\nAnd with that, you're ready to generate Prisma Client.",
    "title": "Introspection: MongoDB and JavaScript | Prisma Documentation",
    "description": "Introspect your MongoDB database with Prisma ORM",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/install-prisma-client-typescript-mongodb",
    "markdown": "# Install Prisma Client in your existing project: TypeScript and MongoDB\n\nTo get started with Prisma Client, you need to install the `@prisma/client` package:\n\n```\nnpm install @prisma/client\n```\n\nThe install command invokes `prisma generate` for you which reads your Prisma schema and generates a version of Prisma Client that is _tailored_ to your models.\n\nWhenever you make changes to your Prisma schema in the future, you manually need to invoke `prisma generate` in order to accommodate the changes in your Prisma Client API.",
    "title": "Install Prisma Client in your existing project: TypeScript and MongoDB | Prisma Documentation",
    "description": "Install and generate Prisma Client in your existing project using a MongoDB database and TypeScript.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/development-environment/environment-variables/using-multiple-env-files",
    "markdown": "# Using multiple .env files. | Prisma Documentation\n\nThere is a risk that your production database could be deleted if you store different connection URLs to each of your environments within a single `.env` file.\n\nOne solution is to have multiple `.env` files which each represent different environments. In practice, this means you create a file for each of your environments:\n\n*   `.env.development`\n*   `.env.sample`\n\nwarning\n\n`.env.production` is omitted from the above list as it is not recommended to store your production credentials locally, even if they are git-ignored.\n\nThen using a package like [`dotenv-cli`](https://www.npmjs.com/package/dotenv-cli), you can load the correct connection URL for the environment you are working in.\n\n## Setup multiple `.env` files[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/using-multiple-env-files#setup-multiple-env-files \"Direct link to setup-multiple-env-files\")\n\nFor the purpose of this guide, it is assumed you have a dedicated development database that you use whilst developing your application.\n\n1.  Rename your `.env` file to `.env.development`\n\n.env.development\n\n```\nDATABASE_URL=\"postgresql://prisma:prisma@localhost:5433/dev\"\n```\n\n2.  Create a new `.env.sample` file and change the database name to `sample` (or your preferred name)\n\n.env.sample\n\n```\nDATABASE_URL=\"postgresql://prisma:prisma@localhost:5433/sample\"\n```\n\n3.  Install [`dotenv-cli`](https://www.npmjs.com/package/dotenv-cli)\n\nIn order for Prisma ORM and Jest to know which `.env` file to use, alter your `package.json` scripts to include and call the `dotenv` package and specify which file to use depending on what commands you are running and in which environment you want them to run.\n\ninfo\n\nAny top-level script that is running the tests and migrations needs the `dotenv` command before it. This makes sure that the env variables from `.env.sample` are passed to all commands, including Jest.\n\n### Running migrations on different environments[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/using-multiple-env-files#running-migrations-on-different-environments \"Direct link to Running migrations on different environments\")\n\nYou can use the [`dotenv-cli`](https://www.npmjs.com/package/dotenv-cli) package to specify which environment file Prisma ORM should use when running a migration.\n\nThe below script uses `dotenv-cli` to pass the `.env.sample` environment file (which holds a `DATABASE_URL` connection string) to the Prisma ORM migration script.\n\n#### Migration script[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/using-multiple-env-files#migration-script \"Direct link to Migration script\")\n\npackage.json\n\n```\n  \"scripts\": {    \"migrate:postgres\": \"dotenv -e .env.sample -- npx prisma migrate deploy\",  },\n```\n\n### Running tests on different environments[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/using-multiple-env-files#running-tests-on-different-environments \"Direct link to Running tests on different environments\")\n\nWhen running tests, we advise you to [mock Prisma Client](https://www.prisma.io/docs/orm/prisma-client/testing/unit-testing#mocking-prisma-client). In doing so, you need to tell Jest which environment it should use when running its tests.\n\nBy default, Prisma Client will use the environment specified in the default `.env` file located at the project's root.\n\nIf you have created a separate `.env.sample` file to specify your testing database, then this environment will need to be passed to Jest.\n\nThe below script uses `dotenv-cli` to pass the `.env.sample` environment file (which holds a `DATABASE_URL` connection string) to Jest.\n\n#### Test script[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/using-multiple-env-files#test-script \"Direct link to Test script\")\n\npackage.json\n\n```\n  \"scripts\": {    \"test\": \"dotenv -e .env.sample -- jest -i\"  },\n```",
    "title": "Using multiple .env files. | Prisma Documentation",
    "description": "Learn how to set up a dedicated testing environment using multiple .env files.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/querying-the-database-node-mongodb",
    "markdown": "# Querying the database in your existing project: MongoDB and JavaScript\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/querying-the-database-node-mongodb#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nIf you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.\n\nFor the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).\n\nCreate a new file named `index.js` and add the following code to it:\n\nindex.js\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Connect to the database\n5.  Call the `main` function\n6.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.js\n\n```\nasync function main() {-  // ... you will write your Prisma Client queries here+  const allUsers = await prisma.user.findMany()+  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nIf you introspected an existing database with records, the query should return an array of JavaScript objects.\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/querying-the-database-node-mongodb#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post`, `User` and `Comment` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.js\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Rich',      email: 'hello@prisma.com',      posts: {        create: {          title: 'My first post',          body: 'Lots of really interesting stuff',          slug: 'my-first-post',        },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with a new `Post` using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the other one via the `Post.author` ↔ `User.posts` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    id: '60cc9b0e001e3bfd00a6eddf',    email: 'hello@prisma.com',    name: 'Rich',    posts: [      {        id: '60cc9bad005059d6007f45dd',        slug: 'my-first-post',        title: 'My first post',        body: 'Lots of really interesting stuff',        userId: '60cc9b0e001e3bfd00a6eddf',      },    ],  },]\n```\n\nThe query added new records to the `User` and the `Post` collections:\n\ninfo\n\nThe `id` field in the Prisma schema maps to `_id` in the underlying MongoDB database.\n\n**User** collection\n\n| **\\_id** | **email** | **name** |\n| --- | --- | --- |\n| `60cc9b0e001e3bfd00a6eddf` | `\"hello@prisma.com\"` | `\"Rich\"` |\n\n**Post** collection\n\n| **\\_id** | **createdAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- |\n| `60cc9bad005059d6007f45dd` | `2020-03-21T16:45:01.246Z` | `\"My first post\"` | `Lots of really interesting stuff` | `false` | `60cc9b0e001e3bfd00a6eddf` |\n\n> **Note**: The unique identifier in the `authorId` document field on `Post` reference the `_id` document field in the `User` collection, meaning the `_id` value `60cc9b0e001e3bfd00a6eddf` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll add a couple of comments to the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.js\n\n```\nasync function main() {  await prisma.post.update({    where: {      slug: 'my-first-post',    },    data: {      comments: {        createMany: {          data: [            { comment: 'Great post!' },            { comment: \"Can't wait to read more!\" },          ],        },      },    },  })  const posts = await prisma.post.findMany({    include: {      comments: true,    },  })  console.dir(posts, { depth: Infinity })}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n[  {    id: '60cc9bad005059d6007f45dd',    slug: 'my-first-post',    title: 'My first post',    body: 'Lots of really interesting stuff',    userId: '60cc9b0e001e3bfd00a6eddf',    comments: [      {        id: '60cca420008a21d800578793',        postId: '60cca40300af8bf000f6ca99',        comment: 'Great post!',      },      {        id: '60cca420008a21d800578794',        postId: '60cca40300af8bf000f6ca99',        comment: \"Can't wait to try this!\",      },    ],  },]\n```\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database in your existing project: MongoDB and JavaScript | Prisma Documentation",
    "description": "Write data to and query your MongoDB database in your existing project.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare",
    "markdown": "# Deploy to Cloudflare Workers & Pages\n\nThis page covers everything you need to know to deploy an app with Prisma ORM to a [Cloudflare Worker](https://developers.cloudflare.com/workers/) or to [Cloudflare Pages](https://developers.cloudflare.com/pages).\n\n## General considerations when deploying to Cloudflare Workers[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#general-considerations-when-deploying-to-cloudflare-workers \"Direct link to General considerations when deploying to Cloudflare Workers\")\n\nThis section covers _general_ things you need to be aware of when deploying to Cloudflare Workers or Pages and are using Prisma ORM, regardless of the database provider you use.\n\n### Using an edge-compatible driver[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#using-an-edge-compatible-driver \"Direct link to Using an edge-compatible driver\")\n\nWhen deploying a Cloudflare Worker that uses Prisma ORM, you need to use an [edge-compatible driver](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview#edge-compatibility-of-database-drivers) and its respective [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters) for Prisma ORM.\n\nThe edge-compatible drivers for Cloudflare Workers and Pages are:\n\n*   [Neon Serverless](https://neon.tech/docs/serverless/serverless-driver) uses HTTP to access the database\n*   [PlanetScale Serverless](https://planetscale.com/docs/tutorials/planetscale-serverless-driver) uses HTTP to access the database\n*   [`node-postgres`](https://node-postgres.com/) (`pg`) uses Cloudflare's `connect()` (TCP) to access the database\n*   [`@libsql/client`](https://github.com/tursodatabase/libsql-client-ts) is used to access Turso databases via HTTP\n*   [Cloudflare D1](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#cloudflare-d1) is used to access D1 databases\n\nThere's [also work being done](https://github.com/sidorares/node-mysql2/pull/2289) on the `node-mysql2` driver which will enable access to traditional MySQL databases from Cloudflare Workers and Pages in the future as well.\n\n> **Note**: [Prisma Accelerate](https://www.prisma.io/docs/accelerate) enables you to access _any_ database from _any_ edge function provider. No edge-compatible driver is necessary.\n\n### Setting your database connection URL as an environment variable[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#setting-your-database-connection-url-as-an-environment-variable \"Direct link to Setting your database connection URL as an environment variable\")\n\nFirst, ensure that the `DATABASE_URL` is set as the `url` of the `datasource` in your Prisma schema:\n\n```\ndatasource db {  provider = \"postgresql\" // this might also be `mysql` or another value depending on your database  url      = env(\"DATABASE_URL\")}\n```\n\n#### Development[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#development \"Direct link to Development\")\n\nWhen using your Worker in **development**, you can configure your database connection via the [`.dev.vars` file](https://developers.cloudflare.com/workers/configuration/secrets/#secrets-in-development) locally.\n\nAssuming you use the `DATABASE_URL` environment variable from above, you can set it inside `.dev.vars` as follows:\n\n.dev.vars\n\n```\nDATABASE_URL=\"your-database-connection-string\"\n```\n\nIn the above snippet, `your-database-connection-string` is a placeholder that you need to replace with the value of your own connection string, for example:\n\n.dev.vars\n\n```\nDATABASE_URL=\"postgresql://admin:mypassword42@somehost.aws.com:5432/mydb\"\n```\n\nNote that the `.dev.vars` file is not compatible with `.env` files which are typically used by Prisma ORM.\n\nThis means that you need to make sure that Prisma ORM gets access to the environment variable when needed, e.g. when running a Prisma CLI command like `prisma migrate dev`.\n\nThere are several options for achieving this:\n\n*   Run your Prisma CLI commands using [`dotenv`](https://www.npmjs.com/package/dotenv-cli) to specify from where the CLI should read the environment variable, for example:\n    \n    ```\n    dotenv -e .dev.vars -- npx prisma migrate dev\n    ```\n    \n*   Create a script in `package.json` that reads `.dev.vars` via [`dotenv`](https://www.npmjs.com/package/dotenv-cli). You can then execute `prisma` commands as follows: `npm run env -- npx prisma migrate dev`. Here's a reference for the script:\n    \n    package.json\n    \n    ```\n    \"scripts\":  { \"env\": \"dotenv -e .dev.vars\" }\n    ```\n    \n*   Duplicate the `DATABASE_URL` and any other relevant env vars into a new file called `.env` which can then be used by Prisma ORM.\n\n> **Note**: If you're using an approach that requires `dotenv`, you need to have the [`dotenv-cli`](https://www.npmjs.com/package/dotenv-cli) package installed. You can do this e.g. by using this command to install the package locally in your project: `npm install -D dotenv-cli`.\n\n#### Production[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#production \"Direct link to Production\")\n\nWhen deploying your Worker to **production**, you'll need to set the database connection using the `wrangler` CLI:\n\n```\nnpx wrangler secret put DATABASE_URL\n```\n\nThe command is interactive and will ask you to enter the value for the `DATABASE_URL` env var as the next step in the terminal.\n\n> **Note**: This command requires you to be authenticated, and will ask you to log in to your Cloudflare account in case you are not.\n\n### Size limits on free accounts[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#size-limits-on-free-accounts \"Direct link to Size limits on free accounts\")\n\nCloudflare has a [size limit of 1 MB for Workers on the free plan](https://developers.cloudflare.com/workers/platform/limits/). If your application bundle with Prisma ORM exceeds that size, we recommend upgrading to a paid Worker plan or using Prisma Accelerate to deploy your application.\n\nIf you're running into this problem with `pg` and the `@prisma/adapter-pg` package, you can replace the `pg` with the custom [`@prisma/pg-worker`](https://github.com/prisma/prisma/tree/main/packages/pg-worker) package and use the [`@prisma/adapter-pg-worker`](https://github.com/prisma/prisma/tree/main/packages/adapter-pg-worker) adapter that belongs to it.\n\n`@prisma/pg-worker` is an optimized and lightweight version of `pg` that is designed to be used in a Worker. It is a drop-in replacement for `pg` and is fully compatible with Prisma ORM.\n\n### Deploying a Next.js app to Cloudflare Pages with `@cloudflare/next-on-pages`[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#deploying-a-nextjs-app-to-cloudflare-pages-with-cloudflarenext-on-pages \"Direct link to deploying-a-nextjs-app-to-cloudflare-pages-with-cloudflarenext-on-pages\")\n\nCloudflare offers an option to run Next.js apps on Cloudflare Pages with [`@cloudflare/next-on-pages`](https://github.com/cloudflare/next-on-pages), see the [docs](https://developers.cloudflare.com/pages/framework-guides/deploy-a-nextjs-site) for instructions.\n\nBased on some testing, we found the following:\n\n*   You can deploy using the PlanetScale or Neon Serverless Driver.\n*   Traditional PostgreSQL deployments using `pg` don't work because `pg` itself currently does not work with `@cloudflare/next-on-pages` (see [here](https://github.com/cloudflare/next-on-pages/issues/605)).\n\nFeel free to reach out to us on [Discord](https://pris.ly/discord) if you find that anything has changed about this.\n\n### Set `PRISMA_CLIENT_FORCE_WASM=1` when running locally with `node`[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#set-prisma_client_force_wasm1-when-running-locally-with-node \"Direct link to set-prisma_client_force_wasm1-when-running-locally-with-node\")\n\nSome frameworks (e.g. [hono](https://hono.dev/)) use `node` instead of `wrangler` for running Workers locally. If you're using such a framework or are running your Worker locally with `node` for another reason, you need to set the `PRISMA_CLIENT_FORCE_WASM` environment variable:\n\n```\nexport PRISMA_CLIENT_FORCE_WASM=1\n```\n\n## Database-specific considerations & examples[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#database-specific-considerations--examples \"Direct link to Database-specific considerations & examples\")\n\nThis section provides database-specific instructions for deploying a Cloudflare Worker with Prisma ORM.\n\n### Prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#prerequisites \"Direct link to Prerequisites\")\n\nAs a prerequisite for the following section, you need to have a Cloudflare Worker running locally and the Prisma CLI installed.\n\nIf you don't have that yet, you can run these commands:\n\n```\nnpm create cloudflare@latest prisma-cloudflare-worker-example -- --type hello-worldcd prisma-cloudflare-worker-examplenpm install prisma --save-devnpx prisma init\n```\n\nYou'll further need a database instance of your database provider of choice available. Refer to the respective documentation of the provider for setting up that instance.\n\nWe'll use the default `User` model for the example below:\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?}\n```\n\n### PostgreSQL (traditional)[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#postgresql-traditional \"Direct link to PostgreSQL (traditional)\")\n\nIf you are using a traditional PostgreSQL database that's accessed via TCP and the `pg` driver, you need to:\n\n*   use the `@prisma/adapter-pg` database adapter (via the `driverAdapters` Preview feature)\n*   set `node_compat = true` in `wrangler.toml` (see the [Cloudflare docs](https://developers.cloudflare.com/workers/wrangler/configuration/#add-polyfills-using-wrangler))\n\nIf you are running into a size issue and can't deploy your application because of that, you can use our slimmer variant of the `pg` driver package [`@prisma/pg-worker`](https://github.com/prisma/prisma/tree/main/packages/pg-worker) and the [`@prisma/adapter-pg-worker`](https://github.com/prisma/prisma/tree/main/packages/adapter-pg-worker) adapter that belongs to it.\n\n`@prisma/pg-worker` is an optimized and lightweight version of `pg` that is designed to be used in a Worker. It is a drop-in replacement for `pg` and is fully compatible with Prisma ORM.\n\n#### 1\\. Configure Prisma schema & database connection[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#1-configure-prisma-schema--database-connection \"Direct link to 1. Configure Prisma schema & database connection\")\n\n> **Note**: If you don't have a project to deploy, follow the instructions in the [Prerequisites](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#prerequisites) to bootstrap a basic Cloudflare Worker with Prisma ORM in it.\n\nFirst, ensure that the database connection is configured properly. In your Prisma schema, set the `url` of the `datasource` block to the `DATABASE_URL` environment variable. You also need to enable the `driverAdapters` feature flag:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNext, you need to set the `DATABASE_URL` environment variable to the value of your database connection string. You'll do this in a file called `.dev.vars` used by Cloudflare:\n\n.dev.vars\n\n```\nDATABASE_URL=\"postgresql://admin:mypassword42@somehost.aws.com:5432/mydb\"\n```\n\nBecause the Prisma CLI by default is only compatible with `.env` files, you can adjust your `package.json` with the following script that loads the env vars from `.dev.vars`. You can then use this script to load the env vars before executing a `prisma` command.\n\nAdd this script to your `package.json`:\n\npackage.json\n\n```\n{  // ...  \"scripts\": {    // ....    \"env\": \"dotenv -e .dev.vars\"  },  // ...}\n```\n\nNow you can execute Prisma CLI commands as follows while ensuring that the command has access to the env vars in `.dev.vars`:\n\n```\nnpm run env -- npx prisma\n```\n\n#### 2\\. Install dependencies[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#2-install-dependencies \"Direct link to 2. Install dependencies\")\n\nNext, install the required packages:\n\n```\nnpm install @prisma/adapter-pgnpm install pgnpm install @types/pg --save-dev # if you're using TypeScript\n```\n\n#### 3\\. Set `node_compat = true` in `wrangler.toml`[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#3-set-node_compat--true-in-wranglertoml \"Direct link to 3-set-node_compat--true-in-wranglertoml\")\n\nIn your `wrangler.toml` file, add the following line:\n\nwrangler.toml\n\n> **Note**: For Cloudflare Pages, using `node_compat` is not officially supported. If you want to use `pg` in Cloudflare Pages, you can find a workaround [here](https://github.com/cloudflare/workers-sdk/pull/2541#issuecomment-1954209855).\n\n#### 4\\. Migrate your database schema (if applicable)[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#4-migrate-your-database-schema-if-applicable \"Direct link to 4. Migrate your database schema (if applicable)\")\n\nIf you ran `npx prisma init` above, you need to migrate your database schema to create the `User` table that's defined in your Prisma schema (if you already have all the tables you need in your database, you can skip this step):\n\n```\nnpm run env -- npx prisma migrate dev --name init\n```\n\n#### 5\\. Use Prisma Client in your Worker to send a query to the database[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#5-use-prisma-client-in-your-worker-to-send-a-query-to-the-database \"Direct link to 5. Use Prisma Client in your Worker to send a query to the database\")\n\nHere is a sample code snippet that you can use to instantiate `PrismaClient` and send a query to your database:\n\n```\nimport { PrismaClient } from '@prisma/client'import { PrismaPg } from '@prisma/adapter-pg'import { Pool } from 'pg'export default {  async fetch(request, env, ctx) {    const pool = new Pool({ connectionString: env.DATABASE_URL })    const adapter = new PrismaPg(pool)    const prisma = new PrismaClient({ adapter })    const users = await prisma.user.findMany()    const result = JSON.stringify(users)    return new Response(result)  },}\n```\n\n#### 6\\. Run the Worker locally[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#6-run-the-worker-locally \"Direct link to 6. Run the Worker locally\")\n\nTo run the Worker locally, you can run the `wrangler dev` command:\n\n#### 7\\. Set the `DATABASE_URL` environment variable and deploy the Worker[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#7-set-the-database_url-environment-variable-and-deploy-the-worker \"Direct link to 7-set-the-database_url-environment-variable-and-deploy-the-worker\")\n\nTo deploy the Worker, you first need to the `DATABASE_URL` environment variable [via the `wrangler` CLI](https://developers.cloudflare.com/workers/configuration/secrets/#secrets-on-deployed-workers):\n\n```\nnpx wrangler secret put DATABASE_URL\n```\n\nThe command is interactive and will ask you to enter the value for the `DATABASE_URL` env var as the next step in the terminal.\n\n> **Note**: This command requires you to be authenticated, and will ask you to log in to your Cloudflare account in case you are not.\n\nThen you can go ahead then deploy the Worker:\n\nThe command will output the URL where you can access the deployed Worker.\n\n### PlanetScale[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#planetscale \"Direct link to PlanetScale\")\n\nIf you are using a PlanetScale database, you need to:\n\n*   use the `@prisma/adapter-planetscale` database adapter (via the `driverAdapters` Preview feature)\n    \n*   manually remove the conflicting `cache` field ([learn more](https://developers.cloudflare.com/workers/databases/native-integrations/planetscale/#:~:text=fetch%3A%20(,init)%3B)):\n    \n    ```\n    export default {  async fetch(request, env, ctx) {    const client = new Client({      url: env.DATABASE_URL,      // see https://github.com/cloudflare/workerd/issues/698      fetch(url, init) {        delete init['cache']        return fetch(url, init)      },    })    const adapter = new PrismaPlanetScale(client)    const prisma = new PrismaClient({ adapter })    // ...  },}\n    ```\n    \n\n#### 1\\. Configure Prisma schema & database connection[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#1-configure-prisma-schema--database-connection-1 \"Direct link to 1. Configure Prisma schema & database connection\")\n\n> **Note**: If you don't have a project to deploy, follow the instructions in the [Prerequisites](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#prerequisites) to bootstrap a basic Cloudflare Worker with Prisma ORM in it.\n\nFirst, ensure that the database connection is configured properly. In your Prisma schema, set the `url` of the `datasource` block to the `DATABASE_URL` environment variable. You also need to enable the `driverAdapters` feature flag:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}datasource db {  provider     = \"mysql\"  url          = env(\"DATABASE_URL\")  relationMode = \"prisma\" // required for PlanetScale (as by default foreign keys are disabled)}\n```\n\nNext, you need to set the `DATABASE_URL` environment variable to the value of your database connection string. You'll do this in a file called `.dev.vars` used by Cloudflare:\n\n.dev.vars\n\n```\nDATABASE_URL=\"mysql://32qxa2r7hfl3102wrccj:password@us-east.connect.psdb.cloud/demo-cf-worker-ps?sslaccept=strict\"\n```\n\nBecause the Prisma CLI by default is only compatible with `.env` files, you can adjust your `package.json` with the following script that loads the env vars from `.dev.vars`. You can then use this script to load the env vars before executing a `prisma` command.\n\nAdd this script to your `package.json`:\n\npackage.json\n\n```\n{  // ...  \"scripts\": {    // ....    \"env\": \"dotenv -e .dev.vars\"  },  // ...}\n```\n\nNow you can execute Prisma CLI commands as follows while ensuring that the command has access to the env vars in `.dev.vars`:\n\n```\nnpm run env -- npx prisma\n```\n\n#### 2\\. Install dependencies[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#2-install-dependencies-1 \"Direct link to 2. Install dependencies\")\n\nNext, install the required packages:\n\n```\nnpm install @prisma/adapter-planetscalenpm install @planetscale/database\n```\n\n#### 3\\. Migrate your database schema (if applicable)[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#3-migrate-your-database-schema-if-applicable \"Direct link to 3. Migrate your database schema (if applicable)\")\n\nIf you ran `npx prisma init` above, you need to migrate your database schema to create the `User` table that's defined in your Prisma schema (if you already have all the tables you need in your database, you can skip this step):\n\n```\nnpm run env -- npx prisma db push\n```\n\n#### 4\\. Use Prisma Client in your Worker to send a query to the database[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#4-use-prisma-client-in-your-worker-to-send-a-query-to-the-database \"Direct link to 4. Use Prisma Client in your Worker to send a query to the database\")\n\nHere is a sample code snippet that you can use to instantiate `PrismaClient` and send a query to your database:\n\n```\nimport { PrismaClient } from '@prisma/client'import { PrismaPlanetScale } from '@prisma/adapter-planetscale'import { Client } from '@planetscale/database'export default {  async fetch(request, env, ctx) {    const client = new Client({      url: env.DATABASE_URL,      // see https://github.com/cloudflare/workerd/issues/698      fetch(url, init) {        delete init['cache']        return fetch(url, init)      },    })    const adapter = new PrismaPlanetScale(client)    const prisma = new PrismaClient({ adapter })    const users = await prisma.user.findMany()    const result = JSON.stringify(users)    return new Response(result)  },}\n```\n\n#### 6\\. Run the Worker locally[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#6-run-the-worker-locally-1 \"Direct link to 6. Run the Worker locally\")\n\nTo run the Worker locally, you can run the `wrangler dev` command:\n\n#### 7\\. Set the `DATABASE_URL` environment variable and deploy the Worker[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#7-set-the-database_url-environment-variable-and-deploy-the-worker-1 \"Direct link to 7-set-the-database_url-environment-variable-and-deploy-the-worker-1\")\n\nTo deploy the Worker, you first need to the `DATABASE_URL` environment variable [via the `wrangler` CLI](https://developers.cloudflare.com/workers/configuration/secrets/#secrets-on-deployed-workers):\n\n```\nnpx wrangler secret put DATABASE_URL\n```\n\nThe command is interactive and will ask you to enter the value for the `DATABASE_URL` env var as the next step in the terminal.\n\n> **Note**: This command requires you to be authenticated, and will ask you to log in to your Cloudflare account in case you are not.\n\nThen you can go ahead then deploy the Worker:\n\nThe command will output the URL where you can access the deployed Worker.\n\n### Neon[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#neon \"Direct link to Neon\")\n\nIf you are using a Neon database, you need to:\n\n*   use the `@prisma/adapter-neon` database adapter (via the `driverAdapters` Preview feature)\n\n#### 1\\. Configure Prisma schema & database connection[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#1-configure-prisma-schema--database-connection-2 \"Direct link to 1. Configure Prisma schema & database connection\")\n\n> **Note**: If you don't have a project to deploy, follow the instructions in the [Prerequisites](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#prerequisites) to bootstrap a basic Cloudflare Worker with Prisma ORM in it.\n\nFirst, ensure that the database connection is configured properly. In your Prisma schema, set the `url` of the `datasource` block to the `DATABASE_URL` environment variable. You also need to enable the `driverAdapters` feature flag:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNext, you need to set the `DATABASE_URL` environment variable to the value of your database connection string. You'll do this in a file called `.dev.vars` used by Cloudflare:\n\n.dev.vars\n\n```\nDATABASE_URL=\"postgresql://janedoe:password@ep-nameless-pond-a23b1mdz.eu-central-1.aws.neon.tech/neondb?sslmode=require\"\n```\n\nBecause the Prisma CLI by default is only compatible with `.env` files, you can adjust your `package.json` with the following script that loads the env vars from `.dev.vars`. You can then use this script to load the env vars before executing a `prisma` command.\n\nAdd this script to your `package.json`:\n\npackage.json\n\n```\n{  // ...  \"scripts\": {    // ....    \"env\": \"dotenv -e .dev.vars\"  },  // ...}\n```\n\nNow you can execute Prisma CLI commands as follows while ensuring that the command has access to the env vars in `.dev.vars`:\n\n```\nnpm run env -- npx prisma\n```\n\n#### 2\\. Install dependencies[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#2-install-dependencies-2 \"Direct link to 2. Install dependencies\")\n\nNext, install the required packages:\n\n```\nnpm install @prisma/adapter-neonnpm install @neondatabase/serverless\n```\n\n#### 3\\. Migrate your database schema (if applicable)[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#3-migrate-your-database-schema-if-applicable-1 \"Direct link to 3. Migrate your database schema (if applicable)\")\n\nIf you ran `npx prisma init` above, you need to migrate your database schema to create the `User` table that's defined in your Prisma schema (if you already have all the tables you need in your database, you can skip this step):\n\n```\nnpm run env -- npx prisma migrate dev --name init\n```\n\n#### 5\\. Use Prisma Client in your Worker to send a query to the database[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#5-use-prisma-client-in-your-worker-to-send-a-query-to-the-database-1 \"Direct link to 5. Use Prisma Client in your Worker to send a query to the database\")\n\nHere is a sample code snippet that you can use to instantiate `PrismaClient` and send a query to your database:\n\n```\nimport { PrismaClient } from '@prisma/client'import { PrismaNeon } from '@prisma/adapter-neon'import { Pool } from '@neondatabase/serverless'export default {  async fetch(request, env, ctx) {    const neon = new Pool({ connectionString: env.DATABASE_URL })    const adapter = new PrismaNeon(neon)    const prisma = new PrismaClient({ adapter })    const users = await prisma.user.findMany()    const result = JSON.stringify(users)    return new Response(result)  },}\n```\n\n#### 6\\. Run the Worker locally[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#6-run-the-worker-locally-2 \"Direct link to 6. Run the Worker locally\")\n\nTo run the Worker locally, you can run the `wrangler dev` command:\n\n#### 7\\. Set the `DATABASE_URL` environment variable and deploy the Worker[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#7-set-the-database_url-environment-variable-and-deploy-the-worker-2 \"Direct link to 7-set-the-database_url-environment-variable-and-deploy-the-worker-2\")\n\nTo deploy the Worker, you first need to the `DATABASE_URL` environment variable [via the `wrangler` CLI](https://developers.cloudflare.com/workers/configuration/secrets/#secrets-on-deployed-workers):\n\n```\nnpx wrangler secret put DATABASE_URL\n```\n\nThe command is interactive and will ask you to enter the value for the `DATABASE_URL` env var as the next step in the terminal.\n\n> **Note**: This command requires you to be authenticated, and will ask you to log in to your Cloudflare account in case you are not.\n\nThen you can go ahead then deploy the Worker:\n\nThe command will output the URL where you can access the deployed Worker.\n\n### Cloudflare D1[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#cloudflare-d1 \"Direct link to Cloudflare D1\")\n\nIf you are using a D1 database, you need to:\n\n*   use the `@prisma/adapter-d1` database adapter (via the `driverAdapters` Preview feature)\n*   set `sqlite` as the `datasource` provider in your Prisma schema\n*   manually generate SQL statements for schema changes using `prisma migrate diff` but execute them using [D1's migration system](https://developers.cloudflare.com/d1/reference/migrations/)\n\nYou can find a [deployment-ready example on GitHub](https://github.com/prisma/prisma-examples/blob/latest/deployment-platforms/edge/cloudflare-workers/with-d1).\n\n#### 1\\. Configure Prisma schema[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#1-configure-prisma-schema \"Direct link to 1. Configure Prisma schema\")\n\n> **Note**: If you don't have a project to deploy, follow the instructions in the [Prerequisites](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#prerequisites) to bootstrap a basic Cloudflare Worker with Prisma ORM in it.\n\nIn your Prisma schema, add the `driverAdapters` Preview feature to the `generator` block and set the `provider` of the `datasource` to `sqlite`. If you just bootstrapped the Prisma schema with `prisma init`, also be sure to add the following `User` model to it:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}datasource db {  provider = \"sqlite\"  url      = env(\"DATABASE_URL\")}model User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?}\n```\n\nNote that in this tutorial, you won't need the `.env` file since the connection between Prisma ORM and D1 will happen through a [binding](https://developers.cloudflare.com/workers/configuration/bindings/).\n\n#### 2\\. Install dependencies[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#2-install-dependencies-3 \"Direct link to 2. Install dependencies\")\n\nNext, install the required packages:\n\n```\nnpm install @prisma/adapter-d1\n```\n\nAlso, be sure to use a version of the Wrangler CLI that's above [`wrangler@^3.39.0`](https://github.com/cloudflare/workers-sdk/releases/tag/wrangler%403.39.0), otherwise the `--remote` flag that's used in the next sections won't be available.\n\n#### 3\\. Set the D1 database connection via a binding[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#3-set-the-d1-database-connection-via-a-binding \"Direct link to 3. Set the D1 database connection via a binding\")\n\nTo connect your Workers with the D1 instance, add the following binding to your `wrangler.toml` (if you don't have a D1 instance yet, you can create one using the [Cloudflare Dashboard](https://dash.cloudflare.com/) or with the [`wrangler d1 create`](https://developers.cloudflare.com/workers/wrangler/commands/#create) command):\n\nwrangler.toml\n\n```\nname = \"prisma-cloudflare-worker-example\"main = \"src/index.ts\"compatibility_date = \"2024-03-20\"compatibility_flags = [\"nodejs_compat\"][[d1_databases]]binding = \"DB\" # i.e. available in your Worker on env.DBdatabase_name = \"__YOUR_D1_DATABASE_NAME__\" # to be replaceddatabase_id = \"__YOUR_D1_DATABASE_ID__\"     # to be replaced\n```\n\nNote that `__YOUR_D1_DATABASE_NAME__` and `__YOUR_D1_DATABASE_ID__` in the snippet above are placeholders that should be replaced with the database name and ID of your own D1 instance.\n\nIf you weren't able to grab this ID from the terminal output, you can also find it in the Cloudflare Dashboard or by running `npx wrangler d1 list` and `npx wrangler d1 info __YOUR_D1_DATABASE_NAME__` in your terminal.\n\n#### 4\\. Migrate your database schema (if applicable)[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#4-migrate-your-database-schema-if-applicable-1 \"Direct link to 4. Migrate your database schema (if applicable)\")\n\nIf your Prisma schema only contains the `User` model but your D1 database is still empty, you need to make sure that there is a table in D1 that mirrors the structure of the `User` model.\n\nD1 comes with its own [migration system](https://developers.cloudflare.com/d1/reference/migrations/) that lets you manage migration files in your file system. While this is convenient for creating and applying migration files, it doesn't help you identifying the actual SQL statements that you need to put into these migration files. That's where Prisma Migrate comes into play, because you can generate SQL statements for schema changes using the [`prisma migrate diff`](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff) command.\n\nFirst, create the `migrations` directory and initial migration file using the [`wrangler d1 migrations`](https://developers.cloudflare.com/workers/wrangler/commands/#migrations-create) command as follows:\n\n```\nnpx wrangler d1 migrations create __YOUR_D1_DATABASE_NAME__ create_user_table\n```\n\nReplace `__YOUR_D1_DATABASE_NAME__` with the name of your database again and, when prompted, confirm that you want to create the `migrations` directory. After having run this command, there should be a new folder called `migrations` with a file called `0001_create_user_table.sql` inside of it.\n\nYou can now generate the required SQL statement for creating a `User` table that can be mapped to the `User` model in your the Prisma schema as follows:\n\n```\nnpx prisma migrate diff --from-empty --to-schema-datamodel ./prisma/schema.prisma --script --output migrations/0001_create_user_table.sql\n```\n\nNote that the resulting SQL statement is stored in a file in the `migrations` directory called `0001_create_user_table.sql` which looks as follows:\n\nmigrations/0001\\_create\\_user\\_table.sql\n\n```\n-- CreateTableCREATE TABLE \"User\" (    \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,    \"email\" TEXT NOT NULL,    \"name\" TEXT);-- CreateIndexCREATE UNIQUE INDEX \"User_email_key\" ON \"User\"(\"email\");\n```\n\nYou now need to use the [`wrangler d1 migrations apply`](https://developers.cloudflare.com/workers/wrangler/commands/#migrations-apply) command to send this SQL statement to D1. Note that this command accepts two options:\n\n*   `--local`: Executes the statement against a _local_ version of D1. This local version of D1 is a SQLite database file that'll be located in your project. This approach is useful, when you want to develop and test your Worker on your local machine. Learn more in the [Cloudflare docs](https://developers.cloudflare.com/d1/configuration/local-development/).\n*   `--remote`: Executes the statement against your _remote_ version of D1. This version is used by your _deployed_ Cloudflare Workers. Learn more in the [Cloudflare docs](https://developers.cloudflare.com/d1/configuration/remote-development/).\n\nIn this tutorial, you'll do both: test the Worker locally _and_ deploy it afterwards. So, you need to run both commands. Open your terminal and paste the following commands:\n\n```\n# For the local databasenpx wrangler d1 migrations apply __YOUR_D1_DATABASE_NAME__ --local# For the remote databasenpx wrangler d1 migrations apply __YOUR_D1_DATABASE_NAME__ --remote\n```\n\nAs before, you need to replace `__YOUR_D1_DATABASE_NAME__` with the name of your D1 database.\n\nLet's also create some dummy data that we can query once the Worker is running. This time, you'll run the SQL statement without storing it in a file:\n\n```\n# For the local databasenpx wrangler d1 execute __YOUR_D1_DATABASE_NAME__ --command \"INSERT INTO  \\\"User\\\" (\\\"email\\\", \\\"name\\\") VALUES('jane@prisma.io', 'Jane Doe (Local)');\" --local# For the remote databasenpx wrangler d1 execute __YOUR_D1_DATABASE_NAME__ --command \"INSERT INTO  \\\"User\\\" (\\\"email\\\", \\\"name\\\") VALUES('jane@prisma.io', 'Jane Doe (Remote)');\" --remote\n```\n\n#### 5\\. Use Prisma Client in your Worker to send a query to the database[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#5-use-prisma-client-in-your-worker-to-send-a-query-to-the-database-2 \"Direct link to 5. Use Prisma Client in your Worker to send a query to the database\")\n\nBefore adding a Prisma Client query to your Worker, you need to generate Prisma Client with the following command:\n\nIn order to query your database from the Worker using Prisma ORM, you need to:\n\n1.  Add the `DB` binding to the `Env` interface. (Alternatively, you can run [`npx wrangler types`](https://developers.cloudflare.com/workers/wrangler/commands/#types) to generate the `Env` type from the binding in a separate file called `worker-configuration.d.ts`.)\n2.  Instantiate `PrismaClient` using the `PrismaD1` driver adapter.\n3.  Send a query using Prisma Client and return the result.\n\nOpen `src/index.ts` and replace the entire content with the following:\n\nsrc/index.ts\n\n```\nimport { PrismaClient } from '@prisma/client'import { PrismaD1 } from '@prisma/adapter-d1'export interface Env {  DB: D1Database}export default {  async fetch(    request: Request,    env: Env,    ctx: ExecutionContext  ): Promise<Response> {    const adapter = new PrismaD1(env.DB)    const prisma = new PrismaClient({ adapter })    const users = await prisma.user.findMany()    const result = JSON.stringify(users)    return new Response(result)  },}\n```\n\n#### 6\\. Run the Worker locally[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#6-run-the-worker-locally-3 \"Direct link to 6. Run the Worker locally\")\n\nWith the database query in place and Prisma Client generated, you can go ahead and run the Worker locally:\n\nNow you can open your browser at [`http://localhost:8787`](http://localhost:8787/) to see the result of the database query:\n\n```\n;[{ id: 1, email: 'jane@prisma.io', name: 'Jane Doe (Local)' }]\n```\n\n#### 7\\. Set the `DATABASE_URL` environment variable and deploy the Worker[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-cloudflare#7-set-the-database_url-environment-variable-and-deploy-the-worker-3 \"Direct link to 7-set-the-database_url-environment-variable-and-deploy-the-worker-3\")\n\nTo deploy the Worker, run the the following command:\n\nYour deployed Worker is accessible via `https://prisma-d1-example.USERNAME.workers.dev`. If you navigate your browser to that URL, you should see the following data that's queried from your remote D1 database:\n\n```\n;[{ id: 1, email: 'jane@prisma.io', name: 'Jane Doe (Remote)' }]\n```",
    "title": "Deploy to Cloudflare Workers & Pages | Prisma Documentation",
    "description": "Learn the things you need to know in order to deploy an app that uses Prisma Client for talking to a database to a Cloudflare Worker or to Cloudflare Pages.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries",
    "markdown": "# Custom & type-safe queries | Prisma Documentation\n\n## Overview[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#overview \"Direct link to Overview\")\n\nThis page explains how to improve the experience of writing raw SQL in Prisma ORM. It uses [Prisma Client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions) and [SafeQL](https://safeql.dev/) to create custom, type-safe Prisma Client queries which abstract custom SQL that your app might need (using `$queryRaw`).\n\nThe example will be using [PostGIS](https://postgis.net/) and PostgreSQL, but is applicable to any raw SQL queries that you might need in your application.\n\n## What is SafeQL?[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#what-is-safeql \"Direct link to What is SafeQL?\")\n\n[SafeQL](https://safeql.dev/) allows for advanced linting and type safety within raw SQL queries. After setup, SafeQL works with Prisma Client `$queryRaw` and `$executeRaw` to provide type safety when raw queries are required.\n\nSafeQL runs as an [ESLint](https://eslint.org/) plugin and is configured using ESLint rules. This guide doesn't cover setting up ESLint and we will assume that you already having it running in your project.\n\n## Prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#prerequisites \"Direct link to Prerequisites\")\n\nTo follow along, you will be expected to have:\n\n*   A [PostgreSQL](https://www.postgresql.org/) database with PostGIS installed\n*   Prisma ORM set up in your project\n*   ESLint set up in your project\n\n## Geographic data support in Prisma ORM[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#geographic-data-support-in-prisma-orm \"Direct link to Geographic data support in Prisma ORM\")\n\nAt the time of writing, Prisma ORM does not support working with geographic data, specifically using [PostGIS](https://github.com/prisma/prisma/issues/2789).\n\nA model that has geographic data columns will be stored using the [`Unsupported`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unsupported) data type. Fields with `Unsupported` types are present in the generated Prisma Client and will be typed as `any`. A model with a required `Unsupported` type does not expose write operations such as `create`, and `update`.\n\nPrisma Client supports write operations on models with a required `Unsupported` field using `$queryRaw` and `$executeRaw`. You can use Prisma Client extensions and SafeQL to improve the type-safety when working with geographical data in raw queries.\n\n## 1\\. Set up Prisma ORM for use with PostGIS[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#1-set-up-prisma-orm-for-use-with-postgis \"Direct link to 1. Set up Prisma ORM for use with PostGIS\")\n\nIf you haven't already, enable the `postgresqlExtensions` Preview feature and add the `postgis` PostgreSQL extension in your Prisma schema:\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"postgresqlExtensions\"]}datasource db {  provider   = \"postgresql\"  url        = env(\"DATABASE_URL\")  extensions = [postgis]}\n```\n\nwarning\n\nIf you are not using a hosted database provider, you will likely need to install the `postgis` extension. Refer to [PostGIS's docs](http://postgis.net/documentation/getting_started/#installing-postgis) to learn more about how to get started with PostGIS. If you're using Docker Compose, you can use the following snippet to set up a PostgreSQL database that has PostGIS installed:\n\n```\nversion: '3.6'services:  pgDB:    image: postgis/postgis:13-3.1-alpine    restart: always    ports:      - '5432:5432'    volumes:      - db_data:/var/lib/postgresql/data    environment:      POSTGRES_PASSWORD: password      POSTGRES_DB: geoexamplevolumes:  db_data:\n```\n\nNext, create a migration and execute a migration to enable the extension:\n\n```\nnpx prisma migrate dev --name add-postgis\n```\n\nFor reference, the output of the migration file should look like the following:\n\nmigrations/TIMESTAMP\\_add\\_postgis/migration.sql\n\n```\n-- CreateExtensionCREATE EXTENSION IF NOT EXISTS \"postgis\";\n```\n\nYou can double-check that the migration has been applied by running `prisma migrate status`.\n\n## 2\\. Create a new model that uses a geographic data column[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#2-create-a-new-model-that-uses-a-geographic-data-column \"Direct link to 2. Create a new model that uses a geographic data column\")\n\nAdd a new model with a column with a `geography` data type once the migration is applied. For this guide, we'll use a model called `PointOfInterest`.\n\n```\nmodel PointOfInterest {  id       Int                                   @id @default(autoincrement())  name     String  location Unsupported(\"geography(Point, 4326)\")}\n```\n\nYou'll notice that the `location` field uses an [`Unsupported`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unsupported) type. This means that we lose a lot of the benefits of Prisma ORM when working with `PointOfInterest`. We'll be using [SafeQL](https://safeql.dev/) to fix this.\n\nLike before, create and execute a migration using the `prisma migrate dev` command to create the `PointOfInterest` table in your database:\n\n```\nnpx prisma migrate dev --name add-poi\n```\n\nFor reference, here is the output of the SQL migration file generated by Prisma Migrate:\n\nmigrations/TIMESTAMP\\_add\\_poi/migration.sql\n\n```\n-- CreateTableCREATE TABLE \"PointOfInterest\" (    \"id\" SERIAL NOT NULL,    \"name\" TEXT NOT NULL,    \"location\" geography(Point, 4326) NOT NULL,    CONSTRAINT \"PointOfInterest_pkey\" PRIMARY KEY (\"id\"));\n```\n\n## 3\\. Integrate SafeQL[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#3-integrate-safeql \"Direct link to 3. Integrate SafeQL\")\n\nSafeQL is easily integrated with Prisma ORM in order to lint `$queryRaw` and `$executeRaw` Prisma operations. You can reference [SafeQL's integration guide](https://safeql.dev/compatibility/prisma.html) or follow the steps below.\n\n### 3.1. Install the `@ts-safeql/eslint-plugin` npm package[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#31-install-the-ts-safeqleslint-plugin-npm-package \"Direct link to 31-install-the-ts-safeqleslint-plugin-npm-package\")\n\n```\nnpm install -D @ts-safeql/eslint-plugin\n```\n\nThis ESLint plugin is what will allow for queries to be linted.\n\n### 3.2. Add `@ts-safeql/eslint-plugin` to your ESLint plugins[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#32-add-ts-safeqleslint-plugin-to-your-eslint-plugins \"Direct link to 32-add-ts-safeqleslint-plugin-to-your-eslint-plugins\")\n\nNext, add `@ts-safeql/eslint-plugin` to your list of ESLint plugins. In our example we are using an `.eslintrc.js` file, but this can be applied to any way that you [configure ESLint](https://eslint.org/docs/latest/use/configure/).\n\n.eslintrc.js\n\n```\n/** @type {import('eslint').Linter.Config} */module.exports = {  \"plugins\": [..., \"@ts-safeql/eslint-plugin\"],  ...}\n```\n\n### 3.3 Add `@ts-safeql/check-sql` rules[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#33-add-ts-safeqlcheck-sql-rules \"Direct link to 33-add-ts-safeqlcheck-sql-rules\")\n\nNow, setup the rules that will enable SafeQL to mark invalid SQL queries as ESLint errors.\n\n.eslintrc.js\n\n```\n/** @type {import('eslint').Linter.Config} */module.exports = {  plugins: [..., '@ts-safeql/eslint-plugin'],  rules: {    '@ts-safeql/check-sql': [      'error',      {        connections: [          {            // The migrations path:            migrationsDir: './prisma/migrations',            targets: [              // This makes `prisma.$queryRaw` and `prisma.$executeRaw` commands linted              { tag: 'prisma.+($queryRaw|$executeRaw)', transform: '{type}[]' },            ],          },        ],      },    ],  },}\n```\n\n> **Note**: If your `PrismaClient` instance is called something different than `prisma`, you need to adjust the value for `tag` accordingly. For example, if it is called `db`, the value for `tag` should be `'db.+($queryRaw|$executeRaw)'`.\n\n### 3.4. Connect to your database[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#34-connect-to-your-database \"Direct link to 3.4. Connect to your database\")\n\nFinally, set up a `connectionUrl` for SafeQL so that it can introspect your database and retrieve the table and column names you use in your schema. SafeQL then uses this information for linting and highlighting problems in your raw SQL statements.\n\nOur example relies on the [`dotenv`](https://github.com/motdotla/dotenv) package to get the same connection string that is used by Prisma ORM. We recommend this in order to keep your database URL out of version control.\n\nIf you haven't installed `dotenv` yet, you can install it as follows:\n\nThen update your ESLint config as follows:\n\n.eslintrc.js\n\n```\nrequire('dotenv').config()/** @type {import('eslint').Linter.Config} */module.exports = {  plugins: ['@ts-safeql/eslint-plugin'],  // exclude `parserOptions` if you are not using TypeScript  parserOptions: {    project: './tsconfig.json',  },  rules: {    '@ts-safeql/check-sql': [      'error',      {        connections: [          {            connectionUrl: process.env.DATABASE_URL,            // The migrations path:            migrationsDir: './prisma/migrations',            targets: [              // what you would like SafeQL to lint. This makes `prisma.$queryRaw` and `prisma.$executeRaw`              // commands linted              { tag: 'prisma.+($queryRaw|$executeRaw)', transform: '{type}[]' },            ],          },        ],      },    ],  },}\n```\n\nSafeQL is now fully configured to help you write better raw SQL using Prisma Client.\n\n## 4\\. Creating extensions to make raw SQL queries type-safe[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#4-creating-extensions-to-make-raw-sql-queries-type-safe \"Direct link to 4. Creating extensions to make raw SQL queries type-safe\")\n\nIn this section, we'll create two [`model`](https://www.prisma.io/docs/orm/prisma-client/client-extensions/model) extensions with custom queries to be able to work conveniently with the `PointOfInterest` model:\n\n1.  A `create` query that allows us to create new `PointOfInterest` records in the database\n2.  A `findClosestPoints` query that returns the `PointOfInterest` records that are closest to a given coordinate\n\n### 4.1. Adding an extension to create `PointOfInterest` records[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#41-adding-an-extension-to-create-pointofinterest-records \"Direct link to 41-adding-an-extension-to-create-pointofinterest-records\")\n\nThe `PointOfInterest` model in the Prisma schema uses an `Unsupported` type. As a consequence, the generated `PointOfInterest` type in Prisma Client can't be used to carry values for latitude and longitude.\n\nWe will resolve this by defining two custom types that better represent our model in TypeScript:\n\n```\ntype MyPoint = {  latitude: number  longitude: number}type MyPointOfInterest = {  name: string  location: MyPoint}\n```\n\nNext, you can add a `create` query to the `pointOfInterest` property of your Prisma Client:\n\n```\nconst prisma = new PrismaClient().$extends({  model: {    pointOfInterest: {      async create(data: {        name: string        latitude: number        longitude: number      }) {        // Create an object using the custom types from above        const poi: MyPointOfInterest = {          name: data.name,          location: {            latitude: data.latitude,            longitude: data.longitude,          },        }        // Insert the object into the database        const point = `POINT(${poi.location.longitude} ${poi.location.latitude})`        await prisma.$queryRaw`          INSERT INTO \"PointOfInterest\" (name, location) VALUES (${poi.name}, ST_GeomFromText(${point}, 4326));        `        // Return the object        return poi      },    },  },})\n```\n\nNotice that the SQL in the line that's highlighted in the code snippet gets checked by SafeQL! For example, if you change the name of the table from `\"PointOfInterest\"` to `\"PointOfInterest2\"`, the following error appears:\n\n```\nerror  Invalid Query: relation \"PointOfInterest2\" does not exist  @ts-safeql/check-sql\n```\n\nThis also works with the column names `name` and `location`.\n\nYou can now create new `PointOfInterest` records in your code as follows:\n\n```\nconst poi = await prisma.pointOfInterest.create({  name: 'Berlin',  latitude: 52.52,  longitude: 13.405,})\n```\n\n### 4.2. Adding an extension to query for closest to `PointOfInterest` records[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#42-adding-an-extension-to-query-for-closest-to-pointofinterest-records \"Direct link to 42-adding-an-extension-to-query-for-closest-to-pointofinterest-records\")\n\nNow let's make a Prisma Client extension in order to query this model. We will be making an extension that finds the closest points of interest to a given longitude and latitude.\n\n```\nconst prisma = new PrismaClient().$extends({  model: {    pointOfInterest: {      async create(data: {        name: string        latitude: number        longitude: number      }) {        // ... same code as before      },      async findClosestPoints(latitude: number, longitude: number) {        // Query for clostest points of interests        const result = await prisma.$queryRaw<          {            id: number | null            name: string | null            st_x: number | null            st_y: number | null          }[]        >`SELECT id, name, ST_X(location::geometry), ST_Y(location::geometry)             FROM \"PointOfInterest\"             ORDER BY ST_DistanceSphere(location::geometry, ST_MakePoint(${longitude}, ${latitude})) DESC`        // Transform to our custom type        const pois: MyPointOfInterest[] = result.map((data) => {          return {            name: data.name,            location: {              latitude: data.st_x || 0,              longitude: data.st_y || 0,            },          }        })        // Return data        return pois      },    },  },})\n```\n\nNow, you can use our Prisma Client as normal to find close points of interest to a given longitude and latitude using the custom method created on the `PointOfInterest` model.\n\n```\nconst closestPointOfInterest = await prisma.pointOfInterest.findClosestPoints(  53.5488,  9.9872)\n```\n\nSimilar to before, we again have the benefit of SafeQL to add extra type safety to our raw queries. For example, if we removed the cast to `geometry` for `location` by changing `location::geometry` to just `location`, we would get linting errors in the `ST_X`, `ST_Y` or `ST_DistanceSphere` functions respectively.\n\n```\nerror  Invalid Query: function st_distancesphere(geography, geometry) does not exist  @ts-safeql/check-sql\n```\n\n## Conclusion[​](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/custom-and-type-safe-queries#conclusion \"Direct link to Conclusion\")\n\nWhile you may sometimes need to drop down to raw SQL when using Prisma ORM, you can use various techniques to make the experience of writing raw SQL queries with Prisma ORM better.\n\nIn this article, you have used SafeQL and Prisma Client extensions to create custom, type-safe Prisma Client queries to abstract PostGIS operations which are currently not natively supported in Prisma ORM.",
    "title": "Custom & type-safe queries | Prisma Documentation",
    "description": "Learn how to use SafeQL and Prisma Client extensions to work around features not natively supported by Prisma, such as PostGIS.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/next-steps",
    "markdown": "# Next steps after adding Prisma ORM to an existing project using MongoDB\n\nHere are a few suggestions for a number of more queries you can send with Prisma Client:\n\n**Filter all `Post` records that contain `\"hello\"`**\n\n```\nconst filteredPosts = await prisma.post.findMany({  where: {    OR: [{ title: { contains: 'hello' } }, { body: { contains: 'hello' } }],  },})\n```\n\n**Create a new `Post` record and connect it to an existing `User` record**\n\n```\nconst post = await prisma.post.create({  data: {    title: 'Join us for Prisma Day 2020',    slug: 'prisma-day-2020',    body: 'A conference on modern application development and databases.',    user: {      connect: { email: 'hello@prisma.com' },    },  },})\n```\n\n**Use the fluent relations API to retrieve the `Post` records of a `User` by traversing the relations**\n\n```\nconst user = await prisma.comment  .findUnique({    where: { id: '60ff4e9500acc65700ebf470' },  })  .post()  .user()\n```\n\n**Delete a `User` record**\n\n```\nconst deletedUser = await prisma.user.delete({  where: { email: 'sarah@prisma.io' },})\n```",
    "title": "Next steps after adding Prisma ORM to an existing project using MongoDB | Prisma Documentation",
    "description": "Next steps to take now that you have successfully added Prisma ORM to your existing Node.js or TypeScript project.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/querying-the-database-typescript-mongodb",
    "markdown": "# Querying the database in your existing project: MongoDB and TypeScript\n\n## Write your first query with Prisma Client[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/querying-the-database-typescript-mongodb#write-your-first-query-with-prisma-client \"Direct link to Write your first query with Prisma Client\")\n\nNow that you have generated Prisma Client, you can start writing queries to read and write data in your database. For the purpose of this guide, you'll use a plain Node.js script to explore some basic features of Prisma Client.\n\nIf you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.\n\nFor the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).\n\nCreate a new file named `index.ts` and add the following code to it:\n\nindex.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient()async function main() {  // ... you will write your Prisma Client queries here}main()  .then(async () => {    await prisma.$disconnect()  })  .catch(async (e) => {    console.error(e)    await prisma.$disconnect()    process.exit(1)  })\n```\n\nHere's a quick overview of the different parts of the code snippet:\n\n1.  Import the `PrismaClient` constructor from the `@prisma/client` node module\n2.  Instantiate `PrismaClient`\n3.  Define an `async` function named `main` to send queries to the database\n4.  Connect to the database\n5.  Call the `main` function\n6.  Close the database connections when the script terminates\n\nInside the `main` function, add the following query to read all `User` records from the database and print the result:\n\nindex.ts\n\n```\nasync function main() {  // ... you will write your Prisma Client queries here+  const allUsers = await prisma.user.findMany()+  console.log(allUsers)}\n```\n\nNow run the code with this command:\n\nIf you introspected an existing database with records, the query should return an array of JavaScript objects.\n\n## Write data into the database[​](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb/querying-the-database-typescript-mongodb#write-data-into-the-database \"Direct link to Write data into the database\")\n\nThe `findMany` query you used in the previous section only _reads_ data from the database (although it was still empty). In this section, you'll learn how to write a query to _write_ new records into the `Post`, `User` and `Comment` tables.\n\nAdjust the `main` function to send a `create` query to the database:\n\nindex.ts\n\n```\nasync function main() {  await prisma.user.create({    data: {      name: 'Rich',      email: 'hello@prisma.com',      posts: {        create: {          title: 'My first post',          body: 'Lots of really interesting stuff',          slug: 'my-first-post',        },      },    },  })  const allUsers = await prisma.user.findMany({    include: {      posts: true,    },  })  console.dir(allUsers, { depth: null })}\n```\n\nThis code creates a new `User` record together with a new `Post` using a [nested write](https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#nested-writes) query. The `User` record is connected to the other one via the `Post.author` ↔ `User.posts` [relation fields](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations#relation-fields) respectively.\n\nNotice that you're passing the [`include`](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#include-relations-and-select-relation-fields) option to `findMany` which tells Prisma Client to include the `posts` relations on the returned `User` objects.\n\nRun the code with this command:\n\nThe output should look similar to this:\n\n```\n[  {    id: '60cc9b0e001e3bfd00a6eddf',    email: 'hello@prisma.com',    name: 'Rich',    posts: [      {        id: '60cc9bad005059d6007f45dd',        slug: 'my-first-post',        title: 'My first post',        body: 'Lots of really interesting stuff',        userId: '60cc9b0e001e3bfd00a6eddf',      },    ],  },]\n```\n\nAlso note that `allUsers` is _statically typed_ thanks to [Prisma Client's generated types](https://www.prisma.io/docs/orm/prisma-client/type-safety/operating-against-partial-structures-of-model-types). You can observe the type by hovering over the `allUsers` variable in your editor. It should be typed as follows:\n\n```\nconst allUsers: (User & {  posts: Post[]})[]export type Post = {  id: number  title: string  body: string | null  published: boolean  authorId: number | null}\n```\n\nThe query added new records to the `User` and the `Post` collections:\n\ninfo\n\nThe `id` field in the Prisma schema maps to `_id` in the underlying MongoDB database.\n\n**User** collection\n\n| **\\_id** | **email** | **name** |\n| --- | --- | --- |\n| `60cc9b0e001e3bfd00a6eddf` | `\"hello@prisma.com\"` | `\"Rich\"` |\n\n**Post** collection\n\n| **\\_id** | **createdAt** | **title** | **content** | **published** | **authorId** |\n| --- | --- | --- | --- | --- | --- |\n| `60cc9bad005059d6007f45dd` | `2020-03-21T16:45:01.246Z` | `\"My first post\"` | `Lots of really interesting stuff` | `false` | `60cc9b0e001e3bfd00a6eddf` |\n\n> **Note**: The unique identifier in the `authorId` document field on `Post` reference the `_id` document field in the `User` collection, meaning the `_id` value `60cc9b0e001e3bfd00a6eddf` column therefore refers to the first (and only) `User` record in the database.\n\nBefore moving on to the next section, you'll add a couple of comments to the `Post` record you just created using an `update` query. Adjust the `main` function as follows:\n\nindex.ts\n\n```\nasync function main() {  await prisma.post.update({    where: {      slug: 'my-first-post',    },    data: {      comments: {        createMany: {          data: [            { comment: 'Great post!' },            { comment: \"Can't wait to read more!\" },          ],        },      },    },  })  const posts = await prisma.post.findMany({    include: {      comments: true,    },  })  console.dir(posts, { depth: Infinity })}\n```\n\nNow run the code using the same command as before:\n\nYou will see the following output:\n\n```\n[  {    id: '60cc9bad005059d6007f45dd',    slug: 'my-first-post',    title: 'My first post',    body: 'Lots of really interesting stuff',    userId: '60cc9b0e001e3bfd00a6eddf',    comments: [      {        id: '60cca420008a21d800578793',        postId: '60cca40300af8bf000f6ca99',        comment: 'Great post!',      },      {        id: '60cca420008a21d800578794',        postId: '60cca40300af8bf000f6ca99',        comment: \"Can't wait to try this!\",      },    ],  },]\n```\n\nFantastic, you just wrote new data into your database for the first time using Prisma Client 🚀",
    "title": "Querying the database in your existing project: MongoDB and TypeScript | Prisma Documentation",
    "description": "Write data to and query your MongoDB database",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/development-environment/environment-variables/managing-env-files-and-setting-variables",
    "markdown": "# Managing .env files and setting variables\n\n[Prisma ORM creates an `.env` file for you upon project initialization with `prisma init`](https://www.prisma.io/docs/orm/more/development-environment/environment-variables#how-does-prisma-orm-use-environment-variables). You are not limited to using that file, some other options include:\n\n*   Do not use `.env` files and let Prisma ORM use the system environment variables directly\n*   Use `.env` files from a location that the Prisma CLI does not check [by default](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files)\n*   [Use multiple `.env` file](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/using-multiple-env-files)\n\n## Using the system environment directly[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/managing-env-files-and-setting-variables#using-the-system-environment-directly \"Direct link to Using the system environment directly\")\n\nBecause Prisma ORM reads from the system's environment when looking for environment variables, it's possible to skip using `.env` completely and create them manually on your local system.\n\ninfo\n\nThe following examples will use setting the `DATABASE_URL` environment variable which is often used for the database connection URL.\n\n### Manually set an environment variable on a Mac/Linux system[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/managing-env-files-and-setting-variables#manually-set-an-environment-variable-on-a-maclinux-system \"Direct link to Manually set an environment variable on a Mac/Linux system\")\n\nFrom a terminal on a Unix machine (Mac/Linux), you export the variable as a key value pair.\n\n```\nexport DATABASE_URL=postgresql://test:test@localhost:5432/test?schema=public\n```\n\nThen check that it has been successfully set using `printenv`:\n\n### Manually set an environment variable on a Windows system[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/managing-env-files-and-setting-variables#manually-set-an-environment-variable-on-a-windows-system \"Direct link to Manually set an environment variable on a Windows system\")\n\nThe following examples illustrate how to set the environment variable (for the current user) using both Command Prompt (`cmd.exe`) and PowerShell, depending on your preference.\n\n*   Command Prompt\n*   Powershell\n\n```\nset DATABASE_URL=\"postgresql://test:test@localhost:5432/test?schema=public\"\n```\n\nThen check that it has been successfully set:\n\n*   Command Prompt\n*   Powershell\n\n## Manage `.env` files manually[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/managing-env-files-and-setting-variables#manage-env-files-manually \"Direct link to manage-env-files-manually\")\n\nThe [`dotenv-cli`](https://www.npmjs.com/package/dotenv-cli) and [`dotenv`](https://www.npmjs.com/package/dotenv) packages can be used if you want to manage your `.env`files manually.\n\nThey allow you to:\n\n*   [Use multiple `.env` files](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/using-multiple-env-files)\n*   Use `.env` files from a location that the Prisma CLI does not check [by default](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files)\n\n### Using `dotenv-cli` via command line[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/managing-env-files-and-setting-variables#using-dotenv-cli-via-command-line \"Direct link to using-dotenv-cli-via-command-line\")\n\nThe following steps show how to use the `dotenv-cli` package to use an alternative file to contain environment variables than the [default](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files) created by Prisma ORM, which is then used to run Introspection.\n\n1.  Install [`dotenv-cli`](https://www.npmjs.com/package/dotenv-cli):\n    \n    ```\n    npm install -g dotenv-cli\n    ```\n    \n2.  Create a file - for example, `.env3` - in your project's root folder.\n    \n3.  To use the `.env3` file, you can use `dotenv` when you run any Prisma ORM command and specify which `.env` file to use. The following example uses a file named `.env3`:\n    \n    ```\n    dotenv -e .env3 -- npx prisma db pull\n    ```\n    \n\n> **Note:** dotenv doesn't pass the flags to the Prisma ORM command by default, this is why the command includes two dashes `--` before `prisma`, making it possible to use flags like `--force`, `--schema` or `--preview-feature`.\n\n### Using `dotenv` via application code[​](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/managing-env-files-and-setting-variables#using-dotenv-via-application-code \"Direct link to using-dotenv-via-application-code\")\n\nThe following steps show how to use the `dotenv` package to reference an alternative environment file in your project's code.\n\n1.  Add [`dotenv`](https://www.npmjs.com/package/dotenv) to your project:\n    \n2.  Create a file - for example, `.env3` - in your project's root folder.\n    \n3.  To use the `.env3` file, include a reference to `dotenv` at the top of your project's entry file.\n    \n    ```\n    import { config } from 'dotenv'config({ path: '.env3' })\n    ```",
    "title": "Managing .env files and setting variables | Prisma Documentation",
    "description": "Learn how to manage .env files and set environment variables",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/logging-middleware",
    "markdown": "# Middleware sample: logging (Reference) | Prisma Documentation\n\n```\nconst prisma = new PrismaClient()prisma.$use(async (params, next) => {  const before = Date.now()  const result = await next(params)  const after = Date.now()  console.log(`Query ${params.model}.${params.action} took ${after - before}ms`)  return result})const create = await prisma.post.create({  data: {    title: 'Welcome to Prisma Day 2020',  },})const createAgain = await prisma.post.create({  data: {    title: 'All about database collation',  },})\n```",
    "title": "Middleware sample: logging (Reference) | Prisma Documentation",
    "description": "How to use middleware to log the time taken to perform any query.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb",
    "markdown": "# Deploy a Prisma ORM app to Koyeb\n\nIn this guide, you will set up and deploy a Node.js server that uses Prisma ORM with PostgreSQL to [Koyeb](https://www.koyeb.com/). The application exposes a REST API and uses Prisma Client to handle fetching, creating, and deleting records from a database.\n\nKoyeb is a developer-friendly serverless platform to deploy apps globally. The platform lets you seamlessly run Docker containers, web apps, and APIs with git-based deployment, TLS encryption, native autoscaling, a global edge network, and built-in service mesh & discovery.\n\nWhen using the [Koyeb git-driven deployment](https://www.koyeb.com/docs/apps/build-from-git) method, each time you push code changes to a GitHub repository a new build and deployment of the application are automatically triggered on the Koyeb Serverless Platform. This guide uses the latter approach whereby you push your code to the app's repository on GitHub.\n\nThe application has the following components:\n\n*   **Backend**: Node.js REST API built with Express.js with resource endpoints that use Prisma Client to handle database operations against a PostgreSQL database (e.g., hosted on Heroku).\n*   **Frontend**: Static HTML page to interact with the API.\n\n![architecture diagram](https://www.prisma.io/docs/assets/images/koyeb-architecture-039aa8826c3714a3f304aa4b36185372.png)\n\nThe focus of this guide is showing how to deploy projects using Prisma ORM to Koyeb. The starting point will be the [Prisma Koyeb example](https://github.com/koyeb/example-prisma), which contains an Express.js server with a couple of preconfigured REST endpoints and a simple frontend.\n\n> **Note:** The various **checkpoints** throughout the guide allow you to validate whether you performed the steps correctly.\n\n## Prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb#prerequisites \"Direct link to Prerequisites\")\n\n*   Hosted PostgreSQL database and a URL from which it can be accessed, e.g. `postgresql://username:password@your_postgres_db.cloud.com/db_identifier` (you can use Supabase, which offers a [free plan](https://dev.to/prisma/set-up-a-free-postgresql-database-on-supabase-to-use-with-prisma-3pk6)).\n*   [GitHub](https://github.com/) account with an empty public repository we will use to push the code.\n*   [Koyeb](https://koyeb.com/) account.\n*   Node.js installed.\n\n## Prisma ORM workflow[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb#prisma-orm-workflow \"Direct link to Prisma ORM workflow\")\n\nAt the core of Prisma ORM is the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) – a declarative configuration where you define your data model and other Prisma ORM-related configuration. The Prisma schema is also a single source of truth for both Prisma Client and Prisma Migrate.\n\nIn this guide, you will create the database schema with [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) to create the database schema. Prisma Migrate is based on the Prisma schema and works by generating `.sql` migration files that are executed against the database.\n\nMigrate comes with two primary workflows:\n\n*   Creating migrations and applying them during local development with `prisma migrate dev`\n*   Applying generated migration to production with `prisma migrate deploy`\n\nFor brevity, the guide does not cover how migrations are created with `prisma migrate dev`. Rather, it focuses on the production workflow and uses the Prisma schema and SQL migration that are included in the example code.\n\nYou will use Koyeb's [build step](https://www.koyeb.com/docs/apps/build-from-git#understanding-the-build-process) to run the `prisma migrate deploy` command so that the migrations are applied before the application starts.\n\nTo learn more about how migrations are created with Prisma Migrate, check out the [start from scratch guide](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-postgresql)\n\n## 1\\. Download the example and install dependencies[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb#1-download-the-example-and-install-dependencies \"Direct link to 1. Download the example and install dependencies\")\n\nOpen your terminal and navigate to a location of your choice. Create the directory that will hold the application code and download the example code:\n\n```\nmkdir prisma-on-koyebcd prisma-on-koyebcurl https://github.com/koyeb/example-prisma/tarball/main/latest | tar xz  --strip=1\n```\n\n**Checkpoint:** Executing the `tree` command should show the following directories and files:\n\n```\n.├── README.md├── package.json├── prisma│   ├── migrations│   │   ├── 20210310152103_init│   │   │   └── migration.sql│   │   └── migration_lock.toml│   └── schema.prisma├── public│   └── index.html└── src    └── index.js5 directories, 8 files\n```\n\nInstall the dependencies:\n\n## 2\\. Initialize a Git repository and push the application code to GitHub[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb#2-initialize-a-git-repository-and-push-the-application-code-to-github \"Direct link to 2. Initialize a Git repository and push the application code to GitHub\")\n\nIn the previous step, you downloaded the code. In this step, you will create a repository from the code so that you can push it to a GitHub repository for deployment.\n\nTo do so, run `git init` from the source code folder:\n\n```\ngit init> Initialized empty Git repository in /Users/edouardb/prisma-on-koyeb/.git/\n```\n\nWith the repository initialized, add and commit the files:\n\n```\ngit add .git commit -m 'Initial commit'\n```\n\n**Checkpoint:** `git log -1` should show the commit:\n\n```\ngit log -1commit 895534590fdd260acee6396e2e1c0438d1be7fed (HEAD -> main)\n```\n\nThen, push the code to your GitHub repository by adding the remote\n\n```\ngit remote add origin git@github.com:<YOUR_GITHUB_USERNAME>/<YOUR_GITHUB_REPOSITORY_NAME>.gitgit push -u origin main\n```\n\n## 3\\. Deploy the application on Koyeb[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb#3-deploy-the-application-on-koyeb \"Direct link to 3. Deploy the application on Koyeb\")\n\nOn the [Koyeb Control Panel](https://app.koyeb.com/), click the **Create App** button.\n\nYou land on the Koyeb App creation page where you are asked for information about the application to deploy such as the deployment method to use, the repository URL, the branch to deploy, the build and run commands to execute.\n\nPick GitHub as the deployment method and select the GitHub repository containing your application and set the branch to deploy to `main`.\n\n> **Note:** If this is your first time using Koyeb, you will be prompted to install the Koyeb app in your GitHub account.\n\nIn the **Environment variables** section, create a new environment variable `DATABASE_URL` that is type Secret. In the value field, click **Create Secret**, name your secret `prisma-pg-url` and set the PostgreSQL database connection string as the secret value which should look as follows: `postgresql://__USER__:__PASSWORD__@__HOST__/__DATABASE__`. [Koyeb Secrets](https://www.koyeb.com/docs/secrets) allow you to securely store and retrieve sensitive information like API tokens, database connection strings. They enable you to secure your code by removing hardcoded credentials and let you pass environment variables securely to your applications.\n\nLast, give your application a name and click the **Create App** button.\n\n**Checkpoint:** Open the deployed app by clicking on the screenshot of the deployed app. Once the page loads, click on the **Check API status** button, which should return: `{\"up\":true}`\n\n![deployed-screenshot](https://www.prisma.io/docs/assets/images/koyeb-app-creation-4fa0f5316d0328ed47ec803ff951ded6.png)\n\nCongratulations! You have successfully deployed the app to Koyeb.\n\nKoyeb will build and deploy the application. Additional commits to your GitHub repository will trigger a new build and deployment on Koyeb.\n\n**Checkpoint:** Once the build and deployment are completed, you can access your application by clicking the App URL ending with koyeb.app in the Koyeb control panel. Once on the app page loads, Once the page loads, click on the **Check API status** button, which should return: `{\"up\":true}`\n\n## 4\\. Test your deployed application[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb#4-test-your-deployed-application \"Direct link to 4. Test your deployed application\")\n\nYou can use the static frontend to interact with the API you deployed via the preview URL.\n\nOpen up the preview URL in your browser, the URL should like this: `https://APP_NAME-ORG_NAME.koyeb.app`. You should see the following:\n\n![deployed-screenshot](https://www.prisma.io/docs/assets/images/koyeb-deployed-0e56d34bb2922de9d48983c105ca23b0.png)\n\nThe buttons allow you to make requests to the REST API and view the response:\n\n*   **Check API status**: Will call the REST API status endpoint that returns `{\"up\":true}`.\n*   **Seed data**: Will seed the database with a test `user` and `post`. Returns the created users.\n*   **Load feed**: Will load all `users` in the database with their related `profiles`.\n\nFor more insight into Prisma Client's API, look at the route handlers in the `src/index.js` file.\n\nYou can view the application's logs clicking the `Runtime logs` tab on your app service from the Koyeb control panel:\n\n```\nnode-72d14691\tstdout\t> prisma-koyeb@1.0.0 startnode-72d14691\tstdout\t> node src/index.jsnode-72d14691\tstdout\t🚀 Server ready at: http://localhost:8080node-72d14691\tstdout\t⭐️ See sample requests: http://pris.ly/e/ts/rest-express#3-using-the-rest-api\n```\n\n## Koyeb specific notes[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb#koyeb-specific-notes \"Direct link to Koyeb specific notes\")\n\n### Build[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb#build \"Direct link to Build\")\n\nBy default, for applications using the Node.js runtime, if the `package.json` contains a `build` script, Koyeb automatically executes it after the dependencies installation. In the example, the `build` script is used to run `prisma generate && prisma migrate deploy && next build`.\n\n### Deployment[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb#deployment \"Direct link to Deployment\")\n\nBy default, for applications using the Node.js runtime, if the `package.json` contains a `start` script, Koyeb automatically executes it to launch the application. In the example, the `start` script is used to run `node src/index.js`.\n\n### Database migrations and deployments[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb#database-migrations-and-deployments \"Direct link to Database migrations and deployments\")\n\nIn the example you deployed, migrations are applied using the `prisma migrate deploy` command during the Koyeb build (as defined in the `build` script in `package.json`).\n\n### Additional notes[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb#additional-notes \"Direct link to Additional notes\")\n\nIn this guide, we kept pre-set values for the region, instance size, and horizontal scaling. You can customize them according to your needs.\n\n> **Note:** The Ports section is used to let Koyeb know which port your application is listening to and properly route incoming HTTP requests. A default `PORT` environment variable is set to `8080` and incoming HTTP requests are routed to the `/` path when creating a new application. If your application is listening on another port, you can define another port to route incoming HTTP requests.\n\n## Summary[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-koyeb#summary \"Direct link to Summary\")\n\nCongratulations! You have successfully deployed a Node.js app with Prisma ORM to Koyeb.\n\nYou can find the source code for the example in [this GitHub repository](https://github.com/koyeb/example-prisma).\n\nFor more insight into Prisma Client's API, look at the route handlers in the `src/index.js` file.",
    "title": "Deploy a Prisma ORM app to Koyeb | Prisma Documentation",
    "description": "Learn how to deploy a Node.js server that uses Prisma ORM to Koyeb Serverless Platform.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku",
    "markdown": "# Deploy a Prisma app to Heroku\n\nIn this guide, you will set up and deploy a Node.js server that uses Prisma ORM with PostgreSQL to [Heroku](https://www.heroku.com/). The application exposes a REST API and uses Prisma Client to handle fetching, creating, and deleting records from a database.\n\nHeroku is a cloud platform as a service (PaaS). In contrast to the popular serverless deployment model, with Heroku, your application is constantly running even if no requests are made to it. This has several benefits due to the connection limits of a PostgreSQL database. For more information, check out the [general deployment documentation](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-prisma)\n\nTypically Heroku integrates with a Git repository for automatic deployments upon commits. You can deploy to Heroku from a GitHub repository or by pushing your source to a [Git repository that Heroku creates per app](https://devcenter.heroku.com/articles/git). This guide uses the latter approach whereby you push your code to the app's repository on Heroku, which triggers a build and deploys the application.\n\nThe application has the following components:\n\n*   **Backend**: Node.js REST API built with Express.js with resource endpoints that use Prisma Client to handle database operations against a PostgreSQL database (e.g., hosted on Heroku).\n*   **Frontend**: Static HTML page to interact with the API.\n\n![architecture diagram](https://www.prisma.io/docs/assets/images/heroku-architecture-98bf7b758c88080c01c2b7a7ae08447b.png)\n\nThe focus of this guide is showing how to deploy projects using Prisma ORM to Heroku. The starting point will be the [Prisma Heroku example](https://github.com/prisma/prisma-examples/tree/latest/deployment-platforms/heroku), which contains an Express.js server with a couple of preconfigured REST endpoints and a simple frontend.\n\n> **Note:** The various **checkpoints** throughout the guide allowing you to validate whether you performed the steps correctly.\n\n## A note on deploying GraphQL servers to Heroku[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku#a-note-on-deploying-graphql-servers-to-heroku \"Direct link to A note on deploying GraphQL servers to Heroku\")\n\nWhile the example uses REST, the same principles apply to a GraphQL server, with the main difference being that you typically have a single GraphQL API endpoint rather than a route for every resource as with REST.\n\n## Prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku#prerequisites \"Direct link to Prerequisites\")\n\n*   [Heroku](https://www.heroku.com/) account.\n*   [Heroku CLI](https://devcenter.heroku.com/articles/heroku-cli) installed.\n*   Node.js installed.\n*   PostgreSQL CLI `psql` installed.\n\n> **Note:** Heroku doesn't provide a free plan, so billing information is required.\n\n## Prisma ORM workflow[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku#prisma-orm-workflow \"Direct link to Prisma ORM workflow\")\n\nAt the core of Prisma ORM is the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema) – a declarative configuration where you define your data model and other Prisma ORM-related configuration. The Prisma schema is also a single source of truth for both Prisma Client and Prisma Migrate.\n\nIn this guide, you will use [Prisma Migrate](https://www.prisma.io/docs/orm/prisma-migrate) to create the database schema. Prisma Migrate is based on the Prisma schema and works by generating `.sql` migration files that are executed against the database.\n\nMigrate comes with two primary workflows:\n\n*   Creating migrations and applying during local development with `prisma migrate dev`\n*   Applying generated migration to production with `prisma migrate deploy`\n\nFor brevity, the guide does not cover how migrations are created with `prisma migrate dev`. Rather, it focuses on the production workflow and uses the Prisma schema and SQL migration that are included in the example code.\n\nYou will use Heroku's [release phase](https://devcenter.heroku.com/articles/release-phase) to run the `prisma migrate deploy` command so that the migrations are applied before the application starts.\n\nTo learn more about how migrations are created with Prisma Migrate, check out the [start from scratch guide](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-postgresql)\n\n## 1\\. Download the example and install dependencies[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku#1-download-the-example-and-install-dependencies \"Direct link to 1. Download the example and install dependencies\")\n\nOpen your terminal and navigate to a location of your choice. Create the directory that will hold the application code and download the example code:\n\n```\nmkdir prisma-herokucd prisma-herokucurl https://codeload.github.com/prisma/prisma-examples/tar.gz/latest | tar -xz --strip=3 prisma-examples-latest/deployment-platforms/heroku\n```\n\n**Checkpoint:** `ls -1` should show:\n\n```\nls -1ProcfileREADME.mdpackage.jsonprismapublicsrc\n```\n\nInstall the dependencies:\n\n> **Note:** The `Procfile` tells Heroku the command needed to start the application, i.e. `npm start`, and the command to run during the release phase, i.e., `npx prisma migrate deploy`\n\n## 2\\. Create a Git repository for the application[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku#2-create-a-git-repository-for-the-application \"Direct link to 2. Create a Git repository for the application\")\n\nIn the previous step, you downloaded the code. In this step, you will create a repository from the code so that you can push it to Heroku for deployment.\n\nTo do so, run `git init` from the source code folder:\n\n```\ngit init> Initialized empty Git repository in /Users/alice/prisma-heroku/.git/\n```\n\nTo use the `main` branch as the default branch, run the following command:\n\nWith the repository initialized, add and commit the files:\n\n```\ngit add .git commit -m 'Initial commit'\n```\n\n**Checkpoint:** `git log -1` should show the commit:\n\n```\ngit log -1commit 895534590fdd260acee6396e2e1c0438d1be7fed (HEAD -> main)\n```\n\n## 3\\. Heroku CLI login[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku#3-heroku-cli-login \"Direct link to 3. Heroku CLI login\")\n\nMake sure you're logged in to Heroku with the CLI:\n\nThis will allow you to deploy to Heroku from the terminal.\n\n**Checkpoint:** `heroku auth:whoami` should show your username:\n\n```\nheroku auth:whoami> your-email\n```\n\n## 4\\. Create a Heroku app[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku#4-create-a-heroku-app \"Direct link to 4. Create a Heroku app\")\n\nTo deploy an application to Heroku, you need to create an app. You can do so with the following command:\n\n```\nheroku apps:create your-app-name\n```\n\n> **Note:** Use a unique name of your choice instead of `your-app-name`.\n\n**Checkpoint:** You should see the URL and the repository for your Heroku app:\n\n```\nheroku apps:create your-app-name> Creating ⬢ your-app-name... done> https://your-app-name.herokuapp.com/ | https://git.heroku.com/your-app-name.git\n```\n\nCreating the Heroku app will add the git remote Heroku created to your local repository. Pushing commits to this remote will trigger a deploy.\n\n**Checkpoint:** `git remote -v` should show the Heroku git remote for your application:\n\n```\nheroku https://git.heroku.com/your-app-name.git (fetch)heroku https://git.heroku.com/your-app-name.git (push)\n```\n\nIf you don't see the heroku remote, use the following command to add it:\n\n```\nheroku git:remote --app your-app-name\n```\n\n## 5\\. Add a PostgreSQL database to your application[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku#5-add-a-postgresql-database-to-your-application \"Direct link to 5. Add a PostgreSQL database to your application\")\n\nHeroku allows your to provision a PostgreSQL database as part of an application.\n\nCreate the database with the following command:\n\n```\nheroku addons:create heroku-postgresql:hobby-dev\n```\n\n**Checkpoint:** To verify the database was created you should see the following:\n\n```\nCreating heroku-postgresql:hobby-dev on ⬢ your-app-name... freeDatabase has been created and is available ! This database is empty. If upgrading, you can transfer ! data from another database with pg:copyCreated postgresql-parallel-73780 as DATABASE_URL\n```\n\n> **Note:** Heroku automatically sets the `DATABASE_URL` environment variable when the app is running on Heroku. Prisma ORM uses this environment variable because it's declared in the _datasource_ block of the Prisma schema (`prisma/schema.prisma`) with `env(\"DATABASE_URL\")`.\n\n## 6\\. Push to deploy[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku#6-push-to-deploy \"Direct link to 6. Push to deploy\")\n\nDeploy the app by pushing the changes to the Heroku app repository:\n\nThis will trigger a build and deploy your application to Heroku. Heroku will also run the `npx prisma migrate deploy` command which executes the migrations to create the database schema before deploying the app (as defined in the `release` step of the `Procfile`).\n\n**Checkpoint:** `git push` will emit the logs from the build and release phase and display the URL of the deployed app:\n\n```\nremote: -----> Launching...remote:  !     Release command declared: this new release will not be available until the command succeeds.remote:        Released v5remote:        https://your-app-name.herokuapp.com/ deployed to Herokuremote:remote: Verifying deploy... done.remote: Running release command...remote:remote: Prisma schema loaded from prisma/schema.prismaremote: Datasource \"db\": PostgreSQL database \"your-db-name\", schema \"public\" at \"your-db-host.compute-1.amazonaws.com:5432\"remote:remote: 1 migration found in prisma/migrationsremote:remote: The following migration have been applied:remote:remote: migrations/remote:   └─ 20210310152103_init/remote:     └─ migration.sqlremote:remote: All migrations have been successfully applied.remote: Waiting for release.... done.\n```\n\n> **Note:** Heroku will also set the `PORT` environment variable to which your application is bound.\n\n## 7\\. Test your deployed application[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku#7-test-your-deployed-application \"Direct link to 7. Test your deployed application\")\n\nYou can use the static frontend to interact with the API you deployed via the preview URL.\n\nOpen up the preview URL in your browser, the URL should like this: `https://APP_NAME.herokuapp.com`. You should see the following:\n\n![deployed-screenshot](https://www.prisma.io/docs/assets/images/heroku-deployed-fc056e33dade6541e1ced33b70f1a11b.png)\n\nThe buttons allow you to make requests to the REST API and view the response:\n\n*   **Check API status**: Will call the REST API status endpoint that returns `{\"up\":true}`.\n*   **Seed data**: Will seed the database with a test `user` and `post`. Returns the created users.\n*   **Load feed**: Will load all `users` in the database with their related `profiles`.\n\nFor more insight into Prisma Client's API, look at the route handlers in the `src/index.js` file.\n\nYou can view the application's logs with the `heroku logs --tail` command:\n\n```\n2020-07-07T14:39:07.396544+00:00 app[web.1]:2020-07-07T14:39:07.396569+00:00 app[web.1]: > prisma-heroku@1.0.0 start /app2020-07-07T14:39:07.396569+00:00 app[web.1]: > node src/index.js2020-07-07T14:39:07.396570+00:00 app[web.1]:2020-07-07T14:39:07.657505+00:00 app[web.1]: 🚀 Server ready at: http://localhost:125162020-07-07T14:39:07.657526+00:00 app[web.1]: ⭐️ See sample requests: http://pris.ly/e/ts/rest-express#3-using-the-rest-api2020-07-07T14:39:07.842546+00:00 heroku[web.1]: State changed from starting to up\n```\n\n## Heroku specific notes[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku#heroku-specific-notes \"Direct link to Heroku specific notes\")\n\nThere are some implementation details relating to Heroku that this guide addresses and are worth reiterating:\n\n*   **Port binding**: web servers bind to a port so that they can accept connections. When deploying to Heroku The `PORT` environment variable is set by Heroku. Ensure you bind to `process.env.PORT` so that your application can accept requests once deployed. A common pattern is to try binding to try `process.env.PORT` and fallback to a preset port as follows:\n\n```\nconst PORT = process.env.PORT || 3000const server = app.listen(PORT, () => {  console.log(`app running on port ${PORT}`)})\n```\n\n*   **Database URL**: As part of Heroku's provisioning process, a `DATABASE_URL` config var is added to your app’s configuration. This contains the URL your app uses to access the database. Ensure that your `schema.prisma` file uses `env(\"DATABASE_URL\")` so that Prisma Client can successfully connect to the database.\n\n## Summary[​](https://www.prisma.io/docs/orm/prisma-client/deployment/traditional/deploy-to-heroku#summary \"Direct link to Summary\")\n\nCongratulations! You have successfully deployed a Node.js app with Prisma ORM to Heroku.\n\nYou can find the source code for the example in [this GitHub repository](https://github.com/prisma/prisma-examples/tree/latest/deployment-platforms/heroku).\n\nFor more insight into Prisma Client's API, look at the route handlers in the `src/index.js` file.",
    "title": "Deploy a Prisma app to Heroku | Prisma Documentation",
    "description": "Learn how to deploy a Node.js server that uses Prisma ORM to Heroku.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda",
    "markdown": "# Deploy your application using Prisma ORM to AWS Lambda\n\nThis guide explains how to avoid common issues when deploying a project using Prisma ORM to [AWS Lambda](https://aws.amazon.com/lambda/).\n\nWhile a deployment framework is not required to deploy to AWS Lambda, this guide covers deploying with:\n\n*   [AWS Serverless Application Model (SAM)](https://aws.amazon.com/serverless/sam/) is an open-source framework from AWS that can be used in the creation of serverless applications. AWS SAM includes the [AWS SAM CLI](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-reference.html#serverless-sam-cli), which you can use to build, test, and deploy your application.\n*   [Serverless Framework](https://www.serverless.com/framework/) provides a CLI that helps with workflow automation and AWS resource provisioning. While Prisma ORM works well with the Serverless Framework \"out of the box\", there are a few improvements that can be made within your project to ensure a smooth deployment and performance. There is also additional configuration that is needed if you are using the [`serverless-webpack`](https://www.npmjs.com/package/serverless-webpack) or [`serverless-bundle`](https://www.npmjs.com/package/serverless-bundle) libraries.\n*   [SST](https://sst.dev/) provides tools that make it easy for developers to define, test, debug, and deploy their applications. Prisma ORM works well with SST but must be configured so that your schema is correctly packaged by SST.\n\n## General considerations when deploying to AWS Lambda[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#general-considerations-when-deploying-to-aws-lambda \"Direct link to General considerations when deploying to AWS Lambda\")\n\nThis section covers changes you will need to make to your application, regardless of framework. After following these steps, follow the steps for your framework.\n\n*   [Deploying with AWS SAM](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#deploying-with-aws-sam)\n*   [Deploying with the Serverless Framework](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#deploying-with-the-serverless-framework)\n*   [Deploying with SST](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#deploying-with-sst)\n\n### Define binary targets in Prisma Schema[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#define-binary-targets-in-prisma-schema \"Direct link to Define binary targets in Prisma Schema\")\n\nDepending on the version of Node.js, your Prisma schema should contain either `rhel-openssl-1.0.x` or `rhel-openssl-3.0.x` in the `generator` block:\n\n*   Node.js 16 and 18\n*   Node.js 20+\n\n```\nbinaryTargets = [\"native\", \"rhel-openssl-1.0.x\"]\n```\n\nThis is necessary because the runtimes used in development and deployment differ. Add the [`binaryTarget`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#binarytargets-options) to make the compatible Prisma ORM engine file available.\n\n#### Lambda functions with arm64 architectures[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#lambda-functions-with-arm64-architectures \"Direct link to Lambda functions with arm64 architectures\")\n\nLambda functions that use [arm64 architectures (AWS Graviton2 processor)](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html#foundation-arch-adv) must use an `arm64` precompiled engine file.\n\nIn the `generator` block of your `schema.prisma` file, add the following:\n\nschema.prisma\n\n```\nbinaryTargets = [\"native\", \"linux-arm64-openssl-1.0.x\"]\n```\n\n### Prisma CLI binary targets[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#prisma-cli-binary-targets \"Direct link to Prisma CLI binary targets\")\n\nWhile we do not recommend running migrations within AWS Lambda, some applications will require it. In these cases, you can use the [PRISMA\\_CLI\\_BINARY\\_TARGETS](https://www.prisma.io/docs/orm/reference/environment-variables-reference#prisma_cli_binary_targets) environment variable to make sure that Prisma CLI commands, including `prisma migrate`, have access to the correct schema engine.\n\nIn the case of AWS lambda, you will have to add the following environment variable:\n\n.env\n\n```\nPRISMA_CLI_BINARY_TARGETS=native,rhel-openssl-1.0.x\n```\n\ninfo\n\n`prisma migrate` is a command in the `prisma` package. Normally, this package is installed as a dev dependency. Depending on your setup, you may need to install this package as a dependency instead so that it is included in the bundle or archive that is uploaded to Lambda and executed.\n\n### Connection pooling[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#connection-pooling \"Direct link to Connection pooling\")\n\nGenerally, when you use a Function as a Service (FaaS) environment to interact with a database, every function invocation can result in a new connection to the database. This is not a problem with a constantly running Node.js server. Therefore, it is beneficial to pool database connections to get better performance. You can use [Accelerate](https://www.prisma.io/docs/accelerate) to solve this issue. For other solutions, see the [connection management guide for serverless environments](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas).\n\n## Deploying with AWS SAM[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#deploying-with-aws-sam \"Direct link to Deploying with AWS SAM\")\n\n### Loading environment variables[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#loading-environment-variables \"Direct link to Loading environment variables\")\n\nAWS SAM does not directly support loading values from a `.env` file. You will have to use one of AWS's services to store and retrieve these parameters. [This guide](https://medium.com/bip-xtech/a-practical-guide-to-surviving-aws-sam-d8ab141b3d25) provides a great overview of your options and how to store and retrieve values in Parameters, SSM, Secrets Manager, and more.\n\n### Loading required files[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#loading-required-files \"Direct link to Loading required files\")\n\nAWS SAM uses [esbuild](https://esbuild.github.io/) to bundle your TypeScript code. However, the full esbuild API is not exposed and esbuild plugins are not supported. This leads to problems when using Prisma ORM in your application as certain files (like `schema.prisma`) must be available at runtime.\n\nTo get around this, you need to directly reference the needed files in your code to bundle them correctly. In your application, you could add the following lines to your application where Prisma ORM is instantiated.\n\napp.ts\n\n```\nimport schema from './prisma/schema.prisma'import x from './node_modules/.prisma/client/libquery_engine-rhel-openssl-1.0.x.so.node'if (process.env.NODE_ENV !== 'production') {  console.debug(schema, x)}\n```\n\nYou will also need to define how to bundle these files with esbuild by adding the following lines to `Metadata.BuildProperties` in your `template.yaml`:\n\ntemplate.yaml\n\n```\nLoader:  - .prisma=file  - .so.node=fileAssetNames: '[name]'\n```\n\nThis will make sure that files needed by Prisma ORM will be included in the AWS SAM build.\n\n## Deploying with the Serverless Framework[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#deploying-with-the-serverless-framework \"Direct link to Deploying with the Serverless Framework\")\n\n### Loading environment variables via a `.env` file[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#loading-environment-variables-via-a-env-file \"Direct link to loading-environment-variables-via-a-env-file\")\n\nYour functions will need the `DATABASE_URL` environment variable to access the database. The `serverless-dotenv-plugin` will allow you to use your `.env` file in your deployments.\n\nFirst, make sure that the plugin is installed:\n\n```\nnpm install -D serverless-dotenv-plugin\n```\n\nThen, add `serverless-dotenv-plugin` to your list of plugins in `serverless.yml`:\n\nserverless.yml\n\n```\nplugins:  - serverless-dotenv-plugin\n```\n\nThe environment variables in your `.env` file will now be automatically loaded on package or deployment.\n\n### Deploy only the required files[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#deploy-only-the-required-files \"Direct link to Deploy only the required files\")\n\nTo reduce your deployment footprint, you can update your deployment process to only upload the files your application needs. The Serverless configuration file, `serverless.yml`, below shows a `package` pattern that includes only the Prisma ORM engine file relevant to the Lambda runtime and excludes the others. This means that when Serverless Framework packages your app for upload, it includes only one engine file. This ensures the packaged archive is as small as possible.\n\nserverless.yml\n\n```\npackage:  patterns:    - '!node_modules/.prisma/client/libquery_engine-*'    - 'node_modules/.prisma/client/libquery_engine-rhel-*'    - '!node_modules/prisma/libquery_engine-*'    - '!node_modules/@prisma/engines/**'    - '!node_modules/.cache/prisma/**'  # only required for Windows\n```\n\nIf you are deploying to [Lambda functions with ARM64 architecture](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#lambda-functions-with-arm64-architectures) you should update the Serverless configuration file to package the `arm64` engine file, as follows:\n\nserverless.yml\n\n```\npackage:  patterns:    - '!node_modules/.prisma/client/libquery_engine-*'    - 'node_modules/.prisma/client/libquery_engine-linux-arm64-*'    - '!node_modules/prisma/libquery_engine-*'    - '!node_modules/@prisma/engines/**'\n```\n\nIf you use `serverless-webpack`, see [Deployment with serverless webpack](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#deployment-with-serverless-webpack) below.\n\n### Deployment with `serverless-webpack`[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#deployment-with-serverless-webpack \"Direct link to deployment-with-serverless-webpack\")\n\nIf you use `serverless-webpack`, you will need additional configuration so that your `schema.prisma` is properly bundled. You will need to:\n\n1.  Copy your `schema.prisma` with [`copy-webpack-plugin`](https://www.npmjs.com/package/copy-webpack-plugin).\n2.  Run `prisma generate` via `custom > webpack > packagerOptions > scripts` in your `serverless.yml`.\n3.  Only package the correct Prisma ORM engine file to save more than 40mb of capacity.\n\n#### 1\\. Install webpack specific dependencies[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#1-install-webpack-specific-dependencies \"Direct link to 1. Install webpack specific dependencies\")\n\nFirst, ensure the following webpack dependencies are installed:\n\n```\nnpm install --save-dev webpack webpack-node-externals copy-webpack-plugin serverless-webpack\n```\n\n#### 2\\. Update `webpack.config.js`[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#2-update-webpackconfigjs \"Direct link to 2-update-webpackconfigjs\")\n\nIn your `webpack.config.js`, make sure that you set `externals` to `nodeExternals()` like the following:\n\nwebpack.config.js\n\n```\nconst nodeExternals = require('webpack-node-externals')module.exports = {  // ... other configuration  externals: [nodeExternals()],  // ... other configuration}\n```\n\nUpdate the `plugins` property in your `webpack.config.js` file to include the `copy-webpack-plugin`:\n\nwebpack.config.js\n\n```\nconst nodeExternals = require('webpack-node-externals')const CopyPlugin = require('copy-webpack-plugin')module.exports = {  // ... other configuration  externals: [nodeExternals()],  plugins: [    new CopyPlugin({      patterns: [        { from: './node_modules/.prisma/client/schema.prisma', to: './' }, // you may need to change `to` here.      ],    }),  ],  // ... other configuration}\n```\n\nThis plugin will allow you to copy your `schema.prisma` file into your bundled code. Prisma ORM requires that your `schema.prisma` be present in order make sure that queries are encoded and decoded according to your schema. In most cases, bundlers will not include this file by default and will cause your application to fail to run.\n\ninfo\n\nDepending on how your application is bundled, you may need to copy the schema to a location other than `./`. Use the `serverless package` command to package your code locally so you can review where your schema should be put.\n\nRefer to the [Serverless Webpack documentation](https://www.serverless.com/plugins/serverless-webpack) for additional configuration.\n\n#### 3\\. Update `serverless.yml`[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#3-update-serverlessyml \"Direct link to 3-update-serverlessyml\")\n\nIn your `serverless.yml` file, make sure that the `custom > webpack` block has `prisma generate` under `packagerOptions > scripts` as follows:\n\nserverless.yml\n\n```\ncustom:  webpack:    packagerOptions:      scripts:        - prisma generate\n```\n\nThis will ensure that, after webpack bundles your code, the Prisma Client is generated according to your schema. Without this step, your app will fail to run.\n\nLastly, you will want to exclude [Prisma ORM query engines](https://www.prisma.io/docs/orm/more/under-the-hood/engines) that do not match the AWS Lambda runtime. Update your `serverless.yml` by adding the following script that makes sure only the required query engine, `rhel-openssl-1.0.x`, is included in the final packaged archive.\n\nserverless.yml\n\n```\ncustom:  webpack:    packagerOptions:      scripts:        - prisma generate        -- find . -name \"libquery_engine-*\" -not -name \"libquery_engine-rhel-openssl-*\" | xargs rm\n```\n\nIf you are deploying to [Lambda functions with ARM64 architecture](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#lambda-functions-with-arm64-architectures) you should update the `find` command to the following:\n\nserverless.yml\n\n```\ncustom:  webpack:    packagerOptions:      scripts:        - prisma generate        -- find . -name \"libquery_engine-*\" -not -name \"libquery_engine-arm64-openssl-*\" | xargs rm\n```\n\n#### 4\\. Wrapping up[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#4-wrapping-up \"Direct link to 4. Wrapping up\")\n\nYou can now re-package and re-deploy your application. To do so, run `serverless deploy`. Webpack output will show the schema being moved with `copy-webpack-plugin`:\n\n## Deploying with SST[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#deploying-with-sst \"Direct link to Deploying with SST\")\n\n### Working with environment variables[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#working-with-environment-variables \"Direct link to Working with environment variables\")\n\nWhile SST supports `.env` files, [it is not recommended](https://docs.sst.dev/config#should-i-use-configsecret-or-env-for-secrets). SST recommends using `Config` to access these environment variables in a secure way.\n\nThe SST guide [available here](https://docs.sst.dev/config#overview) is a step-by-step guide to get started with `Config`. Assuming you have created a new secret called `DATABASE_URL` and have [bound that secret to your app](https://docs.sst.dev/config#bind-the-config), you can set up `PrismaClient` with the following:\n\nprisma.ts\n\n```\nimport { PrismaClient } from '@prisma/client'import { Config } from 'sst/node/config'const globalForPrisma = global as unknown as { prisma: PrismaClient }export const prisma =  globalForPrisma.prisma ||  new PrismaClient({    datasourceUrl: Config.DATABASE_URL,  })if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prismaexport default prisma\n```",
    "title": "Deploy your application using Prisma ORM to AWS Lambda | Prisma Documentation",
    "description": "Learn how to deploy your Prisma ORM-backed applications to AWS Lambda with AWS SAM, Serverless Framework, or SST",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-azure-functions",
    "markdown": "# How to deploy an app using Prisma ORM to Azure Functions\n\nThis guide explains how to avoid common issues when deploying a Node.js-based function app to Azure using [Azure Functions](https://azure.microsoft.com/en-us/services/functions/).\n\nAzure Functions is a serverless deployment platform. You do not need to maintain infrastructure to deploy your code. With Azure Functions, the fundamental building block is the [function app](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference#function-app). A function app provides an execution context in Azure in which your functions run. It is comprised of one or more individual functions that Azure manages, deploys, and scales together. You can organize and collectively manage multiple functions as a single logical unit.\n\n## Prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-azure-functions#prerequisites \"Direct link to Prerequisites\")\n\n*   An existing function app project with Prisma ORM\n\n## Things to know[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-azure-functions#things-to-know \"Direct link to Things to know\")\n\nWhile Prisma ORM works well with Azure functions, there are a few things to take note of before deploying your application.\n\n### Define multiple binary targets[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-azure-functions#define-multiple-binary-targets \"Direct link to Define multiple binary targets\")\n\nWhen deploying a function app, the operating system that Azure functions runs a remote build is different from the one used to host your functions. Therefore, we recommend specifying the following [`binaryTargets` options](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#binarytargets-options) in your Prisma schema:\n\nschema.prisma\n\n```\ngenerator client {  provider      = \"prisma-client-js\"  binaryTargets = [\"native\", \"debian-openssl-1.1.x\"]}\n```\n\n### Connection pooling[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-azure-functions#connection-pooling \"Direct link to Connection pooling\")\n\nGenerally, when you use a FaaS (Function as a Service) environment to interact with a database, every function invocation can result in a new connection to the database. This is not a problem with a constantly running Node.js server. Therefore, it is beneficial to pool DB connections to get better performance. To solve this issue, you can use the [Prisma Accelerate](https://www.prisma.io/docs/accelerate). For other solutions, see the [connection management guide for serverless environments](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas).\n\n## Summary[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-azure-functions#summary \"Direct link to Summary\")\n\nFor more insight into Prisma Client's API, explore the function handlers and check out the [Prisma Client API Reference](https://www.prisma.io/docs/orm/reference/prisma-client-reference)",
    "title": "How to deploy an app using Prisma ORM to Azure Functions | Prisma Documentation",
    "description": "Learn how to deploy a Prisma Client based REST API to Azure Functions and connect to an Azure SQL database",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-vercel",
    "markdown": "# Deploy to Vercel | Prisma Documentation\n\nThis guide takes you through the steps to set up and deploy a serverless application that uses Prisma to [Vercel](https://vercel.com/).\n\nVercel is a cloud platform that hosts static sites, serverless, and edge functions. You can integrate a Vercel project with a GitHub repository to allow you to deploy automatically when you make new commits.\n\nWe created an [example application](https://github.com/prisma/deployment-example-vercel) using Next.js you can use as a reference when deploying an application using Prisma to Vercel.\n\nWhile our examples use Next.js, you can deploy other applications to Vercel. See [Using Express with Vercel](https://vercel.com/guides/using-express-with-vercel) and [Nuxt on Vercel](https://vercel.com/docs/frameworks/nuxt) as examples of other options.\n\n## Generate Prisma ORM during build[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-vercel#generate-prisma-orm-during-build \"Direct link to Generate Prisma ORM during build\")\n\nVercel will automatically cache dependencies on deployment. For most applications, this will not cause any issues. However, for Prisma ORM, it may result in an outdated version of Prisma Client on a change in your Prisma schema. To avoid this issue, add `prisma generate` to the `postinstall` script of your application:\n\npackage.json\n\n```\n{  ...  \"scripts\" {    \"postinstall\": \"prisma generate\"  }  ...}\n```\n\nThis will re-generate Prisma Client at build time so that your deployment always has an up-to-date client.\n\ninfo\n\nIf you see `prisma: command not found` errors during your deployment to Vercel, you are missing `prisma` in your dependencies. By default, `prisma` is a dev dependency and may need to be moved to be a standard dependency.\n\nAnother option to avoid an outdated Prisma Client is to use [a custom output path](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client#using-a-custom-output-path) and check your client into version control. This way each deployment is guaranteed to include the correct Prisma Client.\n\nschema.prisma\n\n```\ngenerator client {  provider = \"prisma-client-js\"  output   = \"./generated/client\"}\n```\n\n## Add a separate database for preview deployments[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-vercel#add-a-separate-database-for-preview-deployments \"Direct link to Add a separate database for preview deployments\")\n\nBy default, your application will have a single _production_ environment associated with the `main` git branch of your repository. If you open a pull request to change your application, Vercel creates a new _preview_ environment.\n\nVercel uses the `DATABASE_URL` environment variable you define when you import the project for both the production and preview environments. This causes problems if you create a pull request with a database schema migration because the pull request will change the schema of the production database.\n\nTo prevent this, use a _second_ hosted database to handle preview deployments. Once you have that connection string, you can add a `DATABASE_URL` for your preview environment using the Vercel dashboard:\n\n1.  Click the **Settings** tab of your Vercel project.\n    \n2.  Click **Environment variables**.\n    \n3.  Add an environment variable with a key of `DATABASE_URL` and select only the **Preview** environment option:\n    \n    ![Add an environment variable for the preview environment](https://www.prisma.io/docs/assets/images/300-60-deploy-to-vercel-preview-environment-variable-5e996d039ed3cea8209ae94a0b85bad6.png)\n    \n4.  Set the value to the connection string of your second database:\n    \n    ```\n    postgresql://dbUsername:dbPassword@myhost:5432/mydb\n    ```\n    \n5.  Click **Save**.\n    \n\n## Connection pooling[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-vercel#connection-pooling \"Direct link to Connection pooling\")\n\nWhen you use a Function-as-a-Service provider, like Vercel Serverless functions, every invocation may result in a new connection to your database. This can cause your database to quickly run out of open connections and cause your application to stall. For this reason, pooling connections to your database is essential.\n\nYou can use [Accelerate](https://www.prisma.io/docs/accelerate) for connection pooling, to reduce your Prisma Client bundle size, and to avoid cold starts.\n\nFor more information on connection management for serverless environments, refer to our [connection management guide](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas).",
    "title": "Deploy to Vercel | Prisma Documentation",
    "description": "Learn how to deploy a Next.js application based on Prisma Client to Vercel.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-netlify",
    "markdown": "# Deploy to Netlify | Prisma Documentation\n\nThis guide covers the steps you will need to take in order to deploy your application that uses Prisma ORM to [Netlify](https://www.netlify.com/).\n\nNetlify is a cloud platform for continuous deployment, static sites, and serverless functions. Netlify integrates seamlessly with GitHub for automatic deployments upon commits. When you follow the steps below, you will use that approach to create a CI/CD pipeline that deploys your application from a GitHub repository.\n\n## Prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-netlify#prerequisites \"Direct link to Prerequisites\")\n\nBefore you can follow this guide, you will need to set up your application to begin deploying to Netlify. We recommend the [\"Get started with Netlify\"](https://docs.netlify.com/get-started/) guide for a quick overview and [\"Deploy functions\"](https://docs.netlify.com/functions/deploy/?fn-language=ts) for an in-depth look at your deployment options.\n\n## Binary targets in `schema.prisma`[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-netlify#binary-targets-in-schemaprisma \"Direct link to binary-targets-in-schemaprisma\")\n\nSince your code is being deployed to Netlify's environment, which isn't necessarily the same as your development environment, you will need to set [`binaryTargets`](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#binarytargets-options) in order to download the query engine that is compatible with the Netlify runtime during your build step. If you do not set this option, your deployed code will have an incorrect query engine deployed with it and will not function.\n\nDepending on the version of Node.js, your Prisma schema should contain either `rhel-openssl-1.0.x` or `rhel-openssl-3.0.x` in the `generator` block:\n\n*   Node.js 16 and 18\n*   Node.js 20+\n\n```\nbinaryTargets = [\"native\", \"rhel-openssl-1.0.x\"]\n```\n\n## Store environment variables in Netlify[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-netlify#store-environment-variables-in-netlify \"Direct link to Store environment variables in Netlify\")\n\nWe recommend keeping `.env` files in your `.gitignore` in order to prevent leakage of sensitives connection strings. Instead, you can use the Netlify CLI to [import values into netlify directly](https://docs.netlify.com/environment-variables/get-started/#import-variables-with-the-netlify-cli).\n\nAssuming you have a file like the following:\n\n.env\n\n```\n# Connect to DBDATABASE_URL=\"postgresql://postgres:__PASSWORD__@__HOST__:__PORT__/__DB_NAME__\"\n```\n\nYou can upload the file as environment variables using the `env:import` command\n\n```\n❯ netlify env:import .envsite: my-very-very-cool-site---------------------------------------------------------------------------------.                         Imported environment variables                          |---------------------------------------------------------------------------------|     Key      |                              Value                               |--------------|------------------------------------------------------------------| DATABASE_URL | postgresql://postgres:__PASSWORD__@__HOST__:__PORT__/__DB_NAME__ |---------------------------------------------------------------------------------'\n```\n\nIf you are not using an `.env` file\n\nIf you are storing your database connection string and other environment variables in a different method, you will need to manually upload your environment variables to Netlify. These options are [discussed in Netlfiy's documentation](https://docs.netlify.com/environment-variables/get-started/) and one method, uploading via the UI, is described below.\n\n1.  Open the Netlify admin UI for the site. You can use Netlify CLI as follows:\n2.  Click **Site settings**: ![Netlify admin UI](https://www.prisma.io/docs/assets/images/500-06-deploy-to-netlify-site-settings-0fa0afc24ded2e67fdf39af700d5b7af.png)\n3.  Navigate to **Build & deploy** in the sidebar on the left and select **Environment**.\n4.  Click **Edit variables** and create a variable with the key `DATABASE_URL` and set its value to your database connection string. ![Netlify environment variables](https://www.prisma.io/docs/assets/images/500-07-deploy-to-netlify-environment-variables-settings-5e96f436ae259821a7dc8a0bdc11c71e.png)\n5.  Click **Save**.\n\nNow start a new Netlify build and deployment so that the new build can use the newly uploaded environment variables.\n\nYou can now test the deployed application.\n\n## Connection pooling[​](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-netlify#connection-pooling \"Direct link to Connection pooling\")\n\nWhen you use a Function-as-a-Service provider, like Netlify, it is beneficial to pool database connections for performance reasons. This is because every function invocation may result in a new connection to your database which can quickly run out of open connections.\n\nYou can use [Accelerate](https://www.prisma.io/docs/accelerate) for connection pooling, to reduce your Prisma Client bundle size, and to avoid cold starts.\n\nFor more information on connection management for serverless environments, refer to our [connection management guide](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/databases-connections#serverless-environments-faas).",
    "title": "Deploy to Netlify | Prisma Documentation",
    "description": "Learn how to deploy Node.js and TypeScript applications that are using Prisma Client to Netlify.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/codemods",
    "markdown": "# Codemods (Guides) | Prisma Documentation\n\nThe `@prisma/codemods` package helps you to upgrade your codebase as Prisma ORM evolves.\n\n```\n  $ npx @prisma/codemods <transform> <path> <...options>\n```",
    "title": "Codemods (Guides) | Prisma Documentation",
    "description": "Use codemods to upgrade your codebase as Prisma ORM evolves.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel",
    "markdown": "# Deploy to Vercel Edge Functions & Middleware\n\nThis page covers everything you need to know to deploy an app that uses Prisma Client for talking to a database in [Vercel Edge Middleware](https://vercel.com/docs/functions/edge-middleware) or a [Vercel Function](https://vercel.com/docs/functions) deployed to the [Vercel Edge Runtime](https://vercel.com/docs/functions/runtimes/edge-runtime).\n\nTo deploy a Vercel Function to the Vercel Edge Runtime, you can set `export const runtime = 'edge'` outside the request handler of the Vercel Function.\n\n## General considerations when deploying to Vercel Edge Functions & Edge Middleware[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#general-considerations-when-deploying-to-vercel-edge-functions--edge-middleware \"Direct link to General considerations when deploying to Vercel Edge Functions & Edge Middleware\")\n\n### Using an edge-compatible driver[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#using-an-edge-compatible-driver \"Direct link to Using an edge-compatible driver\")\n\nVercel's Edge Runtime currently only supports a limited set of database drivers:\n\n*   [Neon Serverless](https://neon.tech/docs/serverless/serverless-driver) uses HTTP to access the database (also compatible with [Vercel Postgres](https://vercel.com/docs/storage/vercel-postgres))\n*   [PlanetScale Serverless](https://planetscale.com/docs/tutorials/planetscale-serverless-driver) uses HTTP to access the database\n*   [`@libsql/client`](https://github.com/tursodatabase/libsql-client-ts) is used to access Turso databases\n\nNote that [`node-postgres`](https://node-postgres.com/) (`pg`) is currently _not_ supported on Vercel Edge Functions.\n\nWhen deploying a Vercel Edge Function that uses Prisma ORM, you need to use one of these [edge-compatible drivers](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview#edge-compatibility-of-database-drivers) and its respective [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters) for Prisma ORM.\n\n> **Note**: [Prisma Accelerate](https://www.prisma.io/docs/accelerate) enables you to access _any_ database from _any_ edge function provider. No edge-compatible driver is necessary.\n\n### Setting your database connection URL as an environment variable[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#setting-your-database-connection-url-as-an-environment-variable \"Direct link to Setting your database connection URL as an environment variable\")\n\nFirst, ensure that the `DATABASE_URL` is set as the `url` of the `datasource` in your Prisma schema:\n\n```\ndatasource db {  provider = \"postgresql\" // this might also be `mysql` or another value depending on your database  url      = env(\"DATABASE_URL\")}\n```\n\n#### Development[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#development \"Direct link to Development\")\n\nWhen in **development**, you can configure your database connection via the `DATABASE_URL` environment variable (e.g. [using `.env` files](https://www.prisma.io/docs/orm/more/development-environment/environment-variables/env-files)).\n\n#### Production[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#production \"Direct link to Production\")\n\nWhen deploying your Edge Function to **production**, you'll need to set the database connection using the `vercel` CLI:\n\n```\nnpx vercel env add DATABASE_URL\n```\n\nThis command is interactive and will ask you to select environments and provide the value for the `DATABASE_URL` in subsequent steps.\n\nAlternatively, you can configure the environment variable [via the UI](https://vercel.com/docs/projects/environment-variables#declare-an-environment-variable) of your project in the Vercel Dashboard.\n\n### Generate Prisma Client in `postinstall` hook[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#generate-prisma-client-in-postinstall-hook \"Direct link to generate-prisma-client-in-postinstall-hook\")\n\nIn your `package.json`, you should add a `\"postinstall\"` section as follows:\n\npackage.json\n\n```\n{  // ...,  \"postinstall\": \"prisma generate\"}\n```\n\n### Size limits on free accounts[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#size-limits-on-free-accounts \"Direct link to Size limits on free accounts\")\n\nVercel has a [size limit of 1 MB on free accounts](https://vercel.com/docs/functions/limitations). If your application bundle with Prisma ORM exceeds that size, we recommend upgrading to a paid account or using Prisma Accelerate to deploy your application.\n\n## Database-specific considerations & examples[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#database-specific-considerations--examples \"Direct link to Database-specific considerations & examples\")\n\nThis section provides database-specific instructions for deploying a Vercel Edge Functions with Prisma ORM.\n\n### Prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#prerequisites \"Direct link to Prerequisites\")\n\nAs a prerequisite for the following section, you need to have a Vercel Edge Function (which typically comes in the form of a Next.js API route) running locally and the Prisma and Vercel CLIs installed.\n\nIf you don't have that yet, you can run these commands to set up a Next.js app from scratch (following the instructions of the [Vercel Edge Quickstart](https://vercel.com/docs/functions/edge-functions/quickstart)):\n\n```\nnpm install -g vercelnpx create-next-app@latestnpm install prisma --save-devnpx prisma init\n```\n\nWe'll use the default `User` model for the example below:\n\n```\nmodel User {  id    Int     @id @default(autoincrement())  email String  @unique  name  String?}\n```\n\n### Vercel Postgres[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#vercel-postgres \"Direct link to Vercel Postgres\")\n\nIf you are using Vercel Postgres, you need to:\n\n*   use the `@prisma/adapter-neon` database adapter (via the `driverAdapters` Preview feature) because Vercel Postgres uses [Neon](https://neon.tech/) under the hood\n*   be aware that Vercel by default calls the environment variable for the database connection string `POSTGRES_PRISMA_URL` while the default name used in the Prisma docs is typically `DATABASE_URL`; using Vercel's naming, you need to set the following fields on your `datasource` block:\n    \n    ```\n    datasource db {  provider  = \"postgresql\"  url       = env(\"POSTGRES_PRISMA_URL\") // uses connection pooling  directUrl = env(\"POSTGRES_URL_NON_POOLING\") // uses a direct connection}\n    ```\n    \n\n#### 1\\. Configure Prisma schema & database connection[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#1-configure-prisma-schema--database-connection \"Direct link to 1. Configure Prisma schema & database connection\")\n\n> **Note**: If you don't have a project to deploy, follow the instructions in the [Prerequisites](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#prerequisites) to bootstrap a basic Next.js app with Prisma ORM in it.\n\nFirst, ensure that the database connection is configured properly. In your Prisma schema, set the `url` of the `datasource` block to the `POSTGRES_PRISMA_URL` and the `directUrl` to the `POSTGRES_URL_NON_POOLING` environment variable. You also need to enable the `driverAdapters` feature flag:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}datasource db {  provider  = \"postgresql\"  url       = env(\"POSTGRES_PRISMA_URL\") // uses connection pooling  directUrl = env(\"POSTGRES_URL_NON_POOLING\") // uses a direct connection}\n```\n\nNext, you need to set the `POSTGRES_PRISMA_URL` and `POSTGRES_URL_NON_POOLING` environment variable to the values of your database connection.\n\nIf you ran `npx prisma init`, you can use the `.env` file that was created by this command to set these:\n\n.env\n\n```\nPOSTGRES_PRISMA_URL=\"postgres://user:password@host-pooler.region.postgres.vercel-storage.com:5432/name?pgbouncer=true&connect_timeout=15\"POSTGRES_URL_NON_POOLING=\"postgres://user:password@host.region.postgres.vercel-storage.com:5432/name\"\n```\n\n#### 2\\. Install dependencies[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#2-install-dependencies \"Direct link to 2. Install dependencies\")\n\nNext, install the required packages:\n\n```\nnpm install @prisma/adapter-neonnpm install @neondatabase/serverless\n```\n\n#### 3\\. Configure `postinstall` hook[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#3-configure-postinstall-hook \"Direct link to 3-configure-postinstall-hook\")\n\nNext, add a new key to the `scripts` section in your `package.json`:\n\npackage.json\n\n```\n{  // ...  \"scripts\": {    // ...    \"postinstall\": \"prisma generate\"  }}\n```\n\n#### 4\\. Migrate your database schema (if applicable)[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#4-migrate-your-database-schema-if-applicable \"Direct link to 4. Migrate your database schema (if applicable)\")\n\nIf you ran `npx prisma init` above, you need to migrate your database schema to create the `User` table that's defined in your Prisma schema (if you already have all the tables you need in your database, you can skip this step):\n\n```\nnpx prisma migrate dev --name init\n```\n\n#### 5\\. Use Prisma Client in your Vercel Edge Function to send a query to the database[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#5-use-prisma-client-in-your-vercel-edge-function-to-send-a-query-to-the-database \"Direct link to 5. Use Prisma Client in your Vercel Edge Function to send a query to the database\")\n\nIf you created the project from scratch, you can create a new edge function as follows.\n\nFirst, create a new API route, e.g. by using these commands:\n\n```\nmkdir src/app/apimkdir src/app/api/edgetouch src/app/api/edge/route.ts\n```\n\nHere is a sample code snippet that you can use to instantiate `PrismaClient` and send a query to your database in the new `app/api/edge/route.ts` file you just created:\n\napp/api/edge/route.ts\n\n```\nimport { NextResponse } from 'next/server'import { PrismaClient } from '@prisma/client'import { PrismaNeon } from '@prisma/adapter-neon'import { Pool } from '@neondatabase/serverless'export const runtime = 'edge'export async function GET(request: Request) {  const neon = new Pool({ connectionString: process.env.POSTGRES_PRISMA_URL })  const adapter = new PrismaNeon(neon)  const prisma = new PrismaClient({ adapter })  const users = await prisma.user.findMany()  return NextResponse.json(users, { status: 200 })}\n```\n\n#### 6\\. Run the Edge Function locally[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#6-run-the-edge-function-locally \"Direct link to 6. Run the Edge Function locally\")\n\nRun the app with the following command:\n\nYou can now access the Edge Function via this URL: [`http://localhost:3000/api/edge`](http://localhost:3000/api/edge).\n\n#### 7\\. Set the `POSTGRES_PRISMA_URL` environment variable and deploy the Edge Function[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#7-set-the-postgres_prisma_url-environment-variable-and-deploy-the-edge-function \"Direct link to 7-set-the-postgres_prisma_url-environment-variable-and-deploy-the-edge-function\")\n\nRun the following command to deploy your project with Vercel:\n\nNote that once the project was created on Vercel, you will need to set the `POSTGRES_PRISMA_URL` environment variable (and if this was your first deploy, it likely failed). You can do this either via the Vercel UI or by running the following command:\n\n```\nnpx vercel env add POSTGRES_PRISMA_URL\n```\n\nAt this point, you can get the URL of the deployed application from the Vercel Dashboard and access the edge function via the `/api/edge` route.\n\n### PlanetScale[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#planetscale \"Direct link to PlanetScale\")\n\nIf you are using a PlanetScale database, you need to:\n\n*   use the `@prisma/adapter-planetscale` database adapter (via the `driverAdapters` Preview feature)\n\n#### 1\\. Configure Prisma schema & database connection[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#1-configure-prisma-schema--database-connection-1 \"Direct link to 1. Configure Prisma schema & database connection\")\n\n> **Note**: If you don't have a project to deploy, follow the instructions in the [Prerequisites](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#prerequisites) to bootstrap a basic Next.js app with Prisma ORM in it.\n\nFirst, ensure that the database connection is configured properly. In your Prisma schema, set the `url` of the `datasource` block to the `DATABASE_URL` environment variable. You also need to enable the `driverAdapters` feature flag:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}datasource db {  provider     = \"mysql\"  url          = env(\"DATABASE_URL\")  relationMode = \"prisma\" // required for PlanetScale (as by default foreign keys are disabled)}\n```\n\nNext, you need to set the `DATABASE_URL` environment variable in your `.env` file that's used both by Prisma and Next.js to read your env vars:\n\n.env\n\n```\nDATABASE_URL=\"mysql://32qxa2r7hfl3102wrccj:password@us-east.connect.psdb.cloud/demo-cf-worker-ps?sslaccept=strict\"\n```\n\n#### 2\\. Install dependencies[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#2-install-dependencies-1 \"Direct link to 2. Install dependencies\")\n\nNext, install the required packages:\n\n```\nnpm install @prisma/adapter-planetscalenpm install @planetscale/database\n```\n\n#### 3\\. Configure `postinstall` hook[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#3-configure-postinstall-hook-1 \"Direct link to 3-configure-postinstall-hook-1\")\n\nNext, add a new key to the `scripts` section in your `package.json`:\n\npackage.json\n\n```\n{  // ...  \"scripts\": {    // ...    \"postinstall\": \"prisma generate\"  }}\n```\n\n#### 4\\. Migrate your database schema (if applicable)[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#4-migrate-your-database-schema-if-applicable-1 \"Direct link to 4. Migrate your database schema (if applicable)\")\n\nIf you ran `npx prisma init` above, you need to migrate your database schema to create the `User` table that's defined in your Prisma schema (if you already have all the tables you need in your database, you can skip this step):\n\n#### 5\\. Use Prisma Client in an Edge Function to send a query to the database[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#5-use-prisma-client-in-an-edge-function-to-send-a-query-to-the-database \"Direct link to 5. Use Prisma Client in an Edge Function to send a query to the database\")\n\nIf you created the project from scratch, you can create a new edge function as follows.\n\nFirst, create a new API route, e.g. by using these commands:\n\n```\nmkdir src/app/apimkdir src/app/api/edgetouch src/app/api/edge/route.ts\n```\n\nHere is a sample code snippet that you can use to instantiate `PrismaClient` and send a query to your database in the new `app/api/edge/route.ts` file you just created:\n\napp/api/edge/route.ts\n\n```\nimport { NextResponse } from 'next/server'import { PrismaClient } from '@prisma/client'import { PrismaPlanetScale } from '@prisma/adapter-planetscale'import { Client } from '@planetscale/database'export const runtime = 'edge'export async function GET(request: Request) {  const client = new Client({ url: process.env.DATABASE_URL })  const adapter = new PrismaPlanetScale(client)  const prisma = new PrismaClient({ adapter })  const users = await prisma.user.findMany()  return NextResponse.json(users, { status: 200 })}\n```\n\n#### 6\\. Run the Edge Function locally[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#6-run-the-edge-function-locally-1 \"Direct link to 6. Run the Edge Function locally\")\n\nRun the app with the following command:\n\nYou can now access the Edge Function via this URL: [`http://localhost:3000/api/edge`](http://localhost:3000/api/edge).\n\n#### 7\\. Set the `DATABASE_URL` environment variable and deploy the Edge Function[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#7-set-the-database_url-environment-variable-and-deploy-the-edge-function \"Direct link to 7-set-the-database_url-environment-variable-and-deploy-the-edge-function\")\n\nRun the following command to deploy your project with Vercel:\n\nNote that once the project was created on Vercel, you will need to set the `DATABASE_URL` environment variable (and if this was your first deploy, it likely failed). You can do this either via the Vercel UI or by running the following command:\n\n```\nnpx vercel env add DATABASE_URL\n```\n\nAt this point, you can get the URL of the deployed application from the Vercel Dashboard and access the edge function via the `/api/edge` route.\n\n### Neon[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#neon \"Direct link to Neon\")\n\nIf you are using a Neon database, you need to:\n\n*   use the `@prisma/adapter-neon` database adapter (via the `driverAdapters` Preview feature)\n\n#### 1\\. Configure Prisma schema & database connection[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#1-configure-prisma-schema--database-connection-2 \"Direct link to 1. Configure Prisma schema & database connection\")\n\n> **Note**: If you don't have a project to deploy, follow the instructions in the [Prerequisites](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#prerequisites) to bootstrap a basic Next.js app with Prisma ORM in it.\n\nFirst, ensure that the database connection is configured properly. In your Prisma schema, set the `url` of the `datasource` block to the `DATABASE_URL` environment variable. You also need to enable the `driverAdapters` feature flag:\n\nschema.prisma\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"driverAdapters\"]}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nNext, you need to set the `DATABASE_URL` environment variable in your `.env` file that's used both by Prisma and Next.js to read your env vars:\n\n.env\n\n```\nDATABASE_URL=\"postgresql://janedoe:password@ep-nameless-pond-a23b1mdz.eu-central-1.aws.neon.tech/neondb?sslmode=require\"\n```\n\n#### 2\\. Install dependencies[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#2-install-dependencies-2 \"Direct link to 2. Install dependencies\")\n\nNext, install the required packages:\n\n```\nnpm install @prisma/adapter-neonnpm install @neondatabase/serverless\n```\n\n#### 3\\. Configure `postinstall` hook[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#3-configure-postinstall-hook-2 \"Direct link to 3-configure-postinstall-hook-2\")\n\nNext, add a new key to the `scripts` section in your `package.json`:\n\npackage.json\n\n```\n{  // ...  \"scripts\": {    // ...    \"postinstall\": \"prisma generate\"  }}\n```\n\n#### 4\\. Migrate your database schema (if applicable)[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#4-migrate-your-database-schema-if-applicable-2 \"Direct link to 4. Migrate your database schema (if applicable)\")\n\nIf you ran `npx prisma init` above, you need to migrate your database schema to create the `User` table that's defined in your Prisma schema (if you already have all the tables you need in your database, you can skip this step):\n\n```\nnpx prisma migrate dev --name init\n```\n\n#### 5\\. Use Prisma Client in an Edge Function to send a query to the database[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#5-use-prisma-client-in-an-edge-function-to-send-a-query-to-the-database-1 \"Direct link to 5. Use Prisma Client in an Edge Function to send a query to the database\")\n\nIf you created the project from scratch, you can create a new edge function as follows.\n\nFirst, create a new API route, e.g. by using these commands:\n\n```\nmkdir src/app/apimkdir src/app/api/edgetouch src/app/api/edge/route.ts\n```\n\nHere is a sample code snippet that you can use to instantiate `PrismaClient` and send a query to your database in the new `app/api/edge/route.ts` file you just created:\n\napp/api/edge/route.ts\n\n```\nimport { NextResponse } from 'next/server'import { PrismaClient } from '@prisma/client'import { PrismaNeon } from '@prisma/adapter-neon'import { Pool } from '@neondatabase/serverless'export const runtime = 'edge'export async function GET(request: Request) {  const neon = new Pool({ connectionString: process.env.DATABASE_URL })  const adapter = new PrismaNeon(neon)  const prisma = new PrismaClient({ adapter })  const users = await prisma.user.findMany()  return NextResponse.json(users, { status: 200 })}\n```\n\n#### 6\\. Run the Edge Function locally[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#6-run-the-edge-function-locally-2 \"Direct link to 6. Run the Edge Function locally\")\n\nRun the app with the following command:\n\nYou can now access the Edge Function via this URL: [`http://localhost:3000/api/edge`](http://localhost:3000/api/edge).\n\n#### 7\\. Set the `DATABASE_URL` environment variable and deploy the Edge Function[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-vercel#7-set-the-database_url-environment-variable-and-deploy-the-edge-function-1 \"Direct link to 7-set-the-database_url-environment-variable-and-deploy-the-edge-function-1\")\n\nRun the following command to deploy your project with Vercel:\n\nNote that once the project was created on Vercel, you will need to set the `DATABASE_URL` environment variable (and if this was your first deploy, it likely failed). You can do this either via the Vercel UI or by running the following command:\n\n```\nnpx vercel env add DATABASE_URL\n```\n\nAt this point, you can get the URL of the deployed application from the Vercel Dashboard and access the edge function via the `/api/edge` route.",
    "title": "Deploy to Vercel Edge Functions & Middleware | Prisma Documentation",
    "description": "Learn the things you need to know in order to deploy an Edge function that uses Prisma Client for talking to a database.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-monorepo",
    "markdown": "# Using Prisma Client in a Next.js project in a monorepo setup\n\ntip\n\nIf you want to learn how to build an app with Next.js and Prisma ORM, check out this comprehensive [video tutorial](https://www.youtube.com/watch?v=QXxy8Uv1LnQ&ab_channel=ByteGrad).\n\n## Problem[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-monorepo#problem \"Direct link to Problem\")\n\nIf you use Prisma Client in a [Next.js](https://nextjs.org/) application within a monorepo, you may run into an error that looks similar to:\n\n```\nPrisma Client could not locate the Query Engine for runtime \"debian-openssl-3.0.x\".We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.This is likely caused by tooling that has not copied \"libquery_engine-debian-openssl-3.0.x.so.node\" to the deployment folder.Ensure that you ran \\`prisma generate\\` and that \"libquery_engine-debian-openssl-3.0.x.so.node\" has been copied to \"generated/client\".We would appreciate if you could take the time to share some information with us.Please help us by answering a few questions: https://pris.ly/engine-not-found-tooling-investigation\n```\n\nor:\n\n```\nPrisma Client could not locate the Query Engine for runtime \"debian-openssl-3.0.x\".We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.This is likely caused by a bundler that has not copied \"libquery_engine-debian-openssl-3.0.x.so.node\" next to the resulting bundle.Ensure that \"libquery_engine-debian-openssl-3.0.x.so.node\" has been copied next to the bundle or in \"generated/client\".We would appreciate if you could take the time to share some information with us.Please help us by answering a few questions: https://pris.ly/engine-not-found-bundler-investigation\n```\n\nAssume you have a monorepo with the following structure:\n\n```\n.├── packages│   ├── db│   │   ├── index.ts│   │   ├── node_modules│   │   ├── package.json│   │   └── prisma│   │       ├── client // <-- Custom output location for the generated Prisma Client│   │       │   ├── index.js│   │       │   ├── libquery_engine-debian-openssl-1.1.x.so.node // engine to be copied│   │       │   └── schema.prisma // schema to be copied│   │       └── schema.prisma│   └── service/│       ├── pages/│       │   └── api/│       │       └── test.js│       ├── next.config.js│       └── package.json├── pnpm-workspace.yaml├── package.json└── vercel.json\n```\n\nThe file tree above shows a monorepo contained in a `packages` folder. Inside, there are two packages:\n\n*   `db`: Contains the generated Prisma Client in a custom output location named `client`. `index.ts` at the root of this package exports the instantiated Prisma Client.\n*   `service`: Contains a Next.js application. The `test.js` API route uses the Prisma Client instance provided by the `db` package.\n\nThe errors mentioned above occur as a result of a bundling problem during Next.js's bundling process. The Query Engine file(s) is expected to be found next to the generated Prisma Client. The bundling process, however, does not copy over those files to the output location of the bundle.\n\ninfo\n\nFor a more detailed explanation of exactly what is going wrong during the bundling process, please refer to [this issue](https://github.com/vercel/next.js/issues/46070) we opened in the Next.js GitHub repository.\n\n## Solution[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-monorepo#solution \"Direct link to Solution\")\n\nTo work around this issue, you can use a custom Webpack plugin we created that correctly copies the files Prisma Client needs to their correct location.\n\nTo use this plugin, first install the package:\n\n```\nnpm install -D @prisma/nextjs-monorepo-workaround-plugin\n```\n\nYou can then import the plugin into your `next.config.js` file and use it in `config.plugins`. For example:\n\n```\nconst { PrismaPlugin } = require('@prisma/nextjs-monorepo-workaround-plugin')module.exports = {  webpack: (config, { isServer }) => {    if (isServer) {      config.plugins = [...config.plugins, new PrismaPlugin()]    }    return config  },}\n```\n\nAlternatively, if you are using `next.config.mjs`, you may alter the file as such:\n\nnext.config.mjs\n\n```\nimport { PrismaPlugin } from '@prisma/nextjs-monorepo-workaround-plugin'const nextConfig = {  webpack: (config, { isServer }) => {    if (isServer) {      config.plugins = [...config.plugins, new PrismaPlugin()]    }    return config  }}export default nextConfig\n```",
    "title": "Using Prisma Client in a Next.js project in a monorepo setup | Prisma Documentation",
    "description": "Using Prisma Client in a Next.js project in a monorepo setup",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3",
    "markdown": "# Upgrade to Prisma ORM 3\n\nPrisma ORM 3 introduces a number of **breaking changes** if you are upgrading from an earlier version (any 2.x version), therefore, it is important to understand how this upgrade might affect your application and make any needed adjustments to ensure a smooth transition.\n\nBelow you will find a list of the breaking changes and how to handle them.\n\n## Breaking changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3#breaking-changes \"Direct link to Breaking changes\")\n\n### [Referential actions](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3#referential-actions \"Direct link to referential-actions\")\n\nThe introduction of referential actions in version 3.x removes the safety net in Prisma Client that had previously prevented cascading deletes at runtime.\n\nAs a result, depending on which workflow you are using to work on your application, you could be impacted. We advise you to check your schema and decide if you need to define referential actions explicitly.\n\nSee [Referential action upgrade path](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions) to understand how to proceed.\n\n### [Named constraints](https://www.prisma.io/docs/orm/prisma-schema/data-model/database-mapping)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3#named-constraints \"Direct link to named-constraints\")\n\nWe changed the convention followed by Prisma ORM to name constraints and indexes. We also introduced a clear distinction between the `map` attribute (database-level name) and `name` attribute (Prisma Client API name) in the PSL to explicitly control how constraints are defined in the Prisma schema.\n\nThis means that you will notice an impact when running Prisma `migrate` or `db pull` which will follow this new convention. We advise you to adjust your schema to reflect the names of your constraints and indexes appropriately.\n\nYou can check out the [Named constraints upgrade path](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints) for more information on how to proceed.\n\n### [$queryRaw](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3#queryraw \"Direct link to queryraw\")\n\nFrom version 3.x onwards, the `$queryRaw` method now only supports a template literal.\n\nThis means that if your application relied on `$queryRaw` calls using _strings_, those calls will **not** work anymore. We advise you to use template literals wherever possible for security reasons or resort to `$queryRawUnsafe` otherwise, after carefully escaping queries to prevent SQL injections.\n\nYou can learn more about the new `$queryRaw` and `$queryRawUnsafe` methods in the [Raw database access](https://www.prisma.io/docs/orm/prisma-client/queries/raw-database-access/raw-queries) section of the docs.\n\n### [Json Null Equality](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filtering-by-null-values)[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3#json-null-equality \"Direct link to json-null-equality\")\n\nYou cannot filter a `Json` field by a null value. [See this GitHub issue](https://github.com/prisma/prisma/issues/8399). This is because `{ equals: null }` checks if the column value in the database is `NULL`, not if the JSON value inside the column equals `null`.\n\nTo fix this problem, we decided to split null on Json fields into `JsonNull`, `DbNull` and `AnyNull`.\n\n*   **JsonNull**: Selects the null value in JSON.\n*   **DbNull**: Selects the NULL value in the database.\n*   **AnyNull:** Selects both null JSON values and NULL database values.\n\nGiven the following model in your Prisma Schema:\n\n```\nmodel Log {  id Int @id  meta Json}\n```\n\nStarting in 3.0.1, you'll see a TypeError if you try to filter by null on a `Json` field:\n\n```\nprisma.log.findMany({  where: {    data: {      meta: {        equals: null                ^ TypeError: Type 'null' is not assignable to type        }    },  },});\n```\n\nTo fix this, you'll import and use one of the new null types:\n\n```\nimport { Prisma } from '@prisma/client'prisma.log.findMany({  where: {    data: {      meta: {        equals: Prisma.AnyNull,      },    },  },})\n```\n\nThis also applies to `create`, `update` and `upsert`. To insert a `null` value into a `Json` field, you would write:\n\n```\nimport { Prisma } from '@prisma/client'prisma.log.create({  data: {    meta: Prisma.JsonNull,  },})\n```\n\nAnd to insert a database `NULL` into a Json field, you would write:\n\n```\nimport { Prisma } from '@prisma/client'prisma.log.create({  data: {    meta: Prisma.DbNull,  },})\n```\n\nwarning\n\nThis API change does not apply to the MongoDB connector where there is not a difference between a JSON null and a database NULL.\n\nThey also do not apply to the `array_contains` operator because there can only be a JSON null within an JSON array. Since there cannot be a database NULL within a JSON array, `{ array_contains: null }` is not ambiguous.\n\n## Specific upgrade paths[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3#specific-upgrade-paths \"Direct link to Specific upgrade paths\")\n\n[\n\n## Named constraints upgrade path\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints)\n\n[\n\n## Referential actions upgrade path\n\n](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/referential-actions)\n\n## Upgrading the `prisma` and `@prisma/client` packages to Prisma ORM 3[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3#upgrading-the-prisma-and-prismaclient-packages-to-prisma-orm-3 \"Direct link to upgrading-the-prisma-and-prismaclient-packages-to-prisma-orm-3\")\n\nTo upgrade from version 2.x to 3.x, you need to update both the `prisma` and `@prisma/client` packages. Both the `prisma` and `@prisma/client` packages install with a caret `^` in their version number to safe guard against breaking changes.\n\nTo ignore the caret `^` and upgrade across major versions, you can use the `@3` tag when upgrading with `npm`, or `yarn` .\n\ndanger\n\nBefore upgrading, check each **breaking change** to see how the upgrade might affect your application.\n\n*   npm\n*   yarn\n\n```\nnpm install prisma@3 @prisma/client@3\n```",
    "title": "Upgrade to Prisma ORM 3 | Prisma Documentation",
    "description": "Guides on how to upgrade to Prisma ORM 3",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5",
    "markdown": "# Upgrade to Prisma ORM 5\n\nPrisma ORM 5.0.0 introduces a number of changes, including the usage of our new JSON Protocol, [which make Prisma Client faster by default](https://www.prisma.io/blog/prisma-5-f66prwkjx72s). A full list of these changes can be found [in our release notes](https://github.com/prisma/prisma/releases/tag/5.0.0).\n\nThis guide explains how upgrading might affect your application and gives instructions on how to handle breaking changes within Prisma ORM 5.\n\n## Upgrade the `prisma` and `@prisma/client` packages to version 5[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#upgrade-the-prisma-and-prismaclient-packages-to-version-5 \"Direct link to upgrade-the-prisma-and-prismaclient-packages-to-version-5\")\n\nTo upgrade to Prisma ORM 5 from an earlier version, you need to update both the `prisma` and `@prisma/client` packages.\n\n*   npm\n*   yarn\n*   pnpm\n\n```\nnpm install @prisma/client@5npm install -D prisma@5\n```\n\ndanger\n\nBefore you upgrade, check each breaking change below to see how the upgrade might affect your application.\n\n## Version changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#version-changes \"Direct link to Version changes\")\n\nPrisma ORM 5 includes some minimum version changes for Node.js, TypeScript, and PostgreSQL. To use Prisma version 5.0.0 and up, you will need to have at least the minimum versions below: See our [system requirements](https://www.prisma.io/docs/orm/reference/system-requirements) for all minimum version requirements.\n\n### Node.js minimum version change[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#nodejs-minimum-version-change \"Direct link to Node.js minimum version change\")\n\nFrom Prisma ORM version 5.0.0, the minimum version of Node.js supported is 16.13.0. If your project uses an earlier version of Node.js, you will need to upgrade it.\n\nwarning\n\nNode.js v16.x is reaching [end-of-life on 11 September 2023](https://nodejs.org/en/blog/announcements/nodejs16-eol) in order to coincide with the end-of-life of OpenSSL 1.1.1. For that reason, we recommend upgrading to the current Node.js LTS, v18.x. Please note that Prisma ORM 5 will be the last major version of Prisma ORM to support Node.js v16.\n\n### TypeScript minimum version change[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#typescript-minimum-version-change \"Direct link to TypeScript minimum version change\")\n\nFrom Prisma ORM version 5.0.0, the minimum version of TypeScript supported is 4.7. If your project uses an earlier version of TypeScript, you will need to upgrade it.\n\n### PostgreSQL minimum version change[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#postgresql-minimum-version-change \"Direct link to PostgreSQL minimum version change\")\n\nFrom Prisma ORM version 5.0.0, the minimum version of PostgreSQL supported is 9.6. If your project uses an earlier version of PostgreSQL, you will need to upgrade it.\n\nwarning\n\nWhile Prisma ORM supports PostgreSQL versions 9.6 and above, we **strongly** recommend updating to a version that is currently supported and still receiving updates. Please check [PostgreSQL's versioning policy](https://www.postgresql.org/support/versioning/) to determine which versions are currently supported.\n\n### Prisma Client embedded SQLite version updated[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#prisma-client-embedded-sqlite-version-updated \"Direct link to Prisma Client embedded SQLite version updated\")\n\nWith Prisma ORM version 5.0.0, we have upgraded the embedded version of SQLite from `3.35.4` to `3.41.2`. We did not see any breaking changes and don't anticipate any changes needed in user projects, but if you are using SQLite, especially with raw queries that might go beyond Prisma ORM's functionality, make sure to check [the SQLite changelog](https://www.sqlite.org/changes.html).\n\n## Primary changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#primary-changes \"Direct link to Primary changes\")\n\nThis section gives an overview of the main breaking changes in Prisma ORM 5.\n\n### Removal of `rejectOnNotFound` parameter[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#removal-of-rejectonnotfound-parameter \"Direct link to removal-of-rejectonnotfound-parameter\")\n\nWith Prisma ORM 5, the deprecated parameter `rejectOnNotFound` has been removed. Depending on if your project used `rejectOnNotFound` per query or globally, there will be be different ways of updating your code.\n\nIf you are using the `rejectOnNotFound` parameter on a per-query basis, then follow our steps for [updating your code at the query level](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/rejectonnotfound-changes#replacing-rejectonnotfound-enabled-at-the-query-level).\n\nIf instead you have set up the `rejectOnNotFound` parameter at the client level, you will need to follow [the steps for updating your code at the client level](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/rejectonnotfound-changes#replacing-rejectonnotfound-enabled-at-the-client-level).\n\n### `jsonProtocol` out of Preview[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#jsonprotocol-out-of-preview \"Direct link to jsonprotocol-out-of-preview\")\n\nThe `jsonProtocol` preview feature is now Generally Available. This new protocol leads to [significantly improved startup times](https://www.prisma.io/blog/prisma-5-f66prwkjx72s#improved-startup-performance-in-prisma-client) when compared to our previous GraphQL-based protocol. When upgrading to Prisma ORM 5, make sure to remove `jsonProtocol` from your preview features, if added.\n\nPrisma ORM 4 and lower:\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"jsonProtocol\"]}\n```\n\nPrisma ORM 5:\n\n```\ngenerator client {  provider = \"prisma-client-js\"}\n```\n\nPlease review our [jsonProtocol changes guide](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes) to learn how to update your app to account for the new protocol in Prisma ORM 5. You will need to:\n\n*   [Remove the `jsonProtocol` Preview Feature](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#removal-of-jsonprotocol-preview-feature)\n*   [Remove usage of certain array shortcuts](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#removal-of-array-shortcuts)\n\n### Removal of array shortcuts[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#removal-of-array-shortcuts \"Direct link to Removal of array shortcuts\")\n\nPrisma ORM 5 drops support for a number of \"array shortcuts\". These shortcuts were a way to add a single element as a value to an array-based operator instead of wrapping that one element in an array. To make our typings more consistent and logical and to conform to the new JSON Protocol, we now require array values for these operators.\n\nIn most cases, the fix will be as simple as wrapping the existing value in an array. The shortcuts removed in Prisma ORM 5 are:\n\n*   [`OR` shortcuts](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#or-operators)\n*   [`in` and `notIn` shortcuts](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#in-and-notin-operators)\n*   [PostgreSQL JSON `path` field shortcuts](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#path-argument-for-filtering-on-json-fields-in-postgresql)\n*   [Scalar list shortcuts](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#scalar-lists)\n*   [MongoDB Composite list shortcuts](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#composite-lists)\n\nWhile `OR`, `in`, and `notIn` operators are affected, `AND` and `NOT` are not affected by this change.\n\n### `cockroachdb` provider is now required when connecting to a CockroachDB database[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#cockroachdb-provider-is-now-required-when-connecting-to-a-cockroachdb-database \"Direct link to cockroachdb-provider-is-now-required-when-connecting-to-a-cockroachdb-database\")\n\nWith Prisma ORM version 5.0.0, we require the `cockroachdb` provider to be used when connecting to CockroachDB databases. Previously, we had accepted `postgresql` as well, but we are removing that option.\n\nIf you were using [native database types](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#postgresql) and also the `postgresql` provider, you will need to [baseline your database](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-typescript-cockroachdb) from PostgreSQL to CockroachDB:\n\n1.  Backup your existing `schema.prisma` file (e.g. use version control)\n2.  Update your `datasource` provider from `postgresql` to `cockroachdb`\n3.  Use `npx prisma db pull --force` in order to overwrite your existing Prisma schema (including native types) to those that are on your CockroachDB instance.\n4.  Review changes between your Prisma schema backup and the new Prisma schema generated by `db pull`. You can either use the new schema as is, or update it to include your preferred spacing, comments, etc.\n5.  Delete your existing migrations. We will be [performing a baseline](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-typescript-cockroachdb) in order to make your local setup agree with your existing CockroachDB instance.\n6.  Perform the [baselining steps](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/baseline-your-database-typescript-cockroachdb). After these steps, you'll have migrated successfully from the `postgresql` provider to the `cockroachdb` provider!\n\n### Removal of `runtime/index.js` from generated client[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#removal-of-runtimeindexjs-from-generated-client \"Direct link to removal-of-runtimeindexjs-from-generated-client\")\n\nThe `runtime/index.js` file has been removed from Prisma Client.\n\n#### Using public APIs from `@prisma/client/runtime`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#using-public-apis-from-prismaclientruntime \"Direct link to using-public-apis-from-prismaclientruntime\")\n\nImporting from `@prisma/client/runtime` is no longer available in Prisma ORM 5. If you were using public APIs available in this namespace before, you can instead import `Prisma` and access them. For example:\n\n```\nimport { Decimal, NotFoundError } from '@prisma/client/runtime'const num = new Decimal(24.454545)const notFound = new NotFoundError()\n```\n\nwill need to be changed to\n\n```\nimport { Prisma } from '@prisma/client'const num = new Prisma.Decimal(24.454545)const notFound = new Prisma.NotFoundError()\n```\n\n#### Using private APIs for a specific runtime[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#using-private-apis-for-a-specific-runtime \"Direct link to Using private APIs for a specific runtime\")\n\nWe highly discourage the use of internal private APIs as they can change without warning and are not guaranteed to be supported. If your usage requires a private API that was previous available [please reach out to us on GitHub.](https://github.com/prisma/prisma/discussions/new?category=q-a)\n\n### Generated type changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#generated-type-changes \"Direct link to Generated type changes\")\n\n#### Changes to `RelationFilterInput` to account for nullability[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#changes-to-relationfilterinput-to-account-for-nullability \"Direct link to changes-to-relationfilterinput-to-account-for-nullability\")\n\nPrior to Prisma ORM 5, there was a long-standing bug that caused nullable reverse relations to not be marked as nullable in our generated types. For example, take the following schema:\n\n```\nmodel User {  id Int @id  addressId Int     @unique  address   Address @relation(fields: [addressId], references: [id])  post Post[]}model Address {  id Int @id  user User?}model Post {  id Int @id  userId Int  user   User @relation(fields: [userId], references: [id])}\n```\n\nIn the generated types, `Address.user` and `Post.user` would use the same type, `UserRelationFilter`. This is obviously unintended as `Address.user` is nullable while `Post.user` is not. In Prisma ORM 5, the type of `Address.user` would be `UserNullableRelationFilter`, resolving this issue.\n\nIf you import generated types in your code, you will need to update instances like this to utilize the new `Nullable` types.\n\n#### Changes to `UncheckedUpdateManyInput` to avoid name collisions[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#changes-to-uncheckedupdatemanyinput-to-avoid-name-collisions \"Direct link to changes-to-uncheckedupdatemanyinput-to-avoid-name-collisions\")\n\nIn certain instances it was possible for name collisions to occur when one model had two foreign keys to two other models that had the same property name for the reverse relation. As an example, the following schema:\n\n```\nmodel Invoice {  InvoiceId Int @id @default(autoincrement())  invoice_items InvoiceItem[]}model InvoiceItem {  InvoiceLineId Int @id @default(autoincrement())  InvoiceItemInvoiceId Int     @map(\"InvoiceId\")  invoices             Invoice @relation(fields: [InvoiceItemInvoiceId], references: [InvoiceId])  TrackId Int  tracks  Track @relation(fields: [TrackId], references: [TrackId])}model Track {  TrackId Int    @id @default(autoincrement())  Name    String  invoice_items InvoiceItem[]}\n```\n\nWould lead to conflicting names between the two relations on `InvoiceItem`. The reverse relations, that is `Invoice.invoice_items` and `Track.invoice_items` would both get the type `InvoiceItemUncheckedUpdateManyWithoutInvoice_itemsInput`. In Prisma ORM 5, this is resolved and Prisma Client will generate `InvoiceItemUncheckedUpdateManyWithoutInvoicesInput` and `InvoiceItemUncheckedUpdateManyWithoutTracksInput` respectively.\n\nIf you import generated types in your code, you will need to update instances like this to the corrected types.\n\n## Other changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#other-changes \"Direct link to Other changes\")\n\nThe following changes may cause an application to initially throw an error message after upgrading to Prisma ORM 5. Fortunately, they are easy to solve, as the underlying functionality has been removed for a while or the change is a simple string replace.\n\n### Removal of deprecated Prisma CLI flags[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#removal-of-deprecated-prisma-cli-flags \"Direct link to Removal of deprecated Prisma CLI flags\")\n\nSeveral deprecated CLI flags have been removed. All following flags are from previous APIs and are no longer needed:\n\n*   `--preview-feature` used in `db execute`, `db seed`, and `db diff`\n*   `--experimental` and `--early-access-feature` used in `migrate`\n*   `--force`/`-f` used in `db push`\n*   `--experimental-reintrospection` and `--clean` used in `db pull`\n\nThe outdated use of `db push --force` can be replaced with the newer implementation `db push --accept-data-loss`.\n\nAll other flags are from previous APIs and are no longer needed.\n\n### Removal of the `beforeExit` hook from the library engine[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#removal-of-the-beforeexit-hook-from-the-library-engine \"Direct link to removal-of-the-beforeexit-hook-from-the-library-engine\")\n\nThe `beforeExit` hook has been removed from the Prisma ORM library engine. While this functionality is still required for the Prisma ORM binary engine in order to run last minute queries or perform shutdown related operations, it provides no benefit over native Node.js exit hooks in the library engine. Instead of this hook we recommend using built-in Node.js exit events.\n\nThe following code with Prisma ORM 4:\n\n```\nconst exitHandler = () => {  // your exit handler code}prisma.$on('beforeExit', exitHandler)\n```\n\nCould become:\n\n```\nconst exitHandler = () => {  // your exit handler code}process.on('exit', exitHandler)process.on('beforeExit', exitHandler)process.on('SIGINT', exitHandler)process.on('SIGTERM', exitHandler)process.on('SIGUSR2', exitHandler)\n```\n\nIf you're using the `beforeExit` hook in NestJS, you can upgrade to Prisma ORM 5 by removing the custom `enableShutdownHooks` method in your service:\n\n\"prisma.service.ts\"\n\n```\n@Injectable()export class PrismaService extends PrismaClient implements OnModuleInit {  async onModuleInit() {    await this.$connect()  }-  async enableShutdownHooks(app: INestApplication) {-    this.$on('beforeExit', async () => {-      await app.close()-    })-  }}\n```\n\nInstead, use the built-in `enableShutdownHooks` method in NestJS if you need to handle lifecycle events:\n\n\"main.ts\"\n\n```\n- prismaService.enableShutdownHooks(app)+ app.enableShutdownHooks()\n```\n\n### Removal of deprecated `prisma2` executable[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#removal-of-deprecated-prisma2-executable \"Direct link to removal-of-deprecated-prisma2-executable\")\n\nWhen we released Prisma ORM 2, the `prisma2` executable was used in order to differentiate from Prisma 1. In a later release, the `prisma2` cli took over the `prisma` executable name.\n\nNeedless to say, the `prisma2` executable has been deprecated for some time and is now removed. If your scripts use Prisma CLI as `prisma2`, please replace it with simply `prisma`.\n\n### Removal of deprecated `experimentalFeatures` property[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#removal-of-deprecated-experimentalfeatures-property \"Direct link to removal-of-deprecated-experimentalfeatures-property\")\n\nThe `previewFeatures` field of the [generator block](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#fields-1) used to be called `experimentalFeatures`. We are removing that deprecated property.\n\nIn Prisma ORM 5, you will need to update references of `experimentalFeatures` to `previewFeatures` manually or use the new code action in the Prisma VSCode extension.\n\n### `migration-engine` renamed to `schema-engine`[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#migration-engine-renamed-to-schema-engine \"Direct link to migration-engine-renamed-to-schema-engine\")\n\nThe engine responsible for commands like `prisma migrate` and `prisma db` has been renamed from `migration-engine` to `schema-engine` to better describe its use. For many users, no changes will be required. However, if you need to explicitly include or exclude this engine file, or refer to the engine name for any other reason, you will need to update your code references.\n\n#### Example with the Serverless Framework[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5#example-with-the-serverless-framework \"Direct link to Example with the Serverless Framework\")\n\nOne example we have seen is projects using the Serverless Framework. In these instances, you will need to update any patterns that reference `migration-engine` to instead reference `schema-engine`.\n\n```\npackage:  patterns:    - '!node_modules/.prisma/client/libquery_engine-*'    - 'node_modules/.prisma/client/libquery_engine-rhel-*'    - '!node_modules/prisma/libquery_engine-*'    -- '!node_modules/prisma/migration-engine-*'    -- '!node_modules/prisma/schema-engine-*'\n```\n\nServerless Framework pattern suggestion\n\nThe [recommended rule from our documentation](https://www.prisma.io/docs/orm/prisma-client/deployment/serverless/deploy-to-aws-lambda#lambda-functions-with-arm64-architectures) is not affected by this change as it excludes all non desired engine files.\n\n```\npackage:  patterns:    - '!node_modules/.prisma/client/libquery_engine-*'    - 'node_modules/.prisma/client/libquery_engine-rhel-*'    - '!node_modules/prisma/libquery_engine-*'    -- '!node_modules/@prisma/engines/**'\n```\n\nEnjoy Prisma ORM 5!",
    "title": "Upgrade to Prisma ORM 5 | Prisma Documentation",
    "description": "Guides on how to upgrade to Prisma ORM 5",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy",
    "markdown": "# Deploy to Deno Deploy | Prisma Documentation\n\nWith this guide, you can learn how to build and deploy a simple application to [Deno Deploy](https://deno.com/deploy). The application uses Prisma ORM to save a log of each request to a PostgreSQL database.\n\nThis guide covers the use of Prisma CLI with Deno CLI, Deno Deploy, Prisma Client, and Prisma Accelerate.\n\n## Prerequisites[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#prerequisites \"Direct link to Prerequisites\")\n\n*   a free [Prisma Data Platform](https://console.prisma.io/) account\n*   a free [Deno Deploy](https://deno.com/deploy) account\n*   a PostgreSQL database\n*   Node.js & npm installed\n*   Deno v1.29.4 or later installed. [Learn more](https://docs.deno.com/runtime/manual/#install-deno).\n*   (Recommended) Latest version of Prisma ORM.\n*   (Recommended) Deno extension for VS Code. [Learn more](https://docs.deno.com/runtime/manual/references/vscode_deno/).\n\n## 1\\. Set up your application[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#1-set-up-your-application \"Direct link to 1. Set up your application\")\n\nTo start, you create a directory for your project, and then use `deno run` to initialize your application with `prisma init` as an [npm package with npm specifiers](https://docs.deno.com/runtime/manual/node/npm_specifiers/).\n\nTo set up your application:\n\n1.  Open your terminal and navigate to a location of your choice.\n    \n2.  Run the following commands to set up your application.\n    \n    ```\n    mkdir prisma-deno-deploycd prisma-deno-deploydeno run -A npm:prisma init\n    ```\n    \n3.  Edit the `prisma/schema.prisma` file to define the data model and enable the `deno` preview feature flag.\n    \n    Later in the guide, you create an application that uses the `Log` model to store data for incoming requests from the application.\n    \n    To use Deno, you need to add the preview feature flag `deno` to the `generator` block of your `schema.prisma` file. Also, Deno requires that you generate Prisma Client in a custom location. You can enable this with the `output` parameter in the `generator` block. To satisfy both of these requirements, add the following lines to the `generator` block:\n    \n    schema.prisma\n    \n    ```\n    generator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"deno\"]  output          = \"../generated/client\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model Log {  id      Int    @id @default(autoincrement())  level   Level  message String  meta    Json}enum Level {  Info  Warn  Error}\n    ```\n    \n4.  In your `.env` file, replace the current placeholder connection string `postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public` with your PostgreSQL connection string.\n    \n\n## 2\\. Create the database schema[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#2-create-the-database-schema \"Direct link to 2. Create the database schema\")\n\nWith the data model in place and your database connection configured, you can now apply the data model to your database.\n\n```\ndeno run -A npm:prisma migrate dev --name init\n```\n\nThe command does two things:\n\n1.  It creates a new SQL migration file for this migration\n2.  It runs the SQL migration file against the database\n\nAt this point, the command has two additional side effects. The command installs Prisma Client and creates the `package.json` file for the project, which includes the `@prisma/client` package as a dependency.\n\n## 3\\. Generate Prisma Client for Prisma Accelerate[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#3-generate-prisma-client-for-prisma-accelerate \"Direct link to 3. Generate Prisma Client for Prisma Accelerate\")\n\nNext, generate Prisma Client for the Prisma Accelerate with the `--no-engine` flag. Later, you will use [Prisma Accelerate](https://www.prisma.io/docs/accelerate) to connect to your database over HTTP.\n\n```\ndeno run -A --unstable npm:prisma generate --no-engine\n```\n\ninfo\n\nPrior to Prisma ORM 5.2.0, the `--no-engine` flag is not available. Instead, use the `--accelerate` flag.\n\n```\ndeno run -A npm:prisma generate --accelerate\n```\n\nYou now have a database schema and a locally generated Prisma Client for the Prisma Accelerate.\n\n## 4\\. Create your application[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#4-create-your-application \"Direct link to 4. Create your application\")\n\nYou can now create a local Deno application. Create `index.ts` in the root folder of your project and add the content below:\n\n```\nimport { serve } from 'https://deno.land/std@0.140.0/http/server.ts'import { PrismaClient } from './generated/client/deno/edge.ts'const prisma = new PrismaClient()async function handler(request: Request) {  const log = await prisma.log.create({    data: {      level: 'Info',      message: `${request.method} ${request.url}`,      meta: {        headers: JSON.stringify(request.headers),      },    },  })  const body = JSON.stringify(log, null, 2)  return new Response(body, {    headers: { 'content-type': 'application/json; charset=utf-8' },  })}serve(handler)\n```\n\ninfo\n\n**VS Code error: `An import path cannot end with a '.ts' extension`**\n\nIf you use VS Code and see the error `An import path cannot end with a '.ts' extension` for the `import` statements at the beginning of `index.ts`, you need to install the [Deno extension for VS Code](https://docs.deno.com/runtime/manual/references/vscode_deno/), select **View** > **Command Palette** and run the command **Deno: Initialize Workspace Configuration**. This tells VS Code that the TypeScript files in the current project need to run with Deno, which then triggers the correct validations.\n\n### What's next[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#whats-next \"Direct link to What's next\")\n\nYou cannot run this script yet, because you do not yet have the required Prisma Accelerate connection string to use Prisma Client with your database. Later in this guide, you will obtain the required credentials when you next add your application to the Prisma Data Platform.\n\nAfter that, you test your application locally.\n\n## 5\\. Enable Accelerate in the Prisma Data Platform[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#5-enable-accelerate-in-the-prisma-data-platform \"Direct link to 5. Enable Accelerate in the Prisma Data Platform\")\n\nTo get started with Prisma Accelerate:\n\n1.  Sign up for a free [Prisma Data Platform account](https://console.prisma.io/)\n2.  Create a project\n3.  Navigate to the project you created\n4.  Enable Accelerate\n5.  Generate an Accelerate connection string and copy it to your clipboard\n\n## 6\\. Configure Prisma Accelerate in your environment[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#6-configure-prisma-accelerate-in-your-environment \"Direct link to 6. Configure Prisma Accelerate in your environment\")\n\nWith the Accelerate connection string copied, you can replace the existing connection string that you used to create the database schema in your `.env` file.\n\nPrisma Client does not read `.env` files by default on Deno, so you must also install `dotenv-cli` locally.\n\nTo configure Prisma Accelerate:\n\n1.  Install the `dotenv-cli`.\n    \n2.  Add the Prisma Accelerate connection string to the `.env` file. Also, comment out the direct connection string.\n    \n    .env\n    \n    ```\n    DATABASE_URL=\"prisma://accelerate.prisma-data.net/?api_key=__API_KEY__\"# Previous database connection# DATABASE_URL=\"postgres://...\"\n    ```\n    \n\nThe configuration of your local environment is now ready to send Prisma Client queries to the database through Prisma Accelerate.\n\n## 7\\. Test your application locally[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#7-test-your-application-locally \"Direct link to 7. Test your application locally\")\n\nYou can now start your application locally and test the creation of log entries.\n\n```\nnpx dotenv -- deno run -A ./index.ts\n```\n\nIn a web browser, open [http://localhost:8000/](http://localhost:8000/). This page writes your request to the database.\n\n```\n{  \"id\": 3,  \"level\": \"Info\",  \"message\": \"GET http://localhost:8000/\",  \"meta\": {    \"headers\": \"{}\"  }}\n```\n\nReload the page a few times.\n\nEvery time you reload, the script generates a new log entry and the id of the current log entry increments.\n\nThis confirms that your application works when you run it from your local environment.\n\n## 8\\. Create a repository and push to GitHub[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#8-create-a-repository-and-push-to-github \"Direct link to 8. Create a repository and push to GitHub\")\n\nYou need a GitHub repository to add your project to Deno Deploy and enable automated deployments whenever you push changes.\n\nTo set up a GitHub repository:\n\n1.  [Create a private GitHub repository](https://github.com/new).\n    \n2.  Initialize your repository locally and push your changes to GitHub, with the following commands:\n    \n    ```\n    git init -b maingit remote add origin https://github.com/<username>/prisma-deno-deploygit add .git commit -m \"initial commit\"git push -u origin main\n    ```\n    \n\n## 9\\. Deploy to Deno Deploy[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#9-deploy-to-deno-deploy \"Direct link to 9. Deploy to Deno Deploy\")\n\nUse the GitHub repository to add your application to Deno Deploy:\n\n1.  Go to [https://dash.deno.com/new](https://dash.deno.com/new).\n2.  Select a GitHub organization or user and then select a repository.\n3.  Select a production branch and select **Automatic** mode so that Deno Deploy can deploy every time you push a change to the repository.\n4.  Select `index.ts` as the entry point to your project.\n5.  To define the Accelerate connection string, click **Add Env Variable**.\n    1.  For **KEY**, enter `DATABASE_URL`.\n    2.  For **VALUE**, paste the Accelerate connection string. ![Deno Deploy - project parameters](https://www.prisma.io/docs/assets/images/550-02-deploy-to-deno-project-parameters-5d624fb005f8d4f6828d874f89c03c65.png)\n6.  Click **Link**.  \n    Wait for the first Deno deployment to finish.\n\nWhen the first deployment finishes, your browser is redirected to the project view.\n\n### What's next[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#whats-next-1 \"Direct link to What's next\")\n\nClick the blue **View** button at the top right to open the deployed Deno application.\n\nThe application shows a similar result as when you tested locally with a further increment of the new `Log` record id number.\n\n```\n{  \"id\": 5,  \"level\": \"Info\",  \"message\": \"GET https://prisma-deno-deploy.deno.dev/\",  \"meta\": {    \"headers\": \"{}\"  }}\n```\n\n## Summary[​](https://www.prisma.io/docs/orm/prisma-client/deployment/edge/deploy-to-deno-deploy#summary \"Direct link to Summary\")\n\nYou successfully deployed a Deno application that you created in TypeScript, which uses Prisma Client for the Prisma Accelerate to connect to a PostgreSQL database.",
    "title": "Deploy to Deno Deploy | Prisma Documentation",
    "description": "Learn how to deploy a TypeScript application to Deno Deploy.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes",
    "markdown": "# Upgrade to jsonProtocol in Prisma ORM 5\n\n## jsonProtocol changes\n\nAs of Prisma ORM version 5.0.0, the new `jsonProtocol` is the default. There are some changes that directly result from this change and a few changes that are related to the new protocol.\n\nA full list of Prisma ORM 5 changes can be found [in our release notes](https://github.com/prisma/prisma/releases/tag/5.0.0).\n\n## `jsonProtocol` specific changes[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#jsonprotocol-specific-changes \"Direct link to jsonprotocol-specific-changes\")\n\nBelow are changes that result directly from the `jsonProtocol` feature becoming the default in Prisma ORM 5.\n\n### Removal of `jsonProtocol` Preview Feature[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#removal-of-jsonprotocol-preview-feature \"Direct link to removal-of-jsonprotocol-preview-feature\")\n\nIn Prisma ORM 5, `jsonProtocol` is the default and only protocol in Prisma Client. The `jsonProtocol` Preview feature is no longer needed.\n\nPrisma ORM 4 and lower:\n\n```\ngenerator client {  provider        = \"prisma-client-js\"  previewFeatures = [\"jsonProtocol\"]}\n```\n\nPrisma ORM 5:\n\n```\ngenerator client {  provider = \"prisma-client-js\"}\n```\n\n### Improved error messages[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#improved-error-messages \"Direct link to Improved error messages\")\n\nDue to the switch to the new protocol, several error messages have been improved. For example, the following error message in Prisma ORM 4 and below:\n\n```\nFailed to validate the query: `Unable to match input value to any allowed input type for the field. Parse errors: [Query parsing/validation error at `Mutation.createOneUser.data.UserCreateInput.person.PersonCreateNestedOneWithoutUserInput.create`: Unable to match input value to any allowed input type for the field. Parse errors: [Query parsing/validation error at `Mutation.createOneUser.data.UserCreateInput.person.PersonCreateNestedOneWithoutUserInput.create.PersonCreateWithoutUserInput.hubspot_id`: A value is required but not set., Query parsing/validation error at `Mutation.createOneUser.data.UserCreateInput.person.PersonCreateNestedOneWithoutUserInput.create.PersonUncheckedCreateWithoutUserInput.hubspot_id`: A value is required but not set.], Query parsing/validation error at `Mutation.createOneUser.data.UserUncheckedCreateInput.person`: Field does not exist on enclosing type.]` at `Mutation.createOneUser.data`\n```\n\nbecomes the following in Prisma ORM 5:\n\n```\nInvalid `prisma.user.create()` invocation in/Users/prismo/projects/prisma/reproductions/workbench/index.ts:21:36  18 const prisma = new PrismaClient()  19  20 for (const u of userData) {→ 21   const user = await prisma.user.create({         data: {           email: \"eugene.albright@gallaudet.edu\",           person: {             create: {               first_name: \"William\",               last_name: \"Albright\",       +       hubspot_id: String             }           }         }       })Argument `hubspot_id` must not be null.\n```\n\nBelow are changes that are related to the switch to the new protocol. If you were using the `jsonProtocol` Preview Feature, you most likely ran into these issues.\n\n### Removal of array shortcuts[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#removal-of-array-shortcuts \"Direct link to Removal of array shortcuts\")\n\nSeveral array shortcuts were removed as a part of this major update. These shortcuts were a way to add a single element as a value to an array-based operator.\n\n#### `OR` operators[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#or-operators \"Direct link to or-operators\")\n\nThe following code in Prisma ORM 4 and lower:\n\n```\nprisma.user.findMany({  where: {    OR: { email: 'foo@example.com' },  },})\n```\n\nWill need to be changed to the following in Prisma ORM 5:\n\n```\nprisma.user.findMany({  where: {    OR: [{ email: 'foo@example.com' }],  },})\n```\n\n`OR` operators will only accept array values.\n\n#### `in` and `notIn` operators[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#in-and-notin-operators \"Direct link to in-and-notin-operators\")\n\nSimilar to `OR`, `in` and `notIn` require array values.\n\nPrisma ORM 4 and lower:\n\n```\nprisma.user.findMany({  where: {    id: { in: 123 },  },})prisma.user.findMany({  where: {    id: { notIn: 123 },  },})\n```\n\nPrisma ORM 5:\n\n```\nprisma.user.findMany({  where: {    id: {      in: [123],    },  },})prisma.user.findMany({  where: {    id: {      notIn: [123],    },  },})\n```\n\nSuggestion for single elements\n\nIf your `in` and `notIn` values are only one element, you can also update your code to not use these operators at all:\n\n```\nprisma.user.findMany({  where: {    id: 123,  },})prisma.user.findMany({  where: {    id: { not: 123 },  },})\n```\n\n#### `path` argument for filtering on JSON fields in PostgreSQL[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#path-argument-for-filtering-on-json-fields-in-postgresql \"Direct link to path-argument-for-filtering-on-json-fields-in-postgresql\")\n\n[When filtering on JSON fields in a PostgreSQL model](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types/working-with-json-fields#filter-on-a-json-field-simple) the `path` argument now only accepts an array.\n\nWhen using the following schema:\n\n```\nmodel User {  id       String @id  settings Json}\n```\n\nPrisma ORM 4 and lower:\n\n```\nprisma.user.findMany({  where: {    settings: {      path: 'someSetting',      equals: someValue,    },  },})\n```\n\nPrisma ORM 5:\n\n```\nprisma.user.findMany({  where: {    settings: {      path: ['someSetting'],      equals: someValue,    },  },})\n```\n\ninfo\n\nNote: This `path` argument change only affects PostgreSQL databases. MySQL databases are not affected as they use a different syntax.\n\n#### Scalar lists[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#scalar-lists \"Direct link to Scalar lists\")\n\n[Scalar list](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#scalar-fields) values must be arrays in all operations.\n\nWith the following schema:\n\n```\nmodel Post {  id   String   @id @default(uuid())  tags String[]}\n```\n\nPrisma ORM 4 and lower:\n\n```\nprisma.post.create({  data: {    tags: 'databases',  },})prisma.post.findMany({  where: {    tags: 'databases',  },})\n```\n\nPrisma ORM 5:\n\n```\nprisma.post.create({  data: {    tags: ['databases'],  },})prisma.post.findMany({  where: {    tags: ['databases'],  },})\n```\n\n#### Composite lists[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-5/jsonprotocol-changes#composite-lists \"Direct link to Composite lists\")\n\nOperations on lists of [Composite types](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-composite-types) (for [MongoDB](https://www.prisma.io/docs/orm/overview/databases/mongodb)) now only accept array values.\n\nWith the following schema:\n\n```\nmodel Post {  id           String    @id @default(uuid())  commentsList Comment[]}type Comment {  text String}\n```\n\nPrisma ORM 4 and lower:\n\n```\nprisma.post.findMany({  where: {    commentsList: {      equals: { text: 'hello' },    },  },})\n```\n\nPrisma ORM 5:\n\n```\nprisma.post.findMany({  where: {    commentsList: {      equals: [{ text: 'hello' }],    },  },})\n```\n\nShorthand notation usage\n\nIf you use the shorthand notation and exclude `equals`, you still must supply an array value for composite list fields.\n\nPrisma 4 and lower:\n\n```\nprisma.post.create({  data: {    commentsList: { text: 'hello' },  },})prisma.post.findMany({  where: {    commentsList: { text: 'hello' },  },})\n```\n\nPrisma 5:\n\n```\nprisma.post.create({  data: {    commentsList: [{ text: 'hello' }],  },})prisma.post.findMany({  where: {    commentsList: [{ text: 'hello' }],  },})\n```",
    "title": "Upgrade to jsonProtocol in Prisma ORM 5 | Prisma Documentation",
    "description": "Changes that need to be made to your app in Prisma ORM 5 due to the jsonProtocol",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints",
    "markdown": "# Named constraints upgrade path | Prisma Documentation\n\nAfter upgrading to Prisma ORM 3, the default naming convention for constraint and index names will change and your primary and foreign key names will now be part of the schema for databases that support them. Therefore the meaning of your existing Prisma schema will change.\n\nBefore you continue to evolve your schema and your database, you should decide which names for constraints and indexes you want to use on your project going forward.\n\nYou can either keep the names as they exist in your database or you can switch to use the names generated by Prisma ORM, which follow the new naming convention.\n\nThis page describes the manual upgrade steps that you need to perform after upgrading to Prisma ORM 3. You can pick either of the two options:\n\n*   **Option 1**: [I want to maintain my existing constraint and index names](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints#option-1-i-want-to-maintain-my-existing-constraint-and-index-names)\n*   **Option 2**: [I want to use Prisma ORM's default constraint and index names](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints#option-2-i-want-to-use-prisma-orms-default-constraint-and-index-names)\n\n## Option 1: I want to maintain my existing constraint and index names[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints#option-1-i-want-to-maintain-my-existing-constraint-and-index-names \"Direct link to Option 1: I want to maintain my existing constraint and index names\")\n\nIf you want to keep your database unchanged and keep the existing names for constraints and indexes you need to pull them into your schema so Prisma ORM is aware of them.\n\nReasons to keep your existing names might be:\n\n*   Naming conventions you have to follow\n*   Other tooling relying on the names\n*   Personal preference\n\nTo keep existing names, run `prisma db pull` against the target environment. This will result in all names that do not match Prisma ORM's naming convention for constraint and index names being pulled into your schema as `map` arguments on their respective attributes.\n\n1.  Example schema:\n    \n    ```\n    model User {  id    Int    @id @default(autoincrement())  name  String @unique  posts Post[]}model Post {  id         Int    @id @default(autoincrement())  title      String  authorName String @default(\"Anonymous\")  author     User?  @relation(fields: [authorName], references: [name])}\n    ```\n    \n2.  Introspect your **development database** to populate the Prisma schema with constraint and index names in your underlying database _that do not match Prisma ORM's naming convention_:\n    \n    In this example, the highlighted constraints did not conform to Prisma ORM's default naming convention and now include the `map` attribute field:\n    \n    ```\n    model User {  id    Int    @id(map: \"Custom_Constraint_Name\") @default(autoincrement())  name  String @unique  posts Post[]}model Post {  id         Int    @id @default(autoincrement())  title      String  authorName String @default(\"Anonymous\")  author     User?  @relation(fields: [authorName], references: [name], map: \"Custom_Foreign_Key_Constraint\")}\n    ```\n    \n\n## Option 2: I want to use Prisma ORM's default constraint and index names[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints#option-2-i-want-to-use-prisma-orms-default-constraint-and-index-names \"Direct link to Option 2: I want to use Prisma ORM's default constraint and index names\")\n\nIf you want to keep your Prisma Schema clean and if you have no reasons preventing you from renaming constraints and indexes in your database, then you can create a migration to update the names.\n\nRun `prisma migrate dev` to create a migration updating the constraint names to Prisma ORM's defaults.\n\nAfterwards, do not forget to `prisma migrate deploy` against your production environment if you have one to also update the names there. The schema below has no explicit constraint or index names spelled out, so Prisma ORM will infer them.\n\n1.  Example schema:\n    \n    ```\n    model User {  name  String @id //inferred as User_pkey  posts Post[]}model Post {  id         Int    @id @default(autoincrement()) //inferred as Post_pkey  authorName String @default(\"Anonymous\")  author     User?  @relation(fields: [authorName], references: [name]) //inferred as Post_authorName_fkey}\n    ```\n    \n2.  Run the `prisma migrate dev` command to generate a new migration:\n    \n    This migration renames any constraints that do not currently follow Prisma ORM's naming convention.\n    \n3.  Run the [`prisma migrate deploy`](https://www.prisma.io/docs/orm/prisma-client/deployment/deploy-database-changes-with-prisma-migrate) command to apply the migration to your production environment:\n    \n    ```\n    npx prisma migrate deploy\n    ```\n    \n\n## Dealing with cases where more than one database environment is used for the same application[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints#dealing-with-cases-where-more-than-one-database-environment-is-used-for-the-same-application \"Direct link to Dealing with cases where more than one database environment is used for the same application\")\n\n### Checking whether your environments use identical names[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints#checking-whether-your-environments-use-identical-names \"Direct link to Checking whether your environments use identical names\")\n\nSince Prisma ORM did not offer a way to define constraint or index names explicitly in the past, you can face situations where your different database environments have differing constraint or index names.\n\nIn order to detect this:\n\n*   Create a backup of your current `schema.prisma` file.\n*   Run `prisma db pull` against each database environment, by saving the results to their own separate files using the `--schema` option. [See reference](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#arguments-1)\n\nThen you can either manually inspect both files or use a `diff` tool in your IDE or in the terminal. If you see differences in constraint names, your production and local environments are out of sync and should be aligned.\n\nIn the following example, the `Post` model has a foreign key constraint with a custom name in production that does not match development.\n\n#### Development environment:[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints#development-environment \"Direct link to Development environment:\")\n\n```\nmodel Post {  id         Int    @id @default(autoincrement())  title      String  authorName String @default(\"Anonymous\")  author     User?  @relation(fields: [authorName], references: [name], map: \"Custom_Foreign_Key_Constraint\")}\n```\n\n#### Production environment:[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints#production-environment \"Direct link to Production environment:\")\n\n```\nmodel Post {  id         Int    @id @default(autoincrement())  title      String  authorName String @default(\"Anonymous\")  author     User?  @relation(fields: [authorName], references: [name], map: \"Custom_Production_Name\")}\n```\n\n### Aligning your environments if their constraint or index names differ[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints#aligning-your-environments-if-their-constraint-or-index-names-differ \"Direct link to Aligning your environments if their constraint or index names differ\")\n\nIf the names in your environments differ, the safest option is to align your development environment with the names in your production environment. This makes sure that no changes need to be performed on your production database.\n\nIn order to achieve this:\n\n*   Run `prisma db pull` against your production environment to pull in the constraint and index names\n*   Switch to development and run `prisma migrate dev` to create a new migration. You can call that migration `migration-to-sync-names`\n*   Switch to production, and run `prisma migrate resolve --applied migration-to-sync-names` to mark the migration as applied on production\n\nYour migration history now contains a migration to ensure that the names of any new environments you spin up contain the same names as your production database. And Prisma ORM knows not to apply this migration to production since you already marked it as applied.\n\nYour environments are now in sync and you can proceed to the [upgrade paths for migrate users](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-3/named-constraints#option-2-i-want-to-use-prisma-orms-default-constraint-and-index-names). These let you choose your future naming scheme.",
    "title": "Named constraints upgrade path | Prisma Documentation",
    "description": "Guides on how to handle named constraints using Prisma Introspect or Prisma Migrate when upgrading to Prisma 3",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/soft-delete-middleware",
    "markdown": "# Middleware sample: soft delete (Reference)\n\nThe following sample uses [middleware](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware) to perform a **soft delete**. Soft delete means that a record is **marked as deleted** by changing a field like `deleted` to `true` rather than actually being removed from the database. Reasons to use a soft delete include:\n\n*   Regulatory requirements that mean you have to keep data for a certain amount of time\n*   'Trash' / 'bin' functionality that allows users to restore content that was deleted\n\nwarning\n\n**Note:** This page demonstrates a sample use of middleware. We do not intend the sample to be a fully functional soft delete feature and it does not cover all edge cases. For example, the middleware does not work with nested writes and therefore won't capture situations where you use `delete` or `deleteMany` as an option e.g. in an `update` query.\n\nThis sample uses the following schema - note the `deleted` field on the `Post` model:\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}generator client {  provider = \"prisma-client-js\"}model User {  id        Int     @id @default(autoincrement())  name      String?  email     String  @unique  posts     Post[]  followers User[]  @relation(\"UserToUser\")  user      User?   @relation(\"UserToUser\", fields: [userId], references: [id])  userId    Int?}model Post {  id      Int     @id @default(autoincrement())  title   String  content String?  user    User?   @relation(fields: [userId], references: [id])  userId  Int?  tags    Tag[]  views   Int     @default(0)  deleted Boolean @default(false)}model Category {  id             Int        @id @default(autoincrement())  parentCategory Category?  @relation(\"CategoryToCategory\", fields: [categoryId], references: [id])  category       Category[] @relation(\"CategoryToCategory\")  categoryId     Int?}model Tag {  tagName String @id // Must be unique  posts   Post[]}\n```\n\n## Step 1: Store status of record[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/soft-delete-middleware#step-1-store-status-of-record \"Direct link to Step 1: Store status of record\")\n\nAdd a field named `deleted` to the `Post` model. You can choose between two field types depending on your requirements:\n\n*   `Boolean` with a default value of `false`:\n    \n    ```\n    model Post {  id      Int     @id @default(autoincrement())  ...  deleted Boolean @default(false)}\n    ```\n    \n*   Create a nullable `DateTime` field so that you know exactly _when_ a record was marked as deleted - `NULL` indicates that a record has not been deleted. In some cases, storing when a record was removed may be a regulatory requirement:\n    \n    ```\n    model Post {  id      Int       @id @default(autoincrement())  ...  deleted DateTime?}\n    ```\n    \n\n> **Note**: Using two separate fields (`isDeleted` and `deletedDate`) may result in these two fields becoming out of sync - for example, a record may be marked as deleted but have no associated date.)\n\nThis sample uses a `Boolean` field type for simplicity.\n\n## Step 2: Soft delete middleware[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/soft-delete-middleware#step-2-soft-delete-middleware \"Direct link to Step 2: Soft delete middleware\")\n\nAdd a middleware that performs the following tasks:\n\n*   Intercepts `delete()` and `deleteMany()` queries for the `Post` model\n*   Changes the `params.action` to `update` and `updateMany` respectively\n*   Introduces a `data` argument and sets `{ deleted: true }`, preserving other filter arguments if they exist\n\nRun the following sample to test the soft delete middleware:\n\n```\nimport { PrismaClient } from '@prisma/client'const prisma = new PrismaClient({})async function main() {  /***********************************/  /* SOFT DELETE MIDDLEWARE */  /***********************************/  prisma.$use(async (params, next) => {    // Check incoming query type    if (params.model == 'Post') {      if (params.action == 'delete') {        // Delete queries        // Change action to an update        params.action = 'update'        params.args['data'] = { deleted: true }      }      if (params.action == 'deleteMany') {        // Delete many queries        params.action = 'updateMany'        if (params.args.data != undefined) {          params.args.data['deleted'] = true        } else {          params.args['data'] = { deleted: true }        }      }    }    return next(params)  })  /***********************************/  /* TEST */  /***********************************/  const titles = [    { title: 'How to create soft delete middleware' },    { title: 'How to install Prisma' },    { title: 'How to update a record' },  ]  console.log('\\u001b[1;34mSTARTING SOFT DELETE TEST \\u001b[0m')  console.log('\\u001b[1;34m#################################### \\u001b[0m')  let i = 0  let posts = new Array()  // Create 3 new posts with a randomly assigned title each time  for (i == 0; i < 3; i++) {    const createPostOperation = prisma.post.create({      data: titles[Math.floor(Math.random() * titles.length)],    })    posts.push(createPostOperation)  }  var postsCreated = await prisma.$transaction(posts)  console.log(    'Posts created with IDs: ' +      '\\u001b[1;32m' +      postsCreated.map((x) => x.id) +      '\\u001b[0m'  )  // Delete the first post from the array  const deletePost = await prisma.post.delete({    where: {      id: postsCreated[0].id, // Random ID    },  })  // Delete the 2nd two posts  const deleteManyPosts = await prisma.post.deleteMany({    where: {      id: {        in: [postsCreated[1].id, postsCreated[2].id],      },    },  })  const getPosts = await prisma.post.findMany({    where: {      id: {        in: postsCreated.map((x) => x.id),      },    },  })  console.log()  console.log(    'Deleted post with ID: ' + '\\u001b[1;32m' + deletePost.id + '\\u001b[0m'  )  console.log(    'Deleted posts with IDs: ' +      '\\u001b[1;32m' +      [postsCreated[1].id + ',' + postsCreated[2].id] +      '\\u001b[0m'  )  console.log()  console.log(    'Are the posts still available?: ' +      (getPosts.length == 3        ? '\\u001b[1;32m' + 'Yes!' + '\\u001b[0m'        : '\\u001b[1;31m' + 'No!' + '\\u001b[0m')  )  console.log()  console.log('\\u001b[1;34m#################################### \\u001b[0m')  // 4. Count ALL posts  const f = await prisma.post.findMany({})  console.log('Number of posts: ' + '\\u001b[1;32m' + f.length + '\\u001b[0m')  // 5. Count DELETED posts  const r = await prisma.post.findMany({    where: {      deleted: true,    },  })  console.log(    'Number of SOFT deleted posts: ' + '\\u001b[1;32m' + r.length + '\\u001b[0m'  )}main()\n```\n\nThe sample outputs the following:\n\n```\nSTARTING SOFT DELETE TEST####################################Posts created with IDs: 587,588,589Deleted post with ID: 587Deleted posts with IDs: 588,589Are the posts still available?: Yes!####################################\n```\n\ntip\n\nComment out the middleware to see the message change.\n\n✔ Pros of this approach to soft delete include:\n\n*   Soft delete happens at data access level, which means that you cannot delete records unless you use raw SQL\n\n✘ Cons of this approach to soft delete include:\n\n*   Content can still be read and updated unless you explicitly filter by `where: { deleted: false }` - in a large project with a lot of queries, there is a risk that soft deleted content will still be displayed\n*   You can still use raw SQL to delete records\n\ntip\n\nYou can create rules or triggers ([MySQL](https://dev.mysql.com/doc/refman/8.0/en/trigger-syntax.html) and [PostgreSQL](https://www.postgresql.org/docs/8.1/rules-update.html)) at a database level to prevent records from being deleted.\n\n## Step 3: Optionally prevent read/update of soft deleted records[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/soft-delete-middleware#step-3-optionally-prevent-readupdate-of-soft-deleted-records \"Direct link to Step 3: Optionally prevent read/update of soft deleted records\")\n\nIn step 2, we implemented middleware that prevents `Post` records from being deleted. However, you can still read and update deleted records. This step explores two ways to prevent the reading and updating of deleted records.\n\n> **Note**: These options are just ideas with pros and cons, you may choose to do something entirely different.\n\n### Option 1: Implement filters in your own application code[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/soft-delete-middleware#option-1-implement-filters-in-your-own-application-code \"Direct link to Option 1: Implement filters in your own application code\")\n\nIn this option:\n\n*   Prisma Client middleware is responsible for preventing records from being deleted\n*   Your own application code (which could be a GraphQL API, a REST API, a module) is responsible for filtering out deleted posts where necessary (`{ where: { deleted: false } }`) when reading and updating data - for example, the `getPost` GraphQL resolver never returns a deleted post\n\n✔ Pros of this approach to soft delete include:\n\n*   No change to Prisma Client's create/update queries - you can easily request deleted records if you need them\n*   Modifying queries in middleware can have some unintended consequences, such as changing query return types (see option 2)\n\n✘ Cons of this approach to soft delete include:\n\n*   Logic relating to soft delete maintained in two different places\n*   If your API surface is very large and maintained by multiple contributors, it may be difficult to enforce certain business rules (for example, never allow deleted records to be updated)\n\n### Option 2: Use middleware to determine the behavior of read/update queries for deleted records[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/soft-delete-middleware#option-2-use-middleware-to-determine-the-behavior-of-readupdate-queries-for-deleted-records \"Direct link to Option 2: Use middleware to determine the behavior of read/update queries for deleted records\")\n\nOption two uses Prisma Client middleware to prevent soft deleted records from being returned. The following table describes how the middleware affects each query:\n\n| **Query** | **Middleware logic** | **Changes to return type** |\n| --- | --- | --- |\n| `findUnique()` | 🔧 Change query to `findFirst` (because you cannot apply `deleted: false` filters to `findUnique()`)  <br>🔧 Add `where: { deleted: false }` filter to exclude soft deleted posts  <br>🔧 From version 5.0.0, you can use `findUnique()` to apply `delete: false` filters since [non unique fields are exposed](https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-on-non-unique-fields-with-userwhereuniqueinput). | No change |\n| `findMany` | 🔧 Add `where: { deleted: false }` filter to exclude soft deleted posts by default  <br>🔧 Allow developers to **explicitly request** soft deleted posts by specifying `deleted: true` | No change |\n| `update` | 🔧 Change query to `updateMany` (because you cannot apply `deleted: false` filters to `update`)  <br>🔧 Add `where: { deleted: false }` filter to exclude soft deleted posts | `{ count: n }` instead of `Post` |\n| `updateMany` | 🔧 Add `where: { deleted: false }` filter to exclude soft deleted posts | No change |\n\n*   **Is it not possible to utilize soft delete with `findFirstOrThrow()` or `findUniqueOrThrow()`?**  \n    From version [5.1.0](https://github.com/prisma/prisma/releases/5.1.0), you can apply soft delete `findFirstOrThrow()` or `findUniqueOrThrow()` by using middleware.\n*   **Why are you making it possible to use `findMany()` with a `{ where: { deleted: true } }` filter, but not `updateMany()`?**  \n    This particular sample was written to support the scenario where a user can _restore_ their deleted blog post (which requires a list of soft deleted posts) - but the user should not be able to edit a deleted post.\n*   **Can I still `connect` or `connectOrCreate` a deleted post?**  \n    In this sample - yes. The middleware does not prevent you from connecting an existing, soft deleted post to a user.\n\nRun the following sample to see how middleware affects each query:\n\n```\nimport { PrismaClient, Prisma } from '@prisma/client'const prisma = new PrismaClient({})async function main() {  /***********************************/  /* SOFT DELETE MIDDLEWARE */  /***********************************/  prisma.$use(async (params, next) => {    if (params.model == 'Post') {      if (params.action === 'findUnique' || params.action === 'findFirst') {        // Change to findFirst - you cannot filter        // by anything except ID / unique with findUnique()        params.action = 'findFirst'        // Add 'deleted' filter        // ID filter maintained        params.args.where['deleted'] = false      }      if (        params.action === 'findFirstOrThrow' ||        params.action === 'findUniqueOrThrow'      ) {        if (params.args.where) {          if (params.args.where.deleted == undefined) {            // Exclude deleted records if they have not been explicitly requested            params.args.where['deleted'] = false          }        } else {          params.args['where'] = { deleted: false }        }      }      if (params.action === 'findMany') {        // Find many queries        if (params.args.where) {          if (params.args.where.deleted == undefined) {            params.args.where['deleted'] = false          }        } else {          params.args['where'] = { deleted: false }        }      }    }    return next(params)  })  prisma.$use(async (params, next) => {    if (params.model == 'Post') {      if (params.action == 'update') {        // Change to updateMany - you cannot filter        // by anything except ID / unique with findUnique()        params.action = 'updateMany'        // Add 'deleted' filter        // ID filter maintained        params.args.where['deleted'] = false      }      if (params.action == 'updateMany') {        if (params.args.where != undefined) {          params.args.where['deleted'] = false        } else {          params.args['where'] = { deleted: false }        }      }    }    return next(params)  })  prisma.$use(async (params, next) => {    // Check incoming query type    if (params.model == 'Post') {      if (params.action == 'delete') {        // Delete queries        // Change action to an update        params.action = 'update'        params.args['data'] = { deleted: true }      }      if (params.action == 'deleteMany') {        // Delete many queries        params.action = 'updateMany'        if (params.args.data != undefined) {          params.args.data['deleted'] = true        } else {          params.args['data'] = { deleted: true }        }      }    }    return next(params)  })  /***********************************/  /* TEST */  /***********************************/  const titles = [    { title: 'How to create soft delete middleware' },    { title: 'How to install Prisma' },    { title: 'How to update a record' },  ]  console.log('\\u001b[1;34mSTARTING SOFT DELETE TEST \\u001b[0m')  console.log('\\u001b[1;34m#################################### \\u001b[0m')  let i = 0  let posts = new Array()  // Create 3 new posts with a randomly assigned title each time  for (i == 0; i < 3; i++) {    const createPostOperation = prisma.post.create({      data: titles[Math.floor(Math.random() * titles.length)],    })    posts.push(createPostOperation)  }  var postsCreated = await prisma.$transaction(posts)  console.log(    'Posts created with IDs: ' +      '\\u001b[1;32m' +      postsCreated.map((x) => x.id) +      '\\u001b[0m'  )  // Delete the first post from the array  const deletePost = await prisma.post.delete({    where: {      id: postsCreated[0].id, // Random ID    },  })  // Delete the 2nd two posts  const deleteManyPosts = await prisma.post.deleteMany({    where: {      id: {        in: [postsCreated[1].id, postsCreated[2].id],      },    },  })  const getOnePost = await prisma.post.findUnique({    where: {      id: postsCreated[0].id,    },  })  const getOneUniquePostOrThrow = async () =>    await prisma.post.findUniqueOrThrow({      where: {        id: postsCreated[0].id,      },    })  const getOneFirstPostOrThrow = async () =>    await prisma.post.findFirstOrThrow({      where: {        id: postsCreated[0].id,      },    })  const getPosts = await prisma.post.findMany({    where: {      id: {        in: postsCreated.map((x) => x.id),      },    },  })  const getPostsAnDeletedPosts = await prisma.post.findMany({    where: {      id: {        in: postsCreated.map((x) => x.id),      },      deleted: true,    },  })  const updatePost = await prisma.post.update({    where: {      id: postsCreated[1].id,    },    data: {      title: 'This is an updated title (update)',    },  })  const updateManyDeletedPosts = await prisma.post.updateMany({    where: {      deleted: true,      id: {        in: postsCreated.map((x) => x.id),      },    },    data: {      title: 'This is an updated title (updateMany)',    },  })  console.log()  console.log(    'Deleted post (delete) with ID: ' +      '\\u001b[1;32m' +      deletePost.id +      '\\u001b[0m'  )  console.log(    'Deleted posts (deleteMany) with IDs: ' +      '\\u001b[1;32m' +      [postsCreated[1].id + ',' + postsCreated[2].id] +      '\\u001b[0m'  )  console.log()  console.log(    'findUnique: ' +      (getOnePost?.id != undefined        ? '\\u001b[1;32m' + 'Posts returned!' + '\\u001b[0m'        : '\\u001b[1;31m' +          'Post not returned!' +          '(Value is: ' +          JSON.stringify(getOnePost) +          ')' +          '\\u001b[0m')  )  try {    console.log('findUniqueOrThrow: ')    await getOneUniquePostOrThrow()  } catch (error) {    if (      error instanceof Prisma.PrismaClientKnownRequestError &&      error.code == 'P2025'    )      console.log(        '\\u001b[1;31m' +          'PrismaClientKnownRequestError is catched' +          '(Error name: ' +          error.name +          ')' +          '\\u001b[0m'      )  }  try {    console.log('findFirstOrThrow: ')    await getOneFirstPostOrThrow()  } catch (error) {    if (      error instanceof Prisma.PrismaClientKnownRequestError &&      error.code == 'P2025'    )      console.log(        '\\u001b[1;31m' +          'PrismaClientKnownRequestError is catched' +          '(Error name: ' +          error.name +          ')' +          '\\u001b[0m'      )  }  console.log()  console.log(    'findMany: ' +      (getPosts.length == 3        ? '\\u001b[1;32m' + 'Posts returned!' + '\\u001b[0m'        : '\\u001b[1;31m' + 'Posts not returned!' + '\\u001b[0m')  )  console.log(    'findMany ( delete: true ): ' +      (getPostsAnDeletedPosts.length == 3        ? '\\u001b[1;32m' + 'Posts returned!' + '\\u001b[0m'        : '\\u001b[1;31m' + 'Posts not returned!' + '\\u001b[0m')  )  console.log()  console.log(    'update: ' +      (updatePost.id != undefined        ? '\\u001b[1;32m' + 'Post updated!' + '\\u001b[0m'        : '\\u001b[1;31m' +          'Post not updated!' +          '(Value is: ' +          JSON.stringify(updatePost) +          ')' +          '\\u001b[0m')  )  console.log(    'updateMany ( delete: true ): ' +      (updateManyDeletedPosts.count == 3        ? '\\u001b[1;32m' + 'Posts updated!' + '\\u001b[0m'        : '\\u001b[1;31m' + 'Posts not updated!' + '\\u001b[0m')  )  console.log()  console.log('\\u001b[1;34m#################################### \\u001b[0m')  // 4. Count ALL posts  const f = await prisma.post.findMany({})  console.log(    'Number of active posts: ' + '\\u001b[1;32m' + f.length + '\\u001b[0m'  )  // 5. Count DELETED posts  const r = await prisma.post.findMany({    where: {      deleted: true,    },  })  console.log(    'Number of SOFT deleted posts: ' + '\\u001b[1;32m' + r.length + '\\u001b[0m'  )}main()\n```\n\nThe sample outputs the following:\n\n```\nSTARTING SOFT DELETE TEST####################################Posts created with IDs: 680,681,682Deleted post (delete) with ID: 680Deleted posts (deleteMany) with IDs: 681,682findUnique: Post not returned!(Value is: [])findMany: Posts not returned!findMany ( delete: true ): Posts returned!update: Post not updated!(Value is: {\"count\":0})updateMany ( delete: true ): Posts not updated!####################################Number of active posts: 0Number of SOFT deleted posts: 95\n```\n\n✔ Pros of this approach:\n\n*   A developer can make a conscious choice to include deleted records in `findMany`\n*   You cannot accidentally read or update a deleted record\n\n✖ Cons of this approach:\n\n*   Not obvious from API that you aren't getting all records and that `{ where: { deleted: false } }` is part of the default query\n*   Return type `update` affected because middleware changes the query to `updateMany`\n*   Doesn't handle complex queries with `AND`, `OR`, `every`, etc...\n*   Doesn't handle filtering when using `include` from another model.\n\n## FAQ[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/soft-delete-middleware#faq \"Direct link to FAQ\")\n\n### Can I add a global `includeDeleted` to the `Post` model?[​](https://www.prisma.io/docs/orm/prisma-client/client-extensions/middleware/soft-delete-middleware#can-i-add-a-global-includedeleted-to-the-post-model \"Direct link to can-i-add-a-global-includedeleted-to-the-post-model\")\n\nYou may be tempted to 'hack' your API by adding a `includeDeleted` property to the `Post` model and make the following query possible:\n\n```\nprisma.post.findMany({ where: { includeDeleted: true } })\n```\n\n> **Note**: You would still need to write middleware.\n\nWe **✘ do not** recommend this approach as it pollutes the schema with fields that do not represent real data.",
    "title": "Middleware sample: soft delete (Reference) | Prisma Documentation",
    "description": "How to use middleware to intercept deletes and set a field value instead of deleting the record.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/autocompletion-in-graphql-resolvers-with-js",
    "markdown": "# Autocompletion in GraphQL resolvers with JavaScript\n\n## Problem[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/autocompletion-in-graphql-resolvers-with-js#problem \"Direct link to Problem\")\n\nWhen using GraphQL with TypeScript, you always get autocompletion for the Prisma Client instance in your GraphQL resolvers because then the `context` object can be typed – no matter if folks are using Nexus, TypeGraphQL or SDL first. This immensely helps with autocompletion and preventing unwanted errors.\n\nUnfortunately, this needs a little more effort when you're working in plain JavaScript. Suppose we have a resolver like this:\n\n```\nfilterPosts: (parent, args, ctx) => {  return ctx.prisma.post.findMany({    where: {      OR: [        { title: { contains: args.searchString } },        { content: { contains: args.searchString } },      ],    },  })}\n```\n\nNow whenever you type `ctx.` VS Code will provide unnecessary options in the autocomplete which is undesirable.\n\n![Unwanted autocomplete values by VSCode](https://www.prisma.io/docs/assets/images/unwanted-autocomplete-values-in-vscode-16eea2661f374c7fd9eb713d6215a56b.png)\n\nVS Code doesn't know the _type_ of the `context` object so it can't provide any intellisense for it, which is why unwanted suggestions are displayed.\n\n## Solution[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/autocompletion-in-graphql-resolvers-with-js#solution \"Direct link to Solution\")\n\nTo overcome this, you need to add a [JSDoc](https://jsdoc.app/) comment named `typedef` to \"import\" the correct type of your `PrismaClient` instance.\n\n```\n// Add this to the top of the file/** * @typedef { import(\"@prisma/client\").PrismaClient } Prisma */\n```\n\n> **Note**: You can learn more about JSDoc [here](https://devhints.io/jsdoc).\n\nFinally, you need to type your resolver arguments. For simplicity, ignore the `parent` and `args` parameters. So the resolver should now look like this:\n\n```\n/** * @param {any} parent * @param {{ searchString: string }} args * @param {{ prisma: Prisma }} ctx */filterPosts: (parent, args, ctx) => {  return ctx.prisma.post.findMany({    where: {      OR: [        { title: { contains: args.searchString } },        { content: { contains: args.searchString } },      ],    },  })}\n```\n\nThis will tell VS Code that the `context` has a property named `prisma` and the type is `Prisma` which was defined in the `@typedef` above.\n\nAnd voilà, autocompletion in plain JavaScript.\n\n![The correct parameters for context are obtained](https://www.prisma.io/docs/assets/images/prisma-autocompletion-in-js-183564820ca270ae98fa8defcb6b92d9.png)\n\nThe final file should look something like:\n\n```\n/** * @typedef { import(\"@prisma/client\").PrismaClient } Prisma * @typedef { import(\"@prisma/client\").UserCreateArgs } UserCreateArgs */const { makeExecutableSchema } = require('graphql-tools')const typeDefs = `type User {  email: String!  id: ID!  name: String  posts: [Post!]!}type Post {  author: User  content: String  id: ID!  published: Boolean!  title: String!}type Query {  feed: [Post!]!  filterPosts(searchString: String): [Post!]!  post(where: PostWhereUniqueInput!): Post}type Mutation {  createDraft(authorEmail: String, content: String, title: String!): Post!  deleteOnePost(where: PostWhereUniqueInput!): Post  publish(id: ID): Post  signupUser(data: UserCreateInput!): User!}input PostWhereUniqueInput {  id: ID}input UserCreateInput {  email: String!  id: ID  name: String  posts: PostCreateManyWithoutPostsInput}input PostCreateManyWithoutPostsInput {  connect: [PostWhereUniqueInput!]  create: [PostCreateWithoutAuthorInput!]}input PostCreateWithoutAuthorInput {  content: String  id: ID  published: Boolean  title: String!}`const resolvers = {  Query: {    /**     * @param {any} parent     * @param {any} args     * @param {{ prisma: Prisma }} ctx     */    feed: (parent, args, ctx) => {      return ctx.prisma.post.findMany({        where: { published: true },      })    },    /**     * @param {any} parent     * @param {{ searchString: string }} args     * @param {{ prisma: Prisma }} ctx     */    filterPosts: (parent, args, ctx) => {      return ctx.prisma.post.findMany({        where: {          OR: [            { title: { contains: args.searchString } },            { content: { contains: args.searchString } },          ],        },      })    },    /**     * @param {any} parent     * @param {{ where: { id: string }}} args     * @param {{ prisma: Prisma }} ctx     */    post: (parent, args, ctx) => {      return ctx.prisma.post.findUnique({        where: { id: Number(args.where.id) },      })    },  },  Mutation: {    /**     * @param {any} parent     * @param {{ title: string, content: string, authorEmail: (string|undefined) }} args     * @param {{ prisma: Prisma }} ctx     */    createDraft: (parent, args, ctx) => {      return ctx.prisma.post.create({        data: {          title: args.title,          content: args.content,          published: false,          author: args.authorEmail && {            connect: { email: args.authorEmail },          },        },      })    },    /**     * @param {any} parent     * @param {{ where: { id: string }}} args     * @param {{ prisma: Prisma }} ctx     */    deleteOnePost: (parent, args, ctx) => {      return ctx.prisma.post.delete({        where: { id: Number(args.where.id) },      })    },    /**     * @param {any} parent     * @param {{ id: string }} args     * @param {{ prisma: Prisma }} ctx     */    publish: (parent, args, ctx) => {      return ctx.prisma.post.update({        where: { id: Number(args.id) },        data: { published: true },      })    },    /**     * @param {any} parent     * @param {UserCreateArgs} args     * @param {{ prisma: Prisma }} ctx     */    signupUser: (parent, args, ctx) => {      return ctx.prisma.user.create(args)    },  },  User: {    /**     * @param {{ id: number }} parent     * @param {any} args     * @param {{ prisma: Prisma }} ctx     */    posts: (parent, args, ctx) => {      return ctx.prisma.user        .findUnique({          where: { id: parent.id },        })        .posts()    },  },  Post: {    /**     * @param {{ id: number }} parent     * @param {any} args     * @param {{ prisma: Prisma }} ctx     */    author: (parent, args, ctx) => {      return ctx.prisma.post        .findUnique({          where: { id: parent.id },        })        .author()    },  },}const schema = makeExecutableSchema({  resolvers,  typeDefs,})module.exports = {  schema,}\n```\n\nSo here's a simple method to get autocompletion for your all Prisma Client's methods in JavaScript. You can find a practical example of this approach in the [`prisma-examples`](https://github.com/prisma/prisma-examples/) repo [here](https://github.com/prisma/prisma-examples/tree/latest/javascript/graphql-sdl-first).",
    "title": "Autocompletion in GraphQL resolvers with JavaScript | Prisma Documentation",
    "description": "Learn how you can get autocompletion for Prisma Client queries in GraphQL resolvers with plain JavaScript",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/working-with-many-to-many-relations",
    "markdown": "# Modeling and querying many-to-many relations\n\n## Problem[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/working-with-many-to-many-relations#problem \"Direct link to Problem\")\n\nModeling and querying many-to-many relations in relational databases can be challenging. This article shows two examples how this can be approached with Prisma ORM. The first example uses an [implicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#implicit-many-to-many-relations) and the second one uses an [explicit](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#explicit-many-to-many-relations) many-to-many relation.\n\n## Solution[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/working-with-many-to-many-relations#solution \"Direct link to Solution\")\n\n### Implicit relations[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/working-with-many-to-many-relations#implicit-relations \"Direct link to Implicit relations\")\n\nThis is a type of many-to-many relation where Prisma ORM handles the [relation table](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations#relation-tables) internally. A basic example for an implicit many-to-many relation would look like this:\n\n```\nmodel Post {  id    Int    @id @default(autoincrement())  title String  tags  Tag[]}model Tag {  id    Int    @id @default(autoincrement())  name  String @unique  posts Post[]}\n```\n\nTo create a post and its tags, one can write this with Prisma Client:\n\n```\nawait prisma.post.create({  data: {    title: 'Types of relations',    tags: { create: [{ name: 'dev' }, { name: 'prisma' }] },  },})\n```\n\nIn the above example, we can directly query for posts along with their tags as follows:\n\n```\nawait prisma.post.findMany({  include: { tags: true },})\n```\n\nAnd the response obtained would be:\n\n```\n[  {    \"id\": 1,    \"title\": \"Types of relations\",    \"tags\": [      {        \"id\": 1,        \"name\": \"dev\"      },      {        \"id\": 2,        \"name\": \"prisma\"      }    ]  }]\n```\n\nAnother use case for this is if you want to add new tags as well as connect to existing tags to a post. An example for this is where a user has created new tags for their post and has also selected existing tags to be added as well. In this case, we can perform this in the following way:\n\n```\nawait prisma.post.update({  where: { id: 1 },  data: {    title: 'Prisma is awesome!',    tags: { set: [{ id: 1 }, { id: 2 }], create: { name: 'typescript' } },  },})\n```\n\n### Explicit relations[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/working-with-many-to-many-relations#explicit-relations \"Direct link to Explicit relations\")\n\nExplicit relations mostly need to be created in cases where you need to store extra fields in the relation table or if you're [introspecting](https://www.prisma.io/docs/orm/prisma-schema/introspection) an existing database that already has many-to-many relations setup. This is the same schema used above but with an explicit relation table:\n\n```\nmodel Post {  id    Int        @id @default(autoincrement())  title String  tags  PostTags[]}model PostTags {  id     Int   @id @default(autoincrement())  post   Post? @relation(fields: [postId], references: [id])  tag    Tag?  @relation(fields: [tagId], references: [id])  postId Int?  tagId  Int?  @@index([postId, tagId])}model Tag {  id    Int        @id @default(autoincrement())  name  String     @unique  posts PostTags[]}\n```\n\nAdding tags to a post would be a create into the relation table (`PostTags`) as well as into the tags table (`Tag`):\n\n```\nawait prisma.post.create({  data: {    title: 'Types of relations',    tags: {      create: [        { tag: { create: { name: 'dev' } } },        { tag: { create: { name: 'prisma' } } },      ],    },  },})\n```\n\nAlso querying for posts along with their tags would require an extra `include` as follows:\n\n```\nawait prisma.post.findMany({  include: { tags: { include: { tag: true } } },})\n```\n\nThis will provide the following output:\n\n```\n[  {    \"id\": 1,    \"title\": \"Types of relations\",    \"tags\": [      {        \"id\": 1,        \"postId\": 1,        \"tagId\": 1,        \"tag\": {          \"id\": 1,          \"name\": \"prisma\"        }      },      {        \"id\": 2,        \"postId\": 1,        \"tagId\": 2,        \"tag\": {          \"id\": 2,          \"name\": \"dev\"        }      }    ]  }]\n```\n\nSometimes, it's not ideal to show the data for the relation table in your UI. In this case, it's best to map the data after fetching it on the server itself and sending that response to the frontend.\n\n```\nconst result = posts.map((post) => {  return { ...post, tags: post.tags.map((tag) => tag.tag) }})\n```\n\nThis will provide an output similar to the one you received with implicit relations.\n\n```\n[  {    \"id\": 1,    \"title\": \"Types of relations\",    \"tags\": [      {        \"id\": 1,        \"name\": \"prisma\"      },      {        \"id\": 2,        \"name\": \"dev\"      }    ]  }]\n```\n\nThis article showed how you can implement implicit and explicit many-to-many relations and query them using Prisma Client.",
    "title": "Modeling and querying many-to-many relations | Prisma Documentation",
    "description": "Learn how you can model and query implicit and explicit many-to-many relations with Prisma ORM",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dev-practices",
    "markdown": "# Best practice for instantiating Prisma Client with Next.js\n\ntip\n\nIf you want to learn how to build an app with Next.js and Prisma ORM, check out this comprehensive [video tutorial](https://www.youtube.com/watch?v=QXxy8Uv1LnQ&ab_channel=ByteGrad).\n\n## Problem[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dev-practices#problem \"Direct link to Problem\")\n\nMany users have come across this warning while working with [Next.js](https://nextjs.org/) in development:\n\n```\nwarn(prisma-client) There are already 10 instances of Prisma Client actively running.\n```\n\nThere's a related [discussion](https://github.com/prisma/prisma/discussions/4399) and [issue](https://github.com/prisma/prisma/issues/5103) for the same.\n\nIn development, the command `next dev` clears Node.js cache on run. This in turn initializes a new `PrismaClient` instance each time due to hot reloading that creates a connection to the database. This can quickly exhaust the database connections as each `PrismaClient` instance holds its own connection pool.\n\n## Solution[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dev-practices#solution \"Direct link to Solution\")\n\nThe solution in this case is to instantiate a single instance `PrismaClient` and save it on the [`globalThis`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis) object. Then we keep a check to only instantiate `PrismaClient` if it's not on the `globalThis` object otherwise use the same instance again if already present to prevent instantiating extra `PrismaClient` instances.\n\ndb.ts\n\n```\nimport { PrismaClient } from '@prisma/client'const prismaClientSingleton = () => {  return new PrismaClient()}declare const globalThis: {  prismaGlobal: ReturnType<typeof prismaClientSingleton>;} & typeof global;const prisma = globalThis.prismaGlobal ?? prismaClientSingleton()export default prismaif (process.env.NODE_ENV !== 'production') globalThis.prismaGlobal = prisma\n```\n\nYou can extend Prisma Client using a Prisma Client extension by appending the `$extends` client method when instantiating Prisma Client as follows:\n\n```\nimport { PrismaClient } from '@prisma/client'const prismaClientSingleton = () => {  return new PrismaClient().$extends({    result: {      user: {        fullName: {          needs: { firstName: true, lastName: true },          compute(user) {            return `${user.firstName} ${user.lastName}`          },        },      },    },  })}\n```\n\nAfter creating this file, you can now import the extended `PrismaClient` instance anywhere in your Next.js `pages` as follows:\n\n```\n// e.g. in `pages/index.tsx`import prisma from './db'export const getServerSideProps = async () => {  const posts = await prisma.post.findMany()  return { props: { posts } }}\n```",
    "title": "Best practice for instantiating Prisma Client with Next.js | Prisma Documentation",
    "description": "Best practice for instantiating Prisma Client with Next.js",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dynamic",
    "markdown": "# Best practices for using Prisma Client with Next.js and Next.js Data Cache\n\nWhen deploying a Next.js app, you may run into an issue where your queries are not updating or displaying the correct content. Or, you may find that it takes a long time for newly created objects to show up in your queries.\n\nIn these cases, you are most likely seeing data persisted in the [Next.js Data Cache](https://nextjs.org/docs/app/building-your-application/caching#data-cache). Any `fetch` request has its result cached by default, leading to possibly unwanted results as Prisma uses `fetch` internally.\n\nTo opt-out of the Next.js Data Cache, you can [disable caching for a specific route](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamic) using the `\"force-dynamic\"` config option so that up to date data is always returned and no caching happens.\n\n```\nimport { NextRequest, NextResponse } from 'next/server'import prisma from './db'export const dynamic = 'force-dynamic'export async function GET(request: NextRequest, response: NextResponse) {  // your code would go here}\n```",
    "title": "Best practices for using Prisma Client with Next.js and Next.js Data Cache | Prisma Documentation",
    "description": "Learn best practices to avoid issues with route caching in Next.js",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/pkg-issue",
    "markdown": "# Solve ENOENT package error with vercel/pkg\n\nIf you use [vercel/pkg](https://github.com/vercel/pkg) to package your Node.js project, then you might encounter an `ENOENT` error like the following:\n\n```\nspawn /snapshot/enoent-problem/node_modules/.prisma/client/query-engine-debian-openssl-1.1.x ENOENT\n```\n\nTo avoid this error, add your Prisma query engine binary path to the `pkg/assets` section of your `package.json` file, as follows:",
    "title": "Solve ENOENT package error with vercel/pkg | Prisma Documentation",
    "description": "Solve ENOENT package error with vercel/pkg",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints",
    "markdown": "# Data validation with CHECK constraints (PostgreSQL)\n\n## Overview[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints#overview \"Direct link to Overview\")\n\nThis page explains how to configure [check constraints](https://www.postgresql.org/docs/9.4/ddl-constraints.html#DDL-CONSTRAINTS-CHECK-CONSTRAINTS) in a PostgreSQL database. A check constraint is a condition that must be satisfied before a value can be saved to a table - for example, the discounted price of a product must always be less than the original price.\n\nCheck constraints can be added when you create the table (using `CREATE TABLE`) or to a table that already exists (using `ALTER TABLE`). This guide covers all four combinations.\n\nAt the end of the guide, you'll introspect your database, generate a Prisma Client, and write a simple Node.js script to validate the constraints.\n\n## Prerequisites[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints#prerequisites \"Direct link to Prerequisites\")\n\nIn order to follow this guide, you need:\n\n*   a [PostgreSQL](https://www.postgresql.org/) database server running\n*   the [`createdb`](https://www.postgresql.org/docs/9.1/app-createdb.html) command line utility\n*   the [`psql`](https://www.postgresql.org/docs/13/app-psql.html) command line client for PostgreSQL\n*   [Node.js](https://nodejs.org/) installed on your machine\n\n## 1\\. Create a new database and project directory[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints#1-create-a-new-database-and-project-directory \"Direct link to 1. Create a new database and project directory\")\n\nStart by creating a project directory for the files that you'll create throughout this guide. Open terminal or command line and run the following commands:\n\n```\nmkdir check-democd check-demo\n```\n\nNext, make sure that your PostgreSQL database server is running. Authenticate the default `postgres` user:\n\nUnix (bash):\n\nWindows (command line):\n\nThen execute the following command in your terminal to create a new database called `CheckDemo`:\n\nUnix (bash):\n\nWindows (command line):\n\n```\ncreate database CheckDemo;//delete-next-line\\connect CheckDemo\n```\n\n> _Tip_: Remember the trailing `;`! `postgres=#` `postgres-#`\n\nYou can validate that the database was created by running the `\\dt` command which lists all tables (_relations_) in your database (right now there are none):\n\nUnix (bash):\n\n```\npsql -d CheckDemo -c \"\\dt\"\n```\n\nWindows (command line):\n\n## 2\\. Adding a table with a single check constraint on a single column[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints#2-adding-a-table-with-a-single-check-constraint-on-a-single-column \"Direct link to 2. Adding a table with a single check constraint on a single column\")\n\nIn this section, you'll **create a new table with a single check constraint on a single column** in the `CheckDemo` database.\n\nCreate a new file named `single-column-check-constraint.sql` and add the following code to it:\n\n```\nCREATE TABLE \"public\".\"product\" (  price NUMERIC CONSTRAINT price_value_check CHECK (price > 0.01 AND price <> 1240.00));ALTER TABLE \"public\".\"product\"  ADD COLUMN \"productid\" serial,  ADD PRIMARY KEY (\"productid\");\n```\n\nNow run the SQL statement against your database to create a new table called `product`:\n\nUnix (bash):\n\n```\npsql CheckDemo < single-column-check-constraint.sql\n```\n\nWindows (command line):\n\n```\n\\i 'c:/checkdemo/single-column-check-constraint.sql'\n```\n\nCongratulations, you just created a table called `product` in the database. The table has one column called `price`, which has a single check constraint that ensures price of a product is:\n\n*   Never less than 0.01\n*   Never equal to 1240.00\n\nRun the following command to see the a list of check constraints that apply to the `product` table:\n\nYou will see the following output, which includes a list of all check constraints:\n\n```\nTable \"public.product\" Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description--------+---------+-----------+----------+---------+---------+--------------+------------- price  | numeric |           |          |         | main    |              |Check constraints:    \"price_value_check\" CHECK (price > 0.01 AND price <> 1240.00)\n```\n\nNote that PostgreSQL will auto-generate a constraint name if you do not provide one. For example, the constraint created by `price NUMERIC CHECK (price > 0.01 AND price <> 1240.00)` would be `price_check`.\n\n## 3\\. Adding a table with a multi-column check constraint[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints#3-adding-a-table-with-a-multi-column-check-constraint \"Direct link to 3. Adding a table with a multi-column check constraint\")\n\nNext, you'll **create a table with a multi-column check constraint** that compares the values of two columns.\n\nCreate a new file named `multi-column-check-constraint.sql` and add the following code to it:\n\n```\nCREATE TABLE \"public\".\"anotherproduct\" (  reducedprice NUMERIC CONSTRAINT reduced_price_check CHECK (price > reducedprice),  price NUMERIC);ALTER TABLE \"public\".\"anotherproduct\"  ADD COLUMN \"productid\" serial,  ADD PRIMARY KEY (\"productid\");\n```\n\nNow run the SQL statement against your database to create a new table called `anotherproduct`:\n\nUnix (bash):\n\n```\npsql CheckDemo < multi-column-check-constraint.sql\n```\n\nWindows (command line):\n\n```\n\\i 'c:/checkdemo/multi-column-check-constraint.sql'\n```\n\nCongratulations, you just created a table called `anotherproduct` in the database. The table has two columns called `reducedprice` and `price`. The `reducedprice` column has a check constraint that ensures that the value of `reducedprice` is always less than the value of `price`.\n\n## 4\\. Adding a table with multiple check constraints[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints#4-adding-a-table-with-multiple-check-constraints \"Direct link to 4. Adding a table with multiple check constraints\")\n\nNext, you'll **create a table with multiple check constraint** on different columns.\n\nCreate a new file named `multiple-check-constraints.sql` and add the following code to it:\n\n```\n  CREATE TABLE \"public\".\"secondtolastproduct\" (    reducedprice NUMERIC CONSTRAINT reduced_price_check CHECK (price > reducedprice),    price NUMERIC,    tags TEXT[] CONSTRAINT tags_contains_product CHECK ('product' = ANY(tags))  );ALTER TABLE \"public\".\"secondtolastproduct\"  ADD COLUMN \"productid\" serial,  ADD PRIMARY KEY (\"productid\");\n```\n\nNow run the SQL statement against your database to create a new table called `secondtolastproduct`:\n\nUnix (bash):\n\n```\npsql CheckDemo < multiple-check-constraints.sql\n```\n\nWindows (command line):\n\n```\n\\i 'c:/checkdemo/multiple-check-constraints.sql'\n```\n\nCongratulations, you just created a table called `lastproduct` in the database. The table has three columns named `reducedprice`, `price` and `tags`, and the following check constraints:\n\n*   The `tags` column (which is an array) must contain a tag named `product`\n*   The value of `reducedprice` must be less than the value of `price`\n\n## 5\\. Adding a check constraint to an existing table[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints#5-adding-a-check-constraint-to-an-existing-table \"Direct link to 5. Adding a check constraint to an existing table\")\n\nIn this section, you'll **add a check constraint to a table that already exists in your database**. To do so, you first need to create a new table and then alter the table to add the constraint.\n\nCreate a new file named `add-single-check-constraint-later.sql` and add the following code:\n\n```\nCREATE TABLE \"public\".\"lastproduct\" (  category TEXT);ALTER TABLE \"public\".\"lastproduct\"  ADD CONSTRAINT \"category_not_clothing\" CHECK (category <> 'clothing');\n```\n\nThis code contains two SQL statements:\n\n1.  Create a new table called `lastproduct`\n2.  Alter the table to add a check constraint named `price_not_zero_constraint`\n\nNow run the SQL statements against your database to create a new table called `lastproduct`:\n\nUnix (bash):\n\n```\npsql CheckDemo < add-single-check-constraint-later.sql\n```\n\nWindows (command line):\n\n```\n\\i 'c:/checkdemo/add-single-check-constraint-later.sql'\n```\n\nCongratulations, you just created a table called `lastproduct` in the database with a single column called `price`. You added constraint named `price_not_zero_constraint` to with a second SQL command, which ensures that the price of a product is never less than 0.01.\n\n## 6\\. Introspect your database with Prisma ORM[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints#6-introspect-your-database-with-prisma-orm \"Direct link to 6. Introspect your database with Prisma ORM\")\n\nIn the previous sections, you created four tables with different check constraints:\n\n*   The `product` table has a check constraint that ensures that the value of `price` is never less than `0.01` and never exactly `1240.00`.\n*   The `anotherproduct` table has a check constraint that ensures that the value of `reducedprice` is never greater than the value of `price`.\n*   The `secondtolastproduct` table has two check constraints - one that ensures that the value of `reducedprice` is never greater than the value of `price`, and one that ensures that the `tags` array always contains the value `product`.\n*   The `lastproduct` table has a check constraint that ensures that the value of `category` is never `clothing`.\n\nIn this section you'll introspect your database to generate the Prisma models for these tables.\n\n> **Note**: Check constraints are currently not included in the generated Prisma schema - however, the underlying database still enforces the constraints.\n\nTo start, set up a new Node.js project and add the `prisma` CLI as a development dependency:\n\n```\nnpm init -ynpm install prisma --save-dev\n```\n\nIn order to introspect your database, you need to tell Prisma ORM how to connect to it. You do so by configuring a `datasource` in your Prisma schema.\n\nCreate a new file named `schema.prisma` and add the following code to it:\n\nschema.prisma\n\n```\ndatasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}\n```\n\nThe database connection URL is set via an environment variable. The Prisma CLI automatically supports the [`dotenv`](https://github.com/motdotla/dotenv) format which automatically picks up environment variables defined in a file named `.env`.\n\nCreate a new file named `.env` and set your database connection URL as the `DATABASE_URL` environment variable:\n\n```\nDATABASE_URL=postgresql://__USER__:__PASSWORD__@__HOST__:__PORT__/CheckDemo\n```\n\nIn the above code snippet, you need to replace the uppercase placeholders with your own connection details. For example, if your database is running locally it could look like this:\n\n```\nDATABASE_URL=postgresql://janedoe:mypassword@localhost:5432/CheckDemo\n```\n\nWith both the `schema.prisma` and `.env` files in place, you can run Prisma ORM's introspection with the following command:\n\nThis command introspects your database and for each table adds a Prisma model to the Prisma schema:\n\nschema.prisma\n\n```\ngenerator client {  provider = \"prisma-client-js\"}datasource db {  provider = \"postgresql\"  url      = env(\"DATABASE_URL\")}model anotherproduct {  price        Float?  productid    Int    @id  reducedprice Float?}model lastproduct {  category  String?  productid Int     @id}model product {  price     Float?  productid Int    @id}model secondtolastproduct {  price        Float?  productid    Int      @id  reducedprice Float?  tags         String[]}\n```\n\n## 7\\. Generate Prisma Client[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints#7-generate-prisma-client \"Direct link to 7. Generate Prisma Client\")\n\nTo validate whether the check constraints work, you'll now generate Prisma Client and send a few sample queries to the database.\n\nFirst, add a `generator` block to your Prisma schema (typically added right below the `datasource` block):\n\nschema.prisma\n\n```\ngenerator client {  provider = \"prisma-client-js\"}\n```\n\nRun the following command to install and generate Prisma Client in your project:\n\nNow you can use Prisma Client to send database queries in Node.js.\n\n## 8\\. Validate the check constraints in a Node.js script[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/check-constraints#8-validate-the-check-constraints-in-a-nodejs-script \"Direct link to 8. Validate the check constraints in a Node.js script\")\n\nCreate a new file named `index.js` and add the following code to it:\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  const newProduct = await prisma.product.create({    data: {      price: 0.0,    },  })  console.log(newProduct)}main()\n```\n\nIn this code, you're creating a product with a price of `0.00`, which does not meet the check constraint configured for the `price` column.\n\nRun the code with this command:\n\nThe script throws an error indicating that the `price_check_value` check constraint was not met:\n\n```\nError occurred during query execution:ConnectorError(ConnectorError { user_facing_error: None, kind: QueryError(Error { kind: Db, cause: Some(DbError { severity: \"ERROR\", parsed_severity: Some(Error), code: SqlState(\"23514\"), message: \"new row for relation \\\"product\\\" violates check constraint \\\"price_value_check\\\"\", detail: Some(\"Failing row contains (0, 11).\"), hint: None, position: None, where_: None, schema: Some(\"public\"), table: Some(\"product\"), column: None, datatype: None, constraint: Some(\"price_value_check\"), file: Some(\"d:\\\\pginstaller_12.auto\\\\postgres.windows-x64\\\\src\\\\backend\\\\executor\\\\execmain.c\"), line: Some(2023), routine: Some(\"ExecConstraints\") }) }) })\n```\n\nTo validate the multi-column check constraint, replace the code in `index.js` with the following:\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  const newProduct = await prisma.anotherproduct.create({    data: {      price: 50.0,      reducedprice: 100.0,    },  })  console.log(newProduct)}main()\n```\n\nIn this code, you're creating a product where the reduced price is higher than the actual price.\n\nRun the script again with this command:\n\nThis time, you'll see a similar error message indicating the `reduce_price_check` check constraint was not met:\n\n```\nConnectorError(ConnectorError { user_facing_error: None, kind: QueryError(Error { kind: Db, cause: Some(DbError { severity: \"ERROR\", parsed_severity: Some(Error), code: SqlState(\"23514\"), message: \"new row for relation \\\"anotherproduct\\\" violates check constraint \\\"reduced_price_check\\\"\", detail: Some(\"Failing row contains (100, 50, 1).\"), hint: None, position: None, where_: None, schema: Some(\"public\"), table: Some(\"anotherproduct\"), column: None, datatype: None, constraint: Some(\"reduced_price_check\"), file: Some(\"d:\\\\pginstaller_12.auto\\\\postgres.windows-x64\\\\src\\\\backend\\\\executor\\\\execmain.c\"), line: Some(2023), routine: Some(\"ExecConstraints\") }) }) })    at PrismaClientFetcher.request (C:\\Work\\Personal\\prisma-check-constraint\\node_modules\\@prisma\\client\\index.js:89:17)\n```\n\nFinally, modify the script to include multiple check constraint violations:\n\n```\nconst { PrismaClient } = require('@prisma/client')const prisma = new PrismaClient()async function main() {  const newProduct = await prisma.secondtolastproduct.create({    data: {      tags: {        set: ['wrongtag'],      },      price: 90.0,      reducedprice: 100.0,    },  })  console.log(newProduct)}main()\n```\n\nIn this code, you're creating a product where the reduced price is higher than the actual price, and omitting the required `product` tag.\n\nRun the script again with this command:\n\nNotice that the error message only mentions the `reduced_price_check` constraint:\n\n```\nConnectorError(ConnectorError { user_facing_error: None, kind: QueryError(Error { kind: Db, cause: Some(DbError { severity: \"ERROR\", parsed_severity: Some(Error), code: SqlState(\"23514\"), message: \"new row for relation \\\"secondtolastproduct\\\" violates check constraint \\\"reduced_price_check\\\"\", detail: Some(\"Failing row contains (100, 90, {wrongtag}, 7).\"), hint: None, position: None, where_: None, schema: Some(\"public\"), table: Some(\"secondtolastproduct\"), column: None, datatype: None, constraint: Some(\"reduced_price_check\"), file: Some(\"d:\\\\pginstaller_12.auto\\\\postgres.windows-x64\\\\src\\\\backend\\\\executor\\\\execmain.c\"), line: Some(2023), routine: Some(\"ExecConstraints\") }) }) })\n```\n\nCheck constraints are resolved in alphabetical order, and only the first constraint to fail appears in the error message.",
    "title": "Data validation with CHECK constraints (PostgreSQL) | Prisma Documentation",
    "description": "Learn how to configure CHECK constraints for data validation with Prisma ORM and PostgreSQL by following the step-by-step instructions in this practical guide.",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/netlify-caching-issue",
    "markdown": "# Learn to configure your build process on Netlify to avoid caching-related problems\n\n## Netlify build dependency caching workaround\n\n## Problem[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/netlify-caching-issue#problem \"Direct link to Problem\")\n\nIf you deploy an application using Prisma ORM to [Netlify](https://www.netlify.com/), you may run into the following error message on deployment:\n\n```\nPrisma has detected that this project was built on Netlify, which caches dependencies.This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered.To fix this, make sure to run the \\`prisma generate\\` command during the build process.Learn how: https://pris.ly/d/netlify-build\n```\n\nThis occurs because Netlify caches the dependencies of your project until one of those dependencies changes. It does this to allow faster builds, and while this is typically a good thing, it causes some problems for Prisma Client.\n\nPrisma ORM uses a `postinstall` hook to generate Prisma Client when dependencies are installed. Because Netlify uses cached modules, this `postinstall` hook never gets run in subsequent deployments after the initial deployment. This results in Prisma Client becoming out of sync with your database schema.\n\nThis error message prevents this situation from happening and directs you here to learn how to fix the root issue.\n\nPrisma Client versions below 4.13.0\n\nOn Prisma Client versions lower than 4.13.0, you may encounter error messages that look like the following:\n\n```\n// 1: When adding a field:Unknown arg `name` in data.name for type UserCreateInput. Did you mean `nick`?// 2: When removing a field:Invalid `prisma.user.create()` invocation: The column `User.name` does not exist in the current database.// 3: When a model was removed/renamedInvalid `prisma.user.deleteMany()` invocation: The table `public.User` does not exist in the current database.// 4: When a model was addedCannot read properties of undefined (reading 'create')\n```\n\nThe solutions described in this guide are meant to solve these problems.\n\n## Solution[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/netlify-caching-issue#solution \"Direct link to Solution\")\n\nThis issue can be solved by explicitly generating Prisma Client on every deployment. Running `prisma generate` before each deployment will ensure Prisma Client is up-to-date.\n\nYou can configure the deployment to run this command in multiple different ways:\n\n### A custom `postinstall` script[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/netlify-caching-issue#a-custom-postinstall-script \"Direct link to a-custom-postinstall-script\")\n\ninfo\n\nThis is the preferred method as it is a universal solution.\n\nWithin the `scripts` section of your project's `package.json` file, if there is not already a script named `postinstall`, add one and add prisma generate\\` in that script:\n\n```\n{  ...  \"scripts\" {    \"postinstall\": \"prisma generate\"  }  ...}\n```\n\n### The application's `build` script in `package.json`[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/netlify-caching-issue#the-applications-build-script-in-packagejson \"Direct link to the-applications-build-script-in-packagejson\")\n\nWithin the `scripts` section of your project's `package.json` file, within the `build` script, prepend `prisma generate` to the existing build command:\n\n```\n{  ...  \"scripts\" {    \"build\": \"prisma generate && <actual-build-command>\"  }  ...}\n```\n\n### Netlify UI's build script field[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/netlify-caching-issue#netlify-uis-build-script-field \"Direct link to Netlify UI's build script field\")\n\nAnother way to configure `prisma generate` to be run on every deployment is to add the command to the build settings via Netlify's UI.\n\nWithin your project's dashboard, go to the **Site Settings** tab and find the **Build & deploy** section. In that section, enter the **Continuous deployment** subsection.\n\nFind the box in that section labeled **Build settings** and click the **Edit settings** button:\n\n![Netlify project dashboard&#39;s Build settings button](https://www.prisma.io/docs/assets/images/netlify-edit-settings-4279a444effcfe45cb3bc4f311b0885b.png)\n\nClicking that button will open a form with various fields. Find the **Build command** field and prepend `prisma generate` to the existing script:\n\n![Netlify project dashboard&#39;s Build command setting filled](https://www.prisma.io/docs/assets/images/netlify-build-command-filled-a0505aa3e20bc9c7b3243e31a5878c0e.png)",
    "title": "Learn to configure your build process on Netlify to avoid caching-related problems | Prisma Documentation",
    "description": "Learn to configure your build process on Netlify to avoid caching-related problems",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/vercel-caching-issue",
    "markdown": "# Learn to configure your build process on Vercel to avoid caching-related problems\n\n## Vercel build dependency caching workaround\n\n## Problem[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/vercel-caching-issue#problem \"Direct link to Problem\")\n\nIf you deploy an application using Prisma ORM to [Vercel](https://vercel.com/), you may run into the following error message on deployment:\n\n```\nPrisma has detected that this project was built on Vercel, which caches dependencies.This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered.To fix this, make sure to run the `prisma generate` command during the build process.Learn how: https://pris.ly/d/vercel-build\n```\n\nThis occurs because Vercel caches the dependencies of your project until one of those dependencies changes. It does this to allow faster builds, and while this is typically a good thing, it causes some problems for Prisma Client.\n\nPrisma ORM uses a `postinstall` hook to generate Prisma Client when dependencies are installed. Because Vercel uses cached modules, this `postinstall` hook never gets run in subsequent deployments after the initial deployment. This results in Prisma Client becoming out of sync with your database schema.\n\nThis error message prevents this situation from happening and directs you here to learn how to fix the root issue.\n\nPrisma Client versions below 4.13.0\n\nOn Prisma Client versions lower than 4.13.0, you may encounter error messages that look like the following:\n\n```\n// 1: When adding a field:Unknown arg `name` in data.name for type UserCreateInput. Did you mean `nick`?// 2: When removing a field:Invalid `prisma.user.create()` invocation: The column `User.name` does not exist in the current database.// 3: When a model was removed/renamedInvalid `prisma.user.deleteMany()` invocation: The table `public.User` does not exist in the current database.// 4: When a model was addedCannot read properties of undefined (reading 'create')\n```\n\nThe solutions described in this guide are meant to solve these problems.\n\n## Solution[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/vercel-caching-issue#solution \"Direct link to Solution\")\n\nThis issue can be solved by explicitly generating Prisma Client on every deployment. Running `prisma generate` before each deployment will ensure Prisma Client is up-to-date.\n\nYou can configure the deployment to run this command in multiple different ways:\n\n### A custom `postinstall` script[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/vercel-caching-issue#a-custom-postinstall-script \"Direct link to a-custom-postinstall-script\")\n\ninfo\n\nThis is the preferred method as it is a universal solution.\n\nWithin the `scripts` section of your project's `package.json` file, if there is not already a script named `postinstall`, add one and add `prisma generate` to that script:\n\n```\n{  ...  \"scripts\" {    \"postinstall\": \"prisma generate\"  }  ...}\n```\n\n### The application's `build` script in `package.json`[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/vercel-caching-issue#the-applications-build-script-in-packagejson \"Direct link to the-applications-build-script-in-packagejson\")\n\nWithin the `scripts` section of your project's `package.json` file, within the `build` script, prepend `prisma generate` to the default `vercel build` command:\n\n```\n{  ...  \"scripts\" {    \"build\": \"prisma generate && <actual-build-command>\"  }  ...}\n```\n\n### Vercel UI's build script field[​](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/vercel-caching-issue#vercel-uis-build-script-field \"Direct link to Vercel UI's build script field\")\n\nAnother way to configure `prisma generate` to be run on every deployment is to add the command to the build settings via Vercel's UI.\n\nWithin your project's dashboard, go to the **Settings** tab and find the **General** section. In that section you will find a box labeled **Build & Development Settings** that contains an input field named **Build Command**:\n\n![Vercel project dashboard&#39;s Build Command setting](https://www.prisma.io/docs/assets/images/vercel-ui-build-command-8a900021e6272c674563c8f244489d16.png)\n\nWithin that field, prepend `prisma generate` to the existing script:\n\n![Vercel project dashboard&#39;s Build Command setting filled](https://www.prisma.io/docs/assets/images/vercel-ui-build-command-filled-f9496740922d1c0486ca40e46ce7e94e.png)",
    "title": "Learn to configure your build process on Vercel to avoid caching-related problems | Prisma Documentation",
    "description": "Learn to configure your build process on Vercel to avoid caching-related problems",
    "languageCode": "en"
  },
  {
    "url": "https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade",
    "markdown": "# How to upgrade from Prisma 1 to Prisma ORM version 2.x and later\n\n## Overview[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#overview \"Direct link to Overview\")\n\nThis page helps you make an informed decision on when and how to upgrade from Prisma 1 to Prisma ORM version 2._x_ and later.\n\n## Upgrade documentation[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#upgrade-documentation \"Direct link to Upgrade documentation\")\n\nThe upgrade documentation consists of several pages, here's an overview of how to use them:\n\n*   **How to upgrade** (_you are here_): Starting point to learn about the upgrade process in general.\n*   [Schema incompatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql): A _reference_ page about the schema incompatibilities between Prisma 1 and Prisma ORM 2._x_ (and later versions). Reading this page is optional but it will give you a better understanding of certain steps in the upgrade process.\n\nIn addition to these two pages, there are various _practical guides_ that walk you through an example scenario of the upgrade process:\n\n*   [Upgrading the Prisma layer](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql): No matter what your Prisma 1 setup looks like, you should **always start your upgrade process by following this guide**.\n\nOnce you're done with that guide, you can choose **one of the following four guides to upgrade your application layer**:\n\n*   [Old to new Nexus](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-nexus-prisma-to-nexus): Choose this guide if you're currently running Prisma 1 with GraphQL Nexus.\n*   [prisma-binding to Nexus](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-nexus): Choose this guide if you're currently running Prisma 1 with `prisma-binding` and want to upgrade to [Nexus](https://www.nexusjs.org/#/).\n*   [prisma-binding to SDL-first](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-prisma-binding-to-sdl-first): Choose this guide if you're currently running Prisma 1 with `prisma-binding` and want to upgrade to an [SDL-first](https://www.prisma.io/blog/the-problems-of-schema-first-graphql-development-x1mn4cb0tyl3) GraphQL server.\n*   [REST API](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-a-rest-api): Choose this guide if you're currently running Prisma 1 using Prisma Client 1 and are building a REST API.\n\n## Main differences between Prisma 1 and Prisma ORM version 2._x_ and later[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#main-differences-between-prisma-1-and-prisma-orm-version-2x-and-later \"Direct link to main-differences-between-prisma-1-and-prisma-orm-version-2x-and-later\")\n\nOn a high-level, the biggest differences between Prisma 1 and Prisma ORM versions 2._x_ and later are summarized below.\n\nPrisma ORM 2._x_ and later versions:\n\n*   don't require hosting a database proxy server (i.e., the [Prisma server](https://v1.prisma.io/docs/1.34/prisma-server/)).\n*   make the features of Prisma 1 more modular and splits them into dedicated tools:\n    *   Prisma Client: An improved version of Prisma Client 1.0\n    *   Prisma Migrate: Data modeling and migrations (formerly `prisma deploy`).\n*   use the [Prisma schema](https://www.prisma.io/docs/orm/prisma-schema), a merge of Prisma 1 datamodel and `prisma.yml`.\n*   use its own [modeling language](https://github.com/prisma/specs/tree/master/schema) instead of being based on GraphQL SDL.\n*   don't expose [\"a GraphQL API for your database\"](https://www.prisma.io/blog/prisma-and-graphql-mfl5y2r7t49c) anymore, but only allows for _programmatic access_ via the Prisma Client API.\n    *   don't support Prisma ORM binding any more.\n*   allows connecting Prisma ORM 2._x_ and later version to any existing database, via more powerful introspection\n\n## Feature parity[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#feature-parity \"Direct link to Feature parity\")\n\nPrisma ORM 2._x_ and later versions do not yet have full feature parity with Prisma 1. The biggest feature that is still missing from Prisma ORM versions 2._x_ and later is real-time subscriptions.\n\n*   **Real-time API (Subscriptions)**: Prisma ORM version 2._x_ and later currently [doesn't have a way to subscribe to events happening in the database](https://github.com/prisma/prisma/issues/298) and get notified in real time. It is currently unclear if, when, and in what form a real-time API will be added to Prisma ORM versions 2._x_ and later. For the time being, you can implement real-time functionality using native database triggers, or if you're using GraphQL subscriptions you can consider triggering subscriptions manually inside your _mutation resolvers_.\n\n## Schema incompatibilities[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#schema-incompatibilities \"Direct link to Schema incompatibilities\")\n\nThe database schema that is created when running `prisma deploy` in Prisma 1 is only partially compatible with the one that Prisma ORM versions 2._x_ and later creates. This section gives a quick overview of the general incompatibilities and the potential workarounds. -\n\n> **Note**: For a detailed explanation of the problems and respective workarounds, please refer to the [Schema incompatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql) page.\n\nHere's an overview of the different columns:\n\n*   **Problem**: A short description of the problem when upgrading from Prisma 1 to Prisma ORM versions 2._x_ and later\n*   **SQL**: Can this be solved by making a non-breaking change to the SQL schema?\n*   **Prisma schema**: Can this be solved by making a non-breaking change to the schema in Prisma ORM versions 2._x_ and later?\n*   **Breaking Prisma 1**: Do the SQL statements break the Prisma 1 setup? This is only relevant when you're choosing the gradual side-by-side [upgrade strategy](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#upgrade-strategies).\n\n| Problem | SQL | Prisma schema | Breaking Prisma 1 |\n| --- | --- | --- | --- |\n| Default values aren't represented in database | Yes | Yes | No  |\n| Generated CUIDs as ID values aren't represented in database | No  | Yes | No  |\n| `@createdAt` isn't represented in database | Yes | Yes | No  |\n| `@updatedAt` isn't represented in database | No  | Yes | No  |\n| Inline 1-1 relations are recognized as 1-n (missing `UNIQUE` constraint) | Yes | No  | No  |\n| _All_ non-inline relations are recognized as m-n | Yes | No  | Yes |\n| Json type is represented as `TEXT` in database | Yes | No  | No (MySQL)  <br>Yes (PostgreSQL) |\n| Enums are represented as `TEXT` in database | Yes | No  | No (MySQL)  <br>Yes (PostgreSQL) |\n| Required 1-1 relations are not represented in database | No  | Yes | No  |\n| `@db` attributes from Prisma 1 are not transferred to the Prisma schema | No  | Yes | No  |\n| Mismatching CUID length | Yes | No  | No  |\n| Scalar lists (arrays) are maintained with extra table | Depends | No  | Depends |\n\n> **Note**: A general drawback with the workarounds in the Prisma schema is that [changes to the Prisma schema get lost after re-introspecting the database](https://github.com/prisma/prisma/issues/2425) and need to be re-added manually after each introspection run.\n\n## Prisma 1 Upgrade CLI[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#prisma-1-upgrade-cli \"Direct link to Prisma 1 Upgrade CLI\")\n\nThe [Prisma 1 Upgrade CLI](https://github.com/prisma/prisma1-upgrade) helps you apply the workarounds that are explained on the [Schema incompatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/schema-incompatibilities-postgresql) page. It generates the SQL statements to fix the database schema and make it compatible with Prisma ORM versions 2._x_ and later. Note that you are in full control over the operations that are executed against your database, the Upgrade CLI only generates and prints the statements for you. The Upgrade CLI also takes care of the workarounds in the Prisma schema.\n\nOn a high-level, the upgrade workflow using the Upgrade CLI looks as follows.\n\nFor the **initial setup**:\n\n1.  You set up Prisma ORM by installing the Prisma ORM versions 2._x_ and later CLI and running `npx prisma init`.\n2.  You connect to your database and introspect it with `npx prisma db pull`.\n\n![Prisma CLI introspection flow](https://www.prisma.io/docs/assets/images/prisma-cli-introspection-flow-88d1edc0336810097c2bc31eaba1a894.png)\n\nFor **fixing the schema incompatibilities**:\n\n1.  You invoke the Upgrade CLI with `npx prisma-upgrade`.\n2.  The Upgrade CLI generates SQL commands for you to run on your database.\n3.  You run the SQL commands against your database.\n4.  You run the `prisma db pull` command again.\n5.  You run the `npx prisma-upgrade` command again.\n6.  The Upgrade CLI adjusts the Prisma schema (version 2._x_ and later) by adding missing attributes.\n\n![Fixing the schema incompatibilities](https://www.prisma.io/docs/assets/images/fix-schema-incompatibilities-09a1632f64517dbb92da2de4416337e8.png)\n\nNote that the Upgrade CLI is designed in a way that **you can stop and re-start the process at any time**. Once you ran a SQL command that was generated by the Upgrade CLI against your database, the SQL command will not show up the next time you invoke the Upgrade CLI. That way, you can gradually resolve all schema incompatibilities when it's convenient for you.\n\n## Upgrade strategies[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#upgrade-strategies \"Direct link to Upgrade strategies\")\n\nThere are two main upgrade strategies:\n\n*   **Upgrade all at once**: Entirely remove Prisma 1 from your project and move everything over to Prisma ORM version 2._x_ or later at once.\n*   **Gradual upgrade side-by-side**: Add Prisma ORM version 2._x_ and later to the existing Prisma 1 project and gradually replace existing Prisma 1 features with the newer Prisma features while running them side-by-side.\n\nNote that if you are planning to run Prisma 1 and Prisma ORM 2._x_ or later version side-by-side, you must not yet resolve the [schema compatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#schema-incompatibilities) that are breaking the Prisma 1 setup.\n\n### When to choose which strategy[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#when-to-choose-which-strategy \"Direct link to When to choose which strategy\")\n\nIf your project is not yet running in production or has little traffic and user data, the **all at once** strategy is recommended.\n\nIn case your project already sees a lot of traffic and has a lot of user data stored in the database, you might want to consider the **gradual** upgrade strategy where you're running Prisma 1 and Prisma ORM 2 or later side-by-side for a certain amount of time until you've replace all former Prisma 1 functionality with Prisma ORM 2 or later version.\n\nNote that you won't be able to fix the [schema incompatibilities](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#schema-incompatibilities) that require a \"Breaking Prisma 1\" change if you choose the gradual upgrade strategy and intend to run Prisma 1 and Prisma ORM version 2._x_ or later side-by-side. That's because these data migrations are breaking the schema that Prisma 1 expects. This means that your Prisma Client API might not feel as idiomatic as it could, but you still get the full feature set of Prisma Client.\n\n### Upgrade path[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#upgrade-path \"Direct link to Upgrade path\")\n\nNo matter which of the strategies you choose, on a high-level the envisioned upgrade path looks as follows:\n\n1.  Install the new Prisma ORM version 2._x_ or later CLI as a development dependency\n2.  Create your Prisma schema and configure the database connection URL\n3.  Use the Prisma ORM version 2._x_ or later CLI to introspect your Prisma 1 database and generate your Prisma schema\n4.  Run the [Prisma 1 Upgrade CLI](https://github.com/prisma/prisma1-upgrade) to \"fix\" the Prisma schema\n5.  Install and generate Prisma Client version 2._x_ or later\n6.  Adjust your application code, specifically replace the API calls from the Prisma Client 1.0 with those of Prisma Client version 2._x_ or later\n\n## Next steps[​](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/how-to-upgrade#next-steps \"Direct link to Next steps\")\n\nOnce you've made the decision to upgrade, continue with the [Upgrading the Prisma ORM layer](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrade-from-prisma-1/upgrading-the-prisma-layer-postgresql) guide.",
    "title": "How to upgrade from Prisma 1 to Prisma ORM version 2.x and later | Prisma Documentation",
    "description": "Learn how to upgrade your Prisma 1 project to Prisma ORM version 2.x and later",
    "languageCode": "en"
  }
]