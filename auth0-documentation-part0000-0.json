[{
  "url": "https://auth0.com/docs",
  "markdown": "# Auth0\n\n## Start Building\n\n#### Choose your application type to get started\n\n## Learn about Auth0\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\n#### Rely on the Auth0 identity platform to add sophisticated authentication and authorization to your applications. Centralize and manage users from multiple identity providers and give them branded, seamless signup and login experiences. Finely control access with a degree of customization that can accommodate even the most complex security requirements.\n\n* * *",
  "title": "Auth0",
  "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/articles",
  "markdown": "# Auth0 Docs\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nRely on the Auth0 identity platform to add sophisticated authentication and authorization to your applications. Centralize and manage users from multiple identity providers and give them branded, seamless signup and login experiences. Finely control access with a degree of customization that can accommodate even the most complex security requirements. Easily deploy your implementation and monitor status and services.",
  "title": "Auth0 Docs",
  "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstarts",
  "markdown": "# Auth0\n\n## Quickstarts\n\nStep-by-step guides to quickly integrate Auth0 into your application\n\n![quickstarts header](https://auth0.com/docs/img/quickstarts/header_img.svg)\n\n![](https://auth0.com/docs/img/quickstarts/webapp-quantum.svg)\n\nRegular Web App\n\n###### Traditional web app that runs on the server\n\n[](https://auth0.com/docs/quickstart/webapp/apache)[](https://auth0.com/docs/quickstart/webapp/aspnet-owin/interactive)[](https://auth0.com/docs/quickstart/webapp/aspnet-core-blazor-server/interactive)[](https://auth0.com/docs/quickstart/webapp/aspnet-core/interactive)[](https://auth0.com/docs/quickstart/webapp/django/interactive)[](https://auth0.com/docs/quickstart/webapp/express/interactive)[](https://auth0.com/docs/quickstart/webapp/golang/interactive)[](https://auth0.com/docs/quickstart/webapp/java/interactive)[](https://auth0.com/docs/quickstart/webapp/java-ee)[](https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive)[](https://auth0.com/docs/quickstart/webapp/laravel/interactive)[](https://auth0.com/docs/quickstart/webapp/nextjs/interactive)[](https://auth0.com/docs/quickstart/webapp/nginx-plus)[](https://auth0.com/docs/quickstart/webapp/php/interactive)[](https://auth0.com/docs/quickstart/webapp/python/interactive)[](https://auth0.com/docs/quickstart/webapp/rails/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/spa-quantum.svg)\n\nSingle Page App\n\n###### Javascript web app that runs in the browser\n\n[](https://auth0.com/docs/quickstart/spa/angular/interactive)[](https://auth0.com/docs/quickstart/spa/flutter/interactive)[](https://auth0.com/docs/quickstart/spa/vanillajs/interactive)[](https://auth0.com/docs/quickstart/spa/react/interactive)[](https://auth0.com/docs/quickstart/spa/vuejs/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/native-quantum.svg)\n\nNative/Mobile App\n\n###### Mobile or desktop app that runs natively on a device\n\n[](https://auth0.com/docs/quickstart/native/net-android-ios/interactive)[](https://auth0.com/docs/quickstart/native/android/interactive)[](https://auth0.com/docs/quickstart/native/android-facebook-login)[](https://auth0.com/docs/quickstart/native/device)[](https://auth0.com/docs/quickstart/native/react-native-expo/interactive)[](https://auth0.com/docs/quickstart/native/flutter/interactive)[](https://auth0.com/docs/quickstart/native/ionic-angular/interactive)[](https://auth0.com/docs/quickstart/native/ionic-react/interactive)[](https://auth0.com/docs/quickstart/native/ionic-vue/interactive)[](https://auth0.com/docs/quickstart/native/ios-swift/interactive)[](https://auth0.com/docs/quickstart/native/maui/interactive)[](https://auth0.com/docs/quickstart/native/react-native/interactive)[](https://auth0.com/docs/quickstart/native/windows-uwp-csharp)[](https://auth0.com/docs/quickstart/native/wpf-winforms/interactive)[](https://auth0.com/docs/quickstart/native/xamarin/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/backend-quantum.svg)\n\nBackend/API\n\n###### An API or service protected by Auth0\n\n[](https://auth0.com/docs/quickstart/backend/aspnet-core-webapi/interactive)[](https://auth0.com/docs/quickstart/backend/webapi-owin/interactive)[](https://auth0.com/docs/quickstart/backend/django/interactive)[](https://auth0.com/docs/quickstart/backend/golang/interactive)[](https://auth0.com/docs/quickstart/backend/laravel/interactive)[](https://auth0.com/docs/quickstart/backend/nodejs/interactive)[](https://auth0.com/docs/quickstart/backend/php/interactive)[](https://auth0.com/docs/quickstart/backend/python/interactive)[](https://auth0.com/docs/quickstart/backend/rails/interactive)[](https://auth0.com/docs/quickstart/backend/java-spring-security5/interactive)",
  "title": "Auth0",
  "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api",
  "markdown": "# Auth0 APIs\n\nAuth0 exposes the following APIs for developers to consume in their applications.\n\n## Authentication API\n\nThe Authentication API exposes identity functionality for Auth0 and supported identity protocols (including OpenID Connect, OAuth, and SAML).\n\nTypically, you should consume this API through one of the Auth0 SDKs, such as [Auth0.js](https://auth0.com/docs/libraries/auth0js), or a library like [Lock](https://auth0.com/docs/libraries/lock). However, if you are building your authentication UI manually, you will need to call the Authentication API directly.\n\nSome example tasks include:\n\n*   Get [tokens](https://auth0.com/docs/secure/tokens) during authentication\n    \n*   Request a user's profile using an [Access Token](https://auth0.com/docs/secure/tokens/access-tokens)\n    \n*   Exchange [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens) for new Access Tokens\n    \n*   Request a challenge for [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication)\n    \n\n### API\n\nLearn about and explore the requests and responses for the Auth0 Authentication API endpoints in your browser with the [Authentication API](https://auth0.com/docs/auth-api).\n\n## Management API\n\nThe Management API allows you to manage your Auth0 account programmatically, so you can automate configuration of your environment. Most of the tasks you can perform in the Auth0 Management Dashboard can also be performed programmatically by using this API.\n\nSome example tasks include:\n\n*   Register your applications and APIs with Auth0\n    \n*   Set up [connections](https://auth0.com/docs/connections) with which your users can authenticate\n    \n*   [Manage users](https://auth0.com/docs/manage-users)\n    \n*   [Link user accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts)\n    \n\nFor Public Cloud tenants, Management API endpoints return a maximum of 50 results per response. When there are more results than can be returned in a response, include the `page` and `per_page` parameters in your request to retrieve more results.\n\nSee [Migrate to Management API v2 Endpoint Paginated Queries](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-paginated-queries) for information on updating your applications.\n\n### API Explorer\n\nLearn about and use the Auth0 Management API in your browser with the [Management API Explorer](https://auth0.com/docs/api/v2).\n\n### Management API v1 has been deprecated\n\nThe Management API v1 is deprecated and should not be used for new projects.\n\nManagement API v1 reached its End of Life on **July 13, 2020**. You may have been required to take action before that date to ensure no interruption to your service. Notifications were sent to customers that needed to complete this migration.",
  "title": "Auth0 APIs",
  "description": "Learn about Auth0's Management and Authentication APIs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries",
  "markdown": "# Auth0 Libraries\n\nAuth0 SDK libraries make it easy for developers to integrate and interact with Auth0. Explore any library on GitHub, download a sample application, or use a quickstart for customized help.\n\nAuth0 SDK libraries make it easy for developers to integrate and interact with Auth0.\n\n![library header](https://auth0.com/docs/img/library/header_img.svg)",
  "title": "Auth0 Libraries",
  "description": "Auth0 Libraries and SDKs overview",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native",
  "markdown": "# Auth0 Native/Mobile App Quickstarts\n\nStep-by-step guides to quickly integrate Auth0 into your application\n\n![quickstarts header](https://auth0.com/docs/img/quickstarts/header_img.svg)\n\n![](https://auth0.com/docs/img/quickstarts/webapp-quantum.svg)\n\nRegular Web App\n\n###### Traditional web app that runs on the server\n\n[](https://auth0.com/docs/quickstart/webapp/apache)[](https://auth0.com/docs/quickstart/webapp/aspnet-owin/interactive)[](https://auth0.com/docs/quickstart/webapp/aspnet-core-blazor-server/interactive)[](https://auth0.com/docs/quickstart/webapp/aspnet-core/interactive)[](https://auth0.com/docs/quickstart/webapp/django/interactive)[](https://auth0.com/docs/quickstart/webapp/express/interactive)[](https://auth0.com/docs/quickstart/webapp/golang/interactive)[](https://auth0.com/docs/quickstart/webapp/java/interactive)[](https://auth0.com/docs/quickstart/webapp/java-ee)[](https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive)[](https://auth0.com/docs/quickstart/webapp/laravel/interactive)[](https://auth0.com/docs/quickstart/webapp/nextjs/interactive)[](https://auth0.com/docs/quickstart/webapp/nginx-plus)[](https://auth0.com/docs/quickstart/webapp/php/interactive)[](https://auth0.com/docs/quickstart/webapp/python/interactive)[](https://auth0.com/docs/quickstart/webapp/rails/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/spa-quantum.svg)\n\nSingle Page App\n\n###### Javascript web app that runs in the browser\n\n[](https://auth0.com/docs/quickstart/spa/angular/interactive)[](https://auth0.com/docs/quickstart/spa/flutter/interactive)[](https://auth0.com/docs/quickstart/spa/vanillajs/interactive)[](https://auth0.com/docs/quickstart/spa/react/interactive)[](https://auth0.com/docs/quickstart/spa/vuejs/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/native-quantum.svg)\n\nNative/Mobile App\n\n###### Mobile or desktop app that runs natively on a device\n\n[](https://auth0.com/docs/quickstart/native/net-android-ios/interactive)[](https://auth0.com/docs/quickstart/native/android/interactive)[](https://auth0.com/docs/quickstart/native/android-facebook-login)[](https://auth0.com/docs/quickstart/native/device)[](https://auth0.com/docs/quickstart/native/react-native-expo/interactive)[](https://auth0.com/docs/quickstart/native/flutter/interactive)[](https://auth0.com/docs/quickstart/native/ionic-angular/interactive)[](https://auth0.com/docs/quickstart/native/ionic-react/interactive)[](https://auth0.com/docs/quickstart/native/ionic-vue/interactive)[](https://auth0.com/docs/quickstart/native/ios-swift/interactive)[](https://auth0.com/docs/quickstart/native/maui/interactive)[](https://auth0.com/docs/quickstart/native/react-native/interactive)[](https://auth0.com/docs/quickstart/native/windows-uwp-csharp)[](https://auth0.com/docs/quickstart/native/wpf-winforms/interactive)[](https://auth0.com/docs/quickstart/native/xamarin/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/backend-quantum.svg)\n\nBackend/API\n\n###### An API or service protected by Auth0\n\n[](https://auth0.com/docs/quickstart/backend/aspnet-core-webapi/interactive)[](https://auth0.com/docs/quickstart/backend/webapi-owin/interactive)[](https://auth0.com/docs/quickstart/backend/django/interactive)[](https://auth0.com/docs/quickstart/backend/golang/interactive)[](https://auth0.com/docs/quickstart/backend/laravel/interactive)[](https://auth0.com/docs/quickstart/backend/nodejs/interactive)[](https://auth0.com/docs/quickstart/backend/php/interactive)[](https://auth0.com/docs/quickstart/backend/python/interactive)[](https://auth0.com/docs/quickstart/backend/rails/interactive)[](https://auth0.com/docs/quickstart/backend/java-spring-security5/interactive)",
  "title": "Auth0 Native/Mobile App Quickstarts",
  "description": "Browse native/mobile app quickstarts to learn how to quickly add authentication to your app.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa",
  "markdown": "# Auth0 Single-Page App Quickstarts\n\nStep-by-step guides to quickly integrate Auth0 into your application\n\n![quickstarts header](https://auth0.com/docs/img/quickstarts/header_img.svg)\n\n![](https://auth0.com/docs/img/quickstarts/webapp-quantum.svg)\n\nRegular Web App\n\n###### Traditional web app that runs on the server\n\n[](https://auth0.com/docs/quickstart/webapp/apache)[](https://auth0.com/docs/quickstart/webapp/aspnet-owin/interactive)[](https://auth0.com/docs/quickstart/webapp/aspnet-core-blazor-server/interactive)[](https://auth0.com/docs/quickstart/webapp/aspnet-core/interactive)[](https://auth0.com/docs/quickstart/webapp/django/interactive)[](https://auth0.com/docs/quickstart/webapp/express/interactive)[](https://auth0.com/docs/quickstart/webapp/golang/interactive)[](https://auth0.com/docs/quickstart/webapp/java/interactive)[](https://auth0.com/docs/quickstart/webapp/java-ee)[](https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive)[](https://auth0.com/docs/quickstart/webapp/laravel/interactive)[](https://auth0.com/docs/quickstart/webapp/nextjs/interactive)[](https://auth0.com/docs/quickstart/webapp/nginx-plus)[](https://auth0.com/docs/quickstart/webapp/php/interactive)[](https://auth0.com/docs/quickstart/webapp/python/interactive)[](https://auth0.com/docs/quickstart/webapp/rails/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/spa-quantum.svg)\n\nSingle Page App\n\n###### Javascript web app that runs in the browser\n\n[](https://auth0.com/docs/quickstart/spa/angular/interactive)[](https://auth0.com/docs/quickstart/spa/flutter/interactive)[](https://auth0.com/docs/quickstart/spa/vanillajs/interactive)[](https://auth0.com/docs/quickstart/spa/react/interactive)[](https://auth0.com/docs/quickstart/spa/vuejs/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/native-quantum.svg)\n\nNative/Mobile App\n\n###### Mobile or desktop app that runs natively on a device\n\n[](https://auth0.com/docs/quickstart/native/net-android-ios/interactive)[](https://auth0.com/docs/quickstart/native/android/interactive)[](https://auth0.com/docs/quickstart/native/android-facebook-login)[](https://auth0.com/docs/quickstart/native/device)[](https://auth0.com/docs/quickstart/native/react-native-expo/interactive)[](https://auth0.com/docs/quickstart/native/flutter/interactive)[](https://auth0.com/docs/quickstart/native/ionic-angular/interactive)[](https://auth0.com/docs/quickstart/native/ionic-react/interactive)[](https://auth0.com/docs/quickstart/native/ionic-vue/interactive)[](https://auth0.com/docs/quickstart/native/ios-swift/interactive)[](https://auth0.com/docs/quickstart/native/maui/interactive)[](https://auth0.com/docs/quickstart/native/react-native/interactive)[](https://auth0.com/docs/quickstart/native/windows-uwp-csharp)[](https://auth0.com/docs/quickstart/native/wpf-winforms/interactive)[](https://auth0.com/docs/quickstart/native/xamarin/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/backend-quantum.svg)\n\nBackend/API\n\n###### An API or service protected by Auth0\n\n[](https://auth0.com/docs/quickstart/backend/aspnet-core-webapi/interactive)[](https://auth0.com/docs/quickstart/backend/webapi-owin/interactive)[](https://auth0.com/docs/quickstart/backend/django/interactive)[](https://auth0.com/docs/quickstart/backend/golang/interactive)[](https://auth0.com/docs/quickstart/backend/laravel/interactive)[](https://auth0.com/docs/quickstart/backend/nodejs/interactive)[](https://auth0.com/docs/quickstart/backend/php/interactive)[](https://auth0.com/docs/quickstart/backend/python/interactive)[](https://auth0.com/docs/quickstart/backend/rails/interactive)[](https://auth0.com/docs/quickstart/backend/java-spring-security5/interactive)",
  "title": "Auth0 Single-Page App Quickstarts",
  "description": "Browse single-page app quickstarts to learn how to quickly add authentication to your app.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp",
  "markdown": "# Auth0 Regular Web App Quickstarts\n\nStep-by-step guides to quickly integrate Auth0 into your application\n\n![quickstarts header](https://auth0.com/docs/img/quickstarts/header_img.svg)\n\n![](https://auth0.com/docs/img/quickstarts/webapp-quantum.svg)\n\nRegular Web App\n\n###### Traditional web app that runs on the server\n\n[](https://auth0.com/docs/quickstart/webapp/apache)[](https://auth0.com/docs/quickstart/webapp/aspnet-owin/interactive)[](https://auth0.com/docs/quickstart/webapp/aspnet-core-blazor-server/interactive)[](https://auth0.com/docs/quickstart/webapp/aspnet-core/interactive)[](https://auth0.com/docs/quickstart/webapp/django/interactive)[](https://auth0.com/docs/quickstart/webapp/express/interactive)[](https://auth0.com/docs/quickstart/webapp/golang/interactive)[](https://auth0.com/docs/quickstart/webapp/java/interactive)[](https://auth0.com/docs/quickstart/webapp/java-ee)[](https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive)[](https://auth0.com/docs/quickstart/webapp/laravel/interactive)[](https://auth0.com/docs/quickstart/webapp/nextjs/interactive)[](https://auth0.com/docs/quickstart/webapp/nginx-plus)[](https://auth0.com/docs/quickstart/webapp/php/interactive)[](https://auth0.com/docs/quickstart/webapp/python/interactive)[](https://auth0.com/docs/quickstart/webapp/rails/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/spa-quantum.svg)\n\nSingle Page App\n\n###### Javascript web app that runs in the browser\n\n[](https://auth0.com/docs/quickstart/spa/angular/interactive)[](https://auth0.com/docs/quickstart/spa/flutter/interactive)[](https://auth0.com/docs/quickstart/spa/vanillajs/interactive)[](https://auth0.com/docs/quickstart/spa/react/interactive)[](https://auth0.com/docs/quickstart/spa/vuejs/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/native-quantum.svg)\n\nNative/Mobile App\n\n###### Mobile or desktop app that runs natively on a device\n\n[](https://auth0.com/docs/quickstart/native/net-android-ios/interactive)[](https://auth0.com/docs/quickstart/native/android/interactive)[](https://auth0.com/docs/quickstart/native/android-facebook-login)[](https://auth0.com/docs/quickstart/native/device)[](https://auth0.com/docs/quickstart/native/react-native-expo/interactive)[](https://auth0.com/docs/quickstart/native/flutter/interactive)[](https://auth0.com/docs/quickstart/native/ionic-angular/interactive)[](https://auth0.com/docs/quickstart/native/ionic-react/interactive)[](https://auth0.com/docs/quickstart/native/ionic-vue/interactive)[](https://auth0.com/docs/quickstart/native/ios-swift/interactive)[](https://auth0.com/docs/quickstart/native/maui/interactive)[](https://auth0.com/docs/quickstart/native/react-native/interactive)[](https://auth0.com/docs/quickstart/native/windows-uwp-csharp)[](https://auth0.com/docs/quickstart/native/wpf-winforms/interactive)[](https://auth0.com/docs/quickstart/native/xamarin/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/backend-quantum.svg)\n\nBackend/API\n\n###### An API or service protected by Auth0\n\n[](https://auth0.com/docs/quickstart/backend/aspnet-core-webapi/interactive)[](https://auth0.com/docs/quickstart/backend/webapi-owin/interactive)[](https://auth0.com/docs/quickstart/backend/django/interactive)[](https://auth0.com/docs/quickstart/backend/golang/interactive)[](https://auth0.com/docs/quickstart/backend/laravel/interactive)[](https://auth0.com/docs/quickstart/backend/nodejs/interactive)[](https://auth0.com/docs/quickstart/backend/php/interactive)[](https://auth0.com/docs/quickstart/backend/python/interactive)[](https://auth0.com/docs/quickstart/backend/rails/interactive)[](https://auth0.com/docs/quickstart/backend/java-spring-security5/interactive)",
  "title": "Auth0 Regular Web App Quickstarts",
  "description": "Browse regular web app quickstarts to learn how to quickly add authentication to your app.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started",
  "markdown": "# Get Started\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nWelcome to Auth0, an identity platform to manage access to your applications. If you’re new to identity and access management (IAM), learn some of the basics and plan the solution that best fits your technology and needs. If you’re familiar with IAM, you can jump in and start building.\n\n* * *\n\n## Start Building\n\n##### To get up and running swiftly, choose your application type for a step-by-step quickstart tutorial.\n\n* * *\n\n## Learn the Basics\n\n##### Build your knowledge of IAM technology and Auth0.\n\n* * *\n\n## Configure Auth0\n\n##### Define how Auth0 works with your applications and APIs. Control who can access your Auth0 Dashboard.\n\n* * *\n\n## Plan and Design\n\n##### Learn about Auth0 flows and architecture so you can make informed decisions about your Auth0 implementation.",
  "title": "Get Started",
  "description": "Learn the basics and begin building your authentication solution.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate",
  "markdown": "# Authenticate\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nIn authentication, a user or application proves they are who they say they are by providing valid credentials. The most common verification is password, often combined with other methods, such as a fingerprint.\n\nAuth0 simplifies the use of open industry standards like OAuth 2.0, OIDC, and SAML to authenticate. Users can log into your applications with social media credentials, corporate accounts, and a broad range of other credentials.\n\n* * *\n\n## Add Login\n\n##### Implement Auth0 Universal Login (or an alternative) to control access to your applications.\n\n* * *\n\n## Provision Users\n\n##### Source users from social identity providers (such as Facebook or SalesForce), enterprise user stores (such as Active Directory or Google Workspace), a custom database, and more.",
  "title": "Authenticate",
  "description": "Learn all about how to authenticate using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users",
  "markdown": "# Manage Users\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nAuth0's hosted cloud database stores user data that is available to you via user profiles. The user information itself can come from a variety of sources, including identity providers, your own databases, and enterprise connections (such as Active Directory or SAML).\n\n* * *\n\n## Manage Users\n\n##### Import, group, and administer users and control their access.\n\n* * *\n\n## Manage Access\n\n##### Control who can interact within your applications.",
  "title": "Manage Users",
  "description": "Learn about working with users, user profiles, and user metadata in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize",
  "markdown": "# Customize\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nAuth0 lets you customize your users’ entire authentication experience. You can:\n\n*   Brand and internationalize all interaction with end users\n    \n*   Define your own logic to customize and extend how Auth0 works\n    \n*   Integrate Auth0 with third-party software to add capabilities\n    \n\n* * *\n\n## Brand Customization\n\n##### Seamlessly integrate Auth0 with your own brand and localize the experience for international users.\n\n* * *\n\n## Code Customization\n\n##### Create Actions to customize and extend Auth0’s capabilities with custom logic. Or maintain legacy Rules and Hooks.\n\n* * *\n\n## Third-Party Customization\n\n##### Take advantage of third-party integrations and Auth0 extensions to expand what Auth0 can do for your systems.",
  "title": "Customize",
  "description": "Learn how to brand, customize, and localize your login pages, domain names, emails sent to users, and consent prompts.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor",
  "markdown": "# Deploy and Monitor\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nYou can deploy Auth0 to the public cloud, a private cloud on AWS, or a private cloud on Azure. Deployment tools and checklists smooth the process. Monitoring tools and event logs let you track system health and events.\n\n* * *\n\n## Deployment\n\n##### Plan, check, and execute your Auth0 deployment.\n\n* * *\n\n## Monitoring\n\n##### Monitor events and service status and work with tenant log event data.",
  "title": "Deploy and Monitor",
  "description": "Learn about Auth0 public and private cloud deployment options, as well as deployment checklists and tools. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot",
  "markdown": "# Troubleshoot\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nAuth0 offers multiple tiers of professional support as well as a thriving community of developers discussing their implementations. Troubleshooting topics can help solve common challenges.\n\n* * *\n\n## Get Support\n\n##### Learn about Auth0’s support plans and procedures, service agreements, and community.\n\n* * *\n\n## Troubleshoot\n\n##### Explore solutions to common challenges.\n\n* * *\n\n## Auth0 Product Lifecycle\n\n##### Discover our iterative approach to product delivery.",
  "title": "Troubleshoot",
  "description": "Learn how to troubleshoot and solve common issues in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend",
  "markdown": "# Auth0 Backend/API Quickstarts\n\nStep-by-step guides to quickly integrate Auth0 into your application\n\n![quickstarts header](https://auth0.com/docs/img/quickstarts/header_img.svg)\n\n![](https://auth0.com/docs/img/quickstarts/webapp-quantum.svg)\n\nRegular Web App\n\n###### Traditional web app that runs on the server\n\n[](https://auth0.com/docs/quickstart/webapp/apache)[](https://auth0.com/docs/quickstart/webapp/aspnet-owin/interactive)[](https://auth0.com/docs/quickstart/webapp/aspnet-core-blazor-server/interactive)[](https://auth0.com/docs/quickstart/webapp/aspnet-core/interactive)[](https://auth0.com/docs/quickstart/webapp/django/interactive)[](https://auth0.com/docs/quickstart/webapp/express/interactive)[](https://auth0.com/docs/quickstart/webapp/golang/interactive)[](https://auth0.com/docs/quickstart/webapp/java/interactive)[](https://auth0.com/docs/quickstart/webapp/java-ee)[](https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive)[](https://auth0.com/docs/quickstart/webapp/laravel/interactive)[](https://auth0.com/docs/quickstart/webapp/nextjs/interactive)[](https://auth0.com/docs/quickstart/webapp/nginx-plus)[](https://auth0.com/docs/quickstart/webapp/php/interactive)[](https://auth0.com/docs/quickstart/webapp/python/interactive)[](https://auth0.com/docs/quickstart/webapp/rails/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/spa-quantum.svg)\n\nSingle Page App\n\n###### Javascript web app that runs in the browser\n\n[](https://auth0.com/docs/quickstart/spa/angular/interactive)[](https://auth0.com/docs/quickstart/spa/flutter/interactive)[](https://auth0.com/docs/quickstart/spa/vanillajs/interactive)[](https://auth0.com/docs/quickstart/spa/react/interactive)[](https://auth0.com/docs/quickstart/spa/vuejs/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/native-quantum.svg)\n\nNative/Mobile App\n\n###### Mobile or desktop app that runs natively on a device\n\n[](https://auth0.com/docs/quickstart/native/net-android-ios/interactive)[](https://auth0.com/docs/quickstart/native/android/interactive)[](https://auth0.com/docs/quickstart/native/android-facebook-login)[](https://auth0.com/docs/quickstart/native/device)[](https://auth0.com/docs/quickstart/native/react-native-expo/interactive)[](https://auth0.com/docs/quickstart/native/flutter/interactive)[](https://auth0.com/docs/quickstart/native/ionic-angular/interactive)[](https://auth0.com/docs/quickstart/native/ionic-react/interactive)[](https://auth0.com/docs/quickstart/native/ionic-vue/interactive)[](https://auth0.com/docs/quickstart/native/ios-swift/interactive)[](https://auth0.com/docs/quickstart/native/maui/interactive)[](https://auth0.com/docs/quickstart/native/react-native/interactive)[](https://auth0.com/docs/quickstart/native/windows-uwp-csharp)[](https://auth0.com/docs/quickstart/native/wpf-winforms/interactive)[](https://auth0.com/docs/quickstart/native/xamarin/interactive)\n\n![](https://auth0.com/docs/img/quickstarts/backend-quantum.svg)\n\nBackend/API\n\n###### An API or service protected by Auth0\n\n[](https://auth0.com/docs/quickstart/backend/aspnet-core-webapi/interactive)[](https://auth0.com/docs/quickstart/backend/webapi-owin/interactive)[](https://auth0.com/docs/quickstart/backend/django/interactive)[](https://auth0.com/docs/quickstart/backend/golang/interactive)[](https://auth0.com/docs/quickstart/backend/laravel/interactive)[](https://auth0.com/docs/quickstart/backend/nodejs/interactive)[](https://auth0.com/docs/quickstart/backend/php/interactive)[](https://auth0.com/docs/quickstart/backend/python/interactive)[](https://auth0.com/docs/quickstart/backend/rails/interactive)[](https://auth0.com/docs/quickstart/backend/java-spring-security5/interactive)",
  "title": "Auth0 Backend/API Quickstarts",
  "description": "Browse backend/api quickstarts to learn how to quickly add authentication to your app.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/react-native-expo/interactive",
  "markdown": "# Add Login to your React Native App\n\nThis Quickstart is for the Expo framework. To integrate Auth0 into your React Native application, please refer to the [React Native Quickstart](https://auth0.com/docs/quickstart/native/react-native/interactive)\n\nTo use Auth0 services, you need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure authentication in your project.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure callback and logout URLs\n\nAuth0 invokes the callback and logout URLs to redirect users back to your application. Auth0 invokes the callback URL after authenticating the user and the logout URL after removing the session cookie. If you do not set the callback and logout URLs, users will not be able to log in and out of the app, and your application will produce an error.\n\nAdd the corresponding URL to **Callback URLs** and **Logout URLs**, according to your app's platform. If you are using a [custom domain](https://auth0.com/docs/customize/custom-domains), use the value of your custom domain instead of your Auth0 tenant’s domain.\n\n#### iOS\n\n```\nBUNDLE_IDENTIFIER.auth0://{yourDomain}/ios/BUNDLE_IDENTIFIER/callback\n```\n\n#### Android\n\n```\nPACKAGE_NAME.auth0://{yourDomain}/android/PACKAGE_NAME/callback\n```\n\nIn this section, you will learn how to install the React Native Auth0 module.\n\n### Yarn\n\n```\nyarn add react-native-auth0\n```\n\n### npm\n\n```\nnpm install react-native-auth0 --save\n```\n\nThe Auth0 package runs custom native code that must be configured at build time. Use [Expo Config Plugin](https://docs.expo.dev/guides/config-plugins/) to achieve this.\n\nThe `react-native-auth0` plugin will be added in the [Expo config](https://docs.expo.dev/workflow/configuration/)\n\nYou must generate the native code for the above configuration to be set. To do this, run the following command:\n\nYou will be prompted to provide the [Android package](https://github.com/expo/fyi/blob/main/android-package.md) and [iOS bundle identifier](https://github.com/expo/fyi/blob/main/bundle-identifier.md) if they are not already present in the Expo config.\n\n```\n? What would you like your Android package name to be? > com.auth0samples # or your desired package name\n\n? What would you like your iOS bundle identifier to be? > com.auth0samples # or your desired bundle identifier\n```\n\nThese values are used to set the callback and logout URLs.\n\nThe `useAuth0` hook relies on a React Context to provide state management. This context is provided by the `Auth0Provider` component.\n\nImport the `useAuth0` hook and `Auth0Provider` component from the `react-native-auth0` package:\n\n```\nimport {useAuth0, Auth0Provider} from 'react-native-auth0';\n```\n\nFor the SDK to function properly, you must wrap your application in the `Auth0Provider` component, and set the following properties:\n\n*   `domain`: The domain of your Auth0 tenant. Generally, you can find this in the Auth0 Dashboard under your Application's Settings in the Domain field. If you are using a [custom domain](https://auth0.com/docs/custom-domains), you should set this to the value of your custom domain instead.\n*   `clientId`: The ID of the Auth0 Application you set up earlier in this quickstart. You can find this in the Auth0 Dashboard under your Application's Settings in the Client ID field.\n\n##### Checkpoint\n\nYour `Auth0Provider` component should now be properly configured. Run your application to verify that:\n\n*   the SDK is initializing correctly\n*   your application is not throwing any errors related to Auth0\n\nAuthenticate the user by calling the `authorize` method provided by the `useAuth0` hook. This redirects the user to the Auth0 [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) page for authentication, then back to your app.\n\nFor confirmation that the user was logged in successfully, check that the `user` property provided by the hook is not `null`.\n\n##### Checkpoint\n\nAdd a button component that calls `authorize` when clicked. Verify that you are redirected to the login page and then back to your application.\n\nTo log the user out, redirect them to the Auth0 logout endpoint by calling `clearSession`. This will remove their session from the authorization server and log the user out of the application.\n\n##### Checkpoint\n\nAdd a logout button that calls `clearSession` and observe that you are redirected to the Auth0 logout endpoint and back again. You should no longer be logged in to your application.\n\nThe `useAuth0` hook exposes a `user` object that contains information about the authenticated user. You can use this to access user profile information about the authenticated user that has been decoded from the [ID token](https://auth0.com/docs/secure/tokens/id-tokens).\n\nIf a user has not been authenticated, this property will be `null`.\n\n##### Checkpoint\n\nLog in and inspect the `user` property on the result. Verify the current user's profile information, such as `email` or `name`.",
  "title": "Auth0 Expo SDK Quickstarts: Add Login to your React Native App",
  "description": "This quickstart demonstrates how to add user login to an React Native application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure",
  "markdown": "# Secure\n\n![sectionpipeline-background](https://cdn2.auth0.com/docs/1.13915.0/img/site-graph.svg)\n\n[](https://auth0.com/docs/get-started)[](https://auth0.com/docs/authenticate)[](https://auth0.com/docs/manage-users)[](https://auth0.com/docs/customize)[](https://auth0.com/docs/secure)[](https://auth0.com/docs/deploy-monitor)\n\nAuth0 provides critical tools for securing your applications against people who are interested in attacking information technology systems. Multi-factor authentication (MFA) reduces risk by requiring more than one type of user validation, while attack protection features automatically detect and respond to malicious behavior such as rapid, repeated failed logins or one IP address rapidly attempting to log into multiple accounts. \n\nAuth0 maintains and meets the requirements for multiple compliance frameworks and certifications including GDPR and HIPAA.\n\n* * *\n\n## Protect Your Application\n\n##### Make sure only the right people can access your applications.\n\n* * *\n\n## Compliance\n\n##### Learn how Auth0 meets requirements for multiple compliance frameworks and certifications, including GDPR and HIPAA.",
  "title": "Secure",
  "description": "Learn about various security-related issues, such as handling tokens, preventing security attacks, AllowListing, data privacy, and Auth0 security bulletins",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/ionic-angular/interactive",
  "markdown": "# Auth0 Ionic & Capacitor (Angular) SDK Quickstarts: Add login to your Ionic Angular with Capacitor app\n\nTo use Auth0 services, you need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for your project.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Configure Allowed Origins\n\nTo be able to make requests from your native application to Auth0, set the following **Allowed Origins** in your [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\nLastly, be sure that the **Application Type** for your application is set to **Native** in the [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).",
  "title": "Auth0 Ionic & Capacitor (Angular) SDK Quickstarts: Add login to your Ionic Angular with Capacitor app",
  "description": "This tutorial demonstrates how to add user login with Auth0 to an Ionic Angular & Capacitor application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/flutter/interactive",
  "markdown": "# Add login to your Flutter app\n\nTo use Auth0 services, you need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for your project.\n\n### Configure an Auth0 application\n\nUse the interactive selector to create a new Auth0 application or select an existing **Native** Auth0 application. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample app instead.\n\n### Configure the callback and logout URLs\n\nThe callback and logout URLs are the URLs that Auth0 invokes to redirect back to your app. Auth0 invokes the callback URL after authenticating the user, and the logout URL after removing the session cookie. If the callback and logout URLs are not set, users will be unable to log in and out of the app and will get an error.\n\nSet the callback and logout URLs to the following values, depending on your platform.\n\n#### Android\n\n```\nSCHEME://{yourDomain}/android/YOUR_PACKAGE_NAME/callback\n```\n\n#### iOS\n\n```\nhttps://{yourDomain}/ios/YOUR_BUNDLE_IDENTIFIER/callback,\nYOUR_BUNDLE_IDENTIFIER://{yourDomain}/ios/YOUR_BUNDLE_IDENTIFIER/callback\n```\n\n#### macOS\n\n```\nhttps://{yourDomain}/macos/YOUR_BUNDLE_IDENTIFIER/callback,\nYOUR_BUNDLE_IDENTIFIER://{yourDomain}/macos/YOUR_BUNDLE_IDENTIFIER/callback\n```\n\nFor example, if your iOS bundle identifier were `com.example.MyApp` and your Auth0 domain were `example.us.auth0.com`, then this value would be:\n\n```\nhttps://example.us.auth0.com/ios/com.example.MyApp/callback,\ncom.example.MyApp://example.us.auth0.com/ios/com.example.MyApp/callback\n```",
  "title": "Auth0 Flutter SDK Quickstarts: Add login to your Flutter app",
  "description": "This tutorial demonstrates how to add user login with Auth0 to an Android, iOS, or macOS Flutter app using the Auth0 Flutter SDK",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/ionic-react/interactive",
  "markdown": "# Auth0 Ionic & Capacitor (React) SDK Quickstarts: Add login to your Ionic React with Capacitor app\n\nTo use Auth0 services, you need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for your project.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Configure Allowed Origins\n\nTo be able to make requests from your native application to Auth0, set the following **Allowed Origins** in your [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\nLastly, be sure that the **Application Type** for your application is set to **Native** in the [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).",
  "title": "Auth0 Ionic & Capacitor (React) SDK Quickstarts: Add login to your Ionic React with Capacitor app",
  "description": "This tutorial demonstrates how to add user login with Auth0 to an Ionic React & Capacitor application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/ionic-vue/interactive",
  "markdown": "# Auth0 Ionic & Capacitor (Vue) SDK Quickstarts: Add login to your Ionic Vue with Capacitor app\n\nTo use Auth0 services, you need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for your project.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Configure Allowed Origins\n\nTo be able to make requests from your native application to Auth0, set the following **Allowed Origins** in your [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\nLastly, be sure that the **Application Type** for your application is set to **Native** in the [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).",
  "title": "Auth0 Ionic & Capacitor (Vue) SDK Quickstarts: Add login to your Ionic Vue with Capacitor app",
  "description": "This tutorial demonstrates how to add user login with Auth0 to an Ionic Vue & Capacitor application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/ios-swift/interactive",
  "markdown": "# Auth0 iOS / macOS SDK Quickstarts: Add Login to your iOS or macOS app\n\nThis guide demonstrates how to add authentication and access user profile information in any iOS / macOS app using the [Auth0.swift](https://github.com/auth0/Auth0.swift) SDK.\n\nTo use Auth0 services, you need an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the app you are developing.\n\n### Configure an Auth0 application\n\nUse the interactive selector to create a new Auth0 application or select an existing **Native** Auth0 application. Auth0 assigns every application an alphanumeric, unique Client ID that your app uses to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart automatically update your Auth0 application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample app instead.\n\n### Configure callback and logout URLs\n\nAuth0 invokes the callback and logout URLs to redirect users back to your app. Auth0 invokes the callback URL after authenticating the user and the logout URL after removing the session cookie. If you do not set the callback and login URLs, users will not be able to log in and out of the app, and your app will produce an error.\n\nAdd the following URLs to **Callback URLs** and **Logout URLs**, depending on the platform of your app. If you have a [custom domain](https://auth0.com/docs/customize/custom-domains), use this instead of your Auth0 tenant’s domain.\n\n#### iOS\n\n```\nhttps://{yourDomain}/ios/YOUR_BUNDLE_IDENTIFIER/callback,\nYOUR_BUNDLE_IDENTIFIER://{yourDomain}/ios/YOUR_BUNDLE_IDENTIFIER/callback\n```\n\n#### macOS\n\n```\nhttps://{yourDomain}/macos/YOUR_BUNDLE_IDENTIFIER/callback,\nYOUR_BUNDLE_IDENTIFIER://{yourDomain}/macos/YOUR_BUNDLE_IDENTIFIER/callback\n```\n\nFor example, if your iOS bundle identifier was `com.example.MyApp` and your Auth0 domain was `example.us.auth0.com`, then this value would be:\n\n```\nhttps://example.us.auth0.com/ios/com.example.MyApp/callback,\ncom.example.MyApp://example.us.auth0.com/ios/com.example.MyApp/callback\n```\n\n### Configure the associated domain\n\n#### Configure the Team ID and bundle identifier\n\nGo to the [settings page](https://manage.auth0.com/#/applications/{yourClientId}/settings) of your Auth0 application, scroll to the end, and open **Advanced Settings > Device Settings**. In the **iOS** section, set **Team ID** to your [Apple Team ID](https://developer.apple.com/help/account/manage-your-team/locate-your-team-id/), and **App ID** to your app's bundle identifier.\n\n![Screenshot of the iOS section inside the Auth0 application settings page](https://auth0.com/docs/media/articles/native-platforms/ios-swift/ios-device-settings.png)\n\nThis will add your app to your Auth0 tenant's `apple-app-site-association` file.\n\n#### Add the associated domain capability\n\nIn Xcode, go to the **Signing and Capabilities** [tab](https://developer.apple.com/documentation/xcode/adding-capabilities-to-your-app#Add-a-capability) of your app's target settings, and press the **\\+ Capability** button. Then select **Associated Domains**.\n\n![Screenshot of the capabilities library inside Xcode](https://auth0.com/docs/media/articles/native-platforms/ios-swift/ios-xcode-capabilities.png)\n\nNext, add the following [entry](https://developer.apple.com/documentation/xcode/configuring-an-associated-domain#Define-a-service-and-its-associated-domain) under **Associated Domains**:\n\n```\nwebcredentials:{yourDomain}\n```\n\nIf you have a [custom domain](https://auth0.com/docs/customize/custom-domains), use this instead of your Auth0 tenant’s domain.\n\n### Using the Swift Package Manager\n\nOpen the following menu item in Xcode:\n\n**File > Add Package Dependencies...**\n\nIn the **Search or Enter Package URL** search box enter this URL:\n\n```\nhttps://github.com/auth0/Auth0.swift\n```\n\nThen, select the dependency rule and press **Add Package**.\n\n### Using Cocoapods\n\nAdd the following line to your `Podfile`:\n\nThen, run `pod install`.\n\n### Using Carthage\n\nAdd the following line to your `Cartfile`:\n\n```\ngithub \"auth0/Auth0.swift\" ~> 2.0\n```\n\nThen, run `carthage bootstrap --use-xcframeworks`.\n\nThe Auth0.swift SDK needs your Auth0 **domain** and **Client ID**. You can find these values in the [settings page](https://manage.auth0.com/#/applications/{yourClientId}/settings) of your Auth0 application.\n\n*   **domain**: The domain of your Auth0 tenant. If you have a [custom domain](https://auth0.com/docs/customize/custom-domains), use this instead of your Auth0 tenant’s domain.\n*   **Client ID**: The alphanumeric, unique ID of the Auth0 application you set up earlier in this quickstart.\n\nCreate a `plist` file named `Auth0.plist` in your app bundle containing the Auth0 domain and Client ID values.\n\n##### Checkpoint\n\nYou configured the Auth0.swift SDK. Run your app to verify that it is not producing any errors related to the SDK.\n\nImport the `Auth0` module in the file where you want to present the login page. Then, present the [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) page in the action of your **Login** button.\n\n![Screenshot of the Universal Login page](https://auth0.com/docs/media/articles/native-platforms/ios-swift/login-ios.png)\n\n##### Checkpoint\n\nPress the **Login** button and verify that:\n\n*   An [alert box](https://github.com/auth0/Auth0.swift#sso-alert-box-ios--macos) shows up asking for consent.\n*   Choosing **Continue** opens the Universal Login page in a Safari modal.\n*   You can log in or sign up using a username and password or a social provider.\n*   The Safari modal closes automatically afterward.\n\nNow that you can log in to your app, you need a way to [log out](https://auth0.com/docs/authenticate/login/logout). In the action of your **Logout** button, call the `clearSession()` method to clear the Universal Login session cookie.\n\n##### Checkpoint\n\nPress the **Logout** button and verify that:\n\n*   An alert box shows up asking for consent.\n*   Choosing **Continue** opens a page in a Safari modal.\n*   The Safari modal closes automatically soon after.\n\nThe `Credentials` instance you obtained after logging in includes an [ID token](https://auth0.com/docs/secure/tokens/id-tokens). The ID token contains the profile information associated with the logged-in user, such as their email and profile picture. You can use these details to personalize the user interface of your app.\n\nThe Auth0.swift SDK includes a [utility](https://github.com/auth0/JWTDecode.swift) for decoding [JWTs](https://jwt.io/) like the ID token. Start by importing the `JWTDecode` module in the file where you want to access the user profile information. Then, use the `decode(jwt:)` method to decode the ID token and access the claims it contains.\n\n##### Checkpoint\n\nVerify that you can access the `email`, `picture`, or any other [claim](https://auth0.com/docs/secure/tokens/id-tokens/id-token-structure) after you have logged in.",
  "title": "Auth0 iOS / macOS SDK Quickstarts: Add Login to your iOS or macOS app",
  "description": "This guide demonstrates how to add authentication and gain access to user profile information in any iOS / macOS app using the Auth0.swift SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/windows-uwp-csharp",
  "markdown": "# Auth0 UWP SDK Quickstarts: Login\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Native/Mobile App](https://auth0.com/docs/quickstart/native)\n*   [UWP](https://auth0.com/docs/quickstart/native/windows-uwp-csharp)\n\nThis tutorial demonstrates how to add user login to a UWP C# application using Auth0. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Microsoft Visual Studio 2017 | Windows 10 SDK (10.0.10586.0) | Auth0.OidcClient.UWP 2.3.1\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Integrate Auth0 in your Application\n\n### Install Dependencies\n\nUse the NuGet Package Manager Console (Tools -> NuGet Package Manager -> Package Manager Console) to install the `Auth0.OidcClient.UWP` package, running the command:\n\n```\nInstall-Package Auth0.OidcClient.UWP\n```\n\n## Trigger Authentication\n\nTo integrate Auth0 login into your application, simply instantiate an instance of the `Auth0Client` class, configuring the Auth0 Domain and Client ID:\n\n```\n// MainPage.xaml.cs\n\nusing Auth0.OidcClient;\n\nvar client = new Auth0Client(new Auth0ClientOptions\n{\n    Domain = \"{yourDomain}\",\n    ClientId = \"{yourClientId}\"\n});\n```\n\nYou can then call the `LoginAsync` method to log the user in:\n\n```\nvar loginResult = await client.LoginAsync();\n```\n\n![](https://auth0.com/docs/media/articles/native-platforms/windows-uwp-csharp/universal-login.png)\n\nThis will load the Auth0 login page into a web view. You can learn how to customize the login page in [this document](https://auth0.com/docs/universal-login#simple-customization).\n\n## Handle Authentication Tokens\n\nThe returned login result will indicate whether authentication was successful, and if so contain the tokens and claims of the user.\n\n### Authentication Error\n\nYou can check the `IsError` property of the result to see whether the login has failed. The `ErrorMessage` will contain more information regarding the error which occurred.\n\n```\nif (loginResult.IsError)\n{\n    Debug.WriteLine($\"An error occurred during login: {loginResult.Error}\")\n}\n```\n\n### Accessing the tokens\n\nOn successful login, the login result will contain the ID Token and Access Token in the `IdentityToken` and `AccessToken` properties respectively.\n\n```\nif (!loginResult.IsError)\n{\n    Debug.WriteLine($\"id_token: {loginResult.IdentityToken}\");\n    Debug.WriteLine($\"access_token: {loginResult.AccessToken}\");\n}\n```\n\n### Obtaining the User Information\n\nOn successful login, the login result will contain the user information in the `User` property, which is a [ClaimsPrincipal](https://msdn.microsoft.com/en-us/library/system.security.claims.claimsprincipal(v=vs.110).aspx).\n\nTo obtain information about the user, you can query the claims. You can for example obtain the user's name and email address from the `name` and `email` claims:\n\n```\nif (!loginResult.IsError)\n{\n    Debug.WriteLine($\"name: {loginResult.User.FindFirst(c => c.Type == \"name\")?.Value}\");\n    Debug.WriteLine($\"email: {loginResult.User.FindFirst(c => c.Type == \"email\")?.Value}\");\n}\n```\n\nYou can obtain a list of all the claims contained in the ID Token by iterating through the `Claims` collection:\n\n```\nif (!loginResult.IsError)\n{\n    foreach (var claim in loginResult.User.Claims)\n    {\n        Debug.WriteLine($\"{claim.Type} = {claim.Value}\");\n    }\n}\n```\n\n## Logout\n\nTo log the user out call the `LogoutAsync` method.\n\n```\nawait client.LogoutAsync();\n```",
  "title": "Auth0 UWP SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to a UWP C# application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/maui/interactive",
  "markdown": "# Add login to your .NET MAUI application\n\nAuth0 allows you to add authentication to almost any application type quickly. This guide demonstrates how to integrate Auth0, add authentication, and display user profile information in any .NET MAUI application using the Auth0 SDKs for [MAUI](https://www.nuget.org/packages/Auth0.OidcClient.MAUI/).\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\nAuth0 provides a [MAUI](https://www.nuget.org/packages/Auth0.OidcClient.MAUI/) SDK to simplify the process of implementing Auth0 authentication in MAUI applications.\n\nUse the NuGet Package Manager (Tools -> Library Package Manager -> Package Manager Console) to install the `Auth0.OidcClient.MAUI` package.\n\nAlternatively, you can use the Nuget Package Manager Console (`Install-Package`) or the `dotnet` CLI (`dotnet add`).\n\n```\nInstall-Package Auth0.OidcClient.MAUI\n```\n\n```\ndotnet add package Auth0.OidcClient.MAUI\n```\n\nYou need some platform-specific configuration to use the SDK with Android and Windows.\n\n### Android\n\nCreate a new Activity that extends `WebAuthenticatorCallbackActivity`:\n\n```\n[Activity(NoHistory = true, LaunchMode = LaunchMode.SingleTop, Exported = true)]\n[IntentFilter(new[] { Intent.ActionView },\n              Categories = new[] { Intent.CategoryDefault, Intent.CategoryBrowsable },\n              DataScheme = CALLBACK_SCHEME)]\npublic class WebAuthenticatorActivity : Microsoft.Maui.Authentication.WebAuthenticatorCallbackActivity\n{\n    const string CALLBACK_SCHEME = \"myapp\";\n}\n```\n\nThe above activity will ensure the application can handle the `myapp://callback` URL when Auth0 redirects back to the Android application after logging in.\n\n### Windows\n\nTo make sure it can properly reactivate your application after being redirected back to Auth0, you need to do two things:\n\n*   Add the corresponding protocol to the `Package.appxmanifest`. In this case, this is set to `myapp`, but you can change this to whatever you like (ensure to update all relevant Auth0 URLs as well).\n    \n    ```\n    <Applications>\n      <Application Id=\"App\" Executable=\"$targetnametoken$.exe\" EntryPoint=\"$targetentrypoint$\">\n        <Extensions>\n          <uap:Extension Category=\"windows.protocol\">\n            <uap:Protocol Name=\"myapp\"/>\n          </uap:Extension>\n        </Extensions>\n      </Application>\n    </Applications>\n    ```\n    \n*   Call `Activator.Default.CheckRedirectionActivation()` in the Windows-specific `App.xaml.cs` file.\n    \n    ```\n    public App()\n    {\n      if (Auth0.OidcClient.Platforms.Windows.Activator.Default.CheckRedirectionActivation())\n        return;\n    \n      this.InitializeComponent();\n    }\n    ```\n    \n\nTo integrate Auth0 into your application, instantiate an instance of the `Auth0Client` class, passing an instance of `Auth0ClientOptions` that contains your Auth0 Domain, Client ID and the required Scopes. Additionally, you also need to configure the `RedirectUri` and `PostLogoutRedirectUri` to ensure Auth0 can redirect back to the application using the URL(s) configured.\n\n```\nusing Auth0.OidcClient;\n\nvar client = new Auth0Client(new Auth0ClientOptions\n{\n    Domain = \"{yourDomain}\",\n    ClientId = \"{yourClientId}\",\n    RedirectUri = \"myapp://callback\",\n    PostLogoutRedirectUri = \"myapp://callback\",\n    Scope = \"openid profile email\"\n});\n```\n\nBy default, the SDK will leverage Chrome Custom Tabs for Android, ASWebAuthenticationSession for iOS and macOS and use your system's default browser on Windows.\n\n##### Checkpoint\n\nYour `Auth0Client` should now be properly instantiated. Run your application to verify that:\n\n*   the `Auth0Client` is instantiated correctly in the `MainPage`.\n*   your application is not throwing any errors related to Auth0\n\nNow that you have configured your Auth0 Application and the Auth0 SDK, you need to set up login for your project. To do this, you will use the SDK’s `LoginAsync()` method to create a login button that redirects users to the Auth0 Universal Login page.\n\n```\nvar loginResult = await client.LoginAsync();\n```\n\nIf there isn't any error, you can access the `User`, `IdentityToken`, `AccessToken` and `RefreshToken` on the `LoginResult` returned from `LoginAsync()`.\n\n##### Checkpoint\n\nYou should now be able to log in or sign up using a username and password.\n\nClick the login button and verify that:\n\n*   your application redirects you to the Auth0 Universal Login page\n*   you can log in or sign up\n*   Auth0 redirects you to your application.\n\nUsers who log in to your project will also need a way to log out. Create a logout button using the SDK’s `LogoutAsync()` method. When users log out, they will be redirected to your Auth0 logout endpoint, which will then immediately redirect them back to the logout URL you set up earlier in this quickstart.\n\n```\nawait client.LogoutAsync();\n```\n\n##### Checkpoint\n\nRun your application and click the logout button, verify that:\n\n*   your application redirects you to the address you specified as one of the Allowed Logout URLs in your Application Settings\n*   you are no longer logged in to your application\n\nNow that your users can log in and log out, you will likely want to be able to retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with authenticated users. For example, you may want to be able to display a logged-in user’s name or profile picture in your project.\n\nThe Auth0 SDK for MAUI provides user information through the `LoginResult.User` property.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [auth0-oidc-client-net SDK](https://github.com/auth0/auth0-oidc-client-net) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 MAUI SDK Quickstarts: Add login to your .NET MAUI application",
  "description": "This tutorial demonstrates how to add user login with Auth0 to a .NET MAUI application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/wpf-winforms/interactive",
  "markdown": "# Auth0 WPF / Winforms SDK Quickstarts: Add login to your WinForms and WPF application\n\nAuth0 allows you to add authentication to almost any application type quickly. This guide demonstrates how to integrate Auth0, add authentication, and display user profile information in any WPF and WinForms application using the Auth0 SDKs for [WPF](https://www.nuget.org/packages/Auth0.OidcClient.WPF/) and [WinForms](https://www.nuget.org/packages/Auth0.OidcClient.WinForms).\n\nTo use this quickstart, you’ll need to:\n\n*   Sign up for a free Auth0 account or log in to Auth0.\n*   Have a working WPF or WinForms project that you want to integrate with. Alternatively, you can view or download a sample application after logging in.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\nAuth0 provides a [WPF](https://www.nuget.org/packages/Auth0.OidcClient.WPF/) and [WinForms](https://www.nuget.org/packages/Auth0.OidcClient.WinForms) SDK to simplify the process of implementing Auth0 authentication in WPF and WinForms applications.\n\nUse the NuGet Package Manager (Tools -> Library Package Manager -> Package Manager Console) to install the `Auth0.OidcClient.WPF` or `Auth0.OidcClient.WinForms` package, depending on whether you are building a WPF or Windows Forms application.\n\nAlternatively, you can use the Nuget Package Manager Console (`Install-Package`) or the `dotnet` CLI (`dotnet add`).\n\n```\nInstall-Package Auth0.OidcClient.WPF\nInstall-Package Auth0.OidcClient.WinForms\n```\n\n```\ndotnet add Auth0.OidcClient.WPF\ndotnet add Auth0.OidcClient.WinForms\n```\n\nTo integrate Auth0 into your application, instantiate an instance of the Auth0Client class, passing an instance of Auth0ClientOptions that contains your Auth0 Domain and Client ID.\n\nBy default, the SDK will leverage [WebView2](https://learn.microsoft.com/en-us/microsoft-edge/webview2/) for .NET6 and above, while relying on the older WebView on applications using any version that predates .NET6.\n\n##### Checkpoint\n\nYour `Auth0Client` should now be properly instantiated. Run your application to verify that:\n\n*   the `Auth0Client` is instantiated correctly\n*   your application is not throwing any errors related to Auth0\n\nNow that you have configured your Auth0 Application and the Auth0 SDK, you need to set up login for your project. To do this, you will use the SDK’s `LoginAsync()` method to create a login button that redirects users to the Auth0 Universal Login page. After a user successfully authenticates, they will be redirected to the callback URL you set up earlier in this quickstart.\n\nIf there isn't any error, you can access the `User`, `IdentityToken`, `AccessToken` and `RefreshToken` on the `LoginResult` returned from `LoginAsync()`.\n\n##### Checkpoint\n\nYou should now be able to log in or sign up using a username and password.\n\nClick the login button and verify that:\n\n*   your WPF or WinForms Application redirects you to the Auth0 Universal Login page\n*   you can log in or sign up\n*   Auth0 redirects you to your application.\n\nUsers who log in to your project will also need a way to log out. Create a logout button using the SDK’s `LogoutAsync()` method. When users log out, they will be redirected to your Auth0 logout endpoint, which will then immediately redirect them back to the logout URL you set up earlier in this quickstart.\n\n##### Checkpoint\n\nRun your application and click the logout button, verify that:\n\n*   your WPF or WinForms application redirects you to the address you specified as one of the Allowed Logout URLs in your Application Settings\n*   you are no longer logged in to your application\n\nNow that your users can log in and log out, you will likely want to be able to retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with authenticated users. For example, you may want to be able to display a logged-in user’s name or profile picture in your project.\n\nThe Auth0 SDK for WPF and WinForms provides user information through the `LoginResult.User` property.\n\n##### Checkpoint\n\nVerify that:\n\n*   you can display the user's name or any other user property after you have logged in\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [auth0-oidc-client-net SDK](https://github.com/auth0/auth0-oidc-client-net) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 WPF / Winforms SDK Quickstarts: Add login to your WinForms and WPF application",
  "description": "This tutorial demonstrates how to add user login with Auth0 to a WPF and WinForms application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/react-native/interactive",
  "markdown": "# Add Login to your React Native App\n\n## Add Login to Your React Native Application\n\nThis Quickstart is for the React Native framework. To integrate Auth0 into your Expo application, please refer to the [Expo Quickstart](https://auth0.com/docs/quickstart/native/react-native-expo/interactive)\n\nTo use Auth0 services, you must have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure authentication in your project.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nTo explore a complete configuration, review the sample application in your Dashboard.\n\n### Configure callback and logout URLs\n\nAuth0 invokes the callback and logout URLs to redirect users back to your application. Auth0 invokes the callback URL after authenticating the user and the logout URL after removing the session cookie. If you do not set the callback and logout URLs, users will not be able to log in and out of the app, and your application will produce an error.\n\nAdd the corresponding URL to **Callback URLs** and **Logout URLs**, according to your app's platform. If you are using a [custom domain](https://auth0.com/docs/customize/custom-domains), use the value of your custom domain instead of your Auth0 tenant’s domain.\n\n#### iOS\n\n```\nBUNDLE_IDENTIFIER.auth0://{yourDomain}/ios/BUNDLE_IDENTIFIER/callback\n```\n\n#### Android\n\n```\nPACKAGE_NAME.auth0://{yourDomain}/android/PACKAGE_NAME/callback\n```\n\nIn this section, you will install the React Native Auth0 module.\n\n### Yarn\n\n```\nyarn add react-native-auth0\n```\n\n### npm\n\n```\nnpm install react-native-auth0 --save\n```\n\n### Additional iOS step: install the module Pod\n\nOur SDK requires a minimum iOS deployment target of 13.0. In your project's \\`ios/Podfile\\`\\`, ensure your platform target is set to 13.0.\n\nCocoaPods is the iOS package management tool the React Native framework uses to install itself into your project. For the iOS native module to work with your iOS app, first install the library Pod. If you're familiar with older React Native SDK versions, this is similar to the previous _linking a native module_. The process is now simplified:\n\nChange directory into the `ios` folder and run `pod install`.\n\nFirst, you must provide a way for your users to log in. We recommend using the Auth0 hosted [login page](https://auth0.com/docs/hosted-pages/login).\n\n![Universal Login](https://auth0.com/docs/media/articles/native-platforms/ios-swift/login-ios.png)\n\n### Configure Android\n\nOpen the `build.gradle` file in your application directory (typically at `android/app/build.gradle`) and add the following manifest placeholders. The value for `auth0Domain` should contain your Auth0 application settings [as configured above](#get-your-application-keys).\n\n```\nandroid {\n    defaultConfig {\n        // Add the next line\n        manifestPlaceholders = [auth0Domain: \"{yourDomain}\", auth0Scheme: \"${applicationId}.auth0\"]\n    }\n    ...\n}\n```\n\n### Configure iOS\n\nIn the file `ios/<YOUR PROJECT>/AppDelegate.mm` add the following:\n\n```\n#import <React/RCTLinkingManager.h>\n\n- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url\n            options:(NSDictionary<UIApplicationOpenURLOptionsKey, id> *)options\n{\n  return [RCTLinkingManager application:app openURL:url options:options];\n}\n```\n\nNext, add a URLScheme using your App's bundle identifier.\n\nIn the `ios` folder, open the `Info.plist` and locate the value for `CFBundleIdentifier`\n\n```\n<key>CFBundleIdentifier</key>\n<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>\n```\n\nBelow this value, register a URL type entry using the value of `CFBundleIdentifier` as the value for the `CFBundleURLSchemes`.\n\n```\n<key>CFBundleURLTypes</key>\n<array>\n    <dict>\n        <key>CFBundleTypeRole</key>\n        <string>None</string>\n        <key>CFBundleURLName</key>\n        <string>auth0</string>\n        <key>CFBundleURLSchemes</key>\n        <array>\n            <string>$(PRODUCT_BUNDLE_IDENTIFIER).auth0</string>\n        </array>\n    </dict>\n</array>\n```\n\nIn a later step, you will use this value to define the callback URLs below. You can change it using XCode with the following steps:\n\n*   Open the `ios/<YOUR PROJECT>.xcodeproj` file or run `xed ios` on a Terminal from the app root.\n*   Open your project's or desired target's Build Settings tab and find the section that contains \"Bundle Identifier\".\n*   Replace the \"Bundle Identifier\" value with your desired application's bundle identifier name.\n\nFor additional information please read [react native docs](https://facebook.github.io/react-native/docs/linking).\n\nThe `useAuth0` hook relies on a React Context to provide state management. The `Auth0Provider` component provides this context.\n\nImport the `useAuth0` hook and `Auth0Provider` component from the `react-native-auth0` package:\n\n```\nimport {useAuth0, Auth0Provider} from 'react-native-auth0';\n```\n\nFor the SDK to function correctly, wrap your application in the `Auth0Provider` component and set the following properties:\n\n*   `domain`: The domain of your Auth0 tenant. Generally, you can find this in the Auth0 Dashboard under your Application's Settings in the Domain field. If you are using a [custom domain](https://auth0.com/docs/custom-domains), you should set this to the value of your custom domain instead.\n*   `clientId`: The ID of the Auth0 Application you set up earlier in this quickstart. You can find this in the Auth0 Dashboard under your Application's Settings in the Client ID field.\n\n##### Checkpoint\n\nYou just configured the `Auth0Provider` component. Run your application to verify that:\n\n*   the SDK is initializing correctly\n*   your application is not throwing any errors related to Auth0\n\nAuthenticate the user by calling the `authorize` method provided by the `useAuth0` hook. This method redirects the user to the Auth0 [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) page for authentication, then back to your app.\n\nTo confirm the user successfully logged in, check that the `user` property provided by the hook is not `null`.\n\n##### Checkpoint\n\nAdd a button component that calls `authorize` when clicked. Verify that you are redirected to the login page and then back to your application.\n\nTo log the user out, redirect them to the Auth0 log out endpoint by calling `clearSession`. This will remove their session from the authorization server and log the user out of the application.\n\n##### Checkpoint\n\nAdd a button that calls `clearSession` and observe that you are redirected to the Auth0 logout endpoint and back again. You should no longer be logged in to your application.\n\nThe `useAuth0` hook exposes a `user` object that contains information about the authenticated user. You can use this to access decoded user profile information about the authenticated user from the [ID token](https://auth0.com/docs/secure/tokens/id-tokens).\n\nIf a user has not been authenticated, this property will be `null`.\n\n##### Checkpoint\n\nLog in and inspect the `user` property on the result. Verify the current user's profile information, such as `email` or `name`.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [react-native-auth0 SDK](https://github.com/auth0/react-native-auth0) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 React Native SDK Quickstarts: Add Login to your React Native App",
  "description": "This quickstart demonstrates how to add user login to an React Native application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/apache",
  "markdown": "# Auth0 Apache SDK Quickstarts: Login\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Regular Web App](https://auth0.com/docs/quickstart/webapp)\n*   [Apache](https://auth0.com/docs/quickstart/webapp/apache)\n\nThis tutorial demonstrates how to use the Auth0 Apache SDK to add authentication and authorization to your web app. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### System Requirements\n\nThis tutorial and seed project have been tested with the following:\n\n*   Apache 2.4\n\n**Please follow the steps below to configure your application using Apache to work with Auth0 and Open ID Connect.**\n\n## Install and Enable mod\\_auth\\_openidc Module\n\nFirst, you need to install the `mod_auth_openidc` module for Apache.\n\nYou can get the binaries from [Github](https://github.com/zmartzone/mod_auth_openidc/releases) and install them for your OS. If your OS isn't compatible with any of the binaries, you can still [build it from source](https://github.com/zmartzone/mod_auth_openidc/blob/master/INSTALL)\n\nOnce you've installed it, you just need to enable it for Apache (If you are using Windows, you can use [this](https://github.com/enderandpeter/win-a2enmod#installation) to get `a2enmod` working on your system)\n\n## Configure the Module with Your Auth0 Account Information\n\nNow you should get a new configuration file under the `/etc/apache2/mods-available` folder, where Apache modules are normally installed (On Windows you need to use `/apache/conf/httpd.conf` file).\n\nIn there, you must add the following configuration for the `mod_auth_openidc` module\n\n```\n# mods-available/auth_openidc.conf\n\nOIDCProviderMetadataURL https://{yourDomain}/.well-known/openid-configuration\nOIDCClientID {yourClientId}\nOIDCClientSecret 'YOUR_CLIENT_SECRET'\n\nOIDCScope \"openid name email\"\nOIDCRedirectURI https://your_apache_server/your_path/redirect_uri/\nOIDCCryptoPassphrase <passwordToEncryptTheSessionInformationOnTheCookie>\n\n<Location /your_path>\n   AuthType openid-connect\n   Require valid-user\n   LogLevel debug\n</Location>\n```\n\n## Configuring Auth0 Settings\n\nIn your application settings add a new allowed callback which is equal to `OIDCRedirectURI`.\n\nNow, go to OAuth section in advanced settings and change `JsonWebToken Token Signature Algorithm` to RS256.\n\n## Authorization\n\nYou can configure Apache to protect a certain location based on an attribute of the user. Here is an example:\n\n```\n# mods-available/auth_openidc.conf\n\n<Location /example>\n   AuthType openid-connect\n   #Require valid-user\n   Require claim folder:example\n</Location>\n\n<Location /example2>\n   AuthType openid-connect\n   #Require valid-user\n   Require claim folder:example2\n</Location>\n```\n\nThen you can write a rule in Auth0 that would return the `folder` attribute:\n\n```\nfunction(user, context, callback) {\n    if (somecondition()) {\n       user.folder = 'example2';\n    }\n\n   user.folder = 'example';\n}\n```\n\nOr you could even use an array of folders and the apache module will check if the array contains any of these values\n\n```\nfunction(user, context, callback) {\n    user.folders = [];\n    if (somecondition()) {\n       user.folders.push('example2');\n    }\n\n   user.folders.push('example');\n}\n```",
  "title": "Auth0 Apache SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to use the Auth0 Apache SDK to add authentication and authorization to your web app.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/xamarin/interactive",
  "markdown": "# Auth0 .NET Android and iOS SDK Quickstarts: Add login to your .NET Android or iOS application\n\nAuth0 allows you to add authentication to almost any application type quickly. This guide demonstrates how to integrate Auth0, add authentication, and display user profile information in any .NET Android and iOS application using the Auth0 SDKs for [Android](https://www.nuget.org/packages/Auth0.OidcClient.AndroidX/) and [iOS](https://www.nuget.org/packages/Auth0.OidcClient.iOS).\n\nTo use this quickstart, you’ll need to:\n\n*   Sign up for a free Auth0 account or log in to Auth0.\n*   Have a working Android or iOS project using .NET 6 (or above) that you want to integrate with. Alternatively, you can view or download a sample application after logging in.\n\nTo use Auth0 services, you need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for your project.\n\n### Configure an application\n\nUse the interactive selector to create a new \"Native Application\", or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\nLastly, be sure that the **Application Type** for your application is set to **Native** in the [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\nAuth0 provides an [Android](https://www.nuget.org/packages/Auth0.OidcClient.AndroidX/) and [iOS](https://www.nuget.org/packages/Auth0.OidcClient.iOS) SDK to simplify the process of implementing Auth0 authentication in .NET Android and iOS applications.\n\nUse the NuGet Package Manager (Tools -> Library Package Manager -> Package Manager Console) to install the `Auth0.OidcClient.AndroidX` or `Auth0.OidcClient.iOS` package, depending on whether you are building an Android or iOS application.\n\nAlternatively, you can use the Nuget Package Manager Console (`Install-Package`) or the `dotnet` CLI (`dotnet add`).\n\n```\nInstall-Package Auth0.OidcClient.AndroidX\nInstall-Package Auth0.OidcClient.iOS\n```\n\n```\ndotnet add Auth0.OidcClient.AndroidX\ndotnet add Auth0.OidcClient.iOS\n```\n\nTo integrate Auth0 into your application, instantiate an instance of the `Auth0Client` class, passing an instance of `Auth0ClientOptions` that contains your Auth0 Domain and Client ID.\n\n```\nusing Auth0.OidcClient;\n\nvar client = new Auth0Client(new Auth0ClientOptions\n{\n    Domain = \"{yourDomain}\",\n    ClientId = \"{yourDomain}\"\n}, this);\n```\n\nBy default, the SDK will leverage Chrome Custom Tabs for Android and ASWebAuthenticationSession for iOS.\n\n##### Checkpoint\n\nYour `Auth0Client` should now be properly instantiated. Run your application to verify that:\n\n*   the `Auth0Client` is instantiated correctly in the `Activity` (Android) or `UIViewController` (iOS)\n*   your application is not throwing any errors related to Auth0\n\nAfter a user successfully authenticates, they will be redirected to the callback URL you set up earlier in this quickstart.\n\nTo handle the callback on Android devices, you need to register an intent that handles this callback URL. An easy way to do this is to register the intent on the same activity from which you called the LoginAsync method to instantiate the authentication flow.\n\nEnsure to replace `YOUR_ANDROID_PACKAGE_NAME` in the code sample with the actual Package Name for your application, such as com.mycompany.myapplication, and ensure that all the text for the `DataScheme`, `DataHost`, and `DataPathPrefix` is in lower case. Also, set `LaunchMode = LaunchMode.SingleTask` for the Activity, otherwise the system will create a new instance of the activity every time the Callback URL gets called.\n\nAdditionally, you need to handle the intent in the `OnNewIntent` event in your `Activity` class. You need to notify the Auth0 OIDC Client to finish the authentication flow by calling the `Send` method of the `ActivityMediator` singleton, passing along the URL that was sent in.\n\nAfter a user successfully authenticates, they will be redirected to the callback URL you set up earlier in this quickstart.\n\nTo handle the callback on iOS devices:\n\n*   Open your application's `Info.plist` file in Visual Studio, and go to the **Advanced** tab.\n*   Under **URL Types**, click the **Add URL Type** button\n*   Set the **Identifier** as Auth0, the **URL Schemes** the same as your application's Bundle Identifier, and the **Role** as None\n\nThis is an example of the XML representation of your `info.plist` file after you have added the URL Type:\n\n```\n<key>CFBundleURLTypes</key>\n<array>\n    <dict>\n        <key>CFBundleTypeRole</key>\n        <string>None</string>\n        <key>CFBundleURLName</key>\n        <string>Auth0</string>\n        <key>CFBundleURLSchemes</key>\n        <array>\n            <string>YOUR_BUNDLE_IDENTIFIER</string>\n        </array>\n    </dict>\n</array>\n```\n\nAdditionally, you need to handle the Callback URL in the `OpenUrl` event in your `AppDelegate` class. You need to notify the Auth0 OIDC Client to finish the authentication flow by calling the `Send` method of the `ActivityMediator` singleton, passing along the URL that was sent in.\n\nNow that you have configured your Auth0 Application and the Auth0 SDK, you need to set up login for your project. To do this, you will use the SDK’s `LoginAsync()` method to create a login button that redirects users to the Auth0 Universal Login page.\n\n```\nvar loginResult = await client.LoginAsync();\n```\n\nIf there isn't any error, you can access the `User`, `IdentityToken`, `AccessToken` and `RefreshToken` on the `LoginResult` returned from `LoginAsync()`.\n\n##### Checkpoint\n\nYou should now be able to log in or sign up using a username and password.\n\nClick the login button and verify that:\n\n*   your Android or iOS application redirects you to the Auth0 Universal Login page\n*   you can log in or sign up\n*   Auth0 redirects you to your application.\n\nUsers who log in to your project will also need a way to log out. Create a logout button using the SDK’s `LogoutAsync()` method. When users log out, they will be redirected to your Auth0 logout endpoint, which will then immediately redirect them back to the logout URL you set up earlier in this quickstart.\n\n```\nawait client.LogoutAsync();\n```\n\n##### Checkpoint\n\nRun your application and click the logout button, verify that:\n\n*   your Android or iOS application redirects you to the address you specified as one of the Allowed Logout URLs in your Application Settings\n*   you are no longer logged in to your application\n\nNow that your users can log in and log out, you will likely want to be able to retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with authenticated users. For example, you may want to be able to display a logged-in user’s name or profile picture in your project.\n\nThe Auth0 SDK for Android and iOS provides user information through the `LoginResult.User` property.\n\n```\nif (loginResult.IsError == false)\n{\n    var user = loginResult.User;\n    var name = user.FindFirst(c => c.Type == \"name\")?.Value;\n    var email = user.FindFirst(c => c.Type == \"email\")?.Value;\n    var picture = user.FindFirst(c => c.Type == \"picture\")?.Value;\n}\n```\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [auth0-oidc-client-net SDK](https://github.com/auth0/auth0-oidc-client-net) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 .NET Android and iOS SDK Quickstarts: Add login to your .NET Android or iOS application",
  "description": "This tutorial demonstrates how to add user login with Auth0 to a .NET Android or iOS application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/aspnet-core/interactive",
  "markdown": "# Auth0 ASP.NET Core MVC SDK Quickstarts: Add Login to your ASP.NET MVC application\n\nAuth0 allows you to quickly add authentication and gain access to user profile information in your application. This guide demonstrates how to integrate Auth0 with any new or existing ASP.NET MVC application using the **Auth0.AspNetCore.Authentication** SDK.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Install from Nuget\n\nTo integrate Auth0 with ASP.NET Core you can use our SDK by installing the `Auth0.AspNetCore.Authentication` [Nuget package](https://www.nuget.org/packages/Auth0.AspNetCore.Authentication/) to your application.\n\n```\nInstall-Package Auth0.AspNetCore.Authentication\n```\n\n### Configure the middleware\n\nTo enable authentication in your ASP.NET Core application, use the middleware provided by the SDK. Go to the `Program.cs` file and call `builder.Services.AddAuth0WebAppAuthentication()` to register the SDK's middleware.\n\nEnsure to configure the `Domain` and `ClientId`, these are required fields to ensure the SDK knows which Auth0 tenant and application it should use.\n\nMake sure you have enabled authentication and authorization in your `Program.cs` file.\n\nTo allow users to login to your ASP.NET MVC application, add a `Login` action to your controller.\n\nCall `HttpContext.ChallengeAsync()` and pass `Auth0Constants.AuthenticationScheme` as the authentication scheme. This will invoke the OIDC authentication handler that our SDK registers internally. Be sure to also specify the corresponding `authenticationProperties`, which you can construct using the `LoginAuthenticationPropertiesBuilder`.\n\nAfter succesfully calling `HttpContext.ChallengeAsync()`, the user will be redirected to Auth0 and signed in to both the OIDC middleware and the cookie middleware upon being redirected back to your application. This will allow the users to be authenticated on subsequent requests.\n\n##### Checkpoint\n\nNow that you have configured Login, run your application to verify that:\n\n*   Navigating to your `Login` action will redirect to Auth0\n*   Entering your credentials will redirect you back to your application.\n\nAfter the middleware has successfully retrieved the tokens from Auth0, it will extract the user's information and claims from the ID Token and makes them available as the `User.Claims` property on the controller.\n\nYou can create a custom user profile page for displaying a user's name, email address, and profile image, by retrieving the corresponding information from the `User` and pass it to the view from inside your controller.\n\n##### Checkpoint\n\nNow that you have set up your action to render the user's profile, run your application to verify that:\n\n*   Navigating to your `Profile` action after being succesfully logged in, shows the user's profile.\n\nLogging out the user from your own application can be done by calling `HttpContext.SignOutAsync` with the `CookieAuthenticationDefaults.AuthenticationScheme` authentication scheme from inside your controller's action.\n\nAdditionaly, If you also want to log the user out from Auth0 (this _might_ also log them out of other applications that rely on Single Sign On), call `HttpContext.SignOutAsync` with the `Auth0Constants.AuthenticationScheme` authentication scheme as well as the appropriate `authenticationProperties` that can be constructed using the `LogoutAuthenticationPropertiesBuilder`.\n\n##### Checkpoint\n\nNow that you have configured Logout, run your application to verify that:\n\n*   Navigating to your `Logout` action will ensure the user is logged out.\n*   When also logging out from Auth0, you should be redirected to Auth0 and instantly redirected back to your own application.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [auth0-aspnetcore-authentication SDK](https://github.com/auth0/auth0-aspnetcore-authentication) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 ASP.NET Core MVC SDK Quickstarts: Add Login to your ASP.NET MVC application",
  "description": "This tutorial demonstrates how to add user login to an ASP.NET Core application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/aspnet-core-blazor-server/interactive",
  "markdown": "# Auth0 ASP.NET Core Blazor Server SDK Quickstarts: Add Login to your ASP.NET Core Blazor Server application\n\nAuth0 allows you to quickly add authentication and gain access to user profile information in your application. This guide demonstrates how to integrate Auth0 with any new or existing Blazor Server application using the **Auth0.AspNetCore.Authentication** SDK.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Install from Nuget\n\nTo integrate Auth0 with Blazor Server you can use our SDK by installing the `Auth0.AspNetCore.Authentication` [Nuget package](https://www.nuget.org/packages/Auth0.AspNetCore.Authentication/) to your application.\n\n```\nInstall-Package Auth0.AspNetCore.Authentication\n```\n\n### Configure the middleware\n\nTo enable authentication in your Blazor Server application, use the middleware provided by the SDK. Go to the `Program.cs` file and call `builder.Services.AddAuth0WebAppAuthentication()` to register the SDK's middleware.\n\nEnsure to configure the `Domain` and `ClientId`, these are required fields to ensure the SDK knows which Auth0 tenant and application it should use.\n\nMake sure you have enabled authentication and authorization in your `Program.cs` file.\n\nTo allow users to login to your Blazor Server application, add a `LoginModel` to your `Pages` directory.\n\nInside the `LoginModel`'s `OnGet` method, call `HttpContext.ChallengeAsync()` and pass `Auth0Constants.AuthenticationScheme` as the authentication scheme. This will invoke the OIDC authentication handler that our SDK registers internally. Be sure to also specify the corresponding `authenticationProperties`, which you can construct using the `LoginAuthenticationPropertiesBuilder`.\n\nAfter successfully calling `HttpContext.ChallengeAsync()`, the user will be redirected to Auth0 and signed in to both the OIDC middleware and the cookie middleware upon being redirected back to your application. This will allow the users to be authenticated on subsequent requests.\n\n##### Checkpoint\n\nNow that you have configured Login, run your application to verify that:\n\n*   Navigating to your `Login` page will redirect to Auth0\n*   Entering your credentials will redirect you back to your application.\n\nAfter the middleware has successfully retrieved the tokens from Auth0, it will extract the user's information and claims from the ID Token and make them available through the `AuthenticationState`, which you can add as a `CascadingParameter`.\n\nYou can create a custom user profile page for displaying the user's name, as well as additional claims (such as email and picture), by retrieving the corresponding information from the `AuthenticationState`'s `User` property and passing it to the view from inside Blazor code.\n\n##### Checkpoint\n\nNow that you have set up to render the user's profile, run your application to verify that:\n\n*   Navigating to the endpoint containing the profile after being successfully logged in shows the user's profile.\n\nLogging out the user from your own application can be done by calling `HttpContext.SignOutAsync` with the `CookieAuthenticationDefaults.AuthenticationScheme` authentication scheme from inside a `LogoutModel`'s `OnGet` method.\n\nAdditionally, if you also want to log the user out from Auth0 (this _might_ also log them out of other applications that rely on Single Sign On), call `HttpContext.SignOutAsync` with the `Auth0Constants.AuthenticationScheme` authentication scheme as well as the appropriate `authenticationProperties` that can be constructed using the `LogoutAuthenticationPropertiesBuilder`.\n\n##### Checkpoint\n\nNow that you have configured Logout, run your application to verify that:\n\n*   Navigating to your `Logout` page will ensure the user is logged out.\n*   When also logging out from Auth0, you should be redirected to Auth0 and instantly redirected back to your own application.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [auth0-aspnetcore-authentication SDK](https://github.com/auth0/auth0-aspnetcore-authentication) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 ASP.NET Core Blazor Server SDK Quickstarts: Add Login to your ASP.NET Core Blazor Server application",
  "description": "This tutorial demonstrates how to add user login to an ASP.NET Core Blazor Server application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/aspnet-owin/interactive",
  "markdown": "# Add Login to your ASP.NET Owin application\n\nAuth0 allows you to quickly add authentication and gain access to user profile information in your application. This guide demonstrates how to integrate Auth0 with any new or existing ASP.NET OWIN application using the `Microsoft.Owin.Security.OpenIdConnect` Nuget package.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Install from Nuget\n\nTo integrate Auth0 with ASP.NET OWIN, you can use the `Microsoft.Owin.Security.OpenIdConnect` and `Microsoft.Owin.Security.Cookies` Nuget packages.\n\n```\nInstall-Package Microsoft.Owin.Security.OpenIdConnect\nInstall-Package Microsoft.Owin.Security.Cookies\n```\n\n### Configure the credentials\n\nFor the SDK to function properly, set the following properties in `Web.config`:\n\n*   `auth0:Domain`: The domain of your Auth0 tenant. You can find this in the Auth0 Dashboard under your application's **Settings** in the Domain field. If you are using a [custom domain](https://auth0.com/docs/custom-domains), set this to the value of your custom domain instead.\n*   `auth0:ClientId`: The ID of the Auth0 application you created in Auth0 Dashboard. You can find this in the Auth0 Dashboard under your application's **Settings** in the Client ID field.\n\nTo enable authentication in your ASP.NET OWIN application, go to the `Configuration` method of your `Startup` class and configure the cookie and OIDC middleware.\n\nIt is essential that you register both the cookie middleware and the OpenID Connect middleware as both are required (in that order) for authentication to work. The OpenID Connect middleware handles the authentication with Auth0. Once users have authenticated, their identity is stored in the cookie middleware.\n\nIn the code snippet, `AuthenticationType` is set to **Auth0**. Use `AuthenticationType` in the next section to challenge the OpenID Connect middleware and start the authentication flow. `RedirectToIdentityProvider` notification event constructs the correct [logout URL](https://auth0.com/docs/logout).\n\nTo allow users to log in to your ASP.NET OWIN application, add a `Login` action to your controller.\n\nCall `HttpContext.GetOwinContext().Authentication.Challenge` and pass `\"Auth0\"` as the authentication scheme. This invokes the OIDC authentication handler that was registered earlier. Be sure to specify the corresponding `AuthenticationProperties`, including a `RedirectUri`.\n\nAfter successfully calling `HttpContext.GetOwinContext().Authentication.Challenge`, the user redirects to Auth0 and signed in to both the OIDC middleware and the cookie middleware upon being redirected back to your application. This will allow the users to be authenticated on subsequent requests.\n\n##### Checkpoint\n\nNow that you have configured Login, run your application to verify that:\n\n*   Navigating to your `Login` action will redirect to Auth0\n*   Entering your credentials will redirect you back to your application.\n\nFrom your controller's action, call `HttpContext.GetOwinContext().Authentication.SignOut` with the `CookieAuthenticationDefaults.AuthenticationType` authentication scheme to log the user out of your application.\n\nAdditionally, if you want to log the user out from Auth0 (this _might_ also log them out of other applications that rely on Single Sign-On), call `HttpContext.GetOwinContext().Authentication.SignOut` with the `\"Auth0\"` authentication scheme.\n\n##### Checkpoint\n\nNow that you have configured Logout, run your application to verify that:\n\n*   Navigating to your `Logout` action ensures the user is logged out.\n*   During logout, you redirect to Auth0 and instantly redirect back to your application during log out.\n\nAfter the middleware successfully retrieves the tokens from Auth0, it extracts the user's information and claims from the ID token and makes them available as `ClaimsIdentity`. Access the extracted information by using the `User` property on the controller.\n\nTo create a user profile, retrieve a user's name, email address, and profile image from the `User` and pass it to the view from inside your controller.\n\n##### Checkpoint\n\nNow that you have set up your action to render the user's profile, run your application to verify that:\n\n*   Navigating to your `Profile` action after being successfully logged in, shows the user's profile.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 ASP.NET (OWIN) SDK Quickstarts: Add Login to your ASP.NET Owin application",
  "description": "This tutorial demonstrates how to add user login to an ASP.NET Owin application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/aspnet-core-webapi/interactive",
  "markdown": "# Auth0 ASP.NET Core Web API SDK Quickstarts: Add Authorization to an ASP.NET Core Web API application\n\nAuth0 allows you to add authentication and access user profile information in almost any application type quickly. This guide demonstrates how to integrate Auth0 with any new or existing ASP.NET Web API application using the `Microsoft.AspNetCore.Authentication.JwtBearer` package.\n\nIf you haven't created an API in your Auth0 dashboard yet, you can use the interactive selector to create a new Auth0 API or select an existing API that represents the project you want to integrate with.\n\nAlternatively, you can [read our getting started guide](https://auth0.com/docs/get-started/auth0-overview/set-up-apis), which will help you set up your first API through the Auth0 Dashboard.\n\nNote that every API in Auth0 is configured using an API Identifier; your application code will use the API Identifier as the Audience to validate the access token.\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nTo allow your application to validate access tokens, add a reference to the `Microsoft.AspNetCore.Authentication.JwtBearer` Nuget package:\n\n```\nInstall-Package Microsoft.AspNetCore.Authentication.JwtBearer\n```\n\nSet up the authentication middleware by configuring it in your application's `Program.cs` file:\n\n1.  Register the authentication services by making a call to the `AddAuthentication` method. Configure `JwtBearerDefaults.AuthenticationScheme` as the default scheme.\n    \n2.  Register the JWT Bearer authentication scheme by making a call to the `AddJwtBearer` method. Configure your Auth0 domain as the authority and your Auth0 API Identifier as the audience, and be sure that your Auth0 domain and API Identifier are set in your application's **appsettings.json** file.\n    \n\n3.  Add the authentication and authorization middleware to the middleware pipeline by adding calls to the `UseAuthentication` and `UseAuthorization` methods under the `var app = builder.Build();` method.\n\nTo ensure that an access token contains the correct scopes, use [Policy-Based Authorization](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies) in the ASP.NET Core:\n\n1.  Create a new authorization requirement called `HasScopeRequirement`, which will check whether the `scope` claim issued by your Auth0 tenant is present, and if so, will check that the claim contains the requested scope.\n2.  Under your `Program.cs` file's `var builder = WebApplication.CreateBuilder(args);` method, add a call to the `app.AddAuthorization` method.\n3.  Add policies for scopes by calling `AddPolicy` for each scope.\n4.  Register a singleton for the `HasScopeHandler` class.\n\nThe JWT middleware integrates with the standard ASP.NET Core [Authentication](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/) and [Authorization](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/) mechanisms.\n\nTo secure an endpoint, add the `[Authorize]` attribute to your controller action (or the entire controller if you want to protect all of its actions).\n\nWhen securing endpoints that require specific scopes, make sure that the correct scope is present in the `access_token`. To do so, add the `Authorize` attribute to the `Scoped` action and pass `read:messages` as the `policy` parameter.\n\nThe way in which you call your API depends on the type of application you are developing and the framework you are using. To learn more, read the relevant application Quickstart:\n\n*   [Single-Page Applications](https://auth0.com/docs/quickstart/spa)\n*   [Mobile / Native Application](https://auth0.com/docs/quickstart/native)\n\n### Get an access token\n\nRegardless of the type of application you are developing or the framework you are using, to call your API, you need an access token.\n\nIf you are calling your API from a Single-Page Application (SPA) or a Native application, after the authorization flow completes, you will get an access token.\n\nIf you are calling the API from a command-line tool or another service where a user entering credentials does not exist, use the [OAuth Client Credentials Flow](https://auth0.com/docs/api/authentication#client-credentials). To do so, register a [Machine-to-Machine Application](https://manage.auth0.com/#/applications), and pass in the **Client ID** as the `client_id` parameter, the **Client Secret** as the `client_secret` parameter, and the API Identifier (the same value you used to configure the middleware earlier in this quickstart) as the `audience` parameter when making the following request:\n\n*   [cURL](#be98fb6571154f73a2d95379f322d5e0_shell)\n*   [C#](#be98fb6571154f73a2d95379f322d5e0_csharp)\n*   [Go](#be98fb6571154f73a2d95379f322d5e0_go)\n*   [Java](#be98fb6571154f73a2d95379f322d5e0_java)\n*   [Node.JS](#be98fb6571154f73a2d95379f322d5e0_node)\n*   [Obj-C](#be98fb6571154f73a2d95379f322d5e0_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data 'client_id={yourClientId}' \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data 'audience={yourApiIdentifier}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=%24%7BapiIdentifier%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=%24%7BapiIdentifier%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=%24%7BapiIdentifier%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: '{yourApiIdentifier}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience={yourApiIdentifier}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=%24%7BapiIdentifier%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=%24%7BapiIdentifier%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=%24%7BapiIdentifier%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience={yourApiIdentifier}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Call a secure endpoint\n\nNow that you have an access token, you can use it to call secure API endpoints. When calling a secure endpoint, you must include the access token as a Bearer token in the **Authorization** header of the request. For example, you can make a request to the `/api/private` endpoint:\n\n*   [cURL](#d01aa86a919548edafb68748402b410b_shell)\n*   [C#](#d01aa86a919548edafb68748402b410b_csharp)\n*   [Go](#d01aa86a919548edafb68748402b410b_go)\n*   [Java](#d01aa86a919548edafb68748402b410b_java)\n*   [Node.JS](#d01aa86a919548edafb68748402b410b_node)\n*   [Obj-C](#d01aa86a919548edafb68748402b410b_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nCall the `/api/private-scoped` endpoint in a similar way, but ensure that the API permissions are configured correctly and that the access token includes the `read:messages` scope.\n\n##### Checkpoint\n\nYou should now be able to call the `/api/private` and `/api/private-scoped` endpoints.\n\nRun your application, and verify that:\n\n*   `GET /api/private` is available for authenticated requests.\n*   `GET /api/private-scoped` is available for authenticated requests containing an access token with the `read:messages` scope.",
  "title": "Auth0 ASP.NET Core Web API SDK Quickstarts: Add Authorization to an ASP.NET Core Web API application",
  "description": "This tutorial demonstrates how to add authorization to an ASP.NET Core Web API application using the standard JWT middleware.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/webapi-owin/interactive",
  "markdown": "# Auth0 ASP.NET Web API (OWIN) SDK Quickstarts: Add Authorization to an ASP.NET Owin Web API application\n\nAuth0 allows you to add authorization to any kind of application. This guide demonstrates how to integrate Auth0 with any new or existing ASP.NET Owin Web API application using the `Microsoft.Owin.Security.Jwt` package.\n\nIf you have not created an API in your Auth0 dashboard yet, you can use the interactive selector to create a new Auth0 API or select an existing API for your project.\n\nTo set up your first API through the Auth0 dashboard, review [our getting started guide](https://auth0.com/docs/get-started/auth0-overview/set-up-apis).\n\nEach Auth0 API uses the API Identifier, which your application needs to validate the access token.\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nInstall the `Microsoft.Owin.Security.Jwt` NuGetPackage. This package contains the OWIN JWT Middleware necessary to use Auth0 access tokens in the ASP.NET Owin Web API.\n\n```\nInstall-Package Microsoft.Owin.Security.Jwt\n```\n\nGo to the `Configuration` method of your `Startup` class and add a call to `UseJwtBearerAuthentication` passing in the configured `JwtBearerAuthenticationOptions`.\n\nThe `JwtBearerAuthenticationOptions` needs to specify your Auth0 API Identifier in the `ValidAudience` property, and the full path to your Auth0 domain as the `ValidIssuer`. You will need to configure the `IssuerSigningKeyResolver` to use the instance of `OpenIdConnectSigningKeyResolver` to resolve the signing key:\n\n### Do not forget the trailing slash\n\nEnsure the URL specified for `ValidIssuer` contains a trailing forward slash (`/`). This must match exactly with the JWT issuer claim. API calls will not authenticate correctly if you misconfigured this value.\n\nThe OWIN JWT middleware does not use Open ID Connect Discovery by default, so you must provide a custom `IssuerSigningKeyResolver`. Create the `OpenIdConnectSigningKeyResolver` class and ensure to return the correct `SecurityKey` by implementing `GetSigningKey`. This class is then used as `TokenValidationParameters.IssuerSigningKeyResolver` while configuring the middleware in `Startup.cs`.\n\nThe JWT middleware verifies that the access token included in the request is valid; however, it doesn't yet include any mechanism for checking that the token has the sufficient **scope** to access the requested resources.\n\nCreate a class called `ScopeAuthorizeAttribute` which inherits from `System.Web.Http.AuthorizeAttribute`. This attribute will check that the `scope` claim issued by your Auth0 tenant is present, and if so it will ensure that the `scope` claim contains the requested scope.\n\nThe routes shown below are available for the following requests:\n\n*   `GET /api/public`: available for non-authenticated requests\n*   `GET /api/private`: available for authenticated requests containing an access token with no additional scopes\n*   `GET /api/private-scoped`: available for authenticated requests containing an access token with the `read:messages` scope granted\n\nThe JWT middleware integrates with the standard ASP.NET authentication and authorization mechanisms, so you only need to decorate your controller action with the `[Authorize]` attribute to secure an endpoint.\n\nUpdate the action with the `ScopeAuthorize` attribute and pass the name of the required `scope` in the `scope` parameter. This ensures the correct scope is available to call a specific API endpoing.\n\n##### Checkpoint\n\nNow that you have configured your application, run your application to verify that:\n\n*   `GET /api/public` is available for non-authenticated requests.\n*   `GET /api/private` is available for authenticated requests.\n*   `GET /api/private-scoped` is available for authenticated requests containing an access token with the `read:messages` scope.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 ASP.NET Web API (OWIN) SDK Quickstarts: Add Authorization to an ASP.NET Owin Web API application",
  "description": "This tutorial demonstrates how to add authorization to an ASP.NET OWIN API using the standard JWT middleware.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/django/interactive",
  "markdown": "# Add Login to your Django application\n\nAuth0 allows you to add authentication and gain access to user profile information in your application. This guide demonstrates how to integrate Auth0 with a Python [Django](https://www.djangoproject.com/) application using the [Authlib](https://authlib.org/) SDK.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\nFor this integration, you will add several library dependencies, such as Authlib. Create a `requirements.txt` file in your project directory, and include the following:\n\n```\n# 📁 requirements.txt -----\n\nauthlib ~= 1.0\ndjango ~= 4.0\npython-dotenv ~= 0.19\nrequests ~= 2.27\n```\n\nRun the following command from your shell to make these dependencies available:\n\n```\npip install -r requirements.txt\n```\n\nNext, create an `.env` file in your project directory. This file will hold your client keys and other configuration details.\n\n```\n# 📁 .env -----\n\nAUTH0_CLIENT_ID={yourClientId}\nAUTH0_CLIENT_SECRET={yourClientSecret}\nAUTH0_DOMAIN={yourDomain}\n```\n\nIf you already have a Django application setup, skip to the next step. For a new application project, run the following command:\n\n```\ndjango-admin startproject webappexample\n```\n\nChange to the new project folder:\n\nOpen the `webappexample/settings.py` file to review the `.env` values.\n\nAt the top of the file, add the `os` and `dotenv` imports.\n\nNext, beneath the `BASE_DIR` definition, add the `TEMPLATE_DIR` variable.\n\nNext, find the `TEMPLATES` variable and update the `DIRS` value to add our `TEMPLATE_DIR` string. This determines the path of the template files, which you will create in a future step. Keep any other content of this array the same.\n\nAt the end of this file, add the code to load the Auth0 config.\n\nTo begin creating your application, open the `webappexample/views.py` file in your IDE.\n\nImport all the libraries your application needs.\n\nNow you can configure Authlib to handle your application's authentication with Auth0.\n\nLearn more about the configuration options available for Authlib's OAuth `register()` method from [their documentation.](https://docs.authlib.org/en/latest/client/frameworks.html#using-oauth-2-0-to-log-in)\n\nIn this example, you will add four routes for your application: the login, callback, logout, and index routes.\n\n*   `login` - When visitors to your app visit the `/login` route, they will reach Auth0 to begin the authentication flow.\n*   `callback` - After your users finish logging in with Auth0, they will return to your application at the `/callback` route. This route saves the session for the user and bypasses the need for them to login again when they return.\n*   `logout` - +The `/logout` route signs users out from your application. This route clears the user session in your app and redirects to the Auth0 logout endpoint to ensure the session is no longer saved. Then, the application redirects the user to your home route.\n*   `index` - The home route will render an authenticated user's details or allow visitors to sign in.\n\nReplace the contents of your `webappexample/urls.py` file with the code on the right to connect to these new routes.\n\nThis will route the `/login`, `/callback`, `/logout` and `/` routes to the correct handlers.\n\nNext, you will create a template file used in the home page route.\n\nCreate a new sub-directory within the `webappexample` folder named `templates`, and create a `index.html` file.\n\nThe `index.html` file will contain template code to display the user's info if logged in or present them with a login button if logged out.\n\nYou're ready to run your application! From your project directory, open a shell and use:\n\n```\npython3 manage.py migrate\npython3 manage.py runserver 3000\n```\n\nYour application should now be ready to open from your browser at [http://localhost:3000](http://localhost:3000/).\n\n##### Checkpoint\n\nVisit [http://localhost:3000](http://localhost:3000/) to verify. You should find a login button routing to Auth0 for login, then back to your application to see your profile information.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Django SDK Quickstarts: Add Login to your Django application",
  "description": "This tutorial demonstrates how to add user login to a Django application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/django/interactive",
  "markdown": "# Add Authorization to a Django API Application\n\nThis guide demonstrates how to integrate Auth0 with any new or existing Python API built with [Django](https://www.djangoproject.com/).\n\nIf you haven't created an API in your Auth0 Dashboard yet, you can use the interactive selector to create a new Auth0 API or select an existing API that represents the project you want to integrate with.\n\nAlternatively, you can read our [getting started guide](https://auth0.com/docs/get-started/auth0-overview/set-up-apis), which will help you set up your first API through the Auth0 Dashboard.\n\nEvery API in Auth0 is configured using an API Identifier that your application code will use as the Audience to validate the Access Token.\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\n## Configure Django to use Auth0\n\n1.  Add the following dependencies to your `requirements.txt`:\n\n```\n# /requirements.txt\n\nAuthlib~=1.0.0\nDjango~=4.0.3\npython-dotenv~=0.19.2\n```\n\n2.  Run `pip install -r requirements.txt`\n\n### Create a Django application\n\n```\ndjango-admin startproject apiexample\ncd apiexample\n```\n\nYou're going to use a library called [Authlib](https://github.com/lepture/authlib) to create a [ResourceProtector](https://docs.authlib.org/en/latest/flask/1/resource-server.html), which is a type of [Django view decorator](https://docs.djangoproject.com/en/4.0/topics/http/decorators/) that protects your resources (API views) with a given validator.\n\nThe validator will verify the Access Token that you pass to the resource by checking that it has a valid signature and claims.\n\nYou can use AuthLib's `JWTBearerTokenValidator` validator with a few tweaks to make sure it conforms to our requirements on [validating Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens).\n\nTo create your `Auth0JWTBearerTokenValidator`, you need to pass it your `domain` and `audience` (API Identifier). It will then get the public key required to verify the token's signature and pass it to the `JWTBearerTokenValidator` class.\n\nYou'll then override the class's `claims_options` to make sure the token's `expiry`, `audience`, and `issue` claims are validated according to our requirements.\n\nCreate the file `apiexample/validator.py` using the code from the interactive panel.\n\nNext, you'll create three API views in `apiexample/views.py`:\n\n*   `/api/public`: A public endpoint that requires no authentication.\n*   `/api/private`: A private endpoint that requires a valid Access Token JWT.\n*   `/api/private-scoped`: A private endpoint that requires a valid Access Token JWT containing the given `scope`.\n\nThe protected routes will have a `require_auth` decorator, which is a `ResourceProtector` that uses the `Auth0JWTBearerTokenValidator` you created earlier.\n\nTo create the `Auth0JWTBearerTokenValidator`, you'll pass it your tenant's domain and the API Identifier of the API you created earlier.\n\nThe `require_auth` decorator on the `private_scoped` route accepts an additional argument `\"read:messages\"`, which checks the Access Token for the Permission (Scope) you created earlier.\n\nIn previous steps, you added methods to the `views.py` file. You need to map those methods to URLs using Django's [URL dispatcher](https://docs.djangoproject.com/en/4.0/topics/http/urls/), which lets you map URL patterns to views.\n\nAdd the URL patterns to `apiexample/urls.py`:\n\n### Make a Call to Your API\n\nTo make calls to your API, you need an Access Token. You can get an Access Token for testing purposes from the **Test** view in your [API settings](https://manage.auth0.com/#/apis).\n\n![Obtain a JWT](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/request-access-token.png)\n\nProvide the Access Token as an `Authorization` header in your requests.\n\n*   [cURL](#4088f4a3866947bda089bccec72eeb66_shell)\n*   [C#](#4088f4a3866947bda089bccec72eeb66_csharp)\n*   [Go](#4088f4a3866947bda089bccec72eeb66_go)\n*   [Java](#4088f4a3866947bda089bccec72eeb66_java)\n*   [Node.JS](#4088f4a3866947bda089bccec72eeb66_node)\n*   [Obj-C](#4088f4a3866947bda089bccec72eeb66_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url http://your-domain.com/api_path \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN_HERE'\n```\n\n```\nvar client = new RestClient(\"http://your-domain.com/api_path\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://your-domain.com/api_path\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://your-domain.com/api_path\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://your-domain.com/api_path',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN_HERE'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN_HERE\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://your-domain.com/api_path\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"http://your-domain.com/api_path\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN_HERE\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"your-domain.com\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN_HERE\" }\n\nconn.request(\"GET\", \"/api_path\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://your-domain.com/api_path\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN_HERE'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN_HERE\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://your-domain.com/api_path\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Django API SDK Quickstarts: Add Authorization to a Django API Application",
  "description": "This tutorial demonstrates how to add authorization to a Python API built with Django.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/golang/interactive",
  "markdown": "# Add Login to your Go web application\n\nAuth0 allows you to add authentication and gain access to user profile information in your application. This guide demonstrates how to integrate Auth0 with any new or existing Go web application.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\nCreate a `go.mod` file to list all the dependencies in your application.\n\nTo integrate Auth0 in a Go application, add the`coreos/go-oidc/v3` and `x/oauth2` packages.\n\nIn addition to the OIDC and OAuth2 packages, add`joho/godotenv`, `gin-gonic/gin` and `gin-contrib/sessions`.\n\nSave the `go.mod` file with the necessary dependencies and install them using the following command in your terminal:\n\nYou must set the following environment variables in `.env` within the root of your project directory:\n\n*   **AUTH0\\_DOMAIN**: The domain of your Auth0 tenant. Find your Auth0 Domain in the Auth0 Dashboard under your Application's Settings in the Domain field. For [custom domains](https://auth0.com/docs/custom-domains), set this to the value of your custom domain instead.\n*   **AUTH0\\_CLIENT\\_ID**: The ID of the Auth0 Application you set up earlier in this quickstart. Find this in the Auth0 Dashboard under your Application's Settings in the Client ID field.\n*   **AUTH0\\_CLIENT\\_SECRET**: The Secret of the Auth0 Application you set up earlier in this quickstart. Find this in the Auth0 Dashboard under your Application's Settings in the Client Secret field.\n*   **AUTH0\\_CALLBACK\\_URL**: The URL used by Auth0 to redirect the user after successful authentication.\n\nNext, configure the OAuth2 and OpenID Connect packages.\n\nCreate a file called `auth.go` in the `platform/authenticator` folder. In this package, create a method to configure and return [OAuth2](https://godoc.org/golang.org/x/oauth2) and [OIDC](https://godoc.org/github.com/coreos/go-oidc) clients, and another one to verify an ID Token.\n\nCreate a file called `router.go` in the `platform/router` folder. In this package, create a method to configure and return our routes using [github.com/gin-gonic/gin](https://github.com/gin-gonic/gin). You will be passing an instance of `Authenticator` to the method, for use with the `login` and `callback` handlers.\n\nFor the user to authenticate themselves, we need to create a handler function to handle the `/login` route.\n\nCreate a file called `login.go` in the `web/app/login` folder, and add a `Handler` function. Upon executing the handler, the user will be redirected to Auth0 where they can enter their credentials.\n\nTo call the `/login` route, add a link to `/login` in the `home.html` template located in the `web/template` directory.\n\n```\n<!-- Save this within ./web/template/home.html -->\n\n<div>\n    <h3>Auth0 Example</h3>\n    <p>Zero friction identity infrastructure, built for developers</p>\n    <a href=\"/login\">SignIn</a>\n</div>\n```\n\nOnce users have authenticated using Auth0's Universal Login Page, they will return to the app at the `/callback` route.\n\nCreate a file called `callback.go` in the `web/app/callback` folder, and add a `Handler` function.\n\nThis handler will take the `code` query string, provided by Auth0, and exchange it for an ID token and an access token.\n\nIf the ID token is valid, it will store the profile information and access token in the session. The profile information is based on the claims contained in the ID token. Session storage allows the application to access that information as needed.\n\nNow that your users can log in, you will likely want to be able to retrieve and use the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with authenticated users.\n\nYou can access that [profile information](https://auth0.com/docs/users/concepts/overview-user-profile), such as their nickname or profile picture, through the `profile` that was stored in the session previously.\n\nCreate a handler for the `/user` endpoint in `web/app/user/user.go` and return the corresponding HTML file. As the `profile` is being passed to `ctx.HTML()`, you can access the profile information such as `picture` and `nickname` inside that same HTML file.\n\nAn example of such an HTML file could look like the example below, but you can retrieve any [profile information](https://auth0.com/docs/users/concepts/overview-user-profile), including custom claims.\n\n```\n<!-- Save this within ./web/template/user.html -->\n\n<div>\n    <img class=\"avatar\" src=\"{{ .picture }}\"/>\n    <h2>Welcome {{.nickname}}</h2>\n</div>\n```\n\nTo log the user out, clear the data from the session and redirect the user to the Auth0 logout endpoint. You can find more information about this in the [logout documentation](https://auth0.com/docs/logout).\n\nCreate a file called `logout.go` in the folder `web/app/logout`, and add the function `Handler` to redirect the user to Auth0's logout endpoint.\n\nCreate a file called `user.js` in the folder `web/static/js`, and add the code to remove the cookie from a logged-in user.\n\n```\n// Save this within ./web/static/js/user.js\n\n$(document).ready(function () {\n    $('.btn-logout').click(function (e) {\n        Cookies.remove('auth-session');\n    });\n});\n```\n\nRecommended practice dictates certain routes are accessible only to authenticated users. When unauthenticated users try accessing protected routes, your application should redirect them.\n\nIn this case, you will implement middleware to hook into the HTTP request. The middleware function determines if the request should route to the endpoint handler or block the request.\n\nCreate a file called `isAuthenticated.go` in `platform/middleware` and add a function that checks if the user is authenticated or not based on the `profile` session key. If the user is not authenticated, the middleware will redirect the user to the root of the application.\n\nWith the middleware created, we can set it up for any route that needs authentication by adding it to the router.\n\n```\n// This goes within ./platform/router/router.go\n\nrouter.GET(\"/user\", middleware.IsAuthenticated, user.Handler)\n```\n\nWith both the authenticator and router configured, we can wire things up using our application's entry point. Inside `main.go`, create an instance of the authenticator and the router, which gets passed the authenticator instance.\n\nIf you are using a `.env` file, you must call `godotenv.Load()` at the very beginning of the `main()` function.\n\nServe your application by using the following command in your terminal:\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Go SDK Quickstarts: Add Login to your Go web application",
  "description": "This tutorial demonstrates how to add user login to a Go web application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/express/interactive",
  "markdown": "# Add Login to your Express App\n\nAuth0 allows you to add authentication to almost any application type quickly. This guide demonstrates how to integrate Auth0, add user login, logout, and profile to a Node.js Express application using the Express OpenID Connect SDK.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\nYour application will need the [`express-openid-connect`](https://github.com/auth0/express-openid-connect) package which is an Auth0-maintained OIDC-compliant SDK for Express.\n\nInstall the Express OpenID Connect SDK by running the following commands in your terminal:\n\n```\ncd <your-project-directory>\nnpm install express-openid-connect\n```\n\n### Configure Router\n\nThe Express OpenID Connect library provides the `auth` router in order to attach authentication routes to your application. You will need to configure the router with the following configuration keys:\n\n*   `authRequired` - Controls whether authentication is required for all routes\n*   `auth0Logout` - Uses Auth0 logout feature\n*   `baseURL` - The URL where the application is served\n*   `secret` - A long, random string\n*   `issuerBaseURL` - The Domain as a secure URL found in your [Application settings](https://manage.auth0.com/#/applications/{yourClientId}/settings)\n*   `clientID` - The Client ID found in your [Application settings](https://manage.auth0.com/#/applications/{yourClientId}/settings)\n\nFor additional configuration options visit the [API documentation](https://auth0.github.io/express-openid-connect).\n\n##### Checkpoint\n\nA user can now log into your application by visiting the `/login` route provided by the library. If you are running your project on `localhost:3000` that link would be [`http://localhost:3000/login`](http://localhost:3000/login).\n\nTo display the user's profile, your application should provide a protected route.\n\nAdd the `requiresAuth` middleware for routes that require authentication. Any route using this middleware will check for a valid user session and, if one does not exist, it will redirect the user to log in.\n\n##### Checkpoint\n\nA user can log out of your application by visiting the `/logout` route provided by the library. If you are running your project on `localhost:3000` that link would be [`http://localhost:3000/logout`](http://localhost:3000/logout).",
  "title": "Auth0 Express SDK Quickstarts: Add Login to your Express App",
  "description": "Auth0 allows you to add authentication to almost any application type quickly. This guide demonstrates how to integrate Auth0, add user login, logout, and profile to a Node.js Express application using the Express OpenID Connect SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/golang/interactive",
  "markdown": "# Add authorization to a Go API\n\n## Add Authorization to Your Go Application\n\nThis guide demonstrates how to integrate Auth0 with any new or existing Go API application using the [go-jwt-middleware](https://github.com/auth0/go-jwt-middleware) package.\n\nIf you have not created an API in your Auth0 dashboard yet, use the interactive selector to create a new Auth0 API or select an existing API for your project.\n\nTo set up your first API through the Auth0 dashboard, review [our getting started guide](https://auth0.com/docs/get-started/auth0-overview/set-up-apis).\n\nEach Auth0 API uses the API Identifier, which your application needs to validate the access token.\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nAdd a `go.mod` file to list all the necessary dependencies.\n\n```\n// go.mod\n\nmodule 01-Authorization-RS256\n\ngo 1.21\n\nrequire (\n\tgithub.com/auth0/go-jwt-middleware/v2 v2.2.0\n\tgithub.com/joho/godotenv v1.5.1\n)\n```\n\nDownload dependencies by running the following shell command:\n\nCreate a `.env` file within the root of your project directory to store the app configuration, and fill in the environment variables:\n\n```\n# The URL of our Auth0 Tenant Domain.\n# If you're using a Custom Domain, be sure to set this to that value instead.\nAUTH0_DOMAIN='{yourDomain}'\n\n# Our Auth0 API's Identifier.\nAUTH0_AUDIENCE='{yourApiIdentifier}'\n```\n\nThe `EnsureValidToken` middleware function validates the access token. You can apply this function to any endpoints you wish to protect. If the token is valid, the endpoint releases the resources. If the token is not valid, the API returns a `401 Authorization` error.\n\nSetup the **go-jwt-middleware** middleware to verify access tokens from incoming requests.\n\nBy default, your API will be set up to use RS256 as the algorithm for signing tokens. Since RS256 works by using a private/public keypair, tokens can be verified against the public key for your Auth0 account. This public key is accessible at [https://{yourDomain}/.well-known/jwks.json](https://{yourdomain}/.well-known/jwks.json).\n\nInclude a mechanism to check that the token has sufficient **scope** to access the requested resources.\n\nCreate a function `HasScope` to check and ensure the access token has the correct scope before returning a successful response.\n\nIn this example, create an `/api/public` endpoint that does not use the `EnsureToken` middleware as it is accessible to non-authenticated requests.\n\nCreate an `/api/private` endpoint that requires the `EnsureToken` middleware as it is only available to authenticated requests containing an access token with no additional scope.\n\nCreate an `/api/private-scoped` endpoint that requires the `EnsureToken` middleware and `HasScope` as it is only available for authenticated requests containing an access token with the `read:messages` scope granted.\n\n### Make a Call to Your API\n\nTo make calls to your API, you need an Access Token. You can get an Access Token for testing purposes from the **Test** view in your [API settings](https://manage.auth0.com/#/apis).\n\n![Obtain a JWT](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/request-access-token.png)\n\nProvide the Access Token as an `Authorization` header in your requests.\n\n*   [cURL](#36fcd08498a64963b1f2ce22414c3c43_shell)\n*   [C#](#36fcd08498a64963b1f2ce22414c3c43_csharp)\n*   [Go](#36fcd08498a64963b1f2ce22414c3c43_go)\n*   [Java](#36fcd08498a64963b1f2ce22414c3c43_java)\n*   [Node.JS](#36fcd08498a64963b1f2ce22414c3c43_node)\n*   [Obj-C](#36fcd08498a64963b1f2ce22414c3c43_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url http://your-domain.com/api_path \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN_HERE'\n```\n\n```\nvar client = new RestClient(\"http://your-domain.com/api_path\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://your-domain.com/api_path\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://your-domain.com/api_path\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://your-domain.com/api_path',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN_HERE'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN_HERE\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://your-domain.com/api_path\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"http://your-domain.com/api_path\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN_HERE\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"your-domain.com\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN_HERE\" }\n\nconn.request(\"GET\", \"/api_path\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://your-domain.com/api_path\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN_HERE'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN_HERE\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://your-domain.com/api_path\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Checkpoint\n\nNow that you have configured your application, run your application to verify that:\n\n*   `GET /api/public` is available for non-authenticated requests.\n*   `GET /api/private` is available for authenticated requests.\n*   `GET /api/private-scoped` is available for authenticated requests containing an access token with the `read:messages` scope.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [go-jwt-middleware SDK](https://github.com/auth0/go-jwt-middleware) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Go API SDK Quickstarts: Add authorization to a Go API",
  "description": "This tutorial demonstrates how to add authorization to a Go API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/laravel/interactive",
  "markdown": "# Add Authorization to a Laravel Application\n\n[Auth0's Laravel SDK](https://github.com/auth0/laravel-auth0) allows you to quickly add token-based authorization and route access control to your Laravel application. This guide demonstrates how to integrate Auth0 with a new (or existing) [Laravel 9 or 10](https://github.com/auth0/laravel-auth0#support-policy) application.\n\n* * *\n\n**Backend applications differ from traditional web applications in that they do not handle user authentication or have a user interface. They provide an API that other applications can interact with. They accept [access tokens](https://auth0.com/docs/secure/tokens/access-tokens) from `Authorization` headers in requests to control access to routes.**\n\nSeparate front-end applications are usually built to interact with these types of backends. These can be anything from [single-page applications](https://auth0.com/docs/quickstart/spa) or [native or mobile apps](https://auth0.com/docs/quickstart/native) (all of which Auth0 also provides SDKs for!)\n\nWhen users need to interact with your backend application, they first authenticate with Auth0 using the frontend application. The frontend application then retrieves an access token from Auth0, which it can use to make requests to your backend application on behalf of the user.\n\nAs their name implies, [access tokens](https://auth0.com/docs/secure/tokens/access-tokens) are designed to address matters of access control (authorization), and do not contain information about the user. **Backend applications work exclusively with access tokens.** You can retrieve information about the user who created the token using the [Management API](https://auth0.com/docs/api/management/v2), which we will demonstrate later.\n\n**If you do not already have a Laravel application set up**, open a shell to a suitable directory for a new project and run the following command:\n\n```\ncomposer create-project --prefer-dist laravel/laravel auth0-laravel-api ^9.0\n```\n\nAll the commands in this guide assume you are running them from the root of your Laravel project, directory so you should `cd` into the new project directory:\n\nRun the following command within your project directory to install the [Auth0 Laravel SDK](https://github.com/auth0/laravel-auth0):\n\n```\ncomposer require auth0/login:^7.8 --update-with-all-dependencies\n```\n\nThen generate an SDK configuration file for your application:\n\n```\nphp artisan vendor:publish --tag auth0\n```\n\nRun the following command from your project directory to download the [Auth0 CLI](https://github.com/auth0/auth0-cli):\n\n```\ncurl -sSfL https://raw.githubusercontent.com/auth0/auth0-cli/main/install.sh | sh -s -- -b .\n```\n\nThen authenticate the CLI with your Auth0 account, choosing \"as a user\" when prompted:\n\nNext, create a new application with Auth0:\n\n```\n./auth0 apps create \\\n  --name \"My Laravel Backend\" \\\n  --type \"regular\" \\\n  --auth-method \"post\" \\\n  --callbacks \"http://localhost:8000/callback\" \\\n  --logout-urls \"http://localhost:8000\" \\\n  --reveal-secrets \\\n  --no-input \\\n  --json > .auth0.app.json\n```\n\nYou should also create a new API:\n\n```\n./auth0 apis create \\\n  --name \"My Laravel Backend API\" \\\n  --identifier \"https://github.com/auth0/laravel-auth0\" \\\n  --offline-access \\\n  --no-input \\\n  --json > .auth0.api.json\n```\n\nThis produces two files in your project directory that configure the SDK.\n\nAs these files contain credentials it's important to treat these as sensitive. You should ensure you do not commit these to version control. If you're using Git, you should add them to your `.gitignore` file:\n\n```\necho \".auth0.*.json\" >> .gitignore\n```\n\nThe SDK automatically registers its authorization guard with your Laravel application for use with the `api` middleware, which by default Laravel applies to all routes in your application's `routes/api.php` file.\n\nYou can use the Auth0 SDK's authorization guard to restrict access to your application's routes.\n\nTo reject requests that do not contain a valid access token in the `Authorization` header, you can use Laravel's `auth` middleware:\n\n```\nRoute::get('/private', function () {\n  return response()->json([\n    'message' => 'Your token is valid; you are authorized.',\n  ]);\n})->middleware('auth');\n```\n\nYou can also require the provided token to have specific [permissions](https://auth0.com/docs/manage-users/access-control/rbac) by combining this with Laravel's `can` middleware:\n\n```\nRoute::get('/scope', function () {\n    return response()->json([\n      'message' => 'Your token is valid and has the `read:messages` permission; you are authorized.',\n    ]);\n})->middleware('auth')->can('read:messages');\n```\n\nInformation about the provided access token is available through Laravel's `Auth` Facade, or the `auth()` helper function.\n\nFor example, to retrieve the user's identifier and email address:\n\n```\nRoute::get('/', function () {\n  if (! auth()->check()) {\n    return response()->json([\n      'message' => 'You did not provide a valid token.',\n    ]);\n  }\n\n  return response()->json([\n    'message' => 'Your token is valid; you are authorized.',\n    'id' => auth()->id(),\n    'token' => auth()?->user()?->getAttributes(),\n  ]);\n});\n```\n\nYou can retrieve information about the user who created the access token from Auth0 using the [Auth0 Management API](https://github.com/auth0/laravel-auth0/blob/main/docs/Management.md). The SDK provides a convenient wrapper for this API, accessible through the SDK's `management()` method.\n\n**Before making Management API calls you must enable your application to communicate with the Management API.** This can be done from the [Auth0 Dashboard's API page](https://manage.auth0.com/#/apis/), choosing `Auth0 Management API`, and selecting the 'Machine to Machine Applications' tab. Authorize your Laravel application, and then click the down arrow to choose the scopes you wish to grant.\n\nFor the following example, you should grant the `read:users` scope. A list of API endpoints and the required scopes can be found in [the Management API documentation](https://auth0.com/docs/api/management/v2).\n\n```\nuse Auth0\\Laravel\\Facade\\Auth0;\n\nRoute::get('/me', function () {\n  $user = auth()->id();\n  $profile = cache()->get($user);\n\n  if (null === $profile) {\n    $endpoint = Auth0::management()->users();\n    $profile = $endpoint->get($user);\n    $profile = Auth0::json($profile);\n\n    cache()->put($user, $profile, 120);\n  }\n\n  $name = $profile['name'] ?? 'Unknown';\n  $email = $profile['email'] ?? 'Unknown';\n\n  return response()->json([\n    'name' => $name,\n    'email' => $email,\n  ]);\n})->middleware('auth');\n```\n\nYou are now ready to start your Laravel application, so it can accept requests:\n\nYou can learn more about [retrieving access tokens here](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens). For this quickstart, however, you can simply use an access token from [your API settings' \"test\" view](https://manage.auth0.com/#/apis).\n\n##### Checkpoint\n\nOpen a shell and try issuing requests to your application.\n\nBegin by requesting the public route:\n\n```\ncurl --request GET \\\n  --url http://localhost:8000/api \\\n  --header 'Accept: application/json'\n```\n\nNext, use your access token in an `Authorization` header to request a protected route:\n\n```\ncurl --request GET \\\n  --url http://localhost:8000/api/private \\\n  --header 'Accept: application/json' \\\n  --header 'Authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\nFinally, try requesting the scope-protected route, which will only succeed if the access token has the `read:messages` scope granted:\n\n```\ncurl --request GET \\\n  --url http://localhost:8000/api/scope \\\n  --header 'Accept: application/json' \\\n  --header 'Authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n### Additional Reading\n\n*   [User Repositories and Models](https://github.com/auth0/laravel-auth0/blob/main/docs/Users.md) extends the Auth0 Laravel SDK to use custom user models, and how to store and retrieve users from a database.\n*   [Hooking Events](https://github.com/auth0/laravel-auth0/blob/main/docs/Events.md) covers how to listen for events raised by the Auth0 Laravel SDK, to fully customize the behavior of your integration.\n*   [Management API](https://github.com/auth0/laravel-auth0/blob/main/docs/Management.md) support is built into the Auth0 Laravel SDK, allowing you to interact with the Management API from your Laravel application.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [laravel-auth0 SDK](https://github.com/auth0/laravel-auth0) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Laravel API SDK Quickstarts: Add Authorization to a Laravel Application",
  "description": "Auth0's Laravel SDK allows you to quickly add token-based authorization and route access control to your Laravel application. This guide demonstrates how to integrate Auth0 with a new or existing Laravel 9 or 10 application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/java/interactive",
  "markdown": "# Add Login to your Java Servlet application\n\nAuth0 allows you to quickly add authentication and gain access to user profile information in your application. This guide demonstrates how to integrate Auth0 with any new or existing Java Servlet application.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Setup dependencies\n\nTo integrate your Java application with Auth0, add the following dependencies:\n\n*   **javax.servlet-api**: is the library that allows you to create Java Servlets. You then need to add a Server dependency like Tomcat or Gretty, which one is up to you. Check our sample code for more information.\n*   **auth0-java-mvc-commons**: is the [Java library](https://github.com/auth0/auth0-java-mvc-common) that allows you to use Auth0 with Java for server-side MVC web apps. It generates the Authorize URL that you need to call in order to authenticate and validates the result received on the way back to finally obtain the [Auth0 Tokens](https://auth0.com/docs/tokens) that identify the user.\n\nIf you are using Gradle, add them to your `build.gradle`:\n\n```\n// build.gradle\n\ncompile 'javax.servlet:javax.servlet-api:3.1.0'\ncompile 'com.auth0:mvc-auth-commons:1.+'\n```\n\nIf you are using Maven, add them to your `pom.xml`:\n\n```\n<!-- pom.xml -->\n\n<dependency>\n  <groupId>com.auth0</groupId>\n  <artifactId>mvc-auth-commons</artifactId>\n  <version>[1.0, 2.0)</version>\n</dependency>\n<dependency>\n  <groupId>javax.servlet</groupId>\n  <artifactId>javax.servlet-api</artifactId>\n  <version>3.1.0</version>\n</dependency>\n```\n\nYour Java App needs some information in order to authenticate against your Auth0 account. The samples read this information from the deployment descriptor file `src/main/webapp/WEB-INF/web.xml`, but you could store them anywhere else.\n\nThis information will be used to configure the **auth0-java-mvc-commons** library to enable users to login to your application. To learn more about the library, including its various configuration options, see the [library's documentation](https://github.com/auth0/auth0-java-mvc-common/blob/master/README.md).\n\n### Check populated attributes\n\nIf you downloaded this sample using the **Download Sample** button, the `domain`, `clientId` and `clientSecret` attributes will be populated for you. You should verify that the values are correct, especially if you have multiple Auth0 applications in your account.\n\n### Project structure\n\nThe example project, which can be downloaded using the **Download Sample** button, has the following structure:\n\n```\n- src\n-- main\n---- java\n------ com\n-------- auth0\n---------- example\n------------ Auth0Filter.java\n------------ AuthenticationControllerProvider.java\n------------ HomeServlet.java\n------------ CallbackServlet.java\n------------ LoginServlet.java\n------------ LogoutServlet.java\n---- webapp\n------ WEB-INF\n-------- jsp\n---------- home.jsp\n-------- web.xml\n- build.gradle\n```\n\nThe project contains a single JSP: the `home.jsp` which will display the tokens associated with the user after a successful login and provide the option to logout.\n\nThe project contains a WebFilter: the `Auth0Filter.java` which will check for existing tokens before giving the user access to our protected `/portal/*` path. If the tokens don't exist, the request will be redirected to the `LoginServlet`.\n\nThe project contains also four servlets:\n\n*   `LoginServlet.java`: Invoked when the user attempts to log in. The servlet uses the `client_id` and `domain` parameters to create a valid Authorize URL and redirects the user there.\n*   `CallbackServlet.java`: The servlet captures requests to our Callback URL and processes the data to obtain the credentials. After a successful login, the credentials are then saved to the request's HttpSession.\n*   `HomeServlet.java`: The servlet reads the previously saved tokens and shows them on the `home.jsp` resource.\n*   `LogoutServlet.java`: Invoked when the user clicks the logout link. The servlet invalidates the user session and redirects the user to the login page, handled by the `LoginServlet`.\n*   `AuthenticationControllerProvider`: Responsible to create and manage a single instance of the `AuthenticationController`\n\nTo enable users to authenticate, create an instance of the `AuthenticationController` provided by the `auth0-java-mvc-commons` SDK using the `domain`, `clientId`, and `clientSecret`. The sample shows how to configure the component for use with tokens signed using the RS256 asymmetric signing algorithm, by specifying a `JwkProvider` to fetch the public key used to verify the token's signature. See the [jwks-rsa-java repository](https://github.com/auth0/jwks-rsa-java) to learn about additional configuration options. If you are using HS256, there is no need to configure the `JwkProvider`.\n\nTo enable users to log in, your application will redirect them to the [Universal Login](https://auth0.com/docs/universal-login) page. Using the `AuthenticationController` instance, you can generate the redirect URL by calling the `buildAuthorizeUrl(HttpServletRequest request, HttpServletResponse response, String redirectUrl)` method. The redirect URL must be the URL that was added to the **Allowed Callback URLs** of your Auth0 application.\n\nAfter the user logs in, the result will be received in our `CallbackServlet` via either a GET or POST HTTP request. Because we are using the Authorization Code Flow (the default), a GET request will be sent. If you have configured the library for the Implicit Flow, a POST request will be sent instead.\n\nThe request holds the call context that the library previously set by generating the Authorize URL with the `AuthenticationController`. When passed to the controller, you get back either a valid `Tokens` instance or an Exception indicating what went wrong. In the case of a successful call, you need to save the credentials somewhere to access them later. You can use the `HttpSession` of the request by using the `SessionsUtils` class included in the library.\n\nNow that the user is authenticated (the tokens exists), the `Auth0Filter` will allow them to access our protected resources. In the `HomeServlet` we obtain the tokens from the request's session and set them as the `userId` attribute so they can be used from the JSP code.\n\nTo properly handle logout, we need to clear the session and log the user out of Auth0. This is handled in the `LogoutServlet` of our sample application.\n\nFirst, we clear the session by calling `request.getSession().invalidate()`. We then construct the logout URL, being sure to include the `returnTo` query parameter, which is where the user will be redirected to after logging out. Finally, we redirect the response to our logout URL.\n\nTo run the sample from a terminal, change the directory to the root folder of the project and execute the following line:\n\nAfter a few seconds, the application will be accessible on `http://localhost:3000/`. Try to access the protected resource [http://localhost:3000/portal/home](http://localhost:3000/portal/home) and note how you're redirected by the `Auth0Filter` to the Auth0 Login Page. The widget displays all the social and database connections that you have defined for this application in the [dashboard](https://manage.auth0.com/#/).\n\n![Auth0 Universal Login](https://auth0.com/docs/media/quickstarts/universal-login.png)\n\nAfter a successful authentication, you'll be able to see the home page contents.\n\n![Display Token](https://auth0.com/docs/media/articles/java/display-token.png)\n\nLog out by clicking the **logout** button at the top right of the home page.",
  "title": "Auth0 Java SDK Quickstarts: Add Login to your Java Servlet application",
  "description": "This tutorial demonstrates how to add user login to a Java Servlet application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/nodejs/interactive",
  "markdown": "# Auth0 Node (Express) API SDK Quickstarts: Add authorization to an Express.js API application\n\nThis guide demonstrates how to integrate Auth0 with any new or existing Express.js API application using the `express-oauth2-jwt-bearer` package.\n\nIf you have not created an API in your Auth0 dashboard yet, use the interactive selector to create a new Auth0 API or select an existing project API.\n\nTo set up your first API through the Auth0 dashboard, review [our getting started guide](https://auth0.com/docs/get-started/auth0-overview/set-up-apis). Each Auth0 API uses the API Identifier, which your application needs to validate the access token.\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nFirst, install the SDK with `npm`.\n\n```\nnpm install --save express-oauth2-jwt-bearer\n```\n\nConfigure `express-oauth2-jwt-bearer` with your Domain and API Identifier.\n\nThe `checkJwt` middleware shown to the right checks if the user's access token included in the request is valid. If the token is not valid, the user gets a 401 Authorization error when they try to access the endpoints.\n\nThe middleware does not check if the token has sufficient scope to access the requested resources.\n\nTo protect an individual route by requiring a valid JWT, configure the route with the `checkJwt` middleware constructed from `express-oauth2-jwt-bearer`.\n\nYou can configure individual routes to look for a particular scope. To achieve that, set up another middleware with the `requiresScope` method. Provide the required scopes and apply the middleware to any routes you want to add authorization to.\n\nPass the `checkJwt` and `requiredScopes` middlewares to the route you want to protect.\n\nIn this configuration, only access tokens with the `read:messages` scope can access the endpoint.\n\n### Make a Call to Your API\n\nTo make calls to your API, you need an Access Token. You can get an Access Token for testing purposes from the **Test** view in your [API settings](https://manage.auth0.com/#/apis).\n\n![Obtain a JWT](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/request-access-token.png)\n\nProvide the Access Token as an `Authorization` header in your requests.\n\n*   [cURL](#b2c8398041a443d0afcd95e898bd80e5_shell)\n*   [C#](#b2c8398041a443d0afcd95e898bd80e5_csharp)\n*   [Go](#b2c8398041a443d0afcd95e898bd80e5_go)\n*   [Java](#b2c8398041a443d0afcd95e898bd80e5_java)\n*   [Node.JS](#b2c8398041a443d0afcd95e898bd80e5_node)\n*   [Obj-C](#b2c8398041a443d0afcd95e898bd80e5_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url http://your-domain.com/api_path \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN_HERE'\n```\n\n```\nvar client = new RestClient(\"http://your-domain.com/api_path\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://your-domain.com/api_path\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://your-domain.com/api_path\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://your-domain.com/api_path',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN_HERE'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN_HERE\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://your-domain.com/api_path\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"http://your-domain.com/api_path\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN_HERE\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"your-domain.com\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN_HERE\" }\n\nconn.request(\"GET\", \"/api_path\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://your-domain.com/api_path\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN_HERE'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN_HERE\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://your-domain.com/api_path\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Checkpoint\n\nNow that you have configured your application, run your application to verify that:\n\n*   `GET /api/public` is available for non-authenticated requests.\n*   `GET /api/private` is available for authenticated requests.\n*   `GET /api/private-scoped` is available for authenticated requests containing an access token with the `read:messages` scope.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [express-oauth2-jwt-bearer SDK](https://github.com/auth0/node-oauth2-jwt-bearer/tree/main/packages/express-oauth2-jwt-bearer) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Node (Express) API SDK Quickstarts: Add authorization to an Express.js API application",
  "description": "This tutorial demonstrates how to add authorization to an Express.js API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/java-ee",
  "markdown": "# Auth0 Java EE SDK Quickstarts: Login\n\nThis tutorial demonstrates how to add user login to a Java EE web application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Java 11\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n*   **Client Secret**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Configure Java EE to use Auth0\n\n### Set up dependencies\n\nTo integrate your Java EE application with Auth0, add the following dependencies:\n\n*   **javax.javaee-api**: The Java EE 8 API necessary to write applications using Java EE 8. The actual implementation is provided by the application container, so it does not need to be included in the WAR file.\n*   **javax.security.enterprise**: The Java EE 8 Security API that enables handling security concerns in an EE application. Like the `javax.javaee-api` dependency, the implementation is provided by the application container, so is not included in the WAR file.\n*   **auth0-java-mvc-commons**: The [Auth0 Java MVC SDK](https://github.com/auth0/auth0-java-mvc-common) allows you to use Auth0 with Java for server-side MVC web applications. It generates the Authorize URL that your application needs to call in order to authenticate a user using Auth0.\n\nIf you are using Maven, add these dependencies to your `pom.xml`:\n\n```\n<!-- pom.xml -->\n\n<dependency>\n    <groupId>com.auth0</groupId>\n    <artifactId>mvc-auth-commons</artifactId>\n    <version>[1.0, 2.0)</version>\n</dependency>\n<dependency>\n    <groupId>javax</groupId>\n    <artifactId>javaee-api</artifactId>\n    <version>8.0.1</version>\n    <scope>provided</scope>\n</dependency>\n<dependency>\n    <groupId>javax.security.enterprise</groupId>\n    <artifactId>javax.security.enterprise-api</artifactId>\n    <version>1.0</version>\n    <scope>provided</scope>\n</dependency>\n```\n\nIf you are using Gradle, add them to your `build.gradle`:\n\n```\n// build.gradle\n\nprovidedCompile 'javax:javaee-api:8.0.1'\nprovidedCompile 'javax.security.enterprise:javax.security.enterprise-api:1.0'\nimplementation 'com.auth0:mvc-auth-commons:1.+'\n```\n\n### Configure your Java EE application\n\nYour Java EE application needs some information in order to authenticate users with your Auth0 application. The deployment descriptor `web.xml` file can be used to store this information, though you could store them in a different secured location. The required information is:\n\n```\n<!-- `src/main/webapp/WEB-INF/web.xml`-->\n\n<env-entry>\n    <env-entry-name>auth0.domain</env-entry-name>\n    <env-entry-type>java.lang.String</env-entry-type>\n    <env-entry-value>{yourDomain}</env-entry-value>\n</env-entry>\n<env-entry>\n    <env-entry-name>auth0.clientId</env-entry-name>\n    <env-entry-type>java.lang.String</env-entry-type>\n    <env-entry-value>{yourClientId}</env-entry-value>\n</env-entry>\n<env-entry>\n    <env-entry-name>auth0.clientSecret</env-entry-name>\n    <env-entry-type>java.lang.String</env-entry-type>\n    <env-entry-value>YOUR_CLIENT_SECRET</env-entry-value>\n</env-entry>\n<env-entry>\n    <env-entry-name>auth0.scope</env-entry-name>\n    <env-entry-type>java.lang.String</env-entry-type>\n    <env-entry-value>openid profile email</env-entry-value>\n</env-entry>\n```\n\nThis information will be used to configure the **auth0-java-mvc-commons** library to enable users to login to your application. To learn more about the library, including its various configuration options, see the [README](https://github.com/auth0/auth0-java-mvc-common/blob/master/README.md) of the library.\n\n### Check populated attributes\n\nIf you downloaded this sample using the **Download Sample** button, the `domain`, `clientId` and `clientSecret` attributes will be populated for you. You should verify that the values are correct, especially if you have multiple Auth0 applications in your account.\n\n## Configure Java EE Security\n\nThe Java EE 8 Security API introduced the `HttpAuthenticationMechanism` interface to enable applications to obtain a user's credentials. Default implementations exist for Basic and form-based authentication, and it provides an easy way to configure a custom authentication strategy.\n\nTo authenticate with Auth0, provide custom implementations of the following interfaces:\n\n*   `HttpAuthenticationMechanism`: Responsible for obtaining a user's credentials and notifying the container of successful (or not) login status ([JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/authentication/mechanism/http/HttpAuthenticationMechanism.html)).\n*   `IdentityStore`: Responsible for validating the user's credentials ([JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/identitystore/IdentityStore.html)).\n*   `CallerPrincipal`: Represents the caller principal of the current HTTP request ([JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/CallerPrincipal.html)).\n*   `Credential`: Represents the credential the caller will use to authenticate ([JavaDoc](https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/credential/Credential.html)).\n\nFirst, make your Auth0 settings available to the application by creating an `@ApplicationScoped` bean to retrieve the values from the web context and make them available via getters:\n\n```\n// src/main/java/com/auth0/example/security/Auth0AuthenticationConfig.java\n\n@ApplicationScoped\npublic class Auth0AuthenticationConfig {\n\n    private String domain;\n    private String clientId;\n    private String clientSecret;\n    private String scope;\n\n    @PostConstruct\n    public void init() {\n        // Get authentication config values from env-entries in web.xml\n        try {\n            Context env = (Context)new InitialContext().lookup(\"java:comp/env\");\n\n            this.domain = (String) env.lookup(\"auth0.domain\");\n            this.clientId = (String) env.lookup(\"auth0.clientId\");\n            this.clientSecret = (String) env.lookup(\"auth0.clientSecret\");\n            this.scope = (String) env.lookup(\"auth0.scope\");\n        } catch (NamingException ne) {\n            throw new IllegalArgumentException(\"Unable to lookup auth0 configuration properties from web.xml\", ne);\n        }\n\n        if (this.domain == null || this.clientId == null || this.clientSecret == null || this.scope == null) {\n            throw new IllegalArgumentException(\"domain, clientId, clientSecret, and scope must be set in web.xml\");\n        }\n    }\n\n    public String getDomain() {\n         return domain;\n    }\n\n    public String getClientId() {\n         return clientId;\n    }\n\n    public String getClientSecret() {\n         return clientSecret;\n    }\n\n    public String getScope() {\n        return scope;\n    }\n}\n```\n\nNext, create a custom `CallerPrincipal` that represents the caller of the current request:\n\n```\n// src/main/java/com/auth0/example/security/Auth0JwtPrincipal.java\n\npublic class Auth0JwtPrincipal extends CallerPrincipal {\n    private final DecodedJWT idToken;\n\n    Auth0JwtPrincipal(DecodedJWT idToken) {\n        super(idToken.getClaim(\"name\").asString());\n        this.idToken = idToken;\n    }\n\n    public DecodedJWT getIdToken() {\n        return this.idToken;\n    }\n}\n```\n\nYou can now implement a custom `Credential` that will be used to represent the user's credentials. It will hold information about the principal:\n\n```\n// src/main/java/com/auth0/example/security/Auth0JwtCredential.java\n\nclass Auth0JwtCredential implements Credential {\n    private Auth0JwtPrincipal auth0JwtPrincipal;\n\n    Auth0JwtCredential(String token) {\n        DecodedJWT decodedJWT = JWT.decode(token);\n        this.auth0JwtPrincipal = new Auth0JwtPrincipal(decodedJWT);\n    }\n\n    Auth0JwtPrincipal getAuth0JwtPrincipal() {\n        return auth0JwtPrincipal;\n    }\n}\n```\n\nYou now have defined the classes that represent a calling principal and credential. Next, create a custom implementation of `IdentityStore`. This class will be responsible for validating the user's credentials:\n\n```\n// src/main/java/com/auth0/example/security/Auth0JwtIdentityStore.java\n\n@ApplicationScoped\npublic class Auth0JwtIdentityStore implements IdentityStore {\n\n    @Override\n    public CredentialValidationResult validate(final Credential credential) {\n        CredentialValidationResult result = CredentialValidationResult.NOT_VALIDATED_RESULT;\n        if (credential instanceof Auth0JwtCredential) {\n            Auth0JwtCredential auth0JwtCredential = (Auth0JwtCredential) credential;\n            result = new CredentialValidationResult(auth0JwtCredential.getAuth0JwtPrincipal());\n        }\n        return result;\n    }\n}\n```\n\nIf the `credential` is an `Auth0Credential`, the calling user is authenticated and valid, so a `CredentialValidationResult` created with the credential is returned to indicate success. If it is not an `Auth0Credential`, return `CredentialValidationResult.NOT_VALIDATED_RESULT`.\n\nBefore implementing the `HttpAuthenticationMechanism` interface that will use all these collaborators, create a bean that will provide a configured instance of the `AuthenticationController` from the Auth0 Java MVC SDK. The `AuthenticationController` is used to build the authorization URL where users will login, and handle the token exchange to authenticate users.\n\n*   If your Auth0 Application is configured to use the **RS256 signing algorithm** (the default when creating a new Auth0 Application), you need to configure a `JwkProvider` to fetch the public key used to verify the token's signature. See the [jwks-rsa-java repository](https://github.com/auth0/jwks-rsa-java) to learn about additional configuration options.\n*   If your Auth0 Application is configured to use the **HS256 signing algorithm**, there is no need to configure the `JwkProvider`.\n\nThe sample below shows how to configure the `AuthenticationController` for use with the **RS256 signing algorithm**:\n\n```\n// src/main/java/com/auth0/example/security/Auth0AuthenticationProvider.java\n\n@ApplicationScoped\npublic class Auth0AuthenticationProvider {\n\n    @Produces\n    public AuthenticationController authenticationController(Auth0AuthenticationConfig config) {\n        JwkProvider jwkProvider = new JwkProviderBuilder(config.getDomain()).build();\n        return AuthenticationController.newBuilder(config.getDomain(), config.getClientId(), config.getClientSecret())\n                .withJwkProvider(jwkProvider)\n                .build();\n    }\n}\n```\n\nFinally, implement a custom `HttpAuthenticationMechanism`\n\n```\n// src/main/java/com/auth0/example/security/Auth0AuthenticationMechanism.java\n\n@ApplicationScoped\n@AutoApplySession\npublic class Auth0AuthenticationMechanism implements HttpAuthenticationMechanism {\n    private final AuthenticationController authenticationController;\n    private final IdentityStoreHandler identityStoreHandler;\n\n    @Inject\n    Auth0AuthenticationMechanism(AuthenticationController authenticationController, IdentityStoreHandler identityStoreHandler) {\n        this.authenticationController = authenticationController;\n        this.identityStoreHandler = identityStoreHandler;\n    }\n\n    @Override\n    public AuthenticationStatus validateRequest(HttpServletRequest httpServletRequest,\n                                                HttpServletResponse httpServletResponse,\n                                                HttpMessageContext httpMessageContext) throws AuthenticationException {\n\n        // Exchange the code for the ID token, and notify container of result.\n        if (isCallbackRequest(httpServletRequest)) {\n            try {\n                Tokens tokens = authenticationController.handle(httpServletRequest, httpServletResponse);\n                Auth0JwtCredential auth0JwtCredential = new Auth0JwtCredential(tokens.getIdToken());\n                CredentialValidationResult result = identityStoreHandler.validate(auth0JwtCredential);\n                return httpMessageContext.notifyContainerAboutLogin(result);\n            } catch (IdentityVerificationException e) {\n                return httpMessageContext.responseUnauthorized();\n            }\n        }\n        return httpMessageContext.doNothing();\n    }\n\n    private boolean isCallbackRequest(HttpServletRequest request) {\n        return request.getRequestURI().equals(\"/callback\") && request.getParameter(\"code\") != null;\n    }\n}\n```\n\nThe class overrides the `validateRequest` method, which is called on every request to our application, and is responsible for notifying the container of the authentication status.\n\nThis sample uses the [Authorization Code Flow](https://auth0.com/docs/flows/concepts/auth-code) to exchange an Authorization Code for a token during the authentication flow. If this request is to the `/callback` endpoint and contains the `code` request parameter, it does a few important things:\n\n*   Calls the `handle` method of the `AuthenticationController` to exchange the Authorization Code for an ID token and an access token.\n*   Uses the ID token to create a new `Auth0Credential`.\n*   Calls the `validate` method of the custom `IdentityStore` implementation to obtain the validation result.\n*   Notifies the application container of the login status.\n\nIf the requested resource is not `/callback`, return `httpMessageContext.doNothing()` to allow the request processing to continue. You will see shortly how to use the authentication information when triggering authentication and displaying web views.\n\nFinally, note that the `@AutoApplySession` annotation has been added to allow the container to create a session for the authenticated user.\n\n## Trigger authentication\n\nTo enable a user to log in, create a Servlet that will handle requests to the `/login` path:\n\n```\n// src/main/java/com/auth0/example/web/LoginServlet.java\n\n@WebServlet(urlPatterns = \"/login\")\npublic class LoginServlet extends HttpServlet {\n    private final Auth0AuthenticationConfig config;\n    private final AuthenticationController authenticationController;\n\n    @Inject\n    LoginServlet(Auth0AuthenticationConfig config, AuthenticationController authenticationController) {\n        this.config = config;\n        this.authenticationController = authenticationController;\n    }\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // URL where the application will receive the authorization code (e.g., http://localhost:3000/callback)\n        String callbackUrl = String.format(\n                \"%s://%s:%s/callback\",\n                request.getScheme(),\n                request.getServerName(),\n                request.getServerPort()\n        );\n\n        // Create the authorization URL to redirect the user to, to begin the authentication flow.\n        String authURL = authenticationController.buildAuthorizeUrl(request, response, callbackUrl)\n                .withScope(config.getScope())\n                .build();\n\n        response.sendRedirect(authURL);\n    }\n}\n```\n\nThe `LoginController` is responsible for redirecting the request to the proper authorization URL, where the user can authenticate with Auth0. It uses the `AuthenticationController` from the Auth0 Java MVC SDK to build the correct authorization URL, using the configuration values injected via `Auth0AuthenticationConfig`. By default, this sample requests the `\"openid profile email\"` scopes, to allow the application to retrieve basic profile information from the authenticated user. You can read more about these scopes in the [OpenID Connect Scopes](https://auth0.com/docs/scopes/current/oidc-scopes) documentation.\n\nOnce the user has entered their credentials and authorized the requested permissions, Auth0 will issue a request to the `callbackUrl`, and include a `code` query parameter which can be exchanged for an ID token and an access token. Recall that the `Auth0HttpAuthenticationMechanism` created above handles this exchange so that it can notify the application container of authentication status. This allows the Servlet that handles requests to the `/callback` path to simply forward the request on to the originally requested resource prior to logging in, or simply redirect to the home page:\n\n```\n// src/main/com/auth0/example/web/CallbackServlet.java\n\n@WebServlet(urlPatterns = {\"/callback\"})\npublic class CallbackServlet extends HttpServlet {\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String referer = (String) request.getSession().getAttribute(\"Referer\");\n        String redirectTo = referer != null ? referer : \"/\";\n\n        response.sendRedirect(redirectTo);\n    }\n}\n```\n\n## Display user information\n\nYou can use the `Auth0JwtPrincipal` to get profile information for the authenticated user. The following code sample demonstrates how to use the claims on the [ID token](https://auth0.com/docs/tokens/id-token) to set profile data as a request attribute:\n\n```\n// src/main/java/com/auth0/example/web/HomeServlet.java\n\n@WebServlet(urlPatterns = \"\")\npublic class HomeServlet extends HttpServlet {\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Principal principal = request.getUserPrincipal();\n\n        if (principal instanceof Auth0JwtPrincipal) {\n            Auth0JwtPrincipal auth0JwtPrincipal = (Auth0JwtPrincipal) principal;\n            request.setAttribute(\"profile\", auth0JwtPrincipal.getIdToken().getClaims());\n        }\n        request.getRequestDispatcher(\"/WEB-INF/jsp/home.jsp\").forward(request, response);\n    }\n}\n```\n\nYou can then use that profile information in your view to display information about the user:\n\n```\n<!-- src/main/webapp/WEB-INF/jsp/fragments/navbar.jspf -->\n\n<c:choose>\n    <c:when test=\"${empty profile}\">\n        <li>\n            <form action=\"/login\" method=\"GET\">\n                <input type=\"submit\" value=\"Login\"/>\n            </form>\n        </li>\n    </c:when>\n    <c:otherwise>\n        <li>\n            <a href=\"#\">\n                <!-- Profile image should be set to the profile picture from the id token -->\n                <img src=\"${profile.get('picture').asString()}\" alt=\"Profile picture\"/>\n            </a>\n            <div>\n                <!-- Show the user's full name from the id token here -->\n                <div>\"${profile.get('name').asString()}\"</div>\n                <a href=\"/profile\">Profile</a>\n                <a href=\"/logout\">Log out</a>\n            </div>\n        </li>\n    </c:otherwise>\n</c:choose>\n```\n\n## Handle logout\n\nTo log a user out, you should clear the application session and log the user out of Auth0. This is handled in the `LogoutServlet`.\n\nFirst, clear the session by calling `request.getSession().invalidate()`. Then construct the logout URL, being sure to include the `returnTo` query parameter, which is where the user will be redirected to after logging out. Finally, redirect the response to the application's logout URL:\n\n```\n// src/main/java/com/auth0/example/web/LogoutServlet.java\n\n@WebServlet(urlPatterns = \"/logout\")\npublic class LogoutServlet extends HttpServlet {\n    private final Auth0AuthenticationConfig config;\n\n    @Inject\n    LogoutServlet(Auth0AuthenticationConfig config) {\n        this.config = config;\n    }\n\n    @Override\n    protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n        clearSession(request);\n        response.sendRedirect(getLogoutUrl(request));\n    }\n\n    private void clearSession(HttpServletRequest request) {\n        if (request.getSession() != null) {\n            request.getSession().invalidate();\n        }\n    }\n\n    private String getLogoutUrl(HttpServletRequest request) {\n        String returnUrl = String.format(\"%s://%s\", request.getScheme(), request.getServerName());\n        int port = request.getServerPort();\n        String scheme = request.getScheme();\n\n        if ((\"http\".equals(scheme) && port != 80) ||\n                (\"https\".equals(scheme) && port != 443)) {\n            returnUrl += \":\" + port;\n        }\n\n        returnUrl += \"/\";\n\n        // Build logout URL like:\n        // https://{YOUR-DOMAIN}/v2/logout?client_id={YOUR-CLIENT-ID}&returnTo=http://localhost:3000/\n        String logoutUrl = String.format(\n                \"https://%s/v2/logout?client_id=%s&returnTo=%s\",\n                config.getDomain(),\n                config.getClientId(),\n                returnUrl\n        );\n\n        return logoutUrl;\n    }\n}\n```\n\n## Run the sample\n\nTo build and run the sample, execute the `wildfly:run` Maven goal to start an embedded WildFly application server with this application deployed to it. See the [WildFly Maven Plugin](https://docs.jboss.org/wildfly/plugins/maven/latest/) documentation for more information.\n\nIf you are using Linux or MacOS:\n\nWindows:\n\n```\nmvnw.cmd clean wildfly:run\n```\n\nPoint your browser to [http://localhost:3000](http://localhost:3000/). Follow the **Log In** link to log in or sign up to your Auth0 tenant.\n\n![Auth0 Universal Login](https://auth0.com/docs/media/quickstarts/universal-login.png)\n\nUpon successful login, you will see the user's profile picture and a drop-down menu where the Log In link was. You can then view the user's profile page by clicking the **Profile** link. You can log out by clicking the **Logout** link in the drop-down menu.",
  "title": "Auth0 Java EE SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to a Java EE web application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/php/interactive",
  "markdown": "# Add endpoint authorization to your PHP application\n\nAuth0 allows you to add token-based endpoint authorization to almost any application type quickly. This guide demonstrates how to integrate Auth0, add token-based authorization, and protect application routes using the Auth0 PHP SDK.\n\nTo use this quickstart, you’ll need to:\n\n*   Sign up for a free Auth0 account or log in to Auth0.\n*   Have a working PHP project that you want to integrate with Auth0. Alternatively, you can view or download a sample application after logging in.\n\nTo use Auth0 services, you need to have an application registered in the Auth0 Dashboard. The Auth0 application is where you configure how you want authentication to work for your project.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code uses to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart automatically updates for your application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure an API\n\nSimilarly, you need to create a new Auth0 API or use an existing API that represents the project you're integrating from the [Dashboard](https://manage.auth0.com/#/). Choose a unique identifier for the API and make a note of it. You need that identifier to configure your application below.\n\nAuth0 provides a [PHP SDK](https://github.com/auth0/auth0-PHP) (Auth0-PHP) to simplify the process of implementing Auth0 authentication and authorization in PHP apps.\n\nThe Auth0 PHP SDK requires [PSR-17](https://www.php-fig.org/psr/psr-17/) and [PSR-18](https://www.php-fig.org/psr/psr-18/) installed, compatible HTTP libraries for managing network requests. If you don't have libraries available, you can install reliable choices by running the following commands in your terminal:\n\n```\ncd <your-project-directory>\ncomposer require symfony/http-client nyholm/psr7\n```\n\nNow, install the Auth0 PHP SDK by running the following command in your terminal:\n\n```\ncomposer require auth0/auth0-php\n```\n\n### Configure the Auth0 SDK\n\nFor the SDK to function properly, you must set the following properties in the Auth0 SDK during initialization:\n\n*   `strategy`: The strategy helps guide the behavior of the SDK for the use case of your app. In this case, you want to set this to the constant `Auth0\\SDK\\Configuration\\SdkConfiguration::STRATEGY_API`.\n*   `domain`: The domain of your Auth0 tenant. Generally, you find this in the Auth0 Dashboard under Application's Settings in the _Domain_ field. If you are using a [custom domain](https://auth0.com/docs/custom-domains), set this to the value of your custom domain instead.\n*   `clientId`: The ID of the Auth0 Application you set up earlier in this quickstart. You can find this in the Auth0 Dashboard under your Application's Settings in the _Client ID_ field.\n*   `clientSecret`: The secret of the Auth0 application you created earlier in this quickstart. Client secret is in the Auth0 Dashboard under your Application's Settings in the _Client Secret_ field.\n*   `audience`: The identifier of the Auth0 API you registered above. This must be provided as an array.\n\n##### Checkpoint\n\nYour Auth0 SDK is now properly configured. Run your application to verify that:\n\n*   The SDK is initializing correctly.\n*   Your application is not throwing any errors related to Auth0.\n\nNext, expand your application to retrieve and process bearer tokens. Bearer tokens are access tokens provided to your API with requests from clients on a users' behalf. Access tokens approve or deny access to routes in your application. This is referred to as endpoint authorization.\n\nThe easiest way to retrieve access tokens from a request is using the PHP SDK's `getBearerToken()` method. This method fetches tokens from GET parameters, POST bodies, request headers, and other sources. In this case, the PHP SDK processes tokens passed from GET requests in the `token` parameter or from the HTTP `Authorization` header.\n\nNow, install a routing library to help direct incoming requests to your application. This isn't a required step, but simplifies the application structure for the purposes of this quickstart.\n\n```\ncomposer require steampixel/simple-php-router\n```\n\nCreate a new file in your application called `router.php` to define the routes. Copy in the code from the interactive panel to the right under the **router.php** tab.\n\nNow that you have configured your Auth0 application, the Auth0 PHP SDK, and you application retrieves bearer tokens from requests, the next step is to set up endpoint authorization for your project. The `getBearerToken()` method you implemented above returns a `Token` class that includes details on the request's access.\n\nSince the `getBearerToken()` method automatically validates and verifies the incoming request, your application determines the details of the access token by evaluating the method's response. When the response is null, no valid token has been provided. Otherwise, inspect the contents of the response to learn more about the request.\n\nIn the interactive panel to the right, you can see a check if the response is null or not to filter access to your `/api/private` route.\n\nIn some cases, you may want to filter access to a specific route based on the requested scopes in an access token. As shown in the interactive panel on the right, evaluate the contents of the 'scope' property from the `getBearerToken()` method's response to check the scopes granted by the access token.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [Auth0-PHP SDK](https://github.com/auth0/auth0-php) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 PHP API SDK Quickstarts: Add endpoint authorization to your PHP application",
  "description": "Auth0 allows you to add token-based endpoint authorization to your PHP application quickly and to protect your routes. This guide demonstrates how to integrate Auth0 with any new or existing PHP application using the Auth0 PHP SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive",
  "markdown": "# Auth0 Java Spring Boot SDK Quickstarts: Add login to your Spring Webapp\n\n## Add Login to Your Spring Web Application\n\n### Using Spring WebFlux?\n\nThis tutorial uses [Spring MVC](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html). If you are using [Spring WebFlux](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-web-reactive), the steps to add authentication are similar, but some implementation details are different. Refer to the [Spring Boot WebFlux Sample Code](https://github.com/auth0-samples/auth0-spring-boot-login-samples/tree/master/webflux-login) to see how to integrate Auth0 with your Spring Boot WebFlux application.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Add Spring dependencies\n\nTo integrate your Spring Boot application with Auth0, include the [Okta Spring Boot Starter](https://github.com/okta/okta-spring-boot/) in your application's dependencies.\n\nIf you're using Gradle, you can include these dependencies as shown below.\n\n```\nplugins {\n    id 'java'\n    id 'org.springframework.boot' version '3.1.4'\n    id 'io.spring.dependency-management' version '1.1.3'\n}\n\nimplementation 'com.okta.spring:okta-spring-boot-starter:3.0.5'\nimplementation 'org.springframework.boot:spring-boot-starter-web'\nimplementation 'org.springframework.boot:spring-boot-starter-thymeleaf'\nimplementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity6'\nimplementation 'nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect'\n```\n\nIf you are using Maven:\n\n```\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>3.1.4</version>\n    <relativePath/>\n</parent>\n\n<dependencies>\n    <dependency>\n        <groupId>com.okta</groupId>\n        <artifactId>okta-spring-boot-starter</artifactId>\n        <version>3.0.5</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-oauth2-client</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-thymeleaf</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.thymeleaf.extras</groupId>\n        <artifactId>thymeleaf-extras-springsecurity6</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>nz.net.ultraq.thymeleaf</groupId>\n        <artifactId>thymeleaf-layout-dialect</artifactId>\n    </dependency>\n</dependencies>\n```\n\nThe Okta Spring Boot Starter makes it easy to configure your application with Auth0. The sample below uses an `application.yml` file, though you can also use properties files or any of the other [supported externalization mechanisms](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config).\n\n```\n# src/main/resources/application.yml\nokta:\n  oauth2:\n    issuer: https://{yourDomain}/\n    client-id: {yourClientId}\n    client-secret: YOUR_CLIENT_SECRET\n\n# The sample and instructions above for the callback and logout URL configuration use port 3000.\n# If you wish to use a different port, change this and be sure your callback and logout URLs are\n# configured with the correct port.\nserver:\n  port: 3000\n```\n\nTo enable user login with Auth0, create a class that will register a [SecurityFilterChain](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/SecurityFilterChain.html), and add the `@Configuration` annotation.\n\nThe Okta Spring Boot Starter will use the client configuration you defined earlier to handle login when a user visits the `/oauth2/authorization/okta` path of your application. You can use this to create a login link in your application.\n\nThis page returns the user attributes when the user authentications. You will use the `/logout` link in the template to implement the logout feature.\n\nCreate a controller to handle the incoming request. This controller renders the `index.html` page. When the user authenticates, the application retrieves the users's profile information attributes to render the page.\n\n##### Checkpoint\n\nWhen you click the login link, verify the application redirects you to the [Auth0 Universal Login](https://auth0.com/universal-login) page and that you can now log in or sign up using a username and password or a social provider.\n\n![Auth0 Universal Login](https://auth0.com/docs/media/quickstarts/universal-login.png)\n\nNow that users can log into your application, they need [a way to log out](https://auth0.com/docs/logout/guides/logout-auth0). By default, when logout is enabled, Spring Security will log the user out of your application and clear the session. To enable successful logout of Auth0, you can provide a `LogoutHandler` to redirect users to your [Auth0 logout endpoint](https://auth0.com/docs/api/authentication?javascript#logout) (`https://{yourDomain}/v2/logout`) and then immediately redirect them to your application.\n\nIn the `SecurityConfig` class, provide a `LogoutHandler` that redirects to the Auth0 logout endpoint, and configure the `HttpSecurity` to add the logout handler\n\n##### Checkpoint\n\nWhen you click logout link, the application should redirect you to the address you specified as one of the \"Allowed Logout URLs\" in the \"Settings\" and you are no longer logged in to your application.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [Okta Spring Boot Starter SDK](https://github.com/okta/okta-spring-boot/) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Java Spring Boot SDK Quickstarts: Add login to your Spring Webapp",
  "description": "The Okta Spring Boot Starter makes it easy to add login to your Spring Boot application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/python/interactive",
  "markdown": "# Add Authorization to a Flask API application\n\nThis guide demonstrates how to integrate Auth0 with any new or existing Python API built with [Flask](https://flask.palletsprojects.com/).\n\nIf you haven't created an API in your Auth0 dashboard yet, you can use the interactive selector to create a new Auth0 API or select an existing API that represents the project you want to integrate with.\n\nAlternatively, you can read [our getting started guide](https://auth0.com/docs/get-started/auth0-overview/set-up-apis) that helps you set up your first API through the Auth0 dashboard.\n\nEvery API in Auth0 is configured using an API Identifier that your application code will use as the Audience to validate the Access Token.\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\n## Configure Flask to Use Auth0\n\nAdd the following dependencies to your `requirements.txt`:\n\n```\n# /requirements.txt\n\nflask\nAuthlib\n```\n\nWe're going to use a library called [Authlib](https://github.com/lepture/authlib) to create a [ResourceProtector](https://docs.authlib.org/en/latest/flask/1/resource-server.html), which is a type of [Flask decorator](https://flask.palletsprojects.com/patterns/viewdecorators/) that protects our resources (API routes) with a given validator.\n\nThe validator will validate the Access Token that we pass to the resource by checking that it has a valid signature and claims.\n\nWe can use AuthLib's `JWTBearerTokenValidator` validator with a few tweaks to make sure it conforms to our requirements on [validating Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens).\n\nTo create our `Auth0JWTBearerTokenValidator` we need to pass it our `domain` and `audience` (API Identifier). It will then get the public key required to verify the token's signature and pass it to the `JWTBearerTokenValidator` class.\n\nWe'll then override the class's `claims_options` to make sure the token's expiry, audience and issue claims are validated according to our requirements.\n\nNext we'll create a Flask application with 3 API routes:\n\n*   `/api/public` A public endpoint that requires no authentication.\n*   `/api/private` A private endpoint that requires a valid Access Token JWT.\n*   `/api/private-scoped` A private endpoint that requires a valid Access Token JWT that contains the given `scope`.\n\nThe protected routes will have a `require_auth` decorator which is a `ResourceProtector` that uses the `Auth0JWTBearerTokenValidator` we created earlier.\n\nTo create the `Auth0JWTBearerTokenValidator` we'll pass it our tenant's domain and the API Identifier of the API we created earlier.\n\nThe `require_auth` decorator on the `private_scoped` route accepts an additional argument `\"read:messages\"`, which checks the Access Token for the Permission (Scope) we created earlier.\n\n### Make a Call to Your API\n\nTo make calls to your API, you need an Access Token. You can get an Access Token for testing purposes from the **Test** view in your [API settings](https://manage.auth0.com/#/apis).\n\n![Obtain a JWT](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/request-access-token.png)\n\nProvide the Access Token as an `Authorization` header in your requests.\n\n*   [cURL](#e8533bcd194b4d9db8538f869ae674ee_shell)\n*   [C#](#e8533bcd194b4d9db8538f869ae674ee_csharp)\n*   [Go](#e8533bcd194b4d9db8538f869ae674ee_go)\n*   [Java](#e8533bcd194b4d9db8538f869ae674ee_java)\n*   [Node.JS](#e8533bcd194b4d9db8538f869ae674ee_node)\n*   [Obj-C](#e8533bcd194b4d9db8538f869ae674ee_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url http://your-domain.com/api_path \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN_HERE'\n```\n\n```\nvar client = new RestClient(\"http://your-domain.com/api_path\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://your-domain.com/api_path\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://your-domain.com/api_path\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://your-domain.com/api_path',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN_HERE'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN_HERE\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://your-domain.com/api_path\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"http://your-domain.com/api_path\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN_HERE\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"your-domain.com\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN_HERE\" }\n\nconn.request(\"GET\", \"/api_path\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://your-domain.com/api_path\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN_HERE'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN_HERE\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://your-domain.com/api_path\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [auth0-python SDK](https://github.com/auth0/auth0-python) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Python API SDK Quickstarts: Add Authorization to a Flask API application",
  "description": "This tutorial demonstrates how to add authorization to a Python API built with Flask.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/laravel/interactive",
  "markdown": "# Add Login to a Laravel Application\n\n[Auth0's Laravel SDK](https://github.com/auth0/laravel-auth0) allows you to quickly add authentication, user profile management, and routing access control to your Laravel application. This guide demonstrates how to integrate Auth0 with a new (or existing) [Laravel 9 or 10](https://github.com/auth0/laravel-auth0#support-policy) application.\n\n**If you do not already have a Laravel application set up**, open a shell to a suitable directory for a new project and run the following command:\n\n```\ncomposer create-project --prefer-dist laravel/laravel auth0-laravel-app ^9.0\n```\n\nAll the commands in this guide assume you are running them from the root of your Laravel project, directory so you should `cd` into the new project directory:\n\nRun the following command within your project directory to install the [Auth0 Laravel SDK](https://github.com/auth0/laravel-auth0):\n\n```\ncomposer require auth0/login:^7.8 --update-with-all-dependencies\n```\n\nThen generate an SDK configuration file for your application:\n\n```\nphp artisan vendor:publish --tag auth0\n```\n\nRun the following command from your project directory to download the [Auth0 CLI](https://github.com/auth0/auth0-cli):\n\n```\ncurl -sSfL https://raw.githubusercontent.com/auth0/auth0-cli/main/install.sh | sh -s -- -b .\n```\n\nThen authenticate the CLI with your Auth0 account, choosing \"as a user\" when prompted:\n\nNext, create a new application with Auth0:\n\n```\n./auth0 apps create \\\n  --name \"My Laravel Application\" \\\n  --type \"regular\" \\\n  --auth-method \"post\" \\\n  --callbacks \"http://localhost:8000/callback\" \\\n  --logout-urls \"http://localhost:8000\" \\\n  --reveal-secrets \\\n  --no-input \\\n  --json > .auth0.app.json\n```\n\nYou should also create a new API:\n\n```\n./auth0 apis create \\\n  --name \"My Laravel Application's API\" \\\n  --identifier \"https://github.com/auth0/laravel-auth0\" \\\n  --offline-access \\\n  --no-input \\\n  --json > .auth0.api.json\n```\n\nThis produces two files in your project directory that configure the SDK.\n\nAs these files contain credentials it's important to treat these as sensitive. You should ensure you do not commit these to version control. If you're using Git, you should add them to your `.gitignore` file:\n\n```\necho \".auth0.*.json\" >> .gitignore\n```\n\nThe SDK automatically registers all the necessary routes for your application's users to authenticate.\n\n| Route | Purpose |\n| --- | --- |\n| `/login` | Initiates the authentication flow. |\n| `/logout` | Logs the user out. |\n| `/callback` | Handles the callback from Auth0. |\n\nIf you require more control over these, or if they conflict with existing routes in your application, you can manually register the SDK's controllers instead. Please see [the SDK's README](https://github.com/auth0/laravel-auth0) for advanced integrations.\n\nLaravel's authentication facilities use \"guards\" to define how users are authenticated for each request. You can use the Auth0 SDK's authentication guard to restrict access to your application's routes.\n\nTo require users to authenticate before accessing a route, you can use Laravel's `auth` middleware:\n\n```\nRoute::get('/private', function () {\n  return response('Welcome! You are logged in.');\n})->middleware('auth');\n```\n\nYou can also require authenticated users to have specific [permissions](https://auth0.com/docs/manage-users/access-control/rbac) by combining this with Laravel's `can` middleware:\n\n```\nRoute::get('/scope', function () {\n    return response('You have `read:messages` permission, and can therefore access this resource.');\n})->middleware('auth')->can('read:messages');\n```\n\nInformation about the authenticated user is available through Laravel's `Auth` Facade, or the `auth()` helper function.\n\nFor example, to retrieve the user's identifier and email address:\n\n```\nRoute::get('/', function () {\n  if (! auth()->check()) {\n    return response('You are not logged in.');\n  }\n\n  $user = auth()->user();\n  $name = $user->name ?? 'User';\n  $email = $user->email ?? '';\n\n  return response(\"Hello {$name}! Your email address is {$email}.\");\n});;\n```\n\nYou can update user information using the [Auth0 Management API](https://github.com/auth0/laravel-auth0/blob/main/docs/Management.md). All Management endpoints are accessible through the SDK's `management()` method.\n\n**Before making Management API calls you must enable your application to communicate with the Management API.** This can be done from the [Auth0 Dashboard's API page](https://manage.auth0.com/#/apis/), choosing `Auth0 Management API`, and selecting the 'Machine to Machine Applications' tab. Authorize your Laravel application, and then click the down arrow to choose the scopes you wish to grant.\n\nFor the following example, in which we will update a user's metadata and assign a random favorite color, you should grant the `read:users` and `update:users` scopes. A list of API endpoints and the required scopes can be found in [the Management API documentation](https://auth0.com/docs/api/management/v2).\n\n```\nuse Auth0\\Laravel\\Facade\\Auth0;\n\nRoute::get('/colors', function () {\n  $endpoint = Auth0::management()->users();\n\n  $colors = ['red', 'blue', 'green', 'black', 'white', 'yellow', 'purple', 'orange', 'pink', 'brown'];\n\n  $endpoint->update(\n    id: auth()->id(),\n    body: [\n        'user_metadata' => [\n            'color' => $colors[random_int(0, count($colors) - 1)]\n        ]\n    ]\n  );\n\n  $metadata = $endpoint->get(auth()->id());\n  $metadata = Auth0::json($metadata);\n\n  $color = $metadata['user_metadata']['color'] ?? 'unknown';\n  $name = auth()->user()->name;\n\n  return response(\"Hello {$name}! Your favorite color is {$color}.\");\n})->middleware('auth');\n```\n\nA quick reference guide of all the SDK's Management API methods is [available here](https://github.com/auth0/laravel-auth0/blob/main/docs/Management.md).\n\nYou are now ready to start your Laravel application, so it can accept requests:\n\n##### Checkpoint\n\n### Additional Reading\n\n*   [User Repositories and Models](https://github.com/auth0/laravel-auth0/blob/main/docs/Users.md) extends the Auth0 Laravel SDK to use custom user models, and how to store and retrieve users from a database.\n*   [Hooking Events](https://github.com/auth0/laravel-auth0/blob/main/docs/Events.md) covers how to listen for events raised by the Auth0 Laravel SDK, to fully customize the behavior of your integration.\n*   [Management API](https://github.com/auth0/laravel-auth0/blob/main/docs/Management.md) support is built into the Auth0 Laravel SDK, allowing you to interact with the Management API from your Laravel application.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [laravel-auth0 SDK](https://github.com/auth0/laravel-auth0) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Laravel SDK Quickstarts: Add Login to a Laravel Application",
  "description": "Auth0's Laravel SDK allows you to quickly add authentication, user profile management, and routing access control to your Laravel application. This guide demonstrates how to integrate Auth0 with a new or existing Laravel 9 or 10 application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/rails/interactive",
  "markdown": "# Auth0 Ruby On Rails API SDK Quickstarts: Add authorization to a Ruby on Rails API\n\nThis tutorial performs access token validation using the **[jwt](https://github.com/jwt/ruby-jwt)** Gem within a custom `Auth0Client` class. A Concern called `Secured` is used to authorize endpoints which require authentication through an incoming access token.\n\nIf you have not created an API in your Auth0 dashboard yet, use the interactive selector to create a new Auth0 API or select an existing API for your project.\n\nTo set up your first API through the Auth0 dashboard, review [our getting started guide](https://auth0.com/docs/get-started/auth0-overview/set-up-apis).\n\nEach Auth0 API uses the API Identifier, which your application needs to validate the access token.\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nCreate a class called `Auth0Client`. This class decodes and verifies the incoming access token taken from the `Authorization` header of the request.\n\nThe `Auth0Client` class retrieves the public key for your Auth0 tenant and then uses it to verify the signature of the access token. The `Token` struct defines a `validate_permissions` method to look for a particular `scope` in an access token by providing an array of required scopes and check if they are present in the payload of the token.\n\nCreate a Concern called `Secured` which looks for the access token in the `Authorization` header of an incoming request.\n\nIf the token is present, the `Auth0Client.validate_token` will use the `jwt` Gem to verify the token's signature and validate the token's claims.\n\nIn addition to verifying that the access token is valid, the Concern also includes a mechanism for confirming the token has the sufficient **scope** to access the requested resources. In this example we define a `validate_permissions` method that receives a block and checks the permissions by calling the `Token.validate_permissions` method from the `Auth0Client` class.\n\nFor the `/private-scoped` route, the scopes defined will be intersected with the scopes coming in the payload, to determine if it contains one or more items from the other array.\n\nBy adding the `Secure` concern to your application controller, you'll only need to use a `before_action` filter in the controller that requires authorization.\n\nCreate a controller to handle the public endpoint `/api/public`.\n\nThe `/public` endpoint does not require any authorization so no `before_action` is needed.\n\nCreate a controller to handle the private endpoints: `/api/private` and `/api/private-scoped`.\n\n`/api/private` is available for authenticated requests containing an access token with no additional scopes.\n\n`/api/private-scoped` is available for authenticated requests containing an access token with the `read:messages` scope granted\n\nThe protected endpoints need to call the `authorize` method from the `Secured` concern, for that you use `before_action :authorize`, this ensure the `Secured.authorize` method is called before every action in the `PrivateController`.\n\n### Make a Call to Your API\n\nTo make calls to your API, you need an Access Token. You can get an Access Token for testing purposes from the **Test** view in your [API settings](https://manage.auth0.com/#/apis).\n\n![Obtain a JWT](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/request-access-token.png)\n\nProvide the Access Token as an `Authorization` header in your requests.\n\n*   [cURL](#05125301790946be8d2331336e366b69_shell)\n*   [C#](#05125301790946be8d2331336e366b69_csharp)\n*   [Go](#05125301790946be8d2331336e366b69_go)\n*   [Java](#05125301790946be8d2331336e366b69_java)\n*   [Node.JS](#05125301790946be8d2331336e366b69_node)\n*   [Obj-C](#05125301790946be8d2331336e366b69_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url http://your-domain.com/api_path \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN_HERE'\n```\n\n```\nvar client = new RestClient(\"http://your-domain.com/api_path\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://your-domain.com/api_path\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://your-domain.com/api_path\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN_HERE\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://your-domain.com/api_path',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN_HERE'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN_HERE\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://your-domain.com/api_path\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"http://your-domain.com/api_path\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN_HERE\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"your-domain.com\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN_HERE\" }\n\nconn.request(\"GET\", \"/api_path\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://your-domain.com/api_path\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN_HERE'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN_HERE\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://your-domain.com/api_path\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Checkpoint\n\nNow that you have configured your application, run your application to verify that:\n\n*   `GET /api/public` is available for non-authenticated requests.\n*   `GET /api/private` is available for authenticated requests.\n*   `GET /api/private-scoped` is available for authenticated requests containing an Access Token with the `read:messages` scope.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [omniauth-auth0 SDK](https://github.com/auth0/omniauth-auth0) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Ruby On Rails API SDK Quickstarts: Add authorization to a Ruby on Rails API",
  "description": "This tutorial demonstrates how to add authorization to a Ruby on Rails API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/java-spring-security5/interactive",
  "markdown": "# Auth0 Spring Boot API SDK Quickstarts: Spring Boot API\n\nAuth0 allows you to quickly add authorization to your application. This guide demonstrates how to integrate Auth0 with any new or existing Spring Boot application.\n\nIf you have not created an API in your Auth0 dashboard yet, use the interactive selector to create a new Auth0 API or select an existing API that represents the project you want to integrate with.\n\nReview [our getting started guide](https://auth0.com/docs/get-started/auth0-overview/set-up-apis) to set up your first API through the Auth0 dashboard.\n\nEach Auth0 API uses the API Identifier, which your application needs to validate the access token.\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nThe sample project uses a `/src/main/resources/application.yml` file, which configures it to use the correct Auth0 **domain** and **API Identifier** for your API. If you download the code from this page it will be automatically configured. If you clone the example from GitHub, you will need to fill it in yourself.\n\n| Attribute | Description |\n| --- | --- |\n| `okta.oauth2.audience` | The unique identifier for your API. If you are following the steps in this tutorial it would be `https://quickstarts/api`. |\n| `okta.oauth2.issuer` | The issuer URI of the resource server, which will be the value of the `iss` claim in the JWT issued by Auth0. Spring Security will use this property to discover the authorization server's public keys and validate the JWT signature. The value will be your Auth0 domain with an `https://` prefix and a `/` suffix (the trailing slash is important). |\n\nIf you are using Gradle, you can add the required dependencies using the [Spring Boot Gradle Plugin](https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/html/) and the [Dependency Management Plugin](https://docs.spring.io/dependency-management-plugin/docs/current/reference/html/) to resolve dependency versions:\n\n```\n// build.gradle\n\nplugins {\n    id 'java'\n    id 'org.springframework.boot' version '3.1.5'\n    id 'io.spring.dependency-management' version '1.1.3'\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'com.okta.spring:okta-spring-boot-starter:3.0.5'\n}\n```\n\nIf you are using Maven, add the Spring dependencies to your `pom.xml` file:\n\n```\n// pom.xml\n\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>3.1.5</version>\n    <relativePath/>\n</parent>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.okta.spring</groupId>\n        <artifactId>okta-spring-boot-starter</artifactId>\n        <version>3.0.5</version>\n    </dependency>\n</dependencies>\n```\n\nTo configure the application as a Resource Server and validate the JWTs, create a class that will provide an instance of `SecurityFilterChain`, and add the `@Configuration` annotation.\n\n### Protect API endpoints\n\nThe routes shown below are available for the following requests:\n\n*   `GET /api/public`: available for non-authenticated requests\n*   `GET /api/private`: available for authenticated requests containing an access token with no additional scopes\n*   `GET /api/private-scoped`: available for authenticated requests containing an access token with the `read:messages` scope granted\n\nThe example below shows how to secure API methods using the `HttpSecurity` object provided in the `filterChain()` method of the `SecurityConfig` class. Route matchers restrict access based on the level of authorization required.\n\nTo make your endpoint return a JSON, you can use a Java record. The member variables of this object is serialized into the key value for your JSON. Create a new record named `Message` as an example domain object to return during the API calls.\n\nCreate a new class named `APIController` to handle requests to the endpoints. The `APIController` has three routes as defined in the [Protect API Endpoints](https://auth0.com/docs/quickstart/backend/java-spring-security5/interactive#configure-the-resource-server) section. For this example, allow all origins through `@CrossOrigin` annotation. Real applications should configure `CORS` for their use case.\n\nTo build and run the sample project, execute the `bootRun` Gradle task.\n\nLinux or macOS:\n\nWindows:\n\nIf you are configuring your own application using Maven and the [Spring Boot Maven Plugin](https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html), you can execute the `spring-boot:run` goal.\n\nLinux or macOS:\n\nWindows:\n\n##### Checkpoint\n\nThe sample application will be available at `http://localhost:3010/`. Read about how to test and use your API in the [Using Your API](https://auth0.com/docs/quickstart/backend/java-spring-security5/02-using) article.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [Okta Spring Boot Starter SDK](https://github.com/okta/okta-spring-boot/) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Spring Boot API SDK Quickstarts: Spring Boot API",
  "description": "Secure your API using the Okta Spring Boot Starter",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/nextjs/interactive",
  "markdown": "# Add Login to your Next.js application\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.",
  "title": "Auth0 Next.js SDK Quickstarts: Add Login to your Next.js application",
  "description": "This guide demonstrates how to integrate Auth0 with any new or existing Next.js application using the Auth0 Next.js SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/nginx-plus",
  "markdown": "# Auth0 NGINX Plus SDK Quickstarts: Login\n\nThis tutorial demonstrates how to use the \\`nginx-openid-connect\\` module to add authentication and authorization to your NGINX server. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### System Requirements\n\nThis tutorial and seed project have been tested with the following:\n\n*   NGINX Plus R24\n\n**Please follow the steps below to configure your application using [NGINX Plus](https://www.nginx.com/products/nginx/) to work with Auth0 and Open ID Connect.**\n\n## Install and Enable nginx-plus-module-njs Module\n\nFirst, you need to install the nginx-plus-module-njs module for NGINX Plus. Follow the [dynamic module installation guide](https://www.nginx.com/products/nginx/dynamic-modules/) to install packages in your host OS. For Linux distributions that use `yum` package manager install as follows:\n\n```\nsudo yum install nginx-plus-module-njs jq\n```\n\nOnce you've installed it, you need to enable it for NGINX by adding the following line near the top of your `/etc/nginx/nginx.conf` file:\n\n```\nload_module modules/ngx_http_js_module.so;\n```\n\n## Checkout nginx-openid-connect Template Repository\n\nClone [`nginx-openid-connect` GitHub repository](https://github.com/nginxinc/nginx-openid-connect). This repository comes with a template configuration.\n\n```\ngit clone https://github.com/nginxinc/nginx-openid-connect\n```\n\n## Configure with Your Auth0 Application Information\n\nRun the `configure.sh` script inside nginx-openid-connect folder to populate template configuration for your Auth0 application:\n\n```\n./configure.sh --auth_jwt_key request \\\n  --client_id {yourClientId} \\\n  --pkce_enable \\\n  https://{yourDomain}/.well-known/openid-configuration\n```\n\nNext, add your tenant’s logout URL to `openid_connect_configuration.conf` file\n\n```\n# openid_connect_configuration.conf\nmap $host $oidc_logout_redirect {\n    default \"https://{yourDomain}/v2/logout\";\n}\n```\n\n## Set Accept-Encoding Type for Token and JWKS Endpoints\n\nAdd `Accept-Encoding` header in `openid_connect.server_conf`\n\n```\n# openid_connect.server_conf\nlocation = /_jwks_uri {\n    internal;\n    ...\n    proxy_set_header    Content-Length \"\";           \n    proxy_set_header    Accept-Encoding \"gzip\";          # this is required\n    ...\n}\n\nlocation = /_token {\n    internal;\n    ...\n    proxy_set_header    Content-Type \"application/x-www-form-urlencoded\";\n    proxy_set_header    Accept-Encoding \"gzip\";          # this is required\n    ...\n}\n```\n\n## Copy OpenID Connect Config Files to NGINX Server\n\nYou need to copy four files to the config folder of NGINX server machine\n\n```\nsudo cp openid_connect.js \\ \n   frontend.conf \\\n   openid_connect_configuration.conf \\\n   openid_connect.server_conf /etc/nginx/conf.d\n```\n\n## Configuring Auth0 Settings\n\nIn your application settings add a new \"Allowed Callback URLs\" that is equal to `https://server-fqdn/_codexch`.\n\nThen, change \"Token Endpoint Authentication Method\" to \"None\" in Auth0 for your Application. This is required for PKCE authorisation code flow.\n\nEdit `/etc/nginx/conf.d/frontend.conf` and add additional headers from `id_token` to the upstream target:\n\n```\n# frontend.conf\n# auth_jwt_claim_set $claim_name https://namespace/key;\n\nserver {\n    include conf.d/openid_connect.server_conf; # Authorization code flow and Relying Party processing\n    error_log /var/log/nginx/error.log debug;  # Reduce severity level as required\n\n    listen 8010; # Use SSL/TLS in production\n    \n    location / {\n        # This site is protected with OpenID Connect\n        auth_jwt \"\" token=$session_jwt;\n        error_page 401 = @do_oidc_flow;\n\n        #auth_jwt_key_file $oidc_jwt_keyfile; # Enable when using filename\n        auth_jwt_key_request /_jwks_uri; # Enable when using URL\n\n        # Successfully authenticated users are proxied to the backend,\n        # with 'sub' claim passed as HTTP header\n        proxy_set_header username $jwt_claim_sub;\n        proxy_set_header x-email $jwt_claim_email;\n        #proxy_set_header x-custom $claim_name;             # namespaced claim\n\n        proxy_pass http://my_backend; # The backend site/app\n\n        access_log /var/log/nginx/access.log main_jwt;\n    }\n}\n```",
  "title": "Auth0 NGINX Plus SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to use the `nginx-openid-connect` module to add authentication and authorization to your NGINX server.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/flutter/interactive",
  "markdown": "# Add login to your Flutter app\n\n## Add Login to Your Flutter Application\n\nAuth0 allows you to quickly add authentication and access user profile information in your application. This guide demonstrates how to integrate Auth0 with a Flutter application using the [Auth0 Flutter SDK](https://github.com/auth0/auth0-flutter).\n\nThis quickstart assumes you already have a [Flutter](https://flutter.dev/) application up and running. If not, check out the [Flutter \"getting started\" guides](https://docs.flutter.dev/get-started/install) to get started with a simple app.\n\nYou should also be familiar with the [Flutter command line tool](https://docs.flutter.dev/reference/flutter-cli).\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n### Configure Allowed Web Origins\n\nYou need to add the URL for your app to the **Allowed Web Origins** field in your [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings). If you don't register your application URL here, the application will be unable to silently refresh the authentication tokens and your users will be logged out the next time they visit the application, or refresh the page.\n\nAdd the Auth0 Flutter SDK into the project:\n\n```\nflutter pub add auth0_flutter\n```\n\nAdd the following script tag to your `index.html` page:\n\n```\n<script src=\"https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js\" defer></script>\n```\n\n[Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) is the easiest way to set up authentication in your application. We recommend using it for the best experience, best security, and the fullest array of features.\n\nIntegrate Auth0 Universal Login in your Flutter Web app by using the `Auth0Web` class. Redirect your users to the Auth0 Universal Login page using `loginWithRedirect()`.\n\nWhen a user logs in, they are redirected back to your application. You are then able to access the ID and access tokens for this user by calling `onLoad` during startup and handling the credentials that are given to you:\n\n```\nauth0.onLoad().then((final credentials) => setState(() {\n    // Handle or store credentials here\n    _credentials = credentials;\n  }));\n```\n\n##### Checkpoint\n\nAdd a button to your app that calls `loginWithRedirect()` and logs the user into your app. Verify that you are redirected to Auth0 for authentication and then back to your application.\n\nVerify that you can access `credentials` as a result of calling `onLoad` and that you're able to access the ID and access tokens.\n\nTo log users out, redirect them to the Auth0 logout endpoint to clear their login session by calling the Auth0 Flutter SDK `logout()`. [Read more about logging out of Auth0](https://auth0.com/docs/authenticate/login/logout).\n\n##### Checkpoint\n\nAdd a button to your app that calls `logout()` and logs the user out of your application. When you select it, verify that your Flutter app redirects you to the logout endpoint and back again. You should not be logged in to your application.\n\nThe user profile automatically retrieves user profile properties for you when the page loads, and can be accessed and stored by calling `onLoad` during application startup. The returned object from `onLoad` contains a `user` property with all the user profile properties. This is internally populated by decoding the ID token.\n\n##### Checkpoint\n\nLog in and inspect the `user` property on the result. Verify the current user's profile information, such as `email` or `name`.",
  "title": "Auth0 Flutter (Web) SDK Quickstarts: Add login to your Flutter app",
  "description": "This tutorial demonstrates how to add user login with Auth0 to a Flutter Web application using the Auth0 Flutter SDK",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/php/interactive",
  "markdown": "# Add Login to your PHP application\n\nAuth0 allows you to add authentication to almost any application type quickly. This guide demonstrates how to integrate Auth0, add authentication, and display user profile information in any PHP application using the Auth0 PHP SDK.\n\nTo use this quickstart, you’ll need to:\n\n*   Sign up for a free Auth0 account or log in to Auth0.\n*   Have a working PHP project that you want to integrate with. Alternatively, you can view or download a sample application after logging in.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Configure Allowed Web Origins\n\nAn Allowed Web Origin is a URL that you want to be allowed to access to your authentication flow. This must contain the URL of your project. If not properly set, your project will be unable to silently refresh authentication tokens, so your users will be logged out the next time they visit your application or refresh a page.\n\nAuth0 provides a [PHP SDK](https://github.com/auth0/auth0-PHP) (Auth0-PHP) to simplify the process of implementing Auth0 authentication and authorization in PHP apps.\n\nThe Auth0 PHP SDK requires [PSR-17](https://www.php-fig.org/psr/psr-17/) and [PSR-18](https://www.php-fig.org/psr/psr-18/) compatible HTTP libraries to be installed for managing network requests. If you don't have libraries available, you can install reliable choices by running the following commands in your terminal:\n\n```\ncd <your-project-directory>\ncomposer require symfony/http-client nyholm/psr7\n```\n\nNow install the Auth0 PHP SDK by running the following command in your terminal:\n\n```\ncomposer require auth0/auth0-php\n```\n\n### Configure the Auth0 SDK\n\nCreate a new file in your application called `index.php`, and copy in the code from the interactive panel to the right under the **index.php** tab.\n\nFor the SDK to function properly, you must set the following properties in the Auth0 SDK during initialization:\n\n*   `domain`: The domain of your Auth0 tenant. Generally, you can find this in the Auth0 Dashboard under your Application's Settings in the Domain field. If you are using a [custom domain](https://auth0.com/docs/custom-domains), you should set this to the value of your custom domain instead.\n*   `clientId`: The ID of the Auth0 Application you set up earlier in this quickstart. You can find this in the Auth0 Dashboard under your Application's Settings in the Client ID field.\n*   `clientSecret`: The secret of the Auth0 Application you set up earlier in this quickstart. You can find this in the Auth0 Dashboard under your Application's Settings in the Client Secret field.\n*   `redirectUri`: The URL in your application that you would like Auth0 to redirect users to after they have authenticated. This corresponds to the callback URL you set up earlier in this quickstart. You can also find this value in the Auth0 Dashboard under your Application's Settings in the Callback URLs field. Make sure what you enter in your code matches what you set up earlier or your users will see an error.\n*   `cookieSecret`: A long secret value used to encrypt the session cookie. You can generate a suitable string by running `openssl rand -hex 32` in your terminal.\n\n##### Checkpoint\n\nYour Auth0 SDK should now be properly configured. Run your application to verify that:\n\n*   The SDK is initializing correctly.\n*   Your application is not throwing any errors related to Auth0.\n\nNow install a routing library, to help direct incoming requests to your application. This isn't a required step, but simplifies our application structure for the purposes of this quickstart.\n\n```\ncomposer require steampixel/simple-php-router\n```\n\nCreate a new file in your application called `router.php` to define our routes, and copy in the code from the interactive panel to the right.\n\nNow that you have configured your Auth0 Application and the Auth0 PHP SDK, you need to set up login for your project. To do this, you will use the SDK’s `login()` method to create a login button that redirects users to the Auth0 Universal Login page. After a user successfully authenticates, they will be redirected to the callback URL you set up earlier in this quickstart.\n\nCreate a new file in your application called `login.php` to handle logging process, and copy in the code from the interactive panel to the right, which contains the logic needed for login.\n\n##### Checkpoint\n\nYou should now be able to log in or sign up using a username and password.\n\nClick the login link and verify that:\n\n*   Your application redirects you to the Auth0 Universal Login page.\n*   You can log in or sign up.\n*   Auth0 redirects you back to your application using the value of the `redirectUri` you used to configure the SDK.\n\nUsers who log in to your project will also need a way to log out. We will handle a logout button using the SDK’s `logout()` method. When users log out, they will be redirected to your [Auth0 logout](https://auth0.com/docs/api/authentication?http#logout) endpoint, which will then immediately redirect them to the logout URL you set up earlier in this quickstart.\n\nCreate a new file in your application called `logout.php` for handling the process, and copy in the code from the interactive panel, which contains the logic needed for logout. Then, update your `index.php` file to include the logout button.\n\n##### Checkpoint\n\nRun your application and click the logout button, verify that:\n\n*   Your application redirects you to the address you specified as one of the Allowed Logout URLs in your Application Settings.\n*   You are no longer logged in to your application.\n\nNow that your users can log in and log out, you will likely want to be able to retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with authenticated users. For example, you may want to be able to display a logged-in user’s name or profile picture in your project.\n\nThe Auth0 PHP SDK provides user information through the `getCredentials()` method. Review the `profile.php` code in the interactive panel to see an example of how to use it.\n\nBecause the method contains sensitive information related to the user's identity, its availability depends on the user's authentication status. To prevent render errors, you should always check if the `getCredentials()` method returns an `object` or `null` to determine whether Auth0 has authenticated the user before your application consumes the results.\n\n##### Checkpoint\n\nVerify that:\n\n*   You can display the `nickname` or any other user property correctly after you have logged in.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [Auth0-PHP SDK](https://github.com/auth0/auth0-php) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 PHP SDK Quickstarts: Add Login to your PHP application",
  "description": "Auth0 allows you to add authentication to your PHP application quickly and to gain access to user profile information. This guide demonstrates how to integrate Auth0 with any new or existing PHP application using the Auth0 PHP SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/angular/interactive",
  "markdown": "# Add Login to your Angular Application\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Configure Allowed Web Origins\n\nAn Allowed Web Origin is a URL that you want to be allowed to access to your authentication flow. This must contain the URL of your project. If not properly set, your project will be unable to silently refresh authentication tokens, so your users will be logged out the next time they visit your application or refresh a page.",
  "title": "Auth0 Angular SDK Quickstarts: Add Login to your Angular Application",
  "description": "Auth0 allows you to add authentication to your Angular application and gain access to user profile information. This guide demonstrates common snippets used to integrate Auth0 with any new or existing Angular application using the Auth0 Angular SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/python/interactive",
  "markdown": "# Add login to your Python Flask app\n\n## Add Login to Your Python Flask Application\n\nAuth0 allows you to add authentication and gain access to user profile information in your application. This guide demonstrates how to integrate Auth0 with a Python [Flask](https://flask.palletsprojects.com/) application using the [Authlib](https://authlib.org/) SDK.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\nCreate a `requirements.txt` file in your project directory:\n\n```\n# 📁 requirements.txt -----\n\nflask>=2.0.3\npython-dotenv>=0.19.2\nauthlib>=1.0\nrequests>=2.27.1\n```\n\nRun the following command from your shell to enable these dependencies in your project:\n\n```\npip install -r requirements.txt\n```\n\nNext, create an `.env` file in your project directory. This file will hold your client keys and other configuration details.\n\n```\n# 📁 .env -----\n\nAUTH0_CLIENT_ID={yourClientId}\nAUTH0_CLIENT_SECRET={yourClientSecret}\nAUTH0_DOMAIN={yourDomain}\nAPP_SECRET_KEY=\n```\n\n*   Generate a string for `APP_SECRET_KEY` using `openssl rand -hex 32` from your shell.\n\nNext, set up your application. Create a `server.py` file in your project directory - this file will contain your application logic.\n\nImport all the libraries your application needs.\n\nLoad the configuration `.env` file you made in the previous step.\n\nConfigure Authlib to handle your application's authentication with Auth0. To learn more about the configuration options available for Authlib's OAuth `register()` method from [their documentation.](https://docs.authlib.org/en/latest/client/frameworks.html#using-oauth-2-0-to-log-in)\n\nIn this example, you will add four routes to the application: login, callback, logout, and home.\n\nWhen visitors to your app visit the `/login` route, your application will route them to the Auth0 login page.\n\nAfter your users log in with Auth0, your application will route them to the `/callback` route. This route saves the session for the user and bypasses the need for them to login again when they return.\n\nThe `/logout` route signs users out from your application. This route clears the user session in your app and redirects to the Auth0 logout endpoint to ensure the session is no longer saved. Then, the application redirects the user to your home route.\n\nYour `/` home route either renders an authenticated user's details or allows visitors to sign in.\n\nNext, create the template file used in the home route (during `render_template()` calls).\n\nCreate a new sub-directory in your project folder named `templates`, and create `home.html` in the directory. Paste the content from the right into that file.\n\nTo run your application, navigate to the root of your project directory and open a terminal. Run the following command:\n\n##### Checkpoint\n\nVisit [http://localhost:3000](http://localhost:3000/) to verify. You should find a login button routing to Auth0 for login, then back to your application to see your profile information.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [auth0-python SDK](https://github.com/auth0/auth0-python) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Python SDK Quickstarts: Add login to your Python Flask app",
  "description": "This tutorial demonstrates how to add user login to a Python web application built with the Flask framework and Authlib OAuth library.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/rails/interactive",
  "markdown": "# Auth0 Ruby On Rails SDK Quickstarts: Add Login to Your Ruby on Rails Application\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Configure Allowed Web Origins\n\nAn Allowed Web Origin is a URL that you want to be allowed to access to your authentication flow. This must contain the URL of your project. If not properly set, your project will be unable to silently refresh authentication tokens, so your users will be logged out the next time they visit your application or refresh a page.",
  "title": "Auth0 Ruby On Rails SDK Quickstarts: Add Login to Your Ruby on Rails Application",
  "description": "This tutorial demonstrates how to add user login to a Ruby on Rails application using OmniAuth.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/vanillajs/interactive",
  "markdown": "# Add login to your JavaScript App\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Configure Allowed Web Origins\n\nAn Allowed Web Origin is a URL that you want to be allowed to access to your authentication flow. This must contain the URL of your project. If not properly set, your project will be unable to silently refresh authentication tokens, so your users will be logged out the next time they visit your application or refresh a page.",
  "title": "Auth0 JavaScript SDK Quickstarts: Add login to your JavaScript App",
  "description": "Auth0 allows you to add authentication to your JavaScript application quickly and to gain access to user profile information. This guide demonstrates how to integrate Auth0 with any new or existing JavaScript application using the Auth0 SPA SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/android/interactive",
  "markdown": "# Add Login to your Android App\n\n## Add Login to Your Android Application\n\nTo use Auth0 services, you need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure authentication in your project.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure callback URLs\n\nA callback URL is the application URL that Auth0 will direct your users to once they have authenticated. If you do not set this value, Auth0 will not return users to your application after they log in.\n\n### Configure logout URLs\n\nA logout URL is the application URL Auth0 will redirect your users to once they log out. If you do not set this value, users will not be able to log out from your application and will receive an error.\n\nAdd the [Auth0 Android](https://github.com/auth0/Auth0.Android) SDK into your project. The library will make requests to the Auth0's Authentication and Management APIs.\n\nIn your app's `build.gradle` dependencies section, add the following:\n\n```\nimplementation 'com.auth0.android:auth0:2.+'\n```\n\nEnsure you target Java 8+ byte code for Android and Kotlin plugins respectively.\n\nThe SDK requires manifest placeholders. Auth0 uses placeholders internally to define an `intent-filter`, which captures the authentication callback URL. You must set Auth0 tenant domain and the callback URL scheme.\n\nYou do not need to declare a specific `intent-filter` for your activity, because you have defined the manifest placeholders with your Auth0 **Domain** and **Scheme** values and the library will handle the redirection for you.\n\nFor the SDK to function properly, you must set the following properties in `strings.xml`:\n\n*   `com_auth0_domain`: The domain of your Auth0 tenant. Generally, you can find this in the Auth0 Dashboard under your Application's Settings in the Domain field. If you are using a [custom domain](https://auth0.com/docs/custom-domains), you should set this to the value of your custom domain instead.\n*   `com_auth0_client_id`: The ID of the Auth0 Application you set up earlier in this quickstart. You can find this in the Auth0 Dashboard under your Application's Settings in the Client ID field.\n\nEnsure that the `AndroidManifest.xml` file specifies the `android.permissions.INTERNET` permission:\n\n```\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\nRun **Sync Project with Gradle Files** inside Android Studio or execute `./gradlew clean assembleDebug` from the command line.\n\n[Universal Login](https://auth0.com/docs/hosted-pages/login) is the easiest way to set up authentication in your application. We recommend using it for the best experience, best security and the fullest array of features.\n\nIn the `onCreate` method, create a new instance of the `Auth0` class to hold user credentials.\n\nCreate a `loginWithBrowser` method and use the `WebAuthProvider` class to authenticate with any connection you enabled on your application in the [Auth0 dashboard](https://manage.auth0.com/#/). Here, you can pass the scheme value that was used in the `auth0Scheme` manifest placeholder as part of the initial configuration.\n\nAfter you call the `WebAuthProvider#start` function, the browser launches and shows the login page. Once the user authenticates, the callback URL is called. The callback URL contains the final result of the authentication process.\n\n##### Checkpoint\n\nAdd a button to your application that calls `loginWithBrowser`. When you click it, verify that your Android application redirects you to the [Auth0 Universal Login](https://auth0.com/universal-login) page and that you can now log in or sign up using a username and password or a social provider.\n\nOnce that's complete, verify that Auth0 redirects back to your app.\n\nUse `WebAuthProvider` to remove the cookie set by the browser at authentication time, so that the users are forced to re-enter their credentials the next time they try to authenticate.\n\nAdd a `logout` method to your app to remove the user's session and log them out of the app. Here, you can pass the scheme value that was used in the `auth0Scheme` manifest placeholder as part of the initial configuration.\n\nUse the `WebAuthProvider` class to implement logout. This call opens the browser and navigates the user to the logout endpoint. If the user cancels the logout, consider redirected the user to their previous URL.\n\n##### Checkpoint\n\nAdd a button to your app that calls `logout` and logs the user out of your application. When you click it, verify that your Android app redirects you logout page and back again, and that you are no longer logged in to your application.\n\nUse the `AuthenticationAPIClient` class to [retrieve the user's profile from Auth0](https://auth0.com/docs/users/user-profiles#user-profile-management-api-access). This requires:\n\n*   The access token returned from the login phase\n*   The `WebAuthProvider.login` must contain the `profile` scope\n\nYou must specify the `email` scope if you need to retreive the user's email address.\n\nThe following demonstrates a function that can be used to retrieve the user's profile and show it on the screen:\n\n##### Checkpoint\n\nCall the `showUserProfile` function after login. Verify the `onSuccess` callback returns the user's profile information.\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [Auth0.Android SDK](https://github.com/auth0/Auth0.Android) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Android SDK Quickstarts: Add Login to your Android App",
  "description": "This quickstart demonstrates how to add user login to an Android application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/vuejs/interactive",
  "markdown": "# Add Login to your Vue App\n\n## Add Login to Your Vue Application\n\nAuth0 allows you to add authentication to almost any application type. This guide demonstrates how to integrate Auth0, add authentication, and display user profile information in any Vue application using the Auth0 Vue SDK.\n\nTo use this quickstart, you will need:\n\n*   A free Auth0 account or log in to Auth0.\n*   A working Vue project that you want to integrate with OR you can download a sample application after logging in.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Configure Allowed Web Origins\n\nAn Allowed Web Origin is a URL that you want to be allowed to access to your authentication flow. This must contain the URL of your project. If not properly set, your project will be unable to silently refresh authentication tokens, so your users will be logged out the next time they visit your application or refresh a page.\n\nAuth0 provides a [Vue SDK](https://github.com/auth0/auth0-vue) to simplify the process of implementing Auth0 authentication and authorization in Vue 3 apps.\n\nInstall the Auth0 Vue SDK by running the following commands in your terminal:\n\n```\ncd <your-project-directory>\nnpm install @auth0/auth0-vue\n```\n\n### Register the plugin\n\nFor the SDK to function, you must register the plugin with your Vue application using the following properties:\n\n*   `domain`: The domain of your Auth0 tenant. This value is in the Auth0 Dashboard under your Application's Settings in the Domain field. If you are using a [custom domain](https://auth0.com/docs/custom-domains), set this to the value of your custom domain instead.\n*   `clientId`: The ID of the Auth0 Application you set up earlier in this quickstart. Find this in the Auth0 Dashboard under your Application's Settings in the Client ID field.\n*   `authorizationParams.redirect_uri`: The URL in your application that you would like Auth0 to redirect users to after they have authenticated. This corresponds to the callback URL you set up earlier in this quickstart. This value is in the Auth0 Dashboard under your Application's Settings in the Callback URLs field. Make sure what you enter in your code matches what you set up earlier or your users will see an error.\n\nThe plugin will register the SDK using both `provide` and `app.config.globalProperties`. This enables both the [Composition API](https://vuejs.org/guide/introduction.html#composition-api) and [Options API](https://vuejs.org/guide/introduction.html#options-api).\n\n##### Checkpoint\n\nThe plugin is now configured. Run your application to verify that:\n\n*   the SDK is initializing correctly\n*   your application is not throwing any errors related to Auth0\n\nNext, you will set up login for your project. You will use the SDK’s `loginWithRedirect` function exposed on the return value of `useAuth0`, which you can access in your component's setup function. It will redirect users to the Auth0 Universal Login page. and, after a user authenticates, redirect then back to the callback URL you set up earlier in this quickstart.\n\n### Using the Options API\n\nIf you are using the Options API, you can use the same `loginWithRedirect` method from the global `$auth0` property through the `this` accessor.\n\n##### Checkpoint\n\nYou should now be able to log in using Auth0 Universal Login.\n\nClick the login button and verify that:\n\n*   your Vue application redirects you to the Auth0 Universal Login page\n*   you can log in or sign up\n*   Auth0 redirects you to your application using the value of the `authorizationParams.redirect_uri` you used to configure the plugin.\n\nUsers who log in to your project will also need a way to log out. When users log out, your application will redirect them to your [Auth0 logout](https://auth0.com/docs/api/authentication?javascript#logout) endpoint, which will then redirect them to the specified `logoutParams.returnTo` parameter.\n\nUse the `logout` function exposed on the return value of `useAuth0`, which you can access in your component's `setup` function, to log the user out of your application.\n\n### Using the Options API\n\nWith the Options API, you can use the same `logout` method from the global `$auth0` property through the `this` accessor.\n\n##### Checkpoint\n\nRun your application and click the logout button, verify that:\n\n*   your Vue application redirects you to the `logoutParams.returnTo` address\n*   you are no longer logged in to your application\n\nNext, you will configure how to retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with authenticated users. For example, you may want to be able to display a logged-in user’s name or profile picture in your project. Once the user authenticates, the SDK extracts the user's profile information and stores it in memory. The application can access the user profile with the reactive `user` property. To access this property, review your component's `setup` function and find the `userAuth0` return value.\n\nThe `user` property contains sensitive information related to the user's identity. It is only available based on the user's authentication status. To prevent render errors, you should always:\n\n*   use the `isAuthenticated` property to determine whether Auth0 has authenticated the user before Vue renders any component that consumes the `user` property.\n    \n*   ensure that the SDK has finished loading by checking that `isLoading` is false before accessing the `isAuthenticated` property.\n    \n\n### Using the Options API\n\nFor the Options API, use the same reactive `user`, `isLoading`, and `isAuthenticated` properties from the global `$auth0` property through the `this` accessor.\n\n##### Checkpoint\n\nVerify that:\n\n*   you can display the `user` or any of the user properties within a component correctly after you have logged in\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [auth0-vue SDK](https://www.github.com/auth0/auth0-vue) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 Vue SDK Quickstarts: Add Login to your Vue App",
  "description": "Auth0 allows you to add authentication to almost any application type quickly. This guide demonstrates how to integrate Auth0, add authentication, and display user profile information in any Vue application using the Auth0 Vue SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/android-facebook-login",
  "markdown": "# Auth0 Android - Facebook Login SDK Quickstarts: Login\n\nThis tutorial demonstrates how to add user login to an Android application using native Facebook Login. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Android Studio 3.6.1 | Android SDK 25 | Emulator - Nexus 5X - Android 6.0\n\nThis tutorial describes how to implement login with the [Facebook SDK](https://developers.facebook.com/docs/). ​\n\n## Before You Start\n\n​\n\n*   Install and configure the [Facebook Login SDK](https://developers.facebook.com/docs/facebook-login/). You’ll also go through the process of creating a Facebook app in [https://developers.facebook.com](https://developers.facebook.com/). **When you finish this step, you should have a mobile app running with Facebook Login integrated.**\n*   Configure your Auth0 application in the dashboard to use Facebook Native Sign In. See [Add Facebook Login to Native Apps](https://auth0.com/docs/connections/nativesocial/facebook). **When you finish this step, your application will be able to implement Facebook Native Login.**\n\n## Set up the “Continue with Facebook” button\n\nThis guide will help you add authentication with Auth0 to the application you built in the first step.\n\n### Request Facebook permissions\n\nYour application is already able to sign in with Facebook. However, to ensure you have a rich user profile, you need to update the permissions with which the Facebook Login Button was set up.\n\nSet the requested permissions to `public_profile` and `email`. This way, the user email will also be included as part of the response, provided the access request is accepted by the user.\n\n```\nloginButton.setPermissions(Arrays.asList(\"public_profile\", \"email\"));\n```\n\nNow, to kick off the authentication process with Auth0, create a new method in which you will prepare the payload to be sent.\n\nYou will make use of a small interface to handle our internal callbacks.\n\nIn the sample, the method was named `performLogin` and the interface `SimpleCallback`. Go ahead and add both.\n\n```\nprivate void performLogin(@NonNull final AccessToken accessToken) {\n  // TODO\n}\n\nprivate interface SimpleCallback<T> {\n    void onResult(@NonNull T result);\n\n    void onError(@NonNull Throwable cause);\n}\n```\n\nNow, call the method from the Facebook login callback's `onSuccess` method.\n\n```\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    setContentView(R.layout.activity_login);\n\n    Auth0 account = new Auth0(getString(R.string.com_auth0_client_id), getString(R.string.com_auth0_domain));\n    auth0Client = new AuthenticationAPIClient(account);\n\n    fbCallbackManager = CallbackManager.Factory.create();\n\n    LoginButton loginButton = findViewById(R.id.login_button);\n    loginButton.setPermissions(FACEBOOK_PERMISSIONS);\n    loginButton.registerCallback(fbCallbackManager, new FacebookCallback<LoginResult>() {\n        @Override\n        public void onSuccess(LoginResult result) {\n            //1. Logged in to Facebook\n            AccessToken accessToken = result.getAccessToken();\n            performLogin(accessToken);\n        }\n\n        @Override\n        public void onCancel() {\n            //User closed the dialog. Safe to ignore\n        }\n\n        @Override\n        public void onError(FacebookException error) {\n            //Handle Facebook authentication error\n        }\n    });\n}\n```\n\n## Integrate Facebook\n\nWhen you sign in with Facebook at Auth0, the backend will perform some checks in the background to ensure the user is who they say they are. To achieve this, it needs to be provided with a Session Access Token.\n\nFurthermore, if a user needs to be created on Auth0 to represent this Facebook user, the backend will require some of their information, such as their name, last name, and email. The email, if provided, will be **flagged as non-verified** on the Auth0 user profile.\n\nTo obtain the Session Access Token and the user profile, two additional requests need to be made against the Facebook API.\n\n### Fetch Facebook session Access Token\n\nMake a new GET request against the Facebook API's `/oauth/access_token` endpoint. Use the following query parameters:\n\n*   `grant_type`: `fb_attenuate_token`.\n*   `fb_exchange_token`: the access token received upon login.\n*   `client_id`: your App ID. This value comes from the Facebook Developer's dashboard and should already be in use in your application if you have integrated Facebook Login successfully.\n\nPut the logic from this step in its own method. You will be calling it later from the previously-added method.\n\nThe sample uses the Facebook SDK's `GraphRequest` class to perform this request.\n\n```\nprivate void fetchSessionToken(String token, final SimpleCallback<String> callback) {\n    Bundle params = new Bundle();\n    params.putString(\"grant_type\", \"fb_attenuate_token\");\n    params.putString(\"fb_exchange_token\", token);\n    params.putString(\"client_id\", getString(R.string.facebook_app_id));\n\n    GraphRequest request = new GraphRequest();\n    request.setParameters(params);\n    request.setGraphPath(\"oauth/access_token\");\n    request.setCallback(new GraphRequest.Callback() {\n        @Override\n        public void onCompleted(GraphResponse response) {\n            FacebookRequestError error = response.getError();\n            if (error != null) {\n                //Failed to fetch session token\n                callback.onError(error.getException());\n                return;\n            }\n            try {\n                String fbSessionToken = response.getJSONObject().getString(\"access_token\");\n                callback.onResult(fbSessionToken);\n            } catch (JSONException e) {\n                //Failed to parse session token\n                callback.onError(e);\n            }\n        }\n    });\n    request.executeAsync();\n}\n```\n\n### Fetch Facebook user profile\n\nNow make another GET request, just like in the step above. The endpoint path will be the User ID value from the Facebook login result (for example, `/904636746222815`). Use the following parameters:\n\n*   `access_token`: the access token received upon login.\n*   `fields`: the fields from the user profile that you'd like to get back in the response. These are directly tied to the Facebook Login Button permissions that were configured at the beginning. When a permission is optional, the user must first consent to give access to it. For the purpose of signing up a user at Auth0, their full name and email will suffice.\n\n```\nprivate void fetchUserProfile(String token, String userId, final SimpleCallback<String> callback) {\n    Bundle params = new Bundle();\n    params.putString(\"access_token\", token);\n    params.putString(\"fields\", \"first_name,last_name,email\");\n\n    GraphRequest request = new GraphRequest();\n    request.setParameters(params);\n    request.setGraphPath(userId);\n    request.setCallback(new GraphRequest.Callback() {\n        @Override\n        public void onCompleted(GraphResponse response) {\n            FacebookRequestError error = response.getError();\n            if (error != null) {\n                //Failed to fetch user profile\n                callback.onError(error.getException());\n                return;\n            }\n            //Handle back the profile as received\n            callback.onResult(response.getRawResponse());\n        }\n    });\n    request.executeAsync();\n}\n```\n\n## Integrate Auth0\n\nNow that the required artifacts have been obtained, you are ready to trade them for Auth0 user credentials, such as the ID and Access Tokens. But first, you must set up the Auth0 SDK to make that last request.\n\n### Get your application keys\n\nGo to the **Applications** section of the [Auth0 Dashboard](https://manage.auth0.com/) and select the existing application in which you enabled **Sign in with Facebook**. If you need help with this step, please check the requirements section at the top of this article.\n\nCopy the **Domain** and **Client ID** values from the application settings page. These are required by the SDK.\n\nCreate two new resources in your Android application's `strings.xml` file to store them. The name of the keys must match the ones used below:\n\n```\n<resources>\n    <string name=\"com_auth0_domain\">{TENANT}</string>\n    <string name=\"com_auth0_client_id\">{CLIENT_ID}</string>\n</resources>\n```\n\n### Install the Auth0 SDK\n\nIn your Android application, add this line to the `app/build.gradle` file:\n\n```\ndependencies {\n    implementation 'com.auth0.android:auth0:1.+'\n}\n```\n\nNow is time to run the Gradle Sync task to refresh the project and its dependencies.\n\n### Web Authentication\n\nIf your application does not plan to make use of the Web Authentication module provided by the SDK, you will need to remove the unused activity from the `AndroidManifest.xml` file to prevent Manifest Placeholder issues. This can be achieved by adding an activity declaration and annotating it with `tools:node=\"remove\"`.\n\n```\n<application>\n  <!-- Add the activity declaration line below -->\n   <activity\n    android:name=\"com.auth0.android.provider.AuthenticationActivity\"\n    tools:node=\"remove\" />\n  \n</application>\n```\n\nHowever, if you do plan to support Web Authentication, head over [here](https://auth0.com/docs/libraries/auth0-android#authentication-via-universal-login) to learn how to declare the Manifest Placeholders.\n\n### Exchange the received data for Auth0 tokens\n\nThe SDK must be instantiated before use. Define a field at the class level and initialize it on the `onCreate` method. Note how the credentials defined in the step above are passed to the `Auth0` constructor and then a new instance of the `AuthenticationAPIClient` is created with it.\n\n```\nprivate AuthenticationAPIClient auth0Client;\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n\n    setContentView(R.layout.activity_login);\n\n    Auth0 account = new Auth0(getString(R.string.com_auth0_client_id), getString(R.string.com_auth0_domain));\n    auth0Client = new AuthenticationAPIClient(account);\n\n    //...\n}\n```\n\nCreate the method that will hold the logic to exchange the two obtained artifacts for Auth0 user credentials. In the sample, this method is named `exchangeTokens`.\n\nThe API client declares the method `loginWithNativeSocialToken` that receives a token and a subject type. The former corresponds to the session token, and the latter indicates what type of connection the backend will attempt to authenticate with. For native Facebook Login, you will use the following value:\n\n```\n\"http://auth0.com/oauth/token-type/facebook-info-session-access-token\"\n```\n\nOther values that need to be configured are the user profile (using the `user_profile` key) and the scope you request the Auth0 tokens contain.\n\n```\nprivate void exchangeTokens(@NonNull String sessionToken, @NonNull String userProfile, @NonNull final SimpleCallback<Credentials> callback) {\n    Map<String, Object> params = new HashMap<>();\n    params.put(\"user_profile\", userProfile);\n\n    auth0Client.loginWithNativeSocialToken(sessionToken, \"http://auth0.com/oauth/token-type/facebook-info-session-access-token\")\n            .setScope(\"openid email profile offline_access\")\n            .addAuthenticationParameters(params)\n            .start(new BaseCallback<Credentials, AuthenticationException>() {\n                @Override\n                public void onSuccess(Credentials credentials) {\n                    callback.onResult(credentials);\n                }\n\n                @Override\n                public void onFailure(AuthenticationException error) {\n                    callback.onError(error);\n                }\n            });\n}\n```\n\nNow that every step is defined in its own method, it's time to put everything together inside the `performLogin` method.\n\n```\nprivate void performLogin(@NonNull final AccessToken accessToken) {\n    final String token = accessToken.getToken();\n    fetchSessionToken(token, new SimpleCallback<String>() {\n        @Override\n        public void onResult(@NonNull final String sessionToken) {\n            //2. Obtained the Facebook session token\n            fetchUserProfile(token, accessToken.getUserId(), new SimpleCallback<String>() {\n\n                @Override\n                public void onResult(@NonNull String jsonProfile) {\n                    //3. Obtained the Facebook user profile\n                    exchangeTokens(sessionToken, jsonProfile, new SimpleCallback<Credentials>() {\n\n                        @Override\n                        public void onResult(@NonNull Credentials credentials) {\n                            /*\n                            *  4. Logged in!\n                            *     Use access token to call API\n                            *     or consume ID token locally\n                            */\n                        }\n\n                        @Override\n                        public void onError(@NonNull Throwable cause) {\n                            //Handle token exchange error\n                        }\n                    });\n                }\n\n                @Override\n                public void onError(@NonNull Throwable cause) {\n                    //Handle profile request error\n                }\n            });\n        }\n\n        @Override\n        public void onError(@NonNull Throwable cause) {\n            //Handle session token request error\n        }\n    });\n}\n```\n\nIf everything went well, you should now be able to authenticate natively with the Facebook Login SDK. This means that if the Facebook app is installed on the device, the authentication will be handled via the application and not a browser app.",
  "title": "Auth0 Android - Facebook Login SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to an Android application using native Facebook Login.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/management/v2/",
  "markdown": "Auth0 Management API v2",
  "title": "Auth0 Management API v2",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/quickstart/native/device",
  "markdown": "# Auth0 Device Authorization Flow SDK Quickstarts: Login\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Native/Mobile App](https://auth0.com/docs/quickstart/native)\n*   [Device Authorization Flow](https://auth0.com/docs/quickstart/native/device)\n\nThis tutorial demonstrates how to call your API from an input-constrained device using the Device Authorization flow. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nAuth0 makes it easy for your app to implement the Device Authorization flow using:\n\n*   Authentication API: Keep reading to learn how to call our API directly. For an interactive experience, see our [Device Flow Playground](https://auth0.github.io/device-flow-playground/).\n\n## Prerequisites\n\n**Before beginning this tutorial:**\n\n*   Check [limitations](#limitations) to be sure the Device Authorization flow is suitable for your implementation.\n    \n*   [Register the Application with Auth0](https://auth0.com/docs/dashboard/guides/applications/register-app-native).\n    \n    *   Select an **Application Type** of **Native**.\n    *   If necessary, set **Allowed Web Origins**. You can use this to allow localhost as an origin for local development, or to set an allowed origin for specific TV software with architecture subject to CORS (eg: HTML5 + JS). Most applications will not use this setting.\n    *   Ensure that the **OIDC Conformant** toggle is enabled. This setting is in the [Dashboard](https://manage.auth0.com/#) under **Application Settings > Advanced > OAuth**.\n    *   Make sure the Application's **[Grant Types](https://auth0.com/docs/dashboard/guides/applications/update-grant-types)** include **Device Code**. This is also in the [Dashboard](https://manage.auth0.com/#), under **Application Settings > Advanced > Grant Types**.\n    *   If you want your Application to be able to use [Refresh Tokens](https://auth0.com/docs/tokens/concepts/refresh-tokens), make sure the Application's **[Grant Types](https://auth0.com/docs/dashboard/guides/applications/update-grant-types)** include **Refresh Token**.\n*   Set up and enable at least one connection for the Application: [Database connections](https://auth0.com/docs/dashboard/guides/connections/set-up-connections-database), [Social connections](https://auth0.com/docs/dashboard/guides/connections/set-up-connections-social)\n    \n*   [Register your API with Auth0](https://auth0.com/docs/architecture-scenarios/mobile-api/part-2#create-the-api)\n    \n    *   If you want your API to receive [Refresh Tokens](https://auth0.com/docs/tokens/concepts/refresh-tokens) to allow it to obtain new tokens when the previous ones expire, enable **Allow Offline Access**.\n*   [Configure Device User Code Settings](https://auth0.com/docs/dashboard/guides/tenants/configure-device-user-code-settings) to define the character set, format, and length of your randomly-generated user code.\n    \n\n## Steps\n\n1.  [Request device code](#request-device-code) (Device Flow): Request a device code that the user can use to authorize the device.\n2.  [Request device activation](#request-device-activation) (Device Flow): Request that the user authorize the device using their laptop or smartphone.\n3.  [Request Tokens](#request-tokens) (Device Flow): Poll the token endpoint to request a token.\n4.  [User authorization](#user-authorization) (Browser Flow): The user authorizes the device, so the device can receive tokens.\n5.  [Receive Tokens](#receive-tokens) (Device Flow): After the user successfully authorizes the device, receive tokens.\n6.  [Call your API](#call-your-api) (Device Flow): Use the retrieved Access Token to call your API.\n7.  [Refresh Tokens](#refresh-tokens) (Device Flow): Use a Refresh Token to request new tokens when the existing ones expire.\n\nOptional: [Explore Sample Use Cases](#sample-use-cases)\n\nOptional: [Troubleshooting](#troubleshooting)\n\n## Request Device Code\n\nOnce the user has started their device app and wants to authorize the device, you'll need to get a device code. When the user begins their session in their browser-based device, this code will be bound to that session.\n\nTo get the device code, your app must request a code from the [device code URL](https://auth0.com/docs/api/authentication#get-device-code), including the Client ID.\n\n### Example POST to device code URL\n\n*   [cURL](#ca554f3780e647809d427b2e63bf4b5f_shell)\n*   [C#](#ca554f3780e647809d427b2e63bf4b5f_csharp)\n*   [Go](#ca554f3780e647809d427b2e63bf4b5f_go)\n*   [Java](#ca554f3780e647809d427b2e63bf4b5f_java)\n*   [Node.JS](#ca554f3780e647809d427b2e63bf4b5f_node)\n*   [Obj-C](#ca554f3780e647809d427b2e63bf4b5f_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/device/code' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}' \\\n  --data scope=SCOPE \\\n  --data audience=AUDIENCE\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/device/code\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"client_id=%24%7Baccount.clientId%7D&scope=SCOPE&audience=AUDIENCE\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/device/code\"\n\n\tpayload := strings.NewReader(\"client_id=%24%7Baccount.clientId%7D&scope=SCOPE&audience=AUDIENCE\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/device/code\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"client_id=%24%7Baccount.clientId%7D&scope=SCOPE&audience=AUDIENCE\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/device/code',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: {client_id: '{yourClientId}', scope: 'SCOPE', audience: 'AUDIENCE'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&scope=SCOPE\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=AUDIENCE\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/device/code\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/device/code\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"client_id=%24%7Baccount.clientId%7D&scope=SCOPE&audience=AUDIENCE\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"client_id=%24%7Baccount.clientId%7D&scope=SCOPE&audience=AUDIENCE\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/device/code\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/device/code\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"client_id=%24%7Baccount.clientId%7D&scope=SCOPE&audience=AUDIENCE\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&scope=SCOPE\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=AUDIENCE\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/device/code\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Device Code Parameters\n\nNote that when requesting a device code to call a custom API, you:\n\n*   must include an audience parameter\n*   can include additional scopes supported by the target API\n\n| Parameter Name | Description |\n| --- | --- |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `scope` | The [scopes](https://auth0.com/docs/scopes) for which you want to request authorization. These must be separated by a space. You can request any of the [standard OIDC scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, [custom claims](https://auth0.com/docs/tokens/concepts/jwt-claims#custom-claims) conforming to a [namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any [scopes supported by the target API](https://auth0.com/docs/scopes/current/api-scopes) (e.g., `read:contacts`). Include `openid` to get an ID Token or to be able to use the [/userinfo endpoint](https://auth0.com/docs/api/authentication#user-profile) to retrieve profile information for the user. Include `offline_access` to get a Refresh Token (make sure that the **Allow Offline Access** field is enabled in the [API Settings](https://manage.auth0.com/#/apis)). Note that this must be URL encoded. |\n| `audience` | The unique identifier of the API your app wants to access. Use the **Identifier** value on the [Settings](https://manage.auth0.com/#/apis) tab for the API you created as part of the prerequisites for this tutorial. Note that this must be URL encoded. |\n\n### Device Code Response\n\nIf all goes well, you'll receive an HTTP 200 response with a payload containing `device_code`, `user_code`, `verification_uri`, and `expires_in`, `interval`, and `verification_uri_complete` values:\n\n```\n{\n  \"device_code\": \"Ag_EE...ko1p\",\n  \"user_code\": \"QTZL-MCBW\",\n  \"verification_uri\": \"https://accounts.acmetest.org/activate\",\n  \"verification_uri_complete\": \"https://accounts.acmetest.org/activate?user_code=QTZL-MCBW\",\n  \"expires_in\": 900,\n  \"interval\": 5\n}\n```\n\n*   `device_code` is the unique code for the device. When the user goes to the `verification_uri` in their browser-based device, this code will be bound to their session.\n*   `user_code` contains the code that should be input at the `verification_uri` to authorize the device.\n*   `verification_uri` contains the URL the user should visit to authorize the device.\n*   `verification_uri_complete` contains the complete URL the user should visit to authorize the device. This allows your app to embed the `user_code` in the URL, if you so choose.\n*   `expires_in` indicates the lifetime (in seconds) of the `device_code` and `user_code`.\n*   `interval` indicates the interval (in seconds) at which the app should poll the token URL to request a token.\n\n## Request Device Activation\n\nOnce you have received a `device_code` and `user_code`, you must ask the user to go to the `verification_uri` on their laptop or smartphone and enter the `user_code`:\n\n![Request Device Activation](https://auth0.com/docs/media/articles/flows/guides/device-auth/request-device-activation.png)\n\nThe `device_code` is not intended for the user directly and should not be displayed during the interaction to avoid confusing the user.\n\n## Request Tokens\n\nWhile you are waiting for the user to activate the device, begin polling the token URL to request an Access Token. Using the extracted polling interval (`interval`) from the previous step, you will need to `POST` to the [token URL](https://auth0.com/docs/api/authentication#device-auth) sending along the `device_code`.\n\nTo avoid errors due to network latency, you should start counting each interval after receipt of the last polling request's response.\n\n### Example request token POST to token URL\n\n*   [cURL](#188488aa7b5840aeb01ed2b6bf39b0da_shell)\n*   [C#](#188488aa7b5840aeb01ed2b6bf39b0da_csharp)\n*   [Go](#188488aa7b5840aeb01ed2b6bf39b0da_go)\n*   [Java](#188488aa7b5840aeb01ed2b6bf39b0da_java)\n*   [Node.JS](#188488aa7b5840aeb01ed2b6bf39b0da_node)\n*   [Obj-C](#188488aa7b5840aeb01ed2b6bf39b0da_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=urn:ietf:params:oauth:grant-type:device_code \\\n  --data device_code=YOUR_DEVICE_CODE \\\n  --data 'client_id={yourClientId}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=YOUR_DEVICE_CODE&client_id=%24%7Baccount.clientId%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=YOUR_DEVICE_CODE&client_id=%24%7Baccount.clientId%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=YOUR_DEVICE_CODE&client_id=%24%7Baccount.clientId%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n    device_code: 'YOUR_DEVICE_CODE',\n    client_id: '{yourClientId}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=urn:ietf:params:oauth:grant-type:device_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&device_code=YOUR_DEVICE_CODE\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=YOUR_DEVICE_CODE&client_id=%24%7Baccount.clientId%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=YOUR_DEVICE_CODE&client_id=%24%7Baccount.clientId%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=YOUR_DEVICE_CODE&client_id=%24%7Baccount.clientId%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=urn:ietf:params:oauth:grant-type:device_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&device_code=YOUR_DEVICE_CODE\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Token Request Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to \"urn:ietf:params:oauth:grant-type:device\\_code\". This is an extension grant type (as defined by Section 4.5 of [RFC6749](https://tools.ietf.org/html/rfc6749#section-4.5)). Note that this must be URL encoded. |\n| `device_code` | The `device_code` retrieved in the previous step of this tutorial. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n\n### Token Responses\n\nWhile you wait for the user to authorize the device, you may receive a few different `HTTP 4xx` responses:\n\n#### Authorization pending\n\nYou will see this error while waiting for the user to take action. Continue polling using the suggested interval retrieved in the previous step of this tutorial.\n\n```\n`HTTP 403`\n\n{\n  \"error\": \"authorization_pending\",\n  \"error_description\": \"...\"\n}\n```\n\n#### Slow down\n\nYou are polling too fast. Slow down and use the suggested interval retrieved in the previous step of this tutorial. To avoid receiving this error due to network latency, you should start counting each interval after receipt of the last polling request's response.\n\n```\n`HTTP 429`\n\n{\n  \"error\": \"slow_down\",\n  \"error_description\": \"...\"\n}\n```\n\n#### Expired Token\n\nThe user has not authorized the device quickly enough, so the `device_code` has expired. Your application should notify the user that the flow has expired and prompt them to reinitiate the flow.\n\n```\n`HTTP 403`\n\n{ \n  \"error\": \"expired_token\",\n  \"error_description\": \"...\"\n}\n```\n\n#### Access Denied\n\nFinally, if access is denied, you will receive:\n\n```\n`HTTP 403`\n\n{\n  \"error\": \"access_denied\",\n  \"error_description\": \"...\"\n}\n```\n\nThis can occur for a variety of reasons, including:\n\n*   the user refused to authorize the device\n*   the authorization server denied the transaction\n*   a configured [Rule](https://auth0.com/docs/rules) denied access\n\n## User Authorization\n\nThe user will either scan the QR code, or else will open the activation page and enter the user code:\n\n![Enter User Code](https://auth0.com/docs/media/articles/flows/guides/device-auth/enter-user-code.png)\n\nA confirmation page will be shown to have the user confirm that this is the right device:\n\n![Confirm Device](https://auth0.com/docs/media/articles/flows/guides/device-auth/confirm-device.png)\n\nThe user will complete the transaction by signing in. This step may include one or more of the following processes:\n\n*   Authenticating the user;\n*   Redirecting the user to an Identity Provider to handle authentication;\n*   Checking for active SSO sessions;\n*   Obtaining user consent for the device, unless consent has been previously given.\n\n![Authenticate User](https://auth0.com/docs/media/articles/flows/guides/device-auth/user-auth.png)\n\nUpon successful authentication and consent, the confirmation prompt will be shown:\n\n![User Confirmation](https://auth0.com/docs/media/articles/flows/guides/device-auth/user-confirmation.png)\n\nAt this point, the user has authenticated, and the device has been authorized.\n\n## Receive Tokens\n\nWhile the user has been authenticating and authorizing the device, the device app has continued to poll the token URL to request an Access Token.\n\nOnce the user has successfully authorized the device, you'll receive an `HTTP 200` response with a payload containing `access_token`, `refresh_token` (optionally), `id_token` (optionally), `token_type`, and `expires_in` values:\n\n```\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"refresh_token\":\"GEbRxBN...edjnXbL\",\n  \"id_token\": \"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n[Access Tokens](https://auth0.com/docs/tokens/concepts/access-token) are used to call the [Auth0 Authentication API's `/userinfo` endpoint](https://auth0.com/docs/api/authentication#get-user-info) or another API. You will be able to use the Access Token to call `/userinfo` only if you included the `openid` scope. If you are calling your own API, the first thing your API will need to do is [verify the Access Token](https://auth0.com/docs/tokens/guides/validate-access-tokens).\n\n[ID Tokens](https://auth0.com/docs/tokens/concepts/id-tokens) contain user information that must be [decoded and extracted](https://auth0.com/docs/tokens/id-tokens#id-token-payload). The `id_token` will only be present in the response if you included the `openid` scope.\n\n[Refresh Tokens](https://auth0.com/docs/tokens/concepts/refresh-tokens) are used to obtain a new Access Token or ID Token after the previous one has expired. The `refresh_token` will only be present in the response if you included the `offline_access` scope and enabled **Allow Offline Access** for your API in the Dashboard.\n\n## Call your API\n\nTo call your API, the application must pass the retrieved Access Token as a Bearer token in the Authorization header of your HTTP request.\n\n*   [cURL](#0a89e7b8e64b44a5adea8a15b05fb68c_shell)\n*   [C#](#0a89e7b8e64b44a5adea8a15b05fb68c_csharp)\n*   [Go](#0a89e7b8e64b44a5adea8a15b05fb68c_go)\n*   [Java](#0a89e7b8e64b44a5adea8a15b05fb68c_java)\n*   [Node.JS](#0a89e7b8e64b44a5adea8a15b05fb68c_node)\n*   [Obj-C](#0a89e7b8e64b44a5adea8a15b05fb68c_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://myapi.com/api \\\n  --header 'authorization: Bearer ACCESS_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://myapi.com/api\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://myapi.com/api\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://myapi.com/api\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://myapi.com/api',\n  headers: {'content-type': 'application/json', authorization: 'Bearer ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://myapi.com/api\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://myapi.com/api\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"myapi.com\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer ACCESS_TOKEN\"\n    }\n\nconn.request(\"GET\", \"/api\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://myapi.com/api\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer ACCESS_TOKEN\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://myapi.com/api\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Refresh Tokens\n\nYou have already received a [Refresh Token](https://auth0.com/docs/tokens/concepts/refresh-tokens) if you've been following this tutorial and completed the following:\n\n*   configured your API to allow offline access\n*   included the `offline_access` scope when you initiated the authentication request through the [authorize](https://auth0.com/docs/api/authentication/reference#authorize-application) endpoint\n\nYou can use the Refresh Token to get a new Access Token. Usually, a user will need a new Access Token only after the previous one expires or when gaining access to a new resource for the first time. It's bad practice to call the endpoint to get a new Access Token every time you call an API, and Auth0 maintains rate limits that will throttle the amount of requests to the endpoint that can be executed using the same token from the same IP.\n\nTo refresh your token, make a `POST` request to the `/oauth/token` endpoint in the Authentication API, using `grant_type=refresh_token`.\n\n### Example refresh token POST to token URL\n\n*   [cURL](#ff08abbe11a14aac9fa9c3e72743cf2d_shell)\n*   [C#](#ff08abbe11a14aac9fa9c3e72743cf2d_csharp)\n*   [Go](#ff08abbe11a14aac9fa9c3e72743cf2d_go)\n*   [Java](#ff08abbe11a14aac9fa9c3e72743cf2d_java)\n*   [Node.JS](#ff08abbe11a14aac9fa9c3e72743cf2d_node)\n*   [Obj-C](#ff08abbe11a14aac9fa9c3e72743cf2d_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=refresh_token \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data refresh_token=YOUR_REFRESH_TOKEN\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=refresh_token&client_id=%24%7Baccount.clientId%7D&client_secret=%24%7Baccount.clientSecret%7D&refresh_token=YOUR_REFRESH_TOKEN\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=refresh_token&client_id=%24%7Baccount.clientId%7D&client_secret=%24%7Baccount.clientSecret%7D&refresh_token=YOUR_REFRESH_TOKEN\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=refresh_token&client_id=%24%7Baccount.clientId%7D&client_secret=%24%7Baccount.clientSecret%7D&refresh_token=YOUR_REFRESH_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'refresh_token',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    refresh_token: 'YOUR_REFRESH_TOKEN'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=refresh_token\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&refresh_token=YOUR_REFRESH_TOKEN\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=refresh_token&client_id=%24%7Baccount.clientId%7D&client_secret=%24%7Baccount.clientSecret%7D&refresh_token=YOUR_REFRESH_TOKEN\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=refresh_token&client_id=%24%7Baccount.clientId%7D&client_secret=%24%7Baccount.clientSecret%7D&refresh_token=YOUR_REFRESH_TOKEN\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=refresh_token&client_id=%24%7Baccount.clientId%7D&client_secret=%24%7Baccount.clientSecret%7D&refresh_token=YOUR_REFRESH_TOKEN\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=refresh_token\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&refresh_token=YOUR_REFRESH_TOKEN\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Refresh Token Request Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to \"refresh\\_token\". |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `client_secret` | Your application's Client Secret. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientSecret}/settings). |\n| `refresh_token` | The Refresh Token to use. |\n| `scope` | (Optional) A space-delimited list of requested scope permissions. If not sent, the original scopes will be used; otherwise you can request a reduced set of scopes. Note that this must be URL encoded. |\n\n### Refresh Token Response\n\nIf all goes well, you'll receive an `HTTP 200` response with a payload containing a new `access_token`, `id_token` (optionally), token lifetime in seconds (`expires_in`), granted `scope` values, and `token_type`:\n\n```\n{\n  \"access_token\": \"eyJ...MoQ\",\n  \"expires_in\": 86400,\n  \"scope\": \"openid offline_access\",\n  \"id_token\": \"eyJ...0NE\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n## Sample Use Cases\n\n### Detect Device Authorization Flow Use\n\nYou can use [Rules](https://auth0.com/docs/rules) to detect whether the current transaction is using the Device Authorization Flow. To do so, check the `context` object's `protocol` property:\n\n```\nfunction (user, context, callback) {\n   if (context.protocol === 'oauth2-device-code') {\n      ...\n   }\n \n   callback(null, user, context);\n}\n```\n\n### Sample Implementations\n\n*   [Device Authorization Playground](https://auth0.github.io/device-flow-playground/)\n*   [AppleTV (Swift)](https://github.com/pushpabrol/auth0-device-flow-appletv): Simple application that shows how Auth0 can be used with the Device Authorization Flow from an AppleTV.\n*   [CLI (Node.js)](https://gist.github.com/panva/652c61e7d847e0ed99926c324fa91b36): Sample implementation of a CLI that uses the Device Authorization Flow instead of the Authorization Code Flow. The major difference is that your CLI does not need to host a webserver and listen on a port.\n\n## Keep reading\n\n*   [The OAuth 2.0 protocol](https://auth0.com/docs/protocols/oauth2)\n*   [The OpenID Connect protocol](https://auth0.com/docs/protocols/oidc)\n*   [Tokens](https://auth0.com/docs/tokens)\n*   [Tenant Logs for Devices](https://auth0.com/docs/logs)",
  "title": "Auth0 Device Authorization Flow SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to call your API from an input-constrained device using the Device Authorization flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0js",
  "markdown": "# Auth0.js v9 Reference\n\nAuth0.js is a client-side library for Auth0. It is recommended for use in conjunction with [Universal Login](https://auth0.com/docs/universal-login), which should be used whenever possible. Using auth0.js in your SPA makes it easier to do authentication and authorization with Auth0.\n\nThe full API documentation for the library is [here](https://auth0.github.io/auth0.js/index.html).\n\n## Ready-to-go example\n\nThe [example directory](https://github.com/auth0/auth0.js/tree/master/example) of the auth0.js library is a ready-to-go app that can help you to quickly and easily try out auth0.js. In order to run it, follow these quick steps:\n\n1.  If you don't have [node](http://nodejs.org/) installed, do that now\n    \n2.  Download dependencies by running `npm install` from the root of this project\n    \n3.  Finally, execute `npm start` from the root of this project, and then browse to your app running on the node server, presumably at `http://localhost:3000/example`.\n    \n\n## Set up and initialization\n\nNow, let's get started integrating auth0.js into your project. We'll cover [methods of installation](#installation-options), [how to initialize auth0.js](#initialization), [signup](#signup), [login](#login), [logout](#logout), and more!\n\n### Configure your Auth0 application for embedded login\n\nWhen implementing embedded login, the library will use cross-origin calls inside hidden iframes to perform authentication. To make sure this can be done securely, Auth0 needs to know the domains where you will be hosting your applications.\n\nAdd the domain to the **Allowed Web Origins** field. You can find this field in the [Application Settings](https://manage.auth0.com/#/application/{yourClientId}/settings) area of your Dashboard.\n\n### Installation options\n\nYou have a few options for using auth0.js in your project. Pick one of the below depending on your needs:\n\nInstall via [npm](https://npmjs.org/) or [yarn](https://yarnpkg.com/):\n\n```\nnpm install auth0-js\n\nyarn add auth0-js\n```\n\nAfter installing the `auth0-js` module, you'll need to bundle it up along with all of its dependencies, or import it using:\n\n```\nimport auth0 from 'auth0-js';\n```\n\nAlternatively, include the script via our CDN:\n\n```\n<script src=\"https://cdn.auth0.com/js/auth0/9.18/auth0.min.js\"></script>\n```\n\n### Initialization\n\nInitialize a new instance of the Auth0 application as follows:\n\n```\n<script type=\"text/javascript\">\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n</script>\n```\n\n#### Available parameters\n\nThere are two required parameters that must be passed in the `options` object when instantiating `webAuth`, and more that are optional.\n\n| **Parameter** | **Required** | **Description** |\n| --- | --- | --- |\n| `domain` | required | (String) Your Auth0 account domain (ex. myaccount.auth0.com) |\n| `clientID` | required | (String) Your Auth0 client ID |\n| `redirectUri` | optional\\* | (String) The default `redirectUri` used. Defaults to an empty string (none). **If you do not provide a global `redirectUri` value here, you will need to provide a redirectUri value for _each_ method you use.** |\n| `scope` | optional | (String) The default scope(s) used by the application. Using scopes can allow you to return specific claims for specific fields in your request. You should read our [documentation on scopes](https://auth0.com/docs/scopes) for further details. |\n| `audience` | optional | (String) The default audience to be used for requesting API access. |\n| `responseType` | optional\\* | (String) The default `responseType` used. It can be any space separated list of the values `code`, `token`, `id_token`. It defaults to `'token'`, unless a `redirectUri` is provided, then it defaults to `'code'`. **If you do not provide a global `responseType` value, you will need to provide a `responseType` value for _each_ method you use.** |\n| `responseMode` | optional | (String) This option is omitted by default. Can be set to `'form_post'` in order to send the token or code to the `'redirectUri'` via POST. Supported values are `query`, `fragment` and `form_post`. |\n| `leeway` | optional | (Integer) A value in seconds; leeway to allow for clock skew with regard to ID Token expiration times. |\n| `_disableDeprecationWarnings` | optional | (Boolean) Disables the deprecation warnings, defaults to `false`. |\n\nBecause of clock skew issues, you may occasionally encounter the error `The token was issued in the future`. The `leeway` parameter can be used to allow a few seconds of leeway to ID Token expiration times, to prevent that from occurring.\n\n##### Scope\n\nThe default `scope` value in auth0.js v9 is `openid profile email`.\n\n#### Running Auth0.js locally\n\nIf you don't specify at least the above scope when initializing auth0.js, and you are running your website from `http://localhost` or `http://127.0.0.1`, calling the `getSSOData()` method will result in the following error in the browser console:\n\n`Consent required. When using getSSOData, the user has to be authenticated with the following scope: openid profile email`\n\nThat will not happen when you run your application in production or if you specify the `openid profile email` scope. You can read more about this in the [User consent and third-party applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications) document.\n\n## Login\n\nYou can choose a method for login based on the type of auth you need in your application.\n\nThe `authorize()` method can be used for logging in users via Universal Login, or via social connections, as exhibited in the examples below. This method invokes the `/authorize` endpoint of the Authentication API, and can take a variety of parameters via the `options` object.\n\n| **Parameter** | **Required** | **Description** |\n| --- | --- | --- |\n| `audience` | optional | (String) The default audience to be used for requesting API access. |\n| `connection` | optional | (String) Specifies the connection to use rather than presenting all connections available to the application. |\n| `scope` | optional | (String) The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OIDC scopes about users, such as `profile` and `email`, custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). Include `offline_access` to get a Refresh Token. |\n| `responseType` | optional | (String) It can be any space separated list of the values `code`, `token`, `id_token`. It defaults to `'token'`, unless a `redirectUri` is provided, then it defaults to `'code'`. |\n| `clientID` | optional | (String) Your Auth0 client ID. |\n| `redirectUri` | optional | (String) The URL to which Auth0 will redirect the browser after authorization has been granted for the user. |\n| `state` | optional | (String) An arbitrary value that should be maintained across redirects. It is useful to mitigate CSRF attacks and for any contextual information (for example, a return URL) that you might need after the authentication process is finished. For more information, see [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state). auth0.js, when used in single-page applications, handles the state generation and validation automatically if not specified. |\n| `prompt` | optional | (String) A value of `login` will force the login page to show regardless of current session. A value of `none` will attempt to bypass the login prompts if a session already exists (see the [silent authentication](https://auth0.com/docs/sso/current/single-page-apps#silent-authentication) documentation for more details). |\n\nFor hosted login, one must call the `/authorize()` method. `webAuth.authorize({ //Any additional options can go here });`\n\nFor social logins, the `connection` parameter will need to be specified: `webAuth.authorize({ connection: 'twitter' });`\n\nFor popup authentication the `popup.authorize` method can be used. Popup authentication cannot be used within hosted login pages. Typically, popup authentication is used by single page apps so the current state is not lost by doing a full page redirection.\n\nDefault authorization with popup (users see Auth0's Universal Login):\n\n```\nwebAuth.popup.authorize({\n  responseType: 'token'\n  redirectUri: 'https://{yourApp}/popup_response_handler.html'\n  //Any additional options can go here\n}, function(err, authResult) {\n  //do something\n});\n```\n\nAnd for social login with popup using `authorize`:\n\n```\nwebAuth.popup.authorize({\n  responseType: 'token'\n  redirectUri: 'https://{yourApp}/popup_response_handler.html',\n  connection: 'twitter'\n}, function(err, authResult) {\n  //do something\n});\n```\n\n#### Handling popup authentication results\n\nWhen using popup authentication, you'll have to provide a `redirectUri` where the destination page communicates the authorization results back to the callback by using the `webAuth.popup.callback` method. A simple implementation would be something like this:\n\n```\n<!-- popup_response_handler.html -->\n<html>\n  <body>\n    <script src=\"https://cdn.auth0.com/js/auth0/9.18/auth0.min.js\"></script>\n    <script type=\"text/javascript\">\n      var webAuth = new auth0.WebAuth({\n        domain:       'YOUR_AUTH0_DOMAIN',\n        clientID:     'YOUR_CLIENT_ID'\n      });\n      webAuth.popup.callback();\n    </script>\n  </body>\n</html>\n```\n\nAn ideal handler would contain just this minimal functionality (i.e. avoid reloading the whole application just to handle the response). You will need to add the `redirectUri` to the application's **Allowed Callback URLs** list in the application configuration page on the Dashboard.\n\n### webAuth.login()\n\nThe `login` method allows for [cross-origin authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication) for database connections, using `/co/authenticate`.\n\n| **Parameter** | **Required** | **Description** |\n| --- | --- | --- |\n| `username` | optional | (String) The username to present for authentication. **Either** `username` or `email` must be present. |\n| `email` | optional | (String) The email to present for authentication. **Either** `username` or `email` must be present. |\n| `password` | required | (String) The password to present for authentication. |\n| `realm` | required | (String) The name of the database connection against which to authenticate. |\n\n```\nwebAuth.login({\n  realm: 'tests',\n  username: 'testuser',\n  password: 'testpass',\n});\n```\n\n### webAuth.crossOriginVerification()\n\nThe `crossOriginVerification()` method can be used to help provide cross-origin authentication to customers who have third-party cookies disabled in their browsers. Further details about its usage can be read in the [cross-origin authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication) document.\n\n### buildAuthorizeUrl(options)\n\nThe `buildAuthorizeUrl` method can be used to build the `/authorize` URL, in order to initialize a new transaction. Use this method if you want to implement browser based (passive) authentication.\n\nto configure this snippet with your account\n\n```\n// Calculate URL to redirect to\nvar url = webAuth.client.buildAuthorizeUrl({\n  clientID: '{yourClientId}', // string\n  responseType: 'token id_token', // code\n  redirectUri: 'https://{yourApp}/callback',\n  state: '{yourState}',\n  nonce: '{yourNonce}'\n});\n\n// Redirect to url\n// ...\n```\n\nThe `state` parameter is an opaque value that Auth0 will send back to you. This method helps prevent CSRF attacks, and it needs to be specified if you redirect to the URL yourself instead of calling `webAuth.authorize()`. For more information, see [State Parameter](https://auth0.com/docs/secure/attack-protection/state-parameters).\n\n### Single Sign-On with embedded authentication\n\nApps with embedded login must meet two criteria in order to have Single Sign-on (SSO).\n\n1.  Both of the applications attempting SSO must be first-party applications. SSO with third-party applications will not work.\n    \n2.  They need to make use of custom domains and have both the applications which intend to have SSO as well as the Auth0 tenant on the same domain. Traditionally, Auth0 domains are in the format `foo.auth0.com`, but custom domains allow you to use the same domain for each of the applications in question as well as your Auth0 tenant, preventing the risk of CSRF attacks.\n    \n\nOur recommendation is to use Universal Login instead of setting up SSO in embedded login scenarios. Universal Login is the most reliable and stable way to perform SSO, and is the only way to do so if you must use multiple domains for your applications, or use [third-party applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications).\n\n## Passwordless login\n\nPasswordless authentication allows users to log in by receiving a one-time password via email or text message. The process will require you to start the Passwordless process, generating and dispatching a code to the user, (or a code within a link), followed by accepting their credentials via the verification method. That could happen in the form of a login screen which asks for their (email or phone number) and the code you just sent them. It could also be implemented in the form of a Passwordless link instead of a code sent to the user. They would simply click the link in their email or text and it would hit your endpoint and verify this data automatically using the same verification method (just without manual entry of a code by the user).\n\nIn order to use Passwordless, you will want to initialize auth0.js with a `redirectUri` and to set the `responseType: 'token'`.\n\nto configure this snippet with your account\n\n```\nvar webAuth = new auth0.WebAuth({\n  clientID: '{yourClientId}',\n  domain: '{yourDomain}',\n  redirectUri: 'http://example.com',\n  responseType: 'token id_token'\n});\n```\n\n### Start passwordless authentication\n\nThe first step in Passwordless authentication with auth0.js is the `passwordlessStart` method, which has several parameters which can be passed within its `options` object:\n\n| **Parameter** | **Required** | **Description** |\n| --- | --- | --- |\n| `connection` | required | (String) Specifies how to send the code/link to the user. Value must be either `email` or `sms`. |\n| `send` | required | (String) Value must be either `code` or `link`. If `null`, a link will be sent. |\n| `phoneNumber` | optional | (String) The user's phone number for delivery of a code or link via SMS. |\n| `email` | optional | (String) The user's email for delivery of a code or link via email. |\n\nNote that exactly one of the optional `phoneNumber` and `email` parameters must be sent in order to start the Passwordless transaction.\n\n```\nwebAuth.passwordlessStart({\n    connection: 'email',\n    send: 'code',\n    email: 'foo@bar.com'\n  }, function (err,res) {\n    // handle errors or continue\n  }\n);\n```\n\n### Complete passwordless authentication\n\nIf sending a code, you will then need to prompt the user to enter that code. You will process the code, and authenticate the user, with the `passwordlessLogin` method, which has several parameters which can be sent in its `options` object:\n\n| **Parameter** | **Required** | **Description** |\n| --- | --- | --- |\n| `connection` | required | (String) Specifies how to send the code/link to the user. Value must be either `email` or `sms` and the same as the value passed to `passwordlessStart`. |\n| `verificationCode` | required | (String) The code sent to the user, either as a code or embedded in a link. |\n| `phoneNumber` | optional | (String) The user's phone number to which the code or link was delivered via SMS. |\n| `email` | optional | (String) The user's email to which the code or link was delivered via email. |\n\nAs with `passwordlessStart`, exactly one of the optional `phoneNumber` and `email` parameters must be sent in order to verify the Passwordless transaction.\n\nIn order to use `passwordlessLogin`, the options `redirectUri` and `responseType` must be specified when first initializing WebAuth.\n\n```\nwebAuth.passwordlessLogin({\n    connection: 'email',\n    email: 'foo@bar.com',\n    verificationCode: '389945'\n  }, function (err,res) {\n    // handle errors or continue\n  }\n);\n```\n\n## Extract the authResult and get user info\n\nAfter authentication occurs, you can use the `parseHash` method to parse a URL hash fragment when the user is redirected back to your application in order to extract the result of an Auth0 authentication response. You may choose to handle this in a callback page that will then redirect to your main application, or in-page, as the situation dictates.\n\nThe `parseHash` method takes an `options` object that contains the following parameters:\n\n| **Parameter** | **Required** | **Description** |\n| --- | --- | --- |\n| `state` | optional | (String) An opaque value the application adds to the initial request that Auth0 includes when redirecting back to the application. This value is used by auth0.js to prevent CSRF attacks. |\n| `nonce` | optional | (String) Used to verify the ID Token |\n| `hash` | optional | (String) The URL hash (if not provided, `window.location.hash` will be used by default) |\n\nThe contents of the authResult object returned by `parseHash` depend upon which authentication parameters were used. It can include:\n\n| **Item** | **Description** |\n| --- | --- |\n| `accessToken` | An Access Token for the API, specified by the `audience` |\n| `expiresIn` | A string containing the expiration time (in seconds) of the `accessToken` |\n| `idToken` | An ID Token JWT containing user profile information |\n\n```\nwebAuth.parseHash({ hash: window.location.hash }, function(err, authResult) {\n  if (err) {\n    return console.log(err);\n  }\n\n  webAuth.client.userInfo(authResult.accessToken, function(err, user) {\n    // Now you have the user's information\n  });\n});\n```\n\nAs shown above, the `client.userInfo` method can be called passing the returned `accessToken`. It will make a request to the `/userinfo` endpoint and return the `user` object, which contains the user's information, formatted similarly to the below example.\n\n```\n{\n    \"sub\": \"auth0|123456789012345678901234\",\n    \"nickname\": \"johnfoo\",\n    \"name\": \"johnfoo@gmail.com\",\n    \"picture\": \"https://gravatar.com/avatar/example.png\",\n    \"updated_at\": \"2018-05-07T14:16:52.013Z\",\n    \"email\": \"johnfoo@gmail.com\",\n    \"email_verified\": \"false\"\n}\n```\n\nYou can now do something else with this information as your application needs, such as acquire the user's entire set of profile information with the Management API, as described below.\n\n## Using nonces\n\nBy default (and if `responseType` contains `id_token`), `auth0.js` will generate a random `nonce` when you call `webAuth.authorize`, store it in local storage, and pull it out in `webAuth.parseHash`. The default behavior should work in most cases, but some use cases may require a developer to control the `nonce`. If you want to use a developer generated `nonce`, then you must provide it as an option to both `webAuth.authorize` and `webAuth.parseHash`. `webAuth.authorize({nonce: '1234', responseType: 'token id_token'}); webAuth.parseHash({nonce: '1234'}, callback);`\n\nIf you're calling `webAuth.checkSession` instead of `webAuth.authorize`, then you only have to specify your custom `nonce` as an option to `checkSession`:\n\n```\nwebAuth.checkSession({\n  nonce: '1234',\n}, function (err, authResult) {\n    ...\n});\n```\n\nThe `webAuth.checkSession` method will automatically verify that the returned ID Token's `nonce` claim is the same as the option.\n\n## Error Codes and Descriptions\n\nWhen Auth0.js is used for embedded login, it employs the `/co/authenticate` endpoint, which can produce the following errors:\n\n| **Status** | **Code** | **Description** |\n| --- | --- | --- |\n| 400 | invalid\\_request | Invalid request body. All and only of client\\_id, credential\\_type, username, otp, realm are required. |\n| 401 | unauthorized\\_client | Cross origin login not allowed. |\n| 400 | unsupported\\_credential\\_type | Unknown credential type parameter. |\n| 400 | invalid\\_request | Unknown realm non-existent-connection. |\n| 403 | access\\_denied | Wrong email or password. |\n| 403 | access\\_denied | Authentication error |\n| 403 | blocked\\_user | Blocked user |\n| 401 | password\\_leaked | This login attempt has been blocked because the password you're using was previously disclosed through a data breach (not in this application). |\n| 429 | too\\_many\\_attempts | Your account has been blocked after multiple consecutive login attempts. We've sent you a notification via your preferred contact method with instructions on how to unblock it. |\n| 429 | too\\_many\\_attempts | We have detected suspicious login behavior and further attempts will be blocked. Please contact the administrator. |\n\nIn addition, you can also get a generic 403 error without an `error` or `error_description` property. The response body would just include something similar to the following: `Origin https://test.app is not allowed.`\n\n## Logout\n\nTo log out a user, use the `logout()` method. This method accepts an options object, which can include the following parameters.\n\nIf the `clientID` parameter is included, the `returnTo` URL that is provided must be listed in the Application's **Allowed Logout URLs** in the [Auth0 dashboard](https://manage.auth0.com/#). However, if the `clientID` parameter is not included, the `returnTo` URL must be listed in the **Allowed Logout URLs** at the account level in the [Auth0 dashboard](https://manage.auth0.com/#).\n\n```\nwebAuth.logout({\n  returnTo: 'some url here',\n  clientID: 'some client ID here'\n});\n```\n\n## Signup\n\nTo sign up a user, use the `signup` method. This method accepts an options object, which can include the following parameters.\n\n| **Parameter** | **Required** | **Description** |\n| --- | --- | --- |\n| `email` | required | (String) User's email address |\n| `password` | required | (String) User's desired password |\n| `username` | required\\* | (String) User's desired username.  <br>\\*Required if you use a database connection and you have enabled **Requires Username** |\n| `connection` | required | (String) The database connection name on your application upon which to attempt user account creation |\n| `user_metadata` | optional | (JSON object) Additional attributes used for user information. Will be stored in [user\\_metadata](https://auth0.com/docs/users/concepts/overview-user-metadata) |\n\nSignups should be for database connections. Here is an example of the `signup` method and some sample code for a form.\n\n```\n<h2>Signup Database Connection</h2>\n<input class=\"signup-email\" />\n<input type=\"password\" class=\"signup-password\" />\n<input type=\"button\" class=\"signup-db\" value=\"Signup!\" />\n<script type=\"text/javascript\">\n    $('.signup-db').click(function (e) {\n        e.preventDefault();\n        webAuth.signup({\n            connection: 'Username-Password-Authentication',\n            email: $('.signup-email').val(),\n            password: $('.signup-password').val(),\n            user_metadata: { plan: 'silver', team_id: 'a111' }\n        }, function (err) {\n            if (err) return alert('Something went wrong: ' + err.message);\n            return alert('success signup without login!')\n        });\n    });\n</script>\n```\n\n## Using checkSession to acquire new tokens\n\nThe `checkSession` method allows you to acquire a new token from Auth0 for a user who is already authenticated against Auth0 for your domain. The method accepts any valid OAuth2 parameters that would normally be sent to `authorize`. If you omit them, it will use the ones provided when initializing Auth0.\n\nThe call to `checkSession` can be used to get a new token for the API that was specified as the audience when `webAuth` was initialized:\n\n```\nwebAuth.checkSession({}, function (err, authResult) {\n  // err if automatic parseHash fails\n  ...\n});\n```\n\nSee [Extract the AuthResult and Get User Info](#extract-the-authresult-and-get-user-info) for the format of `authResult`.\n\nOr, the token can be acquired for a different API than the one used when initializing `webAuth` by specifying an `audience` and `scope`:\n\n```\nwebAuth.checkSession(\n  {\n    audience: `https://mydomain/another-api/˜`,\n    scope: 'read:messages'\n  }, function (err, authResult) {\n  // err if automatic parseHash fails\n  ...\n});\n```\n\nNote that `checkSession()` triggers any [rules](https://auth0.com/docs/customize/rules) you may have set up, so you should check on your rules in the [Dashboard](https://manage.auth0.com/#/rules) prior to using it.\n\nThe actual redirect to `/authorize` happens inside an iframe, so it will not reload your application or redirect away from it.\n\nHowever, the browser **must** have third-party cookies enabled. Otherwise, **checkSession()** is unable to access the current user's session (making it impossible to obtain a new token without displaying anything to the user). The same will happen if users have [Safari's ITP enabled](https://auth0.com/docs/troubleshoot/authentication-issues/renew-tokens-when-using-safari).\n\nRemember to add the URL where the authorization request originates from, to the **Allowed Web Origins** list of your Auth0 application in the [Dashboard](https://manage.auth0.com/#) under your application's **Settings**.\n\n### Polling with checkSession()\n\nIn some multi-application scenarios, where Single Logout is desired (a user logging out of one application needs to be logged out of other applications), an application can be set up to periodically poll Auth0 using `checkSession()` to see if a session exists. If the session does not exist, you can then log the user out of the application. The same polling method can be used to implement silent authentication for a Single Sign-on (SSO) scenario.\n\nThe poll interval between checks to `checkSession()` should be at least 15 minutes between calls to avoid any issues in the future with rate limiting of this call.\n\n## Password reset requests\n\nIf attempting to set up a password reset functionality, you'll use the `changePassword` method and pass in an \"options\" object, with a \"connection\" parameter and an \"email\" parameter.\n\n```\n$('.change_password').click(function () {\n    webAuth.changePassword({\n      connection: 'db-conn',\n      email:   'foo@bar.com'\n    }, function (err, resp) {\n      if(err){\n        console.log(err.message);\n      }else{\n        console.log(resp);\n      }\n    });\n  });\n```\n\nThe user will then receive an email which will contain a link that they can follow to reset their password.\n\n## User management\n\nThe Management API provides functionality that allows you to link and unlink separate user accounts from different providers, tying them to a single profile (See [User Account Linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking) for details.) It also allows you to update user metadata.\n\nTo get started, you first need to obtain a an Access Token that can be used to call the Management API. You can do it by specifying the `https://{yourDomain}/api/v2/` audience when initializing auth0.js, in which case you will get the Access Token as part of the authentication flow.\n\nIf you use [custom domains](https://auth0.com/docs/customize/custom-domains), you will need to instantiate a new copy of `webAuth` using your Auth0 domain rather than your custom one, for use with the Management API calls, as it only works with Auth0 domains.\n\n```\nvar webAuth = new auth0.WebAuth({\n  clientID: '{yourClientId}',\n  domain: '{yourDomain}',\n  redirectUri: 'http://example.com',\n  audience: `https://{yourDomain}/api/v2/`,\n  scope: 'read:current_user',\n  responseType: 'token id_token'\n});\n```\n\nYou can also do so by using `checkSession()`:\n\n```\nwebAuth.checkSession(\n  {\n    audience: `https://{yourDomain}/api/v2/`,\n    scope: 'read:current_user'\n  }, function(err, result) {\n     // use result.accessToken\n  }\n);\n```\n\nYou must specify the specific scopes you need. You can ask for the following scopes:\n\n*   `read:current_user`\n    \n*   `update:current_user_identities`\n    \n*   `create:current_user_metadata`\n    \n*   `update:current_user_metadata`\n    \n*   `delete:current_user_metadata`\n    \n*   `create:current_user_device_credentials`\n    \n*   `delete:current_user_device_credentials`\n    \n\nOnce you have the Access Token, you can create a new `auth0.Management` instance by passing it the account's Auth0 domain, and the Access Token.\n\n```\nvar auth0Manage = new auth0.Management({\n  domain: '{yourDomain}',\n  token: 'ACCESS_TOKEN'\n});\n```\n\n### Getting the user profile\n\nIn order to get the user profile data, use the `getUser()` method, with the `userId` and a callback as parameters. The method returns the user profile. Note that the `userID` required here will be the same one fetched from the `client.userInfo` method. `auth0Manage.getUser(userId, cb);`\n\n### Updating the user profile\n\nWhen updating user metadata, you will need to first create a `userMetadata` object, and then call the `patchUserMetadata` method, passing it the user id and the `userMetadata` object you created. The values in this object will overwrite existing values with the same key, or add new ones for those that don't yet exist in the user metadata. See the [Metadata](https://auth0.com/docs/manage-users/user-accounts/metadata) documentation for more details on user metadata. `auth0Manage.patchUserMetadata(userId, userMetadata, cb);`\n\n### Linking users\n\nLinking user accounts will allow a user to authenticate from any of their accounts and no matter which one they use, still pull up the same profile upon login. Auth0 treats all of these accounts as separate profiles by default, so if you wish a user's accounts to be linked, this is the way to go.\n\nThe `linkUser` method accepts two parameters, the primary `userId` and the secondary user's ID Token (the token obtained after login with this identity). The user ID in question is the unique identifier for the primary user account. The ID should be passed with the provider prefix, e.g., `auth0|1234567890` or `facebook|1234567890`, when using this method. See [User Account Linking](https://auth0.com/docs/users/concepts/overview-user-account-linking) for details. `auth0Manage.linkUser(userId, secondaryUserToken, cb);`\n\nAfter linking the accounts, the second account will no longer exist as a separate entry in the user database, and will only be accessible as part of the primary one. When accounts are linked, the secondary account's metadata is **not** merged with the primary account's metadata, and if they are ever unlinked, the secondary account will likewise not retain the primary account's metadata when it becomes separate again.",
  "title": "Auth0.js v9 Reference",
  "description": "How to install, initialize and use auth0.js v9",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api/authentication",
  "markdown": "# Authentication API Explorer\n\n## Introduction\n\nThe Authentication API enables you to manage all aspects of user identity when you use Auth0. It offers endpoints so your users can log in, sign up, log out, access APIs, and more.\n\nThe API supports various identity protocols, like [OpenID Connect](https://auth0.com/docs/protocols/oidc), [OAuth 2.0](https://auth0.com/docs/protocols/oauth2), [FAPI](https://auth0.com/docs/secure/highly-regulated-identity#advanced-security-with-openid-connect-fapi-) and [SAML](https://auth0.com/docs/protocols/saml).\n\n## Base URL\n\nThe Authentication API is served over HTTPS. All URLs referenced in the documentation have the following base: `https://{yourDomain}`\n\n## Authentication methods\n\nYou have five options for authenticating with this API:\n\n*   OAuth2 Access Token\n*   Client ID and Client Assertion (confidential applications)\n*   Client ID and Client Secret (confidential applications)\n*   Client ID (public applications)\n*   mTLS Authentication (confidential applications)\n\n### OAuth2 Access Token\n\nSend a valid Access Token in the `Authorization` header, using the `Bearer` authentication scheme.\n\nAn example is the [Get User Info endpoint](#get-user-info). In this scenario, you get an Access Token when you authenticate a user, and then you can make a request to the [Get User Info endpoint](#get-user-info), using that token in the `Authorization` header, in order to retrieve the user's profile.\n\n### Client ID and Client Assertion\n\nGenerate a [client assertion](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt) containing a signed JSON Web Token (JWT) to authenticate. In the body of the request, include your Client ID, a `client_assertion_type` parameter with the value `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`, and a `client_assertion` parameter with your signed assertion. Review [Private Key JWT](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt) for examples.\n\n### Client ID and Client Secret\n\nSend the Client ID and Client Secret. The method you can use to send this data is determined by the [Token Endpoint Authentication Method](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/view-application-type) configured for your application.\n\nIf you are using **Post**, you must send this data in the JSON body of your request.\n\nIf you are using **Basic**, you must send this data in the `Authorization` header, using the `Basic` authentication scheme. To generate your credential value, concatenate your Client ID and Client Secret, separated by a colon (`:`), and encode it in Base64.\n\nAn example is the [Revoke Refresh Token endpoint](#revoke-refresh-token). This option is available only for confidential applications (such as applications that are able to hold credentials in a secure way without exposing them to unauthorized parties).\n\n### Client ID\n\nSend the Client ID. For public applications (applications that cannot hold credentials securely, such as SPAs or mobile apps), we offer some endpoints that can be accessed using only the Client ID.\n\nAn example is the [Implicit Grant](#implicit-flow).\n\n### mTLS Authentication\n\nGenerate a certificate, either [self-signed](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#self-signed-certificates) or [certificate authority signed](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#certificate-authority-signed-certificates). Then, [set up the customer edge network](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge) that performs the mTLS handshake.\n\nOnce your edge network verifies the certificate, forward the request to the Auth0 edge network with the following headers:\n\n*   The Custom Domain API key as the `cname-api-key` header.\n*   The client certificate as the `client-certificate` header.\n*   The client certificate CA verification status as the `client-certificate-ca-verified` header. For more information, see [Forward the Request](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge#forward-the-request-).\n\nTo learn more, read [Authenticate with mTLS](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls).\n\n## Parameters\n\nFor GET requests, any parameters not specified as a segment in the path can be passed as an HTTP query string parameter:\n\n`GET https://{yourDomain}/some-endpoint?param=value&param=value`\n\nFor POST requests, parameters not included in the URL should be encoded as JSON with a Content-Type of `application/json`:\n\n`curl --request POST --url 'https://{yourDomain}/some-endpoint' --header 'content-type: application/json' --data '{\"param\": \"value\", \"param\": \"value\"}'`\n\n## Code samples\n\nFor each endpoint, you will find sample snippets you can use, in three available formats:\n\n*   HTTP request\n*   Curl command\n*   JavaScript: depending on the endpoint each snippet may use the [Auth0.js library](https://auth0.com/docs/libraries/auth0js), Node.js code or simple JavaScript\n\nEach request should be sent with a Content-Type of `application/json`.\n\n## Testing\n\nYou can test the endpoints using the [Authentication API Debugger](https://auth0.com/docs/extensions/authentication-api-debugger).\n\n### Authentication API Debugger\n\nThe [Authentication API Debugger](https://auth0.com/docs/extensions/authentication-api-debugger) is an Auth0 extension you can use to test several endpoints of the Authentication API.\n\nClick on **Install Debugger** to go to the article that explains how (you only have to do this once).\n\n**If you have already installed the extension, skip to the Authentication API Debugger.**\n\nThe link varies according to your tenant's region: [US West](https://{yourtenant}.us.webtask.io/auth0-authentication-api-debugger), [Europe Central](https://{yourtenant}.eu.webtask.io/auth0-authentication-api-debugger) or [Australia](https://{yourtenant}.au.webtask.io/auth0-authentication-api-debugger).\n\n### Configure Connections\n\n1.  On the _Configuration_ tab, set the fields **Application** (select the application you want to use for the test) and **Connection** (the name of the social connection to use).\n    \n2.  Copy the **Callback URL** and set it as part of the **Allowed Callback URLs** of your [Application Settings](https://manage.auth0.com/#/applications).\n    \n3.  At the _OAuth2 / OIDC_ tab, select **OAuth2 / OIDC Login**.\n    \n\n### Endpoint options\n\nConfigure other endpoints with the following options:\n\n*   Passwordless: On the _OAuth2 / OIDC_ tab, set **Username** to the user's phone number if `connection=sms`, or the user's email if `connection=email`, and **Password** to the user's verification code. Click **Resource Owner Endpoint**.\n*   SAML SSO: On the _Other Flows_ tab, select **SAML**.\n*   WS-Federation: On the _Other Flows_ tab, select **WS-Federation**.\n*   Logout: On the _Other Flows_ tab, select **Logout**, or **Logout (Federated)** to log the user out of the identity provider as well.\n*   Legacy Login: On the _OAuth2 / OIDC_ tab, set the fields **ID Token**, **Refresh Token** and **Target Client ID**. Click **Delegation**.\n*   Legacy Delegation: On the _OAuth2 / OIDC_ tab, set **Username** and **Password**. Click **Resource Owner Endpoint**.\n*   Legacy Resource Owner: On the _OAuth2 / OIDC_ tab, set the **Username** and **Password**, then select **Resource Owner Endpoint**.\n\n### Authentications flows\n\nConfigure authentication flows with the following options:\n\n*   Authorization Code Flow: On the _OAuth2 / OIDC_ tab, set the field **Authorization Code** to the code you retrieved from [Authorization Code Grant](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow), and the **Code Verifier** to the key. Click **OAuth2 Code Exchange**.\n*   Authorization Code Flow + PKCE: On the _OAuth2 / OIDC_ tab, set the field **Authorization Code** to the code you retrieved from [Authorization Code Grant](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce), and the **Code Verifier** to the key. Click **OAuth2 Code Exchange**.\n*   Client Credential Flow: On the _OAuth2 / OIDC_ tab, select **OAuth2 Client Credentials**.\n\n## Errors\n\nWhen an error occurs, you will receive an error object. Most of these error objects contain an error code and an error description so that your applications can more efficiently identify the problem.\n\nIf you get an `4xx` HTTP response code, then you can assume that there is a bad request from your end. In this case, check the [Standard Error Responses](#standard-error-responses) for more context.\n\n`5xx` errors suggest a problem on Auth0's end, so in this case, check [Auth0 Status Page](https://status.auth0.com/) and [@auth0status on Twitter](https://twitter.com/auth0status) to see how our systems are doing.\n\nIn any other case you can use [our support options](#support).\n\n## Rate limiting\n\nThe Authentication API is subject to rate limiting. The limits differ per endpoint.\n\nIf you exceed the provided rate limit for a given endpoint, you will receive the `429 Too Many Requests` response with the following message: `Too many requests. Check the X-RateLimit-Limit, X-RateLimit-Remaining and X-RateLimit-Reset headers.`\n\nFor details on rate limiting, refer to [Auth0 API Rate Limit Policy](https://auth0.com/docs/policies/rate-limits).\n\nNote that for database connections Auth0 limits certain types of repeat login attempts depending on the user account and IP address. For details, refer to [Rate Limits on User/Password Authentication](https://auth0.com/docs/policies/rate-limit-policy/database-connections-rate-limits).\n\n## Support\n\nIf you have problems or need help with your case, you can always reach out to our [Support](https://support.auth0.com/).\n\nNote that if you have a free subscription plan, and you are not in your 22-day trial period, you will not be able to access or open tickets in the [Support Center](https://support.auth0.com/). In this case, you can seek support through the [Auth0 Community](https://community.auth0.com/). For more info on our support program, refer to [Support Options](https://auth0.com/docs/support).\n\n## Login\n\n```\nGET https://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection=CONNECTION&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE&\n  ADDITIONAL_PARAMETERS\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize app\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Trigger login with google\n  webAuth.authorize({\n    connection: 'google-oauth2'\n  });\n\n  // Trigger login with github\n  webAuth.authorize({\n    connection: 'github'\n  });\n\n  // Trigger login popup with twitter\n  webAuth.popup.authorize({\n    connection: 'twitter'\n  });\n</script>\n```\n\nYou can connect your Auth0 service to a social identity provider and allow your users to log in to your application via Facebook, Google, Apple, or other supported providers. To learn more about supported providers, visit [Marketplace](https://marketplace.auth0.com/features/social-connections).\n\nTo authenticate users with a social provider, make a `GET` call to the `/authorize` endpoint. It will return a `302` redirect to the social provider specified in the `connection` parameter.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`response_type`  \nRequired\n\nSpecifies the token type. Use `code` for server side flows and `token` for application side flows\n\n`client_id`  \nRequired\n\nThe `client_id` of your application\n\n`connection`\n\nThe name of a social identity provider configured to your application, for example `google-oauth2` or `facebook`. If null, it will redirect to the [Auth0 Login Page](https://{yourdomain}/login) and show the Login Widget.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user. Specify the `redirect_uri` under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n`state`  \nRecommended\n\nAn opaque value the applications adds to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n`ADDITIONAL_PARAMETERS`\n\nAppend any additional parameter to the end of your request, and it will be sent to the provider. For example, `access_type=offline` (for Google Refresh Tokens) , `display=popup` (for Windows Live popup mode).\n\n*   If `response_type=token`, after the user authenticates on the provider, it will redirect to your application `callback URL` passing the Access Token and ID Token in the address `location.hash`. This is used for Single-Page Apps and also on Native Mobile SDKs.\n    \n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n    \n\n### Learn More\n\n*   [Supported Social Identity Providers](https://marketplace.auth0.com/features/social-connections)\n*   [Custom Social Connections](https://auth0.com/docs/connections/social/oauth2)\n*   [State Parameter](https://auth0.com/docs/secure/attack-protection/state-parameters)\n*   [Auth0.js /authorize Method Reference](https://auth0.com/docs/libraries/auth0js#webauth-authorize-)\n\n```\nGET https://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection=CONNECTION&\n  redirect_uri={https://yourApp/callback}&\n  scope=openid%20profile%20email&\n  state=STATE\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize app\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Calculate URL to redirect to\n  var url = webAuth.client.buildAuthorizeUrl({\n    clientID: '{yourClientId}', // string\n    responseType: 'token', // code or token\n    redirectUri: '{https://yourApp/callback}',\n    scope: 'openid profile email'\n    state: 'YOUR_STATE'\n  });\n\n  // Redirect to url\n  // ...\n</script>\n```\n\nUse the Auth0 user store or your own database to store and manage username and password credentials. If you have your own user database, you can use it as an identity provider in Auth0 to authenticate users. When you make a `GET` call to the `/authorize` endpoint for browser based (passive) authentication. It returns a `302` redirect to the [Auth0 Login Page](https://{yourdomain}/login) that will show the Login Widget where the user can log in with email and password.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`response_type`  \nRequired\n\nSpecifies the token type. Use `code` for server side flows and `token` for application side flows.\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`connection`\n\nThe name of the connection configured to your application. If null, it will redirect to the [Auth0 Login Page](https://{yourdomain}/login) and show the Login Widget using the first database connection.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user. Specify the `redirect_uri` under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n`scope`  \nRecommended\n\nOIDC scopes and custom API scopes. For example: `openid read:timesheets`. Include `offline_access` to get a Refresh Token.\n\n`state`  \nRecommended\n\nAn opaque value the applications adds to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n*   If `response_type=token`, after the user authenticates, it will redirect to your application `callback URL` passing the Access Token and ID Token in the address `location.hash`. This is used for Single-Page Apps and also on Native Mobile SDKs.\n*   The main difference between passive and active authentication is that the former happens in the browser through the [Auth0 Login Page](https://{yourdomain}/login) and the latter can be invoked from anywhere (a script, server to server, and so forth).\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Learn More\n\n*   [Database Identity Providers](https://auth0.com/docs/connections/database)\n*   [Rate Limits on User/Password Authentication](https://auth0.com/docs/policies/rate-limit-policy/database-connections-rate-limits)\n*   [Active Directory/LDAP Connector](https://auth0.com/docs/connector)\n*   [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state)\n*   [Auth0.js /authorize Method Reference](https://auth0.com/docs/libraries/auth0js#webauth-authorize-)\n\n## Enterprise (SAML and Others)\n\n```\nGET https://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection=CONNECTION&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Calculate URL to redirect to\n  var url = webAuth.client.buildAuthorizeUrl({\n    clientID: 'YOUR_CLIENT_ID', // string\n    responseType: 'token', // code or token\n    redirectUri: 'https://YOUR_APP/callback',\n    scope: 'openid profile email'\n    state: 'YOUR_STATE'\n  });\n\n  // Redirect to url\n  // ...\n</script>\n```\n\nYou can connect your Auth0 service to an enterprise identity provider and allow your users to log in to your application via Microsoft Azure Active Directory, Google Workspace, Okta Workforce, or other supported providers. To learn more about supported providers, visit [Auth0 Marketplace](https://marketplace.auth0.com/features/enterprise-connections).\n\nMake a `GET` call to the `/authorize` endpoint for passive authentication. It returns a `302` redirect to the SAML Provider (or Windows Azure AD and the rest, as specified in the `connection`) to enter their credentials.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`response_type`  \nRequired\n\nSpecifies the token type. Use `code` for server side flows, `token` for application side flows.\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`connection`\n\nThe name of the connection configured to your application. If null, it will redirect to the [Auth0 Login Page](https://{yourdomain}/login) and show the Login Widget using the first database connection.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user. Specify the `redirect_uri` under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n`state`  \nRecommended\n\nAn opaque value the applications adds to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n*   If no `connection` is specified, it will redirect to the [Login Page](https://{yourdomain}/login) and show the Login Widget.\n*   If `response_type=token`, after the user authenticates, it will redirect to your application `callback URL` passing the Access Token and ID Token in the address `location.hash`. This is used for Single-Page Apps and also on Native Mobile SDKs.\n*   Additional parameters can be sent that will be passed to the provider.\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Learn More\n\n*   [SAML](https://auth0.com/docs/protocols/saml)\n*   [Obtain a Client Id and Client Secret for Microsoft Azure Active Directory](https://auth0.com/docs/connections/enterprise/azure-active-directory)\n*   [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state)\n*   [Auth0.js /authorize Method Reference](https://auth0.com/docs/libraries/auth0js#webauth-authorize-)\n\n## Logout\n\n## Auth0 Logout\n\n### GET /v2/logout\n\n```\nGET https://{yourDomain}/v2/logout?\n  client_id={yourClientId}&\n  returnTo=LOGOUT_URL\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/v2/logout' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"returnTo\":\"LOGOUT_URL\"}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n  \n  webAuth.logout({\n    returnTo: 'YOUR_LOGOUT_URL',\n    client_id: '{yourClientId}'\n  });\n</script>\n```\n\nUse this endpoint to logout a user. If you want to navigate the user to a specific URL after the logout, set that URL at the `returnTo` parameter. The URL should be included in any the appropriate `Allowed Logout URLs` list:\n\n*   If the `client_id` parameter is included, the `returnTo` URL must be listed in the `Allowed Logout URLs` set at the application level. To learn more, read [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications).\n*   If the `client_id` parameter is NOT included, the `returnTo` URL must be listed in the `Allowed Logout URLs` set at the tenant level. To learn more, read [Log Users Out of Auth0](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0).\n*   If the `client_id` parameter is included and the `returnTo` URL is NOT set, the server returns the user to the first Allowed Logout URLs set in the Dashboard. To learn more, read [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`returnTo`\n\nURL to redirect the user after the logout.\n\n`client_id`\n\nThe `client_id` of your application.\n\n`federated`\n\nAdd this query string parameter to the logout URL, to log the user out of their identity provider, as well: `https://{yourDomain}/v2/logout?federated`.\n\n*   Logging the user out of their identity provider is not common practice, so think about the user experience before you use the `federated` query string parameter.\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Learn More\n\n*   [Logout](https://auth0.com/docs/logout)\n\n## OIDC Logout\n\n### GET /oidc/logout\n\n```\nGET https://{yourDomain}/oidc/logout?\n  post_logout_redirect_uri=LOGOUT_URL&\n  id_token_hint=ID_TOKEN_HINT\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/oidc/logout' \\\n  --header 'content-type: application/json' \\\n  --data-raw '\n  { \n    \"client_id\":\"{yourClientId}\", \n    \"post_logout_redirect_uri\":\"LOGOUT_URL\", \n    \"id_token_hint\":\"ID_TOKEN_HINT\"\n  }'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n  \n  webAuth.logout({\n    post_logout_redirect_uri: 'YOUR_LOGOUT_URL',\n    id_token_hint: 'YOUR_ID_TOKEN_HINT'\n  });\n</script>\n```\n\nUse this endpoint to logout a user. If you want to navigate the user to a specific URL after the logout, set that URL at the `post_logout_redirect_uri` parameter. The URL should be included in the appropriate `Allowed Logout URLs` list:\n\n*   If the `id_token_hint` parameter is included:\n    \n    *   When the `client_id` parameter is included, the server uses the URL from the `aud` claim in the `id_token_hint` to select which of the `Allowed Logout URLs` to use from the application specified by the `client_id`.\n    *   When the `client_id` parameter is NOT included, the server uses the URL from the `aud` claim in the `id_token_hint` to select which of the `Allowed Logout URLs` at the tenant level to use.\n*   If the `id_token_hint` parameter is not included:\n    \n    *   If the `client_id` parameter is included, the `post_logout_redirect_uri` URL must be listed in the `Allowed Logout URLs` set at the application level.\n    *   If the `client_id` parameter is NOT included, the `post_logout_redirect_uri` URL must be listed in the `Allowed Logout URLs` set at the tenant level.\n    *   If the `client_id` parameter is included and the `post_logout_redirect_uri` URL is NOT set, the server returns the user to the first `Allowed Logout URLs` set in Auth0 Dashboard.\n    \n    To learn more, read [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0).\n    \n\n### Request Parameters\n\nParameter\n\nDescription\n\n`id_token_hint` (Recommended)\n\nPreviously issued ID Token for the user. This is used to indicate which user to log out.\n\n`logout_hint` (Optional)\n\nOptional `sid` (session ID) value to indicate which user to log out. Should be provided when `id_token_hint` is not available.\n\n`post_logout_redirect_uri` (Optional)\n\nURL to redirect the user after the logout.\n\n`client_id` (Optional)\n\nThe `client_id` of your application.\n\n`federated` (Optional)\n\nAdd this query string parameter to log the user out of their identity provider: `https://YOUR_DOMAIN/oidc/logout?federated`.\n\n`state` (Optional)\n\nAn opaque value the applications adds to the initial request that the authorization server includes when redirecting the back to the`post_logout_redirect_uri`.\n\n`ui_locales` (Optional)\n\nSpace-delimited list of locales used to constrain the language list for the request. The first locale on the list must match the enabled locale in your tenant\n\n*   Logging the user out of their social identity provider is not common practice, so think about the user experience before you use the `federated` query string parameter with social identity providers.\n*   If providing both `id_token_hint` and `logout_hint`, the `logout_hint` value must match the `sid` claim from the id\\_token\\_hint.\n*   If providing both `id_token_hint` and `client_id`, the `client_id` value must match the `aud` claim from the `id_token_hint`.\n*   If `id_token_hint` is not provided, then the user will be prompted for consent unless a `logout_hint` that matches the user's session ID is provided.\n*   The `POST` HTTP method is also supported for this request. When using `POST`, the request parameters should be provided in the request body as form parameters instead of the query string. The federated parameter requires a value of `true` or `false`.\n*   This conforms to the [OIDC RP-initiated Logout Specification](https://openid.net/specs/openid-connect-rpinitiated-1_0.html).\n\n### Learn More\n\n*   [Logout](https://auth0.com/docs/logout)\n*   [Use the OIDC Endpoint to Log Users Out of Auth0](https://auth0.com/docs/logout/log-users-out-of-auth0)\n*   [OIDC RP-initiated Logout Specification](https://openid.net/specs/openid-connect-rpinitiated-1_0.html)\n\n## SAML Logout\n\n```\nPOST https://{yourDomain}/samlp/CLIENT_ID/logout\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/samlp/CLIENT_ID/logout' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data '{SAML_LOGOUT_REQUEST}'\n```\n\nUse this endpoint to log out a user from an Auth0 tenant configured as a SAML identity provider (IdP).\n\nLogout behavior is determined by the configuration of the SAML2 Web App addon for the application on the Auth0 tenant acting as the SAML IdP. To learn more, read [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps#configure-slo-when-auth0-is-the-saml-idp).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`CLIENT_ID`\n\nClient ID of your application configured with the [SAML2 Web App addon](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon).\n\n`SAML_LOGOUT_REQUEST`\n\nSAML `<LogoutRequest>` message.\n\n*   The POST body must contain a valid SAML `<LogoutRequest>` message. To learn more, read [Assertions and Protocols for the OASIS Security Assertion Markup Language (SAML) V2.0 on Oasis](https://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf).\n\n### Learn More\n\n*   [Logout](https://auth0.com/docs/logout)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n\n## Passwordless\n\nPasswordless connections do not require the user to remember a password. Instead, another mechanism is used to prove identity, such as a one-time code sent through email or SMS, every time the user logs in.\n\n## Get Code or Link\n\n```\nPOST https://{yourDomain}/passwordless/start\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\", // for web applications\n  \"connection\": \"email|sms\",\n  \"email\": \"USER_EMAIL\", //set for connection=email\n  \"phone_number\": \"USER_PHONE_NUMBER\", //set for connection=sms\n  \"send\": \"link|code\", //if left null defaults to link\n  \"authParams\": { // any authentication parameters that you would like to add\n    \"scope\": \"openid\",\n    \"state\": \"YOUR_STATE\"\n  }\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/passwordless/start' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"connection\":\"email|sms\", \"email\":\"USER_EMAIL\", \"phone_number\":\"USER_PHONE_NUMBER\", \"send\":\"link|code\", \"authParams\":{\"scope\": \"openid\",\"state\": \"YOUR_STATE\"}}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Send a verification code using email\n  webAuth.passwordlessStart({\n      connection: 'email',\n      send: 'code',\n      email: 'USER_EMAIL'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n\n  // Send a link using email\n  webAuth.passwordlessStart({\n      connection: 'email',\n      send: 'link',\n      email: 'USER_EMAIL'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n\n  // Send a verification code using SMS\n  webAuth.passwordlessStart({\n      connection: 'sms',\n      send: 'code',\n      phoneNumber: 'USER_PHONE_NUMBER'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n</script>\n```\n\n### POST /passwordless/start\n\nYou have three options for [passwordless authentication](https://auth0.com/docs/connections/passwordless):\n\n*   Send a verification code using email.\n*   Send a link using email.\n*   Send a verification code using SMS.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`client_assertion`  \n\nA JWT containing containing a signed assertion with your applications credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nUse the value `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nThe `client_secret` of your application. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`. Specifically required for Regular Web Applications **only**.\n\n`connection`  \nRequired\n\nHow to send the code/link to the user. Use `email` to send the code/link using email, or `sms` to use SMS.\n\n`email`\n\nSet this to the user's email address, when `connection=email`.\n\n`phone_number`\n\nSet this to the user's phone number, when `connection=sms`.\n\n`send`\n\nUse `link` to send a link or `code` to send a verification code. If null, a link will be sent.\n\n`authParams`\n\nUse this to append or override the link parameters (like `scope`, `redirect_uri`, `protocol`, `response_type`), when you send a link using email.\n\n*   If you sent a verification code, using either email or SMS, after you get the code, you have to authenticate the user using the [/passwordless/verify endpoint](#authenticate-user), using `email` or `phone_number` as the `username`, and the verification code as the `password`.\n*   This endpoint is designed to be called from the client-side, and is subject to [rate limits](https://auth0.com/docs/policies/rate-limit-policy/authentication-api-endpoint-rate-limits).\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Errors > POST /passwordless/start](#post-passwordless-start).\n\n### Learn More\n\n*   [Passwordless Authentication](https://auth0.com/docs/connections/passwordless)\n*   [Passwordless Best Practices](https://auth0.com/docs/connections/passwordless/best-practices)\n\n## Authenticate User\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/json\n{\n  \"grant_type\" : \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\", // for web applications\n  \"otp\": \"CODE\",\n  \"realm\": \"email|sms\" //email or sms\n  \"username\":\"USER_EMAIL|USER_PHONE_NUMBER\", // depends on which realm you chose\n  \"audience\" : \"API_IDENTIFIER\", // in case you need an access token for a specific API\n  \"scope\": \"SCOPE\",\n  \"redirect_uri\": \"REDIRECT_URI\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/json' \\\n  --data '{\"grant_type\":\"http://auth0.com/oauth/grant-type/passwordless/otp\", \"client_id\":\"{yourClientId}\", \"client_secret\":\"CLIENT_SECRET\", \"otp\":\"CODE\", \"realm\":\"email|sms\", \"username\":\"USER_EMAIL|USER_PHONE_NUMBER\", \"audience\":\"API_IDENTIFIER\", \"scope\":\"SCOPE\", \"redirect_uri\": \"REDIRECT_URI\"}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Verify code sent via email\n  webAuth.passwordlessLogin({\n      connection: 'email',\n      email: 'USER_EMAIL',\n      verificationCode: 'VERIFICATION_CODE_SENT'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n\n  // Verify code sent within link using email\n  webAuth.passwordlessLogin({\n      connection: 'email',\n      email: 'USER_EMAIL',\n      verificationCode: 'VERIFICATION_CODE_SENT_WITHIN_LINK'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n\n  // Verify code sent via SMS\n  webAuth.passwordlessLogin({\n      connection: 'sms',\n      phoneNumber: 'USER_PHONE_NUMBER',\n      verificationCode: 'VERIFICATION_CODE_SENT'\n    }, function (err,res) {\n      // handle errors or continue\n    }\n  );\n</script>\n```\n\n### POST /oauth/token\n\nOnce you have a verification code, use this endpoint to login the user with their phone number/email and verification code.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nIt should be `http://auth0.com/oauth/grant-type/passwordless/otp`.\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nThe `client_secret` of your application. Required\\*\\* when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`. Specifically required for Regular Web Applications **only**.\n\n`username`  \nRequired\n\nThe user's phone number if `realm=sms`, or the user's email if `realm=email`.\n\n`realm`  \nRequired\n\nUse `sms` or `email` (should be the same as [POST /passwordless/start](#get-code-or-link))\n\n`otp`  \nRequired\n\nThe user's verification code.\n\n`audience`\n\nAPI Identifier of the API for which you want to get an Access Token.\n\n`scope`\n\nUse `openid` to get an ID Token, or `openid profile email` to also include user profile information in the ID Token.\n\n`redirect_uri`  \nRequired\n\nA callback URL that has been registered with your application's **Allowed Callback URLs**.\n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Standard Error Responses](#standard-error-responses).\n\n### Learn More\n\n*   [Passwordless Authentication](https://auth0.com/docs/connections/passwordless)\n\n### POST /passwordless/verify\n\nOnce you have a verification code, use this endpoint to login the user with their phone number/email and verification code. This is active authentication, so the user must enter the code in your app.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`connection`  \nRequired\n\nUse `sms` or `email` (should be the same as [POST /passwordless/start](#get-code-or-link))\n\n`grant_type`  \nRequired\n\nUse `password`\n\n`username`  \nRequired\n\nThe user's phone number if `connection=sms`, or the user's email if `connection=email`.\n\n`password`  \nRequired\n\nThe user's verification code.\n\n`scope`\n\nUse `openid` to get an ID Token, or `openid profile email` to include also user profile information in the ID Token.\n\n*   The `profile` scope value requests access to the End-User's default profile Claims, which are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`.\n*   The `email` scope value requests access to the `email` and `email_verified` Claims.\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Errors > POST /passwordless/verify](#post-passwordless-verify).\n\n### Learn More\n\n*   [Passwordless Best Practices](https://auth0.com/docs/connections/passwordless/best-practices)\n\n## Signup\n\n```\nPOST https://{yourDomain}/dbconnections/signup\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"email\": \"EMAIL\",\n  \"password\": \"PASSWORD\",\n  \"connection\": \"CONNECTION\",\n  \"username\": \"johndoe\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n  \"name\": \"John Doe\",\n  \"nickname\": \"johnny\",\n  \"picture\": \"http://example.org/jdoe.png\"\n  \"user_metadata\": { plan: 'silver', team_id: 'a111' }\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/dbconnections/signup' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"email\":\"test.account@signup.com\", \"password\":\"PASSWORD\", \"connection\":\"CONNECTION\", \"username\": \"johndoe\", \"given_name\": \"John\", \"family_name\": \"Doe\", \"name\": \"John Doe\", \"nickname\": \"johnny\", \"picture\": \"http://example.org/jdoe.png\", \"user_metadata\":{ \"plan\": \"silver\", \"team_id\": \"a111\" }}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize client\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n  \n  webAuth.signup({ \n    connection: 'CONNECTION', \n    email: 'EMAIL', \n    password: 'PASSWORD',\n    username: \"johndoe\",\n    given_name: \"John\",\n    family_name: \"Doe\",\n    name: \"John Doe\",\n    nickname: \"johnny\",\n    picture: \"http://example.org/jdoe.png\",\n    user_metadata: { plan: 'silver', team_id: 'a111' }\n  }, function (err) { \n    if (err) return alert('Something went wrong: ' + err.message); \n      return alert('success signup without login!') \n  });\n</script>\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"_id\": \"58457fe6b27...\",\n  \"email_verified\": false,\n  \"email\": \"test.account@signup.com\",\n  \"username\": \"johndoe\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n  \"name\": \"John Doe\",\n  \"nickname\": \"johnny\",\n  \"picture\": \"http://example.org/jdoe.png\"\n}\n```\n\n### POST /dbconnections/signup\n\nGiven a user's credentials and a `connection`, this endpoint creates a new user.\n\nThis endpoint only works for database connections.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your client.\n\n`email`  \nRequired\n\nThe user's email address.\n\n`password`  \nRequired\n\nThe user's desired password.\n\n`connection`  \nRequired\n\nThe name of the database configured to your client.\n\n`username`\n\nThe user's username. Only valid if the connection requires a username.\n\n`given_name`\n\nThe user's given name(s).\n\n`family_name`\n\nThe user's family name(s).\n\n`name`\n\nThe user's full name.\n\n`nickname`\n\nThe user's nickname.\n\n`picture`\n\nA URI pointing to the user's picture.\n\n`user_metadata`\n\nThe [user metadata](https://auth0.com/docs/users/concepts/overview-user-metadata) to be associated with the user. If set, the field must be an object containing no more than ten properties. Property names can have a maximum of 100 characters, and property values must be strings of no more than 500 characters.\n\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n\n### Learn More\n\n*   [Password Strength in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-strength)\n*   [Password Options in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-options)\n*   [Adding Username for Database Connections](https://auth0.com/docs/connections/database/require-username)\n*   [Metadata Overview](https://auth0.com/docs/users/concepts/overview-user-metadata)\n\n## Change Password\n\n```\nPOST https://{yourDomain}/dbconnections/change_password\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"email\": \"EMAIL\",\n  \"connection\": \"CONNECTION\",\n  \"organization\": \"ORGANIZATION_ID\"\n}\n```\n\n```\ncurl --request POST \\\n  --url https://{yourDomain}/dbconnections/change_password \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\",\"email\": \"EMAIL\", \"connection\": \"CONNECTION\", \"organization\": \"ORGANIZATION_ID\"}'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n  \n  webAuth.changePassword({\n    connection: 'CONNECTION',\n    email:   'EMAIL',\n    organization: 'ORGANIZATION_ID'\n  }, function (err, resp) {\n    if(err){\n      console.log(err.message);\n    }else{\n      console.log(resp);\n    }\n  });\n</script>\n```\n\n### POST /dbconnections/change\\_password\n\n> RESPONSE SAMPLE:\n\n```\n\"We've just sent you an email to reset your password.\"\n```\n\nSend a change password email to the user's provided email address and `connection`.\n\nOptionally, you may provide an Organization ID to support Organization-specific variables in [customized email templates](https://auth0.com/docs/customize/email/email-templates#common-variables) and to include the `organization_id` and `organization_name` parameters in the **Redirect To** URL.\n\nNote: This endpoint only works for database connections.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`\n\nThe `client_id` of your client. We strongly recommend including a Client ID so that the email template knows from which client the request was triggered.\n\n`email`  \nRequired\n\nThe user's email address.\n\n`connection`  \nRequired\n\nThe name of the database connection configured to your client.\n\n`organization`\n\nThe `organization_id` of the Organization associated with the user.\n\n*   When the user clicks on the password change link they will be redirected to a page asking them for a new password.\n*   This endpoint will return three HTTP Response Headers, that provide relevant data on its rate limits:\n    *   `X-RateLimit-Limit`: Number of requests allowed per minute.\n    *   `X-RateLimit-Remaining`: Number of requests available. Each new request reduces this number by 1. For each minute that passes, requests are added back, so this number increases by 1 each time.\n    *   `X-RateLimit-Reset`: Remaining time until the rate limit (`X-RateLimit-Limit`) resets. The value is in [UTC epoch seconds](https://en.wikipedia.org/wiki/Unix_time).\n\n### Learn More\n\n*   [Changing a User's Password](https://auth0.com/docs/connections/database/password-change)\n*   [Password Strength in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-strength)\n*   [Password Options in Auth0 Database Connections](https://auth0.com/docs/connections/database/password-options)\n*   [Auth0 API Rate Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations)\n\n## User Profile\n\n## Get User Info\n\n```\nGET https://{yourDomain}/userinfo\nAuthorization: 'Bearer {ACCESS_TOKEN}'\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/userinfo' \\\n  --header 'Authorization: Bearer {ACCESS_TOKEN}' \\\n  --header 'Content-Type: application/json'\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize the Auth0 application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Parse the URL and extract the Access Token\n  webAuth.parseHash(window.location.hash, function(err, authResult) {\n    if (err) {\n      return console.log(err);\n    }\n    webAuth.client.userInfo(authResult.accessToken, function(err, user) {\n        // This method will make a request to the /userinfo endpoint\n        // and return the user object, which contains the user's information,\n        // similar to the response below.\n    });\n  });\n</script>\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"sub\": \"248289761001\",\n  \"name\": \"Jane Josephine Doe\",\n  \"given_name\": \"Jane\",\n  \"family_name\": \"Doe\",\n  \"middle_name\": \"Josephine\",\n  \"nickname\": \"JJ\",\n  \"preferred_username\": \"j.doe\",\n  \"profile\": \"http://exampleco.com/janedoe\",\n  \"picture\": \"http://exampleco.com/janedoe/me.jpg\",\n  \"website\": \"http://exampleco.com\",\n  \"email\": \"janedoe@exampleco.com\",\n  \"email_verified\": true,\n  \"gender\": \"female\",\n  \"birthdate\": \"1972-03-31\",\n  \"zoneinfo\": \"America/Los_Angeles\",\n  \"locale\": \"en-US\",\n  \"phone_number\": \"+1 (111) 222-3434\",\n  \"phone_number_verified\": false,\n  \"address\": {\n    \"country\": \"us\"\n  },\n  \"updated_at\": \"1556845729\"\n}\n```\n\n### GET /userinfo\n\nGiven the Auth0 Access Token obtained during login, this endpoint returns a user's profile.\n\nThis endpoint will work only if `openid` was granted as a scope for the Access Token. The user profile information included in the response depends on the scopes requested. For example, a scope of just `openid` may return less information than a a scope of `openid profile email`.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`access_token`  \nRequired\n\nThe Auth0 Access Token obtained during login.\n\n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n*   The auth0.js `parseHash` method, requires that your tokens are signed with `RS256`, rather than `HS256`.\n*   To return `user_metadata` or other custom information from this endpoint, add a custom claim to the ID token with an [Action](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims#create-custom-claims). For more information refer to [User profile claims and scope](https://auth0.com/docs/api-auth/tutorials/adoption/scope-custom-claims).\n*   This endpoint will return three HTTP Response Headers, that provide relevant data on its rate limits:\n    *   `X-RateLimit-Limit`: Number of requests allowed per minute.\n    *   `X-RateLimit-Remaining`: Number of requests available. Each new request reduces this number by 1. For each minute that passes, requests are added back, so this number increases by 1 each time.\n    *   `X-RateLimit-Reset`: Remaining time until the rate limit (`X-RateLimit-Limit`) resets. The value is in [UTC epoch seconds](https://en.wikipedia.org/wiki/Unix_time).\n*   The `Email` claim returns a snapshot of the email at the time of login\n*   Standard claims (other than `email`) return the latest value (unless the value comes from an external IdP)\n*   Custom claims always returns the latest value of the claim\n*   To access the most up-to-date values for the `email` or custom claims, you must get new tokens. You can log in using silent authentication (where the `prompt` parameter for your call to the [`authorize` endpoint](https://auth0.com/docs/api/authentication#authorization-code-grant) equals `none`)\n*   To access the most up-to-date values for standard claims that were changed using an external IdP (for example, the user changed their email address in Facebook)., you must get new tokens. Log in again using the external IdP, but _not_ with silent authentication.\n\n### Learn More\n\n*   [Auth0.js v8 Reference: Extract the authResult and get user info](https://auth0.com/docs/libraries/auth0js#extract-the-authresult-and-get-user-info)\n    \n*   [Auth0 API Rate Limit Policy](https://auth0.com/docs/policies/rate-limits)\n    \n\n## Multi-factor Authentication\n\nThe Multi-factor Authentication (MFA) API endpoints allow you to enforce MFA when users interact with [the Token endpoints](#get-token), as well as enroll and manage user authenticators.\n\nFirst, request a challenge based on the challenge types supported by the application and user. If you know that one-time password (OTP) is supported, you can skip the challenge request.\n\nNext, verify the multi-factor authentication using the `/oauth/token` endpoint and the specified challenge type: a one-time password (OTP), a recovery code, or an out-of-band (OOB) challenge.\n\nTo learn more, read:\n\n*   [Multi-factor Authentication and Resource Owner Password](https://auth0.com/docs/mfa/guides/mfa-api/multifactor-resource-owner-password)\n*   [Multi-factor Authentication API](https://auth0.com/docs/mfa/concepts/mfa-api)\n*   [Multi-factor Authentication in Auth0](https://auth0.com/docs/mfa)\n\n## Challenge Request\n\n```\nPOST https://{yourDomain}/mfa/challenge\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\",\n  \"mfa_token\": \"MFA_TOKEN\",\n  \"challenge_type\": \"oob|otp\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/challenge' \\\n  --header 'content-type: application/json' \\\n  --data '{\"mfa_token\":\"MFA_TOKEN\", \"challenge_type\":\"oob otp\", \"client_id\": \"{yourClientId}\", \"client_secret\": \"YOUR_CLIENT_SECRET\"}'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/mfa/challenge',\n  headers: { 'content-type': 'application/json' },\n  body:\n   { mfa_token: 'MFA_TOKEN',\n     challenge_type: 'oob otp',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR OTP:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"challenge_type\":\"otp\",\n}\n```\n\n> RESPONSE SAMPLE FOR OOB WITHOUT BINDING METHOD:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"challenge_type\":\"oob\",\n  \"oob_code\": \"abcde...dasg\"\n}\n```\n\n> RESPONSE SAMPLE FOR OOB WITH BINDING METHOD:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"challenge_type\":\"oob\",\n  \"binding_method\":\"prompt\",\n  \"oob_code\": \"abcde...dasg\"\n}\n```\n\nRequest a challenge for multi-factor authentication (MFA) based on the challenge types supported by the application and user.\n\nThe `challenge_type` is how the user will get the challenge and prove possession. Supported challenge types include:\n\n*   `otp`: for one-time password (OTP)\n*   `oob`: for SMS/Voice messages or out-of-band (OOB)\n\nIf OTP is supported by the user and you don't want to request a different factor, you can skip the challenge request and [verify the multi-factor authentication with a one-time password](#verify-with-one-time-password-otp-).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`mfa_token`  \nRequired\n\nThe token received from `mfa_required` error.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`challenge_type`\n\nA whitespace-separated list of the challenges types accepted by your application. Accepted challenge types are `oob` or `otp`. Excluding this parameter means that your client application accepts all supported challenge types.\n\n`authenticator_id`\n\nThe ID of the authenticator to challenge. You can get the ID by querying the list of available authenticators for the user as explained on [List authenticators](#list-authenticators) below.\n\n*   This endpoint does not support enrollment; the user must be enrolled with the preferred method before requesting a challenge.\n*   Auth0 chooses the challenge type based on the application's supported types and types the user is enrolled with.\n*   An `unsupported_challenge_type` error is returned if your application does not support any of the challenge types the user has enrolled with.\n*   An `unsupported_challenge_type` error is returned if the user is not enrolled.\n*   If the user is not enrolled, you will get a `association_required` error, indicating the user needs to enroll to use MFA. Read [Add an authenticator](#add-an-authenticator) below on how to proceed.\n\n### Learn More\n\n*   [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/mfa/guides/mfa-api/authenticate)\n*   [Manage Authenticator Factors using the MFA API](https://auth0.com/docs/mfa/guides/mfa-api/manage)\n\n## Verify with One-Time Password (OTP)\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&otp=OTP_CODE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'mfa_token=MFA_TOKEN&otp=OTP_CODE&grant_type=http://auth0.com/oauth/grant-type/mfa-otp&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { mfa_token: 'MFA_TOKEN',\n     otp: 'OTP_CODE',\n     grant_type: 'http://auth0.com/oauth/grant-type/mfa-otp',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR OTP:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nVerifies multi-factor authentication (MFA) using a one-time password (OTP).\n\nTo verify MFA with an OTP, prompt the user to get the OTP code, then make a request to the `/oauth/token` endpoint. The request must have the OTP code, the `mfa_token` you received (from the `mfa_required` error), and the `grant_type` set to `http://auth0.com/oauth/grant-type/mfa-otp`.\n\nThe response is the same as responses for `password` or `http://auth0.com/oauth/grant-type/password-realm` grant types.\n\n### Request parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For OTP MFA use `http://auth0.com/oauth/grant-type/mfa-otp`.\n\n`client_id`\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`mfa_token`  \nRequired\n\nThe `mfa_token` you received from `mfa_required` error.\n\n`otp`  \nRequired\n\nOTP Code provided by the user.\n\n### Learn More\n\n*   [Associate OTP Authenticators](https://auth0.com/docs/mfa/guides/mfa-api/otp)\n\n## Verify with Out-of-Band (OOB)\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&oob_code=OOB_CODE&binding_code=BINDING_CODE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http://auth0.com/oauth/grant-type/mfa-oob&oob_code=OOB_CODE&binding_code=BINDING_CODE'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { mfa_token: 'MFA_TOKEN',\n     oob_code: \"OOB_CODE\",\n     binding_code: \"BINDING_CODE\"\n     grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR PENDING CHALLENGE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"error\":\"authorization_pending\",\n  \"error_description\":\"Authorization pending: please repeat the request in a few seconds.\"\n}\n```\n\n> RESPONSE SAMPLE FOR VERIFIED CHALLENGE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n> RESPONSE SAMPLE FOR REJECTED CHALLENGE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"error\":\"invalid_grant\",\n  \"error_description\":\"MFA Authorization rejected.\"\n}\n```\n\n### POST /oauth/token\n\nVerifies multi-factor authentication (MFA) using an out-of-band (OOB) challenge (either Push notification, SMS, or Voice).\n\nTo verify MFA using an OOB challenge, your application must make a request to `/oauth/token` with `grant_type=http://auth0.com/oauth/grant-type/mfa-oob`. Include the `oob_code` you received from the challenge response, as well as the `mfa_token` you received as part of `mfa_required` error.\n\nThe response to this request depends on the status of the underlying challenge verification:\n\n*   If the challenge has been accepted and verified, it will be the same as `password` or `http://auth0.com/oauth/grant-type/password-realm` grant types.\n*   If the challenge has been rejected, you will get an `invalid_grant` error, meaning that the challenge was rejected by the user. At this point you should stop polling, as this response is final.\n*   If the challenge verification is still pending (meaning it has not been accepted nor rejected), you will get an `authorization_pending` error, meaning that you must retry the same request a few seconds later. If you request too frequently, you will get a `slow_down` error.\n\nWhen the challenge response includes a `binding_method: prompt`, your app needs to prompt the user for the `binding_code` and send it as part of the request. The `binding_code` is usually a 6-digit number (similar to an OTP) included as part of the challenge. No `binding_code` is necessary if the challenge response did not include a `binding_method`. In this scenario, the response will be immediate; you will receive an `invalid_grant` or an `access_token` as response.\n\n### Request parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For OTP MFA, use `http://auth0.com/oauth/grant-type/mfa-oob`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`mfa_token`  \nRequired\n\nThe `mfa_token` you received from `mfa_required` error.\n\n`oob_code`  \nRequired\n\nThe oob code received from the challenge request.\n\n`binding_code`\n\nA code used to bind the side channel (used to deliver the challenge) with the main channel you are using to authenticate. This is usually an OTP-like code delivered as part of the challenge message.\n\n### Learn More\n\n*   [Associate Out-of-Band Authenticators](https://auth0.com/docs/mfa/guides/mfa-api/oob)\n\n## Verify with Recovery Code\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-recovery-code&recovery_code=RECOVERY_CODE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&mfa_token=MFA_TOKEN&grant_type=http://auth0.com/oauth/grant-type/mfa-recovery-code&recovery_code=RECOVERY_CODE'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { mfa_token: 'MFA_TOKEN',\n     recovery_code: 'RECOVERY_CODE',\n     grant_type: 'http://auth0.com/oauth/grant-type/mfa-recovery-code',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR OTP:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400,\n  \"recovery_code\": \"abcdefg\"\n}\n```\n\n### POST /oauth/token\n\nVerifies multi-factor authentication (MFA) using a recovery code.\n\nSome multi-factor authentication (MFA) providers (such as Guardian) support using a recovery code to login. Use this method to authenticate when the user's enrolled device is unavailable, or the user cannot receive the challenge or accept it due to connectivity issues.\n\nTo verify MFA using a recovery code your app must prompt the user for the recovery code, and then make a request to `oauth/token` with `grant_type=http://auth0.com/oauth/grant-type/mfa-recovery-code`. Include the collected recovery code and the `mfa_token` from the `mfa_required` error. If the recovery code is accepted, the response will be the same as for `password` or `http://auth0.com/oauth/grant-type/password-realm` grant types. It might also include a `recovery_code` field, which the application must display to the end-user to be stored securely for future use.\n\n### Request parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For recovery code use `http://auth0.com/oauth/grant-type/mfa-recovery-code`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`mfa_token`  \nRequired\n\nThe `mfa_token` you received from `mfa_required` error.\n\n`recovery_code`  \nRequired\n\nRecovery code provided by the end-user.\n\n## Add an Authenticator\n\n```\nPOST https://{yourDomain}/mfa/associate\nContent-Type: application/json\nAuthorization: Bearer ACCESS_TOKEN or MFA_TOKEN\n{\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\",\n  \"authenticator_types\": [\"oob\"],\n  \"oob_channels\": \"sms\",\n  \"phone_number\": \"+1 555 123456\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/associate' \\\n  --header 'authorization: Bearer ACCESS_TOKEN or MFA_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\", \"client_secret\": \"YOUR_CLIENT_SECRET\", \"authenticator_types\":[\"oob\"], \"oob_channels\":\"sms\", \"phone_number\": \"+1 555 123456\"}'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/mfa/associate',\n  headers: {\n    'authorization': 'Bearer TOKEN',\n    'content-type': 'application/json'\n  },\n  body:\n   { client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     authenticator_types: [\"oob\"],\n     oob_channels: \"sms\",\n     phone_number: \"+1 555 123456\" },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE FOR OOB (SMS channel):\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"oob_code\": \"Fe26.2**da6....\",\n  \"binding_method\":\"prompt\",\n  \"authenticator_type\":\"oob\",\n  \"oob_channels\":\"sms\",\n  \"recovery_codes\":[\"ABCDEFGDRFK75ABYR7PH8TJA\"],\n}\n```\n\n> RESPONSE SAMPLE FOR OOB (Auth0 channel):\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"oob_code\": \"Fe26.2**da6....\",\n  \"barcode_uri\":\"otpauth://...\",\n  \"authenticator_type\":\"oob\",\n  \"oob_channels\":\"auth0\",\n  \"recovery_codes\":[\"ABCDEFGDRFK75ABYR7PH8TJA\"],\n}\n```\n\n> RESPONSE SAMPLE FOR OTP:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"secret\": \"ABCDEFGMK5CE6WTZKRTTQRKUJVFXOVRF\",\n  \"barcode_uri\":\"otpauth://...\",\n  \"authenticator_type\":\"otp\",\n  \"recovery_codes\":[\"ABCDEFGDRFK75ABYR7PH8TJA\"],\n}\n```\n\n### POST /mfa/associate\n\nAssociates or adds a new authenticator for multi-factor authentication (MFA).\n\nIf the user has active authenticators, an Access Token with the `enroll` scope and the `audience` set to `https://{yourDomain}/mfa/` is required to use this endpoint.\n\nIf the user has no active authenticators, you can use the `mfa_token` from the `mfa_required` error in place of an Access Token for this request.\n\nAfter an authenticator is added, it must be verified. To verify the authenticator, use the response values from the `/mfa/associate` request in place of the values returned from the `/mfa/challenge` endpoint and continue with the verification flow.\n\nA `recovery_codes` field is included in the response the first time an authenticator is added. You can use `recovery_codes` to pass multi-factor authentication as shown on [Verify with recovery code](#verify-with-recovery-code) above.\n\nTo access this endpoint, you must set an Access Token at the Authorization header, with the following claims:\n\n*   `scope`: `enroll`\n*   `audience`: `https://{yourDomain}/mfa/`\n\n### Request parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field in your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`authenticator_types`  \nRequired\n\nThe type of authenticators supported by the client. Value is an array with values `\"otp\"` or `\"oob\"`.\n\n`oob_channels`\n\nThe type of OOB channels supported by the client. An array with values `\"auth0\"`, `\"sms\"`, `\"voice\"`. Required if `authenticator_types` include `oob`.\n\n`phone_number`\n\nThe phone number to use for SMS or Voice. Required if `oob_channels` includes `sms` or `voice`.\n\n### Learn More\n\n*   [Multi-factor Authentication API](https://auth0.com/docs/mfa/concepts/mfa-api)\n\n## List Authenticators\n\n```\nGET https://{yourDomain}/mfa/authenticators\nContent-Type: application/json\nAuthorization: Bearer ACCESS_TOKEN\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer ACCESS_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {\n    'authorization': 'Bearer ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n[\n  {\n    \"id\":\"recovery-code|dev_DsvzGfZw2Fg5N3rI\",\n    \"authenticator_type\":\"recovery-code\",\n    \"active\":true\n  },\n  {\n    \"id\":\"sms|dev_gB342kcL2K22S4yB\",\n    \"authenticator_type\":\"oob\",\n    \"oob_channels\":\"sms\",\n    \"name\":\"+X XXXX1234\",\n    \"active\":true\n  },\n  {\n    \"id\":\"sms|dev_gB342kcL2K22S4yB\",\n    \"authenticator_type\":\"oob\",\n    \"oob_channels\":\"sms\",\n    \"name\":\"+X XXXX1234\",\n    \"active\":false\n  },\n  {\n    \"id\":\"push|dev_433sJ7Mcwj9P794y\",\n    \"authenticator_type\":\"oob\",\n    \"oob_channels\":\"auth0\",\n    \"name\":\"John's Device\",\n    \"active\":true\n  },\n    {\n    \"id\":\"totp|dev_LJaKaN5O3tjRFOw2\",\n    \"authenticator_type\":\"otp\",\n    \"active\":true\n  }\n]\n```\n\n### GET /mfa/authenticators\n\nReturns a list of authenticators associated with your application.\n\nTo access this endpoint you must set an Access Token at the Authorization header, with the following claims:\n\n*   `scope`: `read:authenticators`\n*   `audience`: `https://{yourDomain}/mfa/`\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`ACCESS_TOKEN`  \nRequired\n\nThe Access Token obtained during login.\n\n#### Learn More\n\n*   [Manage Authenticators](https://auth0.com/docs/mfa/guides/mfa-api/manage)\n\n## Delete an Authenticator\n\n```\nDELETE https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\nAuthorization: Bearer ACCESS_TOKEN\n```\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID' \\\n  --header 'authorization: Bearer ACCESS_TOKEN' \\\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'DELETE',\n  url: 'https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID',\n  headers: {\n    'authorization': 'Bearer ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 204 OK\n```\n\n### DELETE /mfa/authenticators\n\nDeletes an associated authenticator using its ID.\n\nYou can get authenticator IDs by [listing the authenticators](#list-authenticators).\n\nTo access this endpoint, you must set an Access Token at the Authorization header, with the following claims:\n\n*   `scope`: `remove:authenticators`\n*   `audience`: `https://{yourDomain}/mfa/`\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`ACCESS_TOKEN`  \nRequired\n\nThe Access Token obtained during login.\n\n`AUTHENTICATOR_ID`  \nRequired\n\nThe ID of the authenticator to delete.\n\n### Learn More\n\n*   [Manage Authenticators](https://auth0.com/docs/mfa/guides/mfa-api/manage)\n\n## SAML\n\nThe SAML protocol is used mostly for third-party SaaS applications, like Salesforce and Box. Auth0 supports Service Provider (SP) and Identity Provider (IDP) initiated Sign On. To learn more, see [SAML](https://auth0.com/docs/protocols/saml).\n\n## Accept Request\n\n```\nGET https://{yourDomain}/samlp/{yourClientId}?\n  connection=CONNECTION\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/samlp/{yourClientId}' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data '\"connection\"=\"CONNECTION\"'\n```\n\n### GET /samlp/YOUR\\_CLIENT\\_ID\n\nUse this endpoint to accept a SAML request to initiate a login.\n\nOptionally, you can include a `connection` parameter to log in with a specific provider. If no connection is specified, the [Auth0 Login Page](https://auth0.com/docs/authenticate/login/auth0-universal-login) will be shown.\n\nOptionally, SP-initiated login requests can include an `organization` parameter to authenticate users in the context of an organization. To learn more, see [Organizations](https://auth0.com/docs/organizations).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nClient ID of your application.\n\n`connection`\n\nConnection to use during login.\n\n`organization`\n\nOrganization ID, if authenticating in the context of an organization.\n\n*   All the parameters of the SAML response can be modified with [Rules](https://auth0.com/docs/rules).\n*   The SAML request `AssertionConsumerServiceURL` will be used to `POST` back the assertion. It must match one of the application's `callback_URLs`.\n\n### Learn More\n\n*   [SAML](https://auth0.com/docs/protocols/saml)\n\n## Get Metadata\n\n```\nGET https://{yourDomain}/samlp/metadata/{yourClientId}\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/samlp/metadata/{yourClientId}'\n```\n\n### GET /samlp/metadata/YOUR\\_CLIENT\\_ID\n\nThis endpoint returns the SAML 2.0 metadata.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n### Learn More\n\n*   [SAML](https://auth0.com/docs/protocols/saml)\n\n## IdP-Initiated Single Sign-On (SSO) Flow\n\n```\nPOST https://{yourDomain}/login/callback?connection=CONNECTION\nContent-Type: 'application/x-www-form-urlencoded'\n  SAMLResponse=SAML_RESPONSE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/login/callback' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data '\"connection\":\"CONNECTION\", \"SAMLResponse\":\"SAML_RESPONSE\"'\n```\n\n### POST /login/callback\n\nThis endpoint accepts an IdP-Initiated Sign On SAMLResponse from a SAML Identity Provider. The connection corresponding to the identity provider is specified in the query string. The user will be redirected to the application that is specified in the SAML Provider IdP-Initiated Sign On section.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`connection`  \nRequired\n\nThe name of an identity provider configured to your application.\n\n`SAMLResponse`  \nRequired\n\nAn IdP-Initiated Sign On SAML Response.\n\n### Learn More\n\n*   [SAML](https://auth0.com/docs/protocols/saml)\n\n## WS-Federation\n\n## Accept Request\n\n```\nGET https://{yourDomain}/wsfed/{yourClientId}\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/wsfed/{yourClientId}'\n```\n\n### GET /wsfed/YOUR\\_CLIENT\\_ID\n\nThis endpoint accepts a WS-Federation request to initiate a login.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client-id`\n\nThe `client-id` of your application.\n\n`wtrealm`\n\nCan be used in place of `client-id`.\n\n`whr`\n\nThe name of the connection (used to skip the login page).\n\n`wctx`\n\nYour application's state.\n\n`wreply`\n\nThe callback URL.\n\n*   The `wtrealm` parameter must be in one of these formats:\n    *   `urn:clientID` (for example, urn:{yourClientId})\n    *   If this parameter does not begin with a urn, the `client.clientAliases` array is used for look-up. This can only be set with the [/api/v2/clients](https://auth0.com/docs/api/management/v2#!/Clients/get_clients) Management API.\n*   The `whr` parameter is mapped to the connection like this: `urn:CONNECTION_NAME`. For example, `urn:google-oauth2` indicates login with Google. If there is no `whr` parameter included, the user will be directed to the [Auth0 Login Page](https://auth0.com/docs/login_page).\n\n### Learn More\n\n*   [WS-Federation](https://auth0.com/docs/protocols/ws-fed)\n\n## Get Metadata\n\n```\nGET https://{yourDomain}/wsfed/FederationMetadata/2007-06/FederationMetadata.xml\n```\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/wsfed/FederationMetadata/2007-06/FederationMetadata.xml'\n```\n\n### GET /wsfed/FederationMetadata/2007-06/FederationMetadata.xml\n\nThis endpoint returns the WS-Federation metadata.\n\n### Learn More\n\n*   [WS-Federation](https://auth0.com/docs/protocols/ws-fed)\n\n## Dynamic Application (Client) Registration\n\n```\nPOST https://{yourDomain}/oidc/register\nContent-Type: application/json\n{\n  \"client_name\": \"YOUR-NEW-CLIENT-NAME\",\n  \"redirect_uris\": [],\n  \"token_endpoint_auth_method\": \"client_secret_post\"\n}\n```\n\n```\ncurl --request POST \\\n  --url https://{yourDomain}/oidc/register \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_name\": \"YOUR-NEW-CLIENT-NAME\",\"redirect_uris\": [], \"token_endpoint_auth_method\": \"client_secret_post\"}'\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"client_name\": \"My Dynamic Client\",\n  \"client_id\": \"8SXWY6j3afl2CP5ntwEOpMdPxxy49Gt2\",\n  \"client_secret\": \"Q5O...33P\",\n  \"redirect_uris\": [\n    \"https://client.example.com/callback\",\n    \"https://client.example.com/callback2\"\n  ],\n  \"client_secret_expires_at\": 0\n}\n```\n\n### POST /oidc/register\n\nWith a name and the necessary callback URL, you can dynamically register a client with Auth0. No token is needed for this request.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_name`\n\nThe name of the Dynamic Client to be created. It is recommended to provide a value but if it is omitted, the default name \"My App\" will be used.\n\n`redirect_uris`  \nRequired\n\nAn array of URLs that Auth0 will deem valid to call at the end of an Authentication flow.\n\n`token_endpoint_auth_method`\n\nDefault value is `client_secret_post`. Use `token_endpoint_auth_method: none` in the request payload if creating a SPA.\n\nAPI Authorization\n\n## Authorize Application\n\nTo begin an OAuth 2.0 Authorization flow, your application should first send the user to the authorization URL.\n\n## Authorize endpoint\n\nThe purpose of this call is to obtain consent from the user to invoke the API (specified in `audience`) and do certain things (specified in `scope`) on behalf of the user. Auth0 will authenticate the user and obtain consent, unless consent has been previously given. If you alter the value in `scope`, Auth0 will require consent to be given again.\n\nThe OAuth 2.0 flows that require user authorization are:\n\n*   [Authorization Code Flow](https://auth0.com/docs/flows/concepts/auth-code)\n*   [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/flows/concepts/auth-code-pkce)\n*   [Implicit Flow](https://auth0.com/docs/flows/concepts/implicit)\n\nThe [Resource Owner Password Grant](https://auth0.com/docs/api-auth/grant/password) and [Client Credentials Flow](https://auth0.com/docs/flows/concepts/client-credentials) do not use this endpoint since there is no user authorization involved. Instead, they directly invoke the `POST /oauth/token` endpoint to retrieve an Access Token.\n\nBased on the OAuth 2.0 flow you are implementing, the parameters slightly change. To determine which flow is best suited for your case, refer to: [Which OAuth 2.0 flow should I use?](https://auth0.com/docs/api-auth/which-oauth-flow-to-use).\n\n## Get Token\n\nFor token-based authentication, use the `oauth/token` endpoint to get an access token for your application to make authenticated calls to a secure API. Optionally, you can also retrieve an ID Token and a Refresh Token. ID Tokens contains user information in the form of scopes you application can extract to provide a better user experience. Refresh Tokens allow your application to request a new access token once the current token expires without interruping the user experience. To learn more, read [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens) and [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\nNote that the only OAuth 2.0 flows that can retrieve a Refresh Token are:\n\n*   [Authorization Code Flow (Authorization Code)](https://auth0.com/docs/flows/concepts/auth-code)\n*   [Authorization Code Flow with PKCE (Authorization Code with PKCE)](https://auth0.com/docs/flows/concepts/auth-code-pkce)\n*   [Resource Owner Password](https://auth0.com/docs/api-auth/grant/password)\n*   [Device Authorization Flow](https://auth0.com/docs/flows/concepts/device-auth)\n*   Token Exchange\\*\n\n## Authorization Code Flow\n\n## Authorize\n\n```\nGET https://{yourDomain}/authorize?\n  audience=API_IDENTIFIER&\n  scope=SCOPE&\n  response_type=code&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE\n```\n\n> RESPONSE SAMPLE\n\n```\nHTTP/1.1 302 Found\nLocation: {https://yourApp/callback}?code=AUTHORIZATION_CODE&state=STATE\n```\n\n### GET /authorize\n\nThis is the OAuth 2.0 grant that regular web apps utilize in order to access an API.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`audience`  \n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nThe scopes which you want to request authorization for. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). Include `offline_access` to get a Refresh Token.\n\n`response_type`  \nRequired\n\nIndicates to Auth0 which OAuth 2.0 flow you want to use. Use `code` for Authorization Code Grant Flow.\n\n`client_id`  \nRequired\n\nYour application's ID.\n\n`state`  \nRecommended\n\nAn opaque value the application adds to the initial request that Auth0 includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n`redirect_uri`\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user.\n\n`connection`\n\nThe name of the connection configured to your application.\n\n`prompt`\n\nTo initiate a [silent authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) request, use `prompt=none` (To learn more, read the Remarks).\n\n`organization`\n\nID of the [organization](https://auth0.com/docs/organizations) to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating.\n\n`invitation`\n\nTicket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the invitation and organization key-value pairs when the user accepts the invitation.\n\n## Get Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=authorization_code&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&code=AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { grant_type: 'authorization_code',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     code: 'AUTHORIZATION_CODE',\n     redirect_uri: '{https://yourApp/callback}' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"refresh_token\":\"GEbRxBN...edjnXbL\",\n  \"id_token\":\"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nThis is the flow that regular web apps use to access an API. Use this endpoint to exchange an Authorization Code for a token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Authorization Code, use `authorization_code`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_secret`  \nRequired\n\nYour application's Client Secret.\n\n`code`  \nRequired\n\nThe Authorization Code received from the initial `/authorize` call.\n\n`redirect_uri`\n\nThis is required only if it was set at the [GET /authorize](#authorization-code-grant) endpoint. The values from `/authorize` must match the value you set at `/oauth/token`.\n\n### Learn More\n\n*   [Authorization Code Flow](https://auth0.com/docs/flows/concepts/auth-code)\n*   [Call API Using the Authorization Code Flow](https://auth0.com/docs/flows/guides/auth-code/call-api-auth-code)\n*   [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state)\n*   [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication)\n\n## Authorization Code Flow with PKCE\n\n## Authorize\n\n```\nGET https://{yourDomain}/authorize?\n  audience=API_IDENTIFIER&\n  scope=SCOPE&\n  response_type=code&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  code_challenge=CODE_CHALLENGE&\n  code_challenge_method=S256\n```\n\n> RESPONSE SAMPLE\n\n```\nHTTP/1.1 302 Found\nLocation: {https://yourApp/callback}?code=AUTHORIZATION_CODE\n```\n\n### GET /authorize\n\nThis is the OAuth 2.0 grant that mobile apps utilize in order to access an API. Before starting with this flow, you need to generate and store a `code_verifier`, and using that, generate a `code_challenge` that will be sent in the authorization request.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`audience`  \n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nThe scopes which you want to request authorization for. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). Include `offline_access` to get a Refresh Token.\n\n`response_type`  \nRequired\n\nIndicates to Auth0 which OAuth 2.0 Flow you want to perform. Use `code` for Authorization Code Grant (PKCE) Flow.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`state`  \nRecommended\n\nAn opaque value the client adds to the initial request that Auth0 includes when redirecting back to the client. This value must be used by the client to prevent CSRF attacks.\n\n`redirect_uri`\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user.\n\n`code_challenge_method`  \nRequired\n\nMethod used to generate the challenge. The PKCE spec defines two methods, `S256` and `plain`, however, Auth0 supports only `S256` since the latter is discouraged.\n\n`code_challenge`  \nRequired\n\nGenerated challenge from the `code_verifier`.\n\n`connection`\n\nThe name of the connection configured to your application.\n\n`prompt`\n\nTo initiate a [silent authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) request, use `prompt=none` (To learn more, read the Remarks).\n\n`organization`\n\nID of the [organization](https://auth0.com/docs/organizations) to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating.\n\n`invitation`\n\nTicket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the invitation and organization key-value pairs when the user accepts the invitation.\n\n## Get Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&client_id={yourClientId}&code_verifier=CODE_VERIFIER&code=AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=authorization_code&client_id={yourClientId}&code_verifier=CODE_VERIFIER&code=AUTHORIZATION_CODE&redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form: {\n    grant_type:\"authorization_code\",\n    client_id: \"{yourClientId}\",\n    code_verifier: \"CODE_VERIFIER\",\n    code: \"AUTHORIZATION_CODE\",\n    redirect_uri: \"{https://yourApp/callback}\", } };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"refresh_token\":\"GEbRxBN...edjnXbL\",\n  \"id_token\":\"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nThis is the flow that mobile apps use to access an API. Use this endpoint to exchange an Authorization Code for a token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Authorization Code (PKCE) use `authorization_code`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`code`  \nRequired\n\nThe Authorization Code received from the initial `/authorize` call.\n\n`code_verifier`  \nRequired\n\nCryptographically random key that was used to generate the `code_challenge` passed to `/authorize`.\n\n`redirect_uri`\n\nThis is required only if it was set at the [GET /authorize](#authorization-code-grant-pkce-) endpoint. The values from `/authorize` must match the value you set at `/oauth/token`.\n\n*   In order to improve compatibility for applications, Auth0 will now return profile information in a [structured claim format as defined by the OIDC specification](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). This means that in order to add custom claims to ID tokens or access tokens, they must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims) to avoid possible collisions with standard OIDC claims.\n*   Include `offline_access` to the `scope` request parameter to get a refresh token from [POST /oauth/token](#authorization-code-pkce-). Make sure that the **Allow Offline Access** field is enabled in the [API Settings](https://manage.auth0.com/#/apis).\n*   The `redirect_uri` value must be specified as a valid callback URL under your [Application's Settings](https://manage.auth0.com/#/applications).\n*   Silent authentication lets you perform an authentication flow where Auth0 will only reply with redirects, and never with a login page. When an Access Token has expired, silent authentication can be used to retrieve a new one without user interaction, assuming the user's Single Sign-on (SSO) session has not expired.\n\n### Learn More\n\n*   [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/flows/concepts/auth-code-pkce)\n*   [Call API Using the Authorization Code Flow with PKCE](https://auth0.com/docs/flows/guides/auth-code-pkce/call-api-auth-code-pkce)\n*   [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication)\n\n\\>\n\n## Authorization Code Flow with Enhanced Privacy Protection\n\n## Push Authorization Requests (PAR)\n\n### POST /oauth/par\n\n```\nPOST {yourDomain}/oauth/par\nContent-Type: 'application/x-www-form-urlencoded'\n  audience={https://yourApi/}&\n  response_type=code|code id_token&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE&\n  scope=openid|profile|email&\n  code_challenge=CODE_CHALLENGE&\n  code_challenge_method=S256&\n  nonce=NONCE&\n  connection=CONNECTION&\n  prompt=login|consent|none&\n  organisation=ORGANIZATION\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/par,\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form: {\n    audience: '{https://yourApi/}',\n    response_type: 'code|code id_token',\n    client_id: '{yourClientId}',\n    redirect_uri: '{https://yourApp/callback}',\n    state: 'STATE',\n    scope: 'openid|profile|email',\n    authorization_details: JSON.stringify([{ type: 'my_type' }]),\n    code_challenge: 'CODE_CHALLENGE',\n    code_challenge_method: 'S256',\n    nonce: 'NONCE',\n    connection: 'CONNECTION',\n    prompt: 'login|consent|none'\n    organisation: 'ORGANIZATION'\n    }\n};\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/par' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n--data 'audience={https://yourApi/}response_type=code|code id_token&client_id={yourClientId}&redirect_uri={https://yourApp/callback}&state=STATE&scope=openid|profile|email&authorization_details='[{\"type\":\"my_type\"}]'\n&code_challenge=CODE_CHALLENGE&code_challenge_method=S256&nonce=NONCE&connection=CONNECTION&prompt=login|consent|none&organisation=ORGANIZATION'\n\n```\n\n> RESPONSE SAMPLE:\n\n```\n/**\nIf the request is successful, `/oauth/par` responds with a `JSON` object containing the `request_uri` property, which can be used at the authorization endpoint, and the `expires_in` value, which indicates the number of seconds the `request_uri` is valid. \n*/\n\nHTTP/1.1 201 Created\nContent-Type: application/json\n\n{\n  \"request_uri\":\n    \"urn:ietf:params:oauth:request_uri:6esc_11ACC5bwc014ltc14eY22c\",\n  \"expires_in\": 30\n}\n```\n\nAuthorization Code Flow with [Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par) uses the `/oauth/par` endpoint to allow applications to send the authorization parameters usually sent in a `GET` request to `/authorize`. PAR uses a POST method from the backend to keep parameter values secure. The `/oauth/par` endpoint accepts all authorization parameters which can be proivided to `/authorize`. Assuming the call to the `/oauth/par` endpoint is valid, Auth0 will respond with a `redirect_uri` value that can be used as a parameter for the `/authorize` endpoint.\n\nAssuming the call to the `/oauth/par` endpoint is valid, Auth0 will respond with a `redirect_uri` value also used as a parameter for the `/authorize` endpoint. To learn more about configuring PAR, read [Configure Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/applications/configure-par).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`authorization_details`\n\nRequested permissions for each resource. Similar to scopes. To learn more, read [RAR reference documention](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-rar).\n\n`audience`\n\nThe unique identifier of the target API you want to access.\n\n`response_type`  \nRequired\n\nSpecifies the token type. We recommend you use `code` to request an authorization code, or code `id_token` to receive an authorization code and a [detached signature](https://openid.net/specs/openid-financial-api-part-2-1_0.html#id-token-as-detached-signature).\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user. Specify the `redirect_uri` under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n`state`  \nRecommended\n\nAn opaque value the application adds to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n\n`scope`  \nRecommended\n\nOIDC scopes and custom API scopes. For example: `openid read:timesheets`. Include `offline_access` to get a refresh token.\n\n`code_challenge`  \nRecommended\n\nOIDC scopes and custom API scopes. For example: `openid read:timesheets`. Include `offline_access` to get a refresh token.\n\n`code_challenge_method`  \nRecommended\n\nMethod used to generate the challenge. The PKCE specification defines two methods, `S256` and plain, however, Auth0 supports only S256 since the latter is discouraged. \\[Authorization Code Flow with Proof Key for Code Exchange (PKCE)\\] (/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).\n\n`nonce`  \nRecommended\n\nA string value which will be included in the ID token response from Auth0, used to prevent token replay attacks. It is required for `response_type=id_token` token.\n\n`connection`\n\nThe name of the connection configured to your application. If null, it will redirect to the [Auth0 Login Page](https://{yourdomain}/login) and show the Login Widget using the first database connection.\n\n`prompt`\n\nCan be used to force a particular prompt to display, e.g. `prompt=consent` will always display the consent prompt.\n\n`organization`\n\nID of the organization to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating.\n\n*   To make a call to the PAR endpoint, you must:\n    *   Set the request content type as `application/x-www-form-urlencoded`\n    *   Use `strings` for all passed parameters\n    *   Include an additional parameter for application authentication in the request (e.g. `client_secret`, or `client_assertion` and `client_assertion_type` for JSON Web Token Client Authentication, or pass a `client-certificate` and `client-certificate-ca-verified` header when using Mutual TLS).\n*   Use the `authorization_details` parameter to request permission for each resource. For example, you can specify an array of JSON objects to convey fine-grained information on the authorization. Each JSON object must contain a `type` attribute. The rest is up to you to define.\n\n## Authorize\n\n### GET /authorize\n\n```\nGET https://{yourDomain}/authorize\n  request_uri={yourRequestUri}&\n  client_id={yourClientId}\n```\n\nAfter calling the `/oauth/par` endpoint, redirect the end user to the `/authorize` endpoint using a `GET` call.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`request_uri`  \nRequired\n\nThe `request_uri` value that was received from the `/oauth/par` endpoint.\n\n## Exchange an Authorization Code for a Token\n\n### POST /oauth/token\n\n```\nPOST https://{yourDomain}/oauth/par\nContent-Type: 'application/x-www-form-urlencoded'\n  grant_type=code|code id_token&\n  client_id={yourClientId}&\n  code=CODE&\n redirect_uri={https://yourApp/callback}&\n code_verifier=CODE_VERIFIER\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/par' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n--data 'grant_type=authorization_code& client_id={yourClientId}& code=CODE&redirect_uri={https://yourApp/callback}&code_verifier=CODE_VERIFIER'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token,\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form: { \n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    code: 'CODE',\n    redirect_uri: '{https://yourApp/callback}',\n    code_verifier: 'CODE_VERIFIER'\n    }\n};\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\n/**\nThe `/oauth/token` endpoint will respond with a JSON object containing an `id_token` property, and potentially also a `refresh_token` if one was requested.\n*/\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n   \"refresh_token\":\"GEbRxBN...edjnXbL\",\n    \"access_token\":\"eybRxBN...edjnXZQ\",  \n  \"id_token\":\"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400,\n  \"authrorization_details\":[\n    {\n      \"type\":\"my_type\",\n      \"other_attributes_of_my_type\":\"value\"}\n  ]\n},\n  \n  \n```\n\nWhen users are redirected back to your callback, you need to make a `POST` call to the `oauth/token` endpoint to exchange an authorization code for an access and/or an ID token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow. Assuming you have an authorization code from the `/authorize` endpoint, use `authorization_code`.\n\n`code`\n\nThe authorization code from the initial `/authorize` call.\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`request_uri`  \nRequired\n\nThis is required only if it was set at the `GET` `/oauth/par` endpoint. The values from `/authorize` must match the value you set at `/oauth/token`.\n\n`code_verifier`  \nRecommended\n\nCryptographically random key used to generate the `code_challenge` passed to `/oauth/par`. If the `code_challenge` parameter is passed in the call to `/oauth/par`, this is required.\n\nTo make a call to `/oauth/token` endpoint, you must:\n\n*   Set the request content type as `application/x-www-form-urlencoded`\n*   Use `strings` for all passed parameters\n*   Include an additional parameter for application authentication in the request (e.g. `client_secret`, or `client_assertion` and `client_assertion_type` for JSON Web Token Client Authentication, or pass a `client-certificate` and `client-certificate-ca-verified` header when using Mutual TLS).\n\n\\>\n\n## Client Credential Flow\n\n## Get Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\naudience=API_IDENTIFIER&grant_type=client_credentials&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'audience=API_IDENTIFIER&grant_type=client_credentials&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     audience: 'API_IDENTIFIER',\n     grant_type: 'client_credentials' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nThis is the OAuth 2.0 grant that server processes use to access an API. Use this endpoint to directly request an access token by using the application's credentials (a Client ID and a Client Secret).\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Client Credentials use `client_credentials`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_secret`  \nRequired\n\nYour application's Client Secret.\n\n`audience`  \nRequired\n\nThe unique identifier of the target API you want to access.\n\n### Learn More\n\n*   [Client Credentials Flow](https://auth0.com/docs/flows/concepts/client-credentials)\n*   [Call API using the Client Credentials Flow](https://auth0.com/docs/flows/guides/client-credentials/call-api-client-credentials)\n*   [Setting up a Client Grant using the Management Dashboard](https://auth0.com/docs/api-auth/config/using-the-auth0-dashboard)\n*   [Asking for Access Tokens for a Client Credentials Grant](https://auth0.com/docs/api-auth/config/asking-for-access-tokens)\n\n\\>\n\n## Implicit Flow\n\n## Authorize\n\n```\nGET https://{yourDomain}/authorize?\n  audience=API_IDENTIFIER&\n  scope=SCOPE&\n  response_type=token|id_token|id_token token&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  state=STATE&\n  nonce=NONCE\n```\n\n> RESPONSE SAMPLE\n\n```\nHTTP/1.1 302 Found\nLocation: {https://yourApp/callback}#access_token=TOKEN&state=STATE&token_type=TYPE&expires_in=SECONDS\n```\n\n### GET /authorize\n\nThis is the OAuth 2.0 grant that web apps utilize in order to access an API.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`audience`  \n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nThe scopes which you want to request authorization for. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`. Custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`).\n\n`response_type`  \nRequired\n\nThis will specify the type of token you will receive at the end of the flow. Use `token` to get only an Access Token, `id_token` to get only an ID token (if you don't plan on accessing an API), or `id_token token` to get both an ID token and an Access Token.\n\n`client_id`  \nRequired\n\nYour application's ID.\n\n`state`  \nRecommended\n\nAn opaque value the application adds to the initial request that Auth0 includes when redirecting back to the application. This value must be used by the application to prevent CSRF attacks.\n\n`redirect_uri`\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user.\n\n`nonce`  \nRecommended\n\nA string value which will be included in the ID token response from Auth0, [used to prevent token replay attacks](https://auth0.com/docs/api-auth/tutorials/nonce). It is required for `response_type=id_token token`.\n\n`connection`\n\nThe name of the connection configured for your application.\n\n`prompt`\n\nTo initiate a [silent authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) request, use `prompt=none` (To learn more, read the Remarks).\n\n`organization`\n\nID of the [organization](https://auth0.com/docs/organizations) to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating.\n\n`invitation`\n\nTicket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the invitation and organization key-value pairs when the user accepts the invitation.\n\n*   The `redirect_uri` value must be specified as a valid callback URL under your [Application's Settings](https://manage.auth0.com/#/applications).\n*   If `response_type=token`, after the user authenticates with the provider, this will redirect them to your application callback URL while passing the `access_token` in the address `location.hash`. This is used for Single-Page Apps and on Native Mobile SDKs.\n*   The Implicit Grant does not support the issuance of Refresh Tokens. Use [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication) instead.\n*   In order to improve compatibility for applications, Auth0 will now return profile information in a [structured claim format as defined by the OIDC specification](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). This means that in order to add custom claims to ID tokens or Access Tokens, they must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims) to avoid possible collisions with standard OIDC claims.\n*   Silent Authentication lets you perform an authentication flow where Auth0 will only reply with redirects, and never with a login page. When an Access Token has expired, silent authentication can be used to retrieve a new one without user interaction, assuming the user's Single Sign-on (SSO) session has not expired.\n\n### Learn More\n\n*   [Implicit Flow](https://auth0.com/docs/flows/concepts/implicit)\n*   [State Parameter](https://auth0.com/docs/protocols/oauth2/oauth-state)\n*   [Mitigate replay attacks when using the Implicit Grant](https://auth0.com/docs/api-auth/tutorials/nonce)\n*   [Silent Authentication](https://auth0.com/docs/api-auth/tutorials/silent-authentication)\n\n\\>\n\n## Resource Owner Password Flow\n\n## Get Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=password&username=USERNAME&password=PASSWORD&audience=API_IDENTIFIER&scope=SCOPE&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=password&username=USERNAME&password=PASSWORD&audience=API_IDENTIFIER&scope=SCOPE&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { grant_type: 'password',\n     username: 'USERNAME',\n     password: 'PASSWORD',\n     audience: 'API_IDENTIFIER',\n     scope: 'SCOPE',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### POST /oauth/token\n\nThis is the OAuth 2.0 grant that highly-trusted apps use to access an API. In this flow, the end-user is asked to fill in credentials (username/password), typically using an interactive form in the user-agent (browser). This information is sent to the backend and from there to Auth0. It is therefore imperative that the application is absolutely trusted with this information. For [single-page applications and native/mobile apps](https://auth0.com/docs/flows/concepts/auth-code-pkce), we recommend using web flows instead.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Resource Owner Password use `password`. To add realm support use `http://auth0.com/oauth/grant-type/password-realm`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_secret`\n\nYour application's Client Secret. Required when the Token Endpoint Authentication Method field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`audience`\n\nThe unique identifier of the target API you want to access.\n\n`username`  \nRequired\n\nResource Owner's identifier, such as a username or email address.\n\n`password`  \nRequired\n\nResource Owner's secret.\n\n`scope`\n\nString value of the different scopes the application is asking for. Multiple scopes are separated with whitespace.\n\n`realm`\n\nString value of the realm the user belongs. Set this if you want to add realm support at this grant. For more information on what realms are refer to [Realm Support](https://auth0.com/docs/api-auth/grant/password#realm-support).\n\nParameter\n\nDescription\n\n`auth0-forwarded-for`\n\nEnd-user IP as a string value. Set this if you want brute-force protection to work in server-side scenarios. For more information on how and when to use this header, refer to [Using resource owner password from server-side](https://auth0.com/docs/api-auth/tutorials/using-resource-owner-password-from-server-side).\n\n*   The scopes issued to the application may differ from the scopes requested. In this case, a `scope` parameter will be included in the response JSON.\n*   If you don't request specific scopes, all scopes defined for the audience will be returned due to the implied trust to the application in this grant. You can customize the scopes returned in a rule. For more information, refer to [Calling APIs from Highly Trusted Applications](https://auth0.com/docs/api-auth/grant/password).\n*   To add realm support set the `grant_type` to `http://auth0.com/oauth/grant-type/password-realm`, and the `realm` to the realm the user belongs. This maps to a connection in Auth0. For example, if you have configured a database connection for your internal employees and you have named the connection `employees`, then use this value. For more information on how to implement this refer to: [Realm Support](https://auth0.com/docs/api-auth/tutorials/password-grant#realm-support).\n*   In addition to username and password, Auth0 may also require the end-user to provide an additional factor as proof of identity before issuing the requested scopes. In this case, the request described above will return an `mfa_required` error along with an `mfa_token`. You can use these tokens to request a challenge for the possession factor and validate it accordingly. For details refer to [Resource Owner Password and MFA](#resource-owner-password-and-mfa).\n\n### Learn More\n\n*   [Calling APIs from Highly-Trusted Applications](https://auth0.com/docs/api-auth/grant/password)\n*   [Executing the Resource Owner Password Grant](https://auth0.com/docs/api-auth/tutorials/password-grant)\n*   [Multi-factor Authentication and Resource Owner Password](https://auth0.com/docs/mfa/guides/mfa-api/multifactor-resource-owner-password)\n\n\\>\n\n## Device Authorization Flow\n\n## Authorize\n\n```\nPOST https://{yourDomain}/oauth/device/code\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&scope=SCOPE&audience=API_IDENTIFIER\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/device/code' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}&scope=SCOPE&audience=API_IDENTIFIER'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/device/code',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { client_id: '{yourClientId}',\n     scope: 'SCOPE',\n     audience: 'API_IDENTIFIER' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"device_code\":\"GmRh...k9eS\",\n  \"user_code\":\"WDJB-MJHT\",\n  \"verification_uri\":\"https://{yourDomain}/device\",\n  \"verification_uri_complete\":\"https://{yourDomain}/device?user_code=WDJB-MJHT\",\n  \"expires_in\":900, //in seconds\n  \"interval\":5\n}\n```\n\n### POST /oauth/device/code\n\nThis is the flow that input-constrained devices use to access an API. Use this endpoint to get a device code. To begin the [Device Authorization Flow](https://auth0.com/docs/flows/concepts/device-auth), your application should first request a device code.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`audience`  \n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nThe scopes for which you want to request authorization. These must be separated by a space. You can request any of the [standard OIDC scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, custom claims that must [conform to a namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). Include `offline_access` to get a Refresh Token.\n\n`client_id`  \nRequired\n\nYour application's ID.\n\n### Response Values\n\nValue\n\nDescription\n\n`device_code`\n\nThe unique code for the device. When the user visits the `verification_uri` in their browser-based device, this code will be bound to their session.\n\n`user_code`\n\nThe code that the user should input at the `verification_uri` to authorize the device.\n\n`verification_uri`\n\nThe URL the user should visit to authorize the device.\n\n`verification_uri_complete`\n\nThe complete URL the user should visit to authorize the device. Your app can use this value to embed the `user_code` in the URL, if you so choose.\n\n`expires_in`\n\nThe lifetime (in seconds) of the `device_code` and `user_code`.\n\n`interval`\n\nThe interval (in seconds) at which the app should poll the token URL to request a token.\n\n*   Include `offline_access` to the `scope` request parameter to get a Refresh Token from [POST /oauth/token](#device-auth). Make sure that the **Allow Offline Access** field is enabled in the [API Settings](https://manage.auth0.com/#/apis).\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\nclient_id={yourClientId}&device_code=YOUR_DEVICE_CODE&grant_type=urn:ietf:params:oauth:grant-type:device_code\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}&device_code=YOUR_DEVICE_CODE&grant_type=urn:ietf:params:oauth:grant-type:device_code'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { client_id: '{yourClientId}',\n     device_code: 'YOUR_DEVICE_CODE',\n     grant_type: 'urn:ietf:params:oauth:grant-type:device_code' }\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n   \"access_token\": \"eyJz93a...k4laUWw\",\n   \"id_token\": \"eyJ...0NE\",\n   \"refresh_token\": \"eyJ...MoQ\",\n   \"scope\": \"...\",\n   \"expires_in\": 86400,\n   \"token_type\": \"Bearer\"\n}\n```\n\n```\nHTTP/1.1 403 Forbidden\nContent-Type: application/json\n { \n  // Can be retried\n  \"error\": \"authorization_pending\",\n  \"error_description\": \"User has yet to authorize device code.\"\n }\n```\n\n```\nHTTP/1.1 429 Too Many Requests\nContent-Type: application/json\n { \n  // Can be retried\n  \"error\": \"slow_down\",\n  \"error_description\": \"You are polling faster than the specified interval of 5 seconds.\"\n }\n```\n\n```\nHTTP/1.1 403 Forbidden\nContent-Type: application/json\n { \n    // Cannot be retried; transaction failed\n    \"error\": \"access_denied|invalid_grant|...\",\n    \"error_description\": \"Failure: User cancelled the confirmation prompt or consent page; the code expired; there was an error.\"\n }\n```\n\n### POST /oauth/token\n\nThis is the OAuth 2.0 grant that input-constrained devices use to access an API. Poll this endpoint using the interval returned with your [device code](https://auth0.com/docs/api/authentication#get-device-code) to directly request an access token using the application's credentials (a Client ID) and a device code.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Device Authorization, use `urn:ietf:params:oauth:grant-type:device_code`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`device_code`  \nRequired\n\nThe device code previously returned from the [/oauth/device/code endpoint](https://auth0.com/docs/api/authentication#device-authorization-flow).\n\n*   Because you will be polling this endpoint (using the `interval` from the initial response to determine frequency) while waiting for the user to go to the verification URL and enter their user code, you will likely receive at least one failure before receiving a successful response. See sample responses for possible responses.\n\n### Learn More\n\n*   [Device Authorization Flow](https://auth0.com/docs/flows/concepts/device-auth)\n*   [Call API using the Device Authorization Flow](https://auth0.com/docs/flows/guides/device-auth/call-api-device-auth)\n*   [Setting up a Device Code Grant using the Management Dashboard](https://auth0.com/docs/api-auth/config/using-the-auth0-dashboard)\n\n## Refresh Token\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=refresh_token&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&refresh_token=YOUR_REFRESH_TOKEN\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=refresh_token&client_id={yourClientId}&client_secret=YOUR_CLIENT_SECRET&refresh_token=YOUR_REFRESH_TOKEN'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { grant_type: 'refresh_token',\n     client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     refresh_token: 'YOUR_REFRESH_TOKEN'}\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n  \"access_token\": \"eyJ...MoQ\",\n  \"expires_in\": 86400,\n  \"scope\": \"openid offline_access\",\n  \"id_token\": \"eyJ...0NE\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n### POST /oauth/token\n\nUse this endpoint to refresh an Access Token using the Refresh Token you got during authorization.\n\n## Request Parameters\n\nParameter\n\nDescription\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. To refresh a token, use `refresh_token`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`client_secret`\n\nYour application's Client Secret. Required when the **Token Endpoint Authentication Method** field at your [Application Settings](https://manage.auth0.com/#/applications) is `Post` or `Basic`.\n\n`refresh_token`  \nRequired\n\nThe refresh token to use.\n\n`scope`\n\nA space-delimited list of requested scope permissions. If not sent, the original scopes will be used; otherwise you can request a reduced set of scopes. Note that this must be URL encoded.\n\n## Learn More\n\n*   [Refresh Tokens](https://auth0.com/docs/tokens/concepts/refresh-tokens)\n\n## Revoke Refresh Token\n\n```\nPOST https://{yourDomain}/oauth/revoke\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"YOUR_CLIENT_SECRET\",\n  \"token\": \"YOUR_REFRESH_TOKEN\",\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/revoke' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"client_id\": \"{yourClientId}\", \"client_secret\": \"YOUR_CLIENT_SECRET\", \"token\": \"YOUR_REFRESH_TOKEN\" }'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/revoke',\n  headers: { 'content-type': 'application/json' },\n  body: \n   { client_id: '{yourClientId}',\n     client_secret: 'YOUR_CLIENT_SECRET',\n     token: 'YOUR_REFRESH_TOKEN' },\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\n(empty-response-body)\n```\n\n### POST /oauth/revoke\n\nUse this endpoint to invalidate a Refresh Token if it has been compromised.\n\nThe behaviour of this endpoint depends on the state of the [Refresh Token Revocation Deletes Grant](https://auth0.com/docs/tokens/refresh-tokens/revoke-refresh-tokens#refresh-tokens-and-grants) toggle. If this toggle is enabled, then each revocation request invalidates not only the specific token, but all other tokens based on the same authorization grant. This means that **all Refresh Tokens that have been issued for the same user, application, and audience will be revoked**. If this toggle is disabled, then only the refresh token is revoked, while the grant is left intact.\n\n## Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`client_assertion`\n\nA JWT containing a signed assertion with your application credentials. Required when Private Key JWT is the application authentication method.\n\n`client_assertion_type`\n\nThe value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method.\n\n`client_secret`\n\nThe `client_secret` of your application. Required when Client Secret Basic or Client Secret Post is the application authentication method. Specifically required for Regular Web Applications **only**.\n\n`token`  \nRequired\n\nThe Refresh Token you want to revoke.\n\n*   For non-confidential applications that cannot keep the Client Secret safe (for example, native apps), the endpoint supports passing no Client Secret but the application itself must have the property `tokenEndpointAuthMethod` set to `none`. You can do this either from the UI ([Dashboard > Applications > Application Settings](https://manage.auth0.com/#/applications)) or using the [Management API](https://auth0.com/docs/api/management/v2#!/Applications/patch_applications_by_id).\n\n## Error Codes\n\nFor the complete error code reference for this endpoint, refer to [Errors > POST /oauth/revoke](#post-oauth-revoke).\n\n## Learn More\n\n*   [Refresh Tokens](https://auth0.com/docs/tokens/concepts/refresh-tokens)\n\n```\nPOST https://{yourDomain}/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=urn:ietf:params:oauth:grant-type:token-exchange&subject_token=SUBJECT_TOKEN&subject_token_type=SUBJECT_TOKEN_TYPE&client_id={yourClientId}&audience=API_IDENTIFIER&scope=SCOPE\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=urn:ietf:params:oauth:grant-type:token-exchange&subject_token=SUBJECT_TOKEN&subject_token_type=SUBJECT_TOKEN_TYPE&client_id={yourClientId}&audience=API_IDENTIFIER&scope=SCOPE'\n }'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: { 'content-type': 'application/x-www-form-urlencoded' },\n  form:\n   { grant_type: 'urn:ietf:params:oauth:grant-type:token-exchange',\n     subject_token: 'SUBJECT_TOKEN',\n     subject_token_type: 'SUBJECT_TOKEN_TYPE',\n     client_id: '{yourClientId}',\n     audience: 'API_IDENTIFIER',\n     scope: 'SCOPE',\n   };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{ \n  \"access_token\": \"eyJz93a...k4laUWw\",\n  \"id_token\": \"eyJ...0NE\",\n  \"refresh_token\": \"eyJ...MoQ\",\n  \"expires_in\":86400,\n  \"token_type\":\"Bearer\"\n}\n```\n\n### POST /oauth/token\n\nWhen a non-browser-based solution (such as a mobile platform's SDK) authenticates the user, the authentication will commonly result in artifacts being returned to application code. In such situations, this grant type allows for the Auth0 platform to accept artifacts from trusted sources and issue tokens in response. In this way, apps making use of non-browser-based authentication mechanisms (as are common in native apps) can still retrieve Auth0 tokens without asking for further user interaction.\n\nArtifacts returned by this flow (and the contents thereof) will be determined by the `subject_token_type` and the tenant's configuration settings.\n\n## Request Parameters\n\nParameter\n\nDescription\n\n`auth0-forwarded-for`\n\nEnd user IP as a string value. Set this if you want brute-force protection to work in server-side scenarios. To learn more about how and when to use this header, read [Using resource owner password from server-side](https://auth0.com/docs/api-auth/tutorials/using-resource-owner-password-from-server-side).\n\n`grant_type`  \nRequired\n\nDenotes the flow you are using. For Token Exchange for Native Social, use `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n`subject_token`  \nRequired\n\nExternally-issued identity artifact representing the user.\n\n`subject_token_type`  \nRequired\n\nIdentifier that indicates the type of `subject_token`.\n\n`client_id`  \nRequired\n\nYour application's Client ID.\n\n`audience`\n\nThe unique identifier of the target API you want to access.\n\n`scope`\n\nString value of the different scopes the application is requesting. Multiple scopes are separated with whitespace.\n\n`user_profile`  \nOnly For `apple-authz-code`\n\nOptional element used for native iOS interactions for which profile updates can occur. Expected parameter value will be JSON in the form of: `{ name: { firstName: 'John', lastName: 'Smith }}`\n\n*   The scopes issued to the application may differ from the requested scopes. In this case, a `scope` parameter will be included in the response JSON.\n*   If you don't request specific scopes, all scopes defined for the audience will be returned due to the implied trust to the application in this grant. You can customize the scopes returned in a rule. To learn more, read [Calling APIs from Highly Trusted Applications](https://auth0.com/docs/api-auth/grant/password).\n\n## Learn More\n\n*   [Add Sign In with Apple to Native iOS Apps](https://auth0.com/docs/connections/apple-siwa/add-siwa-to-native-app)\n*   [iOS Swift - Sign In with Apple Quickstart](https://auth0.com/docs/quickstart/native/ios-swift-siwa)\n\nLegacy\n\n## Login\n\n```\nPOST https://{yourDomain}/oauth/access_token\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"access_token\": \"ACCESS_TOKEN\",\n  \"connection\": \"CONNECTION\",\n  \"scope\": \"SCOPE\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/access_token' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"access_token\":\"ACCESS_TOKEN\", \"connection\":\"CONNECTION\", \"scope\":\"SCOPE\"}'\n```\n\n```\nvar url = 'https://' + {yourDomain} + '/oauth/access_token';\nvar params = 'client_id={yourClientId}&access_token={ACCESS_TOKEN}&connection={CONNECTION}&scope={SCOPE}';\n\nvar xhr = new XMLHttpRequest();\n\nxhr.open('POST', url);\nxhr.setRequestHeader('Content-Type', 'application/json');\n\nxhr.onload = function() {\n  if (xhr.status == 200) {\n    fetchProfile();\n  } else {\n    alert(\"Request failed: \" + xhr.statusText);\n  }\n};\n\nxhr.send(params);\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"id_token\": \"eyJ0eXAiOiJKV1Qi...\",\n  \"access_token\": \"A9CvPwFojaBI...\",\n  \"token_type\": \"bearer\"\n}\n```\n\n### POST /oauth/access\\_token\n\nGiven the social provider's Access Token and the `connection`, this endpoint will authenticate the user with the provider and return a JSON with the Access Token and, optionally, an ID Token. This endpoint only works for Facebook, Google, Twitter, and Weibo.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application.\n\n`access_token`  \nRequired\n\nThe social provider's Access Token.\n\n`connection`  \nRequired\n\nThe name of an identity provider configured to your app.\n\n`scope`\n\nUse `openid` to get an ID Token, or `openid profile email` to include user information in the ID Token. If null, only an Access Token will be returned.\n\n*   The `profile` scope value requests access to the End-User's default profile Claims, which are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`.\n    \n*   The `email` scope value requests access to the `email` and `email_verified` Claims.\n    \n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Errors > POST /oauth/access\\_token](#post-oauth-access_token).\n\n### Learn More\n\n*   [Call an Identity Provider API](https://auth0.com/docs/tutorials/calling-an-external-idp-api)\n*   [Identity Provider Access Tokens](https://auth0.com/docs/tokens/overview-idp-access-tokens)\n*   [Add scopes/permissions to call Identity Provider's APIs](https://auth0.com/docs/connections/adding-scopes-for-an-external-idp)\n\n```\nPOST https://{yourDomain}/oauth/ro\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"username\": \"USERNAME\",\n  \"password\": \"PASSWORD\",\n  \"connection\": \"CONNECTION\",\n  \"scope\": \"openid\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/ro' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"username\":\"USERNAME\", \"password\":\"PASSWORD\", \"connection\":\"CONNECTION\", \"scope\":\"openid\"}'\n\n```\n\n```\n// Script uses auth0.js. See Remarks for details.\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  // Initialize application\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n\n  // Trigger login using redirect with credentials to enterprise connections\n  webAuth.redirect.loginWithCredentials({\n    connection: 'Username-Password-Authentication',\n    username: 'testuser',\n    password: 'testpass',\n    scope: 'openid'\n  });\n\n  // Trigger login using popup mode with credentials to enterprise connections\n  webAuth.popup.loginWithCredentials({\n    connection: 'Username-Password-Authentication',\n    username: 'testuser',\n    password: 'testpass',\n    scope: 'openid'\n  });\n\n  // The client.login method allows for non redirect auth using custom database connections, using /oauth/token.\n  webAuth.client.login({\n    realm: 'tests',\n    username: 'testuser',\n    password: 'testpass',\n    scope: 'openid profile',\n    audience: 'urn:test'\n  });\n</script>\n```\n\n### POST /oauth/ro\n\nUse this endpoint for API-based (active) authentication. Given the user credentials and the `connection` specified, it will do the authentication on the provider and return a JSON with the Access Token and ID Token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nThe `client_id` of your application\n\n`username`  \nRequired\n\nUsername/email of the user to login\n\n`password`  \nRequired\n\nPassword of the user to login\n\n`connection`  \nRequired\n\nThe name of the connection to use for login\n\n`scope`\n\nSet to `openid` to retrieve also an ID Token, leave null to get only an Access Token\n\n`grant_type`  \nRequired\n\nSet to `password` to authenticate using username/password or `urn:ietf:params:oauth:grant-type:jwt-bearer` to authenticate using an ID Token instead of username/password, in [Touch ID](https://auth0.com/docs/libraries/lock-ios/touchid-authentication) scenarios.\n\n`device`\n\nString value. Required when `grant_type` is `urn:ietf:params:oauth:grant-type:jwt-bearer`\n\n`id_token`\n\nUsed to authenticate using a token instead of username/password, in [Touch ID](https://auth0.com/docs/libraries/lock-ios/touchid-authentication) scenarios. Required when `grant_type` is `urn:ietf:params:oauth:grant-type:jwt-bearer`\n\n*   This endpoint only works for database connections, passwordless connections, Active Directory/LDAP, Windows Azure AD and ADFS.\n    \n*   The main difference between passive and active authentication is that the former happens in the browser through the [Auth0 Login Page](https://{yourdomain}/login) and the latter can be invoked from anywhere (a script, server to server, and so forth).\n    \n*   The sample auth0.js script uses the library version 8. If you are using auth0.js version 7, please see this [reference guide](https://auth0.com/docs/libraries/auth0js/v7).\n    \n\n### Error Codes\n\nFor the complete error code reference for this endpoint, refer to [Errors > POST /oauth/ro](#post-oauth-ro).\n\n### Learn More\n\n*   [Database Identity Providers](https://auth0.com/docs/connections/database)\n*   [Rate Limits on User/Password Authentication](https://auth0.com/docs/policies/rate-limit-policy/database-connections-rate-limits)\n*   [Active Directory/LDAP Connector](https://auth0.com/docs/connector)\n\n## User Profile\n\n## Get Token Info\n\n```\nPOST https://{yourDomain}/tokeninfo\nContent-Type: application/json\n{\n  \"id_token\": \"ID_TOKEN\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/tokeninfo' \\\n  --header 'content-type: application/json' \\\n  --data '{\"id_token\":\"\"}'\n```\n\n```\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"text/javascript\">\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}'\n  });\n</script>\n\nwebAuth.parseHash(window.location.hash, function(err, authResult) {\n  if (err) {\n    return console.log(err);\n  }\n\n  webAuth.client.userInfo(authResult.accessToken, function(err, user) {\n    // Now you have the user's information\n  });\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"email_verified\": false,\n  \"email\": \"foo@bar.com\",\n  \"clientID\": \"q2hnj2iug0...\",\n  \"updated_at\": \"2016-12-08T14:26:59.923Z\",\n  \"name\": \"foo@bar.com\",\n  \"picture\": \"https://s.gravatar.com/avatar/foobar.png\",\n  \"user_id\": \"auth0|58454...\",\n  \"nickname\": \"foo.bar\",\n  \"identities\": [\n    {\n      \"user_id\": \"58454...\",\n      \"provider\": \"auth0\",\n      \"connection\": \"Username-Password-Authentication\",\n      \"isSocial\": false\n    }\n  ],\n  \"created_at\": \"2016-12-05T11:16:59.640Z\",\n  \"global_client_id\": \"dfas76s...\"\n}\n```\n\n### POST /tokeninfo\n\nThis endpoint validates a JSON Web Token (JWT) (signature and expiration) and returns the user information associated with the user id `sub` property of the token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`id_token`  \nRequired\n\nThe ID Token to use.\n\n*   This endpoint will return three HTTP Response Headers, that provide relevant data on its rate limits:\n    *   `X-RateLimit-Limit`: Number of requests allowed per minute.\n    *   `X-RateLimit-Remaining`: Number of requests available. Each new request reduces this number by 1. For each minute that passes, requests are added back, so this number increases by 1 each time.\n    *   `X-RateLimit-Reset`: Remaining time until the rate limit (`X-RateLimit-Limit`) resets. The value is in [UTC epoch seconds](https://en.wikipedia.org/wiki/Unix_time).\n\n### Learn More\n\n*   [User Profile Struture](https://auth0.com/docs/users/references/user-profile-structure)\n    \n*   [Auth0 API Rate Limit Policy](https://auth0.com/docs/policies/rate-limits)\n    \n\n## Account Linking\n\n## Link\n\n```\nGET https://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection=CONNECTION&\n  redirect_uri={https://yourApp/callback}&\n  access_token=LOGGED_IN_USER_ACCESS_TOKEN\n```\n\n### GET /authorize\n\nCall this endpoint when a user wants to link a second authentication method (for example, a user/password database connection, with Facebook).\n\nThis endpoint will trigger the login flow to link an existing account with a new one. This will return a 302 redirect to the `connection` that the current user wants to add. The user is identified by the Access Token that was returned on login success.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`response_type`  \nRequired\n\nUse `code` for server side flows, `token` for client side flows\n\n`client_id`  \nRequired\n\nThe `client_id` of your application\n\n`connection`\n\nThe name of the connection configured to your application. If null, it will redirect to [Auth0 Login Page](https://auth0.com/#/login_page) and show the Login Widget using the first database connection.\n\n`redirect_uri`  \nRequired\n\nThe URL to which Auth0 will redirect the browser after authorization has been granted by the user.\n\n`access_token`  \nRequired\n\nThe logged-in user's Access Token\n\n*   The `redirect_uri` value must be specified as a valid callback URL under your [Application's Settings](https://manage.auth0.com/#/applications).\n\n### Learn More\n\n*   [Link User Accounts](https://auth0.com/docs/users/guides/link-user-accounts)\n*   [Link User Accounts Initiated by Users Scenario](https://auth0.com/docs/users/references/link-accounts-user-initiated-scenario)\n*   [Link User Accounts Server-Side Scenario](https://auth0.com/docs/users/references/link-accounts-server-side-scenario)\n\n## Unlink\n\n```\nPOST https://{yourDomain}/login/unlink\nContent-Type: application/json\n{\n  \"access_token\": \"LOGGED_IN_USER_ACCESS_TOKEN\", // Primary identity Access Token\n  \"user_id\": \"LINKED_USER_ID\" // (provider|id)\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/login/unlink' \\\n  --header 'content-type: application/json' \\\n  --data '{\"access_token\": \"LOGGED_IN_USER_ACCESS_TOKEN\", \"user_id\": \"LINKED_USER_ID\"}'\n```\n\n```\nvar url = 'https://' + {yourDomain} + '/login/unlink';\nvar params = 'access_token=LOGGED_IN_USER_ACCESS_TOKEN&user_id=' + localStorage.getItem('user_id');\n\nvar xhr = new XMLHttpRequest();\nxhr.open('POST', url);\nxhr.setRequestHeader('Content-Type', 'application/json');\n\nxhr.onload = function() {\n  if (xhr.status == 200) {\n    fetchProfile();\n  } else {\n    alert(\"Request failed: \" + xhr.statusText);\n  }\n};\n\nxhr.send(params);\n```\n\n### POST /login/unlink\n\nGiven a logged-in user's `access_token` and `user_id`, this endpoint will unlink a user's account from the identity provider.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`access_token`  \nRequired\n\nThe logged-in user's Access Token\n\n`user_id`  \nRequired\n\nThe logged-in user's `user_id`\n\n### Learn More\n\n*   [Unlink User Accounts](https://auth0.com/docs/users/guides/unlink-user-accounts)\n\n## Delegation\n\n```\nPOST https://{yourDomain}/delegation\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"grant_type\": \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n  \"id_token\" or \"refresh_token\" : \"TOKEN\",\n  \"target\": \"TARGET_CLIENT_ID\",\n  \"scope\": \"openid\",\n  \"api_type\": \"API_TYPE\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/delegation' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\":\"{yourClientId}\", \"grant_type\":\"urn:ietf:params:oauth:grant-type:jwt-bearer\", \"id_token|refresh_token\":\"TOKEN\", \"target\":\"TARGET_CLIENT_ID\", \"scope\":\"openid\", \"api_type\":\"API_TYPE\"}'\n```\n\n```\n// Delegation is not supported in version 8 of auth0.js.\n// For a version 7 sample refer to: https://auth0.com/docs/libraries/auth0js/v7#delegation-token-request\n```\n\n### POST /delegation\n\nA delegation token can be obtained and used when an application needs to call the API of an Application Addon, such as Firebase or SAP, registered and configured in Auth0, in the same tenant as the calling program.\n\nGiven an existing token, this endpoint will generate a new token signed with the `target` app' secret. This is used to flow the identity of the user from the application to an API.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nΤhe `client_id` of your app\n\n`grant_type`  \nRequired\n\nUse `urn:ietf:params:oauth:grant-type:jwt-bearer`\n\n`id_token` or `refresh_token`  \nRequired\n\nThe existing token of the user.\n\n`target`\n\nThe target `client_id`\n\n`scope`\n\nUse `openid` or `openid profile email`\n\n`api_type`\n\nThe API to be called.\n\n*   The `profile` scope value requests access to the End-User's default profile Claims, which are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`.\n    \n*   The `email` scope value requests access to the `email` and `email_verified` Claims.\n    \n*   Delegation is **not supported** in version 8 of [auth0.js](https://auth0.com/docs/libraries/auth0js). For a sample in version 7 of the library, refer to [Delegation Token Request](https://auth0.com/docs/libraries/auth0js/v7#delegation-token-request).\n    \n*   This endpoint limits up to 10 requests per minute from the same IP address with the same `user_id`.\n    \n*   This endpoint will return three HTTP Response Headers, that provide relevant data on its rate limits:\n    \n    *   `X-RateLimit-Limit`: Number of requests allowed per minute.\n    *   `X-RateLimit-Remaining`: Number of requests available. Each new request reduces this number by 1. For each minute that passes, requests are added back, so this number increases by 1 each time.\n    *   `X-RateLimit-Reset`: Remaining time until the rate limit (`X-RateLimit-Limit`) resets. The value is in [UTC epoch seconds](https://en.wikipedia.org/wiki/Unix_time).\n\n### Learn More\n\n*   [Delegation Tokens](https://auth0.com/docs/tokens/delegation)\n*   [Auth0 API Rate Limit Policy](https://auth0.com/docs/policies/rate-limits)\n\n## Impersonation\n\n```\nPOST https://{yourDomain}/users/{user_id}/impersonate\nContent-Type:   application/json\nAuthorization:  'Bearer {ACCESS_TOKEN}'\n{\n  protocol: \"PROTOCOL\",\n  impersonator_id: \"IMPERSONATOR_ID\",\n  client_id: \"{yourClientId}\",\n  additionalParameters: [\n    \"response_type\": \"code\",\n    \"state\": \"STATE\"\n  ]\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/users/{user_id}/impersonate' \\\n  --header 'Authorization: Bearer {ACCESS_TOKEN}' \\\n  --header 'content-type: application/x-www-form-urlencoded; charset=UTF-8' \\\n  --data '{\"protocol\":\"PROTOCOL\", \"impersonator_id\":\"IMPERSONATOR_ID\", \"client_id\":\"{yourClientId}\", \"additionalParameters\": {\"response_type\": \"code\", \"state\": \"STATE\"}}'\n```\n\n```\nvar url = 'https://' + {yourDomain} + '/users/' + localStorage.getItem('user_id') + '/impersonate';\nvar params = 'protocol=PROTOCOL&impersonator_id=IMPERSONATOR_ID&client_id={yourClientId}';\n\nvar xhr = new XMLHttpRequest();\n\nxhr.open('POST', url);\nxhr.setRequestHeader('Content-Type', 'application/json');\nxhr.setRequestHeader('Authorization', 'Bearer ' + localStorage.getItem('access_token'));\n\nxhr.onload = function() {\n  if (xhr.status == 200) {\n    fetchProfile();\n  } else {\n    alert(\"Request failed: \" + xhr.statusText);\n  }\n};\n\nxhr.send(params);\n```\n\n> RESPONSE SAMPLE:\n\n```\nhttps:/YOUR_DOMAIN/users/IMPERSONATOR_ID/impersonate?&bewit=WFh0MUtm...\n```\n\n### POST /users/{user\\_id}/impersonate\n\nUse this endpoint to obtain an impersonation URL to login as another user. Useful for troubleshooting.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`protocol`  \nRequired\n\nThe protocol to use against the identity provider: `oauth2`, `samlp`, `wsfed`, `wsfed-rms`.\n\n`impersonator_id`  \nRequired\n\nThe `user_id` of the impersonator.\n\n`client_id`  \nRequired\n\nThe `client_id` of the client that is generating the impersonation link.\n\n`additionalParameters`\n\nThis is a JSON object. You can use this to set additional parameters, like `response_type`, `scope` and `state`.\n\n*   This endpoint can only be used with **Global Client** credentials.\n    \n*   To distinguish between real logins and impersonation logins, the profile of the impersonated user will contain additional impersonated and impersonator properties. For example: `\"impersonated\": true, \"impersonator\": {\"user_id\": \"auth0|...\", \"email\": \"admin@example.com\"}`.\n    \n*   For a regular web app, you should set the `additionalParameters`: set the `response_type` to be `code`, the `callback_url` to be the callback URL to which Auth0 will redirect with the authorization code, and the `scope` to be the JWT claims that you want included in the JWT.\n    \n\n## Resource Owner\n\n```\nPOST https://{yourDomain}/oauth/ro\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientId}\",\n  \"connection\": \"CONNECTION\",\n  \"grant_type\": \"password\",\n  \"username\": \"USERNAME\",\n  \"password\": \"PASSWORD\",\n  \"scope\": \"SCOPE\",\n  \"id_token\": \"ID_TOKEN\",\n  \"device\": \"DEVICE\"\n}\n```\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/ro' \\\n  --header 'accept: application/json' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"client_id\": \"{yourClientId}\", \"connection\": \"CONNECTION\", \"grant_type\": \"password\", \"username\": \"USERNAME\", \"password\": \"PASSWORD\", \"scope\": \"SCOPE\", \"id_token\": \"ID_TOKEN\", \"device\": \"DEVICE\" }'\n```\n\n```\nvar request = require(\"request\");\n\nvar options = { method: 'POST',\n  url: 'https://{yourDomain}/oauth/ro',\n  headers: { 'content-type': 'application/json', 'accept': 'application/json' },\n  body:\n   { connection: 'CONNECTION',\n     grant_type: 'PASSWORD',\n     username: 'USERNAME',\n     client_id: '{yourClientId}',\n     password: 'PASSWORD',\n     scope: 'SCOPE',\n     id_token: 'ID_TOKEN',\n     device: 'DEVICE'},\n  json: true };\n\nrequest(options, function (error, response, body) {\n  if (error) throw new Error(error);\n\n  console.log(body);\n});\n```\n\n> RESPONSE SAMPLE:\n\n```\n{\n  \"access_token\": \"eyJz93a...\",\n  \"id_token\": \"eyJ0XAi...\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n### POST /oauth/ro\n\nGiven the user's credentials, this endpoint will authenticate the user with the provider and return a JSON object with the Access Token and an ID Token.\n\n### Request Parameters\n\nParameter\n\nDescription\n\n`client_id`  \nRequired\n\nYour application's Application ID.\n\n`connection`  \nRequired\n\nThe name of the connection configured to your application\n\n`grant_type`  \nRequired\n\nUse the value `password`\n\n`username`  \nRequired\n\nThe user's username\n\n`password`  \nRequired\n\nThe user's password\n\n`scope`\n\nUse `openid` to get an ID Token, `openid profile email` to get an ID Token and the user profile, or `openid offline_access` to get an ID Token and a Refresh Token.\n\n`id_token`\n\nUsed to authenticate using a token instead of username/password, in [Touch ID](https://auth0.com/docs/libraries/lock-ios/touchid-authentication) scenarios.\n\n`device`\n\nYou should set this to a string, if you are requesting a Refresh Token (`scope=offline_access`).\n\n*   This endpoint only works for database connections, passwordless connections, Active Directory/LDAP, Windows Azure AD and ADFS.\n    \n*   The `profile` scope value requests access to the End-User's default profile Claims, which are: `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale`, and `updated_at`.\n    \n*   The `email` scope value requests access to the `email` and `email_verified` Claims.\n    \n\n### Error Codes\n\nFor the complete error code reference for this endpoint refer to [Errors > POST /oauth/ro](#post-oauth-ro).\n\n### Learn More\n\n*   [Calling APIs from Highly Trusted Applications](https://auth0.com/docs/api-auth/grant/password)\n\nErrors\n\n## Standard Error Responses\n\nThe Authentication API may return the following HTTP Status Codes:\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"...\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"...\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_scope\", \"error_description\": \"Scope must be an array or a string\"}`\n\n401 Unauthorized\n\n`{\"error\": \"invalid_client\", \"error_description\": \"...\"}`\n\n401 Unauthorized\n\n`{\"error\": \"requires_validation\", \"error_description\": \"Suspicious request requires verification\"}`\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\", \"error_description\": \"...\"}`\n\n403 Forbidden\n\n`{\"error\": \"access_denied\", \"error_description\": \"...\"}`\n\n403 Forbidden\n\n`{\"error\": \"access_denied\", \"error_description\": \"Unknown or invalid refresh token\"}`\n\n403 Forbidden\n\n`{\"error\": \"invalid_grant\", \"error_description\": \"...\"}`\n\n404 Not Found\n\n`{\"error\": \"endpoint_disabled\", \"error_description\": \"...\"}`\n\n405 Method Not Allowed\n\n`{\"error\": \"method_not_allowed\", \"error_description\": \"...\"}`\n\n429 Too Many Requests\n\n`{\"error\": \"too_many_requests\", \"error_description\": \"...\"}`\n\n500 Internal Server Error\n\n501 Not Implemented\n\n`{\"error\": \"unsupported_response_type\", \"error_description\": \"...\"}`\n\n501 Not Implemented\n\n`{\"error\": \"unsupported_grant_type\", \"error_description\": \"...\"}`\n\n503 Service Unavailable\n\n`{\"error\": \"temporarily_unavailable\", \"error_description\": \"...\"}`\n\n## POST /oauth/revoke\n\nStatus\n\nJSON Response\n\n200 Success\n\n`{\"error\": \"invalid_request\", \"error_description\": \"...\"}`  \nThe Refresh Token is revoked, does not exist, or was not issued to the client making the revocation request\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"...\"}` The required parameters were not sent in the request.\n\n401 Unauthorized\n\n`{\"error\": \"invalid_client\", \"error_description\": \"...\"}`  \nThe request is not authorized. Check that the client credentials `client_id` and client\\_secret\\` are present in the request and hold valid values.\n\n## POST /oauth/access\\_token\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was disabled\"}`  \nThe connection is not active or not enabled for your `client_id`.\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was not found\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing client_id parameter\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing access_token parameter\"}`\n\n401 Unauthorized\n\n`{\"error\": \"invalid_request\", \"error_description\": \"invalid access_token: invalid_token\"}`  \nThe `access_token` is invalid or does not contain the set `scope`\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\", \"error_description\": \"invalid client\"}`\n\n## POST /oauth/ro\n\n## Grant type: jwt-bearer\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing device parameter\"}`  \nYou need to provide a device name for the caller device (like a browser, app, and so on)\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing id_token parameter\"}`  \nFor this grant type you need to provide a JWT ID Token\n\n400 Bad Request\n\n`{\"error\": \"invalid_grant\", \"error_description\": \"...\"}`  \nErrors related to an invalid ID Token or user\n\n## Grant type: password\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"scope parameter must be a string\"}`  \nIncorrect scope formatting; each scope must be separated by whitespace\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"specified strategy does not support requested operation\"}`  \nThe connection/provider does not implement username/password authentication\n\n401 Unauthorized\n\n`{\"error\": \"invalid_user_password\", \"error_description\": \"Wrong email or password.\"}`\n\n401 Unauthorized\n\n`{\"error\": \"unauthorized\", \"error_description\": \"user is blocked\"}`\n\n401 Unauthorized\n\n`{ \"error\": \"password_leaked\", \"error_description\": \"This login has been blocked because your password has been leaked in another website. We’ve sent you an email with instructions on how to unblock it.\"}`\n\n401 Unauthorized\n\n`{ \"error\": \"requires_verification\", \"error_description\": \"Suspicious request requires verification\" }`\n\n429 Too Many Requests\n\n`{\"error\": \"too_many_attempts\", \"error_description\": \"...\"}`  \nSome attack protection features will return this error\n\n429 Too Many Requests\n\n`{\"error\": \"too_many_logins\", \"error_description\": \"...\"}`  \nSome attack protection features will return this error\n\n## All grant types\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing client_id parameter\"}<`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was disabled\"}`  \nCheck the connection in the dashboard, you may have turned it off for the provided `client_id`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"The connection is not yet configured...\"}`  \nThe connection is not properly configured with custom scripts\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was not found for tenant...\"}`  \nThe connection does not belong to the tenant; check your base url\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"Fields with \".\" are not allowed, please remove all dotted fields...\"}`  \nIf you are using rules, some field name contains dots\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\", \"error_description\": \"invalid client\"}`  \nThe provided `client_id` is not valid\n\n403 Forbidden\n\n`{\"error\": \"access_denied\", \"error_description\": \"...\"}`  \nValidation of specific points raised an access issue\n\n## POST /passwordless/start\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"bad.tenant\",\"error_description\": \"error in tenant - tenant validation failed: invalid_tenant\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.client_id\", \"error_description\": \"Missing required property: client_id\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\", \"error_description\": \"Missing required property: connection\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\", \"error_description\": \"Connection does not exist\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\", \"error_description\": \"Connection is disabled\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\", \"error_description\": \"Invalid connection strategy. It must either be a passwordless connection\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.authParams\", \"error_description\": \"error in authParams - invalid type: string (expected object)\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.request\", \"error_description\": \"the following properties are not allowed: <INVALID_PARAMETER_VALUE>\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.phone_number\", \"error_description\": \"Missing required property: phone_number\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.phone_number\", \"error_description\": \"String does not match pattern: ^\\\\+[0-9]{1,15}$\"}`\n\n400 Bad Request\n\n`{\"error\": \"sms_provider_error\", \"error_description\": \"<SPECIFIC_PROVIDER_MESSAGE> (Code: <SPECIFIC_PROVIDER_CODE>)\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\",\"error_description\": \"Expected` auth0-forwarded-for `header to be a valid IP address.\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.tenant\",\"error_description\": \"error in tenant - could not find tenant in params\"}`\n\n400 Bad Request\n\n`{\"error\": \"server_error\",\"error_description\": \"error resolving client\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\",\"error_description\": \"The client_id in the authentication header does not match the client_id in the payload\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"Public signup is disabled\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"Unknown error\"}`\n\n401 Unauthorized\n\n`{\"error\": \"server_error\",\"error_description\": \"user is blocked\"}`\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\",\"error_description\": \"Client authentication is required\"}`\n\n500 Internal Server Error\n\n`{\"error\": \"server_error\",\"error_description\": \"IdP Error\"}`\n\n## POST /passwordless/verify\n\nStatus\n\nJSON Response\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing username parameter\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"scope parameter must be a string\"}`  \nIncorrect scope formatting; each scope must be separated by whitespace\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"missing client_id parameter\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was not found\"}`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was disabled\"}`  \nCheck the connection in the dashboard, you may have turned it off for the provided `client_id`\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"the connection was not found for tenant...\"}`  \nThe connection does not belong to the tenant; check your base url\n\n400 Bad Request\n\n`{\"error\": \"invalid_request\", \"error_description\": \"Fields with \".\" are not allowed, please remove all dotted fields...\"}`  \nIf you are using rules, some field name contains dots\n\n400 Bad Request\n\n`\"error\": \"bad.tenant\",\"error_description\": \"error in tenant - could not find tenant in params\"`\n\n400 Bad Request\n\n`{\"error\": \"bad.tenant\",\"error_description\": \"error in tenant - tenant validation failed: \"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"Connection does not exist\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"Invalid connection strategy. It must either be a passwordless connection\"}`\n\n400 Bad Request\n\n`{\"error\": \"bad.connection\",\"error_description\": \"The connection is disabled\"}`\n\n401 Unauthorized\n\n`{\"error\": \"invalid_user_password\", \"error_description\": \"Wrong email or password.\"}`\n\n401 Unauthorized\n\n`{\"error\": \"unauthorized\", \"error_description\": \"user is blocked\"}`\n\n403 Forbidden\n\n`{\"error\": \"unauthorized_client\", \"error_description\": \"invalid client\"}`  \nThe provided `client_id` is not valid\n\n403 Forbidden\n\n`{\"error\": \"access_denied\", \"error_description\": \"...\"}`  \nValidation of specific points raised an access issue\n\n429 Too Many Requests\n\n`{\"error\": \"too_many_attempts\", \"error_description\": \"...\"}`  \nSome attack protection features will return this error\n\n500 Bad Request\n\n`{\"error\": \"server_error\",\"error_description\": \"...\"}`",
  "title": "Authentication API Explorer",
  "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/react/interactive",
  "markdown": "# Add Login to your React App\n\n## Add Login to Your React Application\n\nAuth0 allows you to add authentication to almost any application type quickly. This guide demonstrates how to integrate Auth0, add authentication, and display user profile information in any React application using the Auth0 React SDK.\n\nTo use this quickstart, you’ll need to:\n\n*   Sign up for a free Auth0 account or log in to Auth0.\n*   Have a working React project that you want to integrate with. Alternatively, you can view or download a sample application after logging in.\n\nTo use Auth0 services, you’ll need to have an application set up in the Auth0 Dashboard. The Auth0 application is where you will configure how you want authentication to work for the project you are developing.\n\n### Configure an application\n\nUse the interactive selector to create a new Auth0 application or select an existing application that represents the project you want to integrate with. Every application in Auth0 is assigned an alphanumeric, unique client ID that your application code will use to call Auth0 APIs through the SDK.\n\nAny settings you configure using this quickstart will automatically update for your Application in the [Dashboard](https://manage.auth0.com/#/), which is where you can manage your Applications in the future.\n\nIf you would rather explore a complete configuration, you can view a sample application instead.\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application that you would like Auth0 to redirect users to after they have authenticated. If not set, users will not be returned to your application after they log in.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that you would like Auth0 to redirect users to after they have logged out. If not set, users will not be able to log out from your application and will receive an error.\n\n### Configure Allowed Web Origins\n\nAn Allowed Web Origin is a URL that you want to be allowed to access to your authentication flow. This must contain the URL of your project. If not properly set, your project will be unable to silently refresh authentication tokens, so your users will be logged out the next time they visit your application or refresh a page.\n\nAuth0 provides a [React SDK](https://github.com/auth0/auth0-react) (auth0-react.js) to simplify the process of implementing Auth0 authentication and authorization in React apps.\n\nInstall the Auth0 React SDK by running the following commands in your terminal:\n\n```\ncd <your-project-directory>\nnpm install @auth0/auth0-react\n```\n\n### Configure the Auth0Provider component\n\nFor the SDK to function properly, you must set the following properties in the Auth0Provider component:\n\n*   `domain`: The domain of your Auth0 tenant. Generally, you can find this in the Auth0 Dashboard under your Application's Settings in the Domain field. If you are using a [custom domain](https://auth0.com/docs/custom-domains), you should set this to the value of your custom domain instead.\n*   `clientId`: The ID of the Auth0 Application you set up earlier in this quickstart. You can find this in the Auth0 Dashboard under your Application's Settings in the Client ID field.\n*   `authorizationParams.redirect_uri`: The URL in your application that you would like Auth0 to redirect users to after they have authenticated. This corresponds to the callback URL you set up earlier in this quickstart. You can also find this value in the Auth0 Dashboard under your Application's Settings in the Callback URLs field. Make sure what you enter in your code matches what you set up earlier or your users will see an error.\n\n##### Checkpoint\n\nYour Auth0Provider component should now be properly configured. Run your application to verify that:\n\n*   the SDK is initializing correctly\n*   your application is not throwing any errors related to Auth0\n\nNow that you have configured your Auth0 Application and the Auth0 React SDK, you need to set up login for your project. To do this, you will use the SDK’s loginWithRedirect() method to create a login button that redirects users to the Auth0 Universal Login page. After a user successfully authenticates, they will be redirected to the callback URL you set up earlier in this quickstart.\n\nCreate a new file in your application called `login.js` for the login button component, and copy in the code from the interactive panel to the right, which contains the logic needed for login. Then, update your `index.js` file to include the new login button.\n\n##### Checkpoint\n\nYou should now be able to log in or sign up using a username and password.\n\nClick the login button and verify that:\n\n*   your React Application redirects you to the Auth0 Universal Login page\n*   you can log in or sign up\n*   Auth0 redirects you to your application using the value of the `authorizationParams.redirect_uri` you used to configure the `Auth0Provider`\n\nUsers who log in to your project will also need a way to log out. Create a logout button using the SDK’s logout() method. When users log out, they will be redirected to your [Auth0 logout](https://auth0.com/docs/api/authentication?javascript#logout) endpoint, which will then immediately redirect them to the logout URL you set up earlier in this quickstart.\n\nCreate a new file in your application called `logout.js` for the logout button component, and copy in the code from the interactive panel, which contains the logic needed for logout. Then, update your `index.js` file to include the logout button.\n\n##### Checkpoint\n\nRun your application and click the logout button, verify that:\n\n*   your React application redirects you to the address you specified as one of the Allowed Logout URLs in your Application Settings\n*   you are no longer logged in to your application\n\nNow that your users can log in and log out, you will likely want to be able to retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with authenticated users. For example, you may want to be able to display a logged-in user’s name or profile picture in your project.\n\nThe Auth0 React SDK provides user information through the `user` property. Review the `profile.js` code in the interactive panel to see an example of how to use it.\n\nBecause the `user` property contains sensitive information related to the user's identity, its availability depends on the user's authentication status. To prevent render errors, you should always:\n\n*   use the `isAuthenticated` property to determine whether Auth0 has authenticated the user before React renders any component that consumes the `user` property.\n*   ensure that the SDK has finished loading by checking that `isLoading` is false before accessing the `isAuthenticated` property.\n\n##### Checkpoint\n\nVerify that:\n\n*   you can display the `user.name` or any other user property within a component correctly after you have logged in\n\n## Next Steps\n\nExcellent work! If you made it this far, you should now have login, logout, and user profile information running in your application.\n\nThis concludes our quickstart tutorial, but there is so much more to explore. To learn more about what you can do with Auth0, check out:\n\n*   [Auth0 Dashboard](https://manage.auth0.com/#) \\- Learn how to configure and manage your Auth0 tenant and applications\n*   [auth0-react SDK](https://www.github.com/auth0/auth0-react/) \\- Explore the SDK used in this tutorial more fully\n*   [Auth0 Marketplace](https://marketplace.auth0.com/) \\- Discover integrations you can enable to extend Auth0’s functionality",
  "title": "Auth0 React SDK Quickstarts: Add Login to your React App",
  "description": "Auth0 allows you to add authentication to your React application quickly and to gain access to user profile information. This guide demonstrates how to integrate Auth0 with any new or existing React application using the Auth0 React SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock",
  "markdown": "# Lock for Web\n\nLock is an embeddable login form that can be [configured to your needs](https://auth0.com/docs/libraries/lock/v11/configuration) and is recommended for use in single-page apps, preferably in conjunction with [Universal Login](https://auth0.com/docs/universal-login), which should be used whenever possible. Lock enables you to easily add social identity providers, so that your users can log in seamlessly using any desired provider.\n\n## Lock Installation\n\nYou can install Lock via several methods. Select any of the following installation sources that best suit your environment and application.\n\n### Installation Sources\n\nInstall via [npm](https://npmjs.org/): `npm install auth0-lock`\n\nInstall via [bower](http://bower.io/):\n\n`bower install auth0-lock`\n\nInclude via our CDN (Replace `.x` and `.y` with the latest minor and patch release numbers from the [Lock Github repository](https://github.com/auth0/lock/releases):\n\nLatest Minor Release: `<script src=\"https://cdn.auth0.com/js/lock/11.x/lock.min.js\"></script>` Latest Patch Release: `<script src=\"https://cdn.auth0.com/js/lock/11.x.y/lock.min.js\"></script>`\n\nIt is recommended that production applications use a specific patch version, or at the very least a specific minor version. Regardless of the method by which Lock is included, the recommendation is that the version should be locked down and only manually updated, to ensure that those updates do not adversely affect your implementation. Check the [GitHub repository](https://github.com/auth0/lock/releases) for a current list of releases.\n\n### Mobile\n\nIf you are targeting mobile audiences, Auth0 recommends that you add the following meta tag to your application's `head`:\n\n`<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>`\n\n### Bundling Dependencies\n\nIf you are using browserify or webpack to build your project and bundle its dependencies, after installing the `auth0-lock` module, you will need to bundle it with all its dependencies. Examples are available for [Browserify](https://github.com/auth0/lock/tree/master/examples/bundling/browserify) and [webpack](https://github.com/auth0/lock/tree/master/examples/bundling/webpack).\n\n### Cross-Origin Authentication\n\nEmbedding Lock within your application requires [cross-origin authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication) to be properly configured. Specifically, you need to set the **Allowed Web Origins** property to the domain making the request. You can find this field in the [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\nMake sure you read about the limitations of cross-origin authentication before implementing embedded login with Lock.\n\n## Usage\n\n### 1\\. Initializing Lock\n\nFirst, you'll need to initialize a new `Auth0Lock` object, and provide it with your Auth0 client ID (the unique client ID for each Auth0 application, which you can get from the [management dashboard](https://manage.auth0.com/#)) and your Auth0 domain (for example `yourname.auth0.com`).\n\nto configure this snippet with your account\n\n```\n// Initializing our Auth0Lock\nvar lock = new Auth0Lock(\n  '{yourClientId}',\n  '{yourDomain}'\n);\n```\n\n### 2\\. Authenticating and Getting User Info\n\nNext, listen using the `on` method for the `authenticated` event. When the event occurs, use the `accessToken` which was received to call the `getUserInfo` method and acquire the user's profile information (as needed).\n\nto configure this snippet with your account\n\n```\nvar Auth = (function() {\n\n  var wm = new WeakMap();\n  var privateStore = {};\n  var lock;\n\n  function Auth() {\n    this.lock = new Auth0Lock(\n      '<{yourClientId}>',\n      '<{yourDomain}>'\n    );\n    wm.set(privateStore, {\n      appName: \"example\"\n    });\n  }\n\n  Auth.prototype.getProfile = function() {\n    return wm.get(privateStore).profile;\n  };\n\n  Auth.prototype.authn = function() {\n    // Listening for the authenticated event\n    this.lock.on(\"authenticated\", function(authResult) {\n      // Use the token in authResult to getUserInfo() and save it if necessary\n      this.getUserInfo(authResult.accessToken, function(error, profile) {\n        if (error) {\n          // Handle error\n          return;\n        }\n\n        //we recommend not storing Access Tokens unless absolutely necessary\n        wm.set(privateStore, {\n          accessToken: authResult.accessToken\n        });\n\n        wm.set(privateStore, {\n          profile: profile\n        });\n\n      });\n    });\n  };\n  return Auth;\n}());\n```\n\nYou can then manipulate page content and display profile information to the user (for example, displaying their name in a welcome message).\n\n`<h2>Welcome <span id=\"nick\" class=\"nickname\"></span></h2>`\n\nNote that if you are storing the user profile, you will want to `JSON.stringify` the profile object and then, when using it later, `JSON.parse` it, because it will need to be stored in `localStorage` as a string rather than a JSON object.\n\n### 3\\. Showing Lock\n\nHere you're showing the Lock widget after the user clicks a login button; you can just as easily show Lock automatically when arriving at a page by just using `lock.show();` on page load.\n\nThis will show the Lock widget, and paired with the above, you're now ready to handle logins!\n\n```\ndocument.getElementById('btn-login').addEventListener('click', function() {\n  lock.show();\n});\n```\n\n## Passwordless\n\nLock's Passwordless Mode is only available in Lock v11.2.0 and later. Please use the [latest release of Lock](https://github.com/auth0/lock/releases) for this feature!\n\nYou can use Lock's Passwordless Mode to allow users to authenticate using just an email or mobile number. They will receive the code and then return to input it, or click the link, and they can be authenticated without remembering a password.\n\nIn Lock, in order to implement Passwordless Mode, you initialize Lock in a slightly different manner, with `Auth0LockPasswordless` rather than with `Auth0Lock`:\n\nto configure this snippet with your account\n\n```\nvar lockPasswordless = new Auth0LockPasswordless(\n '{yourClientId}',\n '{yourDomain}'\n);\n```\n\n### Passwordless options\n\nAdditionally, Lock's Passwordless Mode has a couple of configuration options that are unique to it.\n\nIn order to indicate which connection type you would like, you initialize Lock with the `allowedConnections` option with either `email` or `sms` as the value:\n\n```\nvar passwordlessOptions = {\n  allowedConnections: ['sms']\n}\n```\n\nRemember to enable the passwordless connection of your choice in the [Dashboard](https://manage.auth0.com/#) under **Connections -> Passwordless**, and then to enable it for your application, that way when Lock tries to use it, it is already set up and linked to the application.\n\nIf you choose to use `email`, you have one more option to select - whether you wish your users to receive a code to input, or a \"magic link\" to use. This is done via the `passwordlessMethod` option, which takes values of `code` or `link`.\n\n```\nvar passwordlessOptions = {\n  allowedConnections: ['email'],\n  passwordlessMethod: 'code'\n}\n```\n\n### Passwordless example\n\nto configure this snippet with your account\n\n```\nvar passwordlessOptions = {\n  allowedConnections: ['email'],\n  passwordlessMethod: 'code',\n  auth: {\n    redirectUrl: 'http://localhost:3000/callback',   \n    responseType: 'token id_token',\n    params: {\n      scope: 'openid email'               \n    }          \n  }\n}\n\nvar lockPasswordless = new Auth0LockPasswordless(\n '{yourClientId}',\n '{yourDomain}',\n passwordlessOptions\n);\n```\n\n### Single Sign-On with embedded authentication\n\nApps with embedded login must meet two criteria in order to have Single Sign-on (SSO).\n\n1.  Both of the applications attempting SSO must be first-party applications. SSO with third-party applications will not work.\n    \n2.  They need to make use of custom domains and have both the applications which intend to have SSO as well as the Auth0 tenant on the same domain. Traditionally, Auth0 domains are in the format `foo.auth0.com`, but custom domains allow you to use the same domain for each of the applications in question as well as your Auth0 tenant, preventing the risk of CSRF attacks.\n    \n\nOur recommendation is to use Universal Login instead of setting up SSO in embedded login scenarios. Universal Login is the most reliable and stable way to perform SSO, and is the only way to do so if you must use multiple domains for your applications, or use [third-party applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications).\n\n## Error Codes and Descriptions\n\nWhen Lock is used for embedded login, it employs the `/co/authenticate` endpoint, which has the following errors.\n\nThe error description is human readable. It **should not be parsed by any code** and it subject to change at any time.\n\n| **Status** | **Code** | **Description** |\n| --- | --- | --- |\n| 400 | invalid\\_request | Invalid request body. All and only of client\\_id, credential\\_type, username, otp, realm are required. |\n| 401 | unauthorized\\_client | Cross origin login not allowed. |\n| 400 | unsupported\\_credential\\_type | Unknown credential type parameter. |\n| 400 | invalid\\_request | Unknown realm non-existent-connection. |\n| 403 | access\\_denied | Wrong email or password. |\n| 403 | access\\_denied | Authentication error |\n| 403 | blocked\\_user | Blocked user |\n| 401 | password\\_leaked | This login attempt has been blocked because the password you're using was previously disclosed through a data breach (not in this application). |\n| 429 | too\\_many\\_attempts | Your account has been blocked after multiple consecutive login attempts. We've sent you a notification via your preferred contact method with instructions on how to unblock it. |\n| 429 | too\\_many\\_attempts | We have detected suspicious login behavior and further attempts will be blocked. Please contact the administrator. |\n\n## Browser Compatibility\n\nBrowser compatibility is ensured for **Chrome**, **Safari**, **Firefox** and **IE >= 10**. Auth0 currently uses [zuul](https://github.com/defunctzombie/zuul) along with [Saucelabs](https://saucelabs.com/) to run integration tests on each push.\n\n## Learn more\n\n*   [Lock API Reference](https://auth0.com/docs/libraries/lock/lock-api-reference)\n*   [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration)",
  "title": "Lock for Web",
  "description": "A widget that provides a frictionless login and signup experience for your web apps.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens",
  "markdown": "# Tokens\n\nThere are two types of tokens that are related to identity: ID tokens and access tokens.\n\n## ID tokens\n\n[ID tokens](https://auth0.com/docs/secure/tokens/id-tokens) are [JSON web tokens (JWTs)](https://auth0.com/docs/secure/tokens/json-web-tokens) meant for use by the application only. For example, if there's an app that uses Google to log in users and to sync their calendars, Google sends an ID token to the app that includes information about the user. The app then parses the [token's contents](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) and uses the information (including details like name and profile picture) to customize the user experience.\n\nDo **not** use ID tokens to gain access to an API. Each token contains information for the intended audience (which is usually the recipient). According to the OpenID Connect specification, the audience of the ID token (indicated by the **aud** claim) must be the client ID of the application making the authentication request. If this is not the case, you should not trust the token.\n\nThe decoded contents of an ID token looks like the following:\n\n```\n{\n  \"iss\": \"http://{yourDomain}/\",\n  \"sub\": \"auth0|123456\",\n  \"aud\": \"{yourClientId}\",\n  \"exp\": 1311281970,\n  \"iat\": 1311280970,\n  \"name\": \"Jane Doe\",\n  \"given_name\": \"Jane\",\n  \"family_name\": \"Doe\",\n  \"gender\": \"female\",\n  \"birthdate\": \"0000-10-31\",\n  \"email\": \"janedoe@example.com\",\n  \"picture\": \"http://example.com/janedoe/me.jpg\"\n}\n```\n\nThis token authenticates the user to the application. The audience (the **aud** claim) of the token is set to the application's identifier, which means that only this specific application should consume this token.\n\nConversely, an API expects a token with the **aud** value to equal the API's unique identifier. Therefore, unless you maintain control over both the application and the API, sending an ID token to an API will generally not work. Since the ID token is not signed by the API, the API would have no way of knowing if the application had modified the token (e.g., adding more scopes) if it were to accept the ID Token. See the [JWT Handbook](https://auth0.com/resources/ebooks/jwt-handbook) for more information.\n\n## Access tokens\n\n[Access tokens](https://auth0.com/docs/secure/tokens/access-tokens) (which aren't always JWTs) are used to inform an API that the bearer of the token has been authorized to access the API and perform a predetermined set of actions (specified by the **scopes** granted).\n\nIn the Google example above, Google sends an access token to the app after the user logs in and provides consent for the app to read or write to their Google Calendar. Whenever the app wants to write to Google Calendar, it sends a request to the Google Calendar API, including the access token in the HTTP **Authorization** header.\n\nAccess tokens must **never** be used for [authentication](https://auth0.com/docs/authenticate). Access tokens cannot tell if the user has authenticated. The only user information the access token possesses is the user ID, located in the **sub** claim. In your applications, treat access tokens as opaque strings since they are meant for APIs. Your application should not attempt to decode them or expect to receive tokens in a particular format.\n\nHere is an example of an access token:\n\n```\n{\n  \"iss\": \"https://{yourDomain}/\",\n  \"sub\": \"auth0|123456\",\n  \"aud\": [\n    \"my-api-identifier\",\n    \"https://{yourDomain}/userinfo\"\n  ],\n  \"azp\": \"{yourClientId}\",\n  \"exp\": 1489179954,\n  \"iat\": 1489143954,\n  \"scope\": \"openid profile email address phone read:appointments\"\n}\n```\n\nNote that the token does not contain any information about the user besides their ID (**sub** claim). It only contains authorization information about which actions the application is allowed to perform at the API (**scope** claim). This is what makes it useful for securing an API, but not for authenticating a user.\n\nIn some situations, it may be desirable to put additional information about the user or other custom claims, besides their sub claim, in the access token to save the API from having to do extra work to fetch details about the user. If you choose to do this, bear in mind that these extra claims will be readable in the access token. To learn more, read [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\n## Specialized tokens\n\nThere are three specialized tokens used in Auth0's token-based authentication scenarios:\n\n*   **Refresh tokens**: A token used to obtain a renewed access token without having to re-authenticate the user.\n    \n*   **IDP access tokens**: Access tokens issued by identity providers after user authentication that you can use to call the third-party APIs.\n    \n*   **Auth0 Management API access tokens**: Short-lived tokens containing specific claims (scopes) that allow you to call Management API endpoints.\n    \n\n## Learn more\n\n*   [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens)\n*   [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens)\n*   [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens)\n*   [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens)\n*   [Token Storage](https://auth0.com/docs/secure/security-guidance/data-security/token-storage)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Tokens",
  "description": "Describes the types of tokens related to identity and authentication and how they are used by Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/refresh-tokens",
  "markdown": "# Refresh Tokens\n\nAuth0 issues an access token or an ID token in response to an authentication request. You can use access tokens to make authenticated calls to a secured API, while the ID token contains user profile attributes represented in the form of claims. Both are JSON web tokens (JWTs) and therefore have expiration dates indicated using the `exp` claim, as well as security measures, like signatures. Typically, a user needs a new access token when gaining access to a resource for the first time, or after the previous access token granted to them expires.\n\nAn OAuth Refresh Token is a credential artifact that OAuth can use to get a new access token without user interaction. This allows the Authorization Server to shorten the access token lifetime for security purposes without involving the user when the access token expires. You can request new access tokens until the refresh token is on the DenyList.\n\nIt is important to keep the number of refresh tokens within a reasonable manageable limit to make sure that it’s easy to maintain those credentials safely and securely. Applications must store refresh tokens securely because they essentially allow a user to remain authenticated forever.\n\n#### Offline access\n\nIf you want to allow users to get refresh tokens while offline, you can select the **Allow Offline Access** switch in [API Settings](https://auth0.com/docs/get-started/apis/api-settings).\n\nYou can increase security by using [refresh token rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation) which issues a new refresh token and invalidates the predecessor token with each request made to Auth0 for a new access token. Rotating the refresh token reduces the risk of a compromised refresh token.\n\n### Limitations\n\nAuth0 limits the amount of active refresh tokens to 200 tokens per user per application. This limit only applies to active tokens. If the limit is reached and a new refresh token is created, the system revokes and deletes the oldest token for that user and application. Revoked tokens and expired tokens do not count against the limit. To review our recommendations and best practices to avoid excess tokens, read [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices).\n\n### Enable OIDC Flag\n\nThe refresh token behavior is applicable to OIDC-conformant applications. You can configure an application to be OIDC-conformant in one of the following ways:\n\n1.  Enabling the **OIDC Conformant** flag for an app.\n    \n2.  Passing an `audience` claim to the `/authorize` endpoint of the Authentication API.\n    \n\n## SDK support\n\n### For web apps\n\nAuth0 SDKs support refresh tokens including:\n\n*   Node.js\n    \n*   ASP.NET Core\n    \n*   PHP\n    \n*   Java\n    \n\nFor a complete listing, see [Quickstarts](https://auth0.com/docs/quickstart/webapp).\n\n### For single-page apps\n\nProviding secure authentication in SPAs has a number of challenges based on your application’s use case. New browser privacy controls like Intelligent Tracking Prevention (ITP) adversely impact the user experience in SPAs by preventing access to third-party cookies.\n\nAuth0 recommends using refresh token rotation which provides a secure method for using refresh tokens in SPAs while providing end-users with seamless access to resources without the disruption in UX caused by browser privacy technology like ITP.\n\n### For native/mobile apps\n\nFor native applications, refresh tokens improve the authentication experience significantly. The user has to authenticate only once, through the web authentication process. Subsequent re-authentication can take place without user interaction, using the refresh token.\n\nFor information on using refresh tokens with our mobile SDKs, see:\n\n*   [Mobile/Native Quickstarts](https://auth0.com/docs/quickstart/native)\n    \n*   [Lock Android: Refresh JWT Tokens](https://auth0.com/docs/libraries/lock-android/lock-android-refresh-jwt)\n    \n*   [Lock iOS: Save and Renew JWT Tokens](https://auth0.com/docs/libraries/auth0-swift/auth0-swift-save-and-renew-tokens)\n    \n\n## Learn more\n\n*   [Get Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/get-refresh-tokens)\n*   [Use Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-tokens)\n*   [Revoke Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens)\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Refresh Tokens",
  "description": "Describes how refresh tokens work to allow the application to ask Auth0 to issue a new access token or ID token without having to re-authenticate the user.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/access-tokens",
  "markdown": "# Access Tokens\n\nAccess tokens are used in token-based authentication to allow an application to access an API. The application receives an access token after a user successfully authenticates and authorizes access, then passes the access token as a credential when it calls the target API. The passed token informs the API that the bearer of the token has been authorized to access the API and perform specific actions specified by the Scope that was granted during authorization.\n\nIn addition, if you have chosen to allow users to log in through an Identity Provider (IdP), such as Facebook, the IdP will issue its own access token to allow your application to call the IDP's API. For example, if your user authenticates using Facebook, the access token issued by Facebook can be used to call the Facebook Graph API. These tokens are controlled by the IdP and can be issued in any format. See [Identity Provider Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/identity-provider-access-tokens) for details.\n\n## Opaque access tokens\n\nOpaque access tokens are tokens in a proprietary format that you cannot access and typically contain some identifier to information in a server's persistent storage. To validate an opaque token, the recipient of the token needs to call the server that issued the token.\n\nIn Auth0's case, opaque tokens can be used with the `/userinfo` endpoint to return a user's profile. If you receive an opaque Access Token, you don't need to validate it. You can use it with the `/userinfo` endpoint, and Auth0 takes care of the rest. To learn more, see [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens).\n\n## JWT access tokens\n\nJSON Web Token (JWT) access tokens conform to the [JWT standard](https://tools.ietf.org/html/rfc7519) and contain information about an entity in the form of claims. They are self-contained therefore it is not necessary for the recipient to call a server to validate the token.\n\nAccess tokens issued for the Management API and access tokens issued for any custom API that you have registered with Auth0 follow the JWT standard, which means that their basic structure conforms to the typical [JWT structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure), and they contain standard [JWT claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims) asserted about the token itself.\n\n### Management API access tokens\n\nAn access token issued for the Auth0 Management API should be treated as opaque (regardless of whether it actually is), so you don't need to validate it. You can use it with the Auth0 Management API, and Auth0 takes care of the rest. To learn more, see [Auth0 Management API Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens).\n\n### Custom API access tokens\n\nIf validation of your custom API access token fails, make sure it was issued with your custom API as the `audience`. To learn more, see [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens).\n\n## Sample access token\n\nThis example shows the contents of an access token. Notice that the token only contains authorization information about the actions the application is allowed to perform at the API (such permissions are referred to as `scopes`).\n\n```\n{\n  \"iss\": \"https://my-domain.auth0.com/\",\n  \"sub\": \"auth0|123456\",\n  \"aud\": [\n    \"https://example.com/health-api\",\n    \"https://my-domain.auth0.com/userinfo\"\n  ],\n  \"azp\": \"my_client_id\",\n  \"exp\": 1311281970,\n  \"iat\": 1311280970,\n  \"scope\": \"openid profile read:patients read:admin\"\n}\n```\n\nThe token does not contain any information about the user except for the user ID (located in the `sub` claim). In many cases, you may find it useful to retrieve additional user information. You can do this by calling the [userinfo API endpoint](https://auth0.com/docs/api/authentication#get-user-info) with the Access Token. Be sure that the API for which the Access Token is issued uses the **RS256** [signing algorithm](https://auth0.com/docs/get-started/applications/signing-algorithms).\n\n## Access token security\n\nYou should follow [token best practices](https://auth0.com/docs/secure/tokens/token-best-practices) when using access tokens, and for JWTs, make sure that you [validate an access token](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens) before assuming that its contents can be trusted.\n\n## Access token lifetime\n\n### Custom API token lifetime\n\nBy default, an access token for a custom API is valid for 86400 seconds (24 hours). We recommend that you set the validity period of your token based on the security requirements of your API. For example, an access token that accesses a banking API should expire more quickly than one that accesses a to-do API. To learn more, see [Update Access Token Lifetime](https://auth0.com/docs/secure/tokens/access-tokens/update-access-token-lifetime).\n\n### /userinfo endpoint token lifetime\n\nAccess tokens issued strictly for the purpose of accessing the OIDC `/userinfo` endpoint have a default lifetime and can't be changed. The length of lifetime depends on the flow used to obtain the token:\n\n| Flow | Lifetime |\n| --- | --- |\n| Implicit | 7200 seconds (2 hours) |\n| Authorization Code/Hybrid | 86400 seconds (24 hours) |\n\n## Learn more\n\n*   [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens)\n*   [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens)\n*   [Use Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/use-access-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Access Tokens",
  "description": "Describes how access tokens are used in token-based authentication to allow an application to access an API after a user successfully authenticates and authorizes access.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts",
  "markdown": "# Link User Accounts\n\nLink user accounts together to form a primary and secondary relationship. On successful linking, the endpoint returns the new array of the primary account identities.\n\nAuth0 supports the linking of user accounts from various identity providers. This allows a user to authenticate from any of their accounts and still be recognized by your app and associated with the same user profile.\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nAuth0 treats all identities as separate by default. For example, if a user logs in first against the Auth0 database and then via Google or Facebook, these two attempts would appear to Auth0 as two separate users.\n\nThere are three ways to link accounts:\n\n*   Use the Account Link extension\n    \n*   Use the Management API\n    \n*   Use Auth0.js\n    \n\nUse the tabs below to see the details for each option.\n\n*   [Account Link Extension](#extension)\n*   [Management API](#mgmt-api)\n*   [Auth0 js](#auth0js)\n\n## Account Link extension\n\nInstall and configure the [Account Link Extension](https://auth0.com/docs/extensions/account-link) extension in the Dashboard to prompt users that may have created a second account to link the new account with their old one on their first login. The user can choose to either link the two accounts or keep them separate if it was intentional.\n\n## Management API endpoint\n\nThe Auth0 Management API provides the [Link a user account](https://auth0.com/docs/api/v2#!/Users/post_identities) endpoint, which can be invoked in two ways:\n\n*   User initiated account linking using Access Tokens with the `update:current_user_identities` scope\n*   Server-side account linking using Access Token that contains the `update:users` scope\n\n### User initiated client-side account linking\n\nFor user initiated account linking from client-side code, use an Access Token that contains the following items in the payload:\n\n*   `update:current_user_identites` scope\n*   `user_id` of the primary account as part of the URL\n*   ID Token of the secondary account must be signed with `RS256` and an `aud` claim identifying the client that matches the value of the requesting Access Token's `azp` claim.\n\nAn Access Token that contains the `update:current_user_identities` scope can **only** be used to update the information of the currently logged-in user. Therefore, this method is suitable for scenarios where the user initiates the linking process.\n\n```\n{\n  \"method\": \"POST\",\n  \"url\": \"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\",\n  \"httpVersion\": \"HTTP/1.1\",\n  \"headers\": [{\n    \"name\": \"Authorization\",\n    \"value\": \"Bearer ACCESS_TOKEN\"\n  },\n  {\n    \"name\": \"content-type\",\n    \"value\": \"application/json\"\n  }],\n  \"postData\" : {\n    \"mimeType\": \"application/json\",\n    \"text\": \"{\\\"link_with\\\":\\\"SECONDARY_ACCOUNT_ID_TOKEN\\\"}\"\n  }\n}\n```\n\n### Server-side account linking\n\nFor server-side account linking, use an Access Token that contains the following items in the payload:\n\n*   `update:users` scope\n*   `user_id` of the primary account as part of the URL\n*   `user_id` of the secondary account\n*   ID Token of the secondary account must be signed with `RS256` and an `aud` claim identifying the client that matches the value of the requesting Access Token's `azp` claim.\n\nAccess Tokens that contain the `update:users` scope can be used to update the information of **any** user. Therefore, this method is intended for use in server-side code only.\n\n```\n{\n  \"method\": \"POST\",\n  \"url\": \"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\",\n  \"httpVersion\": \"HTTP/1.1\",\n  \"headers\": [{\n    \"name\": \"Authorization\",\n    \"value\": \"Bearer ACCESS_TOKEN\"\n  },\n  {\n    \"name\": \"content-type\",\n    \"value\": \"application/json\"\n  }],\n  \"postData\" : {\n    \"mimeType\": \"application/json\",\n    \"text\": \"{\\\"provider\\\":\\\"SECONDARY_ACCOUNT_PROVIDER\\\", \\\"user_id\\\": \\\"SECONDARY_ACCOUNT_USER_ID\\\"}\"\n  }\n}\n```\n\nThe `SECONDARY_ACCOUNT_USER_ID` and `SECONDARY_ACCOUNT_PROVIDER` can be deduced by the unique ID of the user. For example, if the user ID is `google-oauth2|108091299999329986433`, set the `google-oauth2` part as the `provider`, and the `108091299999329986433` part as the `user_id` at your request.\n\nInstead of the `provider` and `user_id`, you can send the secondary account's ID Token as part of the payload:\n\n```\n{\n  \"method\": \"POST\",\n  \"url\": \"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\",\n  \"httpVersion\": \"HTTP/1.1\",\n  \"headers\": [{\n    \"name\": \"Authorization\",\n    \"value\": \"Bearer ACCESS_TOKEN\"\n  },\n  {\n    \"name\": \"content-type\",\n    \"value\": \"application/json\"\n  }],\n  \"postData\" : {\n    \"mimeType\": \"application/json\",\n    \"text\": \"{\\\"link_with\\\":\\\"SECONDARY_ACCOUNT_ID_TOKEN\\\"}\"\n  }\n}\n```\n\n## Auth0.js library\n\nYou can use the [Auth0.js](https://auth0.com/docs/libraries/auth0js) library.\n\nFirst, you must get an Access Token that can be used to call the Management API. You can do it by specifying the `https://{yourDomain}/api/v2/` audience when initializing Auth0.js. You will get the Access Token as part of the authentication flow. Alternatively, you can use the `checkSession` method.\n\nOnce you have the Access Token, you can create a new `auth0.Management` instance by passing it the account's Auth0 domain, and the Access Token.\n\nTo learn more, read [Auth0.js > User management](https://auth0.com/docs/libraries/auth0js/v9#user-management).\n\n## Add missing information with Rules\n\nWhen a user logs in, apps receive user information from the **primary identity**. Auth0 does not attempt to automatically complete missing profile fields with information from the secondary identities. For example, if the primary identity comes from a database connection and is missing the `given_name` and `family_name` properties, and the secondary identity comes from a Google social connection that includes the first and last name of the user, then the application will **not** receive data contained in the second identity.\n\nTo add missing information to primary identities with information from secondary identities, you can write a rule like the following example:\n\n```\nfunction(user, context, callback) {\n  \n  const propertiesToComplete = [\"given_name\", \"family_name\", \"name\"];\n\n  // go over each property and try to get missing\n  // information from secondary identities\n  for(var property of propertiesToComplete) {\n    if (!user[property]) {\n      for(var identity of user.identities) {\n        if (identity.profileData && identity.profileData[property]) {\n          user[property] = identity.profileData[property];\n          break;\n        }\n      }\n    }\n  }\n  \n  callback(null, user, context);\n}\n```\n\n## Account linking with Actions\n\nAuth0 Actions can be used to call the Management API to link user accounts. Auth0 does not automatically change to the correct primary user after Account Linking, so it must be changed within the Actions code upon successful Account Linking.\n\n#### Account linking with Actions\n\nActions allows for flexible extension of the Auth0 capabilities, and caution must be taken when linking user accounts.\n\nInsecurely linking accounts can allow malicious actors to access legitimate user accounts.\n\nPlease remain aware of the following:\n\n**Every** manual account link should prompt the user to enter credentials. Your tenant should request authentication for **both** accounts before linking occurs.\n\n### Example account linking with Actions\n\nA basic Account Linking implementation is as follows:\n\n1.  Identify potential user accounts to link with an Action.\n    \n2.  Redirect to an external linking app using the [Actions redirect functionality](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions) and token.\n    \n3.  Require the user to authenticate using their credentials for all accounts they wish to link.\n    \n4.  Redirect back to the Action with the outcome of the authentication encoded in a signed JWT and validate the authenticity and contents in that token.\n    \n5.  Perform Account Linking with a Management API call based on the results.\n    \n6.  Switch to the primary user for the remainder of the transaction using Actions.\n    \n\nIn order to perform those steps, an example Post-Login Action may contain the following:\n\n```\n// @ts-check\nconst { ManagementClient } = require(\"auth0\");\n\n// High-level Workflow for Performing Account Linking in Actions\n// --------------------------------------------------------------------------------------------\n//\n// The goal of this workflow is to systematically process all users for potential account\n// linking. We want to detect situations where an end-user\n// may have other identities in Auth0. These other identities would be discovered through\n// matching verified email addresses. The Auth0 Action will ensure that all users are processed\n// for account linking.\n//\n// A redirect app will be hosted by the customer to which we will redirect the user's browser\n// when account linking might be available. The customer's account linking app is responsible\n// authenticating that the current user owns the candidate linking identities. It will actually\n// perform the account linking via Management API before redirecting back to the login flow's\n// `/continue?state` endpoint.\n//\n// The Action will pick up here and update the primary user for the login if necessary and mark\n// the user as having been successfully processed.\n//\n// Here are the details of the workflow:\n//\n// 1. Check if the user has been processed for account linking. The state for this is encoded in\n//    the user's `app_metadata`. If the user has already been processed, exit this flow.\n// 2. Discover other user identities that are candidates for account linking. If candidates are\n//    found:\n//   1. Encode the current user and any candidate identities into a signed session token to be\n//      passed to the account linking app.\n//   2. Redirect the user's browser to the account linking app with the signed session token.\n//   3. The account linking app should challenge the user to authenticate using the candidate\n//      identities.\n//   4. If the user choses to proceed with account linking and successfully authenticates with\n//      candidate identities, determine the primary user under which to consolidate identities.\n//   5. Use the management API to perform account linking and to map any user or app metadata\n//      from the other user accounts into the new primary user account.\n//   6. Redirect back to `/continue?state` with a new signed token encoding the primary user\n//      that is the outcome of the account linking app.\n//   7. Validate the returned session token in the `onContinuePostLogin` entrypoint of the\n//      Action. If a change of primary user is required, change the primary user via\n//      `api.authentication.setPrimaryUser(newPrimaryUserId)`.\n// 3. Mark the user as having been processed for account linking by storing a flag in the\n//    user's `app_metadata`.\n\nconst LINKING_STATE_KEY = 'account_linking_state';\n\n/**\n * Handler that will be called during the execution of a PostLogin flow.\n *\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  if (!event.user.email_verified) {\n    // We won't process users for account linking until they have verified their email address.\n    // We might consider rejecting logins here or redirecting users to an external tool to\n    // remind the user to confirm their email address before proceeding.\n    //\n    // In this example, we simply won't process users unless their email is verified.\n    return;\n  }\n\n  const accountLinkingState = event.user.app_metadata[LINKING_STATE_KEY];\n\n  if (accountLinkingState) {\n    // Account linking has already been processed and completed for this user. No further work\n    // to be done in this Action.\n    return;\n  }\n\n  const token = await getManagementApiToken(event, api);\n  const domain = event.secrets.TENANT_DOMAIN;\n  const management = new ManagementClient({ domain, token });\n\n  // Search for other candidate users\n  const { data: candidateUsers } = await management.usersByEmail.getByEmail({\n    email: event.user.email,\n  });\n\n  if (!Array.isArray(candidateUsers)) {\n    return;\n  }\n\n  const candidateIdentities = candidateUsers.flatMap((user) => user.identities);\n\n  if (!candidateIdentities.length) {\n    // No candidate users for linking so mark the user as processed.\n    api.user.setAppMetadata(LINKING_STATE_KEY, Date.now());\n  }\n\n  // Encode the current user and an array of their \n  const sessionToken = api.redirect.encodeToken({\n    payload: {\n      current_user: event.user,\n      candidate_identities: candidateIdentities,\n    },\n    secret: event.secrets.REDIRECT_SECRET,\n    expiresInSeconds: 20,\n  });\n\n  api.redirect.sendUserTo('https://url.for/account/linking/service', {\n    query: { session_token: sessionToken },\n  });\n};\n\n/**\n * Handler that will be invoked when this action is resuming after an external redirect. If your\n * onExecutePostLogin function does not perform a redirect, this function can be safely ignored.\n *\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onContinuePostLogin = async (event, api) => {\n  // Validate the session token passed to `/continue?state` and extract the `user_id` claim. \n  const { user_id } = api.redirect.validateToken({\n    secret: event.secrets.REDIRECT_SECRET,\n    tokenParameterName: 'session_token',\n  });\n\n  if (user_id !== event.user.user_id) {\n    // The account linking service indicated that the primary user changed.\n    api.authentication.setPrimaryUser(user_id);\n  }\n\n  // Mark the user as having been processed for account linking\n  api.user.setAppMetadata(LINKING_STATE_KEY, Date.now());\n};\n```\n\n## Learn more\n\n*   [User Account Linking: Server-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)\n*   [User-Initiated Account Linking: Client-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation)\n*   [Unlink User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/unlink-user-accounts)",
  "title": "Link User Accounts",
  "description": "Understand how to link user accounts from various identity providers, so your users can authenticate from any account and be recognized by your app.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections",
  "markdown": "# Identity Providers\n\nIntroduction to the various sources of users for applications, including identity providers, databases, and passwordless authentication methods.\n\nA connection is the relationship between Auth0 and a source of users, which may include external Identity Providers (such as Google or LinkedIn), databases, or passwordless authentication methods. Auth0 sits between your application and its sources of users, which adds a level of abstraction, so your application is isolated from any changes to and idiosyncrasies of each source's implementation.\n\nBy default, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. You can disable synchronization to allow for updating profile attributes from your application.\n\nYou can configure any number of connections for your applications.",
  "title": "Identity Providers",
  "description": "Learn about types of identity providers supported by Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication",
  "markdown": "# Multi-Factor Authentication (MFA)\n\n#### Overview\n\nMulti-factor Authentication (MFA) is another method of securing your application and your users' identities. MFA adds a layer of security during login that requires users to provide more than one credential to prove their digital identity. Factors can be:\n\n*   Something you are - like a biometric\n    \n*   Something you know - like a password\n    \n*   Something you own - like a device\n    \n\nRead this Q&A to see if using MFA with your Auth0 instance is the right choice for you.\n\n## What is multi-factor authentication?\n\nMulti-factor authentication (MFA) is a user verification method that requires more than one type of user validation. It prevents bad actors from accessing an account even if they've acquired the username and password.\n\n## Why use multi-factor authentication?\n\nMFA reduces the likelihood of many types of cyber-attacks. It's common for third parties to steal user names and passwords or programmatically attack user accounts. An additional MFA factor, such as a thumbprint or one-time password, impedes these violations.\n\n## How does multi-factor authentication work?\n\nMFA works by requiring additional verification information (known as factors). Users can't log in using only user names and passwords. They must provide further proof of identity, such as face recognition or text message notifications.\n\n## MFA factors\n\nAuth0 supports a variety of MFA factors, including:\n\n*   Push notifications\n    \n*   SMS notifications\n    \n*   Voice notifications\n    \n*   One-time passwords\n    \n*   WebAuthn with security keys\n    \n*   WebAuthn with device biometrics\n    \n*   Email notifications\n    \n*   Cisco Duo security\n    \n*   Recovery codes\n    \n\nTo learn more, read [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n\n## Enable MFA\n\nTo learn how to enable MFA, read [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa).\n\n## Customize MFA\n\nYou can also use [Auth0 Actions](https://auth0.com/docs/customize/actions) to customize your MFA flow. You can require MFA only in specific circumstances or force use of a particular factor.\n\n## Learn more\n\n*   [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors)\n*   [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa)\n*   [Customize Multi-Factor Authentication Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa)\n*   [Multi-Factor Authentication Developer Resources](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources)\n*   [Auth0 Guardian](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
  "title": "Multi-Factor Authentication (MFA)",
  "description": "Describes how multi-factor authentication (MFA) works in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-paginated-queries",
  "markdown": "# Migrate to Management API v2 Endpoint Paginated Queries\n\nAfter **26 January 2021** (or Private Cloud version 2202), requests to Management API v2 endpoints will return a maximum of 50 items for tenants in the Public Cloud. To retrieve more items, you must include the `page` and `per_page` parameters. Beginning on **21 July 2020** (or Private Cloud version 2108), Auth0 will display tenant logs and a migration toggle to help you prepare for this change.\n\nAffected tenants are those that meet the following criteria:\n\n*   Public Cloud tenants created **before 21 July 2020** or Private Cloud deployments on version 2108\n    \n*   Actively making calls to the affected endpoints without passing the `per_page` parameter for queries that can return more than 1 result.\n    \n\nThe following tenants will default to the new pagination behavior and will continue to operate as they do today after 26 January 2021:\n\n*   Public Cloud tenants created **on or after 21 July 2020** or Private Cloud deployments on version 2108 or higher\n    \n*   Not using any of the affected endpoints\n    \n*   Using the affected endpoints and passing the `per_page` parameter, or making queries that will always return a single result.\n    \n\n## Endpoints affected\n\nCalls to the following Management API v2 endpoints are affected:\n\n*   [`GET /api/v2/clients`](https://auth0.com/docs/api/management/v2#!/Clients/get_clients)\n    \n*   [`GET /api/v2/client_grants`](https://auth0.com/docs/api/management/v2#!/Clients/client_grants)\n    \n*   [`GET /api/v2/grants`](https://auth0.com/docs/api/management/v2#!/Clients/grants)\n    \n*   [`GET /api/v2/connections`](https://auth0.com/docs/api/management/v2#!/Clients/connections)\n    \n*   [`GET /api/v2/device-credentials`](https://auth0.com/docs/api/management/v2#!/Clients/device_credentials)\n    \n*   [`GET /api/v2/resource-servers`](https://auth0.com/docs/api/management/v2#!/Clients/resource_servers)\n    \n*   [`GET /api/v2/rules`](https://auth0.com/docs/api/management/v2#!/Clients/rules)\n    \n\nDeprecation notices will be recorded in your tenant logs for all requests without pagination options that are currently returning more than 1 item, once per hour, for each different client and endpoint.\n\n## Actions\n\n1.  Replace all calls to the affected endpoints by providing the `page` and `per_page` parameters.\n    \n    | Parameter | Type | Description |\n    | --- | --- | --- |\n    | `page` | Integer | Page index of the results to return. First page is 0. |\n    | `per_page` | Integer | Number of results per page. Paging is disabled if the parameter is not sent. |\n    \n2.  Confirm that you are no longer seeing deprecation notices in your tenant logs. Check if a request returned more than 50 items. Look at the `details.size_exceeded` field and check if it's `true`.\n    \n    1.  Use the following log query to return all calls without pagination options with more than 1 result: `type:depnote AND description:*Unpaginated*`\n        \n    2.  Use the following log query to return all calls without pagination options with more than 50 results: `type:depnote AND description:*Unpaginated* AND details.size_exceeded:true`\n        \n    \n    To identify the application making the request, logs will include the `client_id` used to make the request. You can also find the endpoint being used in the logs `details.path` field.\n    \n3.  Disable Management API unpaginated requests for your tenant. Go to [Dashboard > Tenant Settings > Advanced > Migration](https://manage.auth0.com/#/tenant/advanced). This will simulate the expected behavior after the migration window closes, causing calls to affected endpoints to return up to 50 results. You will be able to re-enable unpaginated requests any time before that date.\n    \n\n### Update extensions\n\nYou may need to update from previous versions of [Auth0 Extensions](https://auth0.com/docs/customize/extensions) and custom extensions to the latest versions to make sure they are only performing paginated queries.\n\n1.  Check your tenant logs for deprecation notices for clients with an ID matching an extension URL. It means you will need to update that extension.\n    \n2.  Go to [Dashboard > Extensions](https://manage.auth0.com/#/extensions), select **Installed Extensions**, and click on the extension's **Update** link if present.\n    \n\n### Update Deploy CLI tool\n\nIf you are using the `auth0-deploy-cli` tool, you must update to version **5.3.0 or later**. To learn more, see [Deploy CLI Tool](https://auth0.com/docs/deploy-monitor/deploy-cli-tool).",
  "title": "Migrate to Management API v2 Endpoint Paginated Queries",
  "description": "Describes how to use the pagination parameters for specific Management API v2 endpoint queries.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/maui",
  "markdown": "# Add login to your MAUI application\n\nThis tutorial demonstrates how to add user login with Auth0 to a .NET MAUI application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\nCallback URLs are the URLs that Auth0 invokes after the authentication process. Auth0 routes your application back to this URL and appends additional parameters to it, including an access code which will be exchanged for an ID Token, Access Token, and Refresh Token.\n\nSince callback URLs can be manipulated, you will need to add your application's URL to your application's _Allowed Callback URLs_ for security. This will enable Auth0 to recognize these URLs as valid. If omitted, authentication will not be successful.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Install the Auth0 SDK\n\nAuth0 provides a [MAUI](https://www.nuget.org/packages/Auth0.OidcClient.MAUI/) SDK to simplify the process of implementing Auth0 authentication in MAUI applications.\n\nUse the NuGet Package Manager (Tools -> Library Package Manager -> Package Manager Console) to install the `Auth0.OidcClient.MAUI` package.\n\nAlternatively, you can use the Nuget Package Manager Console (`Install-Package`) or the `dotnet` CLI (`dotnet add`).\n\n```\nInstall-Package Auth0.OidcClient.MAUI\n```\n\n```\ndotnet add package Auth0.OidcClient.MAUI\n```\n\n## Platform specific configuration\n\nYou need some platform-specific configuration to use the SDK with Android and Windows.\n\n### Android\n\nCreate a new Activity that extends `WebAuthenticatorCallbackActivity`:\n\n```\n[Activity(NoHistory = true, LaunchMode = LaunchMode.SingleTop, Exported = true)]\n[IntentFilter(new[] { Intent.ActionView },\n              Categories = new[] { Intent.CategoryDefault, Intent.CategoryBrowsable },\n              DataScheme = CALLBACK_SCHEME)]\npublic class WebAuthenticatorActivity : Microsoft.Maui.Authentication.WebAuthenticatorCallbackActivity\n{\n    const string CALLBACK_SCHEME = \"myapp\";\n}\n```\n\nThe above activity will ensure the application can handle the `myapp://callback` URL when Auth0 redirects back to the Android application after logging in.\n\n### Windows\n\nTo make sure it can properly reactivate your application after being redirected back to Auth0, you need to do two things:\n\n*   Add the corresponding protocol to the `Package.appxmanifest`. In this case, this is set to `myapp`, but you can change this to whatever you like (ensure to update all relevant Auth0 URLs as well).\n    \n    ```\n    <Applications>\n      <Application Id=\"App\" Executable=\"$targetnametoken$.exe\" EntryPoint=\"$targetentrypoint$\">\n        <Extensions>\n          <uap:Extension Category=\"windows.protocol\">\n            <uap:Protocol Name=\"myapp\"/>\n          </uap:Extension>\n        </Extensions>\n      </Application>\n    </Applications>\n    ```\n    \n*   Call `Activator.Default.CheckRedirectionActivation()` in the Windows-specific `App.xaml.cs` file.\n    \n    ```\n    public App()\n    {\n      if (Auth0.OidcClient.Platforms.Windows.Activator.Default.CheckRedirectionActivation())\n        return;\n    \n      this.InitializeComponent();\n    }\n    ```\n    \n\n## Instantiate the Auth0Client\n\nTo integrate Auth0 into your application, instantiate an instance of the `Auth0Client` class, passing an instance of `Auth0ClientOptions` that contains your Auth0 Domain, Client ID and the required Scopes. Additionally, you also need to configure the `RedirectUri` and `PostLogoutRedirectUri` to ensure Auth0 can redirect back to the application using the URL(s) configured.\n\n```\nusing Auth0.OidcClient;\n\nvar client = new Auth0Client(new Auth0ClientOptions\n{\n    Domain = \"{yourDomain}\",\n    ClientId = \"{yourDomain}\",\n    RedirectUri = \"myapp://callback\",\n    PostLogoutRedirectUri = \"myapp://callback\",\n    Scope = \"openid profile email\"\n});\n```\n\nBy default, the SDK will leverage Chrome Custom Tabs for Android, ASWebAuthenticationSession for iOS and macOS and use your system's default browser on Windows.\n\n## Add Login to Your Application\n\nNow that you have configured your Auth0 Application and the Auth0 SDK, you need to set up login for your project. To do this, you will use the SDK’s `LoginAsync()` method to create a login button that redirects users to the Auth0 Universal Login page.\n\n```\nvar loginResult = await client.LoginAsync();\n```\n\nIf there isn't any error, you can access the `User`, `IdentityToken`, `AccessToken` and `RefreshToken` on the `LoginResult` returned from `LoginAsync()`.\n\n## Add Logout to Your Application\n\nUsers who log in to your project will also need a way to log out. Create a logout button using the SDK’s `LogoutAsync()` method. When users log out, they will be redirected to your Auth0 logout endpoint, which will then immediately redirect them back to the logout URL you set up earlier in this quickstart.\n\n```\nawait client.LogoutAsync();\n```\n\n## Show User Profile Information\n\nNow that your users can log in and log out, you will likely want to be able to retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with authenticated users. For example, you may want to be able to display a logged-in user’s name or profile picture in your project.\n\nThe Auth0 SDK for MAUI provides user information through the `LoginResult.User` property.\n\n```\nif (loginResult.IsError == false)\n{\n    var user = loginResult.User;\n    var name = user.FindFirst(c => c.Type == \"name\")?.Value;\n    var email = user.FindFirst(c => c.Type == \"email\")?.Value;\n    var picture = user.FindFirst(c => c.Type == \"picture\")?.Value;\n}\n```",
  "title": "Auth0 MAUI SDK Quickstarts: Add login to your MAUI application",
  "description": "This tutorial demonstrates how to add user login with Auth0 to a .NET MAUI application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/flutter",
  "markdown": "# Add login to your Flutter app\n\nThis tutorial demonstrates how to add user login with Auth0 to an Android, iOS, or macOS Flutter app using the Auth0 Flutter SDK We recommend that you log in to follow this quickstart with examples configured for your account.\n\nSystem requirements: Flutter 3+ | Android API 21+ and Android Studio 4+ (for Android) | iOS 13+ and Xcode 14+ (for iOS) | macOS 11+ and Xcode 14+ (for macOS)\n\n## Add login to your Flutter app\n\nAuth0 allows you to quickly add authentication and access user profile information in your app. This guide demonstrates how to integrate Auth0 with a Flutter app using the [Auth0 Flutter SDK](https://github.com/auth0/auth0-flutter).\n\n## Getting started\n\nThis quickstart assumes you already have a [Flutter](https://flutter.dev/) app up and running. If not, check out the [Flutter \"getting started\" guides](https://docs.flutter.dev/get-started/install) to get started with a simple app.\n\nYou should also be familiar with the [Flutter command line tool](https://docs.flutter.dev/reference/flutter-cli).\n\nFinally, you will need a **Native** Auth0 application. If you don’t have a Native Auth0 application already, [create one](https://auth0.com/docs/get-started/auth0-overview/create-applications/native-apps) before continuing. Avoid using other application types, as they have different configurations and may cause errors.\n\n### Configure the callback and logout URLs\n\nThe callback and logout URLs are the URLs that Auth0 invokes to redirect back to your app. Auth0 invokes the callback URL after authenticating the user, and the logout URL after removing the session cookie.\n\nIf the callback and logout URLs are not set, users will be unable to log in and out of the app and will get an error.\n\nGo to the [settings page](https://manage.auth0.com/#/applications/{yourClientId}/settings) of your Auth0 application and add the following URLs to **Allowed Callback URLs** and **Allowed Logout URLs**, depending on the platform of your app. If you have a [custom domain](https://auth0.com/docs/customize/custom-domains), use this instead of the Auth0 domain from the settings page.\n\n#### Android\n\n```\nSCHEME://{yourDomain}/android/YOUR_PACKAGE_NAME/callback\n```\n\n#### iOS\n\n```\nhttps://{yourDomain}/ios/YOUR_BUNDLE_IDENTIFIER/callback,\nYOUR_BUNDLE_IDENTIFIER://{yourDomain}/ios/YOUR_BUNDLE_IDENTIFIER/callback\n```\n\n#### macOS\n\n```\nhttps://{yourDomain}/macos/YOUR_BUNDLE_IDENTIFIER/callback,\nYOUR_BUNDLE_IDENTIFIER://{yourDomain}/macos/YOUR_BUNDLE_IDENTIFIER/callback\n```\n\nFor example, if your iOS bundle identifier were `com.example.MyApp` and your Auth0 domain were `example.us.auth0.com`, then this value would be:\n\n```\nhttps://example.us.auth0.com/ios/com.example.MyApp/callback,\ncom.example.MyApp://example.us.auth0.com/ios/com.example.MyApp/callback\n```\n\n## Install the Auth0 Flutter SDK\n\nAdd the Auth0 Flutter SDK into the project:\n\n```\nflutter pub add auth0_flutter\n```\n\n## Configure Android\n\nIf you are not developing for the Android platform, skip this step.\n\nThe SDK requires manifest placeholders. Auth0 uses placeholders internally to define an `intent-filter`, which captures the authentication callback URL. You must set the Auth0 tenant domain and the callback URL scheme.\n\nModify `app/build.gradle` to include manifest placeholders for `auth0Domain` and `auth0Scheme` inside the `defaultConfig` section:\n\n```\napply plugin: 'com.android.application'\n\nandroid {\n    defaultConfig {\n        applicationId \"com.auth0.samples\"\n        minSdkVersion 21\n        targetSdkVersion flutter.targetSdkVersion\n        // ...\n\n        // ---> Add the next line\n        manifestPlaceholders += [auth0Domain: \"{yourDomain}\", auth0Scheme: \"https\"]\n        // <---\n    }\n}\n```\n\n*   `auth0Domain`: The domain of your Auth0 tenant. Generally, you find this in the Auth0 Dashboard under your **Application Settings** in the Domain field. If you are using a custom domain, you should set this to the value of your custom domain instead.\n*   `auth0Scheme`: The scheme to use. Can be a custom scheme, or `https` if you want to use [Android App Links](https://auth0.com/docs/applications/enable-android-app-links). You can read more about setting this value in the [Auth0.Android SDK README](https://github.com/auth0/Auth0.Android#a-note-about-app-deep-linking).\n\nRun **Sync Project with Gradle Files** inside Android Studio to apply your changes.\n\n## Configure iOS/macOS\n\nIf you are not developing for the iOS or macOS platforms, skip this step.\n\n#### Configure the Team ID and bundle identifier\n\nGo to the [settings page](https://manage.auth0.com/#/applications/{yourClientId}/settings) of your Auth0 application, scroll to the end, and open **Advanced Settings > Device Settings**. In the **iOS** section, set **Team ID** to your [Apple Team ID](https://developer.apple.com/help/account/manage-your-team/locate-your-team-id/), and **App ID** to your app's bundle identifier.\n\n![Screenshot of the iOS section inside the Auth0 application settings page](https://auth0.com/docs/media/articles/native-platforms/ios-swift/ios-device-settings.png)\n\nThis will add your app to your Auth0 tenant's `apple-app-site-association` file.\n\n#### Add the associated domain capability\n\nOpen your app in Xcode by running `open ios/Runner.xcworkspace` (or `open macos/Runner.xcworkspace` for macOS). Go to the **Signing and Capabilities** [tab](https://developer.apple.com/documentation/xcode/adding-capabilities-to-your-app#Add-a-capability) of the **Runner** target settings, and press the **\\+ Capability** button. Then select **Associated Domains**.\n\n![Screenshot of the capabilities library inside Xcode](https://auth0.com/docs/media/articles/native-platforms/ios-swift/ios-xcode-capabilities.png)\n\nNext, add the following [entry](https://developer.apple.com/documentation/xcode/configuring-an-associated-domain#Define-a-service-and-its-associated-domain) under **Associated Domains**:\n\n```\nwebcredentials:{yourDomain}\n```\n\nIf you have a [custom domain](https://auth0.com/docs/customize/custom-domains), use this instead of the Auth0 domain from the settings page.\n\n## Add login to your app\n\n[Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) is the easiest way to set up authentication in your app. We recommend using it for the best experience, best security, and the fullest array of features.\n\nIntegrate Auth0 Universal Login in your Flutter app by importing the SDK and instantiating the `Auth0` class using your Auth0 domain and Client ID values. See this example, which instantiates the class inside a widget state object:\n\n```\nimport 'package:auth0_flutter/auth0_flutter.dart';\n\nclass MainView extends StatefulWidget {\n  const MainView({Key? key}) : super(key: key);\n\n  @override\n  State<MainView> createState() => _MainViewState();\n}\n\nclass _MainViewState extends State<MainView> {\n  Credentials? _credentials;\n\n  late Auth0 auth0;\n\n  @override\n  void initState() {\n    super.initState();\n    auth0 = Auth0('{yourDomain}', '{yourClientId}');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // ...\n  }\n}\n```\n\nNext, redirect your users to the Auth0 Universal Login page using `webAuthentication().login()`. This is a `Future` and must be awaited for you to retrieve the user's tokens. See this example of a `ElevatedButton` widget that logs the user in when clicked. Note that `_credentials` is used to determine locally within your app whether or not a user is signed in:\n\n```\nif (_credentials == null) {\n  ElevatedButton(\n    onPressed: () async {\n      // Use a Universal Link callback URL on iOS 17.4+ / macOS 14.4+\n      // useHTTPS is ignored on Android\n      final credentials =\n          await auth0.webAuthentication().login(useHTTPS: true);\n\n      setState(() {\n        _credentials = credentials;\n      });\n    },\n    child: const Text(\"Log in\")\n  )\n}\n```\n\n**Android**: if you are using a custom scheme, pass this scheme to the login method so that the SDK can route to the login page and back again correctly:\n\n```\nawait auth0.webAuthentication(scheme: 'YOUR CUSTOM SCHEME').login();\n```\n\nWhen a user logs in, they are redirected back to your app. Then, you are able to access the ID and access tokens for this user.\n\n##### Checkpoint\n\nAdd a button to your app that calls `webAuthentication().login()` and logs the user into your app. Verify that you are redirected to Auth0 for authentication and then back to your app.\n\nVerify that you can get access to the tokens on the result of calling `login`.\n\n## Add logout to your app\n\nTo log users out, redirect them to the Auth0 logout endpoint to clear their login session by calling the Auth0 Flutter SDK `webAuthentication().logout()`. [Read more about logging out of Auth0](https://auth0.com/docs/authenticate/login/logout).\n\nSee this example of an `ElevatedButton` widget that logs the user out of the app. Note that `_credentials` is set to `null`, indicating that the user is no longer signed in to your app:\n\n```\nElevatedButton(\n  onPressed: () async {\n    // Use a Universal Link logout URL on iOS 17.4+ / macOS 14.4+\n    // useHTTPS is ignored on Android\n    await auth0.webAuthentication().logout(useHTTPS: true);\n\n    setState(() {\n      _credentials = null;\n    });\n  },\n  child: const Text(\"Log out\"))\n```\n\n**Android**: if you are using a custom scheme, pass this scheme to the logout method so that the SDK can route back to your app correctly:\n\n```\nawait auth0.webAuthentication(scheme: 'YOUR CUSTOM SCHEME').logout();\n```\n\n##### Checkpoint\n\nAdd a button to your app that calls `webAuthentication().logout()` and logs the user out of your app. When you select it, verify that your Flutter app redirects you to the logout endpoint and back again. You should not be logged in to your app.\n\n## Show user profile information\n\nThe user profile automatically retrieves user profile properties for you when you call `webAuthentication().login()`. The returned object from the login step contains a `user` property with all the user profile properties, which populates by decoding the ID token.\n\nSee this example of a `View` component that displays the user profile on the screen:\n\n```\nimport 'package:auth0_flutter/auth0_flutter.dart';\nimport 'package:flutter/material.dart';\n\nclass ProfileView extends StatelessWidget {\n  const ProfileView({Key? key, required this.user}) : super(key: key);\n\n  final UserProfile user;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        if (user.name != null) Text(user.name!),\n        if (user.email != null) Text(user.email!)\n      ],\n    );\n  }\n}\n```\n\n##### Checkpoint\n\nLog in and inspect the `user` property on the result. Verify the current user's profile information, such as `email` or `name`.",
  "title": "Auth0 Flutter SDK Quickstarts: Add login to your Flutter app",
  "description": "This tutorial demonstrates how to add user login with Auth0 to an Android, iOS, or macOS Flutter app using the Auth0 Flutter SDK",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/wpf-winforms",
  "markdown": "# Auth0 WPF / Winforms SDK Quickstarts: Login\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Native/Mobile App](https://auth0.com/docs/quickstart/native)\n*   [WPF / Winforms](https://auth0.com/docs/quickstart/native/wpf-winforms)\n\nThis tutorial demonstrates how to add user login to a WPF and Windows Forms C# application using Auth0. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Microsoft Visual Studio 2022 | .NET Framework 4.6.2 | .NET 6\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Integrate Auth0 in your Application\n\n### Install Dependencies\n\nThe `Auth0.OidcClient.WPF` or `Auth0.OidcClient.WinForms` NuGet packages helps you authenticate users with any [Auth0 supported identity provider](https://auth0.com/docs/identityproviders).\n\nUse the NuGet Package Manager (Tools -> Library Package Manager -> Package Manager Console) to install the `Auth0.OidcClient.WPF` or `Auth0.OidcClient.WinForms` package, depending on whether you are building a WPF or Windows Forms application:\n\n## Trigger Authentication\n\nTo integrate Auth0 login into your application, simply instantiate an instance of the `Auth0Client` class, passing your Auth0 Domain and Client ID in the constructor.\n\n```\n// Form1.cs\n\nusing Auth0.OidcClient;\n\nAuth0ClientOptions clientOptions = new Auth0ClientOptions\n{\n    Domain = \"{yourDomain}\",\n    ClientId = \"{yourClientId}\"\n};\nclient = new Auth0Client(clientOptions);\nclientOptions.PostLogoutRedirectUri = clientOptions.RedirectUri;\n```\n\nYou can then call the `LoginAsync` method to log the user in:\n\n```\nvar loginResult = await client.LoginAsync();\n```\n\n![](https://auth0.com/docs/media/articles/native-platforms/wpf-winforms/universal-login.png)\n\nThis will load the Auth0 login page into a web view. You can learn how to customize the login page in [this document](https://auth0.com/docs/universal-login#simple-customization).\n\n## Handle Authentication Tokens\n\nThe returned login result will indicate whether authentication was successful, and if so contain the tokens and claims of the user.\n\n### Authentication Error\n\nYou can check the `IsError` property of the result to see whether the login has failed. The `ErrorMessage` will contain more information regarding the error which occurred.\n\n```\nvar loginResult = await client.LoginAsync();\n\nif (loginResult.IsError)\n{\n    Debug.WriteLine($\"An error occurred during login: {loginResult.Error}\");\n}\n```\n\n### Accessing the tokens\n\nOn successful login, the login result will contain the ID Token and Access Token in the `IdentityToken` and `AccessToken` properties respectively.\n\n```\nvar loginResult = await client.LoginAsync();\n\nif (!loginResult.IsError)\n{\n    Debug.WriteLine($\"id_token: {loginResult.IdentityToken}\");\n    Debug.WriteLine($\"access_token: {loginResult.AccessToken}\");\n}\n```\n\n### Obtaining the User Information\n\nOn successful login, the login result will contain the user information in the `User` property, which is a [ClaimsPrincipal](https://msdn.microsoft.com/en-us/library/system.security.claims.claimsprincipal(v=vs.110).aspx).\n\nTo obtain information about the user, you can query the claims. You can for example obtain the user's name and email address from the `name` and `email` claims:\n\n```\nif (!loginResult.IsError)\n{\n    Debug.WriteLine($\"name: {loginResult.User.FindFirst(c => c.Type == \"name\")?.Value}\");\n    Debug.WriteLine($\"email: {loginResult.User.FindFirst(c => c.Type == \"email\")?.Value}\");\n}\n```\n\nYou can obtain a list of all the claims contained in the ID Token by iterating through the `Claims` collection:\n\n```\nif (!loginResult.IsError)\n{\n    foreach (var claim in loginResult.User.Claims)\n    {\n        Debug.WriteLine($\"{claim.Type} = {claim.Value}\");\n    }\n}\n```\n\n## Logout\n\nTo log the user out call the `LogoutAsync` method.\n\n```\nawait client.LogoutAsync();\n```",
  "title": "Auth0 WPF / Winforms SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to a WPF and Windows Forms C# application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/angular",
  "markdown": "# Auth0 Angular SDK Quickstarts: Login\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Single-Page App](https://auth0.com/docs/quickstart/spa)\n*   [Angular](https://auth0.com/docs/quickstart/spa/angular)\n*   [Login](https://auth0.com/docs/quickstart/spa/angular/01-login)\n\nThis tutorial demonstrates how to add user login to an Angular application using Auth0. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Angular 12+\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n### Configure Allowed Web Origins\n\nYou need to add the URL for your app to the **Allowed Web Origins** field in your [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings). If you don't register your application URL here, the application will be unable to silently refresh the authentication tokens and your users will be logged out the next time they visit the application, or refresh the page.\n\n## Install the Auth0 Angular SDK\n\nRun the following command within your project directory to install the Auth0 Angular SDK:\n\n```\nnpm install @auth0/auth0-angular\n```\n\nThe SDK exposes several types that help you integrate Auth0 with your Angular application idiomatically, including a module and an authentication service.\n\n### Register and providing Auth0\n\nThe SDK exports `provideAuth0`, which is a provide function that contains all the services required for the SDK to function. To register this with your application:\n\n1.  Open the `main.ts` file.\n2.  Import the `provideAuth0` function from the `@auth0/auth0-angular` package.\n3.  Add `provideAuth0` to the application by adding it to the `providers` inside `bootstrapApplication`.\n4.  Inject `AuthService` into `AppComponent`.\n\n```\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideAuth0 } from '@auth0/auth0-angular';\nimport { AppComponent } from './app.component';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideAuth0({\n      domain: '{yourDomain}',\n      clientId: '{yourClientId}',\n      authorizationParams: {\n        redirect_uri: window.location.origin\n      }\n    }),\n  ]\n});\n```\n\nThe `provideAuth0` function takes the properties `domain` and `clientId`; the values of these properties correspond to the **Domain** and **Client ID** values that you can find under **Settings** in the Single-Page Application (SPA) that you registered with Auth0. On top of that, we configure `authorizationParams.redirect_uri`, which allows Auth0 to redirect the user back to the specific URL after successfully authenticating.\n\n### Checkpoint\n\nNow that you have imported `AuthModule`, run your application to verify that the SDK is initializing correctly and that your application is not throwing any errors related to Auth0.\n\n## Add Login to Your Application\n\nThe Auth0 Angular SDK gives you tools to quickly implement user authentication in your Angular application, such as creating a [login](https://auth0.com/docs/login) button using the `loginWithRedirect()` method from the `AuthService` service class. Executing `loginWithRedirect()` redirects your users to the Auth0 Universal Login Page, where Auth0 can authenticate them. Upon successful authentication, Auth0 will redirect your users back to your application.\n\n```\nimport { Component } from '@angular/core';\n\n// Import the AuthService type from the SDK\nimport { AuthService } from '@auth0/auth0-angular';\n\n@Component({\n  selector: 'app-auth-button',\n  template: '<button (click)=\"auth.loginWithRedirect()\">Log in</button>',\n  standalone: true\n})\nexport class AuthButtonComponent {\n  // Inject the authentication service into your component through the constructor\n  constructor(public auth: AuthService) {}\n}\n```\n\n### Checkpoint\n\nAdd the `AuthButtonComponent` component to your application. When you click it, verify that your Angular application redirects you to the [Auth0 Universal Login](https://auth0.com/universal-login) page and that you can now log in or sign up using a username and password or a social provider.\n\nOnce that's complete, verify that Auth0 redirects back to your application's homepage.\n\n![Auth0 Universal Login](https://auth0.com/docs/media/quickstarts/universal-login.png)\n\n## Add Logout to Your Application\n\nNow that you can log in to your Angular application, you need [a way to log out](https://auth0.com/docs/logout/guides/logout-auth0). You can create a logout button using the `logout()` method from the `AuthService` service. Executing `logout()` redirects your users to your [Auth0 logout endpoint](https://auth0.com/docs/api/authentication?javascript#logout) (`https://YOUR_DOMAIN/v2/logout`) and then immediately redirects them to your application.\n\nHere is a modified version of the `AuthButtonComponent` component above that uses both `loginWithRedirect()` and `logout()`, as well as checking the authentication state using the `isAuthenticated$` observable:\n\n```\nimport { Component, Inject } from '@angular/core';\nimport { AuthService } from '@auth0/auth0-angular';\nimport { DOCUMENT } from '@angular/common';\n\n@Component({\n  selector: 'app-auth-button',\n  template: `\n    <ng-container *ngIf=\"auth.isAuthenticated$ | async; else loggedOut\">\n      <button (click)=\"auth.logout({ logoutParams: { returnTo: document.location.origin } })\">\n        Log out\n      </button>\n    </ng-container>\n\n    <ng-template #loggedOut>\n      <button (click)=\"auth.loginWithRedirect()\">Log in</button>\n    </ng-template>\n  `,\n  standalone: true\n})\nexport class AuthButtonComponent {\n  constructor(@Inject(DOCUMENT) public document: Document, public auth: AuthService) {}\n}\n```\n\nSpecify the `returnTo` option when calling `logout` to tell Auth0 where it should redirect to after a successful logout. This value must be specified in [the **Allowed Logout URLs** setting](#configure-logout-urls) in the dashboard.\n\n### Checkpoint\n\nAdd a button to the component template that logs the user out of your application. When you click it, verify that your Angular application redirects you the address you specified as one of the \"Allowed Logout URLs\" in the \"Settings\" and that you are no longer logged in to your application.\n\n## Show User Profile Information\n\nThe Auth0 Angular SDK helps you retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with logged-in users quickly in whatever component you need, such as their name or profile picture, to personalize the user interface. The profile information is available through the `user$` observable exposed by the `AuthService` service. Take this `Profile` component as an example of how to use it:\n\n```\nimport { Component } from '@angular/core';\nimport { AuthService } from '@auth0/auth0-angular';\n\n@Component({\n  selector: 'app-user-profile',\n  template: `\n    <ul *ngIf=\"auth.user$ | async as user\">\n      <li>{{ user.name }}</li>\n      <li>{{ user.email }}</li>\n    </ul>`,\n  standalone: true\n})\nexport class UserProfileComponent {\n  constructor(public auth: AuthService) {}\n}\n```\n\nThe `user$` observable contains sensitive information and artifacts related to the user's identity. As such, its availability depends on the user's authentication status. Fortunately, the `user$` observable is configured so that it only starts to emit values once the `isAuthenticated$` observable is true, so there is no need to manually check the authentication state before accessing the user profile data.\n\n### Checkpoint\n\nVerify that you can display the `user.name` or [any other `user` property](https://auth0.com/docs/users/references/user-profile-structure#user-profile-attributes) within a component correctly after you have logged in.",
  "title": "Auth0 Angular SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to an Angular application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/react-native",
  "markdown": "# Auth0 React Native SDK Quickstarts: Login\n\nThis tutorial demonstrates how to add user login to a React Native application using Auth0. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nThis Quickstart is for the React Native framework. To integrate Auth0 into your Expo application, please refer to the [Expo Quickstart](https://auth0.com/docs/quickstart/native/react-native-expo/interactive)\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n## Install Dependencies\n\nIn this section, you will install the React Native Auth0 module.\n\n### Yarn\n\n```\nyarn add react-native-auth0\n```\n\n### npm\n\n```\nnpm install react-native-auth0 --save\n```\n\n### Additional iOS step: install the module Pod\n\nOur SDK requires a minimum iOS deployment target of 13.0. In your project's \\`ios/Podfile\\`\\`, ensure your platform target is set to 13.0.\n\nCocoaPods is the iOS package management tool the React Native framework uses to install itself into your project. For the iOS native module to work with your iOS app, first install the library Pod. If you're familiar with older React Native SDK versions, this is similar to the previous _linking a native module_. The process is now simplified:\n\nChange directory into the `ios` folder and run `pod install`.\n\nFirst, you must provide a way for your users to log in. We recommend using the Auth0 hosted [login page](https://auth0.com/docs/hosted-pages/login).\n\n![Universal Login](https://auth0.com/docs/media/articles/native-platforms/ios-swift/login-ios.png)\n\n## Integrate Auth0 in Your Application\n\n### Configure Android\n\nOpen your app's `build.gradle` file (typically at `android/app/build.gradle`) and add the following manifest placeholders. The value for `auth0Domain` should contain your Auth0 application settings [as configured above](#get-your-application-keys).\n\n```\nandroid {\n    defaultConfig {\n        // Add the next line\n        manifestPlaceholders = [auth0Domain: \"{yourDomain}\", auth0Scheme: \"${applicationId}.auth0\"]\n    }\n    ...\n}\n```\n\n### Configure iOS\n\nIn the file `ios/<YOUR PROJECT>/AppDelegate.mm` add the following:\n\n```\n#import <React/RCTLinkingManager.h>\n\n- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url\n            options:(NSDictionary<UIApplicationOpenURLOptionsKey, id> *)options\n{\n  return [RCTLinkingManager application:app openURL:url options:options];\n}\n```\n\nNext, add a URLScheme using your App's bundle identifier.\n\nIn the `ios` folder, open the `Info.plist` and locate the value for `CFBundleIdentifier`\n\n```\n<key>CFBundleIdentifier</key>\n<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>\n```\n\nBelow this value, register a URL type entry using the value of `CFBundleIdentifier` as the value for the `CFBundleURLSchemes`.\n\n```\n<key>CFBundleURLTypes</key>\n<array>\n    <dict>\n        <key>CFBundleTypeRole</key>\n        <string>None</string>\n        <key>CFBundleURLName</key>\n        <string>auth0</string>\n        <key>CFBundleURLSchemes</key>\n        <array>\n            <string>$(PRODUCT_BUNDLE_IDENTIFIER).auth0</string>\n        </array>\n    </dict>\n</array>\n```\n\nNote this value as you'll be using it to define the callback URLs below. If desired, you can change it using XCode in the following way:\n\n*   Open the `ios/<YOUR PROJECT>.xcodeproj` file or run `xed ios` on a Terminal from the app root.\n*   Open your project's or desired target's Build Settings tab and find the section that contains \"Bundle Identifier\".\n*   Replace the \"Bundle Identifier\" value with your desired application's bundle identifier name.\n\nFor additional information please read [react native docs](https://facebook.github.io/react-native/docs/linking).\n\n### Configure Callback and Logout URLs\n\nThe callback and logout URLs are the URLs that Auth0 invokes to redirect back to your application. Auth0 invokes the callback URL after authenticating the user, and the logout URL after removing the session cookie.\n\nIf the callback and logout URLs are not set, users will be unable to log in and out of the application and will get an error.\n\nGo to the settings page of your [Auth0 application](https://manage.auth0.com/#/applications/{yourClientId}/settings) and add the corresponding URL to **Allowed Callback URLs** and **Allowed Logout URLs**, according to the platform of your application. If you are using a [custom domain](https://auth0.com/docs/customize/custom-domains), use the value of your custom domain instead of the Auth0 domain from the settings page.\n\n#### iOS\n\n```\nBUNDLE_IDENTIFIER.auth0://{yourDomain}/ios/BUNDLE_IDENTIFIER/callback\n```\n\n#### Android\n\n```\nPACKAGE_NAME.auth0://{yourDomain}/android/PACKAGE_NAME/callback\n```\n\n## Add login to your app\n\nImport the `useAuth0` hook and the `Auth0Provider` component from the `react-native-auth0` package.\n\n```\nimport {useAuth0, Auth0Provider} from 'react-native-auth0';\n```\n\nNext, wrap your application in the `Auth0Provider` component, providing your Auth0 domain and Client ID values:\n\n```\nconst App = () => {\n  return (\n    <Auth0Provider domain={\"{yourDomain}\"} clientId={\"{yourClientId}\"}>\n      {/* your application */}\n    </Auth0Provider>\n  );\n};\n```\n\nFinally, present the hosted login screen using the `authorize` method from the `useAuth0` hook. See this usage example showing logging in on a button click:\n\n```\nconst LoginButton = () => {\n    const {authorize} = useAuth0();\n\n    const onPress = async () => {\n        try {\n            await authorize();\n        } catch (e) {\n            console.log(e);\n        }\n    };\n\n    return <Button onPress={onPress} title=\"Log in\" />\n}\n```\n\n### Checkpoint\n\nAdd a button component that calls `authorize` when clicked. Verify that you are redirected to the login page and then back to your application.\n\n## Add logout to your app\n\nTo log the user out, redirect them to the Auth0 log out endpoint by importing and calling the `clearSession` method from the `useAuth0` hook. This method removes their session from the authorization server.\n\nSee this usage example of a button that logs the user out of the app when clicked:\n\n```\nconst LogoutButton = () => {\n    const {clearSession} = useAuth0();\n\n    const onPress = async () => {\n        try {\n            await clearSession();\n        } catch (e) {\n            console.log(e);\n        }\n    };\n\n    return <Button onPress={onPress} title=\"Log out\" />\n}\n```\n\n### Checkpoint\n\nAdd a button that calls `clearSession` when clicked. Verify that you are logged out of the application when clicked.\n\n## Show user profile information\n\nThe `useAuth0` hook exposes a `user` object that contains information about the authenticated user. You can use this to access decoded user profile information about the authenticated user from the [ID token](https://auth0.com/docs/secure/tokens/id-tokens).\n\nIf a user has not been authenticated, this property will be `null`.\n\n```\nconst Profile = () => {\n    const {user} = useAuth0();\n\n    return (\n        <>\n            {user && <Text>Logged in as {user.name}</Text>}\n            {!user && <Text>Not logged in</Text>}\n        </>\n    )\n}\n```\n\n### Checkpoint\n\nAdd a component to your app that uses the `user` prop to display information about the user on the screen.",
  "title": "Auth0 React Native SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to a React Native application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/xamarin",
  "markdown": "# Auth0 .NET Android and iOS SDK Quickstarts: Add login to your .NET Android or iOS application\n\nThis tutorial demonstrates how to add user login with Auth0 to a .NET Android or iOS application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nSystem requirements: Visual Studio 2022+ or Visual Studio for Mac | Xamarin for Visual Studio | .NET6+\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\nCallback URLs are the URLs that Auth0 invokes after the authentication process. Auth0 routes your application back to this URL and appends additional parameters to it, including an access code which will be exchanged for an ID Token, Access Token, and Refresh Token.\n\nSince callback URLs can be manipulated, you will need to add your application's URL to your application's _Allowed Callback URLs_ for security. This will enable Auth0 to recognize these URLs as valid. If omitted, authentication will not be successful.\n\n*   For Android, the callback URL will be in the format\n    \n    ```\n    YOUR_ANDROID_PACKAGE_NAME://{yourDomain}/android/YOUR_ANDROID_PACKAGE_NAME/callback\n    ```\n    \n    where `YOUR_ANDROID_PACKAGE_NAME` is the Package Name for your application, such as `com.mycompany.myapplication`.\n    \n*   For iOS, the callback URL will be in the format\n    \n    ```\n    YOUR_BUNDLE_IDENTIFIER://{yourDomain}/ios/YOUR_BUNDLE_IDENTIFIER/callback\n    ```\n    \n    where `YOUR_BUNDLE_IDENTIFIER` is the Bundle Identifier for your application, such as `com.mycompany.myapplication`.\n    \n\nEnsure that the Callback URL is in lowercase.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Install Dependencies\n\nIf you are using Visual Studio, simply open the Package Manager Console (View -> Other Windows -> Package Manager Console), and install the package:\n\n**For Android:**\n\n```\nInstall-Package Auth0.OidcClient.AndroidX\n```\n\n**For iOS:**\n\n```\nInstall-Package Auth0.OidcClient.iOS\n```\n\nAlternatively, if you are using Visual Studio for Mac, please perform the following steps:\n\n1.  With the project loaded in Visual Studio for Mac, Ctrl+click (or right click) on the **Packages** folder of the project in the **Solution Pad**, and select **Add Packages...**\n2.  The **Add Packages** dialog will appear. Search and locate the package called `Auth0.OidcClient.AndroidX` or `Auth0.OidcClient.iOS` depending on your platform.\n3.  Tick the checkbox next to the package to select it, and click the **Add Package** button\n\n## Trigger Authentication\n\nTo integrate Auth0 login into your application, instantiate an instance of the `Auth0Client` class, configuring the Auth0 Domain and Client ID:\n\n```\nusing Auth0.OidcClient;\n\nvar client = new Auth0Client(new Auth0ClientOptions\n{\n    Domain = \"{yourDomain}\",\n    ClientId = \"{yourClientId}\"\n}, this);\n```\n\nThen, call the `LoginAsync` method which will redirect the user to the login screen. You will typically do this in the event handler for a UI control such as a Login button.\n\n```\nvar loginResult = await client.LoginAsync();\n```\n\n### Handing the callback URL\n\nAfter a user has logged in, they will be redirected back to your application at the **Callback URL** that was registered before. In both Android and iOS you need to handle this callback to complete the authentication flow.\n\n### Android\n\nRegister an intent which will handle this callback URL. An easy way to do this is to register the intent on the same activity from which you called the `LoginAsync` method to initiate the authentication flow.\n\n```\n[Activity(Label = \"AndroidSample\", MainLauncher = true, Icon = \"@drawable/icon\",\n    LaunchMode = LaunchMode.SingleTask)]\n[IntentFilter(\n    new[] { Intent.ActionView },\n    Categories = new[] { Intent.CategoryDefault, Intent.CategoryBrowsable },\n    DataScheme = \"YOUR_ANDROID_PACKAGE_NAME\",\n    DataHost = \"{yourDomain}\",\n    DataPathPrefix = \"/android/YOUR_ANDROID_PACKAGE_NAME/callback\")]\npublic class MainActivity : Activity\n{\n    // Code omitted\n}\n```\n\nReplace `YOUR_ANDROID_PACKAGE_NAME` in the code sample above with the actual Package Name for your application, such as `com.mycompany.myapplication`. Also ensure that all the text for the `DataScheme`, `DataHost`, and `DataPathPrefix` is in lower case. Also, set `LaunchMode = LaunchMode.SingleTask` for the `Activity`, otherwise the system will create a new instance of the activity every time the Callback URL gets called.\n\nNow write code to handle the intent. You can do this by overriding the `OnNewIntent` method. Inside the method you need to call the `Send` method on the `ActivityMediator` to complete the authentication cycle:\n\n```\nprotected override async void OnNewIntent(Intent intent)\n{\n    base.OnNewIntent(intent);\n\n    Auth0.OidcClient.ActivityMediator.Instance.Send(intent.DataString);\n}\n```\n\n### iOS\n\nRegister the URL scheme for your Callback URL which your application should handle:\n\n1.  Open your application's `Info.plist` file in Visual Studio for Mac, and go to the **Advanced** tab.\n2.  Under **URL Types**, click the **Add URL Type** button\n3.  Set the **Identifier** as `Auth0`, the **URL Schemes** the same as your application's **Bundle Identifier**, and the **Role** as `None`\n\nThis is an example of the XML representation of your `info.plist` file after you have added the URL Type:\n\n```\n<key>CFBundleURLTypes</key>\n<array>\n    <dict>\n        <key>CFBundleTypeRole</key>\n        <string>None</string>\n        <key>CFBundleURLName</key>\n        <string>Auth0</string>\n        <key>CFBundleURLSchemes</key>\n        <array>\n            <string>YOUR_BUNDLE_IDENTIFIER</string>\n        </array>\n    </dict>\n</array>\n```\n\nYou need to handle the Callback URL in the `OpenUrl` event in your `AppDelegate` class. You need to notify the Auth0 OIDC Client to finish the authentication flow by calling the `Send` method of the `ActivityMediator` singleton, pass along the URL that was sent in:\n\n```\nusing Auth0.OidcClient;\n\n[Register(\"AppDelegate\")]\npublic class AppDelegate : UIApplicationDelegate\n{\n    public override bool OpenUrl(UIApplication application, NSUrl url, string sourceApplication, NSObject annotation)\n    {\n        ActivityMediator.Instance.Send(url.AbsoluteString);\n\n        return true;\n    }\n}\n```\n\n### Run the application\n\nWith the above code in place, a user can log in to your application using Auth0.\n\n![Universal Login](https://auth0.com/docs/media/articles/native-platforms/android/login-android.png)\n\n## Accessing the User's Information\n\nThe returned login result will indicate whether authentication was successful and if so contain the tokens and claims of the user.\n\n### Authentication Error\n\nYou can check the `IsError` property of the result to see whether the login has failed. The `ErrorMessage` will contain more information regarding the error which occurred.\n\n```\nvar loginResult = await client.LoginAsync();\n\nif (loginResult.IsError)\n{\n    Debug.WriteLine($\"An error occurred during login: {loginResult.Error}\")\n}\n```\n\n### Accessing the tokens\n\nOn successful login, the login result will contain the ID Token and Access Token in the `IdentityToken` and `AccessToken` properties respectively.\n\n```\nvar loginResult = await client.LoginAsync();\n\nif (!loginResult.IsError)\n{\n    Debug.WriteLine($\"id_token: {loginResult.IdentityToken}\");\n    Debug.WriteLine($\"access_token: {loginResult.AccessToken}\");\n}\n```\n\n### Obtaining the User Information\n\nOn successful login, the login result will contain the user information in the `User` property, which is a [ClaimsPrincipal](https://msdn.microsoft.com/en-us/library/system.security.claims.claimsprincipal(v=vs.110).aspx).\n\nTo obtain information about the user, you can query the claims. You can, for example, obtain the user's name and email address from the `name` and `email` claims:\n\n```\nif (!loginResult.IsError)\n{\n    Debug.WriteLine($\"name: {loginResult.User.FindFirst(c => c.Type == \"name\")?.Value}\");\n    Debug.WriteLine($\"email: {loginResult.User.FindFirst(c => c.Type == \"email\")?.Value}\");\n}\n```\n\nYou can obtain a list of all the claims contained in the ID Token by iterating through the `Claims` collection:\n\n```\nif (!loginResult.IsError)\n{\n    foreach (var claim in loginResult.User.Claims)\n    {\n        Debug.WriteLine($\"{claim.Type} = {claim.Value}\");\n    }\n}\n```\n\n## Logout\n\nTo log the user out call the `LogoutAsync` method.\n\n```\nBrowserResultType browserResult = await client.LogoutAsync();\n```",
  "title": "Auth0 .NET Android and iOS SDK Quickstarts: Add login to your .NET Android or iOS application",
  "description": "This tutorial demonstrates how to add user login with Auth0 to a .NET Android or iOS application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/vanillajs",
  "markdown": "# Auth0 JavaScript SDK Quickstarts: Login\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n### Configure Allowed Web Origins\n\nYou need to add the URL for your app to the **Allowed Web Origins** field in your [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings). If you don't register your application URL here, the application will be unable to silently refresh the authentication tokens and your users will be logged out the next time they visit the application, or refresh the page.\n\n## Integrate Auth0 in your Application\n\nUse the [Auth0 SPA SDK](https://github.com/auth0/auth0-spa-js) library to integrate Auth0 into your application. You can either install the library as a dependency in your application, or load it from CDN.\n\n### Install as a dependency\n\nYou can install the Auth0 SPA SDK as a dependency of your application, useful if you're using a build system such as [Webpack](https://webpack.js.org/). You can do this using `npm` or `yarn`.\n\n```\n# installation with npm\nnpm install --save @auth0/auth0-spa-js\n\n# installation with yarn\nyarn add @auth0/auth0-spa-js\n```\n\nOnce the Auth0 SPA SDK is installed, reference it using an import statement at the entrypoint of your application ():\n\n```\nimport { createAuth0Client } from '@auth0/auth0-spa-js';\n```\n\n### Reference the CDN\n\nAlternatively, if you do not use a package manager such as Webpack, you can retrieve the Auth0 SPA SDK from Auth0's CDN.\n\n```\n<script src=\"https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js\"></script>\n```\n\n### Authentication with Auth0\n\n[Universal Login](https://auth0.com/docs/hosted-pages/login) is the easiest way to set up authentication in your application. We recommend using it for the best experience, best security and the fullest array of features. This guide will use it to provide a way for your users to log in to your JavaScript application.\n\nWhen a user logs in, Auth0 returns three items:\n\n*   `access_token`: to learn more, see the [Access Token documentation](https://auth0.com/docs/tokens/concepts/access-tokens)\n*   `id_token`: to learn more, see the [ID Token documentation](https://auth0.com/docs/tokens/concepts/id-tokens)\n*   `expires_in`: the number of seconds before the Access Token expires\n\nYou can use these items in your application to set up and manage authentication.\n\n## Setting Up the Application\n\n### Create a basic HTML page\n\nCreate a folder on your machine to house the application, then add an `index.html` file to the root of the project. This HTML page will display a welcome message and have a \"gated\" section which requires the user to be authenticated before accessing. You can copy/paste the following content into the file. You will be adding more lines as you progress with this article.\n\nAdd the following content to the `index.html` file you just created:\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>SPA SDK Sample</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"/css/main.css\" />\n  </head>\n\n  <body>\n    <h2>SPA Authentication Sample</h2>\n    <p>Welcome to our page!</p>\n    <button id=\"btn-login\" disabled=\"true\" onclick=\"login()\">Log in</button>\n    <button id=\"btn-logout\" disabled=\"true\" onclick=\"logout()\">Log out</button>\n  </body>\n</html>\n```\n\nAdditionally, create a new folder called `public`, a folder inside that called `css` and a new file in there called `main.css`. This will be used to define how the gated content elements will be hidden in the page.\n\nOpen the newly-created `public/css/main.css` file and add the following CSS:\n\n```\n.hidden {\n  display: none;\n}\n\nlabel {\n  margin-bottom: 10px;\n  display: block;\n}\n```\n\nFinally, create a new directory in the `public` folder called `js`, and a new file in there called `app.js`. This will house the application-specific logic that you will create over the next few sections.\n\nThe folder structure so far should look like the following:\n\n```\n.\n├── index.html\n└── public\n    ├── css\n    │   └── main.css\n    └── js\n        └── app.js\n```\n\n### Reference the SDK\n\nThis article is based on the new SPA SDK available [here](https://github.com/auth0/auth0-spa-js/). You can reference the package from the CDN in the `index.html` file by placing the script tags at the very bottom of the `body` tag:\n\n```\n<body>\n  \n  <!-- other HTML -->\n  \n  <!-- add the lines below existing code -->\n  <script src=\"https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js\"></script>\n  <script src=\"js/app.js\"></script>\n</body>\n```\n\n### Configure credentials\n\nCreate an `auth_config.json` in the root of the project. The values from `domain` and `clientId` should be populated from your [Auth0 application settings](https://manage.auth0.com/#/applications/{yourClientId}/settings) as configured [above](#get-your-application-keys).\n\n```\n{\n  \"domain\": \"{yourDomain}\",\n  \"clientId\": \"{yourClientId}\"\n}\n```\n\n## Create the server\n\nIn this section you will create a basic web server using [ExpressJS](https://expressjs.com/). This will be used to serve our HTML page, along with any assets that it requires (JavaScript, CSS, etc).\n\nRun the following command in the same folder as the `index.html` file you created earlier:\n\nThis will initialize a new NPM project and get us ready to install dependencies.\n\n### Installing dependencies\n\nIn the terminal, install the dependencies that are necessary to get the server up and running:\n\nAlso install [`nodemon`](https://npmjs.org/package/nodemon) so that our server can be restarted on any code changes:\n\nFinally, open the `package.json` file and modify the \"scripts\" entry to look like the following:\n\n```\n{\n  // ...\n  \"scripts\": {\n    \"start\": \"node server.js\",\n    \"dev\": \"nodemon server.js\"\n  },\n  // ...\n}\n```\n\n*   `npm start` will run the application as normal\n*   `npm run dev` will run the application using `nodemon`, watching for changes as we modify files\n\n### Creating server.js\n\nNext, create a new file in the root of the project alongside `index.html` and `package.json`, called `server.js`. This will be our backend server and will be used to serve the SPA pages.\n\nPopulate `server.js` with the following code:\n\n```\nconst express = require(\"express\");\nconst { join } = require(\"path\");\nconst app = express();\n\n// Serve static assets from the /public folder\napp.use(express.static(join(__dirname, \"public\")));\n\n// Endpoint to serve the configuration file\napp.get(\"/auth_config.json\", (req, res) => {\n  res.sendFile(join(__dirname, \"auth_config.json\"));\n});\n\n// Serve the index page for all other requests\napp.get(\"/*\", (_, res) => {\n  res.sendFile(join(__dirname, \"index.html\"));\n});\n\n// Listen on port 3000\napp.listen(3000, () => console.log(\"Application running on port 3000\"));\n```\n\nThe server provides two endpoints:\n\n*   one which serves the authentication configuration file to the client-side app\n*   another which serves every other request to the `index.html` file, which will provide support for any client-side routing as all routes go to the same page\n\nThe app also serves all of the static files, such as the `.js` and `.css` files from the `/public` folder.\n\n## Initialize the SDK\n\nThe SDK must be properly initialized with the information of the Auth0 application created above.\n\nTo start, open the `public/js/app.js` file and add a variable to hold the Auth0 client object:\n\nThis must be initialized using the values from the `auth_config.json` file. This can be done by calling the endpoint on the server that was created in the previous section. To do this, create a new function called `fetchAuthConfig` further down the `app.js` file, which can be used to download this information:\n\n```\n// ..\n\nconst fetchAuthConfig = () => fetch(\"/auth_config.json\");\n```\n\nNext, create another new function called `configureClient`. This will use `fetchAuthConfig` to download the configuration file and initialize the `auth0Client` variable:\n\n```\n// ..\n\nconst configureClient = async () => {\n  const response = await fetchAuthConfig();\n  const config = await response.json();\n\n  auth0Client = await auth0.createAuth0Client({\n    domain: config.domain,\n    clientId: config.clientId\n  });\n};\n```\n\nThis call will also populate the in-memory cache with a valid access token and user profile information if someone has already authenticated before and that session is still valid.\n\nAdd a handler for the `window.onload` function that will then make this call to initialize the application:\n\n```\n// ..\n\nwindow.onload = async () => {\n  await configureClient();\n}\n```\n\nNow go and access it at [http://localhost:3000](http://localhost:3000/). You should see the welcome message and both authentication buttons disabled. Note however that some browsers cache the page sources. When checking each step results you should perform a full page refresh ignoring the cache. This can be achieved by using the `CMD+SHIFT+R` keys on OSX and `CTRL+SHIFT+R` keys on Windows.\n\n### Restoring Login State with Social Providers\n\nUsers who are logged in with **username/password** will be silently reauthenticated automatically when the application reloads. No further action is needed for this type of login.\n\nIf you are using the [classic Universal Login experience](https://auth0.com/docs/universal-login/classic) and would like users to authenticate using **[social identity providers](https://auth0.com/docs/connections#social)** (such as Google, Apple, Facebook, etc.), then you will need to configure those connections in your [Auth0 Dashboard](https://manage.auth0.com/dashboard).\n\nIn the navigation menu, choose **Connections** - **Social**, and select the social connection you’d like to support. In the connection’s settings, click “How to obtain a Client ID?“ and follow the instructions to set up your own ID and secret.\n\nIf you are using the [new Universal Login experience](https://auth0.com/docs/universal-login/new), the default enabled social connections will silently reauthenticate without additional configuration. However, you should still set up your own keys and avoid using [default Auth0 development keys](https://auth0.com/docs/connections/social/devkeys#limitations-of-developer-keys) in a production app.\n\n## Evaluate the authentication state\n\nAs a first approach, you want to make sure anyone is able to visit the public page but not the page that is meant for authenticated users only, such as a settings panel or the user profile details. You can decide which content is available by hiding, disabling, or removing it if no user is currently logged in. You do so by checking the result of calling the `auth0Client.isAuthenticated()` method. Use this to enable or disable the **Log in** and **Log out** buttons, which are disabled by default. This can be part of a new `updateUI()` function called from the `window.onload` method right after the initialization.\n\nStill inside the `app.js` file, add a new function called `updateUI` and modify the `onload` handler to call this new function:\n\n```\n// ..\n\nwindow.onload = async () => {\n  await configureClient();\n\n  // NEW - update the UI state\n  updateUI();\n};\n\n// NEW\nconst updateUI = async () => {\n  const isAuthenticated = await auth0Client.isAuthenticated();\n\n  document.getElementById(\"btn-logout\").disabled = !isAuthenticated;\n  document.getElementById(\"btn-login\").disabled = isAuthenticated;\n};\n```\n\n> **Checkpoint:** If you run the project again, you should see that the \"Log in\" button is shown as enabled as no user has previously logged in. But clicking it will not do anything as there is no logic associated to that action yet.\n\n## Log In to the Application\n\nAuthentication is achieved through a redirect to the Auth0 [Universal Login Page](https://auth0.com/docs/hosted-pages/login). Once the user signs up or logs in, the result will be passed to your app's redirect URI, which is provided with the authorization request.\n\nInside the `app.js` file, provide a `login` function that calls `auth0Client.loginWithRedirect()` to perform the login step. The `login` function is called by the **Log in** button previously defined in the HTML page. In this sample, you will redirect the user back to the same page they are now. You can obtain that value from `window.location.origin` property:\n\n```\n// ..\n\nconst login = async () => {\n  await auth0Client.loginWithRedirect({\n    authorizationParams: {\n      redirect_uri: window.location.origin\n    }\n  });\n};\n```\n\nAdditionally, because this is a _single page application_, the result of this call needs to be handled in the same context. This means that when the page is loaded and the user is not authenticated you could be in one of the following two scenarios:\n\n1.  The user does not want to authenticate and is just navigating through public content or\n2.  The user has recently initiated the authentication process and is now looking to complete it.\n\nThis second scenario is the one you need to handle. In your `window.onload` method, check whether the user is authenticated or not, and if the URL query contains both a `code` and `state` parameter. This will indicate that an authentication result is present and needs to be parsed. In that scenario, you do so by calling the `auth0Client.handleRedirectCallback()` method. This will attempt to exchange the result that the Auth0 backend gave you back for real tokens you can use.\n\nIn addition, the query parameters must be removed from the URL so that if the user refreshes the page, the app does not try to parse the `state` and `code` parameters again. This is achieved with the `window.history.replaceState` method.\n\nModify the `window.onload` function inside `app.js` to include these changes:\n\n```\n// ..\n\nwindow.onload = async () => {\n\n  // .. code ommited for brevity\n\n  updateUI();\n\n  const isAuthenticated = await auth0Client.isAuthenticated();\n\n  if (isAuthenticated) {\n    // show the gated content\n    return;\n  }\n\n  // NEW - check for the code and state parameters\n  const query = window.location.search;\n  if (query.includes(\"code=\") && query.includes(\"state=\")) {\n\n    // Process the login state\n    await auth0Client.handleRedirectCallback();\n    \n    updateUI();\n\n    // Use replaceState to redirect the user away and remove the querystring parameters\n    window.history.replaceState({}, document.title, \"/\");\n  }\n};\n\n// ..\n```\n\nThe callback is now handled properly and the authentication can be completed successfully.\n\nRun the project and click the **Log in** button. You should be taken to the Universal Login Page configured for your application. Go ahead and create a new user or log in using a social connection. After authenticating successfully, you will be redirected to the page you were before. This time, the result will be present in the URL query and the exchange will happen automatically. If everything went fine, you will end up with no query parameters in the URL, the user would now be logged in and the \"Log out\" button will be enabled.\n\n## Log the User Out\n\nYou may have noticed that the **Log out** button is clickable when the user is authenticated, but does nothing. You need to add the code that will log the user out from the Auth0 backend.\n\nStart the log out by calling the `auth0Client.logout()` method passing a valid return-to URI. In this sample you will return the user back to the same page they are now. You can obtain that value from `window.location.origin` property. Abstract this logic into a `logout()` method.\n\n```\n// public/js/app.js\n\nconst logout = () => {\n  auth0Client.logout({\n    logoutParams: {\n      returnTo: window.location.origin\n    }\n  });\n};\n```\n\n> **Checkpoint:** Being authenticated click the **Log out** button. You should be taken to the Universal Login Page configured for your application and then back to the page you were before. Now the authentication cookies were cleared and the user is logged out. The \"Log in\" button will be enabled back again.\n\nIf you see any errors from the Auth0 server, check that you have not forgotten to register the logout URL as explained initially.\n\n## Read the User Profile\n\nEvery time a user is logged in you get access both to the **access token** and the **ID token**. The user's profile information is then extracted from the ID token. Typically, the token is used to call your backend application and the profile information is used to display their name and profile picture. In this section you are going to display them in separate text areas so you can easily inspect them.\n\nOpen the `index.html` file and insert the following lines at the bottom of the body.\n\n```\n<body>\n  <!-- ... -->\n\n  <div class=\"hidden\" id=\"gated-content\">\n    <p>\n      You're seeing this content because you're currently\n      <strong>logged in</strong>.\n    </p>\n    <label>\n      Access token:\n      <pre id=\"ipt-access-token\"></pre>\n    </label>\n    <label>\n      User profile:\n      <pre id=\"ipt-user-profile\"></pre>\n    </label>\n  </div>\n  \n  <!-- .. existing script tags .. -->\n</body>\n```\n\nNow re-open the `app.js` file and modify the `updateUI()` function declared previously. Add the logic such that when the user is logged in the gated content is shown. Use the existing variables and functions from the SDK client to obtain and display this information on the page.\n\nIn addition, at the start of this article you added a `public/css/main.css` file with the definition of the `hidden` class, which can be used to easily hide elements on the page. Using the authenticated flag as shown below, add or remove this class to the elements you want to show or hide in the `updateUI()` function:\n\n```\n// ...\n\nconst updateUI = async () => { \n  const isAuthenticated = await auth0Client.isAuthenticated();\n\n  document.getElementById(\"btn-logout\").disabled = !isAuthenticated;\n  document.getElementById(\"btn-login\").disabled = isAuthenticated;\n  \n  // NEW - add logic to show/hide gated content after authentication\n  if (isAuthenticated) {\n    document.getElementById(\"gated-content\").classList.remove(\"hidden\");\n\n    document.getElementById(\n      \"ipt-access-token\"\n    ).innerHTML = await auth0Client.getTokenSilently();\n\n    document.getElementById(\"ipt-user-profile\").textContent = JSON.stringify(\n      await auth0Client.getUser()\n    );\n\n  } else {\n    document.getElementById(\"gated-content\").classList.add(\"hidden\");\n  }\n};\n\n// ..\n```\n\nNote that calls to the SDK instance can throw an exception if the authentication fails, if there is no user currently authenticated, or if the access token needs to be refreshed and that request fails. You will need to put a try/catch block around them to correctly handle any errors. These error checks are not shown on the article but they are available on the final sample app that you can download.\n\n> **Checkpoint:** Go ahead and run the project for the last time. Now if the user is authenticated you will get to see their access token and profile data. See how this content disappears when you log out.",
  "title": "Auth0 JavaScript SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to a Javascript application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/flutter",
  "markdown": "# Add login to your Flutter app\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Single-Page App](https://auth0.com/docs/quickstart/spa)\n*   [Flutter (Web)](https://auth0.com/docs/quickstart/spa/flutter)\n\n## Flutter (Web)\n\nThis tutorial demonstrates how to add user login with Auth0 to an Flutter Web application using the Auth0 Flutter SDK We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Flutter 3+ | Xcode 14+ (for iOS) | Android Studio 4+ (for Android)\n\nAuth0 allows you to quickly add authentication and access user profile information in your application. This guide demonstrates how to integrate Auth0 with a Flutter Web application using the [Auth0 Flutter SDK](https://github.com/auth0/auth0-flutter).\n\n## Getting started\n\nThis quickstart assumes you already have a [Flutter](https://flutter.dev/) application up and running. If not, check out the [Flutter \"getting started\" guides](https://docs.flutter.dev/get-started/install) to get started with a simple app.\n\nYou should also be familiar with the [Flutter command line tool](https://docs.flutter.dev/reference/flutter-cli).\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n### Configure Allowed Web Origins\n\nYou need to add the URL for your app to the **Allowed Web Origins** field in your [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings). If you don't register your application URL here, the application will be unable to silently refresh the authentication tokens and your users will be logged out the next time they visit the application, or refresh the page.\n\n## Install the Auth0 Flutter SDK\n\nAdd the Auth0 Flutter SDK into the project:\n\n```\nflutter pub add auth0_flutter\n```\n\nAdd the following script tag to your `index.html` page:\n\n```\n<script src=\"https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js\" defer></script>\n```\n\n## Add login to your app\n\n[Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) is the easiest way to set up authentication in your application. We recommend using it for the best experience, best security, and the fullest array of features.\n\nIntegrate Auth0 Universal Login in your Flutter app by importing the SDK and instantiating the `Auth0` class using your Auth0 domain and Client ID values. See this example, which instantiates the class inside a widget state object:\n\n```\nimport 'package:auth0_flutter/auth0_flutter.dart';\nimport 'package:auth0_flutter/auth0_flutter_web.dart';\n\nclass MainView extends StatefulWidget {\n  const MainView({Key? key}) : super(key: key);\n\n  @override\n  State<MainView> createState() => _MainViewState();\n}\n\nclass _MainViewState extends State<MainView> {\n  Credentials? _credentials;\n\n  late Auth0Web auth0;\n\n  @override\n  void initState() {\n    super.initState();\n    auth0 = Auth0Web('{yourDomain}', '{yourClientId}');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // ...\n  }\n}\n```\n\nNext, redirect your users to the Auth0 Universal Login page using `loginWithRedirect`. See this example of a `ElevatedButton` widget that logs the user in when clicked:\n\n```\nif (_credentials == null) {\n  ElevatedButton(\n    onPressed: () => auth0.loginWithRedirect(redirectUrl: 'http://localhost:3000'),\n    child: const Text(\"Log in\")\n  )\n}\n```\n\nWhen a user logs in, they are redirected back to your application. You are then able to access the ID and access tokens for this user by calling `onLoad` during startup and handling the credentials that are given to you:\n\n```\nauth0.onLoad().then((final credentials) => setState(() {\n    // Handle or store credentials here\n    _credentials = credentials;\n  }));\n```\n\n##### Checkpoint\n\nAdd a button to your app that calls `loginWithRedirect()` and logs the user into your app. Verify that you are redirected to Auth0 for authentication and then back to your application.\n\nVerify that you can access `credentials` as a result of calling `onLoad` and that you're able to access the ID and access tokens.\n\n## Add logout to your app\n\nTo log users out, redirect them to the Auth0 logout endpoint to clear their login session by calling the Auth0 Flutter SDK `logout()`. [Read more about logging out of Auth0](https://auth0.com/docs/authenticate/login/logout).\n\nSee this example of an `ElevatedButton` widget that logs the user out of the app:\n\n```\nElevatedButton(\n  onPressed: () async {\n    await auth0.logout();\n  },\n  child: const Text(\"Log out\"))\n```\n\n##### Checkpoint\n\nAdd a button to your app that calls `logout()` and logs the user out of your application. When you select it, verify that your Flutter app redirects you to the logout endpoint and back again. You should not be logged in to your application.\n\n## Show user profile information\n\nThe user profile automatically retrieves user profile properties for you when the page loads, and can be accessed and stored by calling `onLoad` during application startup. The returned object from `onLoad` contains a `user` property with all the user profile properties. This is internally populated by decoding the ID token.\n\nSee this example of a `View` component that displays the user profile on the screen:\n\n```\nimport 'package:auth0_flutter/auth0_flutter.dart';\nimport 'package:flutter/material.dart';\n\nclass ProfileView extends StatelessWidget {\n  const ProfileView({Key? key, required this.user}) : super(key: key);\n\n  final UserProfile user;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        if (user.name != null) Text(user.name!),\n        if (user.email != null) Text(user.email!)\n      ],\n    );\n  }\n}\n```\n\n##### Checkpoint\n\nLog in and inspect the `user` property on the result. Verify the current user's profile information, such as `email` or `name`.",
  "title": "Auth0 Flutter (Web) SDK Quickstarts: Add login to your Flutter app",
  "description": "This tutorial demonstrates how to add user login with Auth0 to an Flutter Web application using the Auth0 Flutter SDK",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock-android",
  "markdown": "# Lock.Android: Get Started\n\nLock for Android can integrate into your native Android apps to provide a beautiful way to log your users in and to sign them up in your app. It provides support for social identity providers such as Facebook, Google, or Twitter, as well as enterprise providers such as Active Directory.\n\nCheck out the [Lock.Android repository](https://github.com/auth0/Lock.Android) on GitHub.\n\n## Requirements\n\nTo use Lock's UI or your own UI via the [Auth0.Android library](https://github.com/auth0/Auth0.Android) the minimum required Android API level is 21+ and Java version 8 or above. You will also require an Auth0 application of type \"Native\".\n\nHere’s what you need in `build.gradle` to target Java 8 byte code for the Android and Kotlin plugins respectively.\n\n```\nandroid {\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n}\n```\n\n## Installation\n\nLock is available in [Maven Central](http://search.maven.org/). To start using Lock add these lines to your `build.gradle` dependencies file:\n\n`implementation 'com.auth0.android:lock:3.+'`\n\nYou can check for the latest version on the repository [Readme](https://github.com/auth0/Lock.Android#install) or in [Maven](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22lock%22%20g%3A%22com.auth0.android%22).\n\nAfter adding your Gradle dependency, remember to sync your project with Gradle files.\n\n## Dashboard settings\n\nYou need to fill in a few settings in your [Auth0 Dashboard](https://manage.auth0.com/#) before you get started.\n\n### Callback URL\n\nHead over to your Auth0 Dashboard and go to the application's settings. Add the following URL to the application's **Allowed Callback URLs**:\n\n`https://{yourDomain}/android/{yourAppPackageName}/callback`\n\nReplace `{yourAppPackageName}` with your actual application's package name, available in your `app/build.gradle` file as the `applicationId` value.\n\n### Keystores and key hashes\n\nAndroid applications need to be signed before they can be installed on a device. For this purpose, the Android Studio IDE the first time it runs generates a default \"Android Debug Keystore\" that it will use to sign development builds. This [Keystore](https://developer.android.com/studio/publish/app-signing) will probably be different for your production build, as it will be used to identify you as the developer.\n\nWhen using the Web Authentication feature (i.e. social connections), Lock will be set up by default to attempt to use Android App Links. This requires an additional setting in the Auth0 application's dashboard. Use our [Android Keystores and Key Hashes Guide](https://auth0.com/docs/libraries/auth0-android/android-development-keystores-hashes) to complete this step.\n\nThe following instructions discuss implementing Classic Lock for Android. If you specifically are looking to implement Passwordless Lock for Android, see [Lock.Android: Passwordless](https://auth0.com/docs/libraries/lock-android/lock-android-passwordless).\n\n### Configuring the SDK\n\nIn your `app/build.gradle` file add the [Manifest Placeholders](https://developer.android.com/studio/build/manifest-build-variables.html) for the Auth0 Domain and the Auth0 Scheme properties, which are going to be used internally by the library to register an intent-filter that captures the authentication result.\n\n```\nplugins {\n    id \"com.android.application\"\n    id \"kotlin-android\"\n}\n\nandroid {\n    compileSdkVersion 30\n    defaultConfig {\n        applicationId \"com.auth0.samples\"\n        minSdkVersion 21\n        targetSdkVersion 30\n        // ...\n\n        // ---> Add the next line\n        manifestPlaceholders = [auth0Domain: \"@string/com_auth0_domain\", auth0Scheme: \"https\"]\n        // <---\n    }\n}\n```\n\nIt's good practice to add these values to the `strings.xml` file as string resources that can be referenced later from the code. This guide will follow that practice.\n\n```\n<resources>\n    <string name=\"com_auth0_client_id\">{yourClientId}</string>\n    <string name=\"com_auth0_domain\">{yourDomain}</string>\n</resources>\n```\n\n### SDK usage\n\nIn the activity where you plan to invoke Lock, create an instance of `Auth0` with your application's information. The easiest way to create it is by passing an Android Context. This will use the values previously defined in the `strings.xml` file. For this to work, the string resources must be defined using the same keys as the ones listed above.\n\n```\nval account = Auth0(context)\n```\n\nDeclare an `AuthenticationCallback` implementation that will handle user authentication events. The `Credentials` object returned in successful authentication scenarios will contain the tokens that your application or API will end up consuming. See [Tokens](https://auth0.com/docs/secure/tokens) for more specifics.\n\n```\nprivate val callback = object : AuthenticationCallback() {\n    override fun onAuthentication(credentials: Credentials) {\n        // Authenticated\n    }\n\n    override fun onError(error: AuthenticationException) {\n        // Exception occurred\n    }\n}\n```\n\nPrepare a new Lock instance by using the Builder class to configure it. Provide the account details and the callback implementation declared above. Values like audience, scope, and available connections can be configured here.\n\nWhen done, build the Lock instance. This instance is meant to be reused and must be disposed of when it is no longer needed. A good place to do this is in your activity's `onDestroy` method.\n\n```\n// This activity will show Lock\nclass MyActivity : AppCompatActivity() {\n\n    private lateinit var lock: Lock\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val account = Auth0(this)\n        // Instantiate Lock once\n        lock = Lock.newBuilder(account, callback)\n            // Customize Lock\n            .build(this)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        // Important! Release Lock and its resources\n        lock.onDestroy(this)\n    }\n\n    private val callback = object : AuthenticationCallback() {\n        override fun onAuthentication(credentials: Credentials) {\n            // Authenticated\n        }\n\n        override fun onError(error: AuthenticationException) {\n            // An exception occurred\n        }\n    }\n}\n```\n\nFinally, launch the `Lock` widget from inside your activity.\n\n```\nstartActivity(lock.newIntent(this))\n```\n\nThat's it! Lock will handle the rest for you.\n\n#### Android App Links - Custom Scheme\n\nThe Callback URI scheme used in this article and by default by Lock is `https`. This works best for Android Marshmallow (API 23) or newer if you're using [Android App Links](https://developer.android.com/training/app-links), but in previous Android versions, this may show the intent chooser dialog prompting the user to chose either your application or the browser to resolve the intent. This is called the \"disambiguation dialog\". You can change this behavior by using a custom unique scheme so that the OS opens the link directly with your app.\n\n1.  Update the `auth0Scheme` Manifest Placeholder value in the `app/build.gradle` file or directly in the Intent Filter definition in the `AndroidManifest.xml` file by changing the existing scheme to the new one.\n    \n2.  Update the \"Allowed Callback URLs\" in your Auth0 Dashboard Application's settings to match URLs that begin with the new scheme.\n    \n3.  Call `withScheme()` when configuring Lock with the builder, passing the scheme you want to use.\n    \n\n## Lock configuration\n\nFor a full list of Lock's configuration options, check out [Lock.Android: Configuration](https://auth0.com/docs/libraries/lock-android/lock-android-configuration).\n\n## Error messages\n\nFor descriptions of common error messages, check out the [Error Messages](https://auth0.com/docs/troubleshoot/basic-issues/check-error-messages) page. Also, if your callback receives an `AuthenticationException` you can check [source](https://github.com/auth0/Auth0.Android/blob/main/auth0/src/main/java/com/auth0/android/authentication/AuthenticationException.kt) to learn how to identify each error scenario.\n\n## Learn more\n\n*   [Lock.Android: Custom Theming](https://auth0.com/docs/libraries/lock-android/lock-android-custom-theming)\n*   [Lock.Android: Configuration](https://auth0.com/docs/libraries/lock-android/lock-android-configuration)\n*   [Lock.Android: Custom Fields at Signup](https://auth0.com/docs/libraries/lock-android/lock-android-custom-fields-at-signup)\n*   [Lock.Android Internationalization](https://auth0.com/docs/customize/internationalization-and-localization/lock-android-internationalization)\n*   [Logout](https://auth0.com/docs/authenticate/login/logout)",
  "title": "Lock.Android: Get Started",
  "description": "Get started with Lock for Android, a widget that provides a frictionless login and signup experience for your native Android apps.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/react",
  "markdown": "# Auth0 React SDK Quickstarts: Login\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Single-Page App](https://auth0.com/docs/quickstart/spa)\n*   [React](https://auth0.com/docs/quickstart/spa/react)\n*   [Login](https://auth0.com/docs/quickstart/spa/react/01-login)\n\nAuth0 allows you to add authentication to your React application quickly and to gain access to user profile information. This guide demonstrates how to integrate Auth0 with any new or existing React application using the Auth0 React SDK. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: React 18\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n### Configure Allowed Web Origins\n\nYou need to add the URL for your app to the **Allowed Web Origins** field in your [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings). If you don't register your application URL here, the application will be unable to silently refresh the authentication tokens and your users will be logged out the next time they visit the application, or refresh the page.\n\n## Install the Auth0 React SDK\n\nRun the following command within your project directory to install the Auth0 React SDK:\n\n```\nnpm install @auth0/auth0-react\n```\n\nThe SDK exposes methods and variables that help you integrate Auth0 with your React application idiomatically using [React Hooks](https://reactjs.org/docs/hooks-overview.html) or [Higher-Order Components](https://reactjs.org/docs/higher-order-components.html).\n\n### Configure the Auth0Provider component\n\nUnder the hood, the Auth0 React SDK uses [React Context](https://reactjs.org/docs/context.html) to manage the authentication state of your users. One way to integrate Auth0 with your React app is to wrap your root component with an `Auth0Provider` that you can import from the SDK.\n\n```\nimport React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport { Auth0Provider } from '@auth0/auth0-react';\nimport App from './App';\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(\n<Auth0Provider\n    domain=\"{yourDomain}\"\n    clientId=\"{yourClientId}\"\n    authorizationParams={{\n      redirect_uri: window.location.origin\n    }}\n  >\n    <App />\n  </Auth0Provider>,\n);\n```\n\nThe `Auth0Provider` component takes the following props:\n\n*   `domain` and `clientId`: The values of these properties correspond to the \"Domain\" and \"Client ID\" values present under the \"Settings\" of the single-page application that you registered with Auth0.\n\n*   `authorizationParams.redirect_uri`: The URL to where you'd like to redirect your users after they authenticate with Auth0.\n\n`Auth0Provider` stores the authentication state of your users and the state of the SDK — whether Auth0 is ready to use or not. It also exposes helper methods to log in and log out your users, which you can access using the `useAuth0()` hook.\n\n### Checkpoint\n\nNow that you have configured `Auth0Provider`, run your application to verify that the SDK is initializing correctly, and your application is not throwing any errors related to Auth0.\n\n## Add Login to Your Application\n\nThe Auth0 React SDK gives you tools to quickly implement user authentication in your React application, such as creating a [login](https://auth0.com/docs/login) button using the `loginWithRedirect()` method from the `useAuth0()` hook. Executing `loginWithRedirect()` redirects your users to the Auth0 Universal Login Page, where Auth0 can authenticate them. Upon successful authentication, Auth0 will redirect your users back to your application.\n\n```\nimport React from \"react\";\nimport { useAuth0 } from \"@auth0/auth0-react\";\n\nconst LoginButton = () => {\n  const { loginWithRedirect } = useAuth0();\n\n  return <button onClick={() => loginWithRedirect()}>Log In</button>;\n};\n\nexport default LoginButton;\n```\n\n### Checkpoint\n\nAdd the `LoginButton` component to your application. When you click it, verify that your React application redirects you to the [Auth0 Universal Login](https://auth0.com/universal-login) page and that you can now log in or sign up using a username and password or a social provider.\n\nOnce that's complete, verify that Auth0 redirects you to your application using the value of the `authorizationParams.redirect_uri` that you used to configure the `Auth0Provider`.\n\n![Auth0 Universal Login](https://auth0.com/docs/media/quickstarts/universal-login.png)\n\n## Add Logout to Your Application\n\nNow that you can log in to your React application, you need [a way to log out](https://auth0.com/docs/logout/guides/logout-auth0). You can create a logout button using the `logout()` method from the `useAuth0()` hook. Executing `logout()` redirects your users to your [Auth0 logout endpoint](https://auth0.com/docs/api/authentication?javascript#logout) (`https://YOUR_DOMAIN/v2/logout`) and then immediately redirects them to your application.\n\n```\nimport React from \"react\";\nimport { useAuth0 } from \"@auth0/auth0-react\";\n\nconst LogoutButton = () => {\n  const { logout } = useAuth0();\n\n  return (\n    <button onClick={() => logout({ logoutParams: { returnTo: window.location.origin } })}>\n      Log Out\n    </button>\n  );\n};\n\nexport default LogoutButton;\n```\n\n### Checkpoint\n\nAdd the `LogoutButton` component to your application. When you click it, verify that your React application redirects you the address you specified as one of the \"Allowed Logout URLs\" in the \"Settings\" and that you are no longer logged in to your application.\n\n## Show User Profile Information\n\nThe Auth0 React SDK helps you retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with logged-in users quickly in whatever component you need, such as their name or profile picture, to personalize the user interface. The profile information is available through the `user` property exposed by the `useAuth0()` hook. Take this `Profile` component as an example of how to use it:\n\n```\nimport React from \"react\";\nimport { useAuth0 } from \"@auth0/auth0-react\";\n\nconst Profile = () => {\n  const { user, isAuthenticated, isLoading } = useAuth0();\n\n  if (isLoading) {\n    return <div>Loading ...</div>;\n  }\n\n  return (\n    isAuthenticated && (\n      <div>\n        <img src={user.picture} alt={user.name} />\n        <h2>{user.name}</h2>\n        <p>{user.email}</p>\n      </div>\n    )\n  );\n};\n\nexport default Profile;\n```\n\nThe `user` property contains sensitive information and artifacts related to the user's identity. As such, its availability depends on the user's authentication status. To prevent any render errors, use the `isAuthenticated` property from `useAuth0()` to check if Auth0 has authenticated the user before React renders any component that consumes the `user` property. Ensure that the SDK has completed loading before accessing the `isAuthenticated` property, by checking that `isLoading` is `false`.\n\n### Checkpoint\n\nVerify that you can display the `user.name` or [any other `user` property](https://auth0.com/docs/users/references/user-profile-structure#user-profile-attributes) within a component correctly after you have logged in.",
  "title": "Auth0 React SDK Quickstarts: Login",
  "description": "Auth0 allows you to add authentication to your React application quickly and to gain access to user profile information. This guide demonstrates how to integrate Auth0 with any new or existing React application using the Auth0 React SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock-swift",
  "markdown": "# Lock.swift\n\nThis reference guide will show you how to implement the Lock user interface, and give you the details on configuring and customizing Lock in order to use it as the UI for your authentication needs. However, if you'd like to learn how to do more with Auth0 and Swift, such as how to save, call and refresh Access Tokens, get user profile info, and more, check out the [Auth0.swift SDK](https://auth0.com/docs/libraries/auth0-swift). Or, take a look at the [Swift Quickstart](https://auth0.com/docs/quickstart/native/ios-swift) to walk through complete examples and see options, both for using Lock as the interface, and for using a custom interface.\n\nCheck out the [Lock.swift repository](https://github.com/auth0/Lock.swift) on GitHub.\n\n## Requirements\n\n*   iOS 9+\n    \n*   Xcode 11.4+ / 12.x\n    \n*   Swift 4.x / 5.x\n    \n\n## Install\n\n### Cocoapods\n\nIf you are using [Cocoapods](https://cocoapods.org/), add this line to your `Podfile`:\n\n`pod 'Lock', '~> 2.0'`\n\nThen run `pod install`. For more information on Cocoapods, check [their official documentation](https://guides.cocoapods.org/using/getting-started.html).\n\n### Carthage\n\nIf you are using [Carthage](https://github.com/Carthage/Carthage), add the following line to your `Cartfile`:\n\n`github \"auth0/Lock.swift\" ~> 2.0` Then run `carthage bootstrap`. For more information about Carthage usage, check [their official documentation](https://github.com/Carthage/Carthage#if-youre-building-for-ios-tvos-or-watchos).\n\n### SPM\n\nIf you are using the Swift Package Manager, open the following menu item in Xcode:\n\n**File > Swift Packages > Add Package Dependency...**\n\nIn the **Choose Package Repository** prompt add this url:\n\n`https://github.com/auth0/Lock.swift.git`\n\nThen press **Next** and complete the remaining steps.\n\n## Set up\n\n### Integrate with your Application\n\nLock needs to be notified when the application is asked to open a URL. You can do this in the `AppDelegate` file.\n\n```\nfunc application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {\n  return Lock.resumeAuth(url, options: options)\n}\n```\n\n### Import Lock\n\nImport **Lock** wherever you'll need it\n\n`import lock`\n\n### Auth0 Credentials\n\nIn order to use Lock you need to provide your Auth0 Client Id and Domain, which can be found in your [Auth0 Dashboard](https://manage.auth0.com/#), under your Application's settings.\n\nIn your application bundle you can add a `plist` file named `Auth0.plist` that will include your credentials with the following format.\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n  <key>ClientId</key>\n  <string>{yourClientId}</string>\n  <key>Domain</key>\n  <string>{yourDomain}</string>\n</dict>\n</plist>\n```\n\n## Implementation of Lock Classic\n\nLock Classic handles authentication using Database, Social, and Enterprise connections.\n\n### OIDC Conformant Mode\n\nIt is strongly encouraged that this SDK be used in OIDC Conformant mode. When this mode is enabled, it will force the SDK to use Auth0's current authentication pipeline and will prevent it from reaching legacy endpoints. By default this is `false`\n\n```\n.withOptions {\n    $0.oidcConformant = true\n}\n```\n\nTo show Lock, add the following snippet in your UIViewController.\n\n```\nLock\n    .classic()\n    // withConnections, withOptions, withStyle, and so on\n    .withOptions {\n      $0.oidcConformant = true\n      $0.scope = \"openid profile\"\n    }\n    .onAuth { credentials in\n      // Let's save our credentials.accessToken value\n    }\n    .present(from: self)\n```\n\n## Use Auth0.Swift Library to access user profile\n\nTo access user profile information, you will need to use the `Auth0.Swift` library:\n\n```\nAuth0\n   .authentication()\n   .userInfo(withAccessToken: accessToken)\n   .start { result in\n       switch result {\n       case .success(let profile):\n           print(\"User Profile: \\(profile)\")\n       case .failure(let error):\n           print(\"Failed with \\(error)\")\n       }\n   }\n```\n\nCheck out the [Auth0.Swift Library Documentation](https://auth0.com/docs/libraries/auth0-swift) for more information about its uses.\n\n## Specify Connections\n\nLock will automatically load the connections configured for your application. If you wish to override the default behavior, you can manually specify which connections it should display to users as authentication options. This can be done by calling the method and supplying a closure that can specify the connection(s).\n\nAdding a database connection:\n\n```\n.withConnections {\n    connections.database(name: \"Username-Password-Authentication\", requiresUsername: true)\n}\n```\n\nAdding multiple social connections:\n\n```\n.withConnections {\n    connections.social(name: \"facebook\", style: .Facebook)\n    connections.social(name: \"google-oauth2\", style: .Google)\n}\n```\n\n## Styling and Customization\n\nLock provides many styling options to help you apply your own brand identity to Lock using `withStyle`. For example, changing the primary color and header text of your Lock widget:\n\n### Customize your title, logo, and primary color\n\n```\n.withStyle {\n  $0.title = \"Company LLC\"\n  $0.logo = LazyImage(named: \"company_logo\")\n  $0.primaryColor = UIColor(red: 0.6784, green: 0.5412, blue: 0.7333, alpha: 1.0)\n}\n```\n\nYou can see the complete set of styling options to alter the appearance of Lock for your app in the [Customization Guide](https://auth0.com/docs/libraries/lock-swift/lock-swift-customization).\n\n## Configuration Options\n\nThere are numerous options to configure Lock's behavior. Below is an example of Lock configured to allow it to be closable, to limit it to only usernames (and not emails), and to only show the Login and Reset Password screens.\n\n```\nLock\n  .classic()\n  .withOptions {\n    $0.closable = true\n    $0.usernameStyle = [.Username]\n    $0.allow = [.Login, .ResetPassword]\n  }\n```\n\nYou can see the complete set of behavior configuration options to alter the way Lock works for your app in the [Configuration Guide](https://auth0.com/docs/libraries/lock-swift/lock-swift-configuration-options).\n\n## Password Manager Support\n\nBy default, password manager support using [1Password](https://1password.com/) is enabled for database connections. 1Password support will still require the user to have the 1Password app installed for the option to be visible in the login and signup screens. You can disable 1Password support using the enabled property of the passwordManager.\n\n```\n.withOptions {\n    $0.passwordManager.enabled = false\n}\n```\n\nBy default the `appIdentifier` will be set to the app's bundle identifier and the `displayName` will be set to the app's display name. You can customize these as follows:\n\n```\n.withOptions {\n    $0.passwordManager.appIdentifier = \"www.myapp.com\"\n    $0.passwordManager.displayName = \"My App\"\n}\n```\n\nYou will need to add the following to your app's `info.plist`:\n\n```\n<key>LSApplicationQueriesSchemes</key>\n<array>\n    <string>org-appextension-feature-password-management</string>\n</array>\n```\n\n## Learn more\n\n*   [Lock.swift: Style Customization Options](https://auth0.com/docs/libraries/lock-swift/lock-swift-customization)\n*   [Lock.swift: Configuration Options](https://auth0.com/docs/libraries/lock-swift/lock-swift-configuration-options)\n*   [Lock.swift: Custom Fields at Signup](https://auth0.com/docs/libraries/lock-swift/lock-swift-custom-fields-at-signup)\n*   [Lock.swift Internationalization](https://auth0.com/docs/customize/internationalization-and-localization/lock-swift-internationalization)\n*   [Logout](https://auth0.com/docs/authenticate/login/logout)",
  "title": "Lock.swift",
  "description": "A widget that provides a frictionless login and signup experience for your native iOS apps.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/vuejs",
  "markdown": "# Auth0 Vue SDK Quickstarts: Login\n\nThis quickstart demonstrates how to add user login to a Vue.JS application using Auth0. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Vue 3+\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n### Configure Allowed Web Origins\n\nYou need to add the URL for your app to the **Allowed Web Origins** field in your [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings). If you don't register your application URL here, the application will be unable to silently refresh the authentication tokens and your users will be logged out the next time they visit the application, or refresh the page.\n\n## Install the SDK\n\nInstall the [Auth0 Vue SDK](https://github.com/auth0/auth0-vue) using npm:\n\n```\nnpm install @auth0/auth0-vue\n```\n\n### Register the plugin\n\nTo use the SDK in your Vue application, register the plugin with your Vue application by passing the return value of `createAuth0` to `app.use()`.\n\n```\nimport { createAuth0 } from '@auth0/auth0-vue';\n\nconst app = createApp(App);\n\napp.use(\n  createAuth0({\n    domain: \"{yourDomain}\",\n    clientId: \"{yourClientId}\",\n    authorizationParams: {\n      redirect_uri: window.location.origin\n    }\n  })\n);\n\napp.mount('#app');\n```\n\nThe plugin will register the SDK using both `provide` and `app.config.globalProperties`, allowing the SDK to be used with both the [Composition API](https://v3.vuejs.org/guide/composition-api-introduction.html) and [Options API](https://vuejs.org/guide/introduction.html#options-api).\n\n## Add Login to Your Application\n\nTo add login to your application, use the `loginWithRedirect` function that is exposed on the return value of `useAuth0`, which you can access in your component's `setup` function.\n\n```\n<template>\n  <div>\n    <button @click=\"login\">Log in</button>\n  </div>\n</template>\n<script>\n  import { useAuth0 } from '@auth0/auth0-vue';\n\n  export default {\n    setup() {\n      const { loginWithRedirect } = useAuth0();\n\n      return {\n        login: () => {\n          loginWithRedirect();\n        }\n      };\n    }\n  };\n</script>\n```\n\nThe `loginWithRedirect` function will redirect the user to Auth0, and redirect them back to the `redirect_uri` (provided when calling `createAuth0()`) after entering their credentials.\n\n#### Using the Options API\n\nIf you are using the Options API, you can use the same `loginWithRedirect` method from the global `$auth0` property through the `this` accessor.\n\n```\n<template>\n  <div>\n    <button @click=\"login\">Log in</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    methods: {\n      login() {\n        this.$auth0.loginWithRedirect();\n      }\n    }\n  };\n</script>\n```\n\n## Add Logout to Your Application\n\nUse the `logout` function that is exposed on the return value of `useAuth0`, which you can access in your component's `setup` function, to log the user out of your application.\n\n```\n<template>\n  <div>\n    <button @click=\"logout\">Log out</button>\n  </div>\n</template>\n<script>\n  import { useAuth0 } from '@auth0/auth0-vue';\n\n  export default {\n    setup() {\n      const { logout } = useAuth0();\n\n      return {\n        logout: () => {\n          logout({ logoutParams: { returnTo: window.location.origin } });\n        }\n      };\n    }\n  };\n</script>\n```\n\nThe `logout()` function will redirect the user to Auth0 to ensure their session is ended with Auth0 as well. Once the user is logged out successfully, they will be redirected back to the specified `returnTo` parameter.\n\n#### Using the Options API\n\nIf you're using the Options API, you can use the same `logout` method from the global `$auth0` property through the `this` accessor.\n\n```\n<template>\n  <div>\n    <button @click=\"logout\">Log out</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    methods: {\n      logout() {\n        this.$auth0.logout({ logoutParams: { returnTo: window.location.origin } });\n      }\n    }\n  };\n</script>\n```\n\n## Show User Profile Information\n\nOnce the user authenticates, the SDK extracts the user's profile information and stores it in memory. It can be accessed by using the reactive `user` property exposed by the return value of `useAuth0`, which you can access in your component's `setup` function.\n\n```\n<template>\n  <div>\n    <h2>User Profile</h2>\n    <button @click=\"login\">Log in</button>\n    <pre v-if=\"isAuthenticated\">\n        <code>{{ user }}</code>\n      </pre>\n  </div>\n</template>\n<script>\n  import { useAuth0 } from '@auth0/auth0-vue';\n\n  export default {\n    setup() {\n      const { loginWithRedirect, user, isAuthenticated } = useAuth0();\n\n      return {\n        login: () => {\n          loginWithRedirect();\n        },\n        user,\n        isAuthenticated\n      };\n    }\n  };\n</script>\n```\n\n#### Using the Options API\n\nIf you're using the Options API, you can use the same reactive `user` property from the global `$auth0` property through the `this` accessor.\n\n```\n<template>\n  <div>\n    <h2>User Profile</h2>\n    <button @click=\"login\">Log in</button>\n    <pre>\n      <code>{{ user }}</code>\n    </pre>\n  </div>\n</template>\n\n<script>\n  export default {\n    data: function () {\n      return {\n        user: this.$auth0.user\n      };\n    },\n    methods: {\n      login() {\n        this.$auth0.loginWithRedirect();\n      }\n    }\n  };\n</script>\n```",
  "title": "Auth0 Vue SDK Quickstarts: Login",
  "description": "This quickstart demonstrates how to add user login to a Vue.JS application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/aspnet-core-blazor-server",
  "markdown": "# Auth0 ASP.NET Core Blazor Server SDK Quickstarts: Add Login to your ASP.NET Core Blazor Server application\n\nThis tutorial demonstrates how to add user login to an ASP.NET Core Blazor Server application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nThe Callback URL of your application is the URL where Auth0 will redirect to after the user has authenticated in order for the SDK to complete the authentication process.\n\nYou will need to add this URL to the list of Allowed URLs for your application in your [Application Settings](https://manage.auth0.com/#/applications), this URL will mostly take the format `https://YOUR_APPLICATION_URL/callback`.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Integrate Auth0\n\n[Universal Login](https://auth0.com/docs/hosted-pages/login) is the easiest way to set up authentication in your application. We recommend using it for the best experience, security, and the most complete array of features. This guide uses Universal Login to provide a way for your users to log in to your Blazor Server application.\n\n### Install dependencies\n\nTo integrate Auth0 with Blazor Server you can use our SDK by installing the `Auth0.AspNetCore.Authentication` Nuget package to your application.\n\n```\nInstall-Package Auth0.AspNetCore.Authentication\n```\n\n### Install and configure the SDK\n\nTo enable authentication in your Blazor Server application, use the middleware provided by the SDK. Go to the `Program.cs` file and call `builder.Services.AddAuth0WebAppAuthentication()` to configure the Auth0 ASP.NET Core SDK.\n\nEnsure to configure the `Domain` and `ClientId`, these are required fields to ensure the SDK knows which Auth0 tenant and application it should use.\n\n```\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuth0WebAppAuthentication(options =>\n{\n    options.Domain = builder.Configuration[\"Auth0:Domain\"];\n    options.ClientId = builder.Configuration[\"Auth0:ClientId\"];\n});\n\nvar app = builder.Build();\n```\n\nMake sure you have enabled authentication and authorization in your Program.cs file:\n\n```\napp.UseAuthentication();\napp.UseAuthorization();\n```\n\n## Login\n\nTo allow users to login to your Blazor Server application, add a `LoginModel` to your `Pages` directory.\n\nInside the `LoginModel`'s `OnGet` method, call `HttpContext.ChallengeAsync()` and pass `Auth0Constants.AuthenticationScheme` as the authentication scheme. This will invoke the OIDC authentication handler that our SDK registers internally. Be sure to also specify the corresponding `authenticationProperties`, which you can construct using the `LoginAuthenticationPropertiesBuilder`.\n\nAfter successfully calling `HttpContext.ChallengeAsync()`, the user will be redirected to Auth0 and signed in to both the OIDC middleware and the cookie middleware upon being redirected back to your application. This will allow the users to be authenticated on subsequent requests.\n\n```\npublic class LoginModel : PageModel\n{\n    public async Task OnGet(string redirectUri)\n    {\n        var authenticationProperties = new LoginAuthenticationPropertiesBuilder()\n            .WithRedirectUri(redirectUri)\n            .Build();\n\n        await HttpContext.ChallengeAsync(Auth0Constants.AuthenticationScheme, authenticationProperties);\n    }\n}\n```\n\n## Display User Profile\n\nAfter the middleware has successfully retrieved the tokens from Auth0, it will extract the user's information and claims from the ID Token and make them available through the `AuthenticationState`, which you can add as a `CascadingParameter`.\n\nYou can create a custom user profile page for displaying the user's name, as well as additional claims (such as email and picture), by retrieving the corresponding information from the `AuthenticationState`'s `User` property and passing it to the view from inside Blazor code.\n\n```\n@page \"/Profile\"\n@attribute [Authorize]\n\n<PageTitle>Profile</PageTitle>\n\n<div class=\"row\">\n    <div class=\"col-md-12\">\n        <div class=\"row\">\n            <h2>Profile</h2>\n            <div class=\"col-md-4\">\n                <h3>@Username</h3>\n            </div>\n        </div>\n    </div>\n</div>\n\n@code {\n    [CascadingParameter]\n    public Task<AuthenticationState> AuthenticationStateTask { get; set; }\n    private string Username = \"\";\n\n    protected override async Task OnInitializedAsync()\n    {\n        var state = await AuthenticationStateTask;\n\n        Username = state.User.Identity.Name ?? string.Empty;\n\n        await base.OnInitializedAsync();\n    }\n}\n```\n\n## Logout\n\nLogging out the user from your own application can be done by calling `HttpContext.SignOutAsync` with the `CookieAuthenticationDefaults.AuthenticationScheme` authentication scheme from inside a `LogoutModel`'s `OnGet` method.\n\nAdditionally, if you also want to log the user out from Auth0 (this _might_ also log them out of other applications that rely on Single Sign On), call `HttpContext.SignOutAsync` with the `Auth0Constants.AuthenticationScheme` authentication scheme as well as the appropriate `authenticationProperties` that can be constructed using the `LogoutAuthenticationPropertiesBuilder`.\n\n```\n[Authorize]\npublic class LogoutModel : PageModel\n{\n    public async Task OnGet()\n    {\n        var authenticationProperties = new LogoutAuthenticationPropertiesBuilder()\n            .WithRedirectUri(\"/\")\n            .Build();\n\n        await HttpContext.SignOutAsync(Auth0Constants.AuthenticationScheme, authenticationProperties);\n        await HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);\n    }\n}\n```\n\n## What's next?\n\nWe put together a few examples of how to use the SDK in more advanced use cases:\n\n*   [Configuring Scopes](https://github.com/auth0/auth0-aspnetcore-authentication/blob/main/EXAMPLES.md#blazor-server)",
  "title": "Auth0 ASP.NET Core Blazor Server SDK Quickstarts: Add Login to your ASP.NET Core Blazor Server application",
  "description": "This tutorial demonstrates how to add user login to an ASP.NET Core Blazor Server application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/express",
  "markdown": "# Auth0 Express SDK Quickstarts: Login\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Regular Web App](https://auth0.com/docs/quickstart/webapp)\n*   [Express](https://auth0.com/docs/quickstart/webapp/express)\n\nThis tutorial demonstrates how to add user login, logout, and profile to a Node.js Express application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to integrate with my app\n\n15 minutes\n\n1.  [Configure Auth0](#configure-auth0)\n2.  [Integrate Auth0](#integrate-auth0)\n3.  [Login](#login)\n4.  [Display User Profile](#display-user-profile)\n5.  [Logout](#logout)\n6.  [What's next?](#what-s-next-)\n\nOr\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: NodeJS 10.13+ | Express 4.17+\n\n## Configure Auth0\n\nYou will need to register your application with Auth0 in order to start authenticating users. Go to the [Applications](https://manage.auth0.com/#/applications) screen in the Auth0 dashboard, create a new **Regular Web Application**, and follow the steps below.\n\n### 1\\. Configure Callback URL\n\nA callback URL is an application route where Auth0 redirects users after they have authenticated. This URL must be registered with Auth0 or else users will be unable to log in to the application and will get a \"Callback URL mismatch\" error.\n\nThe callback URL for the application created in this quickstart is `http://localhost:3000/callback`. Paste that in the **Allowed Callback URLs** field for the application you just created.\n\n### 2\\. Configure Logout URL\n\nA logout URL is an application route that Auth0 can return users to after logging out. This URL must be registered with Auth0 or else users will be unable to log out of the application and will get a \"misconfiguration\" error.\n\nThe logout URL for the application created in this quickstart is `http://localhost:3000`. Paste that in the **Allowed Logout URLs** field for the application you just created, then scroll down and click **Save Changes**.\n\n### 3\\. Get Your Application Keys\n\nFinally, copy the following fields for your application for use in step 7:\n\n*   **Domain**\n*   **Client ID**\n\n## Integrate Auth0\n\n### 4\\. Install Dependencies\n\nYour application will need the [`express-openid-connect`](https://github.com/auth0/express-openid-connect) package which is an Auth0-maintained OIDC-compliant library for Express.\n\n```\nnpm install express express-openid-connect --save\n```\n\n### 5\\. Configure Router\n\nThe Express OpenID Connect library provides the `auth` router in order to attach authentication routes to your application. You will need to configure the router with the following configuration keys:\n\n*   `authRequired` - Controls whether authentication is required for all routes\n*   `auth0Logout` - Uses Auth0 logout feature\n*   `baseURL` - The URL where the application is served\n*   `secret` - A long, random string used to encrypt the session cookie\n*   `issuerBaseURL` - The Domain as a secure URL found in your [Application settings](https://manage.auth0.com/#/applications/{yourClientId}/settings)\n*   `clientID` - The Client ID found in your [Application settings](https://manage.auth0.com/#/applications/{yourClientId}/settings)\n\nHere is an example configuration using this router:\n\n```\nconst { auth } = require('express-openid-connect');\n\nconst config = {\n  authRequired: false,\n  auth0Logout: true,\n  baseURL: 'http://localhost:3000',\n  clientID: '{yourClientId}',\n  issuerBaseURL: 'https://{yourDomain}',\n  secret: 'LONG_RANDOM_STRING'\n};\n\n// auth router attaches /login, /logout, and /callback routes to the baseURL\napp.use(auth(config));\n\n// req.isAuthenticated is provided from the auth router\napp.get('/', (req, res) => {\n  res.send(req.oidc.isAuthenticated() ? 'Logged in' : 'Logged out')\n});\n```\n\nFor additional configuration options visit the [API documentation](https://auth0.github.io/express-openid-connect).\n\n## Login\n\nA user can now log into your application by visiting the `/login` route provided by the library. If you are running your project on `localhost:3000` that link would be [`http://localhost:3000/login`](http://localhost:3000/login).\n\n## Display User Profile\n\nTo display the user's profile, your application should provide a protected route.\n\nAdd the `requiresAuth` middleware for routes that require authentication. Any route using this middleware will check for a valid user session and, if one does not exist, it will redirect the user to log in.\n\n```\nconst { requiresAuth } = require('express-openid-connect');\n\napp.get('/profile', requiresAuth(), (req, res) => {\n  res.send(JSON.stringify(req.oidc.user));\n});\n```\n\n## Logout\n\nA user can log out of your application by visiting the `/logout` route provided by the library. If you are running your project on `localhost:3000` that link would be [`http://localhost:3000/logout`](http://localhost:3000/logout).\n\n## What's next?\n\nWe put together a few examples of how to use [Express OpenID Connect](https://github.com/auth0/express-openid-connect) in more advanced use cases:\n\n*   [Route Customization](https://github.com/auth0/express-openid-connect/blob/master/EXAMPLES.md#3-route-customization)\n*   [Obtaining access tokens for external APIs](https://github.com/auth0/express-openid-connect/blob/master/EXAMPLES.md#4-obtaining-access-tokens-to-call-external-apis)\n*   [Require auth for specific routes](https://github.com/auth0/express-openid-connect/blob/master/EXAMPLES.md#2-require-authentication-for-specific-routes)",
  "title": "Auth0 Express SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login, logout, and profile to a Node.js Express application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/aspnet-core",
  "markdown": "# Auth0 ASP.NET Core MVC SDK Quickstarts: Login\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Regular Web App](https://auth0.com/docs/quickstart/webapp)\n*   [ASP.NET Core MVC](https://auth0.com/docs/quickstart/webapp/aspnet-core)\n\nThis tutorial demonstrates how to add user login to an ASP.NET Core application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to integrate with my app\n\n15 minutes\n\n1.  [Configure Auth0](#configure-auth0)\n2.  [Integrate Auth0](#integrate-auth0)\n3.  [Login](#login)\n4.  [Display User Profile](#display-user-profile)\n5.  [Logout](#logout)\n6.  [What's next?](#what-s-next-)\n\nOr\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: .NET 6.0 | .NET 7.0 | .NET 8.0\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nThe Callback URL of your application is the URL where Auth0 will redirect to after the user has authenticated in order for the SDK to complete the authentication process.\n\nYou will need to add this URL to the list of Allowed URLs for your application in your [Application Settings](https://manage.auth0.com/#/applications), this URL will mostly take the format `https://YOUR_APPLICATION_URL/callback`.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Integrate Auth0\n\n[Universal Login](https://auth0.com/docs/hosted-pages/login) is the easiest way to set up authentication in your application. We recommend using it for the best experience, best security and the fullest array of features. This guide will use it to provide a way for your users to log in to your ASP.NET Core application.\n\n### Install dependencies\n\nTo integrate Auth0 with ASP.NET Core you can use our SDK by installing the `Auth0.AspNetCore.Authentication` Nuget package to your application.\n\n```\nInstall-Package Auth0.AspNetCore.Authentication\n```\n\n### Install and configure the SDK\n\nTo enable authentication in your ASP.NET Core application, use the middleware provided by the SDK. Go to the `Program.cs` file and call `builder.Services.AddAuth0WebAppAuthentication()` to configure the Auth0 ASP.NET Core SDK.\n\nEnsure to configure the `Domain` and `ClientId`, these are required fields to ensure the SDK knows which Auth0 tenant and application it should use.\n\n```\nvar builder = WebApplication.CreateBuilder(args);\n// Cookie configuration for HTTP to support cookies with SameSite=None\nbuilder.Services.ConfigureSameSiteNoneCookies();\n\n// Cookie configuration for HTTPS\n//  builder.Services.Configure<CookiePolicyOptions>(options =>\n//  {\n//     options.MinimumSameSitePolicy = SameSiteMode.None;\n//  });\nbuilder.Services.AddAuth0WebAppAuthentication(options =>\n{\n    options.Domain = builder.Configuration[\"Auth0:Domain\"];\n    options.ClientId = builder.Configuration[\"Auth0:ClientId\"];\n});\nbuilder.Services.AddControllersWithViews();\nvar app = builder.Build();\n```\n\nMake sure you have enabled authentication and authorization in your Program.cs file:\n\n```\napp.UseAuthentication();\napp.UseAuthorization();\n```\n\n## Login\n\nTo add the `Login`, call `ChallengeAsync` and pass \"Auth0\" (`Auth0Constants.AuthenticationScheme`) as the authentication scheme. This will invoke the OIDC authentication handler that our SDK registers internally.\n\nAfter the OIDC middleware signs the user in, the user is also automatically signed in to the cookie middleware. This allows the user to be authenticated on subsequent requests.\n\n```\nusing Microsoft.AspNetCore.Authentication;\nusing Microsoft.AspNetCore.Authentication.Cookies;\nusing Auth0.AspNetCore.Authentication;\n\npublic class AccountController : Controller\n{\n    public async Task Login(string returnUrl = \"/\")\n    {\n        var authenticationProperties = new LoginAuthenticationPropertiesBuilder()\n            // Indicate here where Auth0 should redirect the user after a login.\n            // Note that the resulting absolute Uri must be added to the\n            // **Allowed Callback URLs** settings for the app.\n            .WithRedirectUri(returnUrl)\n            .Build();\n\n        await HttpContext.ChallengeAsync(Auth0Constants.AuthenticationScheme, authenticationProperties);\n    }\n}\n```\n\n## Display User Profile\n\nThe SDK extracts the user's information from the ID Token and makes them available as the `User.Claims` property on the controller.\n\nYou can create a custom user profile page for displaying a user's name, email address, and profile image, by passing the corresponding information to the view from inside your controller.\n\n```\npublic class AccountController : Controller\n{\n    [Authorize]\n    public IActionResult Profile()\n    {\n        return View(new\n        {\n            Name = User.Identity.Name,\n            EmailAddress = User.Claims.FirstOrDefault(c => c.Type == ClaimTypes.Email)?.Value,\n            ProfileImage = User.Claims.FirstOrDefault(c => c.Type == \"picture\")?.Value\n        });\n    }\n}\n```\n\n## Logout\n\nTo add `Logout`, you need to sign the user out of both the Auth0 middleware as well as the cookie middleware.\n\n```\nusing Microsoft.AspNetCore.Authentication;\nusing Microsoft.AspNetCore.Authentication.Cookies;\nusing Auth0.AspNetCore.Authentication;\n\npublic class AccountController : Controller\n{\n    [Authorize]\n    public async Task Logout()\n    {\n        var authenticationProperties = new LogoutAuthenticationPropertiesBuilder()\n            // Indicate here where Auth0 should redirect the user after a logout.\n            // Note that the resulting absolute Uri must be added to the\n            // **Allowed Logout URLs** settings for the app.\n            .WithRedirectUri(Url.Action(\"Index\", \"Home\"))\n            .Build();\n\n        await HttpContext.SignOutAsync(Auth0Constants.AuthenticationScheme, authenticationProperties);\n        await HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);\n    }\n}\n```\n\n## What's next?\n\nWe put together a few examples of how to use the SDK in more advanced use cases:\n\n*   [Configuring Scopes](https://github.com/auth0/auth0-aspnetcore-authentication/blob/main/EXAMPLES.md#scopes)\n*   [Obtain an Access Token for Calling an API](https://github.com/auth0/auth0-aspnetcore-authentication/blob/main/EXAMPLES.md#calling-an-api)\n*   [Adding Role-based authorization](https://github.com/auth0/auth0-aspnetcore-authentication/blob/main/EXAMPLES.md#roles)",
  "title": "Auth0 ASP.NET Core MVC SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to an ASP.NET Core application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/java",
  "markdown": "# Auth0 Java SDK Quickstarts: Login\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Regular Web App](https://auth0.com/docs/quickstart/webapp)\n*   [Java](https://auth0.com/docs/quickstart/webapp/java)\n\nThis tutorial demonstrates how to add user login to a Java Servlet application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Java 8 | Gradle 3.3 and up\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n*   **Client Secret**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Integrate Auth0 in your Application\n\n### Setup Dependencies\n\nTo integrate your Java application with Auth0, add the following dependencies:\n\n*   **javax.servlet-api**: is the library that allows you to create Java Servlets. You then need to add a Server dependency like Tomcat or Gretty, which one is up to you. Check our sample code for more information.\n*   **auth0-java-mvc-commons**: is the [Java library](https://github.com/auth0/auth0-java-mvc-common) that allows you to use Auth0 with Java for server-side MVC web apps. It generates the Authorize URL that you need to call in order to authenticate and validates the result received on the way back to finally obtain the [Auth0 Tokens](https://auth0.com/docs/tokens) that identify the user.\n\nIf you are using Gradle, add them to your `build.gradle`:\n\n```\n// build.gradle\n\ncompile 'javax.servlet:javax.servlet-api:3.1.0'\ncompile 'com.auth0:mvc-auth-commons:1.+'\n```\n\nIf you are using Maven, add them to your `pom.xml`:\n\n```\n<!-- pom.xml -->\n\n<dependency>\n  <groupId>com.auth0</groupId>\n  <artifactId>mvc-auth-commons</artifactId>\n  <version>[1.0, 2.0)</version>\n</dependency>\n<dependency>\n  <groupId>javax.servlet</groupId>\n  <artifactId>javax.servlet-api</artifactId>\n  <version>3.1.0</version>\n</dependency>\n```\n\n### Configure your Java App\n\nYour Java App needs some information in order to authenticate against your Auth0 account. The samples read this information from the deployment descriptor file `src/main/webapp/WEB-INF/web.xml`, but you could store them anywhere else. The required information is:\n\n```\n<!-- src/main/webapp/WEB-INF/web.xml -->\n\n<context-param>\n    <param-name>com.auth0.domain</param-name>\n    <param-value>{yourDomain}</param-value>\n</context-param>\n\n<context-param>\n    <param-name>com.auth0.clientId</param-name>\n    <param-value>{yourClientId}</param-value>\n</context-param>\n\n<context-param>\n    <param-name>com.auth0.clientSecret</param-name>\n    <param-value>YOUR_CLIENT_SECRET</param-value>\n</context-param>\n```\n\nThis information will be used to configure the **auth0-java-mvc-commons** library to enable users to login to your application. To learn more about the library, including its various configuration options, see the [library's documentation](https://github.com/auth0/auth0-java-mvc-common/blob/master/README.md).\n\n### Check populated attributes\n\nIf you downloaded this sample using the **Download Sample** button, the `domain`, `clientId` and `clientSecret` attributes will be populated for you. You should verify that the values are correct, especially if you have multiple Auth0 applications in your account.\n\n### Project Structure\n\nThe Login project sample has the following structure:\n\n```\n- src\n-- main\n---- java\n------ com\n-------- auth0\n---------- example\n------------ Auth0Filter.java\n------------ AuthenticationControllerProvider.java\n------------ HomeServlet.java\n------------ CallbackServlet.java\n------------ LoginServlet.java\n------------ LogoutServlet.java\n---- webapp\n------ WEB-INF\n-------- jsp\n---------- home.jsp\n-------- web.xml\n- build.gradle\n```\n\nThe project contains a single JSP: the `home.jsp` which will display the tokens associated with the user after a successful login and provide the option to logout.\n\nThe project contains a WebFilter: the `Auth0Filter.java` which will check for existing tokens before giving the user access to our protected `/portal/*` path. If the tokens don't exist, the request will be redirected to the `LoginServlet`.\n\nThe project contains also four servlets:\n\n*   `LoginServlet.java`: Invoked when the user attempts to log in. The servlet uses the `client_id` and `domain` parameters to create a valid Authorize URL and redirects the user there.\n*   `CallbackServlet.java`: The servlet captures requests to our Callback URL and processes the data to obtain the credentials. After a successful login, the credentials are then saved to the request's HttpSession.\n*   `HomeServlet.java`: The servlet reads the previously saved tokens and shows them on the `home.jsp` resource.\n*   `LogoutServlet.java`: Invoked when the user clicks the logout link. The servlet invalidates the user session and redirects the user to the login page, handled by the `LoginServlet`.\n*   `AuthenticationControllerProvider`: Responsible to create and manage a single instance of the `AuthenticationController`\n\n## Create the AuthenticationController\n\nTo enable users to authenticate, create an instance of the `AuthenticationController` provided by the `auth0-java-mvc-commons` SDK using the `domain`, `clientId`, and `clientSecret`. The sample shows how to configure the component for use with tokens signed using the RS256 asymmetric signing algorithm, by specifying a `JwkProvider` to fetch the public key used to verify the token's signature. See the [jwks-rsa-java repository](https://github.com/auth0/jwks-rsa-java) to learn about additional configuration options. If you are using HS256, there is no need to configure the `JwkProvider`.\n\n```\nclass AuthenticationControllerProvider {\n\n    private AuthenticationControllerProvider() {}\n\n    private static AuthenticationController INSTANCE;\n\n    // if multiple threads may call this, synchronize this method and consider double locking\n    static AuthenticationController getInstance(ServletConfig config) throws UnsupportedEncodingException {\n        if (INSTANCE == null) {\n            String domain = config.getServletContext().getInitParameter(\"com.auth0.domain\");\n            String clientId = config.getServletContext().getInitParameter(\"com.auth0.clientId\");\n            String clientSecret = config.getServletContext().getInitParameter(\"com.auth0.clientSecret\");\n\n            if (domain == null || clientId == null || clientSecret == null) {\n                throw new IllegalArgumentException(\"Missing domain, clientId, or clientSecret. Did you update src/main/webapp/WEB-INF/web.xml?\");\n            }\n\n            // JwkProvider required for RS256 tokens. If using HS256, do not use.\n            JwkProvider jwkProvider = new JwkProviderBuilder(domain).build();\n            INSTANCE = AuthenticationController.newBuilder(domain, clientId, clientSecret)\n                    .withJwkProvider(jwkProvider)\n                    .build();\n        }\n\n        return INSTANCE;\n    }\n```\n\n## Trigger Authentication\n\nTo enable users to login, your application will redirect them to the [Universal Login](https://auth0.com/docs/universal-login) page. Using the `AuthenticationController` instance, you can generate the redirect URL by calling the `buildAuthorizeUrl(HttpServletRequest request, HttpServletResponse response, String redirectUrl)` method. The redirect URL must be the URL that was added to the **Allowed Callback URLs** of your Auth0 Application.\n\n```\n// src/main/java/com/auth0/example/LoginServlet.java\n\n@Override\nprotected void doGet(final HttpServletRequest req, final HttpServletResponse res) throws ServletException, IOException {\n    String redirectUri = req.getScheme() + \"://\" + req.getServerName();\n    if ((req.getScheme().equals(\"http\") && req.getServerPort() != 80) || (req.getScheme().equals(\"https\") && req.getServerPort() != 443)) {\n        redirectUri += \":\" + req.getServerPort();\n    }\n    redirectUri += \"/callback\";\n\n    String authorizeUrl = authenticationController.buildAuthorizeUrl(req, res, redirectUri)\n            .build();\n    res.sendRedirect(authorizeUrl);\n}\n```\n\nAfter the user logs in, the result will be received in our `CallbackServlet` via either a GET or POST HTTP request. Because we are using the Authorization Code Flow (the default), a GET request will be sent. If you have configured the library for the Implicit Flow, a POST request will be sent instead.\n\nThe request holds the call context that the library previously set by generating the Authorize URL with the `AuthenticationController`. When passed to the controller, you get back either a valid `Tokens` instance or an Exception indicating what went wrong. In the case of a successful call, you need to save the credentials somewhere to access them later. You can use the `HttpSession` of the request by using the `SessionsUtils` class included in the library.\n\n```\n// src/main/java/com/auth0/example/CallbackServlet.java\n\n@Override\npublic void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n    handle(req, res);\n}\n\n@Override\npublic void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n    handle(req, res);\n}\n\nprivate void handle(HttpServletRequest req, HttpServletResponse res) throws IOException {\n    try {\n        // Parse the request\n        Tokens tokens = authenticationController.handle(req, res);\n        SessionUtils.set(req, \"accessToken\", tokens.getAccessToken());\n        SessionUtils.set(req, \"idToken\", tokens.getIdToken());\n        res.sendRedirect(redirectOnSuccess);\n    } catch (IdentityVerificationException e) {\n        e.printStackTrace();\n        res.sendRedirect(redirectOnFail);\n    }\n}\n```\n\n## Display the Home Page\n\nNow that the user is authenticated (the tokens exists), the `Auth0Filter` will allow them to access our protected resources. In the `HomeServlet` we obtain the tokens from the request's session and set them as the `userId` attribute so they can be used from the JSP code:\n\n```\n// src/main/java/com/auth0/example/HomeServlet.java\n\nprotected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n    final String accessToken = (String) SessionUtils.get(req, \"accessToken\");\n    final String idToken = (String) SessionUtils.get(req, \"idToken\");\n    if (accessToken != null) {\n        req.setAttribute(\"userId\", accessToken);\n    } else if (idToken != null) {\n        req.setAttribute(\"userId\", idToken);\n    }\n    req.getRequestDispatcher(\"/WEB-INF/jsp/home.jsp\").forward(req, res);\n}\n```\n\n## Handle Logout\n\nTo properly handle logout, we need to clear the session and log the user out of Auth0. This is handled in the `LogoutServlet` of our sample application.\n\nFirst, we clear the session by calling `request.getSession().invalidate()`. We then construct the logout URL, being sure to include the `returnTo` query parameter, which is where the user will be redirected to after logging out. Finally, we redirect the response to our logout URL.\n\n```\n// src/main/java/com/auth0/example/LogoutServlet.java\n\n@Override\nprotected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n    if (request.getSession() != null) {\n        request.getSession().invalidate();\n    }\n\n    String returnUrl = String.format(\"%s://%s\", request.getScheme(), request.getServerName());\n    if ((request.getScheme().equals(\"http\") && request.getServerPort() != 80) || (request.getScheme().equals(\"https\") && request.getServerPort() != 443)) {\n        returnUrl += \":\" + request.getServerPort();\n    }\n    returnUrl += \"/login\";\n\n    // Build logout URL like:\n    // https://{YOUR-DOMAIN}/v2/logout?client_id={YOUR-CLIENT-ID}&returnTo=http://localhost:3000/login\n    String logoutUrl = String.format(\n            \"https://%s/v2/logout?client_id=%s&returnTo=%s\",\n            domain,\n            clientId,\n            returnUrl\n    );\n    response.sendRedirect(logoutUrl);\n}\n```\n\n## Run the Sample\n\nTo run the sample from a terminal, change the directory to the root folder of the project and execute the following line:\n\nAfter a few seconds, the application will be accessible on `http://localhost:3000/`. Try to access the protected resource [http://localhost:3000/portal/home](http://localhost:3000/portal/home) and note how you're redirected by the `Auth0Filter` to the Auth0 Login Page. The widget displays all the social and database connections that you have defined for this application in the [dashboard](https://manage.auth0.com/#/).\n\n![Auth0 Universal Login](https://auth0.com/docs/media/quickstarts/universal-login.png)\n\nAfter a successful authentication, you'll be able to see the home page contents.\n\n![Display Token](https://auth0.com/docs/media/articles/java/display-token.png)\n\nLog out by clicking the **Logout** button at the top right of the home page.",
  "title": "Auth0 Java SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to a Java Servlet application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/laravel",
  "markdown": "# Add Login to a Laravel Application\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Regular Web App](https://auth0.com/docs/quickstart/webapp)\n*   [Laravel](https://auth0.com/docs/quickstart/webapp/laravel)\n\nAuth0's Laravel SDK allows you to quickly add authentication, user profile management, and routing access control to your Laravel application. This guide demonstrates how to integrate Auth0 with a new or existing Laravel 9 or 10 application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Laravel 9 / 10 | PHP 8.0+ | Composer\n\n## Laravel Installation\n\n**If you do not already have a Laravel application set up**, open a shell to a suitable directory for a new project and run the following command:\n\n```\ncomposer create-project --prefer-dist laravel/laravel auth0-laravel-app ^9.0\n```\n\nAll the commands in this guide assume you are running them from the root of your Laravel project, directory so you should `cd` into the new project directory:\n\n## SDK Installation\n\nRun the following command within your project directory to install the [Auth0 Laravel SDK](https://github.com/auth0/laravel-auth0):\n\n```\ncomposer require auth0/login:^7.8 --update-with-all-dependencies\n```\n\nThen generate an SDK configuration file for your application:\n\n```\nphp artisan vendor:publish --tag auth0\n```\n\n## SDK Configuration\n\nRun the following command from your project directory to download the [Auth0 CLI](https://github.com/auth0/auth0-cli):\n\n```\ncurl -sSfL https://raw.githubusercontent.com/auth0/auth0-cli/main/install.sh | sh -s -- -b .\n```\n\nThen authenticate the CLI with your Auth0 account, choosing \"as a user\" when prompted:\n\nNext, create a new application with Auth0:\n\n```\n./auth0 apps create \\\n  --name \"My Laravel Application\" \\\n  --type \"regular\" \\\n  --auth-method \"post\" \\\n  --callbacks \"http://localhost:8000/callback\" \\\n  --logout-urls \"http://localhost:8000\" \\\n  --reveal-secrets \\\n  --no-input \\\n  --json > .auth0.app.json\n```\n\nYou should also create a new API:\n\n```\n./auth0 apis create \\\n  --name \"My Laravel Application's API\" \\\n  --identifier \"https://github.com/auth0/laravel-auth0\" \\\n  --offline-access \\\n  --no-input \\\n  --json > .auth0.api.json\n```\n\nThis produces two files in your project directory that configure the SDK.\n\nAs these files contain credentials it's important to treat these as sensitive. You should ensure you do not commit these to version control. If you're using Git, you should add them to your `.gitignore` file:\n\n```\necho \".auth0.*.json\" >> .gitignore\n```\n\n## Login Routes\n\nThe SDK automatically registers all the necessary routes for your application's users to authenticate.\n\n| Route | Purpose |\n| --- | --- |\n| `/login` | Initiates the authentication flow. |\n| `/logout` | Logs the user out. |\n| `/callback` | Handles the callback from Auth0. |\n\nIf you require more control over these, or if they conflict with existing routes in your application, you can manually register the SDK's controllers instead. Please see [the SDK's README](https://github.com/auth0/laravel-auth0) for advanced integrations.\n\n## Access Control\n\nLaravel's authentication facilities use \"guards\" to define how users are authenticated for each request. You can use the Auth0 SDK's authentication guard to restrict access to your application's routes.\n\nTo require users to authenticate before accessing a route, you can use Laravel's `auth` middleware:\n\n```\nRoute::get('/private', function () {\n  return response('Welcome! You are logged in.');\n})->middleware('auth');\n```\n\nYou can also require authenticated users to have specific [permissions](https://auth0.com/docs/manage-users/access-control/rbac) by combining this with Laravel's `can` middleware:\n\n```\nRoute::get('/scope', function () {\n    return response('You have the `read:messages` permissions, and can therefore access this resource.');\n})->middleware('auth')->can('read:messages');\n```\n\n## User Information\n\nInformation about the authenticated user is available through Laravel's `Auth` Facade, or the `auth()` helper function.\n\nFor example, to retrieve the user's identifier and email address:\n\n```\nRoute::get('/', function () {\n  if (! auth()->check()) {\n    return response('You are not logged in.');\n  }\n\n  $user = auth()->user();\n  $name = $user->name ?? 'User';\n  $email = $user->email ?? '';\n\n  return response(\"Hello {$name}! Your email address is {$email}.\");\n});\n```\n\n## User Management\n\nYou can update user information using the [Auth0 Management API](https://github.com/auth0/laravel-auth0/blob/main/Management.md). All Management endpoints are accessible through the SDK's `management()` method.\n\n**Before making Management API calls you must enable your application to communicate with the Management API.** This can be done from the [Auth0 Dashboard's API page](https://manage.auth0.com/#/apis/), choosing `Auth0 Management API`, and selecting the 'Machine to Machine Applications' tab. Authorize your Laravel application, and then click the down arrow to choose the scopes you wish to grant.\n\nFor the following example, in which we will update a user's metadata and assign a random favorite color, you should grant the `read:users` and `update:users` scopes. A list of API endpoints and the required scopes can be found in [the Management API documentation](https://auth0.com/docs/api/management/v2).\n\n```\nuse Auth0\\Laravel\\Facade\\Auth0;\n\nRoute::get('/colors', function () {\n  $endpoint = Auth0::management()->users();\n\n  $colors = ['red', 'blue', 'green', 'black', 'white', 'yellow', 'purple', 'orange', 'pink', 'brown'];\n\n  $endpoint->update(\n    id: auth()->id(),\n    body: [\n        'user_metadata' => [\n            'color' => $colors[random_int(0, count($colors) - 1)]\n        ]\n    ]\n  );\n\n  $metadata = $endpoint->get(auth()->id());\n  $metadata = Auth0::json($metadata);\n\n  $color = $metadata['user_metadata']['color'] ?? 'unknown';\n  $name = auth()->user()->name;\n\n  return response(\"Hello {$name}! Your favorite color is {$color}.\");\n})->middleware('auth');\n```\n\nA quick reference guide of all the SDK's Management API methods is [available here](https://github.com/auth0/laravel-auth0/blob/main/docs/Management.md).\n\n## Run the Application\n\nYou are now ready to start your Laravel application, so it can accept requests:\n\n### Checkpoint\n\nOpen your web browser and try accessing the following routes:\n\n*   [http://localhost:8000](http://localhost:8000/) to see the public route.\n*   [http://localhost:8000/private](http://localhost:8000/private) to be prompted to authenticate.\n*   [http://localhost:8000](http://localhost:8000/) to see the pubic route, now authenticated.\n*   [http://localhost:8000/scope](http://localhost:8000/scope) to check if you have the `read:messages` [permission](https://auth0.com/docs/manage-users/access-control/rbac).\n*   [http://localhost:8000/update](http://localhost:8000/update) to update the user's profile.\n*   [http://localhost:8000/logout](http://localhost:8000/logout) to log out.\n\nIf you have any issues, here are a couple of things to try:\n\n*   Try running `php artisan optimize:clear` to clear Laravel's cache.\n*   Ensure your `.auth0.app.json` and `.auth0.api.json` files are at the root of your project.\n*   Ensure you have enabled your Laravel application as a Machine-to-Machine application and granted it all the necessary scopes for the `Auth0 Management API` from the [Auth0 Dashboard](https://manage.auth0.com/#/apis/).\n\nEncountering problems? Check the SDK's [documentation](https://github.com/auth0/laravel-auth0) or our [documentation hub](https://auth0.com/docs). You should also consider visiting [the community](https://community.auth0.com/) where our team and other community members can help answer your questions.\n\n### Additional Reading\n\n*   [User Repositories and Models](https://github.com/auth0/laravel-auth0/blob/main/docs/Users.md) extends the Auth0 Laravel SDK to use custom user models, and how to store and retrieve users from a database.\n*   [Hooking Events](https://github.com/auth0/laravel-auth0/blob/main/docs/Events.md) covers how to listen for events raised by the Auth0 Laravel SDK, to fully customize the behavior of your integration.\n*   [Management API](https://github.com/auth0/laravel-auth0/blob/main/docs/Management.md) support is built into the Auth0 Laravel SDK, allowing you to interact with the Management API from your Laravel application.",
  "title": "Auth0 Laravel SDK Quickstarts: Add Login to a Laravel Application",
  "description": "Auth0's Laravel SDK allows you to quickly add authentication, user profile management, and routing access control to your Laravel application. This guide demonstrates how to integrate Auth0 with a new or existing Laravel 9 or 10 application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/java-spring-boot",
  "markdown": "# Auth0 Java Spring Boot SDK Quickstarts: Login\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Regular Web App](https://auth0.com/docs/quickstart/webapp)\n*   [Java Spring Boot](https://auth0.com/docs/quickstart/webapp/java-spring-boot)\n\nThe Okta Spring Boot Starter makes it easy to add login to your Spring Boot application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Java 17\n\n### Using Spring WebFlux?\n\nThis tutorial uses [Spring MVC](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html). If you are using [Spring WebFlux](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-web-reactive), the steps to add authentication are similar, but some of the implementation details are different. Refer to the [Spring Boot WebFlux Sample Code](https://github.com/auth0-samples/auth0-spring-boot-login-samples/tree/master/webflux-login) to see how to integrate Auth0 with your Spring Boot WebFlux application.\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n*   **Client Secret**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Configure Spring Boot Application\n\n### Add dependencies\n\nTo integrate your Spring Boot application with Auth0, include the [Okta Spring Boot Starter](https://github.com/okta/okta-spring-boot/) in your application's dependencies.\n\nIf you're using Gradle, you can include these dependencies as shown below.\n\n```\nplugins {\n    id 'java'\n    id 'org.springframework.boot' version '3.1.4'\n    id 'io.spring.dependency-management' version '1.1.3'\n}\n\nimplementation 'com.okta.spring:okta-spring-boot-starter:3.0.5'\nimplementation 'org.springframework.boot:spring-boot-starter-web'\nimplementation 'org.springframework.boot:spring-boot-starter-thymeleaf'\nimplementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity6'\nimplementation 'nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect'\n```\n\nIf you are using Maven:\n\n```\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>3.1.5</version>\n    <relativePath/>\n</parent>\n\n<dependencies>\n    <dependency>\n        <groupId>com.okta</groupId>\n        <artifactId>okta-spring-boot-starter</artifactId>\n        <version>3.0.5</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-oauth2-client</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-thymeleaf</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.thymeleaf.extras</groupId>\n        <artifactId>thymeleaf-extras-springsecurity6</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>nz.net.ultraq.thymeleaf</groupId>\n        <artifactId>thymeleaf-layout-dialect</artifactId>\n    </dependency>\n</dependencies>\n```\n\n### Configure Spring Security\n\nThe Okta Spring Boot Starter makes it easy to configure your application with Auth0. The sample below uses an `application.yml` file, though you can also use properties files or any of the other [supported externalization mechanisms](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config).\n\n```\n# src/main/resources/application.yml\nokta:\n  oauth2:\n    issuer: https://{yourDomain}/\n    client-id: {yourClientId}\n    client-secret: YOUR_CLIENT_SECRET\n\n# The sample and instructions above for the callback and logout URL configuration use port 3000.\n# If you wish to use a different port, change this and be sure your callback and logout URLs are\n# configured with the correct port.\nserver:\n  port: 3000\n```\n\n## Add Login to Your Application\n\nTo enable user login with Auth0, create a class that will register a [SecurityFilterChain](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/SecurityFilterChain.html), and add the `@Configuration` annotation.\n\n```\npackage com.auth0.example;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.web.SecurityFilterChain;\n\nimport static org.springframework.security.config.Customizer.withDefaults;\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Bean\n    public SecurityFilterChain configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(authorize -> authorize\n                .anyRequest().authenticated()\n            )\n            .oauth2Login(withDefaults());\n        return http.build();\n    }\n}\n```\n\nThe Okta Spring Boot Starter will use the client configuration you defined earlier to handle login when a user visits the `/oauth2/authorization/okta` path of your application. You can use this to create a login link in your application.\n\n```\n<!-- src/main/resources/templates/index.html -->\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\">\n    <body>\n        <div sec:authorize=\"!isAuthenticated()\">\n            <a th:href=\"@{/oauth2/authorization/okta}\">Log In</a>\n        </div>\n        <div sec:authorize=\"isAuthenticated()\">\n            <p>You are logged in!</p>\n        </div>\n    </body>\n</html>\n```\n\nBe sure to create or update a controller to render your view.\n\n```\npackage com.auth0.example;\n\nimport org.springframework.security.core.annotation.AuthenticationPrincipal;\nimport org.springframework.security.oauth2.core.oidc.user.OidcUser;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n/**\n * Controller for the home page.\n */\n@Controller\npublic class HomeController {\n\n    @GetMapping(\"/\")\n    public String home(Model model, @AuthenticationPrincipal OidcUser principal) {\n        return \"index\";\n    }\n}\n```\n\n### Checkpoint\n\nAdd the login link to your application. When you click it, verify that your application redirects you to the [Auth0 Universal Login](https://auth0.com/universal-login) page and that you can now log in or sign up using a username and password or a social provider.\n\nOnce that's complete, verify that Auth0 redirects you to your application and that you are logged in.\n\n![Auth0 Universal Login](https://auth0.com/docs/media/quickstarts/universal-login.png)\n\n## Add Logout to Your Application\n\nNow that users can log into your application, they need [a way to log out](https://auth0.com/docs/logout/guides/logout-auth0). By default, when logout is enabled, Spring Security will log the user out of your application and clear the session. To enable successful logout of Auth0, you can provide a `LogoutHandler` to redirect users to your [Auth0 logout endpoint](https://auth0.com/docs/api/authentication?javascript#logout) (`https://{yourDomain}/v2/logout`) and then immediately redirect them to your application.\n\nIn the `SecurityConfig` class, provide a `LogoutHandler` that redirects to the Auth0 logout endpoint, and configure the `HttpSecurity` to add the logout handler:\n\n```\npackage com.auth0.example;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.web.SecurityFilterChain;\nimport org.springframework.security.web.authentication.logout.LogoutHandler;\nimport org.springframework.web.servlet.support.ServletUriComponentsBuilder;\n\nimport java.io.IOException;\n\nimport static org.springframework.security.config.Customizer.withDefaults;\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Value(\"${okta.oauth2.issuer}\")\n    private String issuer;\n    @Value(\"${okta.oauth2.client-id}\")\n    private String clientId;\n\n    @Bean\n    public SecurityFilterChain configure(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(authorize -> authorize\n                .requestMatchers(\"/\", \"/images/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .oauth2Login(withDefaults())\n\n            // configure logout with Auth0\n            .logout(logout -> logout\n                .addLogoutHandler(logoutHandler()));\n        return http.build();\n    }\n\n    private LogoutHandler logoutHandler() {\n        return (request, response, authentication) -> {\n            try {\n                String baseUrl = ServletUriComponentsBuilder.fromCurrentContextPath().build().toUriString();\n                response.sendRedirect(issuer + \"v2/logout?client_id=\" + clientId + \"&returnTo=\" + baseUrl);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        };\n    }\n}\n```\n\nYou can then update your view to POST to the `/logout` endpoint (Spring Security provides this by default) to enable users to log out.\n\n```\n<div sec:authorize=\"isAuthenticated()\">\n    <p>You are logged in!</p>\n    <form name=\"logoutForm\" th:action=\"@{/logout}\" method=\"post\">\n        <button type=\"submit\" value=\"Log out\"/>\n    </form>\n</div>\n```\n\n### Checkpoint\n\nAdd the logout link in the view of your application. When you click it, verify that your application redirects you the address you specified as one of the \"Allowed Logout URLs\" in the \"Settings\" and that you are no longer logged in to your application.\n\n## Show User Profile Information\n\nYou can retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with logged-in users through the [OidcUser](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/core/oidc/user/OidcUser.html) class, which can be used with the [AuthenticationPrincipal annotation](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/annotation/AuthenticationPrincipal.html).\n\nIn your controller, add the user's profile information to the model:\n\n```\n@Controller\npublic class HomeController {\n\n    @GetMapping(\"/\")\n    public String home(Model model, @AuthenticationPrincipal OidcUser principal) {\n        if (principal != null) {\n            model.addAttribute(\"profile\", principal.getClaims());\n        }\n        return \"index\";\n    }\n}\n```\n\nYou can then use this profile information in your view, as shown below.\n\n```\n<div sec:authorize=\"isAuthenticated()\">\n    <img th:src=\"${profile.get('picture')}\" th:attr=\"alt=${profile.get('name')}\"/>\n    <h2 th:text=\"${profile.get('name')}\"></h2>\n    <p th:text=\"${profile.get('email')}\"></p>\n    <a th:href=\"@{/logout}\">Log Out</a>\n</div>\n```",
  "title": "Auth0 Java Spring Boot SDK Quickstarts: Login",
  "description": "The Okta Spring Boot Starter makes it easy to add login to your Spring Boot application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/nextjs",
  "markdown": "# Auth0 Next.js SDK Quickstarts: Login\n\nThis guide demonstrates how to integrate Auth0 with any new or existing Next.js application using the Auth0 Next.js SDK. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Next.js 13.4+\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n*   **Client Secret**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Install the Auth0 Next.js SDK\n\nRun the following command within your project directory to install the Auth0 Next.js SDK:\n\n```\nnpm install @auth0/nextjs-auth0\n```\n\nThe SDK exposes methods and variables that help you integrate Auth0 with your Next.js application using [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) on the backend and [React Context](https://reactjs.org/docs/context.html) with [React Hooks](https://reactjs.org/docs/hooks-overview.html) on the frontend.\n\n### Configure the SDK\n\nIn the root directory of your project, add the file `.env.local` with the following [environment variables](https://nextjs.org/docs/basic-features/environment-variables):\n\n```\nAUTH0_SECRET='use [openssl rand -hex 32] to generate a 32 bytes value'\nAUTH0_BASE_URL='http://localhost:3000'\nAUTH0_ISSUER_BASE_URL='https://{yourDomain}'\nAUTH0_CLIENT_ID='{yourClientId}'\nAUTH0_CLIENT_SECRET='{yourClientSecret}'\n```\n\n*   `AUTH0_SECRET`: A long secret value used to encrypt the session cookie. You can generate a suitable string using `openssl rand -hex 32` on the command line.\n*   `AUTH0_BASE_URL`: The base URL of your application.\n*   `AUTH0_ISSUER_BASE_URL`: The URL of your Auth0 tenant domain. If you are using a [Custom Domain with Auth0](https://auth0.com/docs/custom-domains), set this to the value of your Custom Domain instead of the value reflected in the \"Settings\" tab.\n*   `AUTH0_CLIENT_ID`: Your Auth0 application's Client ID.\n*   `AUTH0_CLIENT_SECRET`: Your Auth0 application's Client Secret.\n\nThe SDK will read these values from the Node.js process environment and automatically configure itself.\n\n### Add the dynamic API route handler\n\nCreate a file at `app/api/auth/[auth0]/route.js`. This is your Route Handler file with a [Dynamic Route Segment](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#dynamic-route-segments).\n\nThen, import the `handleAuth` method from the SDK and call it from the `GET` export.\n\n```\n// app/api/auth/[auth0]/route.js\nimport { handleAuth } from '@auth0/nextjs-auth0';\n\nexport const GET = handleAuth();\n```\n\nThis creates the following routes:\n\n*   `/api/auth/login`: The route used to perform login with Auth0.\n*   `/api/auth/logout`: The route used to log the user out.\n*   `/api/auth/callback`: The route Auth0 will redirect the user to after a successful login.\n*   `/api/auth/me`: The route to fetch the user profile from.\n\n### Add the UserProvider component\n\nOn the frontend side, the SDK uses React Context to manage the authentication state of your users. To make that state available to all your pages, you need to override the [Root Layout component](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#root-layout-required) and wrap the `<body>` tag with a `UserProvider` in the file `app/layout.jsx`.\n\nCreate the file `app/layout.jsx` as follows:\n\n```\n// app/layout.jsx\nimport { UserProvider } from '@auth0/nextjs-auth0/client';\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n    <UserProvider>\n      <body>{children}</body>\n    </UserProvider>\n    </html>\n  );\n}\n```\n\nThe authentication state exposed by `UserProvider` can be accessed in any Client Component using the `useUser()` hook.\n\n### Checkpoint\n\nNow that you have added the dynamic route and `UserProvider`, run your application to verify that your application is not throwing any errors related to Auth0.\n\n## Add Login to Your Application\n\nUsers can now log in to your application by visiting the `/api/auth/login` route provided by the SDK. Add a link that points to the login route using an **anchor tag**. Clicking it redirects your users to the Auth0 Universal Login Page, where Auth0 can authenticate them. Upon successful authentication, Auth0 will redirect your users back to your application.\n\n```\n<a href=\"/api/auth/login\">Login</a>\n```\n\n### Checkpoint\n\nAdd the login link to your application. When you click it, verify that your Next.js application redirects you to the [Auth0 Universal Login](https://auth0.com/universal-login) page and that you can now log in or sign up using a username and password or a social provider.\n\nOnce that's complete, verify that Auth0 redirects back to your application.\n\n![Auth0 Universal Login](https://auth0.com/docs/media/quickstarts/universal-login.png)\n\n## Add Logout to Your Application\n\nNow that you can log in to your Next.js application, you need [a way to log out](https://auth0.com/docs/logout/log-users-out-of-auth0). Add a link that points to the `/api/auth/logout` API route. Clicking it redirects your users to your [Auth0 logout endpoint](https://auth0.com/docs/api/authentication?javascript#logout) (`https://YOUR_DOMAIN/v2/logout`) and then immediately redirects them back to your application.\n\n```\n<a href=\"/api/auth/logout\">Logout</a>\n```\n\n### Checkpoint\n\nAdd the logout link to your application. When you click it, verify that your Next.js application redirects you to the address you specified as one of the \"Allowed Logout URLs\" in the \"Settings\".\n\n## Show User Profile Information\n\nThe Auth0 Next.js SDK helps you retrieve the [profile information](https://auth0.com/docs/users/user-profiles) associated with the logged-in user, such as their name or profile picture, to personalize the user interface.\n\n### From a Client Component\n\nThe profile information is available through the `user` property exposed by the `useUser()` hook. Take this [Client Component](https://nextjs.org/docs/getting-started/react-essentials#client-components) as an example of how to use it:\n\n```\n'use client';\n\nimport { useUser } from '@auth0/nextjs-auth0/client';\n\nexport default function ProfileClient() {\n  const { user, error, isLoading } = useUser();\n\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>{error.message}</div>;\n\n  return (\n    user && (\n      <div>\n        <img src={user.picture} alt={user.name} />\n        <h2>{user.name}</h2>\n        <p>{user.email}</p>\n      </div>\n    )\n  );\n}\n```\n\nThe `user` property contains sensitive information and artifacts related to the user's identity. As such, its availability depends on the user's authentication status. To prevent any render errors:\n\n*   Ensure that the SDK has completed loading before accessing the `user` property by checking that `isLoading` is `false`.\n*   Ensure that the SDK has loaded successfully by checking that no `error` was produced.\n*   Check the `user` property to ensure that Auth0 has authenticated the user before React renders any component that consumes it.\n\n### From a Server Component\n\nThe profile information is available through the `user` property exposed by the `getSession` function. Take this [Server Component](https://nextjs.org/docs/getting-started/react-essentials#server-components) as an example of how to use it:\n\n```\nimport { getSession } from '@auth0/nextjs-auth0';\n\nexport default async function ProfileServer() {\n  const { user } = await getSession();\n\n  return (\n      user && (\n          <div>\n            <img src={user.picture} alt={user.name} />\n            <h2>{user.name}</h2>\n            <p>{user.email}</p>\n          </div>\n      )\n  );\n}\n```\n\n### Checkpoint\n\nVerify that you can display the `user.name` or [any other](https://auth0.com/docs/users/user-profile-structure#user-profile-attributes) `user` property within a component correctly after you have logged in.\n\n## What's next?\n\nWe put together a few examples of how to use [nextjs-auth0](https://github.com/auth0/nextjs-auth0) in more advanced use cases:\n\n*   [Protecting a Server Side Rendered (SSR) Page](https://github.com/auth0/nextjs-auth0/blob/main/EXAMPLES.md#protecting-a-server-side-rendered-ssr-page)\n*   [Protecting a Client Side Rendered (CSR) Page](https://github.com/auth0/nextjs-auth0/blob/main/EXAMPLES.md#protecting-a-client-side-rendered-csr-page)\n*   [Protect an API Route](https://github.com/auth0/nextjs-auth0/blob/main/EXAMPLES.md#protect-an-api-route)\n*   [Access an External API from an API Route](https://github.com/auth0/nextjs-auth0/blob/main/EXAMPLES.md#access-an-external-api-from-an-api-route)",
  "title": "Auth0 Next.js SDK Quickstarts: Login",
  "description": "This guide demonstrates how to integrate Auth0 with any new or existing Next.js application using the Auth0 Next.js SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/php",
  "markdown": "# Auth0 PHP SDK Quickstarts: Login\n\nThis guide demonstrates how to integrate Auth0 with a PHP application using the Auth0 PHP SDK. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n*   **Client Secret**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Integrate your PHP application\n\nLet's create a sample application that authenticates a user with a PHP application. We'll take a simple approach here, appropriate for the written format. Still, you should check out the accompanying [Quickstart app on GitHub](https://github.com/auth0-samples/auth0-php-web-app/) for a more robust example.\n\n### Installing HTTP Client and Messaging Factories\n\nThe Auth0 PHP SDK supports many [PHP-FIG](https://www.php-fig.org/) standards offering interoperability options with your architecture. Two of particular importance are [PSR-17](https://www.php-fig.org/psr/psr-17/) and [PSR-18](https://www.php-fig.org/psr/psr-18/). These standards allow you to plug-in networking components of your choice to handle messaging and requests. You will need to install compatible libraries in your project for the SDK to use.\n\nThe most prolific networking library for PHP is [Guzzle](https://guzzlephp.org/), although many are available to pick from within the PHP community. Let's use Guzzle for this sample application. Once again, from your project directory, run the following shell command:\n\n```\ncomposer require guzzlehttp/guzzle guzzlehttp/psr7 http-interop/http-factory-guzzle\n```\n\n### Installing the PHP SDK\n\nThe Auth0 PHP SDK requires [Composer](https://getcomposer.org/doc/00-intro.md#installation-linux-unix-macos), a tool for dependency management in PHP. Composer allows you to declare the dependent libraries your project needs and installs them for you. Please ensure Composer is installed and accessible from your shell before continuing.\n\nRun the following shell command within your project directory to install the Auth0 PHP SDK:\n\n```\ncomposer require auth0/auth0-php\n```\n\nThis will create a `vendor` folder within your project and download all the dependencies needed to use the Auth0 PHP SDK. This will also create a `vendor/autoload.php` file used in the sample to load all necessary classes for your application to function. It's important you require this autoload file in your project for the SDK to work.\n\n### Configuring the SDK\n\nTo begin, let's create a `.env` file within the root of your project directory to store our sample application's configuration and fill in the environment variables:\n\n```\n# Your Auth0 application's Client ID\nAUTH0_CLIENT_ID={yourClientId}\n\n# The URL of your Auth0 tenant domain\nAUTH0_DOMAIN={yourDomain}\n\n# Your Auth0 application's Client Secret\nAUTH0_CLIENT_SECRET={yourClientSecret}\n\n# A long, secret value used to encrypt the session cookie.\n# This can be generated using `openssl rand -hex 32` from your shell.\nAUTH0_COOKIE_SECRET=\n\n# A url your application is accessible from. Update this as appropriate.\nAUTH0_BASE_URL=http://127.0.0.1:3000\n```\n\nAs PHP isn't able to read our `.env` file by itself, we'll want to install a library to help with that. Although we'll be using a particular library for our sample application's purposes, in a real world application any 'dotenv' loader of preference will work. From our project directory, let's run the following shell command to install the library:\n\n```\ncomposer require vlucas/phpdotenv\n```\n\nNext, let's create the PHP source file we'll be using for these code samples, `index.php`, and let's configure an instance of the Auth0 PHP SDK for our sample application:\n\n```\n<?php\n\n// Import the Composer Autoloader to make the SDK classes accessible:\nrequire 'vendor/autoload.php';\n\n// Load our environment variables from the .env file:\n(Dotenv\\Dotenv::createImmutable(__DIR__))->load();\n\n// Now instantiate the Auth0 class with our configuration:\n$auth0 = new \\Auth0\\SDK\\Auth0([\n    'domain' => $_ENV['AUTH0_DOMAIN'],\n    'clientId' => $_ENV['AUTH0_CLIENT_ID'],\n    'clientSecret' => $_ENV['AUTH0_CLIENT_SECRET'],\n    'cookieSecret' => $_ENV['AUTH0_COOKIE_SECRET']\n]);\n```\n\n### Setting up your application routes\n\nModern PHP applications use a routing pattern to pass incoming HTTP requests to the code that handles them, determining what should happen when our users visit a particular \"page\" in our app. There is no single, correct way of implementing routing in your application, and there are many libraries to choose from to implement it. We'll be using one particular library for our sample application's purposes, but feel free to select your own in a real-world application.\n\nFrom our project directory, let's run the following shell command to install the routing library:\n\n```\ncomposer require steampixel/simple-php-router\n```\n\nNext, let's open our `index.php` back up and give our application life. Start by importing the routing library and defining our sample application's route's full URLs as named constants for convenience sake, as we'll need to reference them in a few places through our sample application:\n\n```\n// 👆 We're continuing from the steps above. Append this to your index.php file.\n\n// Import our router library:\nuse Steampixel\\Route;\n\n// Define route constants:\ndefine('ROUTE_URL_INDEX', rtrim($_ENV['AUTH0_BASE_URL'], '/'));\ndefine('ROUTE_URL_LOGIN', ROUTE_URL_INDEX . '/login');\ndefine('ROUTE_URL_CALLBACK', ROUTE_URL_INDEX . '/callback');\ndefine('ROUTE_URL_LOGOUT', ROUTE_URL_INDEX . '/logout');\n```\n\nNow we can move on to adding our application's route handling logic, and the SDK integrations:\n\n## Checking for a session\n\nThe Auth0 PHP SDK has a convenient method for checking if our user has authenticated and returned their profile, `getCredentials()`. Let's install this on our index route to print the user profile if they're logged in or report that they need to login.\n\n```\n// 👆 We're continuing from the steps above. Append this to your index.php file.\n\nRoute::add('/', function() use ($auth0) {\n  $session = $auth0->getCredentials();\n\n  if ($session === null) {\n    // The user isn't logged in.\n    echo '<p>Please <a href=\"/login\">log in</a>.</p>';\n    return;\n  }\n\n  // The user is logged in.\n  echo '<pre>';\n  print_r($session->user);\n  echo '</pre>';\n\n  echo '<p>You can now <a href=\"/logout\">log out</a>.</p>';\n});\n```\n\nWe can access all the properties of our user's profile from the `user` property response, which is an array. So, for example, we can pull the user's nickname using `$session->user['nickname']`, or their email address from `$session->user['email']`. The structure is a [normalized user profile](https://auth0.com/docs/users/user-profile-structure), which you can learn more about [here](https://auth0.com/docs/users/normalized-user-profiles).\n\nIt's important to note that the content of the user profile will vary depending on the social provider(s) you use, so you should never assume that a particular value will always be there within your application logic. Use PHP language constructs like `isset` or null coalescence to gracefully handle a value's presence, or lack thereof, for example:\n\n```\n// ✋ We don't need to include this in our sample application, it's just an example.\n$name = $session->user['name'] ?? $session->user['nickname'] ?? $session->user['email'] ?? 'Unknown';\n```\n\n## Logging in\n\nNow let's create our /login route, which will use the Auth0 PHP SDK's `login()` method to set up the user session and return a customized URL to Auth0's Universal Login Page for this user to login.\n\n```\n// 👆 We're continuing from the steps above. Append this to your index.php file.\n\nRoute::add('/login', function() use ($auth0) {\n    // It's a good idea to reset user sessions each time they go to login to avoid \"invalid state\" errors, should they hit network issues or other problems that interrupt a previous login process:\n    $auth0->clear();\n\n    // Finally, set up the local application session, and redirect the user to the Auth0 Universal Login Page to authenticate.\n    header(\"Location: \" . $auth0->login(ROUTE_URL_CALLBACK));\n    exit;\n});\n```\n\n## Handling authentication callback\n\nAfter our users return from authenticating with the Auth0's Universal Login Page, they'll return to our sample application at our callback route, `/callback` which we'll handle in this step.\n\nWhen Auth0 passes our users back to us, it includes a few essential parameters in the query of the HTTP request. The Auth0 PHP SDK's `exchange()` method handles working with those, so finishing our authentication flow is straightforward:\n\n```\n// 👆 We're continuing from the steps above. Append this to your index.php file.\n\nRoute::add('/callback', function() use ($auth0) {\n    // Have the SDK complete the authentication flow:\n    $auth0->exchange(ROUTE_URL_CALLBACK);\n\n    // Finally, redirect our end user back to the / index route, to display their user profile:\n    header(\"Location: \" . ROUTE_URL_INDEX);\n    exit;\n});\n```\n\n## Logging out\n\nLast but not least, let's properly handle logging our users out. The `logout()` method of the Auth0 PHP SDK handles clearing our sample application's session cookies, redirecting the user to Auth0's [/logout endpoint](https://auth0.com/docs/logout) (which logs out Auth0 session layer and any identify provider session layers), and then return the user to our / index route.\n\n```\n// 👆 We're continuing from the steps above. Append this to your index.php file.\n\nRoute::add('/logout', function() use ($auth0) {\n    // Clear the user's local session with our app, then redirect them to the Auth0 logout endpoint to clear their Auth0 session.\n    header(\"Location: \" . $auth0->logout(ROUTE_URL_INDEX));\n    exit;\n});\n```\n\n## Run your app!\n\nLast but not least, we need to tell our routing middleware to actually route requests:\n\n```\n// 👆 We're continuing from the steps above. Append this to your index.php file.\n\n// This tells our router that we've finished configuring our routes, and we're ready to begin routing incoming HTTP requests:\nRoute::run('/');\n```\n\nThat's it! You're ready to run your new application; once again, from your project directory, run the following shell command:\n\n```\nphp -S 127.0.0.1:3000 index.php\n```\n\nOpen your browser to [http://127.0.0.1:3000](https://127.0.0.1:3000/) and try it out.",
  "title": "Auth0 PHP SDK Quickstarts: Login",
  "description": "This guide demonstrates how to integrate Auth0 with a PHP application using the Auth0 PHP SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/python",
  "markdown": "# Auth0 Python SDK Quickstarts: Login\n\nThis tutorial demonstrates how to add user login to a Python web Application built with the Flask framework and Authlib OAuth library. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n*   **Client Secret**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Install dependencies\n\nFor the purposes of this example, we'll be using the [Authlib](https://authlib.org/) OAuth library and [Flask](https://flask.palletsprojects.com/en/2.0.x/).\n\nBegin by creating a `requirements.txt` file in your project directory:\n\n```\n# 📁 requirements.txt -----\n\nflask>=2.0.3\npython-dotenv>=0.19.2\nauthlib>=1.0\nrequests>=2.27.1\n```\n\nYou should now run `pip install -r requirements.txt` from your shell to make these dependencies available to your project.\n\n## Configure your .env file\n\nNext, create an `.env` file in your project directory. This file will hold your client keys and other configuration details.\n\n```\n# 📁 .env -----\n\nAUTH0_CLIENT_ID={yourClientId}\nAUTH0_CLIENT_SECRET={yourClientSecret}\nAUTH0_DOMAIN={yourDomain}\nAPP_SECRET_KEY=\n```\n\n*   Generate a suitable string for `APP_SECRET_KEY` using `openssl rand -hex 32` from your shell.\n\n## Setup your application\n\nNow you're ready to start writing your application. Create a `server.py` file in your project directory - this file will hold all of your application logic.\n\nBegin by importing all the libraries your application will be making use of:\n\n```\n# 📁 server.py -----\n\nimport json\nfrom os import environ as env\nfrom urllib.parse import quote_plus, urlencode\n\nfrom authlib.integrations.flask_client import OAuth\nfrom dotenv import find_dotenv, load_dotenv\nfrom flask import Flask, redirect, render_template, session, url_for\n```\n\nNext, your application will need to load the configuration `.env` file you made in the previous step:\n\n```\n# 👆 We're continuing from the steps above. Append this to your server.py file.\n\nENV_FILE = find_dotenv()\nif ENV_FILE:\n    load_dotenv(ENV_FILE)\n```\n\nNow you can configure Flask for your application's needs:\n\n```\n# 👆 We're continuing from the steps above. Append this to your server.py file.\n\napp = Flask(__name__)\napp.secret_key = env.get(\"APP_SECRET_KEY\")\n```\n\nFinally, you can now configure Authlib to handle your application's authentication with Auth0:\n\n```\n# 👆 We're continuing from the steps above. Append this to your server.py file.\n\noauth = OAuth(app)\n\noauth.register(\n    \"auth0\",\n    client_id=env.get(\"AUTH0_CLIENT_ID\"),\n    client_secret=env.get(\"AUTH0_CLIENT_SECRET\"),\n    client_kwargs={\n        \"scope\": \"openid profile email\",\n    },\n    server_metadata_url=f'https://{env.get(\"AUTH0_DOMAIN\")}/.well-known/openid-configuration'\n)\n```\n\nYou can learn more about the configuration options available for Authlib's OAuth `register()` method from [their documentation.](https://docs.authlib.org/en/latest/client/frameworks.html#using-oauth-2-0-to-log-in)\n\n## Setup your routes\n\nFor this demonstration, we'll be adding 4 routes for your application: your login, callback, logout and home routes.\n\n### Triggering authentication with /login\n\nWhen visitors to your app visit the `/login` route, they'll be redirected to Auth0 to begin the authentication flow.\n\n```\n# 👆 We're continuing from the steps above. Append this to your server.py file.\n\n@app.route(\"/login\")\ndef login():\n    return oauth.auth0.authorize_redirect(\n        redirect_uri=url_for(\"callback\", _external=True)\n    )\n```\n\n### Finalizing authentication with /callback\n\nAfter your users finish logging in with Auth0, they'll be returned to your application at the `/callback` route. This route is responsible for actually saving the session for the user, so when they visit again later, they won't have to sign back in all over again.\n\n```\n# 👆 We're continuing from the steps above. Append this to your server.py file.\n\n@app.route(\"/callback\", methods=[\"GET\", \"POST\"])\ndef callback():\n    token = oauth.auth0.authorize_access_token()\n    session[\"user\"] = token\n    return redirect(\"/\")\n```\n\n### Clearing a session with /logout\n\nAs you might expect, this route handles signing a user out from your application. It will clear the user's session in your app, and briefly redirect to Auth0's logout endpoint to ensure their session is completely clear, before they are returned to your home route (covered next.)\n\n```\n# 👆 We're continuing from the steps above. Append this to your server.py file.\n\n@app.route(\"/logout\")\ndef logout():\n    session.clear()\n    return redirect(\n        \"https://\" + env.get(\"AUTH0_DOMAIN\")\n        + \"/v2/logout?\"\n        + urlencode(\n            {\n                \"returnTo\": url_for(\"home\", _external=True),\n                \"client_id\": env.get(\"AUTH0_CLIENT_ID\"),\n            },\n            quote_via=quote_plus,\n        )\n    )\n```\n\n### There's no place like /home\n\nLast but not least, your home route will serve as a place to either render an authenticated user's details, or offer to allow visitors to sign in.\n\n```\n# 👆 We're continuing from the steps above. Append this to your server.py file.\n\n@app.route(\"/\")\ndef home():\n    return render_template(\"home.html\", session=session.get('user'), pretty=json.dumps(session.get('user'), indent=4))\n```\n\n### Server instantiation\n\nFinally, you'll need to add some small boilerplate code for Flask to actually run your app and listen for connections.\n\n```\n# 👆 We're continuing from the steps above. Append this to your server.py file.\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=env.get(\"PORT\", 3000))\n```\n\n## Add templates\n\nNow we just need to create the simple template files used in the routes about (during `render_template()` calls).\n\nCreate a new sub-directory in your project folder named `templates`, and create two files within: `dashboard.html` and `home.html`. You can paste the content from the two fields below into those files, respectfully:\n\n```\n# 📁 templates/home.html -----\n\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Auth0 Example</title>\n  </head>\n  <body>\n    {% if session %}\n        <h1>Welcome {{session.userinfo.name}}!</h1>\n        <p><a href=\"/logout\">Logout</a></p>\n        <div><pre>{{pretty}}</pre></div>\n    {% else %}\n        <h1>Welcome Guest</h1>\n        <p><a href=\"/login\">Login</a></p>\n    {% endif %}\n  </body>\n</html>\n```\n\n## Run your application\n\nYou're ready to run your application! From your project directory, open a shell and use:\n\nYour application should now be ready to open from your browser at [http://localhost:3000](http://localhost:3000/).",
  "title": "Auth0 Python SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to a Python web Application built with the Flask framework and Authlib OAuth library.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/rails",
  "markdown": "# Auth0 Ruby On Rails SDK Quickstarts: Login\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Regular Web App](https://auth0.com/docs/quickstart/webapp)\n*   [Ruby On Rails](https://auth0.com/docs/quickstart/webapp/rails)\n*   [Login](https://auth0.com/docs/quickstart/webapp/rails/01-login)\n\nThis tutorial demonstrates how to add user login to a Ruby on Rails application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Ruby 2.5.0+ | Rails 6.0+ or Rails 5.0+ or Rails 4.2+\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n*   **Client Secret**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Install the Auth0 SDK\n\n### Install Dependencies\n\nThis tutorial uses `omniauth-auth0`, a custom [OmniAuth strategy](https://github.com/intridea/omniauth#omniauth-standardized-multi-provider-authentication), to handle the authentication flow. Add the following dependencies to your `Gemfile`:\n\n```\ngem 'omniauth-auth0', '~> 3.0'\ngem 'omniauth-rails_csrf_protection', '~> 1.0' # prevents forged authentication requests\n```\n\nOnce your gems are added, install the gems with `bundle install`:\n\n### Initialize Auth0 Configuration\n\nCreate an Auth0 config file `./config/auth0.yml`\n\n```\n# ./config/auth0.yml\ndevelopment:\n  auth0_domain: {yourDomain}\n  auth0_client_id: {yourClientId}\n  auth0_client_secret: <YOUR AUTH0 CLIENT SECRET>\n```\n\nCreate the following initializer file `./config/initializers/auth0.rb` and [configure](https://github.com/auth0/omniauth-auth0/blob/master/EXAMPLES.md#send-additional-authentication-parameters) the **OmniAuth** middleware.\n\n```\n# ./config/initializers/auth0.rb\nAUTH0_CONFIG = Rails.application.config_for(:auth0)\n\nRails.application.config.middleware.use OmniAuth::Builder do\n  provider(\n    :auth0,\n    AUTH0_CONFIG['auth0_client_id'],\n    AUTH0_CONFIG['auth0_client_secret'],\n    AUTH0_CONFIG['auth0_domain'],\n    callback_path: '/auth/auth0/callback',\n    authorize_params: {\n      scope: 'openid profile'\n    }\n  )\nend\n```\n\n### Add an Auth0 controller\n\nCreate an Auth0 controller for handling the authentication callback. Run the command `rails generate controller auth0 callback failure logout --skip-assets --skip-helper --skip-routes --skip-template-engine`.\n\nInside of the callback method assign the hash of user information, returned as `request.env['omniauth.auth']`, to the active session.\n\n```\n# ./app/controllers/auth0_controller.rb\nclass Auth0Controller < ApplicationController\n  def callback\n    # OmniAuth stores the information returned from Auth0 and the IdP in request.env['omniauth.auth'].\n    # In this code, you will pull the raw_info supplied from the id_token and assign it to the session.\n    # Refer to https://github.com/auth0/omniauth-auth0/blob/master/EXAMPLES.md#example-of-the-resulting-authentication-hash for complete information on 'omniauth.auth' contents.\n    auth_info = request.env['omniauth.auth']\n    session[:userinfo] = auth_info['extra']['raw_info']\n\n    # Redirect to the URL you want after successful auth\n    redirect_to '/dashboard'\n  end\n\n  def failure\n    # Handles failed authentication -- Show a failure page (you can also handle with a redirect)\n    @error_msg = request.params['message']\n  end\n\n  def logout\n    # you will finish this in a later step\n  end\nend\n```\n\nAdd the following routes to your `./config/routes.rb` file:\n\n```\n# ./config/routes.rb\nRails.application.routes.draw do\n  # ..\n  get '/auth/auth0/callback' => 'auth0#callback'\n  get '/auth/failure' => 'auth0#failure'\n  get '/auth/logout' => 'auth0#logout'\nend\n```\n\n## Add Login to Your Application\n\nA user can now log into your application by visiting the `/auth/auth0` endpoint.\n\n```\n<!-- Place a login button anywhere on your application -->\n  <%= button_to 'Login', '/auth/auth0', method: :post, data: { turbo: false } %>\n```\n\n## Add Logout to Your Application\n\nNow that you can log in to your Rails application, you need [a way to log out](https://auth0.com/docs/logout/guides/logout-auth0). Revisit the Auth0Controller you created earlier, and finish up the logout method added there.\n\nYou will need to clear out your session and then redirect the user to the Auth0 logout endpoint.\n\nTo clear out all the objects stored within the session, call the `reset_session` method within the `auth0_controller/logout` method. [Learn more about reset\\_session here](http://api.rubyonrails.org/classes/ActionController/Base.html#M000668). Add the following code to `./app/controllers/auth0_controller.rb`:\n\n```\n# ./app/controllers/auth0_controller.rb\nclass Auth0Controller < ApplicationController\n  # ..\n  # ..Insert the code below\n  def logout\n    reset_session\n    redirect_to logout_url, allow_other_host: true\n  end\n\n  private\n\n  def logout_url\n    request_params = {\n      returnTo: root_url,\n      client_id: AUTH0_CONFIG['auth0_client_id']\n    }\n\n    URI::HTTPS.build(host: AUTH0_CONFIG['auth0_domain'], path: '/v2/logout', query: request_params.to_query).to_s\n  end\nend\n```\n\nThe user will now be able to logout of your application by visiting the `/auth/logout` endpoint.\n\n```\n<!-- Place a logout button anywhere on your application -->\n  <%= button_to 'Logout', 'auth/logout', method: :get, data: { turbo: false } %>\n```\n\n## Show User Profile Information\n\nTo display the user's profile, your application should provide a protected route. You can use a controller `concern` to control access to routes. Create the following file `./app/controllers/concerns/secured.rb`\n\n```\n# ./app/controllers/concerns/secured.rb\nmodule Secured\n  extend ActiveSupport::Concern\n\n  included do\n    before_action :logged_in_using_omniauth?\n  end\n\n  def logged_in_using_omniauth?\n    redirect_to '/' unless session[:userinfo].present?\n  end\nend\n```\n\nAfter you have created the secured controller concern, include it in any controller that requires a logged in user. You can then access the user from the session `session[:userinfo]`.\n\n```\n# ./app/controllers/dashboard_controller.rb\nclass DashboardController < ApplicationController\n  include Secured\n\n  def show\n    # session[:userinfo] was saved earlier on Auth0Controller#callback\n    @user = session[:userinfo]\n  end\nend\n```\n\nNow that you have loaded the user from the session, you can use it to display information in your frontend.\n\n```\n<!-- ./app/views/dashboard/show.html.erb -->\n<div>\n  <p>Normalized User Profile:<%= JSON.pretty_generate(@user[:info])%></p>\n  <p>Full User Profile:<%= JSON.pretty_generate(@user[:extra][:raw_info])%></p>\n</div>\n```",
  "title": "Auth0 Ruby On Rails SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to a Ruby on Rails application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/golang",
  "markdown": "# Auth0 Go API SDK Quickstarts: Authorization\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [Go API](https://auth0.com/docs/quickstart/backend/golang)\n*   [Authorization](https://auth0.com/docs/quickstart/backend/golang/01-authorization)\n\nThis tutorial demonstrates how to add authorization to a Go API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to integrate with my app\n\n15 minutes\n\n1.  [Configure Auth0 APIs](#configure-auth0-apis)\n2.  [Validate Access Tokens](#validate-access-tokens)\n3.  [Protect API Endpoints](#protect-api-endpoints)\n\nOr\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Go 1.21+\n\n## Configure Auth0 APIs\n\n### Create an API\n\nIn the [APIs](https://manage.auth0.com/#/apis) section of the Auth0 dashboard, click **Create API**. Provide a name and an identifier for your API, for example, `https://quickstarts/api`. You will use the identifier as an `audience` later, when you are configuring the Access Token verification. Leave the **Signing Algorithm** as **RS256**.\n\n![Create API](https://auth0.com/docs/media/articles/server-apis/create-api.png)\n\nBy default, your API uses RS256 as the algorithm for signing tokens. Since RS256 uses a private/public keypair, it verifies the tokens against the public key for your Auth0 account. The public key is in the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) format, and can be accessed [here](https://{yourdomain}/.well-known/jwks.json).\n\n### Define permissions\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nThis example demonstrates:\n\n*   How to check for a JSON Web Token (JWT) in the `Authorization` header of an incoming HTTP request.\n    \n*   How to check if the token is valid, using the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) for your Auth0 account. To learn more about validating Access Tokens, see [Validate Access Tokens](https://auth0.com/docs/tokens/guides/validate-access-tokens).\n    \n\n## Validate Access Tokens\n\n### Download dependencies\n\nAdd a `go.mod` file to list all the dependencies to be used.\n\n```\n// go.mod\n\nmodule 01-Authorization-RS256\n\ngo 1.21\n\nrequire (\n\tgithub.com/auth0/go-jwt-middleware/v2 v2.2.0\n\tgithub.com/joho/godotenv v1.5.1\n)\n```\n\nDownload dependencies by running the following shell command:\n\n### Configure your application\n\nCreate a `.env` file within the root of your project directory to store the app configuration, and fill in the environment variables:\n\n```\n# The URL of our Auth0 Tenant Domain.\n# If you're using a Custom Domain, be sure to set this to that value instead.\nAUTH0_DOMAIN='{yourDomain}'\n\n# Our Auth0 API's Identifier.\nAUTH0_AUDIENCE='YOUR_API_IDENTIFIER'\n```\n\n### Create a middleware to validate Access Tokens\n\nAccess Token validation will be done in the `EnsureValidToken` middleware function which can be applied to any endpoints you wish to protect. If the token is valid, the resources which are served by the endpoint can be released, otherwise a `401 Authorization` error will be returned.\n\nSetup **go-jwt-middleware** middleware to verify Access Tokens from incoming requests.\n\n```\n// middleware/jwt.go\n\npackage middleware\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"time\"\n\n\tjwtmiddleware \"github.com/auth0/go-jwt-middleware/v2\"\n\t\"github.com/auth0/go-jwt-middleware/v2/jwks\"\n\t\"github.com/auth0/go-jwt-middleware/v2/validator\"\n)\n\n// CustomClaims contains custom data we want from the token.\ntype CustomClaims struct {\n\tScope string `json:\"scope\"`\n}\n\n// Validate does nothing for this example, but we need\n// it to satisfy validator.CustomClaims interface.\nfunc (c CustomClaims) Validate(ctx context.Context) error {\n\treturn nil\n}\n\n// EnsureValidToken is a middleware that will check the validity of our JWT.\nfunc EnsureValidToken() func(next http.Handler) http.Handler {\n\tissuerURL, err := url.Parse(\"https://\" + os.Getenv(\"AUTH0_DOMAIN\") + \"/\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to parse the issuer url: %v\", err)\n\t}\n\n\tprovider := jwks.NewCachingProvider(issuerURL, 5*time.Minute)\n\n\tjwtValidator, err := validator.New(\n\t\tprovider.KeyFunc,\n\t\tvalidator.RS256,\n\t\tissuerURL.String(),\n\t\t[]string{os.Getenv(\"AUTH0_AUDIENCE\")},\n\t\tvalidator.WithCustomClaims(\n\t\t\tfunc() validator.CustomClaims {\n\t\t\t\treturn &CustomClaims{}\n\t\t\t},\n\t\t),\n\t\tvalidator.WithAllowedClockSkew(time.Minute),\n\t)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to set up the jwt validator\")\n\t}\n\n\terrorHandler := func(w http.ResponseWriter, r *http.Request, err error) {\n\t\tlog.Printf(\"Encountered error while validating JWT: %v\", err)\n\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\tw.Write([]byte(`{\"message\":\"Failed to validate JWT.\"}`))\n\t}\n\n\tmiddleware := jwtmiddleware.New(\n\t\tjwtValidator.ValidateToken,\n\t\tjwtmiddleware.WithErrorHandler(errorHandler),\n\t)\n\n\treturn func(next http.Handler) http.Handler {\n\t\treturn middleware.CheckJWT(next)\n\t}\n}\n```\n\nBy default, your API uses RS256 as the algorithm for signing tokens. Since RS256 uses a private/public keypair, it verifies the tokens against the public key for your Auth0 account. The public key is in the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) format, and can be accessed [here](https://{yourdomain}/.well-known/jwks.json).\n\n## Protect API Endpoints\n\nTo protect individual routes, pass `middleware` (defined above) to the http route.\n\n```\n// main.go\n\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/joho/godotenv\"\n\n\t\"01-Authorization-RS256/middleware\"\n)\n\nfunc main() {\n\tif err := godotenv.Load(); err != nil {\n\t\tlog.Fatalf(\"Error loading the .env file: %v\", err)\n\t}\n\n\trouter := http.NewServeMux()\n\n\t// This route is always accessible.\n\trouter.Handle(\"/api/public\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(`{\"message\":\"Hello from a public endpoint! You don't need to be authenticated to see this.\"}`))\n\t}))\n\n\t// This route is only accessible if the user has a valid access_token.\n\trouter.Handle(\"/api/private\", middleware.EnsureValidToken()(\n\t\thttp.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t// CORS Headers.\n\t\t\tw.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\t\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"http://localhost:3000\")\n\t\t\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Authorization\")\n\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tw.Write([]byte(`{\"message\":\"Hello from a private endpoint! You need to be authenticated to see this.\"}`))\n\t\t}),\n\t))\n\n\tlog.Print(\"Server listening on http://localhost:3010\")\n\tif err := http.ListenAndServe(\"0.0.0.0:3010\", router); err != nil {\n\t\tlog.Fatalf(\"There was an error with the http server: %v\", err)\n\t}\n}\n```\n\n### Validate scopes\n\nThe `middleware` above verifies that the Access Token included in the request is valid; however, it doesn't yet include any mechanism for checking that the token has the sufficient **scope** to access the requested resources.\n\nCreate a function to check and ensure the Access Token has the correct scope before returning a successful response.\n\n```\n// 👆 We're continuing from the steps above. Append this to your middleware/jwt.go file.\n\n// HasScope checks whether our claims have a specific scope.\nfunc (c CustomClaims) HasScope(expectedScope string) bool {\n    result := strings.Split(c.Scope, \" \")\n    for i := range result {\n        if result[i] == expectedScope {\n            return true\n        }\n    }\n\n    return false\n}\n```\n\nUse this function in the endpoint that requires the scope `read:messages`.\n\n```\n// 👆 We're continuing from the steps above. Append this to your main.go file.\n\nfunc main() {\n    // ...\n    \n    // This route is only accessible if the user has a\n    // valid access_token with the read:messages scope.\n\trouter.Handle(\"/api/private-scoped\", middleware.EnsureValidToken()(\n\t\thttp.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t// CORS Headers.\n\t\t\tw.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\t\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"http://localhost:3000\")\n\t\t\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Authorization\")\n\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\t\t\ttoken := r.Context().Value(jwtmiddleware.ContextKey{}).(*validator.ValidatedClaims)\n\n\t\t\tclaims := token.CustomClaims.(*middleware.CustomClaims)\n\t\t\tif !claims.HasScope(\"read:messages\") {\n\t\t\t\tw.WriteHeader(http.StatusForbidden)\n\t\t\t\tw.Write([]byte(`{\"message\":\"Insufficient scope.\"}`))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tw.Write([]byte(`{\"message\":\"Hello from a private endpoint! You need to be authenticated to see this.\"}`))\n\t\t}),\n\t))\n    \n    // ...\n}\n```\n\nIn this example, only the `read:messages` scope is checked. You may want to extend the `HasScope` function or make it a standalone middleware that accepts multiple scopes to fit your use case.",
  "title": "Auth0 Go API SDK Quickstarts: Authorization",
  "description": "This tutorial demonstrates how to add authorization to a Go API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/laravel",
  "markdown": "# Add Authorization to a Laravel Application\n\nAuth0's Laravel SDK allows you to quickly add token-based authorization and route access control to your Laravel application. This guide demonstrates how to integrate Auth0 with a new or existing Laravel 9 or 10 application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n* * *\n\n**Backend applications differ from traditional web applications in that they do not handle user authentication or have a user interface. They provide an API that other applications can interact with. They accept [access tokens](https://auth0.com/docs/secure/tokens/access-tokens) from `Authorization` headers in requests to control access to routes.**\n\nSeparate front-end applications are usually built to interact with these types of backends. These can be anything from [single-page applications](https://auth0.com/docs/quickstart/spa) or [native or mobile apps](https://auth0.com/docs/quickstart/native) (all of which Auth0 also provides SDKs for!)\n\nWhen users need to interact with your backend application, they first authenticate with Auth0 using the frontend application. The frontend application then retrieves an access token from Auth0, which it can use to make requests to your backend application on behalf of the user.\n\nAs their name implies, [access tokens](https://auth0.com/docs/secure/tokens/access-tokens) are designed to address matters of access control (authorization), and do not contain information about the user. **Backend applications work exclusively with access tokens.** You can retrieve information about the user who created the token using the [Management API](https://auth0.com/docs/api/management/v2), which we will demonstrate later.\n\n## Laravel Installation\n\n**If you do not already have a Laravel application set up**, open a shell to a suitable directory for a new project and run the following command:\n\n```\ncomposer create-project --prefer-dist laravel/laravel auth0-laravel-api ^9.0\n```\n\nAll the commands in this guide assume you are running them from the root of your Laravel project, directory so you should `cd` into the new project directory:\n\n## SDK Installation\n\nRun the following command within your project directory to install the [Auth0 Laravel SDK](https://github.com/auth0/laravel-auth0):\n\n```\ncomposer require auth0/login:^7.8 --update-with-all-dependencies\n```\n\nThen generate an SDK configuration file for your application:\n\n```\nphp artisan vendor:publish --tag auth0\n```\n\n## SDK Configuration\n\nRun the following command from your project directory to download the [Auth0 CLI](https://github.com/auth0/auth0-cli):\n\n```\ncurl -sSfL https://raw.githubusercontent.com/auth0/auth0-cli/main/install.sh | sh -s -- -b .\n```\n\nThen authenticate the CLI with your Auth0 account, choosing \"as a user\" when prompted:\n\nNext, create a new application with Auth0:\n\n```\n./auth0 apps create \\\n  --name \"My Laravel Backend\" \\\n  --type \"regular\" \\\n  --auth-method \"post\" \\\n  --callbacks \"http://localhost:8000/callback\" \\\n  --logout-urls \"http://localhost:8000\" \\\n  --reveal-secrets \\\n  --no-input \\\n  --json > .auth0.app.json\n```\n\nYou should also create a new API:\n\n```\n./auth0 apis create \\\n  --name \"My Laravel Backend API\" \\\n  --identifier \"https://github.com/auth0/laravel-auth0\" \\\n  --offline-access \\\n  --no-input \\\n  --json > .auth0.api.json\n```\n\nThis produces two files in your project directory that configure the SDK.\n\nAs these files contain credentials it's important to treat these as sensitive. You should ensure you do not commit these to version control. If you're using Git, you should add them to your `.gitignore` file:\n\n```\necho \".auth0.*.json\" >> .gitignore\n```\n\n## Access Control\n\nYou can use the Auth0 SDK's authorization guard to restrict access to your application's routes.\n\nTo reject requests that do not contain a valid access token in the `Authorization` header, you can use Laravel's `auth` middleware:\n\n```\nRoute::get('/private', function () {\n  return response()->json([\n    'message' => 'Your token is valid; you are authorized.',\n  ]);\n})->middleware('auth');\n```\n\nYou can also require the provided token to have specific [permissions](https://auth0.com/docs/manage-users/access-control/rbac) by combining this with Laravel's `can` middleware:\n\n```\nRoute::get('/scope', function () {\n    return response()->json([\n      'message' => 'Your token is valid and has the `read:messages` permission; you are authorized.',\n    ]);\n})->middleware('auth')->can('read:messages');\n```\n\n## Token Information\n\nInformation about the provided access token is available through Laravel's `Auth` Facade, or the `auth()` helper function.\n\nFor example, to retrieve the user's identifier and email address:\n\n```\nRoute::get('/', function () {\n  if (! auth()->check()) {\n    return response()->json([\n      'message' => 'You did not provide a valid token.',\n    ]);\n  }\n\n  return response()->json([\n    'message' => 'Your token is valid; you are authorized.',\n    'id' => auth()->id(),\n    'token' => auth()?->user()?->getAttributes(),\n  ]);\n});\n```\n\n## Retrieve User Information\n\nYou can retrieve information about the user who created the access token from Auth0 using the [Auth0 Management API](https://github.com/auth0/laravel-auth0/blob/main/docs/Management.md). The SDK provides a convenient wrapper for this API, accessible through the SDK's `management()` method.\n\n**Before making Management API calls you must enable your application to communicate with the Management API.** This can be done from the [Auth0 Dashboard's API page](https://manage.auth0.com/#/apis/), choosing `Auth0 Management API`, and selecting the 'Machine to Machine Applications' tab. Authorize your Laravel application, and then click the down arrow to choose the scopes you wish to grant.\n\nFor the following example, you should grant the `read:users` scope. A list of API endpoints and the required scopes can be found in [the Management API documentation](https://auth0.com/docs/api/management/v2).\n\n```\nuse Auth0\\Laravel\\Facade\\Auth0;\n\nRoute::get('/me', function () {\n  $user = auth()->id();\n  $profile = cache()->get($user);\n\n  if (null === $profile) {\n    $endpoint = Auth0::management()->users();\n    $profile = $endpoint->get($user);\n    $profile = Auth0::json($profile);\n\n    cache()->put($user, $profile, 120);\n  }\n\n  $name = $profile['name'] ?? 'Unknown';\n  $email = $profile['email'] ?? 'Unknown';\n\n  return response()->json([\n    'name' => $name,\n    'email' => $email,\n  ]);\n})->middleware('auth');\n```\n\n## Run the Application\n\nYou are now ready to start your Laravel application, so it can accept requests:\n\n## Retrieve a Test Token\n\nYou can learn more about [retrieving access tokens here](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens). For this quickstart, however, you can simply use an access token from [your API settings' \"test\" view](https://manage.auth0.com/#/apis).\n\n## Checkpoint\n\nOpen a shell and try issuing requests to your application.\n\nBegin by requesting the public route:\n\n```\ncurl --request GET \\\n  --url http://localhost:8000/api \\\n  --header 'Accept: application/json'\n```\n\nNext, use your access token in an `Authorization` header to request a protected route:\n\n```\ncurl --request GET \\\n  --url http://localhost:8000/api/private \\\n  --header 'Accept: application/json' \\\n  --header 'Authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\nFinally, try requesting the scope-protected route, which will only succeed if the access token has the `read:messages` scope granted:\n\n```\ncurl --request GET \\\n  --url http://localhost:8000/api/scope \\\n  --header 'Accept: application/json' \\\n  --header 'Authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\nIf you have any issues, here are a couple of things to try:\n\n*   Try running `php artisan optimize:clear` to clear Laravel's cache.\n*   Ensure your `.auth0.app.json` and `.auth0.api.json` files are at the root of your project.\n*   Ensure you have enabled your Laravel application as a Machine-to-Machine application and granted it all the necessary scopes for the `Auth0 Management API` from the [Auth0 Dashboard](https://manage.auth0.com/#/apis/).\n\nEncountering problems? Check the SDK's [documentation](https://github.com/auth0/laravel-auth0) or our [documentation hub](https://auth0.com/docs). You should also consider visiting [the community](https://community.auth0.com/) where our team and other community members can help answer your questions.\n\n### Additional Reading\n\n*   [User Repositories and Models](https://github.com/auth0/laravel-auth0/blob/main/docs/Users.md) extends the Auth0 Laravel SDK to use custom user models, and how to store and retrieve users from a database.\n*   [Hooking Events](https://github.com/auth0/laravel-auth0/blob/main/docs/Events.md) covers how to listen for events raised by the Auth0 Laravel SDK, to fully customize the behavior of your integration.\n*   [Management API](https://github.com/auth0/laravel-auth0/blob/main/docs/Management.md) support is built into the Auth0 Laravel SDK, allowing you to interact with the Management API from your Laravel application.",
  "title": "Auth0 Laravel API SDK Quickstarts: Add Authorization to a Laravel Application",
  "description": "Auth0's Laravel SDK allows you to quickly add token-based authorization and route access control to your Laravel application. This guide demonstrates how to integrate Auth0 with a new or existing Laravel 9 or 10 application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/nodejs",
  "markdown": "# Auth0 Node (Express) API SDK Quickstarts: Authorization\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [Node (Express) API](https://auth0.com/docs/quickstart/backend/nodejs)\n*   [Authorization](https://auth0.com/docs/quickstart/backend/nodejs/01-authorization)\n\nThis tutorial demonstrates how to add authorization to an Express.js API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to integrate with my app\n\n15 minutes\n\n1.  [Configure Auth0 APIs](#configure-auth0-apis)\n2.  [Validate Access Tokens](#validate-access-tokens)\n3.  [Protect API Endpoints](#protect-api-endpoints)\n\nOr\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: express-oauth2-jwt-bearer 1.0.0\n\n## Configure Auth0 APIs\n\n### Create an API\n\nIn the [APIs](https://manage.auth0.com/#/apis) section of the Auth0 dashboard, click **Create API**. Provide a name and an identifier for your API, for example, `https://quickstarts/api`. You will use the identifier as an `audience` later, when you are configuring the Access Token verification. Leave the **Signing Algorithm** as **RS256**.\n\n![Create API](https://auth0.com/docs/media/articles/server-apis/create-api.png)\n\nBy default, your API uses RS256 as the algorithm for signing tokens. Since RS256 uses a private/public keypair, it verifies the tokens against the public key for your Auth0 account. The public key is in the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) format, and can be accessed [here](https://{yourdomain}/.well-known/jwks.json).\n\n### Define permissions\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nThis example demonstrates:\n\n*   How to check for a JSON Web Token (JWT) in the `Authorization` header of an incoming HTTP request.\n    \n*   How to check if the token is valid, using the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) for your Auth0 account. To learn more about validating Access Tokens, see [Validate Access Tokens](https://auth0.com/docs/tokens/guides/validate-access-tokens).\n    \n\n## Validate Access Tokens\n\n### Install dependencies\n\nThis guide shows you how to protect an Express API using the [express-oauth2-jwt-bearer](https://github.com/auth0/node-oauth2-jwt-bearer/tree/main/packages/express-oauth2-jwt-bearer) middleware.\n\nFirst install the SDK using npm.\n\n```\nnpm install --save express-oauth2-jwt-bearer\n```\n\n### Configure the middleware\n\nConfigure `express-oauth2-jwt-bearer` with your Domain and API Identifier.\n\n```\n// server.js\n\nconst express = require('express');\nconst app = express();\nconst { auth } = require('express-oauth2-jwt-bearer');\n\n// Authorization middleware. When used, the Access Token must\n// exist and be verified against the Auth0 JSON Web Key Set.\nconst checkJwt = auth({\n  audience: '{yourApiIdentifier}',\n  issuerBaseURL: `https://{yourDomain}/`,\n});\n```\n\nThe `checkJwt` middleware shown above checks if the user's Access Token included in the request is valid. If the token is not valid, the user gets a 401 Authorization error when they try to access the endpoints. The middleware doesn't check if the token has the sufficient scope to access the requested resources.\n\n## Protect API Endpoints\n\nThe routes shown below are available for the following requests:\n\n*   `GET /api/public`: available for non-authenticated requests\n*   `GET /api/private`: available for authenticated requests containing an access token with no additional scopes\n*   `GET /api/private-scoped`: available for authenticated requests containing an access token with the `read:messages` scope granted\n\nTo protect an individual route that requires a valid JWT, configure the route with the `checkJwt` `express-oauth2-jwt-bearer` middleware.\n\n```\n// server.js\n\n// This route doesn't need authentication\napp.get('/api/public', function(req, res) {\n  res.json({\n    message: 'Hello from a public endpoint! You don\\'t need to be authenticated to see this.'\n  });\n});\n\n// This route needs authentication\napp.get('/api/private', checkJwt, function(req, res) {\n  res.json({\n    message: 'Hello from a private endpoint! You need to be authenticated to see this.'\n  });\n});\n```\n\nYou can configure individual routes to look for a particular scope. To achieve that, set up another middleware with the `requiresScope` method. Provide the required scopes and apply the middleware to any routes you want to add authorization to.\n\nPass the `checkJwt` and `requiredScopes` middlewares to the route you want to protect.\n\n```\n// server.js\nconst { requiredScopes } = require('express-oauth2-jwt-bearer');\n\nconst checkScopes = requiredScopes('read:messages');\n\napp.get('/api/private-scoped', checkJwt, checkScopes, function(req, res) {\n  res.json({\n    message: 'Hello from a private endpoint! You need to be authenticated and have a scope of read:messages to see this.'\n  });\n});\n```\n\nIn this configuration, only Access Tokens with the `read:messages` scope can access the endpoint.",
  "title": "Auth0 Node (Express) API SDK Quickstarts: Authorization",
  "description": "This tutorial demonstrates how to add authorization to an Express.js API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/php",
  "markdown": "# Auth0 PHP API SDK Quickstarts: Authorization\n\nThis guide demonstrates how to integrate Auth0 with a PHP backend API using the Auth0 PHP SDK. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Configure Auth0 APIs\n\n### Create an API\n\nIn the [APIs](https://manage.auth0.com/#/apis) section of the Auth0 dashboard, click **Create API**. Provide a name and an identifier for your API, for example, `https://quickstarts/api`. You will use the identifier as an `audience` later, when you are configuring the Access Token verification. Leave the **Signing Algorithm** as **RS256**.\n\n![Create API](https://auth0.com/docs/media/articles/server-apis/create-api.png)\n\nBy default, your API uses RS256 as the algorithm for signing tokens. Since RS256 uses a private/public keypair, it verifies the tokens against the public key for your Auth0 account. The public key is in the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) format, and can be accessed [here](https://{yourdomain}/.well-known/jwks.json).\n\n### Define permissions\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nThis example demonstrates:\n\n*   How to check for a JSON Web Token (JWT) in the `Authorization` header of an incoming HTTP request.\n    \n*   How to check if the token is valid, using the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) for your Auth0 account. To learn more about validating Access Tokens, see [Validate Access Tokens](https://auth0.com/docs/tokens/guides/validate-access-tokens).\n    \n\n## Integrating your PHP Backend API\n\nLet's create a sample application that authorizes an Auth0-signed token with a backend API we've written in PHP. We'll take a simple approach here, appropriate for the written format. Still, you should check out the accompanying [Quickstart app on GitHub](https://github.com/auth0-samples/auth0-php-api-samples/) for a more robust example.\n\n### Installing HTTP Client and Messaging Factories\n\nThe Auth0 PHP SDK supports many PHP-FIG standards to offer maximum interoperability with your project's architecture, but two of particular importance are [PSR-17](https://www.php-fig.org/psr/psr-17/) and [PSR-18](https://www.php-fig.org/psr/psr-18/). These standards allow you to \"plugin\" networking components of your choice to handle messaging and requests. You will need to install compatible libraries in your project for the SDK to use.\n\nThe most prolific networking library for PHP is Guzzle, although many are available to pick from within the PHP community. Let's use Guzzle for this sample application:\n\n```\ncomposer require guzzlehttp/guzzle guzzlehttp/psr7 http-interop/http-factory-guzzle\n```\n\n### Installing the PHP SDK\n\nThe Auth0 PHP SDK requires [Composer](https://getcomposer.org/doc/00-intro.md#installation-linux-unix-macos), a tool for dependency management in PHP. Composer allows you to declare the dependent libraries your project needs and installs them for you. Please ensure Composer is installed and accessible from your shell before continuing.\n\nRun the following shell command within your project directory to install the Auth0 PHP SDK:\n\n```\ncomposer require auth0/auth0-php\n```\n\nThis will create a `vendor` folder within your project and download all the dependencies needed to use the Auth0 PHP SDK. This will also create a `vendor/autoload.php` file used in the sample to load all necessary classes for your application to function. It's important you require this autoload file in your project for the SDK to work.\n\n### Configure the SDK\n\nTo begin, let's create a `.env` file within the root of your project directory to store our sample application's configuration and fill in the environment variables:\n\n```\n# The URL of our Auth0 Tenant Domain.\n# If we're using a Custom Domain, be sure to set this to that value instead.\nAUTH0_DOMAIN='https://{yourDomain}'\n\n# Our Auth0 application's Client ID.\nAUTH0_CLIENT_ID='{yourClientId}'\n\n# Our Auth0 application's Client Secret.\nAUTH0_CLIENT_SECRET='{yourClientSecret}'\n\n# Our Auth0 API's Identifier.\nAUTH0_AUDIENCE='YOUR_API_IDENTIFIER'\n```\n\nAs PHP isn't able to read our `.env` file by itself, we'll want to install a library to help with that. Although we'll be using a particular library for our sample application's purposes, any 'dotenv' loader of preference will work in a real-world application. From our project directory, let's run the following shell command to install the library:\n\n```\ncomposer require vlucas/phpdotenv\n```\n\nNext, let's create the PHP source file we'll be using for these code samples, `index.php`, and let's configure an instance of the Auth0 PHP SDK for our sample application:\n\n```\n<?php\n\n// Import the Composer Autoloader to make the SDK classes accessible:\nrequire 'vendor/autoload.php';\n\n// Load our environment variables from the .env file:\n(Dotenv\\Dotenv::createImmutable(__DIR__))->load();\n\n// Now instantiate the Auth0 class with our configuration:\n$auth0 = new \\Auth0\\SDK\\Auth0([\n    'strategy' => \\Auth0\\SDK\\Configuration\\SdkConfiguration::STRATEGY_API,\n    'domain' => $_ENV['AUTH0_DOMAIN'],\n    'clientId' => $_ENV['AUTH0_CLIENT_ID'],\n    'clientSecret' => $_ENV['AUTH0_CLIENT_SECRET'],\n    'audience' => ($_ENV['AUTH0_AUDIENCE'] ?? null) !== null ? [trim($_ENV['AUTH0_AUDIENCE'])] : null,\n]);\n```\n\n### Authenticating the user\n\nFor this sample application, we're focusing on [authorization](https://auth0.com/intro-to-iam/authentication-vs-authorization/). There's numerous routes you could go for authenticating your users before they hit your backend API for authorization, such as using [Auth0's SPA.js library](https://github.com/auth0/auth0-spa-js). This approach is demonstrated in [this Quickstart app accompanying Github project](https://github.com/auth0-samples/auth0-php-api-samples/). Regardless of the approach you take, this sample application expects you to pass your Access Token to it through a request parameter or header to work.\n\n### Authorizing an Access Token\n\nFirst, we need to extract the JSON Web Token (JWT) from the incoming HTTP request. Let's look for a `?token` parameter in a GET request or an `HTTP_AUTHORIZATION` or `Authorization` header.\n\n```\n// 👆 We're continuing from the steps above. Append this to your index.php file.\n\n$jwt = $_GET['token'] ?? $_SERVER['HTTP_AUTHORIZATION'] ?? $_SERVER['Authorization'] ?? null;\n```\n\nNext, let's decode the token, if one is present:\n\n```\n// 👆 We're continuing from the steps above. Append this to your index.php file.\n\n// If a token is present, process it.\nif ($jwt !== null) {\n    // Trim whitespace from token string.\n    $jwt = trim($jwt);\n\n    // Remove the 'Bearer ' prefix, if present, in the event we're getting an Authorization header that's using it.\n    if (substr($jwt, 0, 7) === 'Bearer ') {\n        $jwt = substr($jwt, 7);\n    }\n\n    // Attempt to decode the token:\n    try {\n        $token = $auth0->decode($jwt, null, null, null, null, null, null, \\Auth0\\SDK\\Token::TYPE_TOKEN);\n        define('ENDPOINT_AUTHORIZED', true);\n    } catch (\\Auth0\\SDK\\Exception\\InvalidTokenException $exception) {\n        // The token wasn't valid. Let's display the error message from the Auth0 SDK.\n        // We'd probably want to show a custom error here for a real world application.\n        die($exception->getMessage());\n    }\n}\n```\n\nDepending on how you configure your API routing, how exactly you integrate these checks might look a little different, but the principle is the same: check the token, and in the event your API endpoint requires authorization, deny access if the token isn't valid or acceptable:\n\n```\n// 👆 We're continuing from the steps above. Append this to your index.php file.\n\n// Is the request authorized?\nif (defined('ENDPOINT_AUTHORIZED')) {\n    // Respond with a JSON response:\n    echo json_encode([\n        'authorized' => true,\n        'data' => $token->toArray()\n    ], JSON_PRETTY_PRINT);\n\n    exit;\n}\n\n// Issue a HTTP 401 Unauthorized status:\nhttp_response_code(401);\n\n// Respond with a JSON response:\necho json_encode([\n    'authorized' => false,\n    'error' => [\n        'message' => 'You are NOT authorized to be here!'\n    ]\n], JSON_PRETTY_PRINT);\n```\n\n### Caching\n\nThis works, but in a real-world application, we'll want to use caching to ensure we don't hit our Auth0 rate limits or slow down our application with unnecessary network requests. The Auth0 PHP SDK supports a caching interface called [PSR-6](https://www.php-fig.org/psr/psr-6), which you can plug [any compatible caching library](https://packagist.org/providers/psr/cache-implementation) into for the SDK to fit in nicely with your architecture.\n\nFor our sample, let's use the [Symfony caching component](https://symfony.com/doc/current/components/cache.html) library. From our root project directory, issue the following shell command:\n\n```\ncomposer require symfony/cache\n```\n\nNext, we need to update our SdkConfiguration to tell the SDK to use it:\n\n```\n// ✋ Insert this BEFORE the token handling we added in the step above, so the SDK uses the cache.\n\n$tokenCache = new \\Symfony\\Component\\Cache\\Adapter\\FilesystemAdapter();\n$auth0->configuration()->setTokenCache($tokenCache);\n```\n\nOur sample application will now cache our token-related network requests.",
  "title": "Auth0 PHP API SDK Quickstarts: Authorization",
  "description": "This guide demonstrates how to integrate Auth0 with a PHP backend API using the Auth0 PHP SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/rails",
  "markdown": "# Auth0 Ruby On Rails API SDK Quickstarts: Authorization\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [Ruby On Rails API](https://auth0.com/docs/quickstart/backend/rails)\n*   [Authorization](https://auth0.com/docs/quickstart/backend/rails/01-authorization)\n\nThis tutorial demonstrates how to add authorization to a Ruby on Rails API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to integrate with my app\n\n15 minutes\n\n1.  [Configure Auth0 APIs](#configure-auth0-apis)\n2.  [Validate Access Tokens](#validate-access-tokens)\n3.  [Protect API Endpoints](#protect-api-endpoints)\n\nOr\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Ruby 2.1.8 | Rails 4.2.5\n\n## Configure Auth0 APIs\n\n### Create an API\n\nIn the [APIs](https://manage.auth0.com/#/apis) section of the Auth0 dashboard, click **Create API**. Provide a name and an identifier for your API, for example, `https://quickstarts/api`. You will use the identifier as an `audience` later, when you are configuring the Access Token verification. Leave the **Signing Algorithm** as **RS256**.\n\n![Create API](https://auth0.com/docs/media/articles/server-apis/create-api.png)\n\nBy default, your API uses RS256 as the algorithm for signing tokens. Since RS256 uses a private/public keypair, it verifies the tokens against the public key for your Auth0 account. The public key is in the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) format, and can be accessed [here](https://{yourdomain}/.well-known/jwks.json).\n\n### Define permissions\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nThis example demonstrates:\n\n*   How to check for a JSON Web Token (JWT) in the `Authorization` header of an incoming HTTP request.\n    \n*   How to check if the token is valid, using the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) for your Auth0 account. To learn more about validating Access Tokens, see [Validate Access Tokens](https://auth0.com/docs/tokens/guides/validate-access-tokens).\n    \n\n## Validate Access Tokens\n\n### Install dependencies\n\nThis tutorial performs access token validation using the **[jwt](https://github.com/jwt/ruby-jwt)** Gem within a custom `Auth0Client` class. A Concern called `Secured` is used to authorize endpoints which require authentication through an incoming access token.\n\nInstall the **jwt** Gem.\n\n### Create an Auth0Client class\n\nCreate a class called `Auth0Client` which decodes and verifies the incoming access token taken from the `Authorization` header of the request. The public key for your Auth0 tenant can be fetched to verify the token.\n\n```\n# app/lib/auth0_client.rb\n\n# frozen_string_literal: true\n\nrequire 'jwt'\nrequire 'net/http'\n\nclass Auth0Client \n\n  # Auth0 Client Objects \n  Error = Struct.new(:message, :status)\n  Response = Struct.new(:decoded_token, :error)\n\n  # Helper Functions \n  def self.domain_url\n    \"https://#{Rails.configuration.auth0.domain}/\"\n  end\n\n  def self.decode_token(token, jwks_hash)\n    JWT.decode(token, nil, true, {\n                 algorithm: 'RS256',\n                 iss: domain_url,\n                 verify_iss: true,\n                 aud: Rails.configuration.auth0.audience,\n                 verify_aud: true,\n                 jwks: { keys: jwks_hash[:keys] }\n               })\n  end\n\n  def self.get_jwks\n    jwks_uri = URI(\"#{domain_url}.well-known/jwks.json\")\n    Net::HTTP.get_response jwks_uri\n  end\n\n  # Token Validation \n  def self.validate_token(token)\n    jwks_response = get_jwks\n\n    unless jwks_response.is_a? Net::HTTPSuccess\n      error = Error.new(message: 'Unable to verify credentials', status: :internal_server_error)\n      return Response.new(nil, error)\n    end\n\n    jwks_hash = JSON.parse(jwks_response.body).deep_symbolize_keys\n\n    decoded_token = decode_token(token, jwks_hash)\n\n    Response.new(decoded_token, nil)\n  rescue JWT::VerificationError, JWT::DecodeError => e\n    error = Error.new('Bad credentials', :unauthorized)\n    Response.new(nil, error)\n  end\nend\n```\n\n### Define a Secured concern\n\nCreate a Concern called `Secured` which looks for the access token in the `Authorization` header of an incoming request. If the token is present, it should be passed to `Auth0Client.validate_token`.\n\n```\n# app/controllers/concerns/secured.rb\n\n# frozen_string_literal: true\n\nmodule Secured\n  extend ActiveSupport::Concern\n\n  REQUIRES_AUTHENTICATION = { message: 'Requires authentication' }.freeze\n  BAD_CREDENTIALS = {\n    message: 'Bad credentials'\n  }.freeze\n  MALFORMED_AUTHORIZATION_HEADER = {\n    error: 'invalid_request',\n    error_description: 'Authorization header value must follow this format: Bearer access-token',\n    message: 'Bad credentials'\n  }.freeze\n\n  def authorize\n    token = token_from_request\n\n    return if performed?\n    \n    validation_response = Auth0Client.validate_token(token)\n    \n    return unless (error = validation_response.error)\n    \n    render json: { message: error.message }, status: error.status\n  end\n\n  private\n\n  def token_from_request\n    authorization_header_elements = request.headers['Authorization']&.split\n\n    render json: REQUIRES_AUTHENTICATION, status: :unauthorized and return unless authorization_header_elements\n\n    unless authorization_header_elements.length == 2\n      render json: MALFORMED_AUTHORIZATION_HEADER, status: :unauthorized and return\n    end\n\n    scheme, token = authorization_header_elements\n\n    render json: BAD_CREDENTIALS, status: :unauthorized and return unless scheme.downcase == 'bearer'\n\n    token\n  end\nend\n```\n\n### Validate scopes\n\nThe `Auth0Client.validate_token` method above verifies that the access token included in the request is valid; however, it doesn't yet include any mechanism for checking that the token has the sufficient **scope** to access the requested resources.\n\nTo look for a particular `scope` in an access token, create a new struct in your `Auth0Client` class called `Token` and define a new method inside, `validate_permissions`, that given an array of required scopes it will check if they are present in the payload of the token.\n\nGo to the `Auth0Client` class. Add the new `Token` struct and update the return value of the `validate_token` method as follows:\n\n```\n# app/lib/auth0_client.rb\n\n# frozen_string_literal: true\n\nrequire 'jwt'\nrequire 'net/http'\n\nclass Auth0Client \n\n  # Auth0 Client Objects \n  Error = Struct.new(:message, :status)\n  Response = Struct.new(:decoded_token, :error)\n\n  Token = Struct.new(:token) do\n    def validate_permissions(permissions)\n      required_permissions = Set.new permissions\n      scopes = token[0]['scope']\n      token_permissions = scopes.present? ? Set.new(scopes.split(\" \")) : Set.new\n      required_permissions <= token_permissions\n    end\n  end\n\n  # ... \n\n  # Token Validation \n  def self.validate_token(token)\n    jwks_response = get_jwks\n\n    unless jwks_response.is_a? Net::HTTPSuccess\n      error = Error.new(message: 'Unable to verify credentials', status: :internal_server_error)\n      return Response.new(nil, error)\n    end\n\n    jwks_hash = JSON.parse(jwks_response.body).deep_symbolize_keys\n\n    decoded_token = decode_token(token, jwks_hash)\n\n    Response.new(Token.new(decoded_token), nil)\n  rescue JWT::VerificationError, JWT::DecodeError => e\n    error = Error.new('Bad credentials', :unauthorized)\n    Response.new(nil, error)\n  end\nend\n```\n\nNext, in the `Secured` concern, define a new error constant `INSUFFICIENT_PERMISSIONS` to return a proper error message in case there was a attempt to request a resource without the right permissions. Next, update the return value of the `Auth0Client.validate_token` call and finally create a new method `validate_permissions` where to check if the token has the right permissions, or return a `403 FORBIDDEN` status code with the `INSUFFICIENT_PERMISSIONS` error message otherwise.\n\nApply these changes in your `Secured` concern by adding the following code:\n\n```\n# app/controllers/concerns/secured.rb\n\n# frozen_string_literal: true\n\nmodule Secured\n  extend ActiveSupport::Concern\n\n  # ... \n\n  INSUFFICIENT_PERMISSIONS = {\n    error: 'insufficient_permissions',\n    error_description: 'The access token does not contain the required permissions',\n    message: 'Permission denied'\n  }.freeze\n\n  def authorize\n    token = token_from_request\n\n    return if performed?\n\n    validation_response = Auth0Client.validate_token(token)\n\n    @decoded_token = validation_response.decoded_token # Add this line\n\n    return unless (error = validation_response.error)\n\n    render json: { message: error.message }, status: error.status\n  end\n\n  def validate_permissions(permissions)\n    raise 'validate_permissions needs to be called with a block' unless block_given?\n    return yield if @decoded_token.validate_permissions(permissions)\n\n    render json: INSUFFICIENT_PERMISSIONS, status: :forbidden\n  end\n\n  private\n  # ... \nend\n```\n\n## Protect API Endpoints\n\nThe routes shown below are available for the following requests:\n\n*   `GET /api/public`: available for non-authenticated requests\n*   `GET /api/private`: available for authenticated requests containing an access token with no additional scopes\n*   `GET /api/private-scoped`: available for authenticated requests containing an access token with the `read:messages` scope granted\n\nAdd the `Secured` concern to the `ApplicationController`:\n\n```\nclass ApplicationController < ActionController::API\n  include Secured\nend\n```\n\nYou only ned to protect the `PrivateController` as follows:\n\n```\nclass PrivateController < ApplicationController\n  before_action :authorize\n\n  # ...\nend\n```\n\nIn order to check that your access token has the right permissions, call the `validate_permissions` method as follows in the `private-scoped` action:\n\n```\nclass PrivateController < ApplicationController\n  before_action :authorize\n\n  def private\n    render json: { message: 'Hello from a private endpoint! You need to be authenticated to see this.' }\n  end\n\n  def private_scoped\n    validate_permissions ['read:messages'] do\n      render json: { message: 'Hello from a private endpoint! You need to be authenticated and have a scope of read:messages to see this.' }\n    end\n  end\nend\n```",
  "title": "Auth0 Ruby On Rails API SDK Quickstarts: Authorization",
  "description": "This tutorial demonstrates how to add authorization to a Ruby on Rails API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/python",
  "markdown": "# Auth0 Python API SDK Quickstarts: Authorization\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [Python API](https://auth0.com/docs/quickstart/backend/python)\n*   [Authorization](https://auth0.com/docs/quickstart/backend/python/01-authorization)\n\nThis tutorial demonstrates how to add authorization to a Python API built with Flask. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to integrate with my app\n\n15 minutes\n\n1.  [Configure Auth0 APIs](#configure-auth0-apis)\n2.  [Validate Access Tokens](#validate-access-tokens)\n3.  [Protect API Endpoints](#protect-api-endpoints)\n\nOr\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Python 3.6 and up | Flask 2.0 | Authlib 1.0\n\n## Configure Auth0 APIs\n\n### Create an API\n\nIn the [APIs](https://manage.auth0.com/#/apis) section of the Auth0 dashboard, click **Create API**. Provide a name and an identifier for your API, for example, `https://quickstarts/api`. You will use the identifier as an `audience` later, when you are configuring the Access Token verification. Leave the **Signing Algorithm** as **RS256**.\n\n![Create API](https://auth0.com/docs/media/articles/server-apis/create-api.png)\n\nBy default, your API uses RS256 as the algorithm for signing tokens. Since RS256 uses a private/public keypair, it verifies the tokens against the public key for your Auth0 account. The public key is in the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) format, and can be accessed [here](https://{yourdomain}/.well-known/jwks.json).\n\n### Define permissions\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nThis example demonstrates:\n\n*   How to check for a JSON Web Token (JWT) in the `Authorization` header of an incoming HTTP request.\n    \n*   How to check if the token is valid, using the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) for your Auth0 account. To learn more about validating Access Tokens, see [Validate Access Tokens](https://auth0.com/docs/tokens/guides/validate-access-tokens).\n    \n\n## Validate Access Tokens\n\n### Install dependencies\n\nAdd the following dependencies to your `requirements.txt`:\n\n```\n# /requirements.txt\n\nflask\npython-dotenv\npython-jose\nflask-cors\nsix\n```\n\n### Create a Flask application\n\nCreate a `server.py` file and initialize the [Flask](http://flask.pocoo.org/) application. Set the domain, audience and the error handling.\n\n```\n# /server.py\n\nimport json\nfrom six.moves.urllib.request import urlopen\nfrom functools import wraps\n\nfrom flask import Flask, request, jsonify, _request_ctx_stack\nfrom flask_cors import cross_origin\nfrom jose import jwt\n\nAUTH0_DOMAIN = '{yourDomain}'\nAPI_AUDIENCE = YOUR_API_AUDIENCE\nALGORITHMS = [\"RS256\"]\n\nAPP = Flask(__name__)\n\n# Error handler\nclass AuthError(Exception):\n    def __init__(self, error, status_code):\n        self.error = error\n        self.status_code = status_code\n\n@APP.errorhandler(AuthError)\ndef handle_auth_error(ex):\n    response = jsonify(ex.error)\n    response.status_code = ex.status_code\n    return response\n```\n\n### Create the JWT validation decorator\n\nAdd a decorator which verifies the Access Token against your JWKS.\n\n```\n# /server.py\n\n# Format error response and append status code\ndef get_token_auth_header():\n    \"\"\"Obtains the Access Token from the Authorization Header\n    \"\"\"\n    auth = request.headers.get(\"Authorization\", None)\n    if not auth:\n        raise AuthError({\"code\": \"authorization_header_missing\",\n                        \"description\":\n                            \"Authorization header is expected\"}, 401)\n\n    parts = auth.split()\n\n    if parts[0].lower() != \"bearer\":\n        raise AuthError({\"code\": \"invalid_header\",\n                        \"description\":\n                            \"Authorization header must start with\"\n                            \" Bearer\"}, 401)\n    elif len(parts) == 1:\n        raise AuthError({\"code\": \"invalid_header\",\n                        \"description\": \"Token not found\"}, 401)\n    elif len(parts) > 2:\n        raise AuthError({\"code\": \"invalid_header\",\n                        \"description\":\n                            \"Authorization header must be\"\n                            \" Bearer token\"}, 401)\n\n    token = parts[1]\n    return token\n\ndef requires_auth(f):\n    \"\"\"Determines if the Access Token is valid\n    \"\"\"\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        token = get_token_auth_header()\n        jsonurl = urlopen(\"https://\"+AUTH0_DOMAIN+\"/.well-known/jwks.json\")\n        jwks = json.loads(jsonurl.read())\n        unverified_header = jwt.get_unverified_header(token)\n        rsa_key = {}\n        for key in jwks[\"keys\"]:\n            if key[\"kid\"] == unverified_header[\"kid\"]:\n                rsa_key = {\n                    \"kty\": key[\"kty\"],\n                    \"kid\": key[\"kid\"],\n                    \"use\": key[\"use\"],\n                    \"n\": key[\"n\"],\n                    \"e\": key[\"e\"]\n                }\n        if rsa_key:\n            try:\n                payload = jwt.decode(\n                    token,\n                    rsa_key,\n                    algorithms=ALGORITHMS,\n                    audience=API_AUDIENCE,\n                    issuer=\"https://\"+AUTH0_DOMAIN+\"/\"\n                )\n            except jwt.ExpiredSignatureError:\n                raise AuthError({\"code\": \"token_expired\",\n                                \"description\": \"token is expired\"}, 401)\n            except jwt.JWTClaimsError:\n                raise AuthError({\"code\": \"invalid_claims\",\n                                \"description\":\n                                    \"incorrect claims,\"\n                                    \"please check the audience and issuer\"}, 401)\n            except Exception:\n                raise AuthError({\"code\": \"invalid_header\",\n                                \"description\":\n                                    \"Unable to parse authentication\"\n                                    \" token.\"}, 401)\n\n            _request_ctx_stack.top.current_user = payload\n            return f(*args, **kwargs)\n        raise AuthError({\"code\": \"invalid_header\",\n                        \"description\": \"Unable to find appropriate key\"}, 401)\n    return decorated\n```\n\n### Validate scopes\n\nIndividual routes can be configured to look for a particular `scope` in the Access Token by using the following:\n\n```\n# /server.py\n\ndef requires_scope(required_scope):\n    \"\"\"Determines if the required scope is present in the Access Token\n    Args:\n        required_scope (str): The scope required to access the resource\n    \"\"\"\n    token = get_token_auth_header()\n    unverified_claims = jwt.get_unverified_claims(token)\n    if unverified_claims.get(\"scope\"):\n            token_scopes = unverified_claims[\"scope\"].split()\n            for token_scope in token_scopes:\n                if token_scope == required_scope:\n                    return True\n    return False\n```\n\n## Protect API Endpoints\n\nThe routes shown below are available for the following requests:\n\n*   `GET /api/public`: available for non-authenticated requests\n*   `GET /api/private`: available for authenticated requests containing an access token with no additional scopes\n*   `GET /api/private-scoped`: available for authenticated requests containing an access token with the `read:messages` scope granted\n\nYou can use the decorators and functions define above in the corresponding endpoints.\n\n```\n# Controllers API\n\n# This doesn't need authentication\n@APP.route(\"/api/public\")\n@cross_origin(headers=[\"Content-Type\", \"Authorization\"])\ndef public():\n    response = \"Hello from a public endpoint! You don't need to be authenticated to see this.\"\n    return jsonify(message=response)\n\n# This needs authentication\n@APP.route(\"/api/private\")\n@cross_origin(headers=[\"Content-Type\", \"Authorization\"])\n@requires_auth\ndef private():\n    response = \"Hello from a private endpoint! You need to be authenticated to see this.\"\n    return jsonify(message=response)\n\n# This needs authorization\n@APP.route(\"/api/private-scoped\")\n@cross_origin(headers=[\"Content-Type\", \"Authorization\"])\n@requires_auth\ndef private_scoped():\n    if requires_scope(\"read:messages\"):\n        response = \"Hello from a private endpoint! You need to be authenticated and have a scope of read:messages to see this.\"\n        return jsonify(message=response)\n    raise AuthError({\n        \"code\": \"Unauthorized\",\n        \"description\": \"You don't have access to this resource\"\n    }, 403)\n```",
  "title": "Auth0 Python API SDK Quickstarts: Authorization",
  "description": "This tutorial demonstrates how to add authorization to a Python API built with Flask.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/java-spring-security5",
  "markdown": "# Auth0 Spring Boot API SDK Quickstarts: Authorization\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [Spring Boot API](https://auth0.com/docs/quickstart/backend/java-spring-security5)\n*   [Authorization](https://auth0.com/docs/quickstart/backend/java-spring-security5/01-authorization)\n\nThis tutorial demonstrates how to add authorization to an API using the Okta Spring Boot Starter. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Java 17\n\nThis example demonstrates:\n\n*   How to check for a JSON Web Token (JWT) in the `Authorization` header of an incoming HTTP request.\n    \n*   How to check if the token is valid, using the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) for your Auth0 account. To learn more about validating Access Tokens, see [Validate Access Tokens](https://auth0.com/docs/tokens/guides/validate-access-tokens).\n    \n\n## Configure Auth0 APIs\n\n### Create an API\n\nIn the [APIs](https://manage.auth0.com/#/apis) section of the Auth0 dashboard, click **Create API**. Provide a name and an identifier for your API, for example, `https://quickstarts/api`. You will use the identifier as an `audience` later, when you are configuring the Access Token verification. Leave the **Signing Algorithm** as **RS256**.\n\n![Create API](https://auth0.com/docs/media/articles/server-apis/create-api.png)\n\nBy default, your API uses RS256 as the algorithm for signing tokens. Since RS256 uses a private/public keypair, it verifies the tokens against the public key for your Auth0 account. The public key is in the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) format, and can be accessed [here](https://{yourdomain}/.well-known/jwks.json).\n\n### Define permissions\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\n## Configure the Sample Project\n\nThe sample project uses a `/src/main/resources/application.yml` file, which configures it to use the correct Auth0 **Domain** and **API Identifier** for your API. If you download the code from this page it will be automatically configured. If you clone the example from GitHub, you will need to fill it in yourself.\n\n```\nokta:\n  oauth2:\n    # Replace with the domain of your Auth0 tenant.\n    issuer: https://{yourDomain}/\n    # Replace with the API Identifier for your Auth0 API.\n    audience: {yourApiIdentifier}\n```\n\n| Attribute | Description |\n| --- | --- |\n| `okta.oauth2.audience` | The unique identifier for your API. If you are following the steps in this tutorial it would be `https://quickstarts/api`. |\n| `okta.oauth2.issuer` | The issuer URI of the resource server, which will be the value of the `iss` claim in the JWT issued by Auth0. Spring Security will use this property to discover the authorization server's public keys and validate the JWT signature. The value will be your Auth0 domain with an `https://` prefix and a `/` suffix (the trailing slash is important). |\n\n## Install dependencies\n\nIf you are using Gradle, you can add the required dependencies using the [Spring Boot Gradle Plugin](https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/html/) and the [Dependency Management Plugin](https://docs.spring.io/dependency-management-plugin/docs/current/reference/html/) to resolve dependency versions:\n\n```\n// build.gradle\n\nplugins {\n    id 'java'\n    id 'org.springframework.boot' version '3.1.5'\n    id 'io.spring.dependency-management' version '1.1.3'\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'com.okta.spring:okta-spring-boot-starter:3.0.5'\n}\n```\n\nIf you are using Maven, add the Spring dependencies to your `pom.xml` file:\n\n```\n// pom.xml\n\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>3.1.5</version>\n    <relativePath/>\n</parent>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.okta</groupId>\n        <artifactId>okta-spring-boot-starter</artifactId>\n        <version>3.0.5</version>\n    </dependency>\n</dependencies>\n```\n\n## Protect API endpoints\n\nThe routes shown below are available for the following requests:\n\n*   `GET /api/public`: available for non-authenticated requests\n*   `GET /api/private`: available for authenticated requests containing an access token with no additional scopes\n*   `GET /api/private-scoped`: available for authenticated requests containing an access token with the `read:messages` scope granted\n\nTo configure the application as a Resource Server and validate the JWTs, create a class that will register a [SecurityFilterChain](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/SecurityFilterChain.html), an instance of `SecurityFilterChain`, and add the `@Configuration` annotation.\n\nThe example below shows how to secure API methods using the `HttpSecurity` object provided in the `filterChain()` method of the `SecurityConfig` class. Route matchers are used to restrict access based on the level of authorization required:\n\n```\n// src/main/java/com/auth0/example/security/SecurityConfig.java\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.web.SecurityFilterChain;\n\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n                .mvcMatchers(\"/api/public\").permitAll()\n                .mvcMatchers(\"/api/private\").authenticated()\n                .mvcMatchers(\"/api/private-scoped\").hasAuthority(\"SCOPE_read:messages\")\n                .and().cors()\n                .and().oauth2ResourceServer().jwt();\n        return http.build();\n    }\n}\n```\n\n### Create the API controller\n\nCreate a new record named `Message`, which will be the domain object the API will return:\n\n```\n// src/main/java/com/auth0/example/model/Message.java\n\npublic record Message(String message) {}\n```\n\nCreate a new class named `APIController` to handle requests to the endpoints:\n\n```\n// src/main/java/com/auth0/example/web/APIController.java\n\nimport com.auth0.example.model.Message;\nimport org.springframework.http.MediaType;\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * Handles requests to \"/api\" endpoints.\n * @see com.auth0.example.security.SecurityConfig to see how these endpoints are protected.\n */\n@RestController\n@RequestMapping(path = \"api\", produces = MediaType.APPLICATION_JSON_VALUE)\n// For simplicity of this sample, allow all origins. Real applications should configure CORS for their use case.\n@CrossOrigin(origins = \"*\")\npublic class APIController {\n\n    @GetMapping(value = \"/public\")\n    public Message publicEndpoint() {\n        return new Message(\"All good. You DO NOT need to be authenticated to call /api/public.\");\n    }\n\n    @GetMapping(value = \"/private\")\n    public Message privateEndpoint() {\n        return new Message(\"All good. You can see this because you are Authenticated.\");\n    }\n\n    @GetMapping(value = \"/private-scoped\")\n    public Message privateScopedEndpoint() {\n        return new Message(\"All good. You can see this because you are Authenticated with a Token granted the 'read:messages' scope\");\n    }\n}\n```\n\n## Run the Application\n\nTo build and run the sample project, execute the `bootRun` Gradle task.\n\nLinux or macOS:\n\nWindows:\n\nIf you are configuring your own application using Maven and the [Spring Boot Maven Plugin](https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html), you can execute the `spring-boot:run` goal.\n\nLinux or macOS:\n\nWindows:\n\nThe sample application will be available at `http://localhost:3010/`. Read about how to test and use your API in the [Using Your API](https://auth0.com/docs/quickstart/backend/java-spring-security5/02-using) article.",
  "title": "Auth0 Spring Boot API SDK Quickstarts: Authorization",
  "description": "This tutorial demonstrates how to add authorization to an API using the Okta Spring Boot Starter.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/android",
  "markdown": "# Auth0 Android SDK Quickstarts: Login\n\nThis quickstart demonstrates how to add user login to an Android application using Auth0. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nSystem requirements: Android Studio 4.1.0 | Android SDK 30 | Emulator - Android 11.0\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\nReplace `YOUR_APP_PACKAGE_NAME` with your application's package name, available as the `applicationId` attribute in the `app/build.gradle` file.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\nReplace `YOUR_APP_PACKAGE_NAME` with your application's package name, available as the `applicationId` attribute in the `app/build.gradle` file.\n\n## Install the Auth0 Android SDK\n\nAdd the [Auth0 Android](https://github.com/auth0/Auth0.Android) SDK into your project. The library will make requests to the Auth0's Authentication and Management APIs.\n\n### Add Auth0 to Gradle\n\nIn your app's `build.gradle` dependencies section, add the following:\n\n```\ndependencies {\n  // Add the Auth0 Android SDK\n  implementation 'com.auth0.android:auth0:2.+'\n}\n```\n\nIn the android section, target Java 8 byte code for Android and Kotlin plugins respectively.\n\n```\nandroid {\n  compileOptions {\n    sourceCompatibility JavaVersion.VERSION_1_8\n    targetCompatibility JavaVersion.VERSION_1_8\n  }\n  kotlinOptions {\n    jvmTarget = '1.8'\n  }\n}\n```\n\n### Sync Project with Gradle Files\n\nRemember to synchronize using the Android Studio prompt or run `./gradlew clean build` from the command line. For more information about Gradle usage, check [their official documentation](http://tools.android.com/tech-docs/new-build-system/user-guide).\n\nAdd manifest placeholders required by the SDK. The placeholders are used internally to define an `intent-filter` that captures the authentication callback URL. For this, the Auth0 tenant domain and the scheme that take part in the callback URL must be set.\n\nTo add the manifest placeholders, add the next line:\n\n```\n// app/build.gradle\n\napply plugin: 'com.android.application'\ncompileSdkVersion 30\nandroid {\n    defaultConfig {\n        applicationId \"com.auth0.samples\"\n        minSdkVersion 21\n        targetSdkVersion 30\n        // ...\n\n        // ---> Add the next line\n        manifestPlaceholders = [auth0Domain: \"@string/com_auth0_domain\", auth0Scheme: \"demo\"]\n        // <---\n    }\n}\n```\n\nFinally, ensure that the `android.permissions.INTERNET` permission is specified in the `AndroidManifest.xml` file:\n\n```\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\nRun **Sync Project with Gradle Files** inside Android Studio or execute `./gradlew clean assembleDebug` from the command line.\n\n## Add Login to your App\n\n[Universal Login](https://auth0.com/docs/hosted-pages/login) is the easiest way to set up authentication in your application. We recommend using it for the best experience, best security and the fullest array of features.\n\nIn the `onCreate` method, create a new instance of the `Auth0` class to hold user credentials:\n\n```\n// Import the parts needed by the SDK\nimport com.auth0.android.Auth0\nimport com.auth0.android.provider.WebAuthProvider\n\nclass MainActivity : AppCompatActivity() {\n\n  private lateinit var account: Auth0\n\n  override fun onCreate(savedInstanceState: Bundle?) {\n      super.onCreate(savedInstanceState)\n\n      // Set up the account object with the Auth0 application details\n      account = Auth0(\n          \"{yourClientId}\",\n          \"{yourDomain}\"\n      )\n  }\n}\n```\n\nFinally, create a `loginWithBrowser` method and use the `WebAuthProvider` class to authenticate with any connection you enabled on your application in the [Auth0 dashboard](https://manage.auth0.com/#/). Here, you can pass the scheme value that was used in the `auth0Scheme` manifest placeholder as part of the initial configuration:\n\n```\nprivate fun loginWithBrowser() {\n    // Setup the WebAuthProvider, using the custom scheme and scope.\n\n    WebAuthProvider.login(account)\n        .withScheme(\"demo\")\n        .withScope(\"openid profile email\")\n        // Launch the authentication passing the callback where the results will be received\n        .start(this, object : Callback<Credentials, AuthenticationException> {\n            // Called when there is an authentication failure\n            override fun onFailure(exception: AuthenticationException) {\n                // Something went wrong!\n            }\n\n            // Called when authentication completed successfully\n            override fun onSuccess(credentials: Credentials) {\n              // Get the access token from the credentials object.\n              // This can be used to call APIs\n              val accessToken = credentials.accessToken\n            }\n        })\n}\n```\n\nAfter you call the `WebAuthProvider#start` function, the browser launches and shows the login page. Once the user authenticates, the callback URL is called. The callback URL contains the final result of the authentication process.\n\n### Checkpoint\n\nAdd a button to your application that calls `loginWithBrowser`. When you click it, verify that your Android application redirects you to the [Auth0 Universal Login](https://auth0.com/universal-login) page and that you can now log in or sign up using a username and password or a social provider.\n\nOnce that's complete, verify that Auth0 redirects back to your app.\n\n## Add Logout to your App\n\nUse `WebAuthProvider` to remove the cookie set by the Browser at authentication time, so that the users are forced to re-enter their credentials the next time they try to authenticate.\n\nAdd a `logout` method to your app to remove the user's session and log them out of the app. Here, you can pass the scheme value that was used in the `auth0Scheme` manifest placeholder as part of the initial configuration:\n\n```\nprivate fun logout() {\n  WebAuthProvider.logout(account)\n    .withScheme(\"demo\")\n    .start(this, object: Callback<Void?, AuthenticationException> {\n      override fun onSuccess(payload: Void?) {\n        // The user has been logged out!\n      }\n\n      override fun onFailure(error: AuthenticationException) {\n        // Something went wrong!\n      }\n    })\n}\n```\n\nThe logout is achieved by using the `WebAuthProvider` class. This call will open the Browser and navigate the user to the logout endpoint. If the log out is cancelled, you might want to take the user back to where they were before attempting to log out.\n\n### Checkpoint\n\nAdd a button to your app that calls `logout` and logs the user out of your application. When you click it, verify that your Android app redirects you logout page and back again, and that you are no longer logged in to your application.\n\n## Show User Profile Information\n\nUse the `AuthenticationAPIClient` class to [retrieve the user's profile from Auth0](https://auth0.com/docs/users/user-profiles#user-profile-management-api-access). This requires:\n\n*   The access token as received during the login phase\n*   The `profile` scope to be included when `WebAuthProvider.login` is called\n\nThe `email` scope must also be specified if the user's email address is to be retrieved.\n\nThe following demonstrates a function that can be used to retrieve the user's profile and show it on the screen:\n\n```\nprivate fun showUserProfile(accessToken: String) {\n  var client = AuthenticationAPIClient(account)\n\n  // With the access token, call `userInfo` and get the profile from Auth0.\n  client.userInfo(accessToken)\n    .start(object : Callback<UserProfile, AuthenticationException> {\n        override fun onFailure(exception: AuthenticationException) {\n            // Something went wrong!\n        }\n\n        override fun onSuccess(profile: UserProfile) {\n          // We have the user's profile!\n          val email = profile.email\n          val name = profile.name\n        }\n  })\n}\n```\n\n### Checkpoint\n\nCall the `showUserProfile` function after login and verify that the user's profile information has been returned in the `onSuccess` callback.",
  "title": "Auth0 Android SDK Quickstarts: Login",
  "description": "This quickstart demonstrates how to add user login to an Android application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-teams",
  "markdown": "# Auth0 Teams\n\nAuth0 Teams provides a single point of visibility and control over your Auth0 resources by providing centralized governance, compliance, and secure collaboration at scale. Teams membership sits on top of the tenant membership account.\n\nThe main team member role is referred to as the Team Owner and has visibility into all tenants within their Auth0 Account. As an Auth0 Team Owner, you can manage a single tenant or multiple tenants.\n\nThe following features are currently available as part of Auth0 Teams:\n\n*   Visibility and control of Teams members\n    \n*   Visibility into Tenants with relevant details\n    \n*   Visibility and control of Tenant members\n    \n*   Ability to enforce Single Sign-On with your own Identity provider\n    \n*   Ability to restrict tenant creation\n    \n*   Ability to manage subscription and billing details for self-service subscriptions\n    \n\n![Auth0 teams let you manage all tenants and administrators](https://images.ctfassets.net/cdy7uua7fh8z/3flASwD5wAA0xkH9ToFDX5/b305e5a7a8955f34ddf8a4844314286b/2022-08-05_10-17-50.png)\n\nAuth0 Teams currently supports a single Teams instance for all tenants attached to either your subscription or Enterprise contract.\n\nTeam Owners manage and configure the tenants and tenant administrators within the Teams instance.\n\n## Getting Started\n\nAuth0 Teams is on by default for new self-service users since 1 November 2023.\n\nExisting Public and Private Cloud Enterprise customers can request to be onboarded into Teams through their Technical Account Manager, Sales Executive or via support.\n\nFor all other subscription types, if you joined Auth0 prior to 1 November 2023, you need to upgrade your plan to the latest version in your tenant's [subscription settings](https://manage.auth0.com/#/tenant/billing/subscription) to have Teams automatically provisioned for you.\n\n## Feature Support Matrix\n\n| Teams Feature | Enterprise Private Cloud | Enterprise Public Cloud | Self-Service Subscription |\n| --- | --- | --- | --- |\n| Tenant Management | ✅   | ✅   | ✅   |\n| Tenant Member Management | ❌   | ✅   | ✅   |\n| SSO Enforcement | ❌   | ✅   | ❌   |\n| Tenant Creation from Teams | ✅   | ❌   | ✅   |",
  "title": "Auth0 Teams",
  "description": "Describes how Auth0 Teams allows you to manage tenants and tenant administrators.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview",
  "markdown": "# Auth0 Overview\n\nAuth0 is a flexible, drop-in solution to add authentication and authorization services to your applications. Your team and organization can avoid the cost, time, and risk that come with building your own solution to authenticate and authorize users.\n\nTake a look at just a few of Auth0's use cases:\n\n*   You built an awesome app and you want to add user authentication and authorization. Your users should be able to log in either with a username/password or with their social accounts (such as Facebook or Twitter). You want to retrieve the user's profile after the login so you can customize the UI and apply your authorization policies.\n    \n*   You built an API and you want to secure it with [OAuth 2.0](https://auth0.com/docs/authenticate/protocols/oauth).\n    \n*   You have more than one app, and you want to implement [Single Sign-on (SSO)](https://auth0.com/docs/authenticate/single-sign-on).\n    \n*   You built a JavaScript front-end app and a mobile app, and you want them both to securely access your API.\n    \n*   You have a web app that needs to authenticate users using [Security Assertion Markup Language (SAML)](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration).\n    \n*   You believe passwords are broken and you want your users to log in with one-time codes delivered by email or SMS.\n    \n*   If one of your user's email addresses is compromised in some site's public data breach, you want to be notified, and you want to notify the users and/or block them from logging in to your app until they reset their password.\n    \n*   You want to act proactively to block suspicious IP addresses if they make consecutive failed login attempts, in order to avoid DDoS attacks.\n    \n*   You are part of a large organization that wants to federate your existing enterprise directory service to allow employees to log in to the various internal and third-party applications using their existing enterprise credentials.\n    \n*   You don't want (or you don't know how) to implement your own user management solution. Password resets, creating, provisioning, blocking, and deleting users, and the UI to manage all these. You just want to focus on your app.\n    \n*   You want to enforce [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) when your users want to access sensitive data.\n    \n*   You are looking for an identity solution that will help you stay on top of the constantly growing compliance requirements of SOC2, GDPR, PCI DSS, HIPAA, and others.\n    \n*   You want to monitor users on your site or application. You plan on using this data to create funnels, measure user retention, and improve your sign-up flow.\n    \n*   You want robust authorization policy to allow your users access to resources based on [their relationship](https://docs.fga.dev/authorization-concepts) to the resource or [their role](https://auth0.com/docs/manage-users/access-control/rbac) in your organization.\n    \n\n| **Read...** | **To learn...** |\n| --- | --- |\n| [Auth0 Dashboard](https://auth0.com/docs/get-started/auth0-overview/dashboard) | About the Auth0 Dashboard and features you can access to implement authentication and authorization with your applications and APIs. |\n| [Create Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants) | How to create tenants using the Auth0 Dashboard or the Management API, explore creating multiple tenants and child tenants, and learn about setting up multiple environments. |\n| [Create Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications) | How to set up and configure applications in the Auth0 Dashboard. |\n| [Register APIs](https://auth0.com/docs/get-started/auth0-overview/set-up-apis) | How to set up and configure APIs in the Auth0 Dashboard. |\n\n## Learn more\n\n*   [Create Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants)\n*   [Auth0 Dashboard](https://auth0.com/docs/get-started/auth0-overview/dashboard)\n*   [Architecture Scenarios](https://auth0.com/docs/get-started/architecture-scenarios)\n*   [Protocols](https://auth0.com/docs/authenticate/protocols)",
  "title": "Auth0 Overview",
  "description": "Describes Auth0 services and helps you get started using them with your applications and APIs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/identity-fundamentals",
  "markdown": "# Identity Fundamentals\n\nExplore topics related to the fundamentals of identity and access management.",
  "title": "Identity Fundamentals",
  "description": "Learn the basics of identity and access management.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/react-native-expo",
  "markdown": "# Auth0 Expo SDK Quickstarts: Login\n\nThis tutorial demonstrates how to add user login to an Expo application using Auth0. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nThis Quickstart is for the Expo framework. To integrate Auth0 into your React Native application, please refer to the [React Native Quickstart](https://auth0.com/docs/quickstart/native/react-native/interactive)\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n## Install Dependencies\n\nHow to install the React Native Auth0 module.\n\n### Yarn\n\n```\nyarn add react-native-auth0\n```\n\n### npm\n\n```\nnpm install react-native-auth0 --save\n```\n\nThe first step in adding authentication to your application is to provide a way for your users to log in. The fastest, most secure, and most feature-rich way to do this with Auth0 is to use the hosted [login page](https://auth0.com/docs/hosted-pages/login).\n\n![Universal Login](https://auth0.com/docs/media/articles/native-platforms/ios-swift/login-ios.png)\n\n## Integrate Auth0 in Your Application\n\n### Setup Auth0 Config Plugin\n\nThe Auth0 package runs custom native code that needs to be configured at build time. We will use [Expo Config Plugin](https://docs.expo.dev/guides/config-plugins/) to achieve this.\n\nAdd the `react-native-auth0` plugin to the [Expo config](https://docs.expo.dev/workflow/configuration/) file at `app.json` or `app.config.js`.\n\n```\n{\n  \"expo\": {\n    ...\n    \"plugins\": [\n      [\n        \"react-native-auth0\",\n        {\n          \"domain\": \"{yourDomain}\"\n        }\n      ]\n    ]\n  }\n}\n```\n\n### Generate native source code\n\nYou must generate the native code for the above configuration to be set. To do this, run the following command:\n\nYou will be prompted to provide the [Android package](https://github.com/expo/fyi/blob/main/android-package.md) and [iOS bundle identifier](https://github.com/expo/fyi/blob/main/bundle-identifier.md) if they are not already present in the Expo config:\n\n```\n? What would you like your Android package name to be? > com.auth0samples # or your desired package name\n\n? What would you like your iOS bundle identifier to be? > com.auth0samples # or your desired bundle identifier\n```\n\nThese values are found in the Expo config file at `app.json` or `app.config.js`. It will be used in the callback and logout URLs:\n\n```\n{\n    ...\n    \"android\": {\n      \"package\": \"YOUR_ANDROID_PACKAGE_NAME_IS_FOUND_HERE\"\n    },\n    \"ios\": {\n      \"bundleIdentifier\": \"YOUR_IOS_BUNDLE_IDENTIFIER_IS_FOUND_HERE\"\n    }\n  }\n}\n```\n\n### Configure Callback and Logout URLs\n\nThe callback and logout URLs are the URLs that Auth0 invokes to redirect back to your application. Auth0 invokes the callback URL after authenticating the user, and the logout URL after removing the session cookie.\n\nIf the callback and logout URLs are not set, users will be unable to log in and out of the application and will get an error.\n\nGo to the settings page of your [Auth0 application](https://manage.auth0.com/#/applications/{yourClientId}/settings) and add the corresponding URL to **Allowed Callback URLs** and **Allowed Logout URLs**, according to the platform of your application. If you are using a [custom domain](https://auth0.com/docs/customize/custom-domains), use the value of your custom domain instead of the Auth0 domain from the settings page.\n\n#### iOS\n\n```\nBUNDLE_IDENTIFIER.auth0://{yourDomain}/ios/BUNDLE_IDENTIFIER/callback\n```\n\n#### Android\n\n```\nPACKAGE_NAME.auth0://{yourDomain}/android/PACKAGE_NAME/callback\n```\n\n## Add login to your app\n\nFirst, import the `useAuth0` hook and the `Auth0Provider` component from the `react-native-auth0` package.\n\n```\nimport {useAuth0, Auth0Provider} from 'react-native-auth0';\n```\n\nNext, wrap your application in the `Auth0Provider` component, providing your Auth0 domain and Client ID values:\n\n```\nconst App = () => {\n  return (\n    <Auth0Provider domain={\"{yourDomain}\"} clientId={\"{yourClientId}\"}>\n      {/* your application */}\n    </Auth0Provider>\n  );\n};\n```\n\nFinally, present the hosted login screen using the `authorize` method from the `useAuth0` hook. See this usage example showing logging in on a button click:\n\n```\nconst LoginButton = () => {\n    const {authorize} = useAuth0();\n\n    const onPress = async () => {\n        try {\n            await authorize();\n        } catch (e) {\n            console.log(e);\n        }\n    };\n\n    return <Button onPress={onPress} title=\"Log in\" />\n}\n```\n\n### Checkpoint\n\nAdd a button component that calls `authorize` when clicked. Verify that you are redirected to the login page and then back to your application.\n\n## Add logout to your app\n\nTo log the user out, redirect them to the Auth0 log out endpoint by importing and calling the `clearSession` method from the `useAuth0` hook. This will remove their session from the authorization server.\n\nSee this usage example of a button that logs the user out of the app when clicked:\n\n```\nconst LogoutButton = () => {\n    const {clearSession} = useAuth0();\n\n    const onPress = async () => {\n        try {\n            await clearSession();\n        } catch (e) {\n            console.log(e);\n        }\n    };\n\n    return <Button onPress={onPress} title=\"Log out\" />\n}\n```\n\n### Checkpoint\n\nAdd a button that calls `clearSession` when clicked. Verify that you are logged out of the application when clicked.\n\n## Show user profile information\n\nThe `useAuth0` hook exposes a `user` object that contains information about the authenticated user. You can use this to access user profile information about the authenticated user that has been decoded from the [ID token](https://auth0.com/docs/secure/tokens/id-tokens).\n\nIf a user has not been authenticated, this property will be `null`.\n\n```\nconst Profile = () => {\n    const {user, error} = useAuth0();\n\n    return (\n        <>\n            {user && <Text>Logged in as {user.name}</Text>}\n            {!user && <Text>Not logged in</Text>}\n            {error && <Text>{error.message}</Text>}\n        </>\n    )\n}\n```\n\n### Checkpoint\n\nAdd a component to your app that uses the `user` prop to display information about the user on the screen.",
  "title": "Auth0 Expo SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to an Expo application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications",
  "markdown": "# Applications in Auth0\n\nThe term **application** or **app** in Auth0 does not imply any particular implementation characteristics. For example, it could be a native app that executes on a mobile device, a single-page application that executes on a browser, or a regular web application that executes on a server.\n\nAuth0 categorizes apps based on these characteristics:\n\n*   **Application type**: To add authentication to your application, you must register it in the Auth0 Dashboard and select from one of the following application types:\n    \n    *   **Regular web application**: Traditional web apps that perform most of their application logic on the server (such as Express.js or ASP.NET). To learn how to set up a regular web application, read [Register Regular Web Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps).\n        \n    *   **Single page web application (SPA)**: JavaScript apps that perform most of their user interface logic in a web browser, communicating with a web server primarily using APIs (such as AngularJS + Node.js or React). To learn how to set up a Single-page web application, read [Register Single-Page Web Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/single-page-web-apps).\n        \n    *   **Native application**: Mobile or Desktop applications that run natively on a device (such as iOS or Android). To learn how to set up a native application, read [Register Native Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/native-apps).\n        \n    *   **Machine to machine (M2M) application**: Non-interactive applications, such as command-line tools, daemons, IoT devices, or services running on your backend. Typically, you use this option if you have a service that requires access to an API. To learn how to set up a native application, read [Register Machine-to-Machine Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps).\n        \n*   **Credential security**: According to the [OAuth 2.0 spec](https://tools.ietf.org/html/rfc6749#section-2.1), apps can be classified as either public or confidential; confidential apps can hold credentials securely, while public apps cannot. To learn more, read [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n    \n*   **Ownership**: Whether an app is classified as first- or third-party depends on app ownership and control. First-party apps are controlled by the same organization or person that owns the Auth0 domain. Third-party apps enable external parties or partners to securely access protected resources behind your API. To learn more, read [First-Party and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications).\n    \n\n## Manage applications settings\n\nYou register applications in [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications/{yourClientId}/settings). In addition to setting up applications in the Dashboard, you can also set up applications programmatically as described in the [OpenID Connect (OIDC) Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) specification.\n\nYou can set up a more complex configuration that allows users to log in differently for different apps. To learn more, read [Multi-Tenant Application Best Practices](https://auth0.com/docs/get-started/auth0-overview/create-tenants/multi-tenant-apps-best-practices) and [Create Multiple Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants/create-multiple-tenants).\n\nBy default, Auth0 enables all connections associated with your tenant when you create a new application. To change this, [update application connections](https://auth0.com/docs/get-started/applications/update-application-connections) in the **Application Settings** in the Dashboard.\n\n## Monitor applications\n\nYou can [monitor apps](https://auth0.com/docs/deploy-monitor/monitor/monitor-applications) and perform end-to-end testing using your own tests. Auth0 stores [log data](https://auth0.com/docs/deploy-monitor/logs) including Dashboard administrator actions, successful and failed user authentications, and password change requests. You can use log streaming in [Auth0 Marketplace](https://marketplace.auth0.com/features/log-streaming) to export your log data and use tools like Sumo Logic, Splunk, or Mixpanel to analyze and store your log data.\n\n## Remove applications\n\nYou can [remove an application](https://auth0.com/docs/get-started/applications/remove-applications) using the Dashboard or the Management API.\n\n## Manage client secrets\n\nA client secret is a secret known only to your application and the authorization server. It protects your resources by only granting [tokens](https://auth0.com/docs/secure/tokens) to authorized requestors.\n\nProtect your client secrets and **never** include them in mobile or browser-based apps. If your client secret is ever compromised, you should [rotate to a new one](https://auth0.com/docs/get-started/applications/rotate-client-secret) and update all authorized apps with the new client secret.\n\n## Grant types\n\nAuth0 provides many different authentication and authorization grant types or flows and allows you to indicate which grant types are appropriate based on the `grant_types` property of your Auth0-registered app. To learn more, read [Application Grant Types](https://auth0.com/docs/get-started/applications/application-grant-types).\n\n## Learn more\n\n*   [Application Settings](https://auth0.com/docs/get-started/applications/application-settings)\n*   [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications)\n*   [First-Party and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications)\n*   [Application Grant Types](https://auth0.com/docs/get-started/applications/application-grant-types)\n*   [Subdomain URL Placeholders](https://auth0.com/docs/get-started/applications/wildcards-for-subdomains)\n*   [Dynamic Application Registration](https://auth0.com/docs/get-started/applications/dynamic-client-registration)",
  "title": "Applications in Auth0",
  "description": "Learn the basics of registering and configuring your applications in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/tenant-settings",
  "markdown": "# Tenant Settings\n\nUse the **Tenant Settings** page in the Auth0 Dashboard at [Dashboard > Settings](https://manage.auth0.com/#/tenant) to configure various settings related to your Auth0 tenant.\n\n## Recommended settings\n\nWhen you configure your tenant, set the following items:\n\n*   **Specify the Environment Tag.** Tenants tagged as **Production** are granted higher rate limits than tenants tagged as **Development** or **Staging**. On non-Enterprise plans, only one tenant per subscription can be tagged as **Production**. To learn more, read [Set Up Multiple Environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments).\n    \n*   **Set the Support Email and Support URL.** If a user encounters an issue while logging in, they'll want to reach out for help. Set these values to direct them to an email address or landing page to get assistance.\n    \n*   **Configure a custom error page.** If possible, you should host your own custom error page and configure Auth0 to use it instead of the default page. This allows you to provide more complete and customized explanations to users about what to do in the event of an error.\n    \n*   **Set up a custom domain.** If you are on a paid plan, you can configure a custom domain for your Auth0 tenant. A custom domain unifies the login experience with your brand and provides additional benefits. To learn more, read [Custom Domains](https://auth0.com/docs/customize/custom-domains).\n    \n*   **Set the Single Sign-On (SSO) session timeout.** The SSO session timeout value specifies the time until a user's session expires. The value is 7 days by default, which is the length of time users can access your Auth0-integrated applications without re-entering their credentials. To learn more, read [Sessions](https://auth0.com/docs/manage-users/sessions).\n    \n*   **Set up tenant members.** Configure additional Auth0 Dashboard users and enable multi-factor authentication (MFA). To learn more, read [Manage Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access) and [Manage Dashboard Access with Multi-Factor Authentication](https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa).\n    \n*   **Disable the Enable Application Connections setting.** If this setting is enabled, all configured connections will be automatically enabled for any new application you create. As a result, users may be able to log in to the application through connections that you did not intend to be available. Disable this setting so you can explicitly enable the connections appropriate for each application.\n    \n*   **Enable Attack Protection.** Protect your users against brute force attacks and breached passwords. To learn more, read [Attack Protection](https://auth0.com/docs/secure/attack-protection).\n    \n\n## General\n\nOn the **General** tab, you can customize basic tenant settings.\n\n### Settings\n\n![Dashboard Tenant Settings General Settings tab](https://images.ctfassets.net/cdy7uua7fh8z/4okToiwlkNQBxwr8QGE3Rs/3f39b3a057b55d06bff3511f255849ce/dashboard-tenant-settings-general-settings.png)\n\n*   **Friendly Name**: Name you want to be displayed to your users on the Universal Login page. Typically this is the name of your company or organization.\n    \n*   **Logo URL**: URL of the logo you want to be displayed on the Universal Login page. Minimum recommended resolution is 200 pixels (width) by 200 pixels (height).\n    \n*   **Support Email**: Email address used to contact your support team.\n    \n*   **Support URL**: Link to your company or organization support page.\n    \n\n### Environment Tag\n\nYou can identify your tenant as a production, staging, or development tenant to differentiate it from other tenants. Higher rate limits apply to tenants tagged as Production with a paid subscription. To learn more, read [Set Up Multiple Environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments).\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/27OH1jFXce97CSjk7TPeD7/1d858adea38c0b2bc9ff359240edcadf/Dashboard-Tenant_Settings-General-Environmental_Tag0.png)\n\n![Dashboard Tenant Settings General Tab API Authorization Settings](https://images.ctfassets.net/cdy7uua7fh8z/17yNCRrB6dWcHp6zLFb74j/b3cc967c40378a89eaf0159e63991f01/dashboard-tenant-settings-general-api-auth.png)\n\n*   **Default Audience**: API identifier to use for [Authorization Flows](https://auth0.com/docs/get-started/authentication-and-authorization-flow). If you enter a value, all access tokens issued by Auth0 will specify this API identifier as an audience. Setting the **Default Audience** is equivalent to appending this audience to every authorization request made to your tenant for every application. This will cause new behavior that might result in breaking changes for some of your applications. Please [contact support](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets) if you require assistance.\n    \n*   **Default Directory**: Name of the default connection to be used for both the [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow) and [Universal Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/new-experience). Its value should be the exact name of an existing connection for one of the following strategies: `auth0-adldap`, `ad`, `auth0`, `email`, `sms`, `waad`, or `adfs`.\n    \n\n### Error Pages\n\nIn the event of an authorization error, you can either display a generic error page to your users or you can redirect users to your own custom error page. To learn more, read [Custom Error Pages](https://auth0.com/docs/customize/login-pages/custom-error-pages).\n\n![Dashboard Tenant Settings General Error Pages](https://images.ctfassets.net/cdy7uua7fh8z/kteu7boTA7G67HZXHFYOF/9330dc48be531e205da1f5aa117092ff/dashboard-tenant-settings-general-error-pages.png)\n\n### Languages\n\n![Dashboard Tenant Settings General Tab Languages](https://images.ctfassets.net/cdy7uua7fh8z/2G20DUg0pvS4HEChCe3oM8/778234cb3ba4ee5efe7a28465b6b2d9e/dashboard-tenant-settings-general-languages.png)\n\n*   **Default Language**: Language your tenant will use by default.\n    \n*   **Supported Languages**: Languages also supported by your tenant.\n    \n\n## Subscription\n\nOn the **Subscription** tab, you can review your current subscription and compare features of your current plan to other Auth0 subscription plans. You can also change your subscription plan. To learn more, read [Manage Subscription](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions).\n\nIf you have an Enterprise subscription, please refer to your Auth0 agreement for details.\n\n![Auth0 Tenant Settings Subscription tab](https://images.ctfassets.net/cdy7uua7fh8z/3yISRVTJOwP4Yo2uG0iZdO/540ac52cb14f13899e2c55f549f9c11e/Screenshot_2023-12-05_at_3.50.08_PM.png)\n\n## Payment\n\nOn the **Payment** tab, you can enter or update your billing details.\n\n## Tenant Members\n\nOn the **Tenant Members** tab, you can view a list tenant members assigned to your tenant. You may also add or remove tenant members and review their assigned roles and if they have multi-factor authentication (MFA) enabled. To learn more, read [Manage Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access).\n\n![Dashboard Tenant Settings Tenant Members tab](https://images.ctfassets.net/cdy7uua7fh8z/3206A7slUJ1cwOjHM3o3Om/e7feb8cc728b5af9f98a2333742a20d1/dashboard-tenant-settings-tenant-members.png)\n\n## Custom Domains\n\nOn the **Custom Domains** tab, you can configure a custom domain to maintain a consistent user experience. When you create a custom domain, users will remain in your domain for login rather than being redirected to your `auth0.com` domain. To learn more, read [Custom Domains](https://auth0.com/docs/customize/custom-domains).\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n![Dashboard Tenant Settings Custom Domains tab](https://images.ctfassets.net/cdy7uua7fh8z/5RFqn9GqGZ0e9RCbHzvVIk/665b0706c4c8e90dc7a8c397c5f32b15/dashboard-tenant-settings-custom-domains.png)\n\n## Signing Keys\n\nOn the **Signing Keys** tab, you can securely manage the signing key and certificate used to sign ID tokens, access tokens, SAML assertions, and WS-Fed assertions that are sent to your applications.\n\n![Dashboard Tenant Settings Signing Keys tab](https://images.ctfassets.net/cdy7uua7fh8z/7r8t3EGctFmvkCgPrU0i2R/f79ac74dac5cded37b39bd8a8b80951d/dashboard-tenant-settings-signing-keys.png)\n\n*   **Rotation Settings**: Settings that allow you to rotate the application signing key and certificate. You can choose whether or not to revoke the signing key upon rotation. To learn more, read [Signing Keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys).\n    \n    *   **Rotate Signing Key**: Rotates the signing key without revoking it; effectively, moves the current key to the previous key. All tokens signed with the previous key will still be valid until it is revoked.\n        \n    *   **Rotate & Revoke Signing Key**: Rotates the signing key and then revokes it; effectively, moves the current key to the previous key, and then invalidates the previous key. Make sure you have updated your application with the next key in the queue before you rotate and revoke the current key.\n        \n*   **List of Valid Keys**: List of valid application signing keys for your tenant, which are also available at the Metadata endpoint for your application. Valid keys include:\n    \n    *   **Next in queue**: Key that will be used when the signing key is next rotated.\n        \n    *   **Currently used**: Key that is currently in use.\n        \n    *   **Previously used**: Key that was previously used. Its appearance indicates that the signing key has been rotated, but the previously-used key has not yet been revoked.\n        \n*   **List of Revoked Keys**: List of the last three revoked keys for your tenant. More data about revoked keys is available in tenant logs.\n    \n\n## Advanced\n\nOn the **Advanced** tab, you can configure advanced tenant settings.\n\n### Login and Logout\n\n![Dashboard Tenant Settings Advanced Tab Login and Logout](https://images.ctfassets.net/cdy7uua7fh8z/6hp2kPZBWMNB3al6p7gKWa/523df538f28d9e3bb9be9f882e2cfcd2/dashboard-tenant-settings-advanced-login-logout.png)\n\n*   **Allowed Logout URLs**: URLs that Auth0 can redirect to after logout when no `client_id` is specified on the Logout endpoint invocation. Useful as a global list when Single Sign-on (SSO) is enabled. To learn more, see [Logout](https://auth0.com/docs/authenticate/login/logout).\n    \n*   **Tenant Login URI**: URI that points to a route in your application that starts the OIDC login flow by redirecting to the `/authorize` endpoint; it should take the form of `https://mytenant.org/login`. This will only be used in scenarios where Auth0 needs your tenant to start the OIDC login flow. To learn more, see [Configure Default Login Routes](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes).\n    \n\n### Login Session Management\n\nThe **Login Session Management** settings configure the login session lifetime that represents the Auth0 Authorization Server session layer. The authorization server session layer drives single sign-on (SSO). To learn more, read [Single Sign-on](https://auth0.com/docs/authenticate/single-sign-on).\n\nTimeouts for tokens issued by Auth0 can be configured elsewhere. Token timeouts are often used to drive the Application session layer and appear in token claims, such as in the expiration claim for OpenID Connect (OIDC) ID tokens or the lifetime assertion for SAML.\n\n![Dashboard Tenant Settings Advanced Login Session Management](https://images.ctfassets.net/cdy7uua7fh8z/q2fGPzoUqCcXj7OxcHhjy/c01957938aa84be2a450db6590b4e9bd/dashboard-tenant-settings-advanced-login-session.png)\n\n*   **Inactivity timeout**: Timeframe (in minutes) after which a user's session will expire if they haven’t interacted with the Authorization Server. It will be superseded by system limits if over 4,320 minutes (3 days) for non-Enterprise plans or 144,000 minutes (100 days) for Enterprise plans.\n    \n*   **Require log in after**: Timeframe (in minutes) after which a user will be required to log in again, regardless of their activity. It will be superseded by system limits if over 43,200 minutes (30 days) for non-Enterprise plans or 525,600 minutes (365 days) for Enterprise plans.\n    \n\n### Device Flow User Code Format\n\nIf you are using the [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow), these settings configure the randomly generated user code. To learn more, read [Configure Device User Code Settings](https://auth0.com/docs/get-started/tenant-settings/configure-device-user-code-settings).\n\n![Dashboard Tenant Settings Advanced Tab Device Flow User Code Format](https://images.ctfassets.net/cdy7uua7fh8z/5bz66ACqxQh00GCuTLUbkT/6a66352ecf00314dad96bbd105e60cc6/dashboard-tenant-settings-advanced-device-flow.png)\n\n*   **User Code Character Set**: Character set used to generate the user code.\n    \n*   **User Code Mask**: Mask used to format the user code. The mask defines the length of the user code and formats it into a friendly, readable value, allowing spaces or hyphens for readability.\n    \n\n### Global client information\n\nThe **Global Client ID** and **Global Client Secret** are used to generate tokens for legacy Auth0 APIs. Typically, you will not need these values. If you need to have the global client secret changed, please [contact support](https://support.auth0.com/).\n\n![Dashboard Tenant Settings Advanced Tab Global Client Information](https://images.ctfassets.net/cdy7uua7fh8z/1ILkvoM7wZx7OE1Ak8Fn8W/638f9541d1ed9e9df58eb0cade92248d/dashboard-tenant-settings-advanced-global-client.png)\n\n### Settings (Advanced)\n\n![Dashboard Tenant Settings Advanced Tab Settings](https://images.ctfassets.net/cdy7uua7fh8z/5O4QX2T4anl9eqHEZLPM2o/81cbed18ac2a1dbeac02a7b9a9e40494/Screenshot_2024-05-28_at_11.12.06_AM.png)\n\n*   **Change Password Flow v2**: When enabled, the newest version of the Change Password Flow will be used. The previous version has been deprecated, and we strongly recommend enabling v2. This flag is presented only for backward compatibility, and once enabled, you can no longer disable it. You can customize the user interface for the Change Password widget on the [Universal Login > Password Reset](https://manage.auth0.com/#/password_reset) tab in the Auth0 Dashboard.\n    \n*   **OIDC Dynamic Application Registration**: When enabled, third-party developers will be able to dynamically register applications for your APIs. You can also update this flag using the [`/tenant/patch_settings`](https://auth0.com/docs/api/management/v2#!/Tenants/patch_settings) endpoint of the Auth0 Management API. By default, this feature is disabled. To learn more, read [Dynamic Client Registration](https://auth0.com/docs/get-started/applications/dynamic-client-registration).\n    \n*   **Enable Application Connections**: When enabled, all current connections will be enabled for any new application that is created.\n    \n*   **Use a generic response in public signup API error message**: When enabled, errors generated while using the public signup API will return a generic response. This helps protect against user registration enumeration by preventing bad actors from being able to guess previously-registered email addresses or usernames from reading error response codes, such as `user_exists`.\n    \n*   **Enable Publishing of Enterprise Connections Information with IdP domains**: When enabled, it supports [Home Realm Discovery](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) and [Auth0 Lock](https://auth0.com/docs/libraries/lock) relies on a checked public file that includes enterprise connection information. If you don’t require that functionality, you can disable it.\n    \n*   **Enable email verification flow during login for Azure AD and ADFS connections**: When enabled, users will be presented with an email verification prompt during their first login when using Azure AD or ADFS connections.\n    \n*   **Refresh Token Revocation Deletes Grant**: When enabled, it deletes the underlying grant when you revoke a refresh token using the Authentication API `/oauth/revoke` endpoint.\n    \n*   **Allow Organization Names in Authentication API**: When enabled, [/authorize](https://auth0.com/docs/api/authentication#authorize-application) and [SAML](https://auth0.com/docs/api/authentication#saml) endpoints can accept both organization IDs and names. Additionally, ID and access tokens will include both `org_id` and `org_name` claims. Before enabling this setting, review [Use Organization Names in Authentication API](https://auth0.com/docs/manage-users/organizations/configure-organizations/use-org-name-authentication-api) for important considerations and potential impacts.\n    \n*   **Allow Pushed Authorization Requests (PAR):** When enabled, the `/par` endpoint can accept authorization requests pushed to it from a client application. This prevents the client application from sending requests via the insecure front channel (i.e. the browser).\n    \n\n### Extensibility\n\n![Dashboard Tenant Settings Advanced Tab Extensibility](https://images.ctfassets.net/cdy7uua7fh8z/3RVLXoBWLAuJkptdP60U2Y/1cecd2683ef76afe532d360baf5a81ea/Tenant_Settings_-_Extensibility.png)\n\n*   **Runtime**: Select the version of the Node.js runtime environment you want to use for Auth0 extensibility features, including [Actions](https://auth0.com/docs/customize/actions) and [Custom Database Action Scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/templates). If you are migrating to a newer version of Node.js, read [Migrate to Node.js 16](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-nodejs-16) and [Migrate Actions from Node.js 16 to Node.js 18](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-actions-nodejs-16-to-nodejs-18).\n    \n\n### Migrations\n\nIn this section, you can choose to enable or disable various migrations that are available.\n\n### Feature Previews\n\nIn this section, you can choose to enable or disable feature previews that are available.\n\n### Delete tenant or subscription\n\nDeleted tenants cannot be restored and the tenant name cannot be used again when creating new tenants. To learn how to reset your tenant configuration, read [Delete or Reset Tenants](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/delete-or-reset-tenant).\n\n## Learn more\n\n*   [Manage Subscriptions](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions)\n*   [Delete or Reset Tenants](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/delete-or-reset-tenant)\n*   [Manage Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access)\n*   [Signing Keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys)\n*   [Custom Domains](https://auth0.com/docs/customize/custom-domains)",
  "title": "Tenant Settings",
  "description": "Describes the settings related to tenants available in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/manage-dashboard-access",
  "markdown": "# Manage Dashboard Access\n\nAs an Auth0 tenant administrator, you are responsible for all activities that occur under your Auth0 account and tenants including managing your tenant members. You can add, change, and remove tenant members (dashboard users) in the Auth0 Dashboard or from the [Auth0 Teams Dashboard](https://auth0.com/docs/get-started/auth0-teams/tenant-member-management). Auth0 recommends that you periodically review the list of Auth0 Dashboard tenant members with access to your Auth0 tenant and make sure that:\n\n*   Each person has a legitimate need for tenant member access.\n    \n*   Members are registered with a company account.\n    \n*   Former employees no longer have access.\n    \n*   There's more than one Dashboard admin.\n    \n\nHere are some examples of users who may have special access requirements:\n\n*   Support specialists who need to troubleshoot login issues for your app end users.\n    \n*   Support/IT specialists who need to assign roles and permissions to end users.\n    \n*   Developers who need to troubleshoot their applications in production environments. \n    \n*   Product managers who need to analyze their applications' configuration and usage.\n    \n*   Developers who need to configure settings for their own applications.\n    \n*   Support/IT specialists that need to create connections for their customers in a B2B use case.",
  "title": "Manage Dashboard Access",
  "description": "Describes how to manage your team members to have access permissions on your Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/apis",
  "markdown": "# APIs\n\nAn API is an entity that represents an external resource, capable of accepting and responding to protected resource requests made by applications. In the [OAuth2 specification](https://tools.ietf.org/html/rfc6749), an API maps to the **Resource Server**.\n\nAt some point, your custom APIs will need to allow limited access to their protected resources on behalf of users. Authorization refers to the process of verifying what a user has access to. While often used interchangeably with [authentication](https://auth0.com/docs/authenticate), authorization represents a fundamentally different function. To learn more, read [Authentication and Authorization](https://auth0.com/docs/get-started/identity-fundamentals/authentication-and-authorization).\n\nIn authorization, a user or application is granted access to an API after the API determines the extent of the permissions that it should assign. Usually, authorization occurs after identity is successfully validated through authentication so that the API has some idea of what sort of access it should grant.\n\nAuthorization can be determined through the use of [policies](https://auth0.com/docs/manage-users/access-control/authorization-policies) and [rules](https://auth0.com/docs/manage-users/access-control/rules-for-authorization-policies), which can be used with [role-based access control (RBAC)](https://auth0.com/docs/manage-users/access-control/rbac). Regardless of whether RBAC is used, requested access is transmitted to the API via scopes and granted access is returned in issued Access Tokens.\n\nThe application can then use the Access Token to access the API's protected resources. The same Access Token can be used to access the API's resources without having to authenticate again until it expires.\n\n## API permissions\n\nSince only the API can know all of the possible actions that it can handle, it should have its own internal access control system in which it defines its own permissions. To determine a calling application's effective permissions, an API should combine incoming scopes with the permissions assigned within its own internal access control system and make access control decisions accordingly.\n\n## Configure an API\n\nTo protect an API, you must register an API using the Auth0 Dashboard. To learn more, see [Register APIs](https://auth0.com/docs/get-started/auth0-overview/set-up-apis).\n\n## Learn more\n\n*   [API Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes)\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Register APIs](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)\n*   [API Settings](https://auth0.com/docs/get-started/apis/api-settings)",
  "title": "APIs",
  "description": "Explore key topics related to working with APIs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow",
  "markdown": "# Authentication and Authorization Flows\n\nAuth0 uses the [OpenID Connect (OIDC) Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol) and [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth) to authenticate users and get their authorization to access protected resources. With Auth0, you can easily support different flows in your own applications and APIs without worrying about OIDC/OAuth 2.0 specifications or other technical aspects of [authentication and authorization](https://auth0.com/docs/get-started/identity-fundamentals/authentication-and-authorization).\n\nWe support scenarios for server-side, mobile, desktop, client-side, machine-to-machine, and device applications.\n\nIf you're not sure which flow to use, we can help you decide. To learn more, read [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use).\n\nBecause regular web apps are server-side apps where the source code is not publicly exposed, they can use the Authorization Code Flow, which exchanges an Authorization Code for a token.\n\n*   [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)\n    \n*   [Add Login Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow)\n    \n*   [Call API Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/call-your-api-using-the-authorization-code-flow)\n    \n\n## Authorization Code Flow with Proof Key for Code Exchange (PKCE)\n\nDuring authentication, mobile and native applications can use the Authorization Code Flow, but they require additional security. Additionally, single-page apps have special challenges. To mitigate these, OAuth 2.0 provides a version of the Authorization Code Flow which makes use of a Proof Key for Code Exchange (PKCE).\n\n*   [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)\n    \n*   [Add Login Using the Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/add-login-using-the-authorization-code-flow-with-pkce)\n    \n*   [Call API Using the Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce)\n    \n\n## Authorization Code Flow with enhanced privacy protection\n\nDuring the authentication and authorization process, some use cases such as [transactional authorization](https://auth0.com/docs/secure/highly-regulated-identity/transactional-authorization-with-contextual-sca) exchange contextual information, which may contain sensitive data. To protect data and sensitive information, you can use different protocol improvements for the authorization code flow:\n\n*   [Authorization Code Flow with Rich Authorization Requests (RAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-rar)\n    \n*   [Authorization Code Flow with Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par)\n    \n*   [Authorization Code Flow with JWT-Secured Authorization Requests (JAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-jar)\n    \n*   [Authorization Code Flow with PAR and JAR](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par-and-jar)\n    \n*   [JSON Web Encryption (JWE)](https://auth0.com/docs/secure/tokens/access-tokens/json-web-encryption)\n    \n\n## Implicit Flow with Form Post\n\nAs an alternative to the Authorization Code Flow, OAuth 2.0 provides the Implicit Flow, which is intended for Public Clients, or applications which are unable to securely store Client Secrets. While this is no longer considered a best practice for requesting Access Tokens, when used with Form Post response mode, it does offer a streamlined workflow if the application needs only an ID token to perform user authentication.\n\n*   [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post)\n    \n*   [Add Login Using the Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/add-login-using-the-implicit-flow-with-form-post)\n    \n*   [Authenticate SPAs with Cookies](https://auth0.com/docs/manage-users/cookies/spa-authenticate-with-cookies)\n    \n\n## Hybrid Flow\n\nApplications that are able to securely store Client Secrets may benefit from the use of the Hybrid Flow, which combines features of the Authorization Code Flow and Implicit Flow with Form Post to allow your application to have immediate access to an ID token while still providing for secure and safe retrieval of access and refresh tokens. This can be useful in situations where your application needs to immediately access information about the user, but must perform some processing before gaining access to protected resources for an extended period of time.\n\n*   [Hybrid Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/hybrid-flow)\n    \n*   [Call API Using the Hybrid Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/hybrid-flow/call-api-hybrid-flow)\n    \n\n## Client Credentials Flow\n\nWith machine-to-machine (M2M) applications, such as CLIs, daemons, or services running on your back-end, the system authenticates and authorizes the app rather than a user. For this scenario, typical authentication schemes like username + password or social logins don't make sense. Instead, M2M apps use the Client Credentials Flow (defined in OAuth 2.0 RFC 6749, section 4.4).\n\n*   [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow)\n    \n*   [Call API Using the Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/call-your-api-using-the-client-credentials-flow)\n    \n\n## Device Authorization Flow\n\nWith input-constrained devices that connect to the internet, rather than authenticate the user directly, the device asks the user to go to a link on their computer or smartphone and authorize the device. This avoids a poor user experience for devices that do not have an easy way to enter text. To do this, device apps use the Device Authorization Flow (drafted in OAuth 2.0). For use with mobile/native applications.\n\n*   [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)\n    \n*   [Call API Using the Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow/call-your-api-using-the-device-authorization-flow)\n    \n\n## Resource Owner Password Flow\n\nThough we do not recommend it, highly-trusted applications can use the Resource Owner Password Flow, which requests that users provide credentials (username and password), typically using an interactive form. The Resource Owner Password Flow should only be used when redirect-based flows (like the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)) cannot be used.\n\n*   [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n    \n*   [Call API Using the Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/call-your-api-using-resource-owner-password-flow)",
  "title": "Authentication and Authorization Flows",
  "description": "Learn about the various flows used for authentication and authorization of applications and APIs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login",
  "markdown": "# Login\n\nAuth0 offers two ways to implement login authentication for your applications:\n\n*   **Universal Login** where users log in to your application through a page hosted by Auth0.\n    \n*   **Embedded Login** where users log in to your application through a page you host.\n    \n\nFor the vast majority of use cases, we recommend Universal Login. It's safe and easy to implement.",
  "title": "Login",
  "description": "Learn about the ways to implement login authentication for your users with Auth0 Universal Login or Embedded Login. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/professional-services",
  "markdown": "# Auth0 Professional Services\n\nThe Auth0 Professional Services portfolio consists of innovative, specialized service offerings designed to optimize customers' investments in Auth0. Professional Services help customers deploy, implement, and maintain solutions based on proven practices, avoiding common pitfalls, and reducing risk.\n\n## How Professional Services can help with your project\n\nCustomers buy software to solve a business problem. The longer it takes to integrate with that software, the longer the business problem remains unsolved. If integration stalls or fails, it’s a lost opportunity and a major additional cost both for you and for Auth0; at worst, it can become an even bigger security issue or legal nightmare. That's why it's of the utmost importance to plan, design, and implement your IAM solution securely, effectively, and expediently. This is where Auth0 Professional Services come in.\n\n## Get to production faster\n\nWe can help consolidate all the enablement activities leading to a successful adoption into three major milestones; the goal of a Professional Services engagement is to identify, document, and build consensus with you on these milestones as the path to successful Auth0 adoption:\n\n*   **Discovery and Design:** where our Solution Architects will work with your teams to identify the core goals, features, and functionality that constitute your successful IAM implementation. We'll also help you uncover any legacy architectural issues or design requirements that may need more careful consideration.\n    \n*   **Initial Go-Live:** designed to be impactful enough to make material differences in your overall Identity project. At the same time, it's limited enough that it can be reached quickly—ideally within 30 days of the project start—to keep the positive momentum. Initial Go-Live typically includes migration off a legacy IDP, must-have features, and possibly a subset of all your applications.\n    \n*   **Advanced Go-Live:** this can be easily broken into multiple sub-milestones—especially if you have multiple applications or development teams. This helps manage the complexity of a large project and is designed to help you achieve incremental and steady progress.\n    \n\n## Services\n\nDesigned to optimize our customers' investment in Auth0, our service offerings provide the proven best practice assistance required to help avoid common pitfalls and reduce risk when tackling the range of activities involved as part of integrating with Auth0:\n\n| **Read...** | **To learn...** |\n| --- | --- |\n| [Discover and Design](https://auth0.com/docs/professional-services/discover-design) | How we can help you optimize your architectural design based on your needs. |\n| [Implement](https://auth0.com/docs/professional-services/implement) | How you can accelerate your integration with Auth0 through programming advisory, deployment preparatio, and custom implementation. |\n| [Maintain and Improve](https://auth0.com/docs/professional-services/maintain-improve) | How we can review your identity environment, optimize and improve your solution, and advise you about new features. |\n\n[Contact us](https://auth0.com/contact-us) to get started!",
  "title": "Auth0 Professional Services",
  "description": "Describes the Auth0 professional services offerings.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless",
  "markdown": "# Passwordless Connections\n\nPasswordless connections allow users to log in without the need to remember a password. Instead, users enter their mobile phone number or email address and receive a one-time password (OTP) or link, which they can then use to log in.\n\nWhen a user authenticates through a passwordless connection, their profile is created on the connection using Auth0 as the Identity Provider (IdP). Since you can't force users to use the same mobile phone number or email address every time they authenticate, users may end up with multiple user profiles in the Auth0 datastore. If this happens, you can associate multiple user profiles by [linking their accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking).\n\n### Passwordless connection vs. passwordless login\n\nA passwordless connection is another type of connection separate from any existing database, social, or enterprise connections. Even though a user from an Auth0 user database or social provider might share the same email address, the identity associated with their passwordless connection is distinct. As with linking multiple email addresses or mobile phone numbers used for the Passwordless connection, [account linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking) can also be used to associate a passwordless identity with identities from other types of connections.\n\nIn addition to supporting passwordless with passwordless connections, Auth0 lets you define a passwordless flow using WebAuthn with Device Biometrics. To learn more, review [Configure WebAuthn with Device Biometrics for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics).\n\n## Benefits\n\nThe benefits of using passwordless authentication include:\n\n*   Improved user experience. Users only need an email address or mobile phone number to sign up.\n    \n*   Enhanced security. Passwords are a major vulnerability as users reuse passwords and are able to share them with others. Passwords are the biggest attack vector and are responsible for a significant percentage of breaches. They also lead to attacks such as credentials stuffing, corporate account takeover, and brute force attacks.\n    \n*   Reduced total cost of ownership. Managing passwords is expensive between implementing password complexity policies, managing password expiration and password reset processes, hashing and storing passwords, and monitoring breached password detection.\n    \n\n## Supported authentication methods\n\nAuth0 passwordless connections support OTPs sent through SMS or email, and magic links sent through email.\n\n### SMS\n\nWhen using passwordless authentication with SMS, users:\n\n1.  Provide a mobile phone number instead of a username/password combination.\n    \n    ![Example of using Passwordless SMS](https://images.ctfassets.net/cdy7uua7fh8z/5duaNojd4n76NlAsYrdMYo/ebc92f9e422965202e225c5156638ef8/passwordless-sms-enter-phone-web.png)\n2.  Receive an OTP through SMS.\n    \n3.  Enter the OTP on the login screen to access the application.\n    \n\n### Email\n\nWhen using passwordless authentication with email, users:\n\n1.  Provide an email address instead of a username/password combination.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/5lq4hQnYFM4uphbj9YslUy/36abf4c62b442d6845dbe44edbe2fb5a/passwordless-email.png)\n2.  Depending on how you have configured your passwordless connection, receive either an OTP or magic link through email.\n    \n3.  Enter the OTP on the login screen (or open the magic link in the email) to access the application.\n    \n\n## Implement Passwordless\n\nTo implement passwordless, you'll need to make two key decisions:\n\n*   Which authentication factor(s) you want to support\n    \n*   Which login type you want to use\n    \n\n### Authentication factors\n\nWhen deciding to support an authentication factor, you must consider the user's experience, which that depends on your application and its target audience. If the application will run on mobile phones, it is highly likely that users will be able to receive SMS messages. If it's an internal web application that is used in an environment where users cannot have their mobile phones with them, email would be the only choice.\n\nIf you decide to use email, then you need to decide between OTPs or Magic Links. We recommend using OTPs, because the login flow is more predictable for end users. To learn more about authentication factors, read the following articles:\n\n*   [Passwordless Authentication with Email and One-time Passwords (OTP)](https://auth0.com/docs/authenticate/passwordless/authentication-methods/email-otp)\n    \n*   [Passwordless Authentication with Email and Magic Links](https://auth0.com/docs/authenticate/passwordless/authentication-methods/email-magic-link)\n    \n*   [Passwordless Authentication with SMS](https://auth0.com/docs/authenticate/passwordless/authentication-methods/sms-otp)\n    \n\n### Login type\n\nAuth0 recommends using either the Universal Login or the Classic Login experience to implement Passwordless authentication, but you may decide that Embedded Login is the best choice for your application.\n\nTo learn more about how to configure Passwordless authentication for different login types, read the following articles:\n\n*   [Passwordless Authentication with Universal Login](https://auth0.com/docs/authenticate/passwordless/passwordless-with-universal-login)\n    \n*   [Passwordless Authentication with Classic Login](https://auth0.com/docs/authenticate/passwordless/implement-login/universal-login)\n    \n*   [Passwordless Authentication with Embedded Login](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login)\n    \n\n## Learn more\n\n*   [Passwordless Connections Best Practices](https://auth0.com/docs/authenticate/passwordless/best-practices)\n*   [Using Passwordless APIs](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/relevant-api-endpoints)",
  "title": "Passwordless Connections",
  "description": "Learn about passwordless connections, Auth0-supported passwordless methods of authentication, and how to implement passwordless authentication with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios",
  "markdown": "# Architecture Scenarios\n\nCustomers using Auth0 typically have a common set of goals and objectives, and we want to share our real-world customer implementation experiences to help you deliver your solution efficiently.\n\n## Business use cases and planning guides\n\nThese planning guides provide strategies for successfully integrating with Auth0 using a phased approach across multiple workstreams.\n\n## Application architecture scenarios\n\nThese scenarios describe the different types of technology architectures your application may use and how Auth0 can help. The goal of these scenarios is to walk you through the implementation process from beginning to end.\n\n| **Read...** | **To learn...** |\n| --- | --- |\n| [Multiple Organizations](https://auth0.com/docs/architecture-scenarios/multiple-organization-architecture) | How to configure an application architecture that uses either single identity provider organizations or multiple identity provider organizations. |\n| [Single Sign-On for Regular Web Apps](https://auth0.com/docs/architecture-scenarios/web-app-sso) | How to configure and implement a web application that uses SSO for employees using Active Directory and contractors using a separate user store. |\n| [Server Application + API](https://auth0.com/docs/architecture-scenarios/server-api) | How to configure a timesheet API using a cron job to log timesheet entries. |\n| [Single Page Application + API](https://auth0.com/docs/architecture-scenarios/spa-api) | How to configure a timesheet API using a single-page application to log timesheet entries. |\n| [Mobile Application + API](https://auth0.com/docs/architecture-scenarios/mobile-api) | How to configure a timesheet API using a mobile application to log timesheet entries in a centralized database. |\n\n## Implementation checklists and resources\n\nWe provide downloadable spreadsheet checklists that include tasks for each phase of your software development lifecycle (SDLC) project. We also provide other resources to help to get started quickly, test sample code, and try APIs.\n\n| **Read...** | **To learn...** |\n| --- | --- |\n| [Implementation Checklists](https://auth0.com/docs/architecture-scenarios/checklists) | How to plan for tasks associated with each phase in your SDLC project. |\n| [Implementation Resources](https://auth0.com/docs/architecture-scenarios/implementation-resources) | About the resources Auth0 provides to help you get started including videos, terminology, white papers, blog posts, quickstarts, APIs, SDKs, the Auth0 Community forum, and our Auth0 Support Center. |",
  "title": "Architecture Scenarios",
  "description": "Learn about common Auth0 architecture scenarios that you can use to solve your authorization and authentication needs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on",
  "markdown": "# Single Sign-On\n\nSingle Sign-on (SSO) occurs when a user logs in to one application and is then signed in to other applications automatically, regardless of the platform, technology, or domain the user is using. The user signs in only one time, hence the name of the feature (Single Sign-on).\n\nFor example, if you log in to a Google service such as Gmail, you are automatically authenticated to YouTube, AdSense, Google Analytics, and other Google apps. Likewise, if you log out of your Gmail or other Google apps, you are automatically logged out of all the apps; this is known as Single Logout.\n\nSSO provides a seamless experience for users when using your applications and services. Instead of having to remember separate sets of credentials for each application or service, users can simply log in once and access your full suite of applications.\n\nWhenever users go to a domain that requires authentication, they are redirected to the authentication domain where they may be asked to log in. If the user is already logged in at the authentication domain, they can be immediately redirected to the original domain without signing in again.\n\n## How it works\n\nSingle Sign-on and Single Logout are possible through the use of [sessions](https://auth0.com/docs/manage-users/sessions). There may be up to three different sessions for a user with SSO:\n\n*   Local session maintained by the application\n    \n*   Authorization Server session, if SSO is enabled\n    \n*   Identity Provider (IdP) session, if the user chose to log in through an Identity Provider (such as Google, Facebook, or an enterprise SAML Identity Provider)\n    \n\nWith SSO, a central domain performs authentication and then shares the session with other domains. The way a session is shared may differ between SSO protocols, but the general concept is the same.\n\nFor example, the authentication domain may generate a signed [JSON Web Token (JWT)](https://auth0.com/docs/secure/tokens/json-web-tokens) (encrypted using JSON Web Encryption (JWE)), which contains all the information needed to identify the user for any other domain requiring authentication. This token is passed to the client, but because it is signed, it cannot be modified in any way by the client. The token can be passed to the original domain by a redirect and used by the authentication domain and any other domains to identify the user.\n\n## SSO with Universal Login\n\nThe easiest and most secure way to implement Single Sign-on (SSO) with Auth0 is by using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) for authentication. In fact, currently SSO is only possible with native platforms (like iOS or Android) if the application uses Universal Login. The [Swift](https://auth0.com/docs/quickstart/native/ios-swift/00-login) and [Android](https://auth0.com/docs/quickstart/native/android/00-login) quick starts provide some examples of using Universal Login.\n\nIf you cannot use Universal Login with your application, review the following for additional info on embedded authentication:\n\n*   [Lock](https://auth0.com/docs/libraries/lock/lock-api-reference)\n    \n*   [Auth0.js](https://auth0.com/docs/libraries/auth0js)\n    \n\n### SSO on first login\n\nFor SSO with Auth0, the **Central Service** is the Auth0 Authorization Server.\n\nLet's look at an example of the SSO flow when a user logs in for the first time:\n\n1.  Your application redirects the user to the login page.\n    \n2.  Auth0 checks to see whether there is an existing SSO cookie.\n    \n3.  Because this is the first time the user is visiting the login page and no SSO cookie is present, the user will be asked to log in using one of the connections you have configured.\n    \n    ![Example timesheets application login screen](https://images.ctfassets.net/cdy7uua7fh8z/6m01sxT4xI0oUC6ox3vb4Z/99a19ac391ae33b1307d7de29c2222d1/lock-no-sso-cookie.png)\n4.  Once the user has logged in, Auth0 will set an SSO cookie and redirect the user to your application, returning an ID Token that contains identity information for the user.\n    \n\n### SSO on subsequent logins\n\nLet's look at an example of the SSO flow when a user returns to your website for a subsequent visit:\n\n1.  Your application redirects the user to the login page.\n    \n2.  Auth0 checks to see whether there is an existing SSO cookie.\n    \n3.  Auth0 finds the SSO cookie, and if necessary, updates it. No login screen is shown.\n    \n4.  Auth0 redirects the user to your application, returning an ID Token that contains identity information for the user.\n    \n\n### Check user's SSO status\n\nYou can check a user's SSO status from an application by calling the `checkSession` method of the `auth0.js` SDK, which will attempt to [silently authenticate](https://auth0.com/docs/authenticate/login/configure-silent-authentication) the user within an iframe. Whether the authentication is successful or not indicates whether the user has an active SSO cookie.\n\n## Protocols\n\n### SAML and WS-Federation\n\nSecurity Assertion Markup Language (SAML) and Web Services Federation (WS-Fed) are both [protocols](https://auth0.com/docs/authenticate/protocols) that are widely used in SSO implementations. Both SAML and WS-Fed exchange authorization and authentication data in XML format; the main parts of this exchange are the user, the identity provider, and the service provider.\n\nWith SAML or WS-Fed:\n\n1.  A user requests a resource from the service provider.\n    \n2.  The service provider checks with the identity provider to see if the user should have access to the resource.\n    \n3.  The identity provider verifies the user's identity, and if valid, asserts back to the service provider that the user should have access.\n    \n\n### OpenID Connect\n\nOpenID Connect (OIDC) is an authentication protocol commonly used in consumer-facing SSO implementations. The OIDC protocol handles authentication through JSON Web Tokens and a central identity provider.\n\nWith OIDC:\n\n1.  A user requests access to an application.\n    \n2.  The application redirects the user to the identity provider for authentication.\n    \n3.  The identity provider verifies the user, and if successful, prompts the user to grant data access to the application.\n    \n4.  If access is granted, the identity provider generates an ID Token, which contains user identity information that the application can consume.\n    \n5.  The identity provider returns the user to the application.\n    \n\n### AD/LDAP\n\nLightweight Directory Access Protocol (LDAP) is an application protocol used to access a directory of credentials that can be shared by multiple applications; it is commonly used by intranets. When paired with Active Directory (AD), LDAP provides a centralized location for user identity, so the application makes an authentication request to the LDAP/AD server. The LDAP protocol exchanges information in LDAP Data Interchange Format (LDIF).\n\n## Service-provider-initiated SSO\n\nFor [Service-Provider-initiated SSO](https://auth0.com/docs/authenticate/single-sign-on/inbound-single-sign-on), Auth0 is the SSO Service Provider (SP).\n\nWhen a user logs in to an application:\n\n1.  The application presents the user with one or more external identity providers.\n    \n2.  The user selects an identity provider to authenticate with and logs in.\n    \n3.  Upon successful authentication, the user is returned to the application.\n    \n\nSP-initiated SSO in Auth0 is handled by connections.\n\n## Identity-provider-initiated SSO\n\nFor [Identity-Provider-initiated SSO](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on), a third-party Identity Provider (IdP) is the SSO provider.\n\nWhen a user logs in to an application:\n\n1.  The application redirects the user to an identity provider.\n    \n2.  The third-party identity provider performs authentication and authorization.\n    \n3.  Upon successful authentication, the user is returned to the application.\n    \n\nWhen planning an IdP-initiated SSO implementation, you may choose to use Auth0's [SSO Dashboard Extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/create-sso-dashboard-application), which allows you to create a dashboard that lists multiple enterprise applications that can be enabled for SSO. This dashboard is then presented to your users to log in.\n\n## Use cases\n\n### Business to Business\n\nFor Business to Business (B2B) scenarios, SSO can simplify packaging your application for enterprise consumption. With Auth0, your applications can support common enterprise federation scenarios, such as Active Directory (AD), Lightweight Directory Access Protocol (LDAP), Ping, or Security Assertion Markup Language (SAML). This allows your partners and enterprise customers to log in with their preferred enterprise identity technologies.\n\n*   [Case Study: O'Reilly](https://auth0.com/case-studies/oreilly)\n    \n\n### Business to Consumer CIAM\n\nFor Business to Consumer (B2C) or Customer Identity Access Management (CIAM) scenarios, SSO can provide frictionless access to your applications or services. You can let customers authenticate through popular social identity providers, such as Google, Facebook, LinkedIn, X, and Microsoft, instead of requiring them to make another account.\n\n*   [Case Study: Giving Compass](https://auth0.com/case-studies/giving-compass)\n    \n\n## Learn more\n\n*   [Service-Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on/inbound-single-sign-on)\n*   [Identity-Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on)\n*   [API Endpoints for Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on/api-endpoints-for-single-sign-on)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)\n*   [Verify Connections](https://auth0.com/docs/troubleshoot/basic-issues/verify-connections)",
  "title": "Single Sign-On",
  "description": "Learn what Single Sign-on (SSO) is and how it works.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections",
  "markdown": "# Database Connections\n\nAuth0 provides database connections to authenticate users with an email/username and password. These credentials are securely stored in the Auth0 user store or in your own database.\n\nYou can create a new database connection and manage existing ones at [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database):\n\n![Select connection](https://images.ctfassets.net/cdy7uua7fh8z/6shISO4Uw6XqldxxGnbrqW/0215e069f09c6baebd1d7abb5b3ae253/2024-03-20_16-39-37.png)\n\n## Scenarios\n\nAuth0 provides the database infrastructure to store your users by default. This scenario provides the best performance for the authentication process since all data is stored in Auth0.\n\nThe Auth0-hosted database is highly secure. Passwords are never stored or logged in plain text but are hashed with **bcrypt**. Varying levels of password security requirements can also be enforced. To learn more, read [Password Strength in Auth0 Connections](https://auth0.com/docs/authenticate/database-connections/password-strength).\n\n## Learn more\n\n*   [Manage Users](https://auth0.com/docs/manage-users)",
  "title": "Database Connections",
  "description": "Learn how to create and use a database connection using either the Auth0 user store or your own user store.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts",
  "markdown": "# User Accounts\n\nAuth0's hosted cloud database stores a variety of information on your users that is accessible to you. This information is available to you via a user profile, and your users are grouped by tenant. The user information itself can come from a variety of sources, including identity providers, your own databases, and enterprise connections (Active Directory, SAML).",
  "title": "User Accounts",
  "description": "Learn about working with user accounts in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/enterprise-connections",
  "markdown": "# Enterprise Connections\n\nAuth0 provides Enterprise connections to authenticate users in an external, federated identity provider (IdP) such as Azure AD, Google Workspace, PingFederate, and more.\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects the availability of this feature. To learn more, read [Auth0's Pricing Page](https://auth0.com/pricing).\n\n## Create an Enterprise connection\n\nAuth0 supports many identity providers out of the box. To learn more, review [Enterprise Identity Providers](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers).\n\n#### OpenID Connect (OIDC) protocol\n\nEnterprise connections using OpenID Connect or Okta Workforce as the identity provider can support the following:\n\n*   Proof Key for Code Exchange (PKCE)\n    \n    *   For more information on PKCE, review [Protecting Apps with PKCE](https://www.oauth.com/oauth2-servers/pkce/).\n        \n*   Attribute claims and access token mapping\n    \n*   UserInfo integration\n    \n\nYou can currently implement these features for [OpenID Connect](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/oidc) or [Okta Workforce](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/okta) connections. To learn more, review [Configure PKCE and Claim Mapping for OIDC Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc).\n\n## View Enterprise connections\n\nNavigate to [**Auth0 Dashboard > Authentication > Enterprise**](https://manage.auth0.com/#/connections/enterprise) to see all available Enterprise connection types. Select a connection type (for example, SAML) to see if there are any configured connections of that type.\n\nYou can also select a configured connection and check the **Applications** tab to see if it is enabled for any applications.\n\n## What is an active Enterprise connection?\n\nAn Enterprise connection is considered active if (during the current month) it has both:\n\n*   Been enabled for an application.\n    \n*   Had user activity (for example, login, sign-up, or token exchange).\n    \n\nIf an Enterprise connection was never enabled for any application, or was enabled but did not have any user activity during the current month, it is not considered active.\n\n## Learn more\n\n*   [Enterprise Identity Providers](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers)\n*   [Enable Enterprise Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections)\n*   [View Connections](https://auth0.com/docs/authenticate/identity-providers/view-connections)\n*   [Test Enterprise Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections)\n*   [Entity Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/entity-limit-policy)",
  "title": "Enterprise Connections",
  "description": "Learn how to create, manage, and monitor usage of Enterprise connections to authenticate users with external identity providers.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols",
  "markdown": "# Protocols\n\nThere are a set of open specifications and protocols that specify how to design an authentication and authorization system. They specify how you should manage identity, move personal data securely, and decide who can access applications and data.\n\nThe identity industry standards that we use at Auth0 are:\n\n*   Open Authorization (OAuth) 1: the original standard for access delegation. Used as a way for a user to grant websites access to their information on other websites or apps, but without giving them the credentials.\n    \n*   [Open Authorization (OAuth) 2](https://auth0.com/docs/authenticate/protocols/oauth): an authorization standard that allows a user to grant limited access to their resources on one site to another site, without having to expose their credentials. You use this standard every time you log in to a site using your Google account and you are asked if you agree with sharing your email address and your contacts list with that site.\n    \n*   [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol): an identity layer that sits on top of OAuth 2 and allows for easy verification of the user's identity, as well as the ability to get basic profile information from the identity provider.\n    \n*   [Lightweight Directory Access Protocol (LDAP)](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector): an application protocol used for accessing and maintaining distributed directory information services over an IP network. The function of LDAP is to enable access to an existing directory like Active Directory (AD). Auth0 uses a connector that you install on your network to integrate with AD/LDAP.\n    \n*   [JSON Web Tokens (JWTs)](https://auth0.com/docs/secure/tokens/json-web-tokens): an open standard that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.\n    \n*   [Security Assertion Markup Language (SAML)](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration): an open-standard, XML-based data format that allows businesses to communicate user authentication and authorization information to partner companies and enterprise applications their employees may use.\n    \n*   [WS-Federation (WS-Fed)](https://auth0.com/docs/authenticate/protocols/ws-fed-protocol): a standard developed by Microsoft, and used extensively in their applications. It defines the way security tokens can be transported between different entities to exchange identity and authorization information.",
  "title": "Protocols",
  "description": "Describes which authorization protocols Auth0 supports and how they work.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/connection-settings-best-practices",
  "markdown": "# Connection Settings Best Practices\n\nHere are some best practices for configuring connections. Before you set up connections, take a moment to review what connections are and [learn the basics of authentication](https://auth0.com/docs/authenticate) for your application type.\n\nAuth0 provides default credentials for social connections to help you get started. You should replace these temporary credentials with your own to avoid restrictions.\n\n## Review requested data\n\nYou should review the data you are requesting from each social connection. Users must grant consent for the requested data. Requesting a lot of unnecessary data may result in users declining the authorization request out of privacy concerns.\n\n## Set password policy for database connections\n\nConfigure the password policy for your Auth0 database connections so created users have strong passwords. You can configure the password policy in the database connection settings on the dashboard or with the Auth0 Management API.\n\nThe password policy applies to password resets performed with the Universal Login Page as well as the Auth0 Management API.\n\n## Disable user signup if it's not appropriate for each database connection\n\nIn your database connection settings, specify if self-service user signups should be enabled. If you enabled this during development, review if you should disable it on production tenants.\n\nOnly enable this setting for production tenants if you allow end-users to sign up in a self-service manner. If self-service signup is not allowed, disable the feature. You can then add users to the database connection with the Auth0 Management API.\n\nWhen using the Organizations feature, you can enable self-service signup for a given database connection in the context of a specific organization. When enabled, users can access a Sign Up link on the login prompt and gain membership to a specific organization upon creating their account. For more information, review [Enable Organization Connections](https://auth0.com/docs/manage-users/organizations/configure-organizations/enable-connections).\n\n## Review applications enabled for each connection\n\nFor each connection, review the list of allowed applications. Make sure there are no unintended authentication paths into an application. By default, new applications may have all of your tenant's connections enabled, which may not be appropriate.\n\n## Use RSA-SHA256 for SAML connections\n\nConfigure any SAML connections to sign requests and use RSA-SHA256 as the signature algorithm. This ensures the remote SAML Identity Provider can validate whether the authentication requests came from a legitimate application or not.",
  "title": "Connection Settings Best Practices",
  "description": "Learn about recommended identity provider connection settings in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-migration",
  "markdown": "# Import and Export Users\n\nAuth0 supports importing users from external applications using custom database connections, the Auth0 Management API, or the User Import/Export Extension.\n\n## Automatic migrations\n\nAuth0 supports automatic migration of users from a [custom database connection](https://auth0.com/docs/connections/database/custom-db) to Auth0. This practice is sometimes known as **trickle migration** or **lazy migration**. By activating this feature, your users are:\n\n*   Moved to Auth0 the first time they log in after you set up the integration.\n    \n*   Not asked to reset their password as a result of the migration.\n    \n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nWhen a user authenticates via a custom database connection marked for import to Auth0, the following process takes place:\n\n*   Auth0 authenticates migrated users against the Auth0 database.\n    \n*   If the user has not been migrated, Auth0 executes your custom login script and, upon successfully log in, adds the user to the Auth0 database.\n    \n*   Subsequent logins result in the user's credentials retrieved from Auth0, **NOT** your custom database.\n    \n*   New users are automatically added to the Auth0 database.\n    \n\n![User Migration Diagram](https://images.ctfassets.net/cdy7uua7fh8z/JAHBs6NzVRf0N5iXI7Wby/770d8ad3f03a5f47ad28ec2947c92993/migrating-diagram.png)\n\n## Bulk user imports with the Management API\n\nIf you already have a user database, you can use our [`/post_users_imports`](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_imports) Management API endpoint to populate a database connection with this information.\n\n## Migrate users with the User Import/Export Extension\n\nThe User Import/Export Extension allows you to:\n\n*   Bulk import your existing database users into Auth0.\n    \n*   Search for and export some (or all) of your Auth0 database users.\n    \n\nYou must be a Dashboard Admin to use this extension.\n\nYou can import and export user data using the User Import/Export Extension available on the [Extensions](https://manage.auth0.com/#/extensions) section of the Dashboard. Select the **User Import / Export** extension and install it. For more information, see [User Import/Export Extension](https://auth0.com/docs/manage-users/user-migration/user-import-export-extension).\n\n## Learn more\n\n*   [Configure Automatic Migration from Your Database](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database)\n*   [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports)\n*   [User Import / Export Extension](https://auth0.com/docs/manage-users/user-migration/user-import-export-extension)",
  "title": "Import and Export Users",
  "description": "Overview of importing users from external applications into Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-search",
  "markdown": "# Search for Users\n\nUser search allows you to retrieve user profile details using Auth0's [Management API](https://auth0.com/docs/api/management/v2). Search results can be [viewed](https://auth0.com/docs/manage-users/user-search/view-search-results-by-page), [sorted](https://auth0.com/docs/manage-users/user-search/sort-search-results), and [exported](https://auth0.com/docs/manage-users/user-migration/bulk-user-exports).\n\nMost user profile fields are not returned as part of an [ID Token](https://auth0.com/docs/secure/tokens/id-tokens), nor are they included in the response from the [`/userinfo` endpoint](https://auth0.com/docs/api/authentication#get-user-info) of the Authentication API.\n\nWhen searching for users in Auth0, you can use multiple endpoints to search for ID, email, or other criteria:\n\n## Search Result Terminology\n\nWe use the following terms to describe the user search results:\n\n*   **Eventually consistent**: Search results may not reflect a recently-completed write operation. However, if you repeat your request after a short period of time, the response will return up-to-date data.\n    \n*   **Immediately consistent**: Search results will reflect the results of all successful write operations, including those that occurred shortly prior to your request.\n    \n\n## Learn more\n\n*   [User Search Query Syntax](https://auth0.com/docs/manage-users/user-search/user-search-query-syntax)\n*   [Retrieve Users with the Get Users Endpoint](https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint)\n*   [Sort Search Results](https://auth0.com/docs/manage-users/user-search/sort-search-results)",
  "title": "Search for Users",
  "description": "Understand how the Auth0 Management API search endpoints allow you to search for and retrieve user profiles.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations",
  "markdown": "# Auth0 Organizations\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nThe Organizations feature represents a broad update to the Auth0 platform that allows our business-to-business (B2B) customers to better manage their partners and customers, and to customize the ways that end-users access their applications. Auth0 customers can use Organizations to:\n\n*   Represent their business customers and partners in Auth0 and manage their membership.\n    \n*   Configure branded, federated login flows for each business.\n    \n*   Build administration capabilities into their products, using Organizations APIs, so that those businesses can manage their own organizations.",
  "title": "Auth0 Organizations",
  "description": "Describes the Auth0 Organizations feature details.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/ios-swift",
  "markdown": "# Auth0 iOS / macOS SDK Quickstarts: Login\n\nThis guide demonstrates how to integrate Auth0 with any new or existing iOS / macOS app using the Auth0.swift SDK. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Configure Auth0\n\nYou will need a **Native** Auth0 application. If you don’t have a Native Auth0 application already, [create one](https://auth0.com/docs/get-started/auth0-overview/create-applications/native-apps) before continuing. Avoid using other application types, as they have different configurations and may cause errors.\n\n### Configure the callback and logout URLs\n\nThe callback and logout URLs are the URLs that Auth0 invokes to redirect back to your app. Auth0 invokes the callback URL after authenticating the user, and the logout URL after removing the session cookie.\n\nIf the callback and logout URLs are not set, users will be unable to log in and out of the app and will get an error.\n\nGo to the [settings page](https://manage.auth0.com/#/applications/{yourClientId}/settings) of your Auth0 application and add the following URLs to **Allowed Callback URLs** and **Allowed Logout URLs**, depending on the platform of your app. If you have a [custom domain](https://auth0.com/docs/customize/custom-domains), use this instead of the value from the settings page.\n\n#### iOS\n\n```\nhttps://{yourDomain}/ios/YOUR_BUNDLE_IDENTIFIER/callback,\nYOUR_BUNDLE_IDENTIFIER://{yourDomain}/ios/YOUR_BUNDLE_IDENTIFIER/callback\n```\n\n#### macOS\n\n```\nhttps://{yourDomain}/macos/YOUR_BUNDLE_IDENTIFIER/callback,\nYOUR_BUNDLE_IDENTIFIER://{yourDomain}/macos/YOUR_BUNDLE_IDENTIFIER/callback\n```\n\nFor example, if your iOS bundle identifier were `com.example.MyApp` and your Auth0 domain were `example.us.auth0.com`, then this value would be:\n\n```\nhttps://example.us.auth0.com/ios/com.example.MyApp/callback,\ncom.example.MyApp://example.us.auth0.com/ios/com.example.MyApp/callback\n```\n\n### Configure the associated domain\n\n#### Configure the Team ID and bundle identifier\n\nScroll to the end of the settings page of your Auth0 application and open **Advanced Settings > Device Settings**. In the **iOS** section, set **Team ID** to your [Apple Team ID](https://developer.apple.com/help/account/manage-your-team/locate-your-team-id/), and **App ID** to your app's bundle identifier.\n\n![Screenshot of the iOS section inside the Auth0 application settings page](https://auth0.com/docs/media/articles/native-platforms/ios-swift/ios-device-settings.png)\n\nThis will add your app to your Auth0 tenant's `apple-app-site-association` file.\n\n#### Add the associated domain capability\n\nIn Xcode, go to the **Signing and Capabilities** [tab](https://developer.apple.com/documentation/xcode/adding-capabilities-to-your-app#Add-a-capability) of your app's target settings, and press the **\\+ Capability** button. Then select **Associated Domains**.\n\n![Screenshot of the capabilities library inside Xcode](https://auth0.com/docs/media/articles/native-platforms/ios-swift/ios-xcode-capabilities.png)\n\nNext, add the following [entry](https://developer.apple.com/documentation/xcode/configuring-an-associated-domain#Define-a-service-and-its-associated-domain) under **Associated Domains**:\n\n```\nwebcredentials:{yourDomain}\n```\n\nIf you have a [custom domain](https://auth0.com/docs/customize/custom-domains), use this instead of the Auth0 domain from the settings page.\n\n## Install the SDK\n\nAdd the [Auth0.swift](https://github.com/auth0/Auth0.swift) SDK to your project. The library will make requests to the Auth0 Authentication and Management APIs.\n\n### Using the Swift Package Manager\n\nOpen the following menu item in Xcode:\n\n**File > Add Package Dependencies...**\n\nIn the **Search or Enter Package URL** search box enter this URL:\n\n```\nhttps://github.com/auth0/Auth0.swift\n```\n\nThen, select the dependency rule and press **Add Package**..\n\n### Using Cocoapods\n\nAdd the following line to your `Podfile`:\n\nThen, run `pod install`.\n\n### Using Carthage\n\nAdd the following line to your `Cartfile`:\n\n```\ngithub \"auth0/Auth0.swift\" ~> 2.0\n```\n\nThen, run `carthage bootstrap --use-xcframeworks`.\n\n## Configure the SDK\n\nThe Auth0.swift SDK needs the **Client ID** and **domain** of the Auth0 application to communicate with Auth0. You can find these details in the [settings page](https://manage.auth0.com/#/applications/{yourClientId}/settings) of your Auth0 application. If you are using a [custom domain](https://auth0.com/docs/customize/custom-domains), use the value of your custom domain instead of the value from the settings page.\n\n![Screenshot of the Auth0 application settings page](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nCreate a `plist` file named `Auth0.plist` in your app bundle with the following content:\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>ClientId</key>\n    <string>{yourClientId}</string>\n    <key>Domain</key>\n    <string>{yourDomain}</string>\n</dict>\n</plist>\n```\n\n### Checkpoint\n\nNow that you have configured Auth0.swift with the Client ID and domain, run your app to verify that it is not producing any errors related to the SDK.\n\n## Login\n\nImport the `Auth0` module in the file where you want to present the login page.\n\nThen, present the [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) page in the action of your **Login** button.\n\n```\nAuth0\n    .webAuth()\n    .useHTTPS() // Use a Universal Link callback URL on iOS 17.4+ / macOS 14.4+\n    .start { result in\n        switch result {\n        case .success(let credentials):\n            print(\"Obtained credentials: \\(credentials)\")\n        case .failure(let error):\n            print(\"Failed with: \\(error)\")\n        }\n    }\n```\n\n![Screenshot of the Universal Login page](https://auth0.com/docs/media/articles/native-platforms/ios-swift/login-ios.png)\n\n### Checkpoint\n\nVerify that pressing the **Login** button shows an [alert box](https://github.com/auth0/Auth0.swift#sso-alert-box-ios--macos) asking for consent and that choosing **Continue** opens the Universal Login page in a Safari modal. Verify that you can log in or sign up using a username and password or a social provider.\n\nOnce that is complete, verify that the Safari modal closes automatically.\n\n## Logout\n\nNow that you can log in to your app, you need a way to [log out](https://auth0.com/docs/authenticate/login/logout). In the action of your **Logout** button, call the `clearSession()` method to clear the Universal Login session cookie.\n\n```\nAuth0\n    .webAuth()\n    .useHTTPS() // Use a Universal Link logout URL on iOS 17.4+ / macOS 14.4+\n    .clearSession { result in\n        switch result {\n        case .success:\n            print(\"Logged out\")\n        case .failure(let error):\n            print(\"Failed with: \\(error)\")\n        }\n    }\n```\n\n### Checkpoint\n\nVerify that pressing the **Logout** button shows an alert box asking for consent and that choosing **Continue** opens a page in a Safari modal. Verify that the Safari modal closes automatically soon after.\n\n## Access User Profile Information\n\nThe `Credentials` instance you obtained after logging in includes an [ID Token](https://auth0.com/docs/secure/tokens/id-tokens). The ID Token contains the profile information associated with the logged-in user, such as their email and profile picture. You can use these details to personalize the user interface of your app.\n\nThe Auth0.swift SDK includes a [utility](https://github.com/auth0/JWTDecode.swift) for decoding [JWTs](https://jwt.io/) like the ID Token. Start by importing the `JWTDecode` module in the file where you want to access the user profile information.\n\nThen, use the `decode(jwt:)` method to decode the ID Token and access the claims it contains.\n\n```\nguard let jwt = try? decode(jwt: credentials.idToken),\n      let name = jwt[\"name\"].string,\n      let picture = jwt[\"picture\"].string else { return }\nprint(\"Name: \\(name)\")\nprint(\"Picture URL: \\(picture)\")\n```\n\n### Checkpoint\n\nVerify that you can access the `email`, `picture`, or any other [claim](https://auth0.com/docs/secure/tokens/id-tokens/id-token-structure) after you have logged in.\n\n## What's Next?\n\nCheck the SDK documentation to learn how to perform some common tasks, explore more advanced use cases, and discover all the available features:\n\n*   [Next steps](https://github.com/auth0/Auth0.swift#next-steps)\n*   [API documentation](https://auth0.github.io/Auth0.swift/)\n*   [FAQ](https://github.com/auth0/Auth0.swift/blob/master/FAQ.md)",
  "title": "Auth0 iOS / macOS SDK Quickstarts: Login",
  "description": "This guide demonstrates how to integrate Auth0 with any new or existing iOS / macOS app using the Auth0.swift SDK.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/login-pages",
  "markdown": "# Customize Login Pages\n\n[Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) provides the essential feature of an authorization server: the login flow. When a user needs to prove their identity to gain access to your application, you can redirect them to Universal Login and let Auth0 handle the authentication process. \n\nUniversal Login is Auth0's primary hosted login solution. [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience) features easy-to-use customization tools and promotes a simpler, faster experience for end-users. Alternatively, Auth0 also supports [Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience), a hosted login experience that uses JavaScript controls for customization.\n\nFor a comparison between login experiences, review [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login).",
  "title": "Customize Login Pages",
  "description": "Explore topics related to login page customization",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control",
  "markdown": "# Access Control\n\n| **Read...** | **To learn...** |\n| --- | --- |\n| [Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/rbac) | About the concept of role-based access control and how it applies in Auth0. |\n| [Authorization Policies](https://auth0.com/docs/manage-users/access-control/authorization-policies) | About the concept of authorization policies and how they apply in Auth0. |\n| [Rules for Authorization Policies](https://auth0.com/docs/manage-users/access-control/rules-for-authorization-policies) | How rules apply to authorization policies and Auth0's role-based access control (RBAC) system. |\n| [Sample Use Cases: Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/sample-use-cases-role-based-access-control) | How to implement roles-based authorization (RBAC) in different scenarios and explore how to use rules with RBAC. |\n| [Sample Use Cases: Actions with Authorization](https://auth0.com/docs/manage-users/access-control/sample-use-cases-actions-with-authorization) | How to use actions with roles-based access control (RBAC). For use with our Authorization Core feature set. |\n| [Sample Use Cases: Rules with Authorization](https://auth0.com/docs/manage-users/access-control/sample-use-cases-rules-with-authorization) | How to use rules with roles-based access control (RBAC). For use with our Authorization Core feature set. |\n| [Authorization Core vs. Authorization Extension](https://auth0.com/docs/manage-users/access-control/authorization-core-vs-authorization-extension) | About the differences between Auth0's core RBAC release and the Authorization Extension. |\n| [Configure Core RBAC](https://auth0.com/docs/manage-users/access-control/configure-core-rbac) | How to configure Auth0 Core Authorization features for role-based access control (RBAC) of your APIs. |",
  "title": "Access Control",
  "description": "Explore topics related to access control, including role-based access control (RBAC), authorization policies, and the differences between Auth0's core authorization feature and the authorization extension.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email",
  "markdown": "# Customize Emails\n\nYou can configure a test SMTP email server in your development or test environments to check for successful email delivery and view how emails you send appear to recipients prior to going to production. To learn more, read [Configure Test SMTP Email Server](https://auth0.com/docs/customize/email/configure-test-smtp-email-servers).\n\nAuth0's built-in email provider is **not supported for use in a production environment**, should only be used for testing, and has several restrictions:\n\n*   You will not be able to use any of the email customization features. The content of the emails sent for testing will be restricted to the format of the existing templates.\n    \n*   All emails will be sent from a predefined **from address** (`no-reply@auth0user.net`).\n    \n*   You will be restricted to sending no more than 10 emails per minute, regardless of email type.\n    \n*   Your ability to send email from your tenant may be reduced (or even temporarily blocked) if your emails result in high bounce rates.\n    \n\nTo remove these restrictions, you must set up your own email provider. Some options are:\n\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)\n    \n*   [Configure Custom External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider)\n    \n*   [Customize Email Handling](https://auth0.com/docs/customize/email/manage-email-flow)\n    \n\nAfter you have configured your own email service provider, go to [Dashboard > Branding > Email Templates](https://manage.auth0.com/#/emails) to [customize your emails](https://auth0.com/docs/customize/email/email-templates). If you have an Auth0 database connection, there are several email templates you can use as part of the authentication flow:\n\n*   Verification emails (using link or code)\n    \n*   Welcome emails\n    \n*   Enroll in MFA emails\n    \n*   Change password emails\n    \n*   Blocked account emails\n    \n*   Password breach alert emails\n    \n\nYou can restrict user signups to an application with user invitations as a provisioning workflow, either in conjunction with or as an alternative to self-provisioning. To learn more, read [Send Email Invitations for Application Signup](https://auth0.com/docs/customize/email/send-email-invitations-for-application-signup).\n\nA paid subscription plan is required for email customization. To learn more, read [Auth0 Pricing Page](https://auth0.com/pricing).\n\n## Learn more\n\n*   [Customize Email Handling](https://auth0.com/docs/customize/email/manage-email-flow)\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Set Up Database Connections](https://auth0.com/docs/get-started/applications/set-up-database-connections)\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)\n*   [Configure Test SMTP Email Server](https://auth0.com/docs/customize/email/configure-test-smtp-email-servers)\n*   [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails)",
  "title": "Customize Emails",
  "description": "Describes the Auth0 built-in email services.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/cookies",
  "markdown": "# Cookies\n\nCookies are strings of data that a web server sends to the browser. When a browser sends a future request to the web server, it sends the same string to the web server along with its request.\n\nWebsites typically use cookies to ensure that users are recognized when they move between pages, so they don't get asked to log in again every time. Websites also use cookies to remember information users have entered. For example, e-commerce sites use cookies to remember the items placed in a shopping cart.\n\nUsers can choose whether to accept cookies by changing the settings in their browser.\n\n## Cookie-based authentication\n\nTypically, single-page apps (such as React, Vue, and AngularJS + Node), native mobile apps (such as iOS and Android), and web APIs (written in Node, Ruby, ASP.NET, or a mix of those) benefit most from token-based authentication. Traditional, server-side web applications have traditionally used cookie-based authentication.\n\nCookie-based authentication is implemented by each web platform differently, but at the end of the day, they all end up setting some cookie (tied to a session on the server) which represents the authenticated user. On each request, that cookie is sent and the session is deserialized from some store (in memory if it's a single server or some persistent storage if it's a server farm). We provide SDKs for most of the platforms that will tie into the corresponding authentication subsystem (such as passport on node, IPrincipal on .NET or Java, and so on).\n\nWhen you build an application that requires authentication, you can use sessions and cookies to determine if a user is authenticated each time a request is made. To do this, you can choose to use either stateful or stateless cookies.\n\n### Stateful cookies\n\nStateful cookies contain a pointer to a database record that stores the session information.\n\n**Pros**:\n\n*   Have no limitations on amount of session information stored.\n    \n*   Can easily clear a user's session--just remove the record from the database.\n    \n\n**Cons**:\n\n*   Requires a database to store the session data (but most web applications already have this).\n    \n*   Increases latency because you have to make database calls to read the session (and sometimes write it) for each HTTP request a user makes.\n    \n*   Can be challenging to scale when you have many users and therefore many reads/writes to your database.\n    \n\n### Stateless cookies\n\nStateless cookies are self-contained; they include all session information that you need (for authenticated users, the user ID) and reside on the client. To prevent external tampering, stateless cookies should be encrypted (or at least signed).\n\n**Pros**:\n\n*   Can implement easily; doesn’t require a special backend.\n    \n*   Reduces latency because you don't have to call a database.\n    \n*   Easy to scale.\n    \n\n**Cons**:\n\n*   Must restrict stored session information because cookies are limited in size (max 4KB in most browsers). Although session information may be split between multiple cookies, we don't recommend it.\n    \n*   Makes it difficult to revoke a session, because there is no record in a database you can delete; you’ll need to find other methods to forcefully clear a session.\n    \n*   If using multiple web servers, must make sure all servers have the key to encrypt/decrypt or sign the cookie.\n    \n\n## Learn more\n\n*   [Sessions](https://auth0.com/docs/manage-users/sessions)\n*   [Authentication API Cookies](https://auth0.com/docs/manage-users/cookies/authentication-api-cookies)\n*   [SameSite Cookie Attribute Changes](https://auth0.com/docs/manage-users/cookies/samesite-cookie-attribute-changes)\n*   [Secure](https://auth0.com/docs/secure)",
  "title": "Cookies",
  "description": "Describes what cookies are and how they can be used with sessions to track user authentication.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/custom-domains",
  "markdown": "# Custom Domains\n\nIf you have a paid Auth0 subscription, you can use your own domain name (also known as a CNAME or vanity URL) on authentication pages. A custom domain lets you unify the login experience with your own brand and products. Your users see a URL that displays your brand such as `login.YOUR_DOMAIN.com` instead of `YOUR_DOMAIN.auth0.com.` The custom domain in Auth0 is like a \"mask\" for your tenant domain URL.\n\nYou can configure your custom domain when you create your tenant or you can add a custom domain to an existing implementation with minor code and configuration changes.\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Benefits of using a custom domain\n\nWith a custom domain, your users feel confident that they are providing their credentials to the right party. Authentication happens within the context of your brand which helps you build brand loyalty. Users are not redirected to a third-party site that breaks the branding context. This prevents users from becoming confused about whether they are still making a transaction or operation with you.\n\nContaining your authentication services in one place makes your application architecture more maintainable. Applications gain only the access they need and authentication services scale easily. Other security benefits of using a custom domain include:\n\n*   Some browsers, by default, make it difficult to communicate in an iFrame if you don't have a shared domain.\n    \n*   It's harder to phish your domain if you have a vanity URL because the phisher must create a vanity URL to mimic yours. For example, with a custom domain, you can use your own certificate to get an Extended Validation, making phishing harder.\n    \n\n## How it works\n\nYou configure a custom domain on the [Auth0 Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/custom_domains) tab in the Auth0 Dashboard. Add your custom domain, choose your certification type and follow the instructions. You will complete a verification process for your domain that varies depending on whether you use an Auth0-managed or a self-managed certificate. When you create a CNAME, you must declare it to Auth0 so that Auth0 can verify it and use the custom domain. After you configure and verify the custom domain, you must [configure the Auth0 features](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains) to use the new custom domain.\n\nAuth0 recommends that you create your custom domain during the development phase (before you go to production) so that you can ensure that you have managed the CNAME correctly. For example, you can create a CNAME that maps `login.YOUR_DOMAIN.com` to `YOUR_DOMAIN.auth0.com`.\n\nYou can update an existing tenant to use a custom domain. Your existing integrations using `YOUR_DOMAIN.auth0.com` will continue to work. After the change, your users must log in again because existing sessions will no longer be valid. In addition, users may need to delete the browser cookie associated with your custom domain if errors are present during login. If you use embedded Lock or an SDK, you can choose to use the standard domain setting or a custom domain.\n\n### Custom domains and authentication\n\nThe following Auth0 authentication features support the use of custom domains.\n\n| **Feature or Flow** | **Details** |\n| --- | --- |\n| Universal Login | For a seamless and secure user experience |\n| MFA | All factors |\n| Guardian | Android SDK/Swift SDK/MFA Widget version 1.3.3/Guardian.js version 1.3.0 or later |\n| Emails | Links included in the emails use your custom domain |\n| Connections | Database, social, Google Workspace, Azure AD, ADFS, AD/LDAP |\n| Lock | Version 11 with cross-origin authentication |\n| Passwordless | With Universal Login (The email link sent using the custom domain if the option is enabled in **Dashboard > Tenant Settings > Custom Domains**.) |\n| SAML | Connections and applications |\n| WS-Federation | Auth0 as identity provider using WS-Fed add-on |\n| OAuth 2.0/OIDC-Compliant flows | Using the [`/authorize`](https://auth0.com/docs/api/authentication#authorize-application) and [`/oauth/token`](https://auth0.com/docs/api/authentication#get-token) endpoints |\n\n### Custom domains and URIs\n\nAuth0 uses certain metadata endpoints for interoperability and configuration of third-party identity providers and applications. When the metadata contains URIs that point back to Auth0, the URL can be either the Auth0 subdomain or your custom domain depending on the hostname you used to request the metadata. For example:\n\n| **If you use** | **Reference Inside Metadata** |\n| --- | --- |\n| `https://travel0.auth0.com/.well-known/...` | `https://travel0.auth0.com/...` |\n| `https://travel0.auth0.com/samlp/metadata/...` | `https://travel0.auth0.com/...` |\n| `https://login.travel0.com/samlp/metadata/...` | `https://login.travel0.com/...` |\n\nTo learn more, review [Redirect Users After Login](https://auth0.com/docs/authenticate/login/redirect-users-after-login).\n\nThis flexibility applies to the following authentication scenarios:\n\n*   [Configure Applications with OpenID Connect Discovery](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery)\n    \n*   [Configure Auth0 as SAML Service Provider](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider)\n    \n*   [Configure Auth0 as SAML Identity Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider)\n    \n\n### Custom domains and token requests\n\nAuth0 issues tokens with the `iss` claim for the domain you used with the token request. For example:\n\n| **If you use** | **Claim value for iss** |\n| --- | --- |\n| `https://travel0.auth0.com/authorize...`  <br>`https://travel0.auth0.com/oauth/token...` | `https://travel0.auth0.com/` |\n| `https://login.travel0.com/authorize...`  <br>`https://login.travel0.com/oauth/token...` | `https://login.travel0.com/` |\n\nIf you obtain an access token for the Management API using an authorization flow with your custom domain, you must call the Management API using the custom domain or your token will be considered invalid. The token's `iss` claim is independent of the audience. Audience values remain the same for tokens obtained using a custom domain. To learn more about tokens, review [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens).\n\n## Certificate management options\n\n### Auth0-managed certificates\n\nAuth0 can manage the certificates for your custom domain and manage the SSL handshake directly. You add a CNAME record on the domain, Auth0 validates the record and generates the certificate on Auth0 servers. The certificate renews automatically every three months. Once verified, [configure your Auth0 features](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains) to start using your custom domain. To learn more, review [Configure Custom Domains with Auth0-Managed Certificates](https://auth0.com/docs/customize/custom-domains/auth0-managed-certificates).\n\n### Self-managed certificates\n\nYou can obtain and [manage your own certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates) in Custom Domains. In this case, you are responsible for handling SSL certificates and setting up and managing a reverse proxy to send content to Auth0. Auth0 negotiates SSL with the proxy not directly with the end-user client. The proxy, in turn, negotiates SSL with the end-user. To prevent someone from trying to use your Auth0 account from a domain you don't own, Auth0 needs to validate that the domain belongs to you: You need to provide Auth0 with a header (`cname-api-key`) to validate. You must be an Auth0 Enterprise subscriber to use this option.\n\nAuth0 provides instructions to configure a reverse proxy for the following providers:\n\n*   [Google Cloud Platform with Load Balancing](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-gcp-as-reverse-proxy)\n    \n*   [Cloudflare](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-cloudflare-for-use-as-reverse-proxy)\n    \n*   [AWS CloudFront](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-aws-cloudfront-for-use-as-reverse-proxy)\n    \n*   [Azure CDN](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-azure-cdn-for-use-as-reverse-proxy)\n    \n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Configure Custom Domains with Auth0-Managed Certificates](https://auth0.com/docs/customize/custom-domains/auth0-managed-certificates)\n*   [Configure Custom Domains with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [Migrate Private Cloud Custom Domains](https://auth0.com/docs/migrate-private-cloud-custom-domains)",
  "title": "Custom Domains",
  "description": "Understand how a custom domain (CNAME or vanity URL) can help you unify your brand and show continuity to your users.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/sessions",
  "markdown": "# Sessions\n\nA session is a group of interactions between a user and an application during a given timeframe. A single session may consist of multiple activities (such as page views, events, social interactions, and e-commerce transactions) and can store this information temporarily while the user is connected.\n\nWith a standard Set-Cookie header implementation, a session ends when a user leaves a website or closes their browser. To prevent users from having to log in every time, applications can extend sessions by setting a maximum lifetime for the session cookie. Sessions end when a user logs out or a session lifetime limit is reached.\n\nTo learn more, review [Auth0 Privacy and Cookie Policy](https://auth0.com/privacy).\n\n## Session use cases\n\nAuth0 maintains a login session for any user who authenticates through an application. When a user performs a new standard login, Auth0 resets the login session. Updating a password, email, or phone number also causes a user's Auth0 session to expire.\n\nWhen you build an application requiring authentication, you can use sessions to determine whether a user is authenticated each time a request occurs. Depending on how your app has been built, different authorization flows are recommended to support a more secure experience for users.\n\nFor example, consider an OIDC-compliant (OpenID Connect) website called storezero.io.\n\n![Example e-commerce website Storezero.io](https://images.ctfassets.net/cdy7uua7fh8z/5XXxdX4fuApQtAapQfZU1b/2fd9161af60962e3de3fc951d95b83d1/use-case-storezero.png)\n\nStorezero.io does not require its users to log in to complete purchases. However, users must log in to view the My Account section of the site. \n\nFor the use cases listed below, consider a scenario where a user wants to review their previous orders prior to checking out. To do so, they navigate to the All Orders page of the My Account section and are prompted to log in. \n\n### Login flows\n\nMost types of applications (such as web apps, single-page apps, and native apps) should use the [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) to facilitate login authentication. This flow involves exchanging an authorization code for tokens.\n\n#### User logs in with username and password\n\nIn this example, a user manually logs in using their username and password:\n\n1.  Auth0's SDK creates a local session and redirects the user to the Auth0 authorization server (`/authorize` endpoint).\n    \n2.  The authorization server creates a session, then redirects the user to the login and authorization prompt.\n    \n3.  The user authenticates using their username and password.\n    \n4.  The Auth0 authorization server updates the user’s previously-created session to indicate they are logged in.\n    \n5.  Depending on the flow used, the authorization server returns the user to your application, along with either an ID token or an authorization code.\n    \n6.  Your application exchanges the token or authorization code for an access token and completes the flow.\n    \n\nWith this flow, two sessions are created:\n\n*   The **local session** (storezero.io), which indicates to the application whether a user is authenticated.\n    \n*   The **authorization server session** (storezero.auth0.com), which indicates to the server whether a user is authenticated. The server session can also optionally track details about the authentication.\n    \n    *   For example, the authorization server can track if a user leveraged [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication). This information can then be used to determine whether a user should be prompted to log in or use MFA the next time they arrive at the authorization server.\n        \n\n#### User logs in with identity provider\n\nIn this example, the user opts to log in with Facebook instead of their username and password: \n\n1.  Auth0's SDK creates a local session and redirects the user to the Auth0 authorization server (`/authorize` endpoint).\n    \n2.  The authorization server creates a session, then redirects the user to the login and authorization prompt. \n    \n3.  Upon choosing to log in with Facebook, the authorization server redirects the user to Facebook. \n    \n4.  Facebook creates a session and authenticates the user. Facebook then updates its session to indicate the user is logged in. \n    \n5.  Facebook returns the user to the Auth0 authorization server. The authorization server then updates its session to indicate the user is logged in.\n    \n6.  Depending on the flow used, the authorization server returns the user to your application, along with either an ID token or an authorization code.\n    \n7.  Your application exchanges the token or authorization code for an access token and completes the flow.\n    \n\nIn this scenario, three sessions are created: the **local session** (storezero.io), the **authorization server session** (storezero.auth0.com), and an **identity provider (IdP) session** (facebook.com).\n\nThe IdP session on Facebook's server authenticates the user and provides a seamless SSO experience. As there is a high probability that users are already logged in to Facebook, users are often authenticated without having to manually provide their Facebook credentials.\n\n### Session management for SPAs\n\nIn the previous examples, a local session is created when the user initiates either login flow. This local session can keep users logged in and determine when they need to reauthenticate.\n\nHowever, local sessions are not available for applications without backends, such as single-page apps (SPAs). Instead, these applications use a different approach known as [silent authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication) to keep users logged in.\n\nSilent authentication uses the session on the authorization server to determine when a user must reauthenticate. A hidden iframe redirects authentication requests to the authorization server along with the `prompt=none` parameter. This parameter prevents the server from prompting the user for input.\n\n*   If the session on the authorization server has not expired, the transaction continues seamlessly. The server sends an access token through WMRM (Web Message Response Mode), which leverages `postMessage`. \n    \n*   If the session on the authorization has expired or the user logs out, the redirect in the iframe returns an error. The application must then direct the user to the authorization server for reauthentication.\n    \n\n## Learn more\n\n*   [Session Layers](https://auth0.com/docs/manage-users/sessions/session-layers)\n*   [Session Lifetime Limits](https://auth0.com/docs/manage-users/sessions/session-lifetime-limits)\n*   [Configure Session Lifetime Settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings)\n*   [Cookies](https://auth0.com/docs/manage-users/cookies)\n*   [SameSite Cookie Attribute Changes](https://auth0.com/docs/manage-users/cookies/samesite-cookie-attribute-changes)\n*   [Authenticate Single-Page Apps With Cookies](https://auth0.com/docs/manage-users/cookies/spa-authenticate-with-cookies)",
  "title": "Sessions",
  "description": "Describes what sessions are and how the are used in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions",
  "markdown": "# Auth0 Actions\n\nActions are secure, tenant-specific, versioned functions written in Node.js that execute at certain points within the Auth0 platform. Actions are used to customize and extend Auth0's capabilities with custom logic.",
  "title": "Auth0 Actions",
  "description": "Describes Auth0 Actions, which are secure, tenant-specific, self-contained functions that allow you to customize the behavior of Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/phone-messages",
  "markdown": "# Customize Phone Messages\n\nAuth0’s default phone message flow addresses the requirements of most applications. You may want to customize your phone message flow, such as in the following use cases:\n\n*   Localize your phone messages to meet the needs of different target markets.\n    \n*   Set a custom sending phone number based on the user or tenant.\n    \n*   Enable different phone message templates per application or tenant.\n    \n\nThe [Auth0 Management API](https://auth0.com/docs/api/management/v2) provides endpoints to help you manage your phone message flow to control when and how phone messages are sent. You can also implement and manage your own custom phone endpoints using the Auth0 Management API.\n\n## Learn more\n\n*   [Configure Phone Messaging Providers](https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers)\n*   [Customize Phone Templates](https://auth0.com/docs/customize/phone-messages/customize-phone-templates)",
  "title": "Customize Phone Messages",
  "description": "Learn how to customize your phone message flow in the Auth0 Dashboard. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/customize-sms-or-voice-messages",
  "markdown": "# Customize Multi-factor Authentication SMS and Voice Messages\n\nYou can customize SMS and voice messages sent by Auth0 during enrollment (when associating a device to Guardian) and verification (when an authentication message is sent to the device):\n\n1.  Go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa), and click **Phone Message**.\n    \n2.  Customize your message templates, and click **Save**.\n    \n\n![Dashboard - Security - Multifactor Auth - Phone Message - Templates](https://images.ctfassets.net/cdy7uua7fh8z/J6KTz7YTKeswbUjJa1YIs/ac89bdd4f58fb5bb7d25eb17fd94908b/dashboard-mfa_factor_phone-message.png)\n\nYou can customize templates for two message types:\n\n*   **Enrollment**: Message sent by Auth0 during device enrollment.\n    \n*   **Verification**: Message sent by Auth0 to verify the possession of the device.\n    \n\n## Syntax\n\n[Liquid](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers) syntax is the supported templating engine you use when accessing user attributes in SMS templates. The following attributes are available:\n\n| Attribute | Description |\n| --- | --- |\n| `message_type` | Indicates which kind of message is sent; `sms` or `voice`. |\n| `code` | Enrollment/verification code. When sending voice messages. Variable values are separated by dots between the digits (`1.2.3.4.5`) so it can be pronounced accurately by voice messaging providers. |\n| `locale` | For Universal Login or MFA API. Designates the language. |\n| `requestInfo.lang` | For Classic Login localization. Browser accept-language header. For example: `es-AR,es;q=8.0`, `en-US,en`. |\n| `tenant.friendlyName` | The **Friendly Name** set in **Dashboard > Tenant Settings**. |\n\n## Example\n\n```\n{% if message_type == \"voice\" %}\n  {% if locale contains \"fr\" %}\n  Bonjour, vous avez demandé à recevoir un code de vérification pour vous enregister avec {{tenant.friendly_name}}. Votre code est: {{pause}} {{code}}. Je répète, votre code est: {{pause}}{{code}}.\n  {% elsif locale contains \"es\" %}\n  Usted ha requerido un código de verificación para inscribirse con {{tenant.friendly_name}}. Su código es: {{pause}}{{code}}. Repito, su código es: {{pause}}{{code}}.\n  {% else %}\n  Hello, you requested a verification code to enroll with {{tenant.friendly_name}}. Your code is: {{pause}}{{code}}. I repeat, your code is: {{pause}}{{code}}.\n  {% endif %}\n{% else %}\n  {% if locale contains \"fr\" %}\n  {{code}} est votre code de vérification pour vous enregistrer avec {{tenant.friendly_name}}.\n  {% elsif locale contains \"es\" %}\n  {{code}} es su código para inscribirse con {{tenant.friendly_name}}.\n  {% else %}\n  {{code}} is your verification code to enroll with {{tenant.friendly_name}}.\n  {% endif %}\n{% endif %}\n```\n\n## Localization\n\nThe endpoints support the `x-request-language` header and you can use it to send the locale. See [](https://auth0.com/docs/connections/passwordless/guides/sms-otp#multi-language-support)[Multi-Language Support](https://auth0.com/docs/connections/passwordless/guides/sms-otp#multi-language-support) for details.\n\nThis is also supported in the MFA API (`POST /mfa/associate` and `POST /mfa/challenge` endpoints). When it's sent, that locale will be available in the `locale` variable in the MFA SMS/voice template.\n\nYou must also select those languages in **Tenant > Settings** (under **Supported Languages**) for this to work.\n\n## Learn more\n\n*   [Multi-Factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication)\n*   [Configure SMS and Voice Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)",
  "title": "Customize Multi-factor Authentication SMS and Voice Messages",
  "description": "Learn how to customize SMS and voice messages sent by Auth0 during enrollment and verification.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/internationalization-and-localization",
  "markdown": "# Internationalization and Localization\n\nWas this article helpful?",
  "title": "Internationalization and Localization",
  "description": "Learn how to internationalize and localize emails, login prompts, and Lock password options. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/forms",
  "markdown": "# Forms for Actions\n\nForms for Actions is a visual editor that allows you to create customizable forms that can extend your identity flows with additional steps and business logic.\n\n![Dashboard > Actions > Forms](https://images.ctfassets.net/cdy7uua7fh8z/3QLVE6XsMRwhL17SUSMw8H/c679b99a8930d463a30352e1d11ee755/2024-05-09_14-20-42.png)\n\nSome of the key capabilities of Form for Actions include:\n\n*   Controlled and secure experience within your tenant's domain. Not required to [redirect](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions) users to external sites.\n    \n*   Pre-built components with frontend and backend validations.\n    \n*   Custom business logic with out-of-the-box integrations with third parties.\n    \n*   Consistent branding experience with Universal Login.\n    \n\nUsing Forms for Actions enables you to build use cases like:\n\n*   **Progressive profiling:** Defines a set of conditions to require users to complete additional information as they engage with your product. For example, when third-time users log in, you can require them to complete their profile.\n    \n*   **Custom policies acceptance:** If you need to update your policies, you can define logic to check if users have accepted the latest policies, and depending on that, display a custom form to users requiring acceptance.\n    \n*   **Custom signup or login steps:** Extend and customize your flows with additional steps and custom logic. For example, you can verify email or phone numbers with OTP and account linking, or verify payment details with Stripe, and more.",
  "title": "Forms for Actions",
  "description": "Forms for Actions is a visual editor that allows you to create customizable forms that can be used to extend your identity flows with additional steps and business logic.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/rules",
  "markdown": "# Auth0 Rules\n\nRules can be used in a variety of situations as part of the authentication pipeline where protocol-specific artifacts are generated:\n\n*   an ID token in OpenID Connect (OIDC)\n    \n*   an access token in OAuth 2.0\n    \n*   an assertion in SAML\n    \n\nA new pipeline in which rules execute is created for each authentication request.",
  "title": "Auth0 Rules",
  "description": "Learn about Rules and how you can use them to customize and extend Auth0's capabilities.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/hooks",
  "markdown": "# Auth0 Hooks\n\nHooks are secure, self-contained functions that allow you to customize the behavior of Auth0 when executed for selected extensibility points of the Auth0 platform. Auth0 invokes hooks during runtime to execute your custom Node.js code.\n\nWhether hooks can be used with connections varies according to extensibility point. Hooks that can be used with connections only work with database and passwordless connections. To learn more, read [Database Connections](https://auth0.com/docs/connections/database) and [Passwordless Connections](https://auth0.com/docs/connections/passwordless).\n\n| **Read...** | **To learn...** |\n| --- | --- |\n| [Create Hooks](https://auth0.com/docs/hooks/create-hooks) | How to create hooks using the Dashboard or the Management API. |\n| [Update Hooks](https://auth0.com/docs/hooks/update-hooks) | How to update hooks using the Dashboard or the Management API. |\n| [Delete Hooks](https://auth0.com/docs/hooks/delete-hooks) | How to delete hooks using the Dashboard or the Management API. |\n| [Enable/Disable Hooks](https://auth0.com/docs/hooks/enable-disable-hooks) | How to enable and disable hooks using the Dashboard and Management API. |\n| [View Hooks](https://auth0.com/docs/hooks/view-hooks) | How to view hooks using the Dashboard and Management API. |\n| [View Logs for Hooks](https://auth0.com/docs/hooks/view-logs-for-hooks) | How to view real-time log events for specific configured hooks. |\n| [Extensibility Points](https://auth0.com/docs/hooks/extensibility-points) | About Auth0 extensibility points where hooks can be executed. |\n| [Hook Secrets](https://auth0.com/docs/hooks/hook-secrets) | About how hooks store secrets and how to manage them. |",
  "title": "Auth0 Hooks",
  "description": "Describes Auth0 hooks, some of which may be used with database and passwordless connections.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions",
  "markdown": "# Auth0 Extensions\n\nAuth0 Extensions enable you to install applications or run commands/scripts that extend the functionality of the Auth0 base product. Each extension is separate from all other extensions. Auth0 defines extensions per tenant, so data is stored by the pair `tenant\\extension`.",
  "title": "Auth0 Extensions",
  "description": "Describes Auth0 extensions that enable you to install applications or run commands and scripts that extend the functionality of Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/integrations",
  "markdown": "# Auth0 Integrations\n\nReduce implementation time with Auth0-reviewed integrations that you can trust. The Auth0 platform is inherently extensible, allowing you to meet your specific needs by tailoring identity flows with custom code and integrating with third-party applications and tools.\n\nGo to [Auth0 Marketplace](https://marketplace.auth0.com/) to find and enable third-party identity solutions that integrate with our products.",
  "title": "Auth0 Integrations",
  "description": "Describes Auth0 integrations with third-party applications and services.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/pre-deployment-checks",
  "markdown": "# Pre-Deployment Checks\n\nBefore you go live, run Auth0's production checks suite to ensure that your tenants are ready for use in a production environment.\n\n| **Read** | **To learn...** |\n| --- | --- |\n| [Production Checks](https://auth0.com/docs/deploy/pre-deployment/how-to-run-production-checks) | How to run the production checks against one or more applications to see if they're production-ready or not. View your results to see any outstanding required and recommended tasks, as well as changes you can make to ensure that you comply with best practices. |\n| [Pre-Deployment Tests](https://auth0.com/docs/deploy/pre-deployment/predeployment-tests) | How to run unit and integration tests before deploying Auth0. |\n| [Pre-Launch Tips](https://auth0.com/docs/deploy/pre-deployment/pre-launch-tips) | About tips we have collected from our customers when first getting started with Auth0. |",
  "title": "Pre-Deployment Checks",
  "description": "A reference of helpful pre-deployment checks for your production Auth0 environment.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-checklist",
  "markdown": "# Deployment Checklist\n\nAuth0 has provided the following deployment checklist for your use. You may not find that every item is applicable, so please modify the checklist based on the needs of your implementation.\n\n## How to use the checklist\n\n1.  Click the link below to download the checklist.\n    \n2.  Open the checklist in any spreadsheet application.\n    \n3.  Customize the checklist to suit your needs.\n    \n\n![Excel Icon](https://images.ctfassets.net/cdy7uua7fh8z/2Cip8jFt1IhR24t5Q4V4KZ/749eb4107b1b8ad60dbabf4066fea151/file_type_icons-02.png)[Deploy Checklist](https://assets.ctfassets.net/cdy7uua7fh8z/78b5P011cQmYyZ7XZkQcoK/3c42c9146f9823b427bcd06b2889fa7c/Deploy-Checklist.xlsx)\n\nIn the Deploy phase, you will deploy the system to either a staging or production environment, where actual users begin to operate and interact with it.\n\nEventually, you deploy all components of the system to the production environment when you make a live release.\n\n## Learn more\n\n*   [Pre-Deployment Checks](https://auth0.com/docs/deploy-monitor/pre-deployment-checks)\n*   [Run Pre-Deployment Tests](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/predeployment-tests)\n*   [Pre-Launch Tips](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/pre-launch-tips)",
  "title": "Deployment Checklist",
  "description": "Deployment checklists for your implementation",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deployment-options",
  "markdown": "# Deployment Options\n\nAuth0 provides both public cloud and private cloud deployment options and tools to help you with your deployment.\n\nThe Auth0 identity platform can be deployed in the following ways:\n\n| **Option** | **Description** |\n| --- | --- |\n| **Public Cloud** | A multi-tenant cloud service running on Auth0's cloud with standard authentication, personalization, user management, and security features |\n| [**Private Cloud on AWS**](https://auth0.com/docs/deploy/private-cloud) | A dedicated, managed cloud service running on AWS providing isolation, higher performance, dev instances, Geo-HA add-ons and more |\n| [**Private Cloud on Azure**](https://auth0.com/docs/deploy/private-cloud-on-azure) | A dedicated cloud service running on Azure providing isolation, higher performance, dev instances, add-ons and more |\n\nThe **Private Cloud** packages are managed services that you can use if you:\n\n*   Cannot use a multi-tenant public cloud service in your organization\n    \n\n*   Require a guaranteed level of requests per second (RPS)\n    \n\nIf you have specific support requirements or need more information about the Professional Services we offer, please [contact Auth0 Sales](https://auth0.com/contact-us).",
  "title": "Deployment Options",
  "description": "Describes Auth0 public and private cloud deployment options.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/log-streams",
  "markdown": "# Log Streams\n\nAuth0's log streaming service allows you to export tenant log events to a log event analysis service URL. You can choose the content type and form and preview the payload using the Auth0 Dashboard. Log streaming allows you to react to events like password changes or new registrations with your own business logic. Using the Auth0 Dashboard, you can pause a stream, view and update settings, and check the health of the stream.\n\nYou can create a new log stream in the Auth0 Dashboard using one of the services we support or you can configure a stream to a service you already use with a custom webhook.\n\n![Dashboard Monitoring Streams](https://images.ctfassets.net/cdy7uua7fh8z/5ZY6sT68DabXNL9Dr4bhss/d14c4c42ff62634b1bd514e8b08aeda4/Log-Streaming2.png)\n\n## Supported log streaming services\n\nWe support a variety of [log streaming services](https://marketplace.auth0.com/features/log-streaming) through the [Auth0 Marketplace](https://marketplace.auth0.com/), including:\n\n*   [Amazon EventBridge](https://marketplace.auth0.com/integrations/amazon-log-streaming)\n    \n*   [Azure Event Grid](https://marketplace.auth0.com/integrations/azure-log-streaming)\n    \n*   [Elastic](https://marketplace.auth0.com/integrations/elastic-security)\n    \n*   [Logz.io](https://marketplace.auth0.com/integrations/logz-io)\n    \n*   [MDR ONE](https://marketplace.auth0.com/integrations/mdr-one)\n    \n*   [Mixpanel](https://marketplace.auth0.com/integrations/mixpanel-log-streaming)\n    \n*   [Oort](https://marketplace.auth0.com/integrations/oort)\n    \n*   [Pangea](https://marketplace.auth0.com/integrations/pangea-log-streaming)\n    \n*   [Panther](https://marketplace.auth0.com/integrations/panther-log-stream)\n    \n*   [Perch Security](https://marketplace.auth0.com/integrations/perch-security-log-streaming)\n    \n*   [Segment](https://marketplace.auth0.com/integrations/segment-log-streaming)\n    \n*   [Slack](https://marketplace.auth0.com/integrations/slack-log-streaming)\n    \n*   [Verosint](https://marketplace.auth0.com/integrations/verosint-log-stream)\n    \n*   [Datadog](https://marketplace.auth0.com/integrations/datadog-log-streaming) (Auth0 also provides Datadog dashboard templates you can use. To learn more, read [Use Auth0 Dashboard Templates with Datadog](https://auth0.com/docs/customize/log-streams/datadog-dashboard-templates).\n    \n*   [Splunk](https://marketplace.auth0.com/integrations/splunk-log-streaming) (Auth0 also provides a dashboard that you can use to visualize the data from your Auth0 tenant. The app allows you to use recommended aggregations from Auth0, or to use them as a starting point to create your own custom visualizations. To learn more, read [Use Auth0 App for Splunk](https://auth0.com/docs/customize/log-streams/splunk-dashboard).)\n    \n*   [Sumo Logic](https://marketplace.auth0.com/integrations/sumo-logic-log-streaming) (Auth0 provides an Auth0 App for Sumo Logic which creates a dashboard that you can use to visualize the data from your Auth0 tenant. The dashboard allows you to monitor the health of the login traffic for a tenant. The app allows you to use recommended aggregations from Auth0, or to use them as a starting point to create your own custom visualizations. To learn more, read [Use Auth0 App for Sumo Logic](https://auth0.com/docs/customize/log-streams/sumo-logic-dashboard).)\n    \n\n## Delivery attempts and log retention\n\nAuth0 uses a streaming mechanism that delivers each event to your server as it is triggered in our system. We guarantee events are delivered at least once.\n\nWhen an event is triggered:\n\n1.  We attempt to deliver the event to your server up to three times.\n    \n2.  If we fail to reach your server by the third attempt, we log an error visible in the **Health** view for the log stream.\n    \n3.  We restart this process for any errored events until the problem is resolved.\n    \n\nIf we fail to reach your server for 7 consecutive days, we'll automatically pause the stream. You'll need to resolve the issue, and then resume the stream manually.\n\nAuth0 retains events for 30 days. If there is an issue where your server does not receive log events sent from Auth0, you can set the **Starting Cursor** field to restart the stream from a specific day and time within the 30-day retention period.\n\n## Learn more\n\n*   [Create Custom Log Streams Using Webhooks](https://auth0.com/docs/customize/log-streams/custom-log-streams)\n*   [Check Log Stream Health](https://auth0.com/docs/customize/log-streams/check-log-stream-health)\n*   [Log Stream Filters](https://auth0.com/docs/customize/log-streams/event-filters)",
  "title": "Log Streams",
  "description": "Describes how to export your log events in near real-time using log streaming.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-private-cloud",
  "markdown": "# Deploy Private Cloud\n\n**Private Cloud** packages are managed services that you can use if you:\n\n*   Cannot use a multi-tenant public cloud service in your organization\n    \n\n*   Require a guaranteed level of requests per second (RPS)\n    \n\nThe Auth0 private cloud can be deployed in the following ways:\n\n| **Option** | **Description** |\n| --- | --- |\n| [**Private Cloud on AWS**](https://auth0.com/docs/deploy/private-cloud) | A dedicated, managed cloud service running on AWS providing isolation, higher performance, dev instances, Geo-HA add-ons and more |\n| [**Private Cloud on Azure**](https://auth0.com/docs/deploy-monitor/deploy-private-cloud/private-cloud-on-azure) | A dedicated cloud service running on Azure providing isolation, higher performance, dev instances, add-ons and more |\n\nWe also provide [add-on features](https://auth0.com/docs/deploy-monitor/deploy-private-cloud/private-cloud-add-on-features) that can complement your Auth0 Private Cloud deployment.\n\nIf you have specific support requirements or need more information about the Professional Services we offer, please [contact Auth0 Sales](https://auth0.com/contact-us).",
  "title": "Deploy Private Cloud",
  "description": "Describes Auth0 private cloud deployment options.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deploy-cli-tool",
  "markdown": "# Deploy CLI Tool\n\nThe Auth0 Deploy CLI is a tool that helps you manage your Auth0 tenant configuration. It integrates into your development workflows as a standalone CLI or as a node module.\n\nSupported resource types: `actions`, `branding`, `client grants`, `clients (applications)`, `connections`, `custom domains`, `email templates`, `emails`, `grants`, `guardian`, `hook secrets`, `log streams`, `migrations`, `organizations`, `pages`, `prompts`, `resource servers (APIs)`, `roles`, `tenant settings`, `themes`.\n\n## Highlights\n\n*   **Multi-Environment Oriented:** Designed to help you test your applications' Auth0 integrations from feature branch all the way to production.\n    \n*   **Keyword Replacement:** Shared resource configurations across all environments with dynamic keyword replacement.\n    \n*   **Versatile:** Integrate into your CI/CD workflows either as a CLI or as a Node module.\n    \n\n## Get started\n\nThis guide will help you to a working implementation of the Deploy CLI tool used as a standalone CLI. There are three main steps before the Deploy CLI can be run:\n\n1.  [Create a dedicated Auth0 Application](#create-a-dedicated-auth0-application)\n    \n2.  [Configure the Deploy CLI](#configure-the-deploy-cli)\n    \n3.  [Call the Deploy CLI](#call-the-deploy-cli)\n    \n\n### Install the Deploy CLI\n\nTo run as a standalone command-line tool:\n\n`npm install -g auth0-deploy-cli`\n\n### Create a dedicated Auth0 application\n\nIn order for the Deploy CLI to call the Management API, a dedicated Auth0 application must be created to make calls on behalf of the tool:\n\n1.  Go to **Auth0 Dashboard > Applications > Applications**.\n    \n2.  Select **\\+ Create Application**.\n    \n    1.  Give it a descriptive name (such as “Deploy CLI”).\n        \n    2.  Select **Machine to Machine Applications** for the **Application Type**.\n        \n    3.  Select **Create**.\n        \n3.  Switch to the **Authorize Machine to Machine Application** view:\n    \n    1.  Select **Auth0 Management API**.\n        \n    2.  Select the appropriate permissions for the resources you wish to manage. Refer to the [Client Scopes](#client-scopes) section for more information.\n        \n    3.  Select **Authorize**.\n        \n\n#### Client scopes\n\nThe designated application needs to be granted scopes in order to allow the Deploy CLI to execute Management operations.\n\nThe principle of least privilege is abided, so it will operate within the set of permissions granted. , you'll need to select `read:clients`, but it’s recommended to select `read:*`, `create:*`, and `update:*` permissions for all resource types within management purview. To enable deletions, you `delete:*` scopes.\n\n### Configure the Deploy CLI\n\nYou can configure the Deploy CLI in two ways:\n\n1.  Use the configuration file (`config.json`).\n    \n2.  Set environment variables.\n    \n\nThe decision to choose one or both would depend on your specific use case and preferences. To learn more, read [Configure the Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/configure-the-deploy-cli).\n\nFor this example, set the following environment variables:\n\n*   `AUTH0_DOMAIN`\n    \n*   `AUTH0_CLIENT_ID`\n    \n*   `AUTH0_CLIENT_SECRET`\n    \n\nThese values can be found in the **Settings** tab for the dedicated Auth0 application you created previously.\n\n### Call the Deploy CLI\n\nThe Deploy CLI `export` command can be run with the following command:\n\n`a0deploy export --format=yaml --output_folder=local`\n\nOnce the process completes, observe the resource configuration files generated in the local directory. Then, run the `import` command to push the configuration from your local machine to your Auth0 tenant:\n\n`a0deploy import --config_file=config.json --input_file local/tenant.yaml`\n\nFor a comprehensive list of flags and options, please read [Use as CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool/use-as-a-cli).",
  "title": "Deploy CLI Tool",
  "description": "Learn about the Auth0 Deploy CLI Tool and how it works.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/deployment-best-practices",
  "markdown": "# Deployment Best Practices\n\n## Use automated deployment for rules\n\nCoding a rule within the Auth0 Dashboard rule editor is a great way to implement and test while still in the development stage. However, when it comes time to deploy into automated test or production environments, a more automated mechanism is required; copying and pasting code between Auth0 tenants is not a satisfactory method to employ.\n\n### Set up version control extensions\n\nChanges made to a rule deployed to an Auth0 tenant will be made live immediately because changes instantly overwrite what is already there. We recommended that you use version control such as Git via GitHub or the like, is employed to provide change management capability.\n\nAuth0 provides automated deployment methods for rules between Auth0 tenant environments. The following Auth0 integrations allow you to update rules from the version control system—both manually and automatically (for example, when a change in the version control system is detected): [GitHub Actions](https://marketplace.auth0.com/integrations/github-actions), [GitLab Pipelines](https://marketplace.auth0.com/integrations/gitlab-pipeline), [Bitbucket Pipelines](https://marketplace.auth0.com/integrations/bitbucket-pipeline), and [Microsoft Azure Pipelines](https://marketplace.auth0.com/integrations/azure-pipeline).\n\n### Use Deploy CLI tool for rule import and export\n\nThe Auth0 Deploy CLI tool can be used to automate deployment between Auth0 tenants. Deploy CLI works with files stored in the file system together with the Auth0 Management API and provides the capability to allow the export of rule assets from an Auth0 tenant, as well as import of them into an Auth0 tenant. Further, the tool provides for programmatic control over rule ordering and rule environment configuration as part of deployment automation. To learn more, read [Deploy CLI Tool](https://auth0.com/docs/deploy-monitor/deploy-cli-tool).\n\nAs a best practice, you should use the Auth Deploy CLI tool in almost all cases involving deployment to test or production environments, such as with the following integrations: [GitLab Pipelines](https://marketplace.auth0.com/integrations/gitlab-pipeline), [GitHub Actions](https://marketplace.auth0.com/integrations/github-actions), [Bitbucket Pipelines](https://marketplace.auth0.com/integrations/bitbucket-pipeline), and [Microsoft Azure Pipelines](https://marketplace.auth0.com/integrations/azure-pipeline). While the integrations can provide automated detection of changes deployed to the respective version control system, the Deploy CLI tool allows precise control of what’s deployed when, where, and how. To learn more about best practices, read [Rules Best Practices](https://auth0.com/docs/rules-best-practices).\n\n## Set up test tenants\n\nWe recommend that you set up a separate test tenant in Auth0 to provide safe testing of any rules before deploying to production. To learn more, read [Set Up Multiple Environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments).\n\n## Learn more\n\n*   [Rules Best Practices](https://auth0.com/docs/rules-best-practices)",
  "title": "Deployment Best Practices",
  "description": "Learn about best practices for deployment.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/auth0-terraform-provider",
  "markdown": "# Auth0 Terraform Provider\n\nThe Deploy CLI is not the only tool available for managing your Auth0 tenant configuration, there is also an [officially supported Terraform Provider](https://github.com/auth0/terraform-provider-auth0). [Terraform](https://terraform.io/) is a third-party tool for representing your cloud resources’ configurations as code. It has an established plug-in framework that supports a wide array of cloud providers, including Auth0.\n\nBoth the Deploy CLI and Terraform Provider exist to help you manage your Auth0 tenant configurations, but each has their own set of pros and cons.\n\nYou may want to consider the Auth0 Terraform Provider if:\n\n*   Your development workflows already leverages Terraform\n    \n*   Your tenant management needs are granular or only pertain to a few specific resources\n    \n\nYou may not want to consider the Auth0 Terraform Provider if:\n\n*   Your development workflow does not use Terraform, requiring extra setup upfront\n    \n*   Your development workflows are primarily concerned with managing your tenants in bulk\n    \n*   Your tenant has lots of existing resources, may require significant effort to “import\"",
  "title": "Auth0 Terraform Provider",
  "description": "Learn about the Auth0 Terraform Provider for representing your tenant configurations as code.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support",
  "markdown": "# Customer Support\n\n| **Read...** | **To learn...** |\n| --- | --- |\n| [Support Plans](https://auth0.com/docs/support/support-plans) | About different levels of Auth0 support. |\n| [Self Service Support](https://auth0.com/docs/troubleshoot/customer-support/self-service-support) | Tools for customers to troubleshoot their issues. |\n| [Support Channels](https://auth0.com/docs/troubleshoot/customer-support/support-channels) | The different ways to contact Auth0 support. |\n| [Support Procedures](https://auth0.com/docs/troubleshoot/customer-support/support-procedures) | About defect resolution and unsupported requests. |\n| [Support Hours and Languages](https://auth0.com/docs/troubleshoot/customer-support/support-hours-and-languages) | When and in what languages you can get support. |\n| [Whitehat Security Support Tickets](https://auth0.com/docs/support/whitehat-security-support-tickets) | How to report a security issue. |\n| [Product Support Matrix](https://auth0.com/docs/support/product-support-matrix) | About support coverage for browsers, operating systems, and Auth0 libraries and SDKs. |\n| [Service Levels](https://auth0.com/docs/support/services-level-descriptions) | About Auth0 service levels and service level agreements (SLAs) for public and private cloud deployments. |\n| [Open and Manage Support Tickets](https://auth0.com/docs/support/open-and-manage-support-tickets) | How to open and manage Auth0 support tickets. |\n| [Manage Subscriptions](https://auth0.com/docs/support/manage-subscriptions) | How to manage your Auth0 subscription. |\n| [Reset Account Passwords](https://auth0.com/docs/support/reset-account-passwords) | How to change your password to your Auth0 account. |\n| [Software Updates](https://auth0.com/docs/troubleshoot/customer-support/software-updates) | How your version of Auth0 updates. |\n| [Auth0 Versioning Strategy](https://auth0.com/docs/support/versioning-strategy) | About Auth0's software versioning scheme. |\n| [Operational Policies](https://auth0.com/docs/support/policies) | About Auth0 operational policies including billing, data export and transfer, API endpoints, load and penetration testing, migrations, rate limits and much more. |\n| [Changelog](https://auth0.com/changelog) | About the latest updates and additions to the Auth0 platform. |",
  "title": "Customer Support",
  "description": "Describes the different types of support options provided by Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/monitor",
  "markdown": "# Monitor Auth0\n\nYou can monitor your Auth0 implementation and Auth0 status and services, as well as your tenant log event data.\n\nFollow [@auth0status](https://twitter.com/auth0status) on X to get the latest status updates and monitor your Auth0 implementation to check the status and availability of external services and applications. \n\n| **Read...** | **To learn...** |\n| --- | --- |\n| [Check Auth0 Status](https://auth0.com/docs/monitor-auth0/check-auth0-status) | How to check Auth0 service availability for locale and region and subscribe for service updates. |\n| [Check External Services Status](https://auth0.com/docs/monitor-auth0/check-external-services-status) | How to monitor external identity provider services. |\n| [Monitor Applications](https://auth0.com/docs/monitor-auth0/monitor-applications) | How to monitor your application health to report potential impact to your users. |\n| [Monitor Auth0 Using System Center Operations Manager](https://auth0.com/docs/monitor-auth0/monitor-using-scom) | How to monitor Auth0 using System Center Operations Manager (SCOM) or any tool that supports synthetic transactions. |\n| [Logs](https://auth0.com/docs/monitor-auth0/logs) | About Auth0 tenant event logs that you can analyze for your business needs. |\n| [Log Streams](https://auth0.com/docs/monitor-auth0/streams) | How to create tenant log event streams to external services such as AWS EventBridge, Azure Event Grid, Datadog and more. |",
  "title": "Monitor Auth0",
  "description": "Describes how to monitor and track your Auth0 usage, as well as how to send tenant logs to external tools.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/logs",
  "markdown": "# Logs\n\nAuth0 provides event logs that you can analyze for your business needs. You can:\n\n*   View actions performed by tenant administrators.\n    \n*   View operations performed via the Management API.\n    \n*   View authentications made by your users.\n    \n*   View intermittent errors that may be hard to find with quality assurance testing.\n    \n*   Capture forensic data for security purposes and to identify anomaly detection triggers.\n    \n*   Identify patterns in usage trends.\n    \n*   Check for authentication errors and Management API call errors.\n    \n*   Set up automatic log scanning to check for rate limit errors so that you can proactively address activity that hits rate limits before it impacts your users.\n    \n*   Correlate management API events to their initiating requests by matching `X-Correlation-ID` header values.\n    \n\n## View and retrieve logs\n\nView log events in the Auth0 Dashboard and retrieve logs using the Management API. To learn more, read:\n\n*   [View Log Events](https://auth0.com/docs/deploy-monitor/logs/view-log-events)\n    \n*   [Retrieve Log Events Using the Management API](https://auth0.com/docs/deploy-monitor/logs/retrieve-log-events-using-mgmt-api)\n    \n\nAuth0 provides a wide variety of log event types and well as filtering to allow you to find the specific events to suit your tracking and analysis needs. To learn more, read:\n\n*   [Personally Identifiable Information in Auth0 Logs](https://auth0.com/docs/deploy-monitor/logs/pii-in-logs)\n    \n*   [Log Data Retention](https://auth0.com/docs/deploy-monitor/logs/log-data-retention)\n    \n*   [Log Event Type Codes](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes)\n    \n*   [Adaptive MFA Log Events](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-log-events)\n    \n*   [Attack Protection Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events)\n    \n*   [Log Search Query Syntax](https://auth0.com/docs/deploy-monitor/logs/log-search-query-syntax)\n    \n*   [Log Event Filters](https://auth0.com/docs/deploy-monitor/logs/log-event-filters)\n    \n\n## Log streaming and exporting\n\nUse log streaming to export logs to your preferred processing and analysis tools. We provide integrations with several analysis services as well as a way to create a custom log stream using webhooks. To learn more, read [Log Streaming](https://auth0.com/docs/customize/log-streams).",
  "title": " Logs",
  "description": "Understand how tenant and operations event logs work in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/basic-issues",
  "markdown": "# Troubleshoot Basic Issues\n\n##### Troubleshoot Basic Issues\n\nGet Support\n\nTroubleshoot\n\nAuth0 Product Lifecycle\n\n*   [Verify Platform](https://auth0.com/docs/troubleshoot/basic-issues/verify-platform) - Learn how to verify your platform to troubleshoot issues.\n    \n*   [Verify Connections](https://auth0.com/docs/troubleshoot/basic-issues/verify-connections) - Learn how to verify connection transactions and external service dependencies to troubleshoot issues.\n    \n*   [Verify Domain](https://auth0.com/docs/troubleshoot/basic-issues/verify-domain) - Learn how to verify your domain to troubleshoot issues.\n    \n*   [Verify Rules](https://auth0.com/docs/troubleshoot/basic-issues/verify-rules) - Learn how to verify rules to troubleshoot issues.\n    \n*   [Check Error Messages](https://auth0.com/docs/troubleshoot/basic-issues/check-error-messages) - Learn how to check for error messages to troubleshoot issues.\n    \n*   [Troubleshoot Invalid Token Errors](https://auth0.com/docs/troubleshoot/basic-issues/invalid-token-errors) - Describes how to troubleshoot invalid token errors.\n    \n*   [Check for Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/search-logs-for-deprecation-errors) - Describes how to search for and resolve Auth0 feature [deprecation errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors).\n    \n\n## Learn more\n\n*   [Monitor Applications](https://auth0.com/docs/deploy-monitor/monitor/monitor-applications)\n*   [Troubleshoot Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues)\n*   [Troubleshoot Integration and Extensibility Issues](https://auth0.com/docs/troubleshoot/integration-extensibility-issues)\n*   [Troubleshooting Tools](https://auth0.com/docs/troubleshoot/troubleshooting-tools)\n\nWas this article helpful?",
  "title": "Troubleshoot Basic Issues",
  "description": "Learn where to look for basic troubleshooting steps to eliminate common problems such as Auth0 status, platform, connections, rules, domains, and how to generate HAR files and validate JWTs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/authentication-issues",
  "markdown": "# Troubleshoot Authentication Issues\n\n##### Troubleshoot Authentication Issues\n\nGet Support\n\nTroubleshoot\n\nAuth0 Product Lifecycle\n\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls) - Learn how to check API calls to troubleshoot issues.\n    \n*   [Check Login and Logout Issues](https://auth0.com/docs/troubleshoot/authentication-issues/check-login-and-logout-issues) - Learn how to check login and logout to troubleshoot issues.\n    \n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles) - Learn how to check user profiles to troubleshoot issues.\n    \n*   [Troubleshoot Role-Based Access Control and Authorization](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-rbac-authorization) - Describes solutions to common issues experienced when implementing role-based access control (RBAC) using the Authorization Core feature set.\n    \n*   [Troubleshoot Multi-Factor Authentication](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues) - Describes basic troubleshooting for MFA issues with end-users.\n    \n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations) - Describes troubleshooting for SAML configuration issues.\n    \n*   [Troubleshoot SAML Errors](https://auth0.com/docs/troubleshoot/authentication-issues/saml-errors) - Describes troubleshooting for common SAML errors.\n    \n*   [Self Change Password Errors](https://auth0.com/docs/troubleshoot/authentication-issues/self-change-password-errors) - Describes error codes and possible solutions that can occur with the self change password API.\n    \n*   [Troubleshoot the Authorization Extension](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-authorization-extension) - Learn how to troubleshoot the Authorization Extension.\n    \n*   [Troubleshoot Renew Tokens When Using Safari](https://auth0.com/docs/troubleshoot/authentication-issues/renew-tokens-when-using-safari) - Learn how to troubleshoot Safari browser behavior and authentication.\n    \n\n## Learn more\n\n*   [Monitor Auth0](https://auth0.com/docs/deploy-monitor/monitor)\n*   [Open and Manage Support Tickets](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets)\n*   [Troubleshoot Basic Issues](https://auth0.com/docs/troubleshoot/basic-issues)\n*   [Troubleshoot Integration and Extensibility Issues](https://auth0.com/docs/troubleshoot/integration-extensibility-issues)\n*   [Troubleshooting Tools](https://auth0.com/docs/troubleshoot/troubleshooting-tools)\n\nWas this article helpful?",
  "title": "Troubleshoot Authentication Issues",
  "description": "Learn where to look for steps to troubleshoot authentication and authorization issues such as API calls, login, logout, user profiles, MFA and SAML",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/troubleshooting-tools",
  "markdown": "# Troubleshooting Tools\n\nWas this article helpful?",
  "title": "Troubleshooting Tools",
  "description": "Describes the tools available to help with troubleshooting.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/integration-extensibility-issues",
  "markdown": "# Troubleshoot Integration and Extensibility Issues\n\nWas this article helpful?",
  "title": "Troubleshoot Integration and Extensibility Issues",
  "description": "Learn where to look for steps to troubleshoot integration and extensibility issues such as partner connections, Sign in With Apple, custom databases and domains, Deploy CLI, and extensions",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/error-handling-best-practices",
  "markdown": "# Error Handling Best Practices\n\nError conditions returned from API calls must be handled and processed in an appropriate manner. Failure to do so can lead to unhandled exception situations, resulting in premature termination of pipeline execution and ultimately in an authentication error being returned.\n\n## Send error logs to an external service\n\nWe recommend sending error event logs to an external service to provide better visibility and diagnosis of anomalous operation. To retain and analyze your log events past the log retention period offered for your subscription plan, [use Auth0 log streaming](https://auth0.com/docs/customize/log-streams). You can use services like DataDog and AWS EventBridge. We also offer the ability to send logs to an external service in our [Log Streaming](https://marketplace.auth0.com/features/log-streaming) section in Auth0 Marketplace.\n\n## Use error objects in rules\n\nThere are time constraints regarding how much time a rule has to execute. To learn more, read [Custom Database Action Script Execution Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution). If recovery from an error condition is not possible (or probable) within this time period, then an error condition should be explicitly returned; this is as simple as completing rule execution by returning an instance of a Node `Error` object, as in:\n\n`return callback(new Error('some description'));`\n\nTo learn more, read [Class: Error on nodejs.org](https://nodejs.org/api/errors.html#errors_class_error).\n\nAlternatively, an instance of the Auth0-specific `UnauthorizedError` can be returned, which causes an `unauthorized` error condition with the supplied error description to be returned to the application that initiated authentication—that is, the application from which redirect to the `/authorize` endpoint was initiated. This allows an application to offer conditional retry capability and allows you to implement rules to deny access based on certain conditions:\n\n`return callback(new UnauthorizedError('some description'), user, context);`\n\n## Use meaningful error code descriptions\n\nThe `UnauthorizedError` object only returns the description supplied. To use specific processing for unauthorized error conditions, we recommend that you format your descriptions to include some easily accessible error code information, for example:\n\n`'[00043] - my specific error description'`)\n\n## Exception handling\n\nUnexpected error conditions, such as uncaught JavaScript exceptions, can result in the premature termination of pipeline execution, which will ultimately result in an error in authentication being returned.\n\nFor situations involving asynchronous operations, you must use a `catch` handler when using `Promise` object processing. `Promise` object processing can also be effective for error handling during non-asynchronous operations. As illustrated below, a `Promise` object can be used to wrap, say, a synchronous function call, making it easier to implement cascaded error handling via use of promise chaining and the like. To learn more about the Promise object, read [Promise in MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise). To learn more about promise chaining, read [Error Handling with Promises on javascript.info](https://javascript.info/promise-error-handling).\n\n```\nreturn new Promise(function(resolve, reject) {\n    jwt.verify(\n      token,\n      secret,{\n      clockTolerance: 5},\n      function(err, decoded) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(decoded);\n      }\n    });\n  });\n```\n\nAlternatively, you can use `try...catch` processing to handle JavaScript exceptions that occur during synchronous operation. To learn more, read [`try...catch` in MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch). Setting up this type of exception handling can often incur performance costs, so use it sparingly; rule performance should be as optimal as possible. A more pragmatic approach is to implement processing that prevents exceptions from occurring rather than handling them once they have occurred. To learn more about best practices, see [Performance Best Practices](https://auth0.com/docs/troubleshoot/performance-best-practices).\n\n## Avoid uninitialized objects in rules\n\nIf you use uninitialized objects, that can cause exceptions. We recommend that you include initialization as part of any declaration where the existence of an object is in question. For example:\n\n`user.user_metadata = user.user_metadata || {}`)\n\nIn a rule, taking steps to prevent an exception from occurring in the first place is a best practice and is typically less costly in terms of performance and resource usage than implementing exception handling.\n\n## Learn more\n\n*   [Export Log Events with Rules](https://auth0.com/docs/deploy-monitor/logs/export-log-events-with-rules)\n*   [Debugging Best Practices](https://auth0.com/docs/troubleshoot/debugging-best-practices)\n*   [Rules Best Practices](https://auth0.com/docs/rules-best-practices)",
  "title": "Error Handling Best Practices",
  "description": "Learn about best practices for error handling.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/performance-best-practices",
  "markdown": "# Performance Best Practices\n\nRules execute as part of a pipeline where artifacts for authenticity are generated, as described in [Custom Database Anatomy Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/anatomy). As such, an enabled rule will execute for every login operation (interactive or otherwise), every silent authentication, and every time a user-credentials-related Access Token is generated for an API call. This means that even in small scale deployments, performance can be a concern, which will only be exacerbated as the scale of deployment increases.\n\n## Avoid unnecessary execution\n\nPrefer to implement execution based on conditional logic. For example, to run a rule for only specific applications, check on a specific clientID or for specific `clientMetadata`—especially when checking against a single `clientMetadata` value, common across multiple applications. Using `clientMetadata` can also make adding new clients (as well as reading rule code) easier, especially if you have a large number of applications defined, by reducing the code changes or configuration values needed between environments.\n\nClient metadata for an application can be set manually via the Auth0 Dashboard by going to [Application Settings > Advanced Settings > Application Metadata](https://manage.auth0.com/#/applications/) or programmatically via the use of the Auth0 Management API's [Update a client endpoint](https://auth0.com/docs//api/management/v2#!/Clients/patch_clients_by_id).\n\n## Exit early\n\nFor optimal performance, write rules that complete as soon as possible. For example, if a rule has three checks to decide if it should run, use the first check to eliminate the majority of cases, followed by the check to eliminate the next largest set of cases, and so on and so forth. At the end of each check, remember to execute the callback function, ideally combined with a (JavaScript) `return` in order to exit the (rule) function. To learn more, read [Rules Execution Best Practices.](https://auth0.com/docs/rules-best-practices/rules-execution-best-practices)\n\n## Minimize API requests\n\nCalls to APIs, especially calls to third-party APIs, can slow down login response time and can cause rule timeout failures due to call latency, ultimately leading to authentication error situations. We recommend keeping API requests to a minimum wherever possible within a rule and avoiding excessive calls to paid services. We also recommend you avoid potential security exposure by limiting what is sent to any API, third-party or otherwise.\n\nThe `global` object can be used to cache information from API calls, which can subsequently be used across all rules that execute in the pipeline. Prefer to use this to store information instead of repeatedly calling an API. Additionally, the `global` object can also be used to cache other information between executing rules.\n\n### Limit calls to paid services\n\nIf you have rules that call paid services, such as sending SMS messages via Twilio, make sure that you only use those services when necessary. This not only provides performance enhancement, but also helps to avoid extra charges. To help reduce calls to paid services:\n\n*   Disallow public sign-ups to reduce the number of users who can sign up and trigger calls to paid services\n    \n*   Ensure that a rule only gets triggered for an authorized subset of users or other appropriate conditions. For example, you may want to add logic that checks if a user has a particular email domain, role/group, or subscription level before triggering the call to the paid service.\n    \n\n### Limit calls to the Management API\n\nTry to avoid calls to the Auth0 Management API. The Auth0 Management API is rate limited, which will still be a consideration even when using the `auth0` object (so be sure to use it sparingly). To learn more, read [Management API Endpoint Rate Limits](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits).\n\nIn addition, Management API functions take varying degrees of time to perform, so will incur varying degrees of latency; calling the Management API's [List or Search users endpoint](https://auth0.com/docs/api/management/v2#!/Users/get_users), for example, should be kept to a minimum and performed only where absolutely necessary—even when executed via the `auth0` object.\n\nWe have expanded connection-related properties available to the rules `context` object, so you can obtain connection info from the `context` object instead of needing to call the Auth0 Management API. To learn more, read [Context Object Properties in Rules](https://auth0.com/docs/customize/rules/context-object).\n\nTo see this in action, if you are using the **Check if user email domain matches configured domain** rule template, [check out the latest version on Github](https://github.com/auth0/rules/blob/master/src/rules/check-domains-against-connection-aliases.js) or navigate to [Auth0 Dashboard > Auth Pipeline > Rules](https://manage.auth0.com/#/rules/new), and select **Create**. Note: the recent changes will not alter functionality but will improve the performance of rules that had once relied on calls to the Management API.\n\nRemoving calls to the Management API (as well as the extra call required to get the appropriate Access Token) will make your rule code perform better and be more reliable.\n\n## Use explicit timeouts when making API calls\n\nWhen calling APIs or accessing external services, consider specifying explicit timeout(s). The specific timeout value you choose will typically vary based on your use case, but in general, choosing one that is as low as possible—while bearing in mind the performance characteristics of the external service—is advised.\n\nWhether you choose to use explicit timeouts or implicit timeout processing, always be sure to cater to error and/or exception conditions that may occur as a result of any timeout period expiration. To learn more, read [Error Handling Best Practices](https://auth0.com/docs/troubleshoot/error-handling-best-practices).\n\n## Reduce calls to Auth0\n\nWhen you exceed your rate limits, you'll need to reduce the number of calls you make to Auth0. The specifics depend on your use case, but here are some recommendations:\n\n*   Cache `/.well-known/*` responses: This information does not change frequently, so you can usually cache it to reduce the number of times you need to call Auth0.\n    \n*   Consider requesting an `id_token` instead of calling `/userinfo` to get information about the user.\n    \n*   Reduce bulk calls, such as bulk delete or bulk unlock.\n    \n\n## Learn more\n\n*   [Rules Best Practices](https://auth0.com/docs/rules-best-practices)\n*   [Error Handling Best Practices](https://auth0.com/docs/troubleshoot/error-handling-best-practices)\n*   [Debugging Best Practices](https://auth0.com/docs/troubleshoot/debugging-best-practices)",
  "title": "Performance Best Practices",
  "description": "Learn about best practices for performance.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/debugging-best-practices",
  "markdown": "# Debugging Best Practices\n\n## Rule debugging\n\nOut of the box, typically, you [debug a rule during runtime](https://auth0.com/docs/customize/rules/debug-rules) via console logging by using the `console.log` facility. To learn more, read [console.log() in MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/API/Console/log). There is no interactive debugging of a rule available within the Auth0 platform (though one could employ the testing automation technique described below in conjunction with some external interactive source-debugging facility; to learn more, read [Rules Testing Best Practices](https://auth0.com/docs/rules-best-practices/rules-testing-best-practices)).\n\nAdding sufficient line (i.e., `//`) or block (i.e., `/* */`) comments to a rule, particularly around non-obvious functionality, is invaluable to both code debugging and also code understanding, particularly as there are many occasions where the initial implementer of a rule may not be the same person responsible for maintaining it going forward.\n\n## Real-time Webtask logging\n\nBy default, console log output is unavailable for display during normal execution. However, you can [use the Real-time Webtask Logs extension](https://auth0.com/docs/customize/extensions/real-time-webtask-logs) to display all console logs in real-time for all implemented extensibility in an Auth0 tenant, including rules. The real-time console log display provided by the extension includes all `console.log` output, `console.error` output, and `console.exception` output. To learn more, read [console.error() in MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/API/Console/error).\n\n## Enable and disable debug logging\n\nIn a production environment, debug logging isn’t something that’s desirable all the time; given the performance considerations associated with rules, it would not be prudent to have it continuously enabled. To learn more, read [Performance Best Practices](https://auth0.com/docs/troubleshoot/performance-best-practices).\n\nHowever, in a development or testing environment, the option to enable it on a more continuous basis is much more desirable. Further, excessive debug logging could create substantial “noise”, which could make identifying problems that much harder.\n\nModifying a rule to enable or disable debug logging dependent on the environment would be messy and prone to error. To learn more, read [Rules Environment Best Practices](https://auth0.com/docs/rules-best-practices/rules-environment-best-practices). Instead, the environment configuration object can be leveraged to implement conditional processing in a fashion similar to the following:\n\n```\nfunction NPClaims(user, context, callback) {\n    /*\n     * This rule (https://auth0.com/docs/rules) is used to derive\n     * effective claims associated with the Normalized User Profile:\n     *   https://auth0.com/docs/user-profile/normalized/auth0\n     */\n    var LOG_TAG = '[NORMALIZED_PROFILE_CLAIMS]: ';\n    var DEBUG = configuration.DEBUG ? console.log : function () {};\n    DEBUG(LOG_TAG, \"identities=\", user.identities);\n    user.user_metadata = user.user_metadata || {};\n\n    //\n    user.family_name =\n      user.family_name ||\n      user.identities.filter(function(identity) {\n        /* Filter out identities which do not have anything synonymous with\n         * Family Name\n         */\n        return(\n          identity.profileData &&\n          identity.profileData.family_name);\n      }).map(function(identity) {\n        return identity.profileData.family_name;\n      })[0];\n    DEBUG(LOG_TAG, \"Computed user.family_name as '\", user.family_name, \"'\");\n      .\n      .\n\n    //\n    return callback(null, user, context);\n  }\n```\n\nIn the example above, a `DEBUG` environment configuration variable has been created, which can be set to `true` or `false` depending on the execution environment (e.g., production, testing, development). The setting of this variable is used to determine when debug logging is performed. Further, a `DEBUGLEVEL` environment `configuration` variable, say, could be created, which could be used to control the debugging log level (e.g., verbose, medium, sparse).\n\nThe above example also demonstrates declaration of a named function. For convenience, providing a function name—using some compact and unique naming convention—can assist with diagnostic analysis. Anonymous functions make it hard in debugging situations to interpret the call-stack generated as a result of any exceptional error condition and providing a unique function name addresses this. To learn more, read [Error Handling Best Practices](https://auth0.com/docs/troubleshoot/error-handling-best-practices).\n\n### Static analysis\n\nThe rule editor in the Auth0 dashboard provides some rudimentary syntax checking and analysis of rule semantics. However, no provision is made for more complex static code analysis, such as overwrite detection, loop detection, or vulnerability detection. To address this, consider leveraging the use of third-party tooling—such as [JSHint](https://jshint.com/about/), [SonarJS](https://www.sonarsource.com/products/codeanalyzers/sonarjs.html), or [Coverity](https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html)—in conjunction with rule testing as part of your deployment automation process. To learn more, read [Deployment Best Practices](https://auth0.com/docs/deploy-monitor/deployment-best-practices).\n\n## Learn more\n\n*   [Rules Testing Best Practices](https://auth0.com/docs/rules-best-practices/rules-testing-best-practices)\n*   [Deployment Best Practices](https://auth0.com/docs/deploy-monitor/deployment-best-practices)\n*   [Error Handling Best Practices](https://auth0.com/docs/troubleshoot/error-handling-best-practices)\n*   [Performance Best Practices](https://auth0.com/docs/troubleshoot/performance-best-practices)",
  "title": "Debugging Best Practices",
  "description": "Learn about best practices for debugging.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle",
  "markdown": "# Product Lifecycle\n\nWhen building Auth0 products, we resolve to\n\n*   Deliver value to customers early and often, iterating based on their feedback\n    \n*   Seek a deep understanding of our customers and consider them in every decision\n    \n*   Relentlessly acquire and analyze data, so we can make better choices\n    \n*   Visualize and design for current, idealized, and future versions of our whole product when adding features\n    \n\nTo best serve these goals, we apply an iterative approach to product delivery, including an iterative product release lifecycle that allows us to introduce and improve upon new functionality.",
  "title": "Product Lifecycle",
  "description": "Learn about the Auth0 product lifecycle, including product release stages, deprecations, end-of-life, the migration process, and active migrations.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/id-tokens",
  "markdown": "# ID Tokens\n\nID tokens are used in token-based authentication to cache user profile information and provide it to a client application, thereby providing better performance and experience. The application receives an ID token after a user successfully authenticates, then consumes the ID token and extracts user information from it, which it can then use to personalize the user's experience.\n\nFor example, suppose you have a regular web app that you [register it with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps) and configure to allow users to login with Google. Once a user logs in, use the ID token to gather information such as name and email address, which you can then use to auto-generate and send a personalized welcome email.\n\nID Tokens should never be used to obtain direct access to APIs or to make authorization decisions.\n\n## ID token security\n\nAs with other [JWTs](https://auth0.com/docs/secure/tokens/json-web-tokens), you should follow [token usage best practices](https://auth0.com/docs/secure/tokens/token-best-practices) when using and storing ID tokens.\n\nSecuring apps that make API calls come with their own set of concerns. You'll need to ensure that tokens and other sensitive data are not vulnerable to cross-site scripting (XSS) and can't be read by malicious JavaScript.\n\n## ID token lifetime\n\nBy default, an ID token is valid for 36000 seconds (10 hours). If there are security concerns, you can shorten the time period before the token expires, keeping in mind that one of the purposes of the token is to improve user experience by caching user information. See [Update ID Token Lifetime](https://auth0.com/docs/secure/tokens/id-tokens/update-id-token-lifetime) for details.\n\n## Learn more\n\n*   [Validate ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/validate-id-tokens)\n*   [Get ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/get-id-tokens)\n*   [Revoke Tokens](https://auth0.com/docs/secure/tokens/revoke-tokens)\n*   [ID Token Structure](https://auth0.com/docs/secure/tokens/id-tokens/id-token-structure)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "ID Tokens",
  "description": "Describes how ID Tokens are used in token-based authentication to cache user profile information and provide it to a client application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login",
  "markdown": "# Auth0 Universal Login\n\nAuth0 Universal Login provides the essential feature of an authorization server: the login flow. When a user needs to prove their identity to gain access to your application, you can redirect them to Universal Login and let Auth0 handle the authentication process. \n\nWith Universal Login, you don’t have to complete any integration work to accommodate different methods of authentication. You can start with a simple username and password flow, then add additional features, such as social login or multi-factor authentication (MFA), to customize a secure and user-friendly login experience.\n\nConfiguring Universal Login is dynamic and does not require any application-level changes, as web pages hosted on Auth0’s centralized authentication server completely drive the login flow. Additionally, you don’t need to manually update your code for applications to benefit from improvements Auth0 makes to Universal Login.\n\nFrom the Auth0 Dashboard, you can customize the appearance and behavior of login pages to create a consistent, branded experience. For advanced use cases, you can also change the code of each page individually.\n\nTo learn more about the differences between Universal Login and embedded login, review [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login).\n\n## Configure Universal Login\n\nOn your Auth0 Dashboard, you can choose which experience to use for default login pages under [Branding > Universal Login > Advanced Options](https://manage.auth0.com/#/universal-login/customizations-new).\n\n![Auth0 Branding Universal Login Settings Tab Experience](https://images.ctfassets.net/cdy7uua7fh8z/1kronfcLaGJ9NqgfGsKtGi/3b1495aa7b9aaad8802630d2be7e59ef/Universal_Login_Experience_-_Dashboard_Options_-_Smaller__1_.png)\n\nAuth0 offers two hosted login experiences:\n\n*   **Universal Login** offers a streamlined experience for users and does not require the use of JavaScript for customization.\n    \n*   **Classic Login** uses JavaScript controls for each page of the login flow.\n    \n\nAt this time, Auth0’s active development efforts are focused on Universal Login, and Classic Login no longer receives updates. Unless your specific use case requires the Classic experience, implementing Universal Login is recommended.\n\nTo learn more about how these two experiences compare, review [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login).\n\n### Accessibility\n\nAuth0 is implementing [WCAG 2.2 standards](https://www.w3.org/WAI/standards-guidelines/wcag/) to improve access to universal login flows for people with different vision levels. During the initial Early Access rollout, you can use WCAG standards by enabling the toggle on your [Auth0 Dashboard](https://manage.auth0.com/dashboard/us/dev-6endizjt/login_settings).\n\n![In Early Access, this toggle enables WCAG elements in your sign-in flow. ](https://images.ctfassets.net/cdy7uua7fh8z/5O4DDy1h0rgbYNzKwm1lKY/0218b59f9773d500f54a1fdaebdf9cd5/Screenshot_2024-04-05_at_3.31.39_PM_2__4_.png)\n\nThis feature can also be enabled in the Management API by updating the `enable_ulp_wcag_compliance` flag in the [Update Prompt Settings endpoint](https://auth0.com/docs/api/management/v2/prompts/patch-prompts):\n\n```\ncurl -L -X PATCH 'https://<tenant_name>.auth0.com/api/v2/prompts' \\\n-H 'Content-Type: application/json' \\\n-H 'Accept: application/json' \\\n-H 'Authorization: Bearer 'abc123' \\\n-d '{\"universal_login_experience\":\"new\",\"identifier_first\":true,\"webauthn_platform_first_factor\":true,\"enable_ulp_wcag_compliance\":true}'\n```\n\nThese improvements are optional during the Early Access period and do not apply to Classic Login. After the feature is made generally available, the option to opt in will be deprecated and removed for all customers.\n\n### Customize login page\n\nAfter enabling Universal Login, you can customize your login page directly from the Auth0 Dashboard. Specifically, you can customize page templates and themes, sign-up and login prompts, and other text elements. To learn more, review Customize Universal Login. \n\nIf you decide to implement Classic Login, you can customize basic branding options from the Auth0 Dashboard. You can then configure advanced customization with the SDK used to build your login flow. To learn more, review Customize Classic Login.\n\n## Implement Universal Login\n\nAfter enabling either Universal Login or Classic Login within your tenant, follow the steps below to implement the experience:\n\n1.  [Register your application](https://auth0.com/docs/get-started/auth0-overview/create-applications) with Auth0.\n    \n2.  Configure your application to call the [Login endpoint](https://auth0.com/docs/api/authentication#login) of the Authentication API to trigger the login flow and handle the response. and handle the response. You can configure this directly or use one of Auth0's [SDKs](https://auth0.com/docs/libraries).\n    \n3.  Create a [Database](https://auth0.com/docs/get-started/applications/set-up-database-connections), [Enterprise](https://auth0.com/docs/authenticate/enterprise-connections), or [Social](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers) connection and enable it for your application.\n    \n\n### Navigate to the login page\n\nYou can call the [Login endpoint](https://auth0.com/docs/api/authentication#login) directly from any browser:\n\n```\nhttps://{yourDomain}/authorize?\n  response_type=code|token&\n  client_id={yourClientId}&\n  connection={connectionName}&\n  redirect_uri={https://yourApp/callback}&\n  state={state}\n```\n\nThe request must include the following values:\n\n*   `response_type` (either `code` or `token`)\n    \n*   `client_id`\n    \n*   `redirect_uri`\n    \n*   `state`\n    \n    *   To better understand why this value is required review [Prevent Attacks and Redirect Users With OAuth 2.0 State Parameters](https://auth0.com/docs/secure/attack-protection/state-parameters).\n        \n\nOptionally, you can include the `connection` parameter to prompt users to authenticate with the specified connection.\n\n### Use the Quickstart guides\n\nFor more information on how you can set up Universal Login for your application, review the [Quickstart guides](https://auth0.com/docs/quickstarts). Choose the approach that best fits your technologies and follow the Quickstart for a walkthrough of the implementation.\n\n## Learn more\n\n*   [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login)\n*   [Universal Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience)\n*   [Classic Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience)\n*   [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login)\n*   [Universal Login Internationalization](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization)",
  "title": "Auth0 Universal Login",
  "description": "Describes how Auth0 Universal Login provides you with the means to prove your users' identities with our authorization server.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/application-credentials",
  "markdown": "# Application Credentials\n\nConfidential applications, unlike public applications, can securely store credentials. When confidential applications request access or ID tokens from the [token endpoint](https://auth0.com/docs/api/authentication#get-token), the application must authenticate with the authorization server. During this request for tokens, the application provides credentials known by the application. Additionally, application credentials can also provide authenticity and integrity protection for request parameters sent to the [`/authorize`](https://auth0.com/docs/api/authentication#authorize-application) endpoint.\n\nTo learn more about confidential applications versus public applications, read [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n\n## Application authentication methods\n\nTo get tokens from Auth0, your application must authenticate through the [Authentication API](https://auth0.com/docs/api/authentication). Auth0 supports the following ways your application can authenticate:\n\n*   **Client Secret:** A symmetrical authentication method. In Client Secret authentication, you use the Client Secret Auth0 generated when you created the application.\n    \n*   **Private Key JWT:** An asymmetric authentication method. In Private Key JWT, you generate a pair of keys, public and private, to use as credentials. You provide the public key and securely store the private key in your own systems without sharing it with Auth0.\n    \n*   **mTLS for OAuth:** An asymmetric authentication method. In mTLS for OAuth, you register a standard X.509 client certificate with Auth0. Then, you use the corresponding private key to securely establish the mTLS tunnel to send requests to your Auth0 tenant endpoints.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3tPMyIcI7dTfnJLY5lASun/2e566bc0de8b8352bb15a22f40b6c84c/Screenshot_2024-05-28_at_4.30.51_PM.png)\n\n### Client Secret authentication\n\nClient Secret authentication is a symmetric authentication method included in the [OAuth 2.0 specification](https://www.rfc-editor.org/rfc/rfc6749#section-2.3). Client Secret authentication is the default authentication method in Auth0.\n\nThis authentication method is supported by all existing applications and tooling. The Client Secret is a high-entropy value generated by Auth0 when you create an application and is known by both your application and Auth0. Your application authenticates by including the Client Secret in the request to the authorization server.\n\nSome security risks are associated with using Client Secret as a credential, especially for scenarios with higher security demands:\n\n*   The secret used by the application is shared with Auth0.\n    \n*   The secret is sent over the network and could be intercepted in the case of man-in-the-middle attacks. \n    \n\nAn application can have a single Client Secret. It is not possible to rotate the secret while you update your implementation with the new secret. To learn more, read [Rotate Client Secrets](https://auth0.com/docs/get-started/applications/rotate-client-secret).\n\n### Private Key JWT authentication\n\nPrivate Key JWT authentication is an asymmetric authentication method that relies on private and public key pairs. To learn more, read [JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants](http://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer).\n\nYou can use the Auth0 Dashboard or Auth0 Management API to configure a tenant to use Private Key JWT. To learn more, read [Configure Private Key JWT Authentication.](https://auth0.com/docs/get-started/applications/configure-private-key-jwt)\n\nIn Private Key JWT, a request to the authorization server consists of two main steps:\n\n1.  Configure public and private keys:\n    \n    1.  [Generate a key pair](https://auth0.com/docs/secure/application-credentials/generate-rsa-key-pair) (one public key and one private key).\n        \n    2.  Register the private key with the application making the authentication request and register the public key with the identity provider (IdP).\n        \n2.  Build an assertions for requests to the authorization server:\n    \n    1.  Create a new assertion with specified claims in JWT format and sign it with the private key. Include this assertion as part of the request to the IdP.\n        \n    2.  IdP validates the assertion using the public key.\n        \n\nTo configure Private Key JWT for Auth0, read [Configure Private Key JWT Authentication](https://auth0.com/docs/get-started/applications/configure-private-key-jwt). To learn more about building an assertion for Private Key JWT, read [Authenticate with Private Key JWT](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt).\n\nThere are some security benefits associated with using Private Key JWT:\n\n*   The private key is not transmitted over the network and reduces the exposure risk of your application’s credentials. Identity providers like Auth0 have no knowledge of the private key, and only applications that have access to the private key can create authentication requests.\n    \n*   The signed assertions have a short expiry time, limiting the window of opportunity for replay attacks.\n    \n\n### mTLS for OAuth\n\n[mTLS for OAuth](https://www.rfc-editor.org/rfc/rfc8705) authenticates requests to the authorization server using mutual TLS based on self-signed certificates or public key infrastructure (PKI). Read [Authenticate with mTLS](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls) to learn more about how mTLS authentication works at Auth0.\n\nAuth0’s mTLS for OAuth initially targets customers in highly regulated sectors such as finance and healthcare that most likely already have mTLS deployments. To simplify customer adoption, the mTLS feature builds on [custom domains](https://auth0.com/docs/customize/custom-domains) and leverages the customer’s existing mTLS infrastructure to perform certificate provisioning and verification. To learn more about authenticating with mTLS and setting up your edge network, read [Authenticate with mTLS](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls) and [Set up your customer edge](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge). \n\nTo learn how to configure mTLS, read [Configure mTLS Authentication](https://auth0.com/docs/get-started/applications/configure-mtls). Once you have set up your edge network and configured mTLS, your application needs to establish the mTLS tunnel to send requests to Auth0, as explained in [Call the authorization server](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls#call-the-authorization-server).\n\nIn mTLS, the client certificate’s private key is not transmitted over the network, reducing the risk of exposing your application credentials. Identity providers like Auth0 do not have access to the private key. Only applications that have access to the private key can authenticate.\n\n[JWT-Secured Authorization Request (JAR)](https://datatracker.ietf.org/doc/rfc9101/) is an OAuth2 protocol extension that enhances the security of authorization requests. It does so by using a JSON Web Token (JWT) request parameter to protect the integrity and confidentiality of the authorization request parameters.\n\nYou can use the [Auth0 Management API](https://auth0.com/docs/api/management/v2) to configure JAR for your application. Auth0 implementation for JAR uses asymmetric cryptography, where you register the public key while securely storing the private key on your end. To learn more, read [Configure JWT-Secured Authorization Requests](https://auth0.com/docs/get-started/applications/configure-jar).\n\nWhen using JAR, the client creates a JWT that includes the authorization request parameters, signs it with its private key, and sends it to the authorization server. The authorization server then verifies the signature using the client's public key, and if the signature is valid, extracts the authorization request parameters from the JWT and processes the request as usual. To learn more about how to use JAR, read [Authorization Code Flow with JWT-Secured Authorization Requests (JAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-jar).\n\n### Key and certificate registration\n\nYou can register two public keys for an application at the same time. Auth0 handles verification against the proper key and allows you to rotate with no downtime. Once the old key has been removed or deactivated, all requests signed with the corresponding private key are invalidated.\n\n**Note:** Auth0 supports the following algorithms for application authentication and authorization request signing: RS256, RS384 and PS256. Please make sure to provide the appropriate keys for them. To learn more, read [Configure Private JWT Authentication](https://auth0.com/docs/get-started/applications/configure-private-key-jwt) and [Configure JWT-Secured Authorization Requests](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-jar).\n\nSimilarly, for mTLS client certificates, you can register two client X.509 certificates (self-signed or with the CA cert’s Subject DN) at the same time for an application. Auth0 handles verification against both client certificates, which allows you to rotate certificates with zero downtime.\n\n## Update application authentication method\n\nYou can update an application’s authentication method in the Auth0 Dashboard. To learn more, read [Credential Settings](https://auth0.com/docs/get-started/applications/credentials).\n\n## Learn more\n\n*   [Credential Settings](https://auth0.com/docs/get-started/applications/credentials)\n*   [Authenticate with Private Key JWT](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt)\n*   [Rotate Credentials](https://auth0.com/docs/get-started/applications/rotate-credentials)\n*   [Configure Private Key JWT Authentication](https://auth0.com/docs/get-started/applications/configure-private-key-jwt)\n*   [Authenticate with mTLS](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls)",
  "title": "Application Credentials",
  "description": "Describes ways you can authenticate your application with Auth0 services.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/attack-protection",
  "markdown": "# Attack Protection\n\nAuth0 can detect attacks and stop malicious attempts to access your application such as blocking traffic from certain IPs and displaying CAPTCHA.\n\nIn the [Auth0 Dashboard](https://manage.auth0.com/#/security/attack-protection), you can enable the following attack protection options to mitigate attacks:\n\n*   [](https://auth0.com/docs/secure/attack-protection/brute-force-protection)[Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection)\n    \n*   [Suspicious IP Throttling](https://auth0.com/docs/secure/attack-protection/suspicious-ip-throttling)\n    \n*   [Brute Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection)\n    \n*   [Breached Password Detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection)\n    \n\n![Dashboard Security Attack Protection page](https://images.ctfassets.net/cdy7uua7fh8z/7IxNz72aMoNqIEgGKPZiuv/ee9f7ec600bd2495bf51d0b338939b25/dashboard-attack-protection-list.png)\n\n## How it works\n\nWhen it comes to combatting abuse, there is no silver bullet. Auth0 supports the principle of layered protection in security that uses a variety of signals to detect and mitigate attacks.\n\n| **Feature** | **Risk signal** | **How it works** |\n| --- | --- | --- |\n| Bot Detection | **IP reputation** computed by analyzing the quality of traffic seen for each IP. | Triggers a CAPTCHA step when a login attempt comes from an IP suspected of use by a bot. |\n| Suspicious IP Throttling | **Velocity** of login attempts from an IP for any number of accounts against a tenant. | Detects when a bot/script tries too many username/password combinations within a short period of time. |\n| Brute-force Protection | **Velocity** of login attempts from an IP for a particular account. | Detects when a bad actor tries to login to an account too many times within a period of time. |\n| Breached Password Detection | **Use of a breached password** that appears in lists of breached passwords on the dark web. | Stops users from using passwords that are known to be breached in some 3P sites. |\n\n## Notification\n\nIn the event of an attack, users will be notified by email once per hour regardless of the number of logins. For example, if a user tries to log in 200 times in 1 hour and 30 minutes, we will send 2 emails. Password reset links are valid for 5 days. You can [customize the emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails) sent to your users.\n\nIn the event of an ongoing attack, traffic can be blocked from thousands of IP addresses at a time. Auth0 will send a single email to each administrator every hour that traffic is blocked, regardless of the number of IPs involved in the attack.\n\n## Monitoring\n\nEnabling attack protection features without configuring response settings activates Monitoring mode, which records related events in your tenant log only. The tenant log will contain information about whether the login was determined to be risky so you can determine if you want to configure responses.\n\n## Reporting\n\nYou can also create reports using tenant log data to [see attack protection events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events).\n\n## Learn more\n\n*   [Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection)\n*   [Suspicious IP Throttling](https://auth0.com/docs/secure/attack-protection/suspicious-ip-throttling)\n*   [Brute-Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection)\n*   [Breached Password Detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection)\n*   [View Attack Protection Log Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events)",
  "title": "Attack Protection",
  "description": "Describes how Auth0 detects attacks to stop malicious attempts to access your application, alert you and your users of suspicious activity, and block further login attempts.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-center",
  "markdown": "# Security Center\n\nSecurity Center provides observability tools that allow you to see potential attack trends and quickly respond to them in real-time. Security Center provides real-time monitoring that allows you to observe your own Customer Identity and Access Management (CIAM) anomaly detection metrics, and lets you configure attack mitigation features from within the same space.\n\n## Real-time monitoring\n\nSecurity Center provides you with an overview of your tenant’s security pulse and allows you to drive outcomes from within the Auth0 Management Dashboard. In Security Center, you can:\n\n*   Monitor your total traffic and total threats\n    \n*   Observe threat behavior trends\n    \n*   Identify applications associated with threat behavior trends\n    \n*   Track login and signup traffic\n    \n*   Monitor threats identified by our Attack Protection and MFA features\n    \n\n### Filtering and aggregation\n\nSecurity Center allows you to filter available data to your needs.\n\nYou can filter data based on a time period, including:\n\n*   Last hour\n    \n*   Last 12 hours\n    \n*   Last day\n    \n*   Last 7 days\n    \n*   Last 14 days\n    \n\nDepending on the time period you select, the data is automatically aggregated per minute, per hour, or per day.\n\n### Threat behavior trends\n\nSecurity Center allows you to observe threat behavior trends for the following threat types:\n\n*   **Credential stuffing**: Behavioral patterns that appear to involve a machine attempt with the goal of submitting credentials to compromise user accounts.\n    \n*   **Signup attack**: Behavioral patterns that appear to involve a machine attempt with the goal of creating new user accounts.\n    \n*   **MFA bypass**: Behavior patterns that appear to involve a machine attempt with the goal of circumventing user multi-factor authentication (MFA) protections.\n    \n\nViews allow you to slice data by threat type and identify applications associated with threat behavior trends.\n\n![Screenshot shows a dashboard, a line graph, a horizontal bar chart, and a doughnut chart. The dashboard details the total traffic, total threats, and percentage of threats. The line graph details threat behavior trends by traffic type. Separate lines exist for normal traffic, credential stuffing, signup attacks, and MFA bypass threats. The horizontal bar chart details threat behavior by app. Each bar represents a specific app and different threat types are color coded within the bar. The doughnut chart details the threat behavior type breakdown and different threat types are color coded within the doughnut.](https://images.ctfassets.net/cdy7uua7fh8z/2hyZMfdrGwVZxKtuV4ZOR3/f1795066d12eb02550da8f4eb0f00fd5/Threat_Behavior.png)\n\n### Authentication events\n\nSecurity Center allows you to inspect authentication events, including login attempts and signup attempts.\n\n![Screenshot shows two line graphs. One shows the number of login attempts in the last 7 days. Separate lines are shown for successful logins and failed logins. The other shows the number of signup attempts over the last 7 days. Separate lines are shown for successful signups and failed signups.](https://images.ctfassets.net/cdy7uua7fh8z/6ywLqRG3zUAMwkAEGDoDoU/c24aa46d823ae702861ef57ee14dd9e6/Authentication.png)\n\n#### Login attempts\n\nLogin attempts include both successful and failed login transactions over the last seven days.\n\n#### Signup attempts\n\nSignup attempts include both successful and failed signup transactions over the last seven days.\n\n### Attack Protection and MFA monitoring\n\nSecurity Center helps you understand current attack trends identified by our Attack Protection and MFA features, and allows you to implement countermeasures by enabling and configuring these features:\n\n#### Bot detection\n\nBot detection mitigates scripted attacks by detecting when a request is likely to be coming from a bot. Bot detection includes the number of bots detected over the last seven days.\n\n![Screenshot shows a line graph detailing number of bots detected in the last 7 days.](https://images.ctfassets.net/cdy7uua7fh8z/vfXBOFaB8fprq7rbr1vPG/0676832da280a528326b44f97624e8ff/Bot_Detection.png)\n\nTo learn more about this feature, read [Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection).\n\n#### Suspicious IP throttling\n\nSuspicious IP throttling blocks traffic from any IP address that rapidly attempts too many logins or signups. Suspicious IP throttling includes the number of suspicious IPs blocked over the last seven days.\n\n![Screenshot shows a line graph detailing number of suspicious IP activities detected in the last 7 days.](https://images.ctfassets.net/cdy7uua7fh8z/4q2Gso3wAbdAMM9YCUSxTk/23026864247740c4530668a8c4d21665/Suspicious_IP_Throttling.png)\n\nTo learn more about this feature, read [Suspicious IP Throttling](https://auth0.com/docs/secure/attack-protection/suspicious-ip-throttling). \n\n#### Brute-force protection\n\nBrute-force protection safeguards against a single IP address attacking a single user account. Brute-force protection includes the number of blocked brute-force attempts over the last seven days.\n\n![Screenshot shows a line graph detailing number of brute-force attempts blocked in the last 7 days.](https://images.ctfassets.net/cdy7uua7fh8z/2nDIp8GDPe2zhhzcdDPKue/a49e729930a01e21800856768440faab/Brute-Force_Protection.png)\n\nTo learn more about this feature, read [Brute-Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection).\n\n#### Breached password detection\n\nBreached password detection protects your applications from bad actors signing up or logging in with stolen credentials. Breached password detection includes the number of breached credentials detected in login and signup flows over the last seven days.\n\n![Screenshot shows line graph detailing number of breached credentials detected in the last 7 days. Separate lines are shown for login flows and signup flows.](https://images.ctfassets.net/cdy7uua7fh8z/6DxOEJdBbE6flhk6S0apkx/f0ba51ef05a1717db67aa055299f0d08/Breached_Password_Detection.png)\n\nTo learn more about this feature, read [Breached Password Detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection).\n\n#### Multi-factor authentication\n\nMulti-factor authentication (MFA) verifies users by requiring more than one type of user validation. MFA includes the number of MFA challenges detected and the number of MFA challenges passed or failed over the last seven days.\n\n![Screenshot shows two line graphs. One shows the number of MFA challenges in the last 7 days. The other shows the MFA success rate over the last 7 days. Separate lines are shown for MFA passed and MFA failed.](https://images.ctfassets.net/cdy7uua7fh8z/2qqYETiIMP2o0XOciJSS1b/b7b4a61563620aad422a2048e8eb08d4/Multi-Factor_Auth.png)\n\nTo learn more about this feature, read [Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication).\n\n## Learn more\n\n*   [Metrics](https://auth0.com/docs/secure/security-center/metrics)",
  "title": "Security Center",
  "description": "Learn about Security Center, which provides observability tools that empower you to see potential attack trends and quickly respond to them in real-time.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/general-usage-and-operations-best-practices",
  "markdown": "# General Usage and Operations Best Practices\n\nHere are some recommended best practices for general Auth0 usage and operation.\n\n## Capture log files\n\nAuth0 keeps tenant logs for a limited amount of time. (To learn more, read [Logs](https://auth0.com/docs/deploy-monitor/logs).) To get log data and store it elsewhere, you can use the Auth0 Management API's [Search log events endpoint](https://auth0.com/docs/api/management/v2#!/Logs/get_logs), [stream the logs](https://auth0.com/docs/customize/log-streams) to an external service, or [export log events using one of the available extensions](https://marketplace.auth0.com/features/log-streaming) for services such as Loggly or Splunk.\n\n## Set up your own email provider and customize email templates\n\nAuth0 provides a test email provider, so you can test default welcome and email verification messages during tenant configuration. To learn more, read [Email](https://auth0.com/docs/customize/email). The test provider can only send a limited amount of emails, so you should [configure your own mail server](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider). Additionally, we recommend a unique email provider account per tenant. Sharing an email account between tenants can be a potential source of problems or outages for one tenant when making changes to the service intended for another.\n\nAlso, make sure to [configure and customize the templates](https://auth0.com/docs/customize/email/email-templates) for emails sent from Auth0. These include email verification messages, welcome messages, password reset messages, et cetera. For custom templates, provide a \"from\" address, a clear subject, your custom content, and a link timeout for emails with a link (such as a password reset link).\n\n## Avoid pinning or fingerprinting TLS certificates for Auth0 endpoints\n\nAuth0 does not support pinning or fingerprinting TLS certificates for Auth0 API endpoints. Doing so can lead to outages and unexpected behaviors within your applications or services.\n\nCertificates presented on Auth0 endpoints are issued for varying expiry timeframes. These certificates are renewed with different intermediate certificate authorities and root certificate authorities. Any sort of pinning or fingerprinting should be avoided since any aspect of the certificate chain can be changed at any time.\n\n## Subscribe to updates on the Auth0 status page\n\n[Sign up for notifications at the Auth0 status page](https://status.auth0.com/). If there are any Auth0 outages, you or your support staff will be notified.\n\n## Store custom code in a source code repository\n\nIf you have a full continuous integration/continuous deployment pipeline, use the Auth0 Deploy CLI tool for greater flexibility. To learn more, read [Deploy CLI Tool](https://auth0.com/docs/deploy-monitor/deploy-cli-tool).\n\nPlease note that the [auth0-deploy-cli](https://github.com/auth0/auth0-deploy-cli) tool is updated regularly to provide feature enhancements, security improvements, and bug fixes. Before you upgrade to a newer version, review the [release notes](https://github.com/auth0/auth0-deploy-cli/releases) and update your configuration files accordingly.\n\n## Store configuration values in Dashboard\n\nIf your Actions, Rules, Hooks, custom database scripts, or Webtasks require configuration values (such as credentials or API keys), you should store them in the Auth0 Dashboard. Storing configuration values in the Dashboard makes migrating configuration between tenants easier. To learn more, read [Set Up Multiple Environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments).\n\n## Add Auth0 public IP addresses to AllowList\n\nIf your Actions, Rules, Hooks, custom database scripts, or Webtasks call a service in your intranet or behind another firewall, be sure to add the Auth0 public IP addresses to the AllowList. This lets requests from those IP addresses through. You can find the IP addresses for each region in your Auth0 Dashboard, where you edit rules, hooks, or custom database scripts.\n\n## Run tenant configuration checks\n\nThe Auth0 Support Center provides a configuration checker tool. Run the configuration checker periodically during development and again before you launch.\n\nTo run the configuration check, go to [Auth0 Support Center > Tenants](https://support.auth0.com/tenants/public), select the gear icon, and choose **Run Production Check**.\n\n## ASN Binding optimization\n\nAn Autonomous System Network (ASN) is a unique identifier assigned to an Autonomous System comprising IP networks and routing devices under the control of an Administrative Domain (AD) owned by a Service Provider. ASN binding for Dashboard users is enabled by default and is not configurable.\n\nIf you are experiencing redirect loops or are frequently being prompted to enter your password while accessing Teams or Auth0 Dashboard, see the following best practices to help mitigate potential issues:\n\n*   Connecting and disconnecting to either a corporate or commercial VPN could mean your IP and ASN are changing. Verify that when connected to the VPN, the public IP that is used to access the Internet does not change for the duration your VPN connection is on.\n    \n*   If using a VPN, verify the VPN connection is stable; random disconnects and connects as a result of network stability might represent frequent changes to your Public IP and ASN.\n    \n*   Some corporate networks might utilize network or firewall load-balancers to prevent internet outages associated with relying on a single Internet Service Provider. Verify that your Public IP is not frequently changing while accessing Teams or Auth0 Dashboard. Try using another network to test that you can successfully log in.",
  "title": "General Usage and Operations Best Practices",
  "description": "Learn about best practices for general operations in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance",
  "markdown": "# Security Guidance\n\nWas this article helpful?",
  "title": "Security Guidance",
  "description": "Guidance related to security, including general tips, security bulletins, and information about data and token storage, Allow Lists, Deny Lists, and how to prevent common cyberattacks.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/highly-regulated-identity",
  "markdown": "# Highly Regulated Identity\n\nHighly Regulated Identity (HRI) is Auth0’s Financial-Grade Identity™ solution to secure sensitive data operations and services important for your business. Initially targeting highly regulated industries like finance and healthcare, Highly Regulated Identity raises the security level to protect a wide range of customer use cases, including but not limited to money transfers, digital payments, and access to medical records. You can also use Highly Regulated Identity for other sensitive operations that require enhanced security, such as to approve changes in administrative credentials, secure privileged access to a web portal, and more.\n\nTo secure your sensitive business operations, Highly Regulated Identity provides:\n\n*   [Advanced security with OpenID Connect (FAPI)](#advanced-security-with-openid-connect-fapi-)\n    \n*   [Strong Customer Authentication (SCA)](#strong-customer-authentication-sca-) and [Dynamic Linking](#dynamic-linking)\n    \n*   [Confidentiality and integrity protection](#confidentiality-and-integrity-protection)\n    \n*   [Strong application authentication](#stronger-application-authentication)\n    \n*   [Protect access tokens with Token Binding](#protect-access-tokens-with-token-binding)\n    \n*   [Customizable approval flows for better user experience](#customizable-approval-flows-for-better-user-experience)\n    \n\n## Advanced security with OpenID Connect (FAPI)\n\n[OpenID FAPI](https://openid.net/wg/fapi/specifications/) is a suite of security and privacy specifications developed by the OpenID Foundation. APIs that meet the FAPI standards are classified as “financial-grade,” which means that they provide robust authentication and authorization mechanisms that help secure access to financial and other sensitive data and services.\n\nAuth0 is a certified FAPI provider. To learn more about the security improvements we introduced to meet FAPI standards, see the following sections:\n\n*   [Confidentiality and integrity protection](#confidentiality-and-integrity-protection)\n    \n*   [Strong application authentication](#stronger-application-authentication)\n    \n*   [Protect access tokens with Token Binding](#protect-access-tokens-with-token-binding)\n    \n\nFor more information on FAPI, see OpenID's [Open Banking, Open Data, and Financial-grade APIs](https://openid.net/wordpress-content/uploads/2022/03/OIDF-Whitepaper_Open-Banking-Open-Data-and-Financial-Grade-APIs_2022-03-16.pdf) whitepaper and the [FAPI Working Group specifications](https://openid.net/wg/fapi/specifications/).\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/20iajPMtmICMORUfaVQH7a/ec900e1007b3faebd66eb2508f46acb0/image17.png)\n\n## Strong Customer Authentication (SCA)\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3JDIerJcevImoIDRd7OfIy/98597a9164b66cde9ec7ddc23f3e849b/image14.png)\n\nIntroduced by Europe’s [Payment Services Directive (PSD2)](https://www.europeanpaymentscouncil.eu/sites/default/files/infographic/2018-04/EPC_Infographic_PSD2_April%202018.pdf), Strong Customer Authentication (SCA), mandates the use of at least two distinct authentication factors out of the following three:\n\n*   Something the user knows (e.g., a password)\n    \n*   Something the user possesses (e.g., a device)\n    \n*   Something intrinsic to the user (e.g., a fingerprint)\n    \n\nThe authentication factors must be independent so that compromising one does not jeopardize the others. SCA is quickly becoming the worldwide standard for safeguarding sensitive data and services.\n\nTo help with SCA compliance, Auth0 offers various authentication factors that enroll and challenge users during a login transaction. Highly Regulated Identity leverages the following authentication factors to secure your transactions: \n\n*   Mobile push notifications\n    \n*   SMS\n    \n*   Email\n    \n*   WebAuthn\n    \n\nUsing [Actions](https://auth0.com/docs/customize/actions), you can dynamically determine which authentication factors to use. This gives you the flexibility to customize your code logic. For example, you can add a second authentication factor for payments above 10 USD. To learn more, read [Apply dynamic policy](https://auth0.com/docs/secure/highly-regulated-identity/transactional-authorization-with-contextual-sca#apply-dynamic-policy).\n\n## Dynamic Linking\n\nPSD2 requires that payment service providers implement Dynamic Linking along with Strong Customer Authentication. Dynamic Linking presents the user with transaction details for their explicit validation and approval and uniquely links the authorization and the transaction details. This ensures a good user experience and helps with regulatory compliance.\n\nTo enable Dynamic Linking, you can use Rich Authorization Requests (RAR) to pass fine-grained transaction authorization data to the OAuth authorization endpoint. The following code sample shows an `authorization_details` JSON object, which contains information like the payment type, amount, currency, and recipient:\n\n```\n\"authorization_details\": [\n {\n   \"type\": \"one_time_payment\",\n   \"amount\": {\n     \"amount\": 2460,46,\n     \"currency\": \"USD\"\n   },\n   \"sourceAccount\": \"xxxxxxxxxxx4567\",\n   \"recipient\": \"Acme Travel, Inc.\",\n   \"concept\": \"All Inclusive Resort Package for Two\",\n }\n]\n```\n\n`authorization_details` is assigned a unique transaction reference, which Auth0 uses to prompt the user to perform step-up authentication: \n\n*   Use push notifications to show transaction details and get approval on a separate device such as a mobile phone application.\n    \n*   Use SMS, email, or WebAuthn to confirm the details on the device that originated the transaction after the user completes the second authentication factor.\n    \n\nIf the user confirms the details, the transaction progresses and Auth0 issues an access token associated with the now-approved authorization\\_details. Developers can also add the unique transaction reference to the access token. As a result, your API servers can later validate the approved transaction details when receiving and servicing API requests.\n\nTo learn more about RAR, read [Authorization Code Flow with Rich Authorization Requests](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-rar).\n\n## Confidentiality and integrity protection\n\nAuthorization details may include account numbers, monetary amounts, merchant names, and other highly sensitive information that are passed in URLs or access tokens that are not secure. To protect sensitive data from unauthorized access and tampering, Highly Regulated Identity offers comprehensive confidentiality and integrity protection.\n\n### Protect sensitive data in the front channel\n\nTo protect sensitive data in the front channel, such as a web browser, Highly Regulated Identity offers the following solutions as part of the FAPI 1 Advanced Security profile.\n\n[PAR](https://datatracker.ietf.org/doc/rfc9126/) introduces a new endpoint, which allows clients to directly push the payload of an OAuth 2.0 authorization request to the authorization server (i.e. Auth0 in this case). This avoids passing the authorization parameters via the insecure front channel (i.e., the browser), thus reducing the risk of unauthorized access to authorization parameters by an intermediary.\n\nTo learn more about PAR, read [Authorization Code Flow with Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par) and [Configure Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/applications/configure-par).\n\n#### JWT-Secured Authorization Request (JAR)\n\n[JAR](https://datatracker.ietf.org/doc/rfc9101/) is an OAuth2 protocol extension that enhances the security of authorization requests. It does so by using a JSON Web Token (JWT) request parameter to protect the integrity and, optionally, the confidentiality of the authorization request parameters.\n\nTo learn more about JAR, read [Authorization Code Flow with JWT-Secured Authorization Requests (JAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-jar) and [Configure JWT-Secured Authorization Requests (JAR)](https://auth0.com/docs/get-started/applications/configure-jar).\n\n#### Protect sensitive data in access tokens\n\nTo protect the authorization details included in access tokens, Highly Regulated Identity provides support for using [JSON Web Encryption (JWE)](https://datatracker.ietf.org/doc/html/rfc7516) to encrypt the payload of access tokens. This protects access tokens from application-side data breaches and unauthorized inspection into API calls by intermediaries.\n\nTo learn more about JWE, read [JSON Web Encryption](https://auth0.com/docs/secure/tokens/access-tokens/json-web-encryption) and [Configure JSON Web Encryption](https://auth0.com/docs/get-started/apis/configure-json-web-encryption).\n\n## Stronger application authentication\n\nTo improve your application authentication security, Highly Regulated Identity offers two different alternatives as part of the FAPI 1 Advanced Security profile:\n\n*   [Private Key JWT](http://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer): involves generating a public-private key pair to use as credentials to authenticate an application. It is already available for customers on the Enterprise plan. To learn more, read [Private Key JWT Authentication](https://auth0.com/docs/secure/application-credentials#private-key-jwt-authentication).\n    \n*   [mTLS for OAuth](https://datatracker.ietf.org/doc/html/rfc8705): involves registering a standard X.509 certificate linked to an application on your tenant. The certificate can either be CA-issued or self-signed. Following standard mTLS procedures, the private key corresponding to the certificate is used on the client side to establish the mTLS tunnel when sending requests to your Auth0 tenant endpoints. As a result, Auth0 can authenticate the application without transmitting secrets over the network. To learn more, read [mTLS for OAuth](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls).\n    \n\nWith both Private Key JWT and OAuth 2.0 mTLS, you can rotate credentials with zero downtime by temporarily keeping two active keys and/or certificates at the same time for a given application.\n\n## Protect access tokens with Token Binding\n\nSupporting mTLS also adds the ability to use Token Binding or Sender Constraining. Token Binding associates the thumbprint of the client certificate used for establishing the mTLS tunnel to an access token. When the client consumes an API using the certificate-bound access token, the API server is then able to verify whether the client is also using the associated client certificate. As a result, even if the access token is compromised, malicious actors who don’t know the client certificate still cannot access protected resources.\n\n**Note:** Token Binding operates independently of the application's authentication method and does not require the pre-registration of the client certificate. To learn more, read [Token Binding](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#enable-token-binding) and [Call the resource server](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls#call-the-resource-server).\n\n## Customizable approval flows for better user experience\n\nWhen designing real-world solutions for financial-grade security, it’s important to consider user experience. Applying one-size-fits-all authentication flows for all transactions is not as effective as dynamically adjusting based on transaction details and use cases. \n\nYou can customize your authentication flow using [Actions](https://auth0.com/docs/customize/actions). For example, after the user logs in, you can inspect transaction details received via RAR, list the user’s enrolled and already validated authentication factors, and use external services, such as risk evaluation engines, to determine the next authentication factor to use. To learn more, read [Apply dynamic policy](https://auth0.com/docs/secure/highly-regulated-identity/transactional-authorization-with-contextual-sca#apply-dynamic-policy). \n\nThe New Universal Login templates also enable you to customize the attributes displayed on the transaction approval screen depending on the type of transaction and other authorization details. To learn more, read [Configure Rich Authorization Requests (RAR)](https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests).\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7eBJA1IPsCIZubFKEtHh3m/8ec245ebd3bab775e9ba12fbe7f4096c/image2.png)\n\n## Learn more\n\nTo learn how Highly Regulated Identity works from end-to-end to authorize a one-time transaction, read [Transactional Authorization with Contextual Strong Customer Authentication](https://auth0.com/docs/secure/highly-regulated-identity/transactional-authorization-with-contextual-sca).",
  "title": "Highly Regulated Identity",
  "description": "Learn about Highly Regulated Identity, Auth0's Financial-Grade Identity solution. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/data-privacy-and-compliance",
  "markdown": "# Auth0 Data Privacy and Compliance\n\nAuth0 maintains and meets the requirements for multiple compliance frameworks and certifications. To download or request Auth0 compliance documentation, [visit the Support Center](https://support.auth0.com/compliance). Auth0 will document additional compliance frameworks and certifications on this page when available.\n\n## Compliance & Certifications\n\n### FAPI\n\nAuth0 supports technical requirements for [FAPI](https://openid.net/wg/fapi/), a set of advanced security profiles specified by the OpenID Foundation. FAPI introduces stricter security standards for industries and scenarios that require more security on top of normal OAuth 2.0 and OpenID Connect (OIDC) implementations. \n\nAuth0 is a certified FAPI OpenID Provider for the following two profiles:\n\n*   FAPI 1 Advanced OP with mTLS, PAR\n    \n*   FAPI 1 Advanced OP with Private Key JWT, PAR\n    \n\nFor more information, see [FAPI OpenID Providers (OP) & Profiles](https://openid.net/certification/#FAPI-OP-P).\n\nTo understand how we incorporated FAPI capabilities into Auth0, see [Highly Regulated Identity](https://auth0.com/docs/secure/highly-regulated-identity).\n\nAuth0 is GDPR ready. Auth0 provides information to its customers to help them understand how features and functionality of the Auth0 platform may affect their GDPR compliance obligations.\n\n### HIPAA and HITECH\n\nAuth0 is considered as a **Business Associate** as defined by the US HIPAA and HITECH legislation. For Auth0 customers who qualify as a **Covered Entity** under US HIPAA legislation and related legislation and regulations and who provide ePHI (electronic Protected Health Information) to Auth0 as part of the Auth0 user profile, Auth0 may qualify as a business associate. Auth0 can provide its **Business Associate Agreement** to you upon request. To learn more about HIPAA, read [Health Information Privacy on hhs.gov](https://www.hhs.gov/hipaa/index.html). To learn more about HITECH, read [HITECH Act Enforcement Final Rules on hhs.gov](https://www.hhs.gov/hipaa/for-professionals/special-topics/HITECH-act-enforcement-interim-final-rule/index.html). HIPAA compliance is not available on Azure deployments.\n\n### CSA STAR\n\nAuth0 is CSA STAR certified. You can review the CSA Consensus Assessments Initiative Questionnaire (CAIQ) and can view our CAIQ and STAR Certificates in the [CSA STAR Registry](https://cloudsecurityalliance.org/star/registry/auth0/).\n\n### ISO 27001/27018\n\nAuth0 undergoes an ISO 27001/27018 audit by an independent auditor annually. To request access to our ISO 27001/27018 certificate, log in to [Auth0 Support Center](http://support.auth0.com/) and select the **Compliance** option. We can also share our Statement of Applicability (SOA) upon request with a non-disclosure agreement (NDA) signed by a corporate officer authorized to represent the company. To request the SOA, please contact your assigned Technical Account Manager or Account Executive.\n\n### PCI DSS\n\nAuth0 offers PCI compliant environment deployment models. Our Attestation of Compliance (AOC) and/or Self Assessment Questionnaire (SAQ-D) is available upon request. For a copy of these documents, log in to [Auth0 Support Center](http://support.auth0.com/) and select the **Compliance** option.\n\n### Payment Services Directive 2 (PSD2)\n\nWe provide the capabilities for customers to build an end-to-end user journey that includes Strong Customer Authentication(SCA) and Dynamic Linking, which dynamically shows transaction details for explicit end-user approval. For more information, read [Highly Regulated Identity](https://auth0.com/docs/secure/highly-regulated-identity).\n\n### SOC2\n\nAuth0 undergoes a SOC 2 Type 2 audit by an independent auditor annually. The audit covers all 5 Trust Services Criteria (Security, Availability, Processing Integrity, Confidentiality and Privacy). For a copy of the SOC 2 report, log in to [Auth0 Support Center](http://support.auth0.com/) and select the **Compliance** option.\n\n## Specifications\n\nFor information on compliance with technical specifications for authentication, please see our [Protocols](https://auth0.com/docs/authenticate/protocols) documentation.\n\n## Learn more\n\n*   [Auth0 General Data Protection Regulation Compliance](https://auth0.com/docs/secure/data-privacy-and-compliance/gdpr)\n*   [Auth0 Data Processing](https://auth0.com/docs/secure/data-privacy-and-compliance/data-processing)",
  "title": "Auth0 Data Privacy and Compliance",
  "description": "Learn about how Auth0 maintains and meets requirements for multiple compliance frameworks and certifications, including GDPR, CSA STAR, PCI DSS, and more.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/ionic-angular",
  "markdown": "# Auth0 Ionic & Capacitor (Angular) SDK Quickstarts: Login\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Native/Mobile App](https://auth0.com/docs/quickstart/native)\n*   [Ionic & Capacitor (Angular)](https://auth0.com/docs/quickstart/native/ionic-angular)\n\nThis tutorial demonstrates how to add user login with Auth0 to an Ionic Angular & Capacitor application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Node & Npm (LTS) | XCode 12+ (for iOS) | Android Studio 4+ (for Android)\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\nGo to the [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings) section in your Auth0 dashboard and set your **Callback URL** in the **Allowed Callback URLs** box.\n\nYou should set the **Allowed Callback URL** to:\n\n```\nYOUR_PACKAGE_ID://{yourDomain}/capacitor/YOUR_PACKAGE_ID/callback\n```\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\nYou should set the **Allowed Logout URLs** to\n\n```\nYOUR_PACKAGE_ID://{yourDomain}/capacitor/YOUR_PACKAGE_ID/callback\n```\n\n### Configure Origins\n\nTo be able to make requests from your application to Auth0, set the following **Allowed Origins** in your [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\n```\ncapacitor://localhost, http://localhost\n```\n\nThese origins are required for iOS and Android respectively.\n\nLastly, be sure that the **Application Type** for your application is set to **Native** in the [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\n## Install the Auth0 Angular SDK\n\nRun the following command within your project directory to install the Auth0 Angular SDK:\n\n```\nnpm install @auth0/auth0-angular\n```\n\nThe SDK exposes several types that help you integrate Auth0 with your Angular application idiomatically, including a module and an authentication service.\n\n### Install Capacitor plugins\n\nThis quickstart and sample make use of some of Capacitor's official plugins. Install these into your app using the following command:\n\n```\nnpm install @capacitor/browser @capacitor/app\n```\n\n*   [`@capacitor/browser`](https://capacitorjs.com/docs/apis/browser) - allows you to interact with the device's system browser and is used to open the URL to Auth0's authorizaction endpoint\n*   [`@capacitor/app`](https://capacitorjs.com/docs/apis/app) - allows you to subscribe to high-level app events, useful for handling callbacks from Auth0\n\n### Configure your App module\n\nThe SDK exports `AuthModule`, a module that contains all the services required for the SDK to function. To register this with your application:\n\n*   Open the `app.module.ts` file\n*   Import the `AuthModule` type from the `@auth0/auth0-angular` package\n*   Add `AuthModule` to the application by calling `AuthModule.forRoot` and adding to your application module's `imports` array\n*   Specify the configuration for the Auth0 Angular SDK\n\n```\n// Import the types from the SDK\nimport { AuthModule } from '@auth0/auth0-angular';\nimport config from '../../capacitor.config';\n\n// ..\n\n// Build the URL that Auth0 should redirect back to\nconst redirect_uri = `${config.appId}://{yourDomain}/capacitor/${config.appId}/callback`;\n\n// Register AuthModule with your AppModule\n@NgModule({\n  declarations: [AppComponent],\n  entryComponents: [],\n  imports: [\n    BrowserModule,\n    IonicModule.forRoot(),\n    AppRoutingModule,\n    AuthModule.forRoot({\n      domain: \"{yourDomain}\",\n      clientId: \"{yourClientId}\",\n      useRefreshTokens: true,\n      useRefreshTokensFallback: false,\n      authorizationParams: {\n        redirect_uri,\n      }\n    }),\n  ],\n  providers: [{ provide: RouteReuseStrategy, useClass: IonicRouteStrategy }],\n  bootstrap: [AppComponent],\n})\n```\n\nThe `AuthModule.forRoot` function takes the following configuration:\n\n*   `domain`: The \"domain\" value present under the \"Settings\" of the application you created in your Auth0 dashboard, or your custom domain if using Auth0's [Custom Domains feature](http://localhost:3000/docs/custom-domains)\n*   `clientId`: The \"client ID\" value present under the \"Settings\" of the application you created in your Auth0 dashboard\n*   `useRefreshTokens`: To use auth0-angular with Ionic on Android and iOS, it's required to enable refresh tokens.\n*   `useRefreshTokensFallback`: To use auth0-angular with Ionic on Android and iOS, it's required to disable the iframe fallback.\n*   `authorizationParams.redirect_uri`: The URL to where you'd like to redirect your users after they authenticate with Auth0.\n\n### Checkpoint\n\nNow that you have configured your app with the Auth0 Angular SDK, run your application to verify that the SDK is initializing without error and that your application runs as it did before.\n\n## Add Login to Your Application\n\nAdd a new `LoginButton` component to your application with the following code:\n\n```\nimport { Component, OnInit } from '@angular/core';\nimport { AuthService } from '@auth0/auth0-angular';\nimport { Browser } from '@capacitor/browser';\nimport { mergeMap } from 'rxjs/operators';\n\n@Component({\n  selector: 'app-login-button',\n  template: `<ion-button (click)=\"login()\">Login</ion-button>`,\n})\nexport class LoginButtonComponent {\n  constructor(public auth: AuthService) {}\n\n  login() {\n    this.auth\n      .loginWithRedirect({\n        async openUrl(url: string) {\n          await Browser.open({ url, windowName: '_self' });\n        }\n      })\n      .subscribe();\n  }\n}\n```\n\nThis component:\n\n*   defines a template with a simple button that logs the user in when clicked\n*   uses `loginWithRedirect` to login using Auth0's Universal Login page\n*   uses the `openUrl` callback to use Capacitor's Browser plugin to open the URL and show the login page to the user\n\n### Handling the callback\n\nOnce users logs in with the Universal Login Page, they redirect back to your app via a URL with a custom URL scheme. The `appUrlOpen` event must be handled within your app. You can call the `handleRedirectCallback` method from the Auth0 SDK to initialize the authentication state.\n\nYou can only use this method on a redirect from Auth0. To verify success, check for the presence of the `code` and `state` parameters in the URL.\n\nThe `Browser.close()` method should close the browser when this event is raised.\n\nModify your `App` component and use the `ngOnInit` method to handle the callback from Auth0.\n\n```\nimport { Component, OnInit, NgZone } from '@angular/core';\nimport { AuthService } from '@auth0/auth0-angular';\nimport { mergeMap } from 'rxjs/operators';\nimport { Browser } from '@capacitor/browser';\nimport { App } from '@capacitor/app';\n\nconst callbackUri = `${config.appId}://{yourDomain}/capacitor/${config.appId}/callback`;\n\n@Component({\n  selector: 'app-root',\n  templateUrl: 'app.component.html',\n  styleUrls: ['app.component.scss'],\n})\nexport class AppComponent implements OnInit {\n  // Import the AuthService module from the Auth0 Angular SDK\n  constructor(public auth: AuthService, private ngZone: NgZone) {}\n\n  ngOnInit(): void {\n    // Use Capacitor's App plugin to subscribe to the `appUrlOpen` event\n    App.addListener('appUrlOpen', ({ url }) => {\n      // Must run inside an NgZone for Angular to pick up the changes\n      // https://capacitorjs.com/docs/guides/angular\n      ngZone.run(() => {\n        if (url?.startsWith(callbackUri)) {\n          // If the URL is an authentication callback URL..\n          if (\n            url.includes('state=') &&\n            (url.includes('error=') || url.includes('code='))\n          ) {\n            // Call handleRedirectCallback and close the browser\n            this.auth\n              .handleRedirectCallback(url)\n              .pipe(mergeMap(() => Browser.close()))\n              .subscribe();\n          } else {\n            Browser.close();\n          }\n        }\n      });\n    });\n  }\n}\n```\n\nNote that the `appUrlOpen` event callback is wrapped in `ngZone.run`, which means that the changes to observables that occur when `handleRedirectCallback` runs are picked up by the Angular app. Please read [Using Angular with Capacitor](https://capacitorjs.com/docs/guides/angular) for more details. Otherwise, the screen will not update to show the authenticated state after you log in.\n\n### Checkpoint\n\nAdd the `LoginButton` component to your application, as well as the handler for the \"appUrlOpen\" event to your `App` component. When you click the login button, verify that your application redirects you to the Auth0 Universal Login Page and that you can now log in or sign up using a username and password or a social provider.\n\nOnce that's complete, verify that Auth0 redirects you back to your application.\n\n## Add Logout to Your Application\n\nNow that users can log in, you need to configure [a way to log out](https://auth0.com/docs/logout/guides/logout-auth0). Users must redirect to the Auth0 logout endpoint in the browser to clear their browser session. Again, Capacitor's Browser plugin should perform this redirect so that the user does not leave your app and receive a suboptimal experience.\n\nTo achieve this with Ionic and Capacitor in conjunction with the Auth0 SDK:\n\n*   Construct the URL for your app Auth0 should use to redirect to after logout. This is a URL that uses your registered custom scheme and Auth0 domain. Add it to your **Allowed Logout URLs** configuration in the Auth0 Dashboard\n*   Logout from the SDK by calling `logout`, and pass your redirect URL back as the `logoutParams.returnTo` parameter.\n*   Set the `openUrl` parameter to a callback that uses the Capacitor browser plugin to open the URL using `Browser.open`.\n\nCreate a new `LogoutButton` component and add the following code to the file. Then, add the `LogoutButton` component to your app.\n\n```\nimport { Component, OnInit } from '@angular/core';\nimport { AuthService } from '@auth0/auth0-angular';\nimport { Browser } from '@capacitor/browser';\nimport { tap } from 'rxjs/operators';\n\n// Build the URL to return back to your app after logout\nconst returnTo = `${config.appId}://{yourDomain}/capacitor/${config.appId}/callback`;\n\n@Component({\n  selector: 'app-logout-button',\n  template: `<ion-button (click)=\"logout()\">Log out</ion-button>`,\n})\nexport class LogoutButtonComponent {\n  // Import the AuthService module from the Auth0 Angular SDK\n  constructor(public auth: AuthService) {}\n\n   logout() {\n    this.auth\n      .logout({ \n        logoutParams: {\n          returnTo,\n        },\n        async openUrl(url: string) {\n          await Browser.open({ url });\n        } \n      })\n      .subscribe();\n  }\n}\n```\n\n### Checkpoint\n\nAdd the `LogoutButton` component to your application. When you click it, verify that your Ionic application redirects you to the address you specified as one of the \"Allowed Logout URLs\" in the \"Settings\" and that you are no longer logged in to your application.\n\n## Show User Profile Information\n\nThe Auth0 SDK helps you retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with logged-in users quickly in whatever component you need, such as their name or profile picture, to personalize the user interface. The profile information is available through the `user$` property exposed by `AuthService`.\n\nCreate a new component `Profile`, and use the following code to display user profile information in your app.\n\n```\nimport { Component, OnInit } from '@angular/core';\nimport { AuthService } from '@auth0/auth0-angular';\n\n@Component({\n  selector: 'app-profile',\n  template: `\n  <div *ngIf=\"auth.user$ | async as user\">\n    <ion-avatar class=\"avatar\">\n      <img [src]=\"user.picture\" [alt]=\"user.name\" />\n    </ion-avatar>\n    <h2>{{ user.name }}</h2>\n    <p>{{ user.email }}</p>\n  </div>`,\n})\nexport class ProfileComponent {\n  constructor(public auth: AuthService) {}\n}\n```\n\n### Checkpoint\n\nAdd `ProfileComponent` to your application, and verify that you can display the `user.name` or [any other `user` property](https://auth0.com/docs/users/references/user-profile-structure#user-profile-attributes) within a component correctly after you have logged in.",
  "title": "Auth0 Ionic & Capacitor (Angular) SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login with Auth0 to an Ionic Angular & Capacitor application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/users/concepts/overview-user-profile",
  "markdown": "# User Profiles\n\nTo access any of the applications in your tenant, each user must have a profile in the tenant. User profiles contain information about your users such as name and contact information. You can manage user profiles through the [Auth0 Dashboard](https://auth0.com/docs/get-started/auth0-overview/dashboard) and the [Auth0 Management API](https://auth0.com/docs/api/management/v2). \n\n## User data sources\n\nUser data can come from many sources, including your own databases as well as social, legal, and enterprise identity providers. Some examples include Google, Facebook, Active Directory, or SAML. You can normalize user data that comes from any supported data source. \n\nUser profile attributes can include information from the identity provider. These are examples:\n\n| User data from... | Might include... |\n| --- | --- |\n| LinkedIn | Current employer or degrees achieved |\n| Facebook | Profile picture, birthday, or relationship status |\n| Active Directory | Employee number, job title, or department |\n\nAuth0 refers to all user data sources as **connections** because Auth0 connects to them to authenticate the user.\n\n### User data normalization\n\nAuth0 supports a variety of [Identity Providers](https://auth0.com/docs/authenticate/identity-providers) and [Database Connections](https://auth0.com/docs/authenticate/database-connections). Each connection can return a different set of user attributes. Sometimes different connections use different names for the same attribute. For example, `surname` from one connection might be `last_name` and `family_name` from other user data sources. \n\nTo handle this complexity, Auth0 provides a [normalized user profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles), an Auth0-specific standard for storing user data.\n\n### User profile attribute mapping\n\n#### AD/LDAP connector\n\nFor Active Directory or any other LDAP connections that use the Auth0 AD/LDAP connector, there is a mechanism for mapping user profile attributes in the directory service to the Auth0 normalized user profile. A `profileMapper.js` file, located in the installation directory of the AD/LDAP connector, maps the attributes when a user authenticates.\n\n#### SAML assertions\n\nIf your application uses the SAML protocol to communicate with Auth0, one of two mechanisms match the user attributes to the Auth0 normalized user profile:\n\n| If Auth0 is a... | Then... |\n| --- | --- |\n| SAML Service Provider | Use the SAML connection's Mappings tab to map attributes coming from an IDP to attributes in the Auth0 user profile: Go to [Dashboard > Authentication > Enterprise > SAMLP](https://manage.auth0.com/#/connections/database/enterprise/samlp). Click on the name of the SAML connection and click **Mappings**. |\n| SAML Identity Provider | Use the Settings tab of Application AddOns to map attributes from the Auth0 user profile to attributes in the SAML Assertion sent back to the Service Provider: Go to [Dashboard > Applications](https://manage.auth0.com/#/connections/database/applications). Click on the name of your application, click **Addons**, and click **SAML2 Web App**. |\n\n### Account linking\n\nUsers can log into an application initially using one connection (such as a custom database), then later log in using a different connection (such as Facebook). In this case, the `user_id` for the second authentication is different from the `user_id` for the first authentication.\n\nAuth0 provides a mechanism to link the two accounts. When Auth0 links the two accounts, it stores two elements in the `identities` array portion of the user profile, one for each connection.\n\nAuth0 does not merge user profile attributes from multiple providers. Auth0 sources **core** user profile attributes from the first provider used.\n\nTo learn more, read [User Account Linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking).\n\n### Caching user profiles\n\nAuth0 caches the user profile received from a connection before passing it on to the calling application. This cache is in the Auth0 database. Each time the user authenticates, Auth0 updates the cache. To learn more, read [Update User Profile Using Your Database](https://auth0.com/docs/manage-users/user-accounts/user-profiles/update-user-profiles-using-your-database).\n\n## Custom user profile data\n\nAuth0 lets you store [metadata](https://auth0.com/docs/manage-users/user-accounts/metadata), which is data related to each user that has not come from the identity provider. You can use `user_metadata` to store custom attributes such as the user's favorite color or hobby.\n\n## Change user profile data\n\nYou can modify a user's profile information in a number of ways.\n\n*   [Scopes](https://auth0.com/docs/get-started/apis/scopes): The authentication flows supported by Auth0 include an optional parameter that lets you specify a scope. This controls the user profile information (claims) included in the ID token (JWT).\n    \n*   [Auth0 Dashboard](https://auth0.com/docs/manage-users/user-accounts/manage-users-using-the-dashboard): The Dashboard lets you manually edit the `user_metadata` and `app_metadata` portions of any user’s profile.\n    \n*   [Management API](https://auth0.com/docs/manage-users/user-accounts/manage-users-using-the-management-api): You can read, update, and delete user profiles stored in the Auth0 database.\n    \n*   [Custom database scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/templates): If you’re using a custom database as a connection, you can write scripts to implement lifecycle events such as create, login, verify, delete and change password. Auth0 provides templates for these scripts that you can modify for the particular database and schema.\n    \n*   [Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules): Use Rules to augment the user profile during the authentication transaction, and optionally persist those changes back to Auth0. \n    \n\n## Access user profiles\n\nBoth apps and the Auth0 Management API can a user's profile information.\n\n### Access user profiles from apps\n\nOnce Auth0 completes authentication and returns control to your application, it provides the user profile to the application. At a low level, you can accomplish this using one of the application [protocols](https://auth0.com/docs/authenticate/protocols) supported by Auth0. However, most developers prefer to use the Auth0 SDKs. To learn more, read [Quickstarts](https://auth0.com/docs/quickstarts).\n\nOne SDK is the Auth0 Lock widget, which provides a user login interface. To learn more, read:\n\n*   [Lock for Web](https://auth0.com/docs/libraries/lock)\n    \n*   [Lock Swift](https://auth0.com/docs/libraries/lock-swift)\n    \n*   [Lock.Android](https://auth0.com/docs/libraries/lock-android)\n    \n\nIf you want your web app to have a custom login UI, you can use Auth0.js. This headless JavaScript library for Auth0 invokes authentication flow (and other tasks) and receives a User Profile object in return. To learn more, read [Auth0.js v9 Reference](https://auth0.com/docs/libraries/auth0js).\n\n### Access user profiles from the Management API\n\nAuth0 provides a REST API that allows applications and services to access and manipulate the User Profile object.\n\nThe API Explorer lets users interactively explore the Management API. It provides:\n\n*   API calls available\n    \n*   Information required for each call\n    \n*   Information returned by each call\n    \n\nWith the explorer, users can try each endpoint in the explorer UI or via a CuRL command on the command line. To try one of the Management API commands, go to the [API Explorer](https://auth0.com/docs/api/management/v2). Select the access required under **Scopes** within the command you choose, such as `update:users`, and then click **TRY**.\n\nThe Auth0 Authentication API is specifically for authentication flows. To learn more, read [Authentication API Explorer](https://auth0.com/docs/api/authentication). Typically, most of these endpoints are used by the various Auth0 SDKs, not your own code.\n\n## The difference between user profiles and tokens\n\nIn the authentication flows described above, Auth0 returns a set of tokens in lieu of a full user profile.\n\nOne of the returned tokens is the ID token, which is a JSON Web Token (JWT) that contains user profile attributes represented in the form of claims. These claims are statements about the user. A claim can be trusted if the consumer of the token can verify its signature, which (in the case of HS256) is generated with the Auth0 app’s client secret. If your app uses RS256 encryption, the ID token will be signed with a private key and verified with a public key. Your app can then decode the JWT and get the user information contained in its payload. Examples of this information are the user's name, email, and other data that is typically part of the user experience.\n\nThe claims within a JWT generally contain only a subset of the information available in the user profile. The purpose is to minimize the token size. To learn more, read [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens).\n\nThere are three other types of tokens that can be returned during authentication:\n\n*   Auth0 access token\n    \n*   Third-party provider access token\n    \n*   Refresh token\n    \n\nTo learn more about tokens and claims, read [Tokens](https://auth0.com/docs/secure/tokens).\n\n## Learn more\n\n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [Troubleshoot SAML Errors](https://auth0.com/docs/troubleshoot/authentication-issues/saml-errors)\n*   [Verify Connections](https://auth0.com/docs/troubleshoot/basic-issues/verify-connections)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Auth0.Android Login, Logout, and User Profiles](https://auth0.com/docs/libraries/auth0-android/auth0-android-login-logout-and-user-profiles)",
  "title": "User Profiles",
  "description": "Understand how user profiles work in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/logout",
  "markdown": "# Logout\n\n#### Overview\n\nKey Concepts\n\n*   Review different session layers.\n    \n*   Learn how to redirect users after logout.\n    \n\nYou can log a user out of the Auth0 session and (optionally) from the identity provider (IdP) session. When you're implementing the logout functionality, there are typically three-session layers you need to consider:\n\n1.  **Application Session Layer**: The first layer is the session inside your application. Though your application uses Auth0 to authenticate users, you'll still need to track that the user has logged in to your application. In a regular web application, you achieve this by storing information inside a cookie. [Log users out of your applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications) by clearing their sessions. You should handle the application session in your application.\n    \n2.  **Auth0 Session Layer**: Auth0 also maintains a session for the user and stores their information inside a cookie. The next time a user is redirected to the Auth0 Lock screen, the user's information will be remembered. [Log users out of Auth0](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0) by clearing the Single Sign-on (SSO) cookie.\n    \n3.  **Identity Provider Session Layer**: The last session layer is the identity provider layer (for example, Facebook or Google). When users attempt to sign in with any of these providers and they are already signed into the provider, they will not be prompted again to sign in. The users may be asked to give permission to share their information with Auth0 and, in turn, your application. It is not necessary to log the users out of this session layer, but you can force the logout. (For more information, see [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps) and [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps).)\n    \n\n## Redirect users after logout\n\nAfter users log out, you can [redirect users](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout) to a specific URL. You need to register the redirect URL in your tenant or application settings. Auth0 only redirects to URLs from the allow list after logout. If you need different redirects for each application, you can add the URLs to your allow list in your application settings.\n\n## Learn more\n\n*   [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications)\n*   [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0)\n*   [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n*   [Redirect Users with Alternative Logout](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout)\n*   [Check Login and Logout Issues](https://auth0.com/docs/troubleshoot/authentication-issues/check-login-and-logout-issues)",
  "title": "Logout",
  "description": "Describes how logout works with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-single-page-app-sdk",
  "markdown": "# Auth0 Single Page App SDK\n\nThe Auth0 Single Page App SDK is a new JavaScript library for implementing authentication and authorization in single page apps (SPA) with Auth0. It provides a high-level API and handles a lot of the details so you can secure SPAs using best practices while writing less code.\n\nThe Auth0 SPA SDK handles grant and protocol details, token expiration and renewal, as well as token storage and caching. Under the hood, it implements [Universal Login](https://auth0.com/docs/universal-login) and the [Authorization Code Grant Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).\n\nThe [library](https://github.com/auth0/auth0-spa-js) and [API documentation](https://auth0.github.io/auth0-spa-js/) are hosted on GitHub.\n\nIf you encounter any problems or errors when using the new JavaScript SDK, please [read the FAQ](https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md) to see if your issue is covered there.\n\n## Installation\n\nYou have a few options for using the Auth0 SPA SDK in your project:\n\n*   From the CDN: `<script src=\"https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js\"></script>`. For more information, read the [FAQ](https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#how-to-use-from-a-cdn).\n    \n*   With [npm](https://npmjs.org/): `npm install @auth0/auth0-spa-js`\n    \n*   With [yarn](https://yarnpkg.com/): `yarn add @auth0/auth0-spa-js`\n    \n\n## Getting Started\n\n### Create the client\n\nFirst, you'll need to create a new instance of the `Auth0Client` client object. Create the `Auth0Client` instance before rendering or initializing your application. You can do this using either the async/await method, or with promises. You should only create one instance of the client.\n\nUsing `createAuth0Client` does a couple of things automatically:\n\n*   It creates an instance of `Auth0Client`.\n    \n*   It calls `getTokenSilently` to refresh the user session.\n    \n*   It suppresses all errors from `getTokenSilently`, except `login_required`.\n    \n\n#### Use async/await\n\n```\nimport { createAuth0Client } from '@auth0/auth0-spa-js';\n\nconst auth0 = await createAuth0Client({\n  domain: '{yourDomain}',\n  clientId: '{yourClientId}'\n});\n```\n\n#### Use promises\n\n```\ncreateAuth0Client({\n  domain: '{yourDomain}',\n  clientId: '{yourClientId}'\n}).then(auth0 => {\n  //...\n});\n```\n\nYou can also create the client directly using the `Auth0Client` constructor. This can be useful if you want to:\n\n*   Bypass the call to `getTokenSilently` on initialization.\n    \n*   Do custom error handling.\n    \n*   Initialize the SDK in a synchronous way.\n    \n\n```\nimport { Auth0Client } from '@auth0/auth0-spa-js';\n\nconst auth0 = new Auth0Client({\n  domain: '{yourDomain}',\n  clientId: '{yourClientId}'\n});\n```\n\n### Login and get user info\n\nNext, create a button users can click to start logging in:\n\n`<button id=\"login\">Click to Login</button>`\n\nListen for click events on the button you created. When the event occurs, use the desired login method to authenticate the user (`loginWithRedirect()` in this example). After the user is authenticated, you can retrieve the user profile with the `getUser()` method.\n\n#### Use async/await\n\n```\ndocument.getElementById('login').addEventListener('click', async () => {\n  await auth0.loginWithRedirect({\n    authorizationParams: {\n      redirect_uri: 'http://localhost:3000/'\n    }\n  });\n  //logged in. you can get the user profile like this:\n  const user = await auth0.getUser();\n  console.log(user);\n});\n```\n\n#### Use promises\n\n```\ndocument.getElementById('login').addEventListener('click', () => {\n  auth0.loginWithRedirect({\n    authorizationParams: {\n      redirect_uri: 'http://localhost:3000/'\n    }\n  }).then(token => {\n    //logged in. you can get the user profile like this:\n    auth0.getUser().then(user => {\n      console.log(user);\n    });\n  });\n});\n```\n\n### Call an API\n\nTo call your API, start by getting the user's Access Token. Then use the Access Token in your request. In this example, the `getTokenSilently` method is used to retrieve the Access Token:\n\n`<button id=\"callApi\">Call an API</button>`\n\n#### Use async/await\n\n```\ndocument.getElementById('callApi').addEventListener('click', async () => {\n  const accessToken = await auth0.getTokenSilently();\n  const result = await fetch('https://exampleco.com/api', {\n    method: 'GET',\n    headers: {\n      Authorization: 'Bearer ' + accessToken\n    }\n  });\n  const data = await result.json();\n  console.log(data);\n});\n```\n\n#### Use promises\n\n```\ndocument.getElementById('callApi').addEventListener('click', () => {\n  auth0\n    .getTokenSilently()\n    .then(accessToken =>\n      fetch('https://exampleco.com/api', {\n        method: 'GET',\n        headers: {\n          Authorization: 'Bearer ' + accessToken\n        }\n      })\n    )\n    .then(result => result.json())\n    .then(data => {\n      console.log(data);\n    });\n});\n```\n\n### Logout\n\nAdd a button users can click to logout:\n\n`<button id=\"logout\">Logout</button>`\n\n```\n$('#logout').click(async () => {\n  auth0.logout({\n    logoutParams: {\n      returnTo: 'http://localhost:3000/'\n    }\n  });\n});\n```\n\n### Change storage options\n\nThe Auth0 SPA SDK stores tokens in memory by default. However, this does not provide persistence across page refreshes and browser tabs. Instead, you can opt-in to store tokens in local storage by setting the `cacheLocation` property to `localstorage` when initializing the SDK. This can help to mitigate some of the effects of browser privacy technology that prevents access to the Auth0 session cookie by storing Access Tokens for longer.\n\nto configure this snippet with your account\n\n```\nconst auth0 = await createAuth0Client({\n  domain: '{yourDomain}',\n  clientId: '{yourClientId}',\n  cacheLocation: 'localstorage'\n});\n```\n\n### Use rotating Refresh Tokens\n\nThe Auth0 SPA SDK can be configured to use [rotating Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation) to get new access tokens silently. These can be used to bypass browser privacy technology that prevents access to the Auth0 session cookie when authenticating silently, as well as providing built-in reuse detection.\n\nConfigure the SDK to do this by setting `useRefreshTokens` to `true` on initialization:\n\nto configure this snippet with your account\n\n```\nconst auth0 = await createAuth0Client({\n  domain: '{yourDomain}',\n  clientId: '{yourClientId}',\n  useRefreshTokens: true\n});\n\n// Request a new access token using a refresh token\nconst token = await auth0.getTokenSilently();\n```\n\nRefresh Tokens will also need to be [configured for your tenant](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation) before they can be used in your SPA.\n\nOnce configured, the SDK will request the `offline_access` scope during the authorization step. Furthermore, `getTokenSilently` will then call the `/oauth/token` endpoint directly to exchange refresh tokens for access tokens. The SDK will obey the storage configuration when storing refresh tokens. If the SDK has been configured using the default in-memory storage mechanism, refresh tokens will be lost when refreshing the page.\n\n## Usage\n\nBelow are examples of usage for various methods in the SDK. Note that jQuery is used in these examples.\n\n### Login with redirect\n\nRedirect to the `/authorize` endpoint at Auth0, starting the [Universal Login](https://auth0.com/docs/universal-login) flow:\n\n```\n$('#loginRedirect').click(async () => {\n  await auth0.loginWithRedirect({\n    authorizationParams: {\n      redirect_uri: 'http://localhost:3000/'\n    }\n  });\n});\n```\n\nUse a popup window to log in using the Universal Login page:\n\n```\n$('#loginPopup').click(async () => {\n  await auth0.loginWithPopup();\n});\n```\n\nIf the user takes longer than the default timeout of 60 seconds to complete the authentication flow, the authentication will be interrupted, and you will need to catch the error in your code to either:\n\nSuggest that the user retry and close the popup manually using `error.popup.close`:\n\n```\n$('#loginPopup').click(async () => {\n  try {\n    await auth0.loginWithPopup();\n  } catch {error}\n  if (error instanceof auth0.PopupTimeoutError) {\n    // custom logic to inform user to retry\n    error.popup.close();\n  }\n});\n```\n\nOr create a custom `popup` option in the `options` object:\n\n```\n$('#loginPopup').click(async () => {\n  const popup = window.open(\n    '',\n    'auth0:authorize:popup',\n    'left=100,top=100,width=400,height=600,resizable'\n  );\n  try {\n    await auth0.loginWithPopup({ popup });\n  } catch {error}\n  if (error instanceof auth0.PopupTimeoutError) {\n    // custom logic to inform user to retry\n    error.popup.close();\n  }\n});\n```\n\n### Login with redirect callback\n\nWhen the browser is redirected from Auth0 back to your SPA, `handleRedirectCallback` must be called in order to complete the login flow:\n\n```\n$('#loginRedirectCallback').click(async () => {\n  await auth0.handleRedirectCallback();\n});\n```\n\n### Get Access Token with no interaction\n\nGet a new Access Token silently using either a hidden iframe and `prompt=none`, or by using a rotating Refresh Token. Refresh Tokens are used when `useRefreshTokens` is set to `true` when configuring the SDK.\n\nIf in-memory storage (the default) and refresh tokens are used, new tokens are retrieved using a web worker on supported browsers:\n\n```\n$('#getToken').click(async () => {\n  const token = await auth0.getTokenSilently();\n});\n```\n\nThe `getTokenSilently()` method requires you to have **Allow Skipping User Consent** enabled in your [API Settings in the Dashboard](https://manage.auth0.com/#/apis). Additionally, user consent [cannot be skipped on 'localhost'](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications).\n\nAccess Tokens can also be retrieved using a popup window. Unlike `getTokenSilently`, this method of retrieving an Access Token will work in browsers where third-party cookies are blocked by default:\n\n```\n$('#getTokenPopup').click(async () => {\n  const token = await auth0.getTokenWithPopup({\n    authorizationParams: {\n      audience: 'https://mydomain/api/',\n      scope: 'read:rules'\n    }\n  });\n});\n```\n\n### Get Access Token for a different audience\n\nOptions may be passed to `getTokenSilently` that get an Access Token with a different audience and scope of that which was requested at user authentication time.\n\n```\n$('#getToken_audience').click(async () => {\n  const differentAudienceOptions = {\n    authorizationParams: {\n      audience: 'https://mydomain/another-api/',\n      scope: 'read:rules',\n      redirect_uri: 'http://localhost:3000/callback.html'\n    }\n  };\n  const token = await auth0.getTokenSilently(differentAudienceOptions);\n});\n```\n\n### Get user\n\nYou can get the authenticated user's profile data by calling the `getUser` method:\n\n```\n$('#getUser').click(async () => {\n  const user = await auth0.getUser();\n});\n```\n\n### Get ID Token claims\n\nYou can get the claims of the authenticated user's ID Token by calling the `getIdTokenClaims` method:\n\n```\n$('#getIdTokenClaims').click(async () => {\n  const claims = await auth0.getIdTokenClaims();\n  // if you need the raw id_token, you can access it\n  // using the __raw property\n  const id_token = claims.__raw;\n});\n```\n\n### Logout (default)\n\nYou can initiate a logout action by calling the `logout` method:\n\n```\n$('#logout').click(async () => {\n  auth0.logout({\n    logoutParams: {\n      returnTo: 'http://localhost:3000/'\n    }\n  });\n});\n```\n\n### Logout with no client ID\n\nYou can initiate a logout action with no Client ID specified by calling the `logout` method and including `clientId: null`:\n\n```\n$('#logoutNoClientId').click(async () => {\n  auth0.logout({\n    clientId: null,\n    logoutParams: {\n      returnTo: 'http://localhost:3000/'\n    }\n  });\n});\n```\n\n## Learn more\n\n*   [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens)",
  "title": "Auth0 Single Page App SDK",
  "description": "Auth0 SDK for single page applications using Authorization Code Grant Flow with PKCE.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/applications/enable-android-app-links",
  "markdown": "# Enable Android App Links Support\n\n[Android App Links](https://developer.android.com/training/app-links) allow an application to designate itself as the default handler of a given type of link. For example, clicking a URL in an email would open the link in the designated application. This guide will show you how to enable Android App links support for your Auth0-registered application using Auth0's Dashboard.\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select the name of the application to view.\n    \n    ![Dashboard Applications List](https://images.ctfassets.net/cdy7uua7fh8z/1ecNwGgFQZxdP57p0tp3jT/d6796b8b909d0db1d4dd7d5e0487776a/dashboard-applications-applications-list.png)\n2.  Scroll to the bottom of the **Settings** page, and select **Show Advanced Settings**.\n    \n3.  Select **Device Settings**, provide the [App Package Name](https://developer.android.com/studio/build/application-id) and the SHA256 fingerprints of your app’s signing certificate for your Android application, and select **Save Changes**.\n    \n    ![Dashboard Applications Application Settings Tab Advanced Settings Device Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/YKKPtWtswHn2FZGFSVWNw/3af8af94d510abe6db83ac36c5407402/dashboard-applications-applications-settings-advanced-device-settings.png)\n\nYou can use the following command to generate the fingerprint using the Java keytool in your terminal: `keytool -list -v -keystore my-release-key.keystore`\n\nTo learn more about signing certificates, see Android's [Sign Your App](https://developer.android.com/studio/publish/app-signing.html) developer documentation.\n\n## Test link\n\n1.  Navigate to the following URL in your browser: `https://{yourDomain}/.well-known/assetlinks.json`\n    \n2.  If the link is successful, you will return the following JSON (formatted for readability):\n    \n    ```\n    [{\n      \"relation\": [\"delegate_permission/common.handle_all_urls\"],\n      \"target\": {\n        \"namespace\": \"android_app\",\n        \"package_name\": \"com.mycompany.app1\",\n        \"sha256_cert_fingerprints\":\n        [\"14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5\"]\n      }\n    }]\n    ```\n    \n\nTo learn more about testing your app link, read [Verify Android App Links](https://developer.android.com/training/app-links/verify-site-associations) at [https://developer.android.com](https://developer.android.com/).",
  "title": "Enable Android App Links Support",
  "description": "Describes how to enable Android App Links support for your Auth0 application using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/logout/guides/logout-auth0",
  "markdown": "# Log Users Out of Auth0 with OIDC Endpoint\n\nAuth0 implements OpenID Connect’s [RP-Initiated Logout 1.0](https://openid.net/specs/openid-connect-rpinitiated-1_0.html) for end-user logout. This standard is part of the OpenID Connect collection of [final specifications](https://openid.net/developers/specs/).\n\n## How it works\n\nRP-Initiated Logout is a scenario in which a relying party (user) requests the OpenID provider (Auth0) to log them out.\n\n1.  The user initiates a logout request in your application.\n    \n2.  Your application directs the user to the Auth0 Authentication API [OIDC Logout](https://auth0.com/docs/api/authentication#oidc-logout) endpoint.\n    \n3.  Auth0 redirects the user to the appropriate destination based on the provided [OIDC Logout endpoint parameters](#oidc-logout-endpoint-parameters).\n    \n\n## Configure RP-Initiated Logout\n\nTo configure RP-Initiated Logout, you must ensure that your application can find the `end_session_endpoint` parameter in your Auth0 tenant’s [discovery metadata document](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig), and that it calls the OIDC Logout endpoint with the necessary parameters.\n\n### Enable endpoint discovery\n\nYou can enable **RP-Initiated Logout End Session Endpoint Discovery** in the Auth0 Dashboard or with the Auth0 Management API.\n\nTo enable **RP-Initiated Logout End Session Endpoint Discovery** in the Dashboard:\n\n1.  Go to [Dashboard > Settings > Advanced](https://manage.auth0.com/#/tenant/advanced).\n    \n2.  Locate the **Login and Logout** section.\n    \n3.  Enable the **RP-Initiated Logout End Session Endpoint Discovery** toggle.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/7LbKkydtLUOXtzzNxNqI8p/624e66f985d55c2c7a56e90f68a2011a/RP-Initiated_Logout_End_Session_Endpoint_Discovery.png)\n\n### Call the OIDC Logout endpoint\n\nWhen you call the OIDC Logout endpoint, Auth0 recommends that you provide the `id_token_hint` parameter.\n\nIf your application cannot securely store ID tokens, you may provide the `logout_hint` and `client_id` parameters instead.\n\n#### OIDC Logout endpoint parameters\n\nThe Authentication API [OIDC Logout](https://auth0.com/docs/api/authentication#oidc-logout) endpoint supports the following parameters:\n\n| **Parameter** | **Required?** | **Description** |\n| --- | --- | --- |\n| `id_token_hint` | Recommended | ID token previously issued for the user. That indicates which user to log out. |\n| `logout_hint` | Optional | Session ID (`sid`) value that indicates which user to log out. |\n| `post_logout_redirect_uri` | Optional | Redirect URL value that indicates where to redirect the user after logout. |\n| `client_id` | Optional | Client ID of your application. |\n| `federated` | Optional | Directs Auth0 to log the user out of their identity provider. |\n| `state` | Optional | Opaque value that the application adds to the initial logout request, and that Auth0 includes when redirecting the back to the `post_logout_redirect_uri`. |\n| `ui_locales` | Optional | Space-delimited list of locales used to constrain the language list for the request. The first locale on the list must match the enabled locale in your tenant. |\n\n#### id\\_token\\_hint parameter\n\nThe value of the `id_token_hint` parameter must be the ID token that Auth0 issued to the user after they authenticated.\n\nThe ID token contains the registered claims issuer (`iss`), audience (`aud`), and the Auth0 session ID (`sid`) for verification. To learn more about ID token claims, read [ID Token Structure](https://auth0.com/docs/secure/tokens/id-tokens/id-token-structure).\n\n##### Examples\n\n```\nhttps://{yourDomain}/oidc/logout?id_token_hint={yourIdToken}&post_logout_redirect_uri={yourCallbackUrl}\n```\n\n#### logout\\_hint parameter\n\nThe value of the `logout_hint` parameter must be the session ID (`sid`) of the user’s current Auth0 session.\n\nThe session ID (`sid`) is provided as a registered claim within the ID token that Auth0 issued to the user after they authenticated.\n\n##### Example\n\nto configure this snippet with your account\n\n```\nhttps://{yourDomain}/oidc/logout?{clientId}={yourClientId}&logout_hint={sessionId}\n```\n\n#### post\\_logout\\_redirect\\_uri parameter\n\nThe value of the `post_logout_redirect_uri` parameter must be a valid, encoded URL that has been registered in the list of **Allowed Logout URLs** in your:\n\n1.  [Application settings](https://auth0.com/docs/get-started/applications/application-settings#application-uris): If you provide the `id_token_hint` parameter, or the `logout_hint` and `client_id` parameters.\n    \n2.  [Tenant settings](https://auth0.com/docs/get-started/tenant-settings#login-and-logout): If you provide only the `logout_hint` parameter.\n    \n\n##### Example\n\n```\nhttps://{yourDomain}/oidc/logout?post_logout_redirect_uri=http%3A%2F%2Fwww.example.com\n```\n\n##### Update application Allowed Logout URLs\n\nYou can register a URL with your application’s list of **Allowed Logout URLs** in the Auth0 Dashboard or with the Auth0 Management API.\n\nTo register a URL with your application’s list of **Allowed Logout URLs** in the Dashboard:\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Select your application.\n    \n3.  Locate the **Application URIs** section.\n    \n4.  Update **Allowed Logout URLs** following the [provided guidelines](#allowed-logout-urls-guidelines).\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/56qLkA7NxiRyg3sJGVVGfZ/d4f3e191d2673c06271f921781e4441a/Application_URIs.png)\n\n##### Update tenant Allowed Logout URLs\n\nYou can register a URL with your tenant’s list of **Allowed Logout URLs** in the Auth0 Dashboard or with the Auth0 Management API.\n\nTo register a URL with your tenant’s list of **Allowed Logout URLs** in the Dashboard:\n\n1.  Go to [Dashboard > Settings > Advanced](https://manage.auth0.com/#/tenant/advanced).\n    \n2.  Locate the **Login and Logout** section.\n    \n3.  Update **Allowed Logout URLs** following the [provided guidelines](#allowed-logout-urls-guidelines).\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/2IRcKtTbTkE6q3GmbLxMyi/ad3905136ddfdcd4bfec5ed95a09d65a/OIDC_Logout_-_Show_RP-Initiated_Logout_End-User_Consent.png)\n\n##### Allowed Logout URLs guidelines\n\nWhen you update **Allowed Logout URLs**, follow the guidelines below to avoid validation errors:\n\n*   Separate multiple URL values with a comma (`,`).\n    \n*   Include the URL scheme part (for example, `https://`).\n    \n\nYou may use an asterisk (`*`) as a wildcard for subdomains (such as `https://*.example.com`), but we recommend that you do not use wildcards in production environments. For more information, read [Subdomain URL Placeholders](https://auth0.com/docs/get-started/applications/wildcards-for-subdomains#wildcard-url-placeholders).\n\n##### Add query string parameters to post\\_logout\\_redirect\\_uri\n\nThe OIDC Logout endpoint parses query string parameters in the URL provided to the `post_logout_redirect_uri` parameter.\n\nYou must include these query string parameters in your **Allowed Logout URLs**, or the logout request may be denied.\n\nFor example, if you pass `https://example.com/logout?myParam=1234` to the `post_logout_redirect_uri` parameter (encoded as `https%3A%2F%2Fexample.com%2Flogout%3FmyParam%3D1234`), you must include `https://example.com/logout?myParam` in your **Allowed Logout URLs**. \n\n#### ui\\_locales parameter\n\nThe value of the `ui_locales` parameter must be a space-delimited list of [supported locales](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization#new-universal-login-experience-localization). \n\nThe first value provided in the list must match your [tenant’s Default Language setting](https://auth0.com/docs/get-started/tenant-settings#languages).\n\n#### federated parameter\n\nThe `federated` parameter does not require a value.\n\nIf you include the federated parameter when you call the OIDC Logout endpoint, Auth0 attempts to [log the user out of their identity provider](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps).\n\n## Logout consent prompt\n\nThe OIDC standard defines that the logout flow should be interrupted to prompt the user for consent if the OpenID provider cannot verify that the request was made by the user.\n\nAuth0 enforces this behavior by displaying a logout consent prompt if it detects any of the following conditions:\n\n*   Neither the `id_token_hint` nor `logout_hint` parameters are provided.\n    \n*   The ID token's `sid` claim does not correspond to the browser session in the request.\n    \n*   The value of the `logout_hint` parameter does not match current session data.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/5Sycg1aMJ1CLZwJj19Omv4/2c19a5923369354cdc0617fdd521707a/Logout_Prompt.png)\n\nIf the user confirms the logout request, Auth0 continues the logout flow.\n\n### Disable the logout consent prompt\n\nYou may disable the logout consent prompt. If you do, Auth0 does not attempt to detect anomalous behavior and accepts logout requests automatically.\n\nTo disable the logout consent prompt in the Dashboard:\n\n1.  Go to [Dashboard > Settings > Advanced](https://manage.auth0.com/#/tenant/advanced).\n    \n2.  Disable the **Show RP-Initiated Logout End-User Confirmation** toggle.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/37K4hLjhSBMGvdGP9OEP7W/05c2a3cbc438a86b5f24fd9942782272/Tenant_-_Advanced_-_Login_and_Logout_-_Logout_Consent_Prompt_disabled.png)\n\n## Learn more\n\n*   [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications)\n*   [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n*   [Redirect Users with Alternative Logout](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout)",
  "title": "Log Users Out of Auth0 with OIDC Endpoint",
  "description": "Learn how to log user out with the OIDC Logout Endpoint.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/ionic-vue",
  "markdown": "# Auth0 Ionic & Capacitor (Vue) SDK Quickstarts: Login\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Native/Mobile App](https://auth0.com/docs/quickstart/native)\n*   [Ionic & Capacitor (Vue)](https://auth0.com/docs/quickstart/native/ionic-vue)\n\nThis tutorial demonstrates how to add user login with Auth0 to an Ionic Vue & Capacitor application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Node & Npm (LTS) | XCode 12+ (for iOS) | Android Studio 4+ (for Android)\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\nGo to the [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings) section in your Auth0 dashboard and set your **Callback URL** in the **Allowed Callback URLs** box.\n\nYou should set the **Allowed Callback URL** to:\n\n```\nYOUR_PACKAGE_ID://{yourDomain}/capacitor/YOUR_PACKAGE_ID/callback\n```\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\nYou should set the **Allowed Logout URLs** to\n\n```\nYOUR_PACKAGE_ID://{yourDomain}/capacitor/YOUR_PACKAGE_ID/callback\n```\n\n### Configure Origins\n\nTo be able to make requests from your application to Auth0, set the following **Allowed Origins** in your [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\n```\ncapacitor://localhost, http://localhost\n```\n\nThese origins are required for iOS and Android respectively.\n\nLastly, be sure that the **Application Type** for your application is set to **Native** in the [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\n## Install the Auth0 Vue SDK\n\nRun the following command within your project directory to install the Auth0 Vue SDK:\n\n```\nnpm install @auth0/auth0-vue\n```\n\nThe SDK exposes several types that help you integrate Auth0 with your Vue application idiomatically, including a module and an authentication service.\n\n### Install Capacitor plugins\n\nThis quickstart and sample make use of some of Capacitor's official plugins. Install these into your app using the following command:\n\n```\nnpm install @capacitor/browser @capacitor/app\n```\n\n*   [`@capacitor/browser`](https://capacitorjs.com/docs/apis/browser) - allows you to interact with the device's system browser and is used to open the URL to Auth0's authorizaction endpoint\n*   [`@capacitor/app`](https://capacitorjs.com/docs/apis/app) - allows you to subscribe to high-level app events, useful for handling callbacks from Auth0\n\n### Configure the createAuth0 plugin\n\nThe SDK exports `createAuth0`, a composable that contains all the services required for the SDK to function. To register this with your application:\n\nOpen `src/main.ts` and install the plugin using `app.use`\n\n```\nimport { createApp } from \"vue\";\nimport App from \"./App.vue\";\nimport router from \"./router\";\n\nimport { IonicVue } from \"@ionic/vue\";\n\nimport { createAuth0 } from \"@auth0/auth0-vue\";\nimport config from \"./auth.config\";\n\n// ..\n\n// Build the URL that Auth0 should redirect back to\nconst redirect_uri = `${config.appId}://{yourDomain}/capacitor/${config.appId}/callback`;\n\nconst app = createApp(App).use(IonicVue).use(router);\n\napp.use(\n  createAuth0({\n    domain: \"{yourDomain}\",\n    clientId: \"{yourClientId}\",\n    useRefreshTokens: true,\n    useRefreshTokensFallback: false,\n    authorizationParams: {\n      redirect_uri\n    }\n  })\n);\n\nrouter.isReady().then(() => {\n  app.mount(\"#app\");\n});\n```\n\nThe `createAuth0` plugin takes the following props:\n\n*   `domain`: The \"domain\" value present under the \"Settings\" of the application you created in your Auth0 dashboard, or your custom domain if using Auth0's [Custom Domains feature](http://localhost:3000/docs/custom-domains)\n*   `clientId`: The \"client ID\" value present under the \"Settings\" of the application you created in your Auth0 dashboard\n*   `useRefreshTokens`: To use auth0-vue with Ionic on Android and iOS, it's required to enable refresh tokens.\n*   `useRefreshTokensFallback`: To use auth0-vue with Ionic on Android and iOS, it's required to disable the iframe fallback.\n*   `authorizationParams.redirect_uri`: The URL to where you'd like to redirect your users after they authenticate with Auth0.\n\n### Checkpoint\n\nNow that you have configured `createAuth0` plugin, run your application to verify that the SDK is initializing correctly, and your application is not throwing any errors related to Auth0.\n\n## Add Login to Your Application\n\nAdd a new file `LoginButton.vue` with the following code:\n\n```\n<template>\n  <ion-button @click=\"login\">Log in</ion-button>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from \"vue\";\nimport { IonApp, IonRouterOutlet } from \"@ionic/vue\";\n\nimport { useAuth0 } from \"@auth0/auth0-vue\";\nimport { App as CapApp } from \"@capacitor/app\";\nimport { Browser } from \"@capacitor/browser\";\n\nexport default defineComponent({\n  components: {\n    IonButton,\n  },\n  setup() {\n    const { loginWithRedirect } = useAuth0();\n\n    const login = async () => {\n      await loginWithRedirect({\n        openUrl: (url: string) =>\n          Browser.open({\n            url,\n            windowName: \"_self\",\n          }),\n      });\n    };\n\n    return { login };\n  },\n});\n</script>\n```\n\nThis component:\n\n*   defines a template with a simple button that logs the user in when clicked\n*   uses `loginWithRedirect` to login using Auth0's Universal Login page\n*   uses the `openUrl` callback to use Capacitor's Browser plugin to open the URL and show the login page to the user\n\n### Handling the callback\n\nOnce users logs in with the Universal Login Page, they redirect back to your app via a URL with a custom URL scheme. The `appUrlOpen` event must be handled within your app. You can call the `handleRedirectCallback` method from the Auth0 SDK to initialize the authentication state.\n\nYou can only use this method on a redirect from Auth0. To verify success, check for the presence of the `code` and `state` parameters in the URL.\n\nThe `Browser.close()` method should close the browser when this event is raised.\n\nAdd the following capacitor application listener to your main `App` component:\n\n```\n<template>\n  <ion-app>\n    <ion-router-outlet />\n  </ion-app>\n</template>\n\n<script lang=\"ts\">\nimport { useAuth0 } from \"@auth0/auth0-vue\";\nimport { IonApp, IonRouterOutlet } from \"@ionic/vue\";\nimport { defineComponent } from \"vue\";\nimport { App as CapApp } from \"@capacitor/app\";\nimport { Browser } from \"@capacitor/browser\";\n\nexport default defineComponent({\n  name: \"App\",\n  components: {\n    IonApp,\n    IonRouterOutlet,\n  },\n  setup() {\n    const { handleRedirectCallback } = useAuth0();\n\n    // Handle the 'appUrlOpen' event and call `handleRedirectCallback`\n    CapApp.addListener('appUrlOpen', async ({ url }) => {\n      if (url.includes('state') && (url.includes('code') || url.includes('error'))) {\n        await handleRedirectCallback(url);\n      }\n      // No-op on Android\n      await Browser.close();\n    });\n  },\n});\n</script>\n```\n\n### Checkpoint\n\nAdd the `LoginButton` component to your application, as well as the handler for the \"appUrlOpen\" event to your `App` component. When you click the login button, verify that your application redirects you to the Auth0 Universal Login Page and that you can now log in or sign up using a username and password or a social provider.\n\nOnce that's complete, verify that Auth0 redirects you back to your application.\n\n## Add Logout to Your Application\n\nNow that users can log in, you need to configure [a way to log out](https://auth0.com/docs/logout/guides/logout-auth0). Users must redirect to the Auth0 logout endpoint in the browser to clear their browser session. Again, Capacitor's Browser plugin should perform this redirect so that the user does not leave your app and receive a suboptimal experience.\n\nTo achieve this with Ionic and Capacitor in conjunction with the Auth0 SDK:\n\n*   Construct the URL for your app Auth0 should use to redirect to after logout. This is a URL that uses your registered custom scheme and Auth0 domain. Add it to your **Allowed Logout URLs** configuration in the Auth0 Dashboard\n*   Logout from the SDK by calling `logout`, and pass your redirect URL back as the `logoutParams.returnTo` parameter.\n*   Set the `openUrl` parameter to a callback that uses the Capacitor browser plugin to open the URL using `Browser.open`.\n\nCreate a new file `LogoutButton.vue` and add the following code to the file. Then, add the `LogoutButton` component to your app.\n\n```\n<template>\n  <ion-button @click=\"onLogout\">Log out</ion-button>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from \"vue\";\nimport { useAuth0 } from \"@auth0/auth0-vue\";\nimport { Browser } from \"@capacitor/browser\";\nimport { IonButton } from \"@ionic/vue\";\nimport { callbackUri } from \"../auth.config\";\n\nexport default defineComponent({\n  components: {\n    IonButton,\n  },\n  setup() {\n    const { logout } = useAuth0();\n\n    const onLogout = async () => {\n      await logout({\n        logoutParams: {\n          returnTo: callbackUri,\n        },\n        openUrl: (url: string) =>\n          Browser.open({\n            url,\n            windowName: \"_self\",\n          }),\n      });\n    };\n\n    return {\n      onLogout,\n    };\n  },\n});\n</script>\n```\n\n### Checkpoint\n\nAdd the `LogoutButton` component to your application. When you click it, verify that your Ionic application redirects you the address you specified as one of the \"Allowed Logout URLs\" in the \"Settings\" and that you are no longer logged in to your application.\n\n## Show User Profile Information\n\nThe Auth0 Vue SDK helps you retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with logged-in users quickly in whatever component you need, such as their name or profile picture, to personalize the user interface. The profile information is available through the `user` property exposed by the `useAuth0()` composable. Take this `UserProfile` component as an example of how to use it:\n\n```\n<template>\n  <div v-if=\"isLoading\">Loading ...</div>\n  <div v-else-if=\"!user\"></div>\n  <div v-else class=\"profile-container\">\n    <ion-avatar>\n      <img :src=\"user.picture\" :alt=\"user.name\" />\n    </ion-avatar>\n    <h2>{{ user.name }}</h2>\n    <p>{{ user.email }}</p>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from \"vue\";\nimport { useAuth0 } from \"@auth0/auth0-vue\";\nimport { IonAvatar } from \"@ionic/vue\";\n\nexport default defineComponent({\n  components: {\n    IonAvatar,\n  },\n  setup() {\n    const { user, isLoading } = useAuth0();\n\n    return { user, isLoading };\n  },\n});\n</script>\n```\n\nThe `user` property contains sensitive information and artifacts related to the user's identity. As such, its availability depends on the user's authentication status. To prevent any render errors, use the `isAuthenticated` property from `useAuth0()` to check if Auth0 has authenticated the user before Vue renders any component that consumes the `user` property. Ensure that the SDK has completed loading before accessing the `isAuthenticated` property, by checking that `isLoading` is `false`.\n\n### Checkpoint\n\nAdd the `UserProfile` component to your application, and verify that you can display the `user.name` or [any other `user` property](https://auth0.com/docs/users/references/user-profile-structure#user-profile-attributes) within a component correctly after you have logged in.",
  "title": "Auth0 Ionic & Capacitor (Vue) SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login with Auth0 to an Ionic Vue & Capacitor application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/ionic-react",
  "markdown": "# Auth0 Ionic & Capacitor (React) SDK Quickstarts: Login\n\nThis tutorial demonstrates how to add user login with Auth0 to an Ionic React & Capacitor application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Node & Npm (LTS) | XCode 12+ (for iOS) | Android Studio 4+ (for Android) | React 18\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\nGo to the [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings) section in your Auth0 dashboard and set your **Callback URL** in the **Allowed Callback URLs** box.\n\nYou should set the **Allowed Callback URL** to:\n\n```\nYOUR_PACKAGE_ID://{yourDomain}/capacitor/YOUR_PACKAGE_ID/callback\n```\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\nYou should set the **Allowed Logout URLs** to\n\n```\nYOUR_PACKAGE_ID://{yourDomain}/capacitor/YOUR_PACKAGE_ID/callback\n```\n\n### Configure Origins\n\nTo be able to make requests from your application to Auth0, set the following **Allowed Origins** in your [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\n```\ncapacitor://localhost, http://localhost\n```\n\nThese origins are required for iOS and Android respectively.\n\nLastly, be sure that the **Application Type** for your application is set to **Native** in the [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings).\n\n## Install the Auth0 React SDK\n\nRun the following command within your project directory to install the Auth0 React SDK:\n\n```\nnpm install @auth0/auth0-react\n```\n\nThe SDK exposes methods and variables that help you integrate Auth0 with your React application idiomatically using [React Hooks](https://reactjs.org/docs/hooks-overview.html) or [Higher-Order Components](https://reactjs.org/docs/higher-order-components.html).\n\n### Install Capacitor plugins\n\nThis quickstart and sample make use of some of Capacitor's official plugins. Install these into your app using the following command:\n\n```\nnpm install @capacitor/browser @capacitor/app\n```\n\n*   [`@capacitor/browser`](https://capacitorjs.com/docs/apis/browser) - allows you to interact with the device's system browser and is used to open the URL to Auth0's authorizaction endpoint\n*   [`@capacitor/app`](https://capacitorjs.com/docs/apis/app) - allows you to subscribe to high-level app events, useful for handling callbacks from Auth0\n\n### Configure the Auth0Provider component\n\nUnder the hood, the Auth0 React SDK uses [React Context](https://reactjs.org/docs/context.html) to manage the authentication state of your users. One way to integrate Auth0 with your React app is to wrap your root component with an `Auth0Provider` that you can import from the SDK.\n\nOpen `src/index.tsx` and wrap the `App` component in the `Auth0Provider` component.\n\n```\nimport React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport { Auth0Provider } from '@auth0/auth0-react';\nimport App from './App';\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(\n  <Auth0Provider\n    domain=\"{yourDomain}\"\n    clientId=\"{yourClientId}\"\n    useRefreshTokens={true}\n    useRefreshTokensFallback={false}\n    authorizationParams={{\n      redirect_uri: \"YOUR_PACKAGE_ID://{yourDomain}/capacitor/YOUR_PACKAGE_ID/callback\"\n    }}\n  >\n    <App />\n  </Auth0Provider>\n);\n```\n\nThe `Auth0Provider` component takes the following props:\n\n*   `domain`: The \"domain\" value present under the \"Settings\" of the application you created in your Auth0 dashboard, or your custom domain if using Auth0's [Custom Domains feature](http://localhost:3000/docs/custom-domains)\n*   `clientId`: The \"client ID\" value present under the \"Settings\" of the application you created in your Auth0 dashboard\n*   `useRefreshTokens`: To use auth0-react with Ionic on Android and iOS, it's required to enable refresh tokens.\n*   `useRefreshTokensFallback`: To use auth0-react with Ionic on Android and iOS, it's required to disable the iframe fallback.\n*   `authorizationParams.redirect_uri`: The URL to where you'd like to redirect your users after they authenticate with Auth0.\n\n### Checkpoint\n\nNow that you have configured `Auth0Provider`, run your application to verify that the SDK is initializing correctly, and your application is not throwing any errors related to Auth0.\n\n## Add Login to Your Application\n\nAdd a new file `LoginButton.tsx` with the following code:\n\n```\nimport { useAuth0 } from '@auth0/auth0-react';\nimport { Browser } from '@capacitor/browser';\nimport { IonButton } from '@ionic/react';\n\nconst LoginButton: React.FC = () => {\n  const { loginWithRedirect } = useAuth0();\n\n  const login = async () => {\n    await loginWithRedirect({\n      async openUrl(url) {\n         // Redirect using Capacitor's Browser plugin\n        await Browser.open({\n          url,\n          windowName: \"_self\"\n        });\n      }\n    });\n  };\n\n  return <IonButton onClick={login}>Log in</IonButton>;\n};\n\nexport default LoginButton;\n```\n\nThis component:\n\n*   defines a template with a simple button that logs the user in when clicked\n*   uses `loginWithRedirect` to login using Auth0's Universal Login page\n*   uses the `openUrl` callback to use Capacitor's Browser plugin to open the URL and show the login page to the user\n\n### Handling the callback\n\nOnce users logs in with the Universal Login Page, they redirect back to your app via a URL with a custom URL scheme. The `appUrlOpen` event must be handled within your app. You can call the `handleRedirectCallback` method from the Auth0 SDK to initialize the authentication state.\n\nYou can only use this method on a redirect from Auth0. To verify success, check for the presence of the `code` and `state` parameters in the URL.\n\nThe `Browser.close()` method should close the browser when this event is raised.\n\nAdd the following `useEffect` hook to your main `App` component:\n\n```\n// Import Capacitor's app and browser plugins, giving us access to `addListener` and `appUrlOpen`,\n// as well as the bits needed for Auth0 and React\nimport { App as CapApp } from '@capacitor/app';\nimport { Browser } from '@capacitor/browser';\nimport { useEffect } from 'react';\nimport { useAuth0 } from '@auth0/auth0-react';\n\n// ...\n\nconst App: React.FC = () => {\n  // Get the callback handler from the Auth0 React hook\n  const { handleRedirectCallback } = useAuth0();\n\n  useEffect(() => {\n    // Handle the 'appUrlOpen' event and call `handleRedirectCallback`\n    CapApp.addListener('appUrlOpen', async ({ url }) => {\n      if (url.includes('state') && (url.includes('code') || url.includes('error'))) {\n        await handleRedirectCallback(url);\n      }\n      // No-op on Android\n      await Browser.close();\n    });\n  }, [handleRedirectCallback]);\n\n  // ..\n};\n```\n\n### Checkpoint\n\nAdd the `LoginButton` component to your application, as well as the handler for the \"appUrlOpen\" event to your `App` component. When you click the login button, verify that your application redirects you to the Auth0 Universal Login Page and that you can now log in or sign up using a username and password or a social provider.\n\nOnce that's complete, verify that Auth0 redirects you back to your application.\n\n## Add Logout to Your Application\n\nNow that users can log in, you need to configure [a way to log out](https://auth0.com/docs/logout/guides/logout-auth0). Users must redirect to the Auth0 logout endpoint in the browser to clear their browser session. Again, Capacitor's Browser plugin should perform this redirect so that the user does not leave your app and receive a suboptimal experience.\n\nTo achieve this with Ionic and Capacitor in conjunction with the Auth0 SDK:\n\n*   Construct the URL for your app Auth0 should use to redirect to after logout. This is a URL that uses your registered custom scheme and Auth0 domain. Add it to your **Allowed Logout URLs** configuration in the Auth0 Dashboard\n*   Logout from the SDK by calling `logout`, and pass your redirect URL back as the `logoutParams.returnTo` parameter.\n*   Set the `openUrl` parameter to a callback that uses the Capacitor browser plugin to open the URL using `Browser.open`.\n\nCreate a new file `LogoutButton.tsx` and add the following code to the file. Then, add the `LogoutButton` component to your app.\n\n```\nimport { useAuth0 } from '@auth0/auth0-react';\nimport { Browser } from '@capacitor/browser';\nimport { IonButton } from '@ionic/react';\n\n// This should reflect the URL added earlier to your \"Allowed Logout URLs\" setting\n// in the Auth0 dashboard.\nconst logoutUri = 'YOUR_PACKAGE_ID://{yourDomain}/capacitor/YOUR_PACKAGE_ID/callback';\n\nconst LogoutButton: React.FC = () => {\n  const { logout } = useAuth0();\n\n  const doLogout = async () => {\n    await logout({\n      logoutParams: {\n        returnTo: logoutUri,\n      },\n      async openUrl(url) {\n         // Redirect using Capacitor's Browser plugin\n        await Browser.open({\n          url,\n          windowName: \"_self\"\n        });\n      }\n    });\n  };\n\n  return <IonButton onClick={doLogout}>Log out</IonButton>;\n};\n\nexport default LogoutButton;\n```\n\n### Checkpoint\n\nAdd the `LogoutButton` component to your application. When you click it, verify that your Ionic application redirects you the address you specified as one of the \"Allowed Logout URLs\" in the \"Settings\" and that you are no longer logged in to your application.\n\n## Show User Profile Information\n\nThe Auth0 React SDK helps you retrieve the [profile information](https://auth0.com/docs/users/concepts/overview-user-profile) associated with logged-in users quickly in whatever component you need, such as their name or profile picture, to personalize the user interface. The profile information is available through the `user` property exposed by the `useAuth0()` hook. Take this `Profile` component as an example of how to use it:\n\n```\nimport { useAuth0 } from '@auth0/auth0-react';\n\nconst Profile: React.FC = () => {\n  const { user, isLoading } = useAuth0();\n\n  // If the SDK is not ready, or a user is not authenticated, exit.\n  if (isLoading || !user) return null;\n\n  return (\n    <div>\n      <img src={user.picture} alt={user.name} />\n      <h2>{user.name}</h2>\n      <p>{user.email}</p>\n    </div>\n  );\n};\n\nexport default Profile;\n```\n\nThe `user` property contains sensitive information and artifacts related to the user's identity. As such, its availability depends on the user's authentication status. To prevent any render errors, use the `isAuthenticated` property from `useAuth0()` to check if Auth0 has authenticated the user before React renders any component that consumes the `user` property. Ensure that the SDK has completed loading before accessing the `isAuthenticated` property, by checking that `isLoading` is `false`.\n\n### Checkpoint\n\nAdd the `Profile` component to your application, and verify that you can display the `user.name` or [any other `user` property](https://auth0.com/docs/users/references/user-profile-structure#user-profile-attributes) within a component correctly after you have logged in.",
  "title": "Auth0 Ionic & Capacitor (React) SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login with Auth0 to an Ionic React & Capacitor application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/id-tokens/id-token-structure",
  "markdown": "# ID Token Structure\n\nID tokens follow the [JSON Web Token (JWT)](https://auth0.com/docs/secure/tokens/json-web-tokens) standard, which means that their basic structure conforms to the typical [JWT Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure), and they contain standard [JWT Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims) asserted about the token itself.\n\nBeyond what is required for JWT, ID tokens also contain claims asserted about the authenticated user, which are pre-defined by the OpenID Connect (OIDC) protocol, and are thus known as standard OIDC claims. Some standard OIDC claims include:\n\n*   `name`\n    \n*   `nickname`\n    \n*   `picture`\n    \n*   `email`\n    \n*   `email_verified`\n    \n\nFor a full list of standard OIDC claims, see [OIDC specification: Standard Claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). You can also create [custom claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims), which are claims that you define, control, and add to a token using Auth0 Actions.\n\nYou control which OIDC claims are included in the ID token consumed by your application by including specific [OpenID Connect Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes) in a parameter when you request tokens while authenticating users. To learn how to request an ID token, see [Get ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/get-id-tokens).\n\n## Sample ID Token\n\nThis example shows the contents of an ID token. Notice that the audience value (located in the `aud` claim) is set to the application's identifier, which means that only this specific application should consume the token. To learn more about the claims in this example, read [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims).\n\n```\n{\n  \"iss\": \"http://my-domain.auth0.com\",\n  \"sub\": \"auth0|123456\",\n  \"aud\": \"my_client_id\",\n  \"exp\": 1311281970,\n  \"iat\": 1311280970,\n  \"name\": \"Jane Doe\",\n  \"given_name\": \"Jane\",\n  \"family_name\": \"Doe\",\n  \"gender\": \"female\",\n  \"birthdate\": \"0000-10-31\",\n  \"email\": \"janedoe@example.com\",\n  \"picture\": \"http://example.com/janedoe/me.jpg\"\n}\n```\n\n## Learn more\n\n*   [Get ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/get-id-tokens)\n*   [Validate ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/validate-id-tokens)\n*   [Update ID Token Lifetime](https://auth0.com/docs/secure/tokens/id-tokens/update-id-token-lifetime)",
  "title": "ID Token Structure",
  "description": "Describes how ID tokens conform to the JWT standard and contain JWT claims asserted about the token itself, standard OIDC claims about the authenticated user, and custom claims that you define, control, and add to a token using a rule.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/aspnet-owin",
  "markdown": "# Auth0 ASP.NET (OWIN) SDK Quickstarts: Login\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Regular Web App](https://auth0.com/docs/quickstart/webapp)\n*   [ASP.NET (OWIN)](https://auth0.com/docs/quickstart/webapp/aspnet-owin)\n\nThis tutorial demonstrates how to add user login to an ASP.NET OWIN application. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Microsoft Visual Studio 2017 | Microsoft.Owin.Security.OpenIdConnect v4.1.0 and up\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n*   **Client Secret**\n\n## Configure Callback URLs\n\nThe Callback URL of your application is the URL where Auth0 will redirect to after the user has authenticated in order for the OWIN OpenID Connect middleware to complete the authentication process.\n\nYou will need to add this URL to the list of Allowed URLs for your application. The Callback URL for the seed project is `http://localhost:3000/callback`, so be sure to add this to the **Allowed Callback URLs** section of your application. Also, add `http://localhost:3000/` to the **Allowed Logout URLs**.\n\nIf you deploy your application to a different URL you will also need to ensure to add that URL to the **Allowed Callback URLs** and **Allowed Logout URLs**. The `web.config` in the sample projects also contain two keys named `auth0:RedirectUri` and `auth0:PostLogoutRedirectUri` with these URLs. Be sure to change those as well.\n\nThat's all you need to start working with Auth0!\n\n## Install and configure the OpenID Connect middleware\n\nThe easiest way to enable authentication with Auth0 in your ASP.NET MVC application is to use the OWIN OpenID Connect middleware, so install the `Microsoft.Owin.Security.OpenIdConnect` NuGet package first:\n\n```\nInstall-Package Microsoft.Owin.Security.OpenIdConnect\n```\n\nYou must also install the following middleware library to enable cookie authentication in your project:\n\n```\nInstall-Package Microsoft.Owin.Security.Cookies\n```\n\nNow go to the `Configuration` method of your `Startup` class and configure the cookie middleware as well as the Auth0 middleware.\n\n```\n// Startup.cs\nusing Microsoft.IdentityModel.Protocols.OpenIdConnect;\nusing Microsoft.IdentityModel.Tokens;\nusing Microsoft.Owin;\nusing Microsoft.Owin.Host.SystemWeb;\nusing Microsoft.Owin.Security;\nusing Microsoft.Owin.Security.Cookies;\nusing Microsoft.Owin.Security.OpenIdConnect;\nusing MvcApplication.Support;\nusing Owin;\n\npublic void Configuration(IAppBuilder app)\n{\n    // Configure Auth0 parameters\n    string auth0Domain = ConfigurationManager.AppSettings[\"auth0:Domain\"];\n    string auth0ClientId = ConfigurationManager.AppSettings[\"auth0:ClientId\"];\n    string auth0RedirectUri = ConfigurationManager.AppSettings[\"auth0:RedirectUri\"];\n    string auth0PostLogoutRedirectUri = ConfigurationManager.AppSettings[\"auth0:PostLogoutRedirectUri\"];\n\n    // Set Cookies as default authentication type\n    app.SetDefaultSignInAsAuthenticationType(CookieAuthenticationDefaults.AuthenticationType);\n    app.UseCookieAuthentication(new CookieAuthenticationOptions\n    {\n        AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,\n        LoginPath = new PathString(\"/Account/Login\"),\n\n        // Configure SameSite as needed for your app. Lax works well for most scenarios here but\n        // you may want to set SameSiteMode.None for HTTPS\n        CookieSameSite = SameSiteMode.Lax,\n\n        // More information on why the CookieManager needs to be set can be found here: \n        // https://github.com/aspnet/AspNetKatana/wiki/System.Web-response-cookie-integration-issues\n        CookieManager = new SameSiteCookieManager(new SystemWebCookieManager())\n    });\n\n    // Configure Auth0 authentication\n    app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions\n    {\n        AuthenticationType = \"Auth0\",\n\n        Authority = $\"https://{auth0Domain}\",\n\n        ClientId = auth0ClientId,\n\n        RedirectUri = auth0RedirectUri,\n        PostLogoutRedirectUri = auth0PostLogoutRedirectUri,\n        Scope = \"openid profile email\",\n        TokenValidationParameters = new TokenValidationParameters\n        {\n            NameClaimType = \"name\"\n        },\n\n        // More information on why the CookieManager needs to be set can be found here: \n        // https://docs.microsoft.com/en-us/aspnet/samesite/owin-samesite\n        CookieManager = new SameSiteCookieManager(new SystemWebCookieManager()),\n\n        // Configure Auth0's Logout URL by hooking into the RedirectToIdentityProvider notification, \n        // which is getting triggered before any redirect to Auth0 happens.\n        Notifications = new OpenIdConnectAuthenticationNotifications\n        {\n            RedirectToIdentityProvider = notification =>\n            {\n                // Only when the RequestType is OpenIdConnectRequestType.Logout should we configure the logout URL.\n                // Any other RequestType means a different kind of interaction with Auth0 that isn't logging out.\n                if (notification.ProtocolMessage.RequestType == OpenIdConnectRequestType.Logout)\n                {\n                    var logoutUri = $\"https://{auth0Domain}/v2/logout?client_id={auth0ClientId}\";\n\n                    var postLogoutUri = notification.ProtocolMessage.PostLogoutRedirectUri;\n                    if (!string.IsNullOrEmpty(postLogoutUri))\n                    {\n                        if (postLogoutUri.StartsWith(\"/\"))\n                        {\n                            // transform to absolute\n                            var request = notification.Request;\n                            postLogoutUri = request.Scheme + \"://\" + request.Host + request.PathBase + postLogoutUri;\n                        }\n                        logoutUri += $\"&returnTo={ Uri.EscapeDataString(postLogoutUri)}\";\n                    }\n\n                    notification.Response.Redirect(logoutUri);\n                    notification.HandleResponse();\n                }\n                return Task.FromResult(0);\n            }\n        }\n    });\n}\n```\n\nIt is essential that you register both the cookie middleware and the OpenID Connect middleware, as they are required (in that order) for the authentication to work. The OpenID Connect middleware will handle the authentication with Auth0. Once the user has authenticated, their identity will be stored in the cookie middleware.\n\nIn the code snippet above, note that the `AuthenticationType` is set to **Auth0**. This will be used in the next section to challenge the OpenID Connect middleware and start the authentication flow. Also note code in the `RedirectToIdentityProvider` notification event which constructs the correct [logout URL](https://auth0.com/docs/logout).\n\n## Add login to your ASP.NET OWIN application\n\nTo allow users to login to your ASP.NET OWIN application, add a `Login` action to your controller.\n\nCall `HttpContext.GetOwinContext().Authentication.Challenge` and pass `\"Auth0\"` as the authentication scheme. This invokes the OIDC authentication handler that was registered earlier. Be sure to specify the corresponding `AuthenticationProperties`, including a `RedirectUri`.\n\nAfter successfully calling `HttpContext.GetOwinContext().Authentication.Challenge`, the user is redirected to Auth0 and signed in to both the OIDC middleware and the cookie middleware upon being redirected back to your application. This will allow users to be authenticated on subsequent requests.\n\n```\npublic class AccountController : Controller\n{\n    public ActionResult Login(string returnUrl)\n    {\n        HttpContext.GetOwinContext().Authentication.Challenge(new AuthenticationProperties\n            {\n                RedirectUri = returnUrl ?? Url.Action(\"Index\", \"Home\")\n            },\n            \"Auth0\");\n        return new HttpUnauthorizedResult();\n    }\n}\n```\n\n## Add logout to your ASP.NET OWIN application\n\nFrom your controller's action, call `HttpContext.GetOwinContext().Authentication.SignOut` with the `CookieAuthenticationDefaults.AuthenticationType` authentication scheme to log the user out of your application.\n\nAdditionally, if you want to log the user out from Auth0 (this might also log them out of other applications that rely on Single Sign-On), call `HttpContext.GetOwinContext().Authentication.SignOut` with the `\"Auth0\"` authentication scheme.\n\n```\npublic class AccountController : Controller\n{\n    [Authorize]\n    public void Logout()\n    {\n        HttpContext.GetOwinContext().Authentication.SignOut(CookieAuthenticationDefaults.AuthenticationType);\n        HttpContext.GetOwinContext().Authentication.SignOut(\"Auth0\");\n    }\n}\n```\n\n## Display the user profile\n\nAfter the middleware successfully retrieves the tokens from Auth0, it extracts the user's information and claims from the ID token and makes them available as `ClaimsIdentity`. Access the extracted information by using the `User` property on the controller.\n\nTo create a user profile, retrieve a user's name, email address, and profile image from `User.Identity` and pass it to the view from inside your controller.\n\n```\n// Controllers/AccountController.cs\n\n[Authorize]\npublic ActionResult UserProfile()\n{\n    var claimsIdentity = User.Identity as ClaimsIdentity;\n\n    return View(new\n    {\n        Name = claimsIdentity?.FindFirst(c => c.Type == claimsIdentity.NameClaimType)?.Value,\n        EmailAddress = claimsIdentity?.FindFirst(c => c.Type == ClaimTypes.Email)?.Value,\n        ProfileImage = claimsIdentity?.FindFirst(c => c.Type == \"picture\")?.Value\n    });\n}\n```",
  "title": "Auth0 ASP.NET (OWIN) SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to an ASP.NET OWIN application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/architecture-scenarios/application/mobile-api",
  "markdown": "# Mobile Applications with API\n\nIn this scenario we will build a timesheet API for a fictitious company named ExampleCo. The API will allow management of timesheet entries for an employee or a contractor.\n\nWe will also be building a mobile application which will be used to view and log timesheet entries in the centralized timesheet database using the API.\n\n### TL;DR\n\n*   Auth0 provides API Authentication and Authorization as a means to secure access to API endpoints (see [API Authentication and Authorization](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-1#api-authentication-and-authorization))\n*   For authorizing a mobile app user and granting access to the API, Auth0 supports the [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/flows/concepts/auth-code-pkce) (see [Proof Key for Code Exchange](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-1#proof-key-for-code-exchange-pkce-))\n*   Both the mobile app and the API must be configured in the Auth0 Dashboard (see [Auth0 Configuration](https://auth0.com/docs/architecture-scenarios/mobile-api/part-2))\n*   User Permissions can be enforced using the Authorization Extension (see [Configure the Authorization Extension](https://auth0.com/docs/architecture-scenarios/mobile-api/part-2#configure-the-authorization-extension))\n*   The API is secured by ensuring that a valid [Access Token](https://auth0.com/docs/tokens/concepts/access-tokens) is passed in the HTTP Authorization header when calls are made to the API (see [Implement the API](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-3#secure-the-endpoints))\n*   The Auth0.Android SDK can be used to authorize the user of the mobile app and obtain a valid Access Token which can be used to call the API (see [Authorize the User](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-3#authorize-the-user))\n*   The mobile app can retrieve the user's profile information by decoding the ID Token (see [Get the User Profile](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-3#get-the-user-profile))\n*   UI Elements can be displayed conditionally based on the scope that was granted to the user (see [Display UI Elements Conditionally Based on Scope](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-3#display-ui-elements-conditionally-based-on-scope))\n*   The mobile app provides the Access Token in the HTTP Authorization header when making calls to the API (see [Call the API](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-3#call-the-api))\n*   The mobile app user's Access Token can be renewed to ensure the user does not have to log in again during a session (see [Renew the Token](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-3#renew-the-token))\n\n## The Premise\n\nExampleCo is a consulting startup company. Currently they have approximately 100 employees and they also outsource several activities to external contractors. All employees and external contractors are required to fill in their timesheets every week.\n\nThe company has built a timesheets application, a scenario we covered in [Single Sign-On for Regular Web Apps](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps). The internal employees use this web app to fill in their timesheets, but the company wants a mobile application for employees and contractors to use while not on the premises. The app will be used to log timesheet entries and send the data to the centralized timesheet database using the API. The app will also allow managers to approve timesheet entries.\n\n### Goals & Requirements\n\nExampleCo wants to build a flexible solution. There are potential multiple employees and contractors who should be able to log timesheet entries, as well as batch processes which may upload timesheet entries from other, external systems.\n\nHence the company has decided to develop a single Timesheets API which will be used to log time not only by this mobile app, but by all other apps as well. They want to put in place a security architecture that is flexible enough to accommodate this. ExampleCo wants to ensure that a large part of the code and business logic for the application can be shared across the different applications.\n\nIt is required that only authorized users and applications are allowed access to the Timesheets API.\n\n## Learn more\n\n*   [Solution Overview (Mobile Apps + API)](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-1)\n*   [Auth0 Configuration (Mobile Apps + API)](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-2)\n*   [API and Mobile Configuration (Mobile Apps + API)](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-3)\n*   [Node.js API Implementation (Mobile Apps + API)](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/api-implementation-nodejs)\n*   [Android Mobile Application Implementation (Mobile Apps + API)](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/mobile-implementation-android)\n*   [Conclusion (Mobile Apps + API)](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-4)",
  "title": "Mobile Applications with API",
  "description": "Explains the architecture scenario with a mobile application communicating with an API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api-auth/grant/authorization-code-pkce",
  "markdown": "# Authorization Code Flow with Proof Key for Code Exchange (PKCE)\n\n#### Overview\n\nKey Concepts\n\n*   Learn about the OAuth 2.0 grant type, Authorization Code Flow with Proof Key for Code Exchange (PKCE).\n    \n*   Use this grant type for applications that cannot store a client secret, such as native or single-page apps.\n    \n*   Review different implementation methods with Auth0 SDKs.\n    \n\nWhen public clients (e.g., native and single-page applications) request access tokens, some additional security concerns are posed that are not mitigated by the Authorization Code Flow alone. This is because:\n\n**Native apps**\n\n*   Cannot securely store a Client Secret. Decompiling the app will reveal the Client Secret, which is bound to the app and is the same for all users and devices.\n    \n*   May make use of a custom URL scheme to capture redirects (e.g., MyApp://) potentially allowing malicious applications to receive an Authorization Code from your Authorization Server.\n    \n\n**Single-page apps**\n\n*   Cannot securely store a Client Secret because their entire source is available to the browser.\n    \n\nGiven these situations, OAuth 2.0 provides a version of the Authorization Code Flow which makes use of a Proof Key for Code Exchange (PKCE) (defined in [OAuth 2.0 RFC 7636](https://tools.ietf.org/html/rfc7636)).\n\nThe PKCE-enhanced Authorization Code Flow introduces a secret created by the calling application that can be verified by the authorization server; this secret is called the Code Verifier. Additionally, the calling app creates a transform value of the Code Verifier called the Code Challenge and sends this value over HTTPS to retrieve an Authorization Code. This way, a malicious attacker can only intercept the Authorization Code, and they cannot exchange it for a token without the Code Verifier.\n\n## How it works\n\nBecause the PKCE-enhanced Authorization Code Flow builds upon the [standard Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow), the steps are very similar.\n\n![Flows - Authorization Code with PKCE - Authorization sequence diagram](https://images.ctfassets.net/cdy7uua7fh8z/3pstjSYx3YNSiJQnwKZvm5/33c941faf2e0c434a9ab1f0f3a06e13a/auth-sequence-auth-code-pkce.png)\n\n1.  The user clicks **Login** within the application.\n    \n2.  Auth0's SDK creates a cryptographically-random `code_verifier` and from this generates a `code_challenge`.\n    \n3.  Auth0's SDK redirects the user to the Auth0 Authorization Server ([`**/authorize**` endpoint](https://auth0.com/docs/api/authentication#authorization-code-grant-pkce-)) along with the `code_challenge`.\n    \n4.  Your Auth0 Authorization Server redirects the user to the login and authorization prompt.\n    \n5.  The user authenticates using one of the configured login options and may see a consent page listing the permissions Auth0 will give to the application.\n    \n6.  Your Auth0 Authorization Server stores the `code_challenge` and redirects the user back to the application with an authorization `code`, which is good for one use.\n    \n7.  Auth0's SDK sends this `code` and the `code_verifier` (created in step 2) to the Auth0 Authorization Server `(`[`**/oauth/token**` endpoint](https://auth0.com/docs/api/authentication?http#authorization-code-flow-with-pkce44)).\n    \n8.  Your Auth0 Authorization Server verifies the `code_challenge` and `code_verifier`.\n    \n9.  Your Auth0 Authorization Server responds with an ID token and access token (and optionally, a refresh token).\n    \n10.  Your application can use the access token to call an API to access information about the user.\n    \n11.  The API responds with requested data.\n    \n\n## How to implement it\n\nThe easiest way to implement the Authorization Code Flow with PKCE is to [follow our Native Quickstarts](https://auth0.com/docs/quickstart/native) or [follow our Single-Page Quickstarts](https://auth0.com/docs/quickstart/spa).\n\nDepending on your application type, you can also use our mobile or single-page app SDKs:\n\n**Mobile**\n\n*   [Auth0 Swift SDK](https://auth0.com/docs/libraries/auth0-swift)\n    \n*   [Auth0 Android SDK](https://auth0.com/docs/libraries/auth0-android)\n    \n\n**Single-page**\n\n*   [Auth0 Single-Page App SDK](https://auth0.com/docs/libraries/auth0-single-page-app-sdk)\n    \n*   [Auth0 React SDK](https://auth0.com/docs/libraries/auth0-react)\n    \n\nYou can follow our tutorials to use our API endpoints to [Add Login Using the Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/add-login-using-the-authorization-code-flow-with-pkce) or [Call Your API Using the Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce).\n\n## Learn more\n\n*   [Auth0 Rules](https://auth0.com/docs/customize/rules)\n*   [Auth0 Hooks](https://auth0.com/docs/customize/hooks)\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)",
  "title": "Authorization Code Flow with Proof Key for Code Exchange (PKCE)",
  "description": "Learn how the Authorization Code flow with Proof Key for Code Exchange (PKCE) works and why you should use it for native and mobile apps.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/aspnet-core-webapi",
  "markdown": "# Auth0 ASP.NET Core Web API SDK Quickstarts: Authorization\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [ASP.NET Core Web API](https://auth0.com/docs/quickstart/backend/aspnet-core-webapi)\n*   [Authorization](https://auth0.com/docs/quickstart/backend/aspnet-core-webapi/01-authorization)\n\nThis tutorial demonstrates how to add authorization to an ASP.NET Core Web API application using the standard JWT middleware. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: .NET 6.0 | .NET 7.0 | .NET 8.0\n\n## Configure Auth0 APIs\n\n### Create an API\n\nIn the [APIs](https://manage.auth0.com/#/apis) section of the Auth0 dashboard, click **Create API**. Provide a name and an identifier for your API, for example, `https://quickstarts/api`. You will use the identifier as an `audience` later, when you are configuring the Access Token verification. Leave the **Signing Algorithm** as **RS256**.\n\n![Create API](https://auth0.com/docs/media/articles/server-apis/create-api.png)\n\nBy default, your API uses RS256 as the algorithm for signing tokens. Since RS256 uses a private/public keypair, it verifies the tokens against the public key for your Auth0 account. The public key is in the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) format, and can be accessed [here](https://{yourdomain}/.well-known/jwks.json).\n\n### Define permissions\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nThis example demonstrates:\n\n*   How to check for a JSON Web Token (JWT) in the `Authorization` header of an incoming HTTP request.\n    \n*   How to check if the token is valid, using the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) for your Auth0 account. To learn more about validating Access Tokens, see [Validate Access Tokens](https://auth0.com/docs/tokens/guides/validate-access-tokens).\n    \n\n## Configure the Sample Project\n\nThe sample code has an `appsettings.json` file which configures it to use the correct Auth0 **Domain** and **API Identifier** for your API. If you download the code from this page while logged in, it will be automatically filled. If you use the example from Github, you will need to fill it yourself.\n\n```\n{\n  \"Auth0\": {\n    \"Domain\": \"{yourDomain}\",\n    \"Audience\": \"{yourApiIdentifier}\"\n  }\n}\n```\n\n## Validate Access Tokens\n\n### Install dependencies\n\nThe seed project already contains a reference to the `Microsoft.AspNetCore.Authentication.JwtBearer`, which is needed in order to validate Access Tokens. However, if you are not using the seed project, add the package to your application by installing it using Nuget:\n\n```\nInstall-Package Microsoft.AspNetCore.Authentication.JwtBearer\n```\n\n### Configure the middleware\n\nThe ASP.NET Core JWT Bearer authentication handler downloads the JSON Web Key Set (JWKS) file with the public key. The handler uses the JWKS file and the public key to verify the Access Token's signature.\n\nIn your application, register the authentication services:\n\n1.  Make a call to the `AddAuthentication` method. Configure `JwtBearerDefaults.AuthenticationScheme` as the default schemes.\n2.  Make a call to the `AddJwtBearer` method to register the JWT Bearer authentication scheme. Configure your Auth0 domain as the authority, and your Auth0 API identifier as the audience. In some cases the access token will not have a `sub` claim which will lead to `User.Identity.Name` being `null`. If you want to map a different claim to `User.Identity.Name` then add it to `options.TokenValidationParameters` within the `AddAuthentication()` call.\n\n```\n// Program.cs\nvar builder = WebApplication.CreateBuilder(args);\nvar domain = $\"https://{builder.Configuration[\"Auth0:Domain\"]}/\";\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n.AddJwtBearer(options =>\n{\n    options.Authority = domain;\n    options.Audience = builder.Configuration[\"Auth0:Audience\"];\n    options.TokenValidationParameters = new TokenValidationParameters\n    {\n        NameClaimType = ClaimTypes.NameIdentifier\n    };\n});\n```\n\nTo add the authentication and authorization middleware to the middleware pipeline, add a call to the `UseAuthentication` and `UseAuthorization` methods in your Program.cs file:\n\n```\n// Program.cs\nvar app = builder.Build();\n\napp.UseAuthentication();\napp.UseAuthorization();\napp.UseEndpoints(endpoints =>\n{\n    endpoints.MapControllers();\n});\n```\n\n### Validate scopes\n\nTo make sure that an Access Token contains the correct scope, use the [Policy-Based Authorization](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies) in ASP.NET Core.\n\nCreate a new authorization requirement called `HasScopeRequirement`. This requirement checks if the `scope` claim issued by your Auth0 tenant is present. If the `scope` claim exists, the requirement checks if the `scope` claim contains the requested scope.\n\n```\n// HasScopeRequirement.cs\n\npublic class HasScopeRequirement : IAuthorizationRequirement\n{\n    public string Issuer { get; }\n    public string Scope { get; }\n\n    public HasScopeRequirement(string scope, string issuer)\n    {\n        Scope = scope ?? throw new ArgumentNullException(nameof(scope));\n        Issuer = issuer ?? throw new ArgumentNullException(nameof(issuer));\n    }\n}\n```\n\n```\n// HasScopeHandler.cs\n\npublic class HasScopeHandler : AuthorizationHandler<HasScopeRequirement>\n{\n    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, HasScopeRequirement requirement)\n    {\n        // If user does not have the scope claim, get out of here\n        if (!context.User.HasClaim(c => c.Type == \"scope\" && c.Issuer == requirement.Issuer))\n            return Task.CompletedTask;\n\n        // Split the scopes string into an array\n        var scopes = context.User.FindFirst(c => c.Type == \"scope\" && c.Issuer == requirement.Issuer).Value.Split(' ');\n\n        // Succeed if the scope array contains the required scope\n        if (scopes.Any(s => s == requirement.Scope))\n            context.Succeed(requirement);\n\n        return Task.CompletedTask;\n    }\n}\n```\n\nIn your Program.cs file, add a call to the `AddAuthorization` method. To add policies for the scopes, call `AddPolicy` for each scope. Also ensure that you register the `HasScopeHandler` as a singleton:\n\n```\n// Program.cs\n\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"read:messages\", policy => policy.Requirements.Add(new \n    HasScopeRequirement(\"read:messages\", domain)));\n});\n\nbuilder.Services.AddSingleton<IAuthorizationHandler, HasScopeHandler>();\n```\n\n## Protect API Endpoints\n\nThe JWT middleware integrates with the standard ASP.NET Core [Authentication](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/) and [Authorization](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/) mechanisms.\n\nTo secure an endpoint, you need to add the `[Authorize]` attribute to your controller action:\n\n```\n// Controllers/ApiController.cs\n\n[Route(\"api\")]\n[ApiController]\npublic class ApiController : ControllerBase\n{\n    [HttpGet(\"private\")]\n    [Authorize]\n    public IActionResult Private()\n    {\n        return Ok(new\n        {\n            Message = \"Hello from a private endpoint! You need to be authenticated to see this.\"\n        });\n    }\n}\n```\n\nTo secure endpoints that require specific scopes, we need to make sure that the correct scope is present in the `access_token`. To do that, add the `Authorize` attribute to the `Scoped` action and pass `read:messages` as the `policy` parameter.\n\n```\n// Controllers/ApiController.cs\n\n[Route(\"api\")]\npublic class ApiController : Controller\n{\n    [HttpGet(\"private-scoped\")]\n    [Authorize(\"read:messages\")]\n    public IActionResult Scoped()\n    {\n        return Ok(new\n        {\n            Message = \"Hello from a private endpoint! You need to be authenticated and have a scope of read:messages to see this.\"\n        });\n    }\n}\n```",
  "title": "Auth0 ASP.NET Core Web API SDK Quickstarts: Authorization",
  "description": "This tutorial demonstrates how to add authorization to an ASP.NET Core Web API application using the standard JWT middleware.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/set-up-apis",
  "markdown": "# Register APIs\n\n1.  Go to [Dashboard > Applications > APIs](https://manage.auth0.com/#/apis), and select **\\+ Create API**.\n    \n    ![Dashboard Applications APIs Create API Screen](https://images.ctfassets.net/cdy7uua7fh8z/7MayGFhXzQn141E0MwqUkj/b3872737e6e7a3434ff677dcfa46ccfc/image1.png)\n2.  Provide the following information for your API, and click **Create**:\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Name** | A friendly name for the API. Does not affect any functionality. |\n    | **Identifier** | A unique identifier for the API. Auth0 recommends using a URL. Auth0 does differentiate between URLs that include the last forward slash. For example, `https://example.com` and `https://example.com/` are two different identifiers. The URL does not have to be a publicly available URL. Auth0 will not call your API. This value cannot be modified afterwards. |\n    | **Signing Algorithm** | The algorithm to sign the tokens with. The available values are HS256 and RS256. When selecting RS256 the token will be signed with the tenant's private key. |\n    | **JSON Web Token (JWT) Profile** | The profile determines the format of the access tokens issued for the API. The available values are `Auth0` and `RFC 9068`. To learn more, read [Access Token Profiles](https://auth0.com/docs/secure/tokens/access-tokens/access-token-profiles). |\n    | **JSON Web Token (JWT) Signing Algorithm** | The algorithm to sign the access tokens with. The available values are `HS256` and `RS256`. If you select `RS256`, the token will be signed with the tenant's private key. |\n    \n3.  Make the implementation changes to your API that are described in the QuickStart. These changes consist of choosing a JWT library from a predefined list and configuring this library to validate the access tokens in your API.\n    \n    ![Dashboard - Applications - APIs - Quickstart](https://images.ctfassets.net/cdy7uua7fh8z/3nk0LfDGkGv4WhwpEDiaW4/e65c4a54a57ca6951f6210e49d8d3b37/dashboard-apis-edit_view-quick-start.png)\n\nThe other available Dashboard views for your API are:\n\n*   **Settings**: Lists the settings for your API. Some are editable. Here you can change the token expiration time and enable offline access (this way Auth0 will allow your applications to ask for refresh tokens for this API).\n    \n*   **Scopes**: Define the scopes for this API by setting a name and a description.\n    \n*   **Machine to Machine Applications**: Lists all applications for which the **Client Credentials** grant is enabled. By default, this grant is enabled for regular web applications and machine-to-machine applications. You can authorize any of these applications to request access tokens for your API. Optionally, you can select a subset of the defined scopes to limit your authorized application's access.\n    \n*   **Test**: Execute a sample client credentials flow with any of your authorized applications to check that everything is working as expected.\n    \n\n## Learn more\n\n*   [API Settings](https://auth0.com/docs/get-started/apis/api-settings)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)",
  "title": "Register APIs",
  "description": "Learn how to register APIs in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/dashboard/application-settings",
  "markdown": "# Application Settings\n\nOn the [Applications](https://manage.auth0.com/#/applications) page of the Dashboard, locate your application in the list, and click its name to view the available settings.\n\n![Dashboard Applications List](https://images.ctfassets.net/cdy7uua7fh8z/1ecNwGgFQZxdP57p0tp3jT/d6796b8b909d0db1d4dd7d5e0487776a/dashboard-applications-applications-list.png)\n\n## Basic settings\n\nWhen you edit an existing application's settings or create a new application, you enter information about the application in the **Settings** view.\n\n### Basic Information\n\n![Dashboard Applications Application Settings Tab Basic Information](https://images.ctfassets.net/cdy7uua7fh8z/2GPUw7BODYuYYH3658Upz3/92a49ec57e6b4d07be96093989baac03/2023-04-11_15-34-58.png)\n\n*   **Name**: The name of your application. Editable, and will be seen in the portal, emails, logs, and so on.\n    \n*   **Domain**: Your Auth0 tenant name. You choose this when you create a new Auth0 tenant, and it cannot be changed. If you need a different domain, you must register for a new tenant by selecting **\\+ Create Tenant** in the top-right menu.\n    \n*   **Client ID**: The unique identifier for your application. You will use this when configuring authentication with Auth0. Generated by the system when you create a new application and cannot be modified.\n    \n*   **Client Secret**: A string used to sign and validate ID Tokens for authentication flows and to gain access to select Auth0 API endpoints. By default, the value is hidden, so check the **Reveal Client Secret** box to see it. While the Client ID is considered public information, the Client Secret **must be kept confidential**. If anyone can access your Client Secret, they can issue tokens and access resources they shouldn't be able to access.\n    \n*   **Description**: A free-text description of the Application's purpose. Maximum of 140 characters.\n    \n\n### Application Properties\n\n![Dashboard Applications Application Settings Tab Application Properties](https://images.ctfassets.net/cdy7uua7fh8z/4Z66jnQOVFwNo5iuHtdlxo/2d28d23a6a2fb15a3b16ab4d63073f75/dashboard-applications-applications-settings-app-properties.png)\n\n*   **Application Logo**: The URL of a logo (recommended size: 150x150 pixels) to display for the application. Appears in several areas, including the list of applications in the Dashboard and customized consent forms. If none is set the default badge for this type of application will be shown.\n    \n*   **Application Type**: The Auth0 application type determines which settings you can configure using the Dashboard. (Not editable for M2M apps. Sometimes disabled for other Auth0 application types if the selected grant types are only allowed for the currently selected application type.) Use the drop-down to select from the following types:\n    \n    *   [Machine to Machine](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps): Non-interactive applications, such as command-line tools, daemons, IoT devices, or services running on your backend. Typically, you use this option if you have a service that requires access to an API.\n        \n    *   [Native App](https://auth0.com/docs/get-started/auth0-overview/create-applications/native-apps): Mobile or Desktop applications that run natively in a device (such as iOS or Android).\n        \n    *   [Regular Web App](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps): Traditional web apps that perform most of their application logic on the server (such as Express.js or ASP.NET).\n        \n    *   [Single Page App](https://auth0.com/docs/get-started/auth0-overview/create-applications/single-page-web-apps): JavaScript apps that perform most of their user interface logic in a web browser, communicating with a web server primarily using APIs (such as AngularJS + Node.js or React). \n        \n\n### Application URIs\n\n![Dashboard Applications Application Settings Application URIs](https://images.ctfassets.net/cdy7uua7fh8z/1QhW2i4fTCCp8owey2tMPI/c44593dffdcc786731930d394d0da515/Application_URIs.png)\n\n*   **Application Login URI**: In some scenarios, Auth0 will need your application to redirect to your application's login page. This URI needs to point to a route in your application that redirects to your tenant's `/authorize` [endpoint](https://auth0.com/docs/api/authentication#authorize-application). It would usually take the form of `https://myapp.org/login`. To learn more, read [Configure Default Login Routes](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes).\n    \n*   **Allowed Callback URLs**: Set of URLs to which Auth0 is allowed to redirect users after they authenticate. You can specify multiple valid URLs by comma-separating them (typically, to handle different environments like QA or testing). For production environments, verify that the URLs do not point to localhost. You can use the star symbol as a wildcard [placeholder for subdomains](https://auth0.com/docs/get-started/applications/wildcards-for-subdomains) (`*.google.com`). If you are using the Organizations feature, for production applications, you can use `{organization_name}` as a placeholder to dynamically specify a registered organization’s name in a URL (`https://{organization_name}.exampleco.com`). URLs with the `{organization_name}` placeholder should only be used on domains that you fully control (for example, `https://{organization_name}.exampleco.com` where you control the `exampleco.com` domain).\n    \n    Do not use wildcard placeholders or localhost URLs in your application callbacks or allowed origins fields. Using redirect URLs with wildcard placeholders can make your application vulnerable to attacks. To learn more, read [Unvalidated Redirects and Forwards Cheat Sheet on owasp.org](https://www.owasp.org/index.php/Unvalidated_Redirects_and_Forwards_Cheat_Sheet). Instead, URLs with the `{organization_name}` placeholder should be preferred, where relevant. To learn more, read [Subdomain URL Placeholders](https://auth0.com/docs/get-started/applications/wildcards-for-subdomains).\n    \n*   **Allowed Logout URLs**: After a user logs out from Auth0 you can redirect them with the `returnTo` query parameter. The URL that you use in `returnTo` must be listed here. You can specify multiple valid URLs by comma-separating them. For production environments, verify that the URLs do not point to localhost. You can use the star symbol as a wildcard placeholder for subdomains (`*.google.com`). Notice that query strings and hash information are not taken into account when validating these URLs. See [Logout](https://auth0.com/docs/authenticate/login/logout). You can provide up to 100 URLs in the **Allowed Logout URLs** field.\n    \n*   **Allowed Web Origins**: List of URLs from where an authorization request using [Cross-Origin Authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication), [Device Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow), and `web_message` as the response mode can originate from. You can specify multiple valid URLs by comma-separating them. For production environments, verify that the URLs do not point to localhost. You can use the star symbol as a wildcard placeholder for subdomains (`*.google.com`). Paths, query strings, and hash information are not taken into account when validating these URLs (and may, in fact, cause the match to fail). You can provide up to 100 URLs in the **Allowed Web Origins** field.\n    \n*   **Allowed Origins (CORS)**: Set of URLs that will be allowed to make requests from JavaScript to Auth0 API (typically used with CORS). This prevents same-origin policy errors when using Auth0 from within a web browser. By default, all your callback URLs will be allowed. This field allows you to enter other origins if you need to. You can specify multiple valid URLs by comma-separating them. For production environments, verify that the URLs do not point to localhost. You can use the star symbol as a wildcard placeholder for subdomains (`*.google.com`). If you are using the Organizations feature, you can use `{organization_name}` as a placeholder to dynamically specify a registered organization’s name in a URL (`https://{organization_name}.exampleco.com`). Notice that paths, query strings, and hash information are not taken into account when validating these URLs (and may, in fact, cause the match to fail). You can provide up to 100 URLs in the **Allowed Origins (CORS)** field.\n    \n\n### ID Token\n\nIn the **ID Token** section, enter the **ID Token Expiration** (in seconds) which is the amount of time before the Auth0 `id_token` expires. The default value is 36000 seconds which is 10 hours.\n\n![Dashboard Applications Applications Settings Tab ID Token](https://images.ctfassets.net/cdy7uua7fh8z/26uUwvRKsPoVQVkztB3pyf/b8bb8aa28f4df0054ee7c69d3ae8da4e/dashboard-applications-applications-settings-id-token.png)\n\n### Refresh Token Rotation\n\nIn the **Refresh Token Rotation** section, enable or disable rotation. When enabled, as a result of exchanging a refresh token, a new refresh token will be issued and the existing token will be invalidated. This allows for automatic detection of token reuse if the token is leaked. In addition, enter the **Reuse Interval** (in seconds). This interval is the allowable leeway time that the same `refresh_token` can be used to request an `access_token` without triggering automatic reuse detection. To learn more, read [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation).\n\n![Dashboard Applications Applications Settings Tab Refresh Token Rotation](https://images.ctfassets.net/cdy7uua7fh8z/Rk6i8MUVWZG34P7K6aurb/c1906bf4e4066a26965e012b61237af3/dashboard-applications-applications-settings-refresh-token-rotation.png)\n\n### Refresh Token Expiration\n\nIn the **Refresh Token Expiration** section, enable or disable absolute and inactivity expiration and set the lifetimes (in seconds) for each. To learn more, read [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration).\n\n![Dashboard Applications Applications Settings Tab Refresh Token Expiration](https://images.ctfassets.net/cdy7uua7fh8z/2EnpIEc4kBxjnS3T67xPzC/22af4a1d7fbc26a9bfbd4785ff8cb1a3/dashboard-applications-applications-settings-refresh-token-expiration.png)\n\n## Advanced settings\n\nThe **Advanced Settings** section allows you to:\n\n*   Manage or add application metadata, device, OAuth, and WS-Federation settings\n    \n*   Obtain certificates and Token endpoint information\n    \n*   Set the grant type(s) for the application\n    \n\n### Application Metadata\n\nApplication metadata are custom string keys and values (each of which has a character maximum of 255), set on a per-application basis. Metadata is exposed in the application object as `client_metadata`, and in rules as `context.clientMetadata`. You can create up to 10 sets of metadata.\n\n![Dashboard Applications Applications Settings Tab Advanced Settings Application Metadata Tab](https://images.ctfassets.net/cdy7uua7fh8z/7GWHyQloNihda3fuYiVEWQ/d32531dbb111dc90f491985970da76fe/dashboard-applications-applications-settings-advanced-app-metadata.png)\n\n### Device Settings\n\nIf you're developing a mobile application, enter the necessary iOS/Android parameters.\n\n*   When developing iOS apps, you'll provide your **Team ID** and **App ID**. To learn more, read [Enable Universal Links Support in Apple Xcode](https://auth0.com/docs/get-started/applications/enable-universal-links-support-in-apple-xcode).\n    \n*   When developing Android apps, you'll provide your **App Package Name** and your **Key Hashes**. To learn more, read [Enable Android App Links Support](https://auth0.com/docs/get-started/applications/enable-android-app-links-support).\n    \n\n![Dashboard Applications Application Settings Tab Advanced Settings Device Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/YKKPtWtswHn2FZGFSVWNw/3af8af94d510abe6db83ac36c5407402/dashboard-applications-applications-settings-advanced-device-settings.png)\n\n### OAuth\n\n![Dashboard Applications Application Settings Tab Advanced Settings OAuth Tab](https://images.ctfassets.net/cdy7uua7fh8z/5bbq6VrI9tUMht0PwMimre/82709cef487e87f92635a05b55f75ff0/dashboard-applications-applications-settings-advanced-oauth.png)\n\n*   By default, all apps/APIs can make a delegation request, but if you want to explicitly grant permissions to selected apps/APIs, you can do so in **Allowed Apps/APIs**.\n    \n*   Set the algorithm used ([**HS256**](https://en.wikipedia.org/wiki/Symmetric-key_algorithm) or [**RS256**](https://en.wikipedia.org/wiki/Public-key_cryptography)) for signing your JSON web tokens. To learn more, read [JSON Web Token Signing Algorithms](https://auth0.com/docs/get-started/applications/signing-algorithms). When selecting `RS256` (recommended), the token will be signed with your tenant's private key.\n    \n*   Toggle the **Trust Token Endpoint IP Header** setting; if this is enabled, the `auth0-forwarded-for` is set as trusted and used as a source of end user IP information for protection against brute-force attacks on the Token endpoint. This setting is only available for Regular Web Apps and M2M Apps.\n    \n*   Toggle the switch to indicate if your application is **OIDC Conformant** or not. Applications flagged as OIDC Conformant will strictly follow the OIDC specification.\n    \n*   Set the location URL for **Cross-Origin Verification Fallback**. This is the location of the page that will be rendered inside an iframe to perform the token verification when third-party cookies are not enabled in the browser. Must be in the same domain where the embedded login form is hosted and must have an `https` scheme.\n    \n\nFor troubleshooting help, read [Troubleshoot Invalid Token Errors](https://auth0.com/docs/troubleshoot/basic-issues/invalid-token-errors).\n\n### Grant Types\n\nSelect grant types to enable or disable for your application. Available grant types are based on the application type.\n\n![Dashboard Applications Application Settings Tab Advanced Settings Grant Types tab](https://images.ctfassets.net/cdy7uua7fh8z/4ZMq4VfeGsKsKfZVFwSqe8/a6f2f635374d4f14593bace7a3cd1d14/dashboard-applications-applications-settings-advanced-grant-types.png)\n\n### WS-Federation\n\nManage or add WS-Federation settings.\n\n![Dashboard Applications Application Settings Tab Advanced WS-Federation tab](https://images.ctfassets.net/cdy7uua7fh8z/3zuhwy8aQfveqIep1NilGk/f57cc919781b8c63f6552bdcf94645d4/dashboard-applications-applications-settings-advanced-ws-fed.png)\n\n### Certificates\n\nManage or add the signing certificate, and its fingerprint and thumbprint.\n\n![Dashboard Applications Advanced Settings Certificates tab](https://images.ctfassets.net/cdy7uua7fh8z/5eB167clrfOiBEtyrMOtkn/fba0b689fda32cb9fd16eba1c0725c65/dashboard-applications-applications-settings-advanced-certificates.png)\n\n### Endpoints\n\nView endpoint information for OAuth, SAML, and WS-Fed.\n\n![Dashboard Applications Application Settings Tabs Advanced Endpoints tab](https://images.ctfassets.net/cdy7uua7fh8z/6aYWCyJXwGKwVmP42te2oI/118305c73038e2661286b66d1122b5e2/dashboard-applications-applications-settings-advanced-endpoints.png)\n\n## Learn more\n\n*   [Create Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications)\n*   [Remove Applications](https://auth0.com/docs/get-started/applications/remove-applications)\n*   [Configure Applications with OIDC Discovery](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery)\n*   [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications)\n*   [First-Party and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications)\n*   [Check Error Messages](https://auth0.com/docs/troubleshoot/basic-issues/check-error-messages)",
  "title": "Application Settings",
  "description": "Describe the settings related to applications available in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/webapi-owin",
  "markdown": "# Auth0 ASP.NET Web API (OWIN) SDK Quickstarts: Authorization\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [ASP.NET Web API (OWIN)](https://auth0.com/docs/quickstart/backend/webapi-owin)\n*   [Authorization](https://auth0.com/docs/quickstart/backend/webapi-owin/01-authorization)\n\nThis tutorial demonstrates how to add authorization to an ASP.NET OWIN API using the standard JWT middleware. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Microsoft Visual Studio 2015 Update 3 | System.IdentityModel.Tokens.Jwt NuGet Package v5.2.2 | Microsoft.Owin.Security.Jwt NuGet Package V4.0.0\n\n## Configure Auth0 APIs\n\n### Create an API\n\nIn the [APIs](https://manage.auth0.com/#/apis) section of the Auth0 dashboard, click **Create API**. Provide a name and an identifier for your API, for example, `https://quickstarts/api`. You will use the identifier as an `audience` later, when you are configuring the Access Token verification. Leave the **Signing Algorithm** as **RS256**.\n\n![Create API](https://auth0.com/docs/media/articles/server-apis/create-api.png)\n\nBy default, your API uses RS256 as the algorithm for signing tokens. Since RS256 uses a private/public keypair, it verifies the tokens against the public key for your Auth0 account. The public key is in the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) format, and can be accessed [here](https://{yourdomain}/.well-known/jwks.json).\n\n### Define permissions\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nThis example demonstrates:\n\n*   How to check for a JSON Web Token (JWT) in the `Authorization` header of an incoming HTTP request.\n    \n*   How to check if the token is valid, using the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) for your Auth0 account. To learn more about validating Access Tokens, see [Validate Access Tokens](https://auth0.com/docs/tokens/guides/validate-access-tokens).\n    \n\n## Configure the Sample Project\n\nThe sample code has an `appsettings` section in `Web.config` which configures it to use the correct Auth0 **Domain** and **API Identifier** for your API. If you download the code from this page it will be automatically filled. If you use the example from Github, you will need to fill it yourself.\n\n```\n// web.config\n\n<appSettings>\n  <add key=\"Auth0Domain\" value=\"{yourDomain}\" />\n  <add key=\"Auth0ApiIdentifier\" value=\"{yourApiIdentifier}\" />\n</appSettings>\n```\n\n## Validate Access Tokens\n\n### Install dependencies\n\nTo use Auth0 Access Tokens with ASP.NET you will use the OWIN JWT Middleware which is available in the `Microsoft.Owin.Security.Jwt` NuGet package.\n\n```\nInstall-Package Microsoft.Owin.Security.Jwt\n```\n\n### Verifying the token signature\n\nAs the OWIN JWT middleware doesn't use Open ID Connect Discovery by default, you will need to provide a custom `IssuerSigningKeyResolver`. To do this, add the following to the `Support/OpenIdConnectSigningKeyResolver.cs` file:\n\n```\npublic class OpenIdConnectSigningKeyResolver\n{\n    private readonly OpenIdConnectConfiguration openIdConfig;\n\n    public OpenIdConnectSigningKeyResolver(string authority)\n    {\n        var cm = new ConfigurationManager<OpenIdConnectConfiguration>($\"{authority.TrimEnd('/')}/.well-known/openid-configuration\", new OpenIdConnectConfigurationRetriever());\n        openIdConfig = AsyncHelper.RunSync(async () => await cm.GetConfigurationAsync());\n    }\n\n    public SecurityKey[] GetSigningKey(string kid)\n    {\n        return new[] { openIdConfig.JsonWebKeySet.GetSigningKeys().FirstOrDefault(t => t.KeyId == kid) };\n    }\n}\n```\n\nThe `OpenIdConnectSigningKeyResolver` will automatically download the JSON Web Key Set used to sign the RS256 tokens from the OpenID Connect Configuration endpoint (at `/.well-known/openid-configuration`). You can then use it subsequently to resolve the Issuer Signing Key, as will be demonstrated in the JWT registration code below.\n\n### Configuration\n\nGo to the `Configuration` method of your `Startup` class and add a call to `UseJwtBearerAuthentication` passing in the configured `JwtBearerAuthenticationOptions`.\n\nThe `JwtBearerAuthenticationOptions` needs to specify your Auth0 API Identifier in the `ValidAudience` property, and the full path to your Auth0 domain as the `ValidIssuer`. You will need to configure the `IssuerSigningKeyResolver` to use the instance of `OpenIdConnectSigningKeyResolver` to resolve the signing key:\n\n```\n// Startup.cs\n\npublic void Configuration(IAppBuilder app)\n{\n    var domain = $\"https://{ConfigurationManager.AppSettings[\"Auth0Domain\"]}/\";\n    var apiIdentifier = ConfigurationManager.AppSettings[\"Auth0ApiIdentifier\"];\n    var keyResolver = new OpenIdConnectSigningKeyResolver(domain);\n\n    app.UseJwtBearerAuthentication(\n        new JwtBearerAuthenticationOptions\n        {\n            AuthenticationMode = AuthenticationMode.Active,\n            TokenValidationParameters = new TokenValidationParameters()\n            {\n                ValidAudience = apiIdentifier,\n                ValidIssuer = domain,\n                IssuerSigningKeyResolver = (token, securityToken, kid, parameters) => keyResolver.GetSigningKey(kid)\n            }\n        });\n\n    // Configure Web API\n    WebApiConfig.Configure(app);\n}\n```\n\n### Do not forget the trailing backslash\n\nPlease ensure that the URL specified for `ValidIssuer` contains a trailing backslash as this needs to match exactly with the issuer claim of the JWT. This is a common misconfiguration error which will cause your API calls to not be authenticated correctly.\n\n### Validate scopes\n\nThe JWT middleware above verifies that the Access Token included in the request is valid; however, it doesn't yet include any mechanism for checking that the token has the sufficient **scope** to access the requested resources.\n\nCreate a class called `ScopeAuthorizeAttribute` which inherits from `System.Web.Http.AuthorizeAttribute`. This Authorization Attribute will check that the `scope` claim issued by your Auth0 tenant is present, and if so it will ensure that the `scope` claim contains the requested scope.\n\n```\n// Controllers/ScopeAuthorizeAttribute.cs\n\npublic class ScopeAuthorizeAttribute : AuthorizeAttribute\n{\n    private readonly string scope;\n\n    public ScopeAuthorizeAttribute(string scope)\n    {\n        this.scope = scope;\n    }\n\n    public override void OnAuthorization(HttpActionContext actionContext)\n    {\n        base.OnAuthorization(actionContext);\n\n        // Get the Auth0 domain, in order to validate the issuer\n        var domain = $\"https://{ConfigurationManager.AppSettings[\"Auth0Domain\"]}/\";\n\n        // Get the claim principal\n        ClaimsPrincipal principal = actionContext.ControllerContext.RequestContext.Principal as ClaimsPrincipal;\n\n        // Get the scope claim. Ensure that the issuer is for the correct Auth0 domain\n        var scopeClaim = principal?.Claims.FirstOrDefault(c => c.Type == \"scope\" && c.Issuer == domain);\n        if (scopeClaim != null)\n        {\n            // Split scopes\n            var scopes = scopeClaim.Value.Split(' ');\n\n            // Succeed if the scope array contains the required scope\n            if (scopes.Any(s => s == scope))\n                return;\n        }\n\n        HandleUnauthorizedRequest(actionContext);\n    }\n}\n```\n\n## Protect API Endpoints\n\nThe routes shown below are available for the following requests:\n\n*   `GET /api/public`: available for non-authenticated requests\n*   `GET /api/private`: available for authenticated requests containing an access token with no additional scopes\n*   `GET /api/private-scoped`: available for authenticated requests containing an access token with the `read:messages` scope granted\n\nThe JWT middleware integrates with the standard ASP.NET Authentication and Authorization mechanisms, so you only need to decorate your controller action with the `[Authorize]` attribute to secure an endpoint.\n\n```\n// Controllers/ApiController.cs\n\n[RoutePrefix(\"api\")]\npublic class ApiController : ApiController\n{\n    [HttpGet]\n    [Route(\"private\")]\n    [Authorize]\n    public IHttpActionResult Private()\n    {\n        return Json(new\n        {\n            Message = \"Hello from a private endpoint! You need to be authenticated to see this.\"\n        });\n    }\n}\n```\n\nTo ensure that a scope is present in order to call a particular API endpoint, you simply need to decorate the action with the `ScopeAuthorize` attribute and pass the name of the required `scope` in the `scope` parameter.\n\n```\n// Controllers/ApiController.cs\n\n[RoutePrefix(\"api\")]\npublic class ApiController : ApiController\n{\n    [HttpGet]\n    [Route(\"private-scoped\")]\n    [ScopeAuthorize(\"read:messages\")]\n    public IHttpActionResult Scoped()\n    {\n        return Json(new\n        {\n            Message = \"Hello from a private endpoint! You need to be authenticated and have a scope of read:messages to see this.\"\n        });\n    }\n}\n```",
  "title": "Auth0 ASP.NET Web API (OWIN) SDK Quickstarts: Authorization",
  "description": "This tutorial demonstrates how to add authorization to an ASP.NET OWIN API using the standard JWT middleware.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/django",
  "markdown": "# Auth0 Django SDK Quickstarts: Login\n\nThis tutorial demonstrates how to add user login to a Python web application built with the Django framework and Authlib OAuth library. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n*   **Client Secret**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Create application\n\nFor this guide we demonstrate how to integrate Auth0 with a Python application using the [Django framework](https://www.djangoproject.com/) and [Authlib](https://authlib.org/). Let's start by ensuring Django is installed on your system. From your shell, run the following command:\n\nIf you already have a Python application setup, you can skip to the next step. Otherwise, let's create our new application project. From your shell, run the following command, and switch to the new project folder:\n\n```\ndjango-admin startproject webappexample\ncd webappexample\n```\n\n## Install dependencies\n\nFor this integration you'll need few library dependencies, such as Authlib. Go ahead and create a `requirements.txt` file in your project directory, and include the following:\n\n```\n# 📁 requirements.txt -----\n\nauthlib ~= 1.0\ndjango ~= 4.0\npython-dotenv ~= 0.19\nrequests ~= 2.27\n```\n\nYou should now run `pip install -r requirements.txt` from your shell to make these dependencies available to your project.\n\n## Configure your .env file\n\nNext, create an `.env` file in your project directory. This file will hold your client keys and other configuration details.\n\n```\n# 📁 .env -----\n\nAUTH0_CLIENT_ID={yourClientId}\nAUTH0_CLIENT_SECRET={yourClientSecret}\nAUTH0_DOMAIN={yourDomain}\n```\n\n## Update settings.py\n\nYou'll want to make some minor changes to your `webappexample/settings.py` file to read those `.env` values. At the top of the file, add these imports:\n\n```\n# 📁 webappexample/settings.py -----\n\nimport os\nfrom dotenv import load_dotenv, find_dotenv\n```\n\nNext, beneath the 'BASE\\_DIR' definition, add the following:\n\n```\n# 📁 webappexample/settings.py -----\n\n# Add the following line after 'BASE_DIR = ...'\nTEMPLATE_DIR = os.path.join(BASE_DIR, \"webappexample\", \"templates\")\n```\n\nNext, find the `TEMPLATES` variable and update the `DIRS` value to add our `TEMPLATE_DIR` string. This tells Django where to look for our template files, once we create them. Keep any other content of this array the same.\n\n```\n# 📁 webappexample/settings.py -----\n\nTEMPLATES = [\n    {\n        # Leave other lines as they are; we're just updating `DIRS`.\n        \"DIRS\": [TEMPLATE_DIR],\n    },\n]\n```\n\nFinally, at the end of this file, add the following:\n\n```\n# 📁 webappexample/settings.py -----\n\n# Load environment definition file\nENV_FILE = find_dotenv()\nif ENV_FILE:\n    load_dotenv(ENV_FILE)\n\n\n# Load Auth0 application settings into memory\nAUTH0_DOMAIN = os.environ.get(\"AUTH0_DOMAIN\")\nAUTH0_CLIENT_ID = os.environ.get(\"AUTH0_CLIENT_ID\")\nAUTH0_CLIENT_SECRET = os.environ.get(\"AUTH0_CLIENT_SECRET\")\n```\n\n## Setup your application\n\nNow you're ready to start writing your application. Open the `webappexample/views.py` file in your project director.\n\nBegin by importing all the libraries your application will be making use of:\n\n```\n# 📁 webappexample/views.py -----\n\nimport json\nfrom authlib.integrations.django_client import OAuth\nfrom django.conf import settings\nfrom django.shortcuts import redirect, render\nfrom django.urls import reverse\nfrom urllib.parse import quote_plus, urlencode\n```\n\nNow you can configure Authlib to handle your application's authentication with Auth0:\n\n```\n# 👆 We're continuing from the steps above. Append this to your webappexample/views.py file.\n\noauth = OAuth()\n\noauth.register(\n    \"auth0\",\n    client_id=settings.AUTH0_CLIENT_ID,\n    client_secret=settings.AUTH0_CLIENT_SECRET,\n    client_kwargs={\n        \"scope\": \"openid profile email\",\n    },\n    server_metadata_url=f\"https://{settings.AUTH0_DOMAIN}/.well-known/openid-configuration\",\n)\n```\n\nYou can learn more about the configuration options available for Authlib's OAuth `register()` method from [their documentation.](https://docs.authlib.org/en/latest/client/frameworks.html#using-oauth-2-0-to-log-in)\n\n## Setup your route handlers\n\nFor this demonstration, we'll be adding 4 routes for your application: your login, callback, logout and index routes.\n\n### Triggering authentication with /login\n\nWhen visitors to your app visit the `/login` route, they'll be redirected to Auth0 to begin the authentication flow.\n\n```\n# 👆 We're continuing from the steps above. Append this to your webappexample/views.py file.\n\ndef login(request):\n    return oauth.auth0.authorize_redirect(\n        request, request.build_absolute_uri(reverse(\"callback\"))\n    )\n```\n\n### Finalizing authentication with /callback\n\nAfter your users finish logging in with Auth0, they'll be returned to your application at the `/callback` route. This route is responsible for actually saving the session for the user, so when they visit again later, they won't have to sign back in all over again.\n\n```\n# 👆 We're continuing from the steps above. Append this to your webappexample/views.py file.\n\ndef callback(request):\n    token = oauth.auth0.authorize_access_token(request)\n    request.session[\"user\"] = token\n    return redirect(request.build_absolute_uri(reverse(\"index\")))\n```\n\n### Clearing a session with /logout\n\nAs you might expect, this route handles signing a user out from your application. It will clear the user's session in your app, and briefly redirect to Auth0's logout endpoint to ensure their session is completely clear, before they are returned to your home route (covered next.)\n\n```\n# 👆 We're continuing from the steps above. Append this to your webappexample/views.py file.\n\ndef logout(request):\n    request.session.clear()\n\n    return redirect(\n        f\"https://{settings.AUTH0_DOMAIN}/v2/logout?\"\n        + urlencode(\n            {\n                \"returnTo\": request.build_absolute_uri(reverse(\"index\")),\n                \"client_id\": settings.AUTH0_CLIENT_ID,\n            },\n            quote_via=quote_plus,\n        ),\n    )\n```\n\n### There's no place like /home\n\nLast but not least, your home route will serve as a place to either render an authenticated user's details, or offer to allow visitors to sign in.\n\n```\n# 👆 We're continuing from the steps above. Append this to your webappexample/views.py file.\n\ndef index(request):\n    return render(\n        request,\n        \"index.html\",\n        context={\n            \"session\": request.session.get(\"user\"),\n            \"pretty\": json.dumps(request.session.get(\"user\"), indent=4),\n        },\n    )\n```\n\n### Register your routes\n\nFinally, you'll need to tell Django how to connect these new routes. Replace the contents of your `webappexample/urls.py` file with the following:\n\n```\n# 📁 webappexample/urls.py -----\n\nfrom django.urls import path\n\nfrom . import views\n\nurlpatterns = [\n    path(\"\", views.index, name=\"index\"),\n    path(\"login\", views.login, name=\"login\"),\n    path(\"logout\", views.logout, name=\"logout\"),\n    path(\"callback\", views.callback, name=\"callback\"),\n]\n```\n\n## Add templates\n\nNow we just need to create the simple template files used in the routes about (during `render()` calls).\n\nCreate a new sub-directory within the `webappexample` folder named `templates`, and create a `index.html` file:\n\n```\n# 📁 webappexample/templates/index.html -----\n\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Auth0 Example</title>\n  </head>\n  <body>\n    {% if session %}\n    <h1>Welcome {{session.userinfo.name}}!</h1>\n    <p><a href=\"{% url 'logout' %}\">Logout</a></p>\n    <div><pre>{{pretty}}</pre></div>\n    {% else %}\n    <h1>Welcome Guest</h1>\n    <p><a href=\"{% url 'login' %}\">Login</a></p>\n    {% endif %}\n  </body>\n</html>\n```\n\n## Run your application\n\nYou're ready to run your application! From your project directory, open a shell and use:\n\n```\npython3 manage.py migrate\npython3 manage.py runserver 3000\n```\n\nYour application should now be ready to open from your browser at [http://localhost:3000](http://localhost:3000/).",
  "title": "Auth0 Django SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to a Python web application built with the Django framework and Authlib OAuth library.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/logout/guides/redirect-users-after-logout",
  "markdown": "# Redirect Users with Alternative Logout\n\nYou can redirect users to a specific URL after they logout. You will need to register the redirect URL in your tenant or application settings. Auth0 only redirects to allow list URLs after logout. If you need different redirects for each application, you can add the URLs to the allow list in your application settings.\n\n1.  Add a `returnTo` query string parameter with the target URL as the value. Encode the target URL being passed in. For example, to redirect the user to `https://www.example.com` after logout, make the following request: `https://{yourDomain}/v2/logout?returnTo=http%3A%2F%2Fwww.example.com`.\n    \n2.  Add the non-encoded `returnTo` URL (for these examples, it is `http://www.example.com`) as an **Allowed Logout URLs** in one of two places:\n    \n    *   **Tenant Settings**: For logout requests that do not include the `client_id` parameter you must add the `returnTo` URL (for example `http://www.example.com`) to the **Allowed Logout URLs** list in the [Advanced tab of your Tenant Settings](https://manage.auth0.com/#/tenant/advanced). For example: `https://{yourDomain}/v2/logout?returnTo=http%3A%2F%2Fwww.example.com`.\n        \n        To add a list of URLs that the user may be redirected to after logging out at the tenant level, go to the [Tenant Settings > Advanced](https://manage.auth0.com/#/tenant/advanced) of the Auth0 Dashboard.\n        \n        ![Auth0 Dashboard Settings Advanced Tab Login and Logout](https://images.ctfassets.net/cdy7uua7fh8z/77s6AWMuzH78ABObR3lg0o/48d7be12c2a63c3114b28cf20e57f217/dashboard-tenant-settings-advanced-login_and_logout.png)\n    *   **Auth0 Application Settings**: For logout requests that include the `client_id` parameter you must add the `returnTo` URL (for example `http://www.example.com`) to the **Allowed Logout URLs** list in the **Settings** tab of your Auth0 app that is associated with the specified `CLIENT_ID`. For example: `https://{yourDomain}/v2/logout?returnTo=http%3A%2F%2Fwww.example.com&client_id={clientId}`\n        \n        To redirect the user after they log out from a specific application, you must add the URL used in the `returnTo` parameter of the redirect URL to the **Allowed Logout URLs** list in the **Settings** tab of your Auth0 application that is associated with the `CLIENT_ID` parameter.\n        \n        ![Dashboard Applications Application Settings Application URIs](https://images.ctfassets.net/cdy7uua7fh8z/1QhW2i4fTCCp8owey2tMPI/c44593dffdcc786731930d394d0da515/Application_URIs.png)\n\nWhen providing the URL list, you can:\n\n1.  Specify multiple, valid, comma-separated URLs.\n    \n2.  Use `*` as a [wildcard for subdomains](https://auth0.com/docs/get-started/applications/wildcards-for-subdomains) (such as `http://*.example.com`).\n    \n\nIf the `client_id` parameter is included and the `returnTo` URL is not set, the server returns the user to the first Allowed Logout URLs set in the Dashboard.\n\nIn order to avoid validation errors, make sure that you include the protocol part of the URL. For example, setting the value to `*.example.com` will result in a validation error, so you should use `http://*.example.com` instead.\n\n## Federated logouts\n\n[Several providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps#federated-logout-support) support federated logout.\n\nTo redirect users from applications using federated logout, initiate federated logout with the following endpoint:\n\n`https://{yourDomain}/v2/logout?federated`\n\nYou are responsible for ensuring your application terminates the user session before redirecting.\n\nWhen the user reaches the `/logout` endpoint, Auth0 terminates the Auth0 session, redirects the user to the Identity Providers logout endpoint, and terminates the session with the Identity Provider.\n\n## Limitations\n\n*   The validation of URLs provided as values to the `returnTo` parameter, the query string, and hash information provided as part of the URL are not taken into account.\n    \n*   The behavior of federated logouts with social providers is inconsistent. Each provider will handle the `returnTo` parameter differently and for some it will not work. Please check your social provider's settings to ensure that they will accept the `returnTo` parameter and how it will behave.\n    \n*   The URLs provided in the **Allowed Logout URLs** list are case-sensitive, so the URL used for logouts must match the case of the logout URL configured on the dashboard. However, do note that the scheme and host parts are case insensitive. For example, if your URL is `http://www.Example.Com/FooHoo.html`, the `http://www.Example.Com` portion is case insensitive, while the `FooHoo.html` portion is case sensitive.\n    \n\nIf you are working with social identity providers such as Google or Facebook, you must set your `Client ID` and `Secret` for these providers in the [Dashboard](https://manage.auth0.com/#) for the logout to function properly.\n\n## Additional requirements for Facebook\n\nUse the `returnTo` parameter to specify how to redirect the user after logout.\n\nNot all IdPs support `returnTo`.\n\nFor Facebook, the example code below uses the `returnTo` parameter and specifies a website for the redirect.\n\n```\nhttps://{yourDomain}/v2/logout?federated&\n      returnTo=https://{yourDomain}/logout?returnTo=http://www.example.com\n      &access_token={facebookAccessToken}\n```\n\n## Learn more\n\n*   [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications)\n*   [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0)\n*   [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n*   [Check Login and Logout Issues](https://auth0.com/docs/troubleshoot/authentication-issues/check-login-and-logout-issues)",
  "title": "Redirect Users with Alternative Logout",
  "description": "Describes how to redirect users with the legacy logout endpoint.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/django",
  "markdown": "# Auth0 Django API SDK Quickstarts: Authorization\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [Django API](https://auth0.com/docs/quickstart/backend/django)\n*   [Authorization](https://auth0.com/docs/quickstart/backend/django/01-authorization)\n\nThis tutorial demonstrates how to add authorization to a Django REST Framework API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Python 3.5 and up | Django 2.2.\\* | djangorestframework 3.10.\\* | drf-jwt 1.13.\\*\n\n## Configure Auth0 APIs\n\n### Create an API\n\nIn the [APIs](https://manage.auth0.com/#/apis) section of the Auth0 dashboard, click **Create API**. Provide a name and an identifier for your API, for example, `https://quickstarts/api`. You will use the identifier as an `audience` later, when you are configuring the Access Token verification. Leave the **Signing Algorithm** as **RS256**.\n\n![Create API](https://auth0.com/docs/media/articles/server-apis/create-api.png)\n\nBy default, your API uses RS256 as the algorithm for signing tokens. Since RS256 uses a private/public keypair, it verifies the tokens against the public key for your Auth0 account. The public key is in the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) format, and can be accessed [here](https://{yourdomain}/.well-known/jwks.json).\n\n### Define permissions\n\nPermissions let you define how resources can be accessed on behalf of the user with a given access token. For example, you might choose to grant read access to the `messages` resource if users have the manager access level, and a write access to that resource if they have the administrator access level.\n\nYou can define allowed permissions in the **Permissions** view of the Auth0 Dashboard's [APIs](https://manage.auth0.com/#/apis) section.\n\n![Configure Permissions](https://auth0.com/docs/media/articles/server-apis/configure-permissions.png)\n\nThis example demonstrates:\n\n*   How to check for a JSON Web Token (JWT) in the `Authorization` header of an incoming HTTP request.\n    \n*   How to check if the token is valid, using the [JSON Web Key Set (JWKS)](https://auth0.com/docs/tokens/concepts/jwks) for your Auth0 account. To learn more about validating Access Tokens, see [Validate Access Tokens](https://auth0.com/docs/tokens/guides/validate-access-tokens).\n    \n\n## Setup the Django Application\n\n### Install dependencies\n\nAdd the following dependencies to your `requirements.txt` and run `pip install -r requirements.txt`.\n\n```\ncryptography~=2.8\ndjango~=2.2.7\ndjangorestframework~=3.10.31\ndjango-cors-headers~=3.1.1\ndrf-jwt~=1.13.3\npyjwt~=1.7.1\nrequests~=2.22.0\n```\n\n### Create a Django project\n\nThis guide assumes you already have a Django application set up. If that is not the case, follow the steps in the [Django Tutorial](https://docs.djangoproject.com/en/2.2/intro/tutorial01/).\n\nThe sample project was created with the following commands:\n\n```\ndjango-admin startproject apiexample\ncd apiexample\npython manage.py startapp auth0authorization\n```\n\n### Add a Django remote user\n\nYou need to define a way to map the username from the Access Token payload to the Django authentication system user.\n\nAdd [`RemoteUserMiddleware`](https://docs.djangoproject.com/en/2.2/ref/middleware/#django.contrib.auth.middleware.RemoteUserMiddleware) middleware component after `AuthenticationMiddleware` to middleware list.\n\n```\n# apiexample/settings.py\n\nMIDDLEWARE = [\n    # ...\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.auth.middleware.RemoteUserMiddleware',\n]\n```\n\nAdd `ModelBackend` and `RemoteUserBackend` to the Authentication Backends.\n\n```\n# apiexample/settings.py\n\nAUTHENTICATION_BACKENDS = [\n    'django.contrib.auth.backends.ModelBackend',\n    'django.contrib.auth.backends.RemoteUserBackend',\n]\n```\n\nCreate `utils.py` file in your application's folder and define a function that maps the `sub` field from the `access_token` to the username. Then, the [authenticate](https://docs.djangoproject.com/en/2.2/ref/contrib/auth/#django.contrib.auth.backends.RemoteUserBackend.authenticate) method from [RemoteUserBackend](https://docs.djangoproject.com/en/2.2/ref/contrib/auth/#django.contrib.auth.backends.RemoteUserBackend) will create a remote user in the Django authentication system and return a User object for the username.\n\n```\n# auth0authorization/utils.py\n\nfrom django.contrib.auth import authenticate\n\ndef jwt_get_username_from_payload_handler(payload):\n    username = payload.get('sub').replace('|', '.')\n    authenticate(remote_user=username)\n    return username\n```\n\n## Validate Access Tokens\n\nThe `settings.py` file contains the configuration of the Django project.\n\nAdd `rest_framework` app to the `INSTALLED_APPS` entry.\n\n```\n# apiexample/settings.py\n\nINSTALLED_APPS = [\n    # ...\n    'rest_framework'\n]\n```\n\nAdd `JSONWebTokenAuthentication` to Django REST framework's `DEFAULT_AUTHENTICATION_CLASSES`.\n\n```\n# apiexample/settings.py\n\nREST_FRAMEWORK = {\n    'DEFAULT_PERMISSION_CLASSES': (\n        'rest_framework.permissions.IsAuthenticated',\n    ),\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n        'rest_framework.authentication.BasicAuthentication',\n    ),\n}\n```\n\nConfigure the [Django REST Framework JWK](https://github.com/Styria-Digital/django-rest-framework-jwt/) by setting the `JWT_AUTH` variable.\n\nSet the `JWT_AUDIENCE` to your API identifier and the `JWT_ISSUER` to your Auth0 domain. By default, those values will be retrieved from the `.env` file.\n\n```\n# apiexample/settings.py\n\nJWT_AUTH = {\n    'JWT_PAYLOAD_GET_USERNAME_HANDLER':\n        'auth0authorization.utils.jwt_get_username_from_payload_handler',\n    'JWT_DECODE_HANDLER':\n        'auth0authorization.utils.jwt_decode_token',\n    'JWT_ALGORITHM': 'RS256',\n    'JWT_AUDIENCE': '{yourApiIdentifier}',\n    'JWT_ISSUER': 'https://{yourDomain}/',\n    'JWT_AUTH_HEADER_PREFIX': 'Bearer',\n}\n```\n\nCreate the function to fetch the JWKS from your Auth0 account to verify and decode the incoming Access Token.\n\n```\n# auth0authorization/utils.py\n\nimport json\n\nimport jwt\nimport requests\n\ndef jwt_decode_token(token):\n    header = jwt.get_unverified_header(token)\n    jwks = requests.get('https://{}/.well-known/jwks.json'.format('{yourDomain}')).json()\n    public_key = None\n    for jwk in jwks['keys']:\n        if jwk['kid'] == header['kid']:\n            public_key = jwt.algorithms.RSAAlgorithm.from_jwk(json.dumps(jwk))\n\n    if public_key is None:\n        raise Exception('Public key not found.')\n\n    issuer = 'https://{}/'.format('{yourDomain}')\n    return jwt.decode(token, public_key, audience='{yourApiIdentifier}', issuer=issuer, algorithms=['RS256'])\n```\n\n### Validate scopes\n\nAdd the following methods to the `views.py` file to create a decorator that will check the granted scopes from the `access_token`.\n\n```\n# auth0authorization/views.py\n\nfrom functools import wraps\nimport jwt\n\nfrom django.http import JsonResponse\n\ndef get_token_auth_header(request):\n    \"\"\"Obtains the Access Token from the Authorization Header\n    \"\"\"\n    auth = request.META.get(\"HTTP_AUTHORIZATION\", None)\n    parts = auth.split()\n    token = parts[1]\n\n    return token\n\ndef requires_scope(required_scope):\n    \"\"\"Determines if the required scope is present in the Access Token\n    Args:\n        required_scope (str): The scope required to access the resource\n    \"\"\"\n    def require_scope(f):\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            token = get_token_auth_header(args[0])\n            decoded = jwt.decode(token, verify=False)\n            if decoded.get(\"scope\"):\n                token_scopes = decoded[\"scope\"].split()\n                for token_scope in token_scopes:\n                    if token_scope == required_scope:\n                        return f(*args, **kwargs)\n            response = JsonResponse({'message': 'You don\\'t have access to this resource'})\n            response.status_code = 403\n            return response\n        return decorated\n    return require_scope\n```\n\n## Protect API Endpoints\n\nThe routes shown below are available for the following requests:\n\n*   `GET /api/public`: available for non-authenticated requests\n*   `GET /api/private`: available for authenticated requests containing an access token with no additional scopes\n*   `GET /api/private-scoped`: available for authenticated requests containing an access token with the `read:messages` scope granted\n\nIn the file `views.py` add `public` and `private` endpoints. Add the `@api_view` decorator to all the endpoints to indicate that the method requires authentication. Lastly, add the decorator `@permission_classes([AllowAny])` to the `public` endpoint to accept unauthenticated requests.\n\n```\n# auth0authorization/views.py\n\nfrom django.http import JsonResponse\nfrom rest_framework.decorators import api_view, permission_classes\nfrom rest_framework.permissions import AllowAny\n\n@api_view(['GET'])\n@permission_classes([AllowAny])\ndef public(request):\n    return JsonResponse({'message': 'Hello from a public endpoint! You don\\'t need to be authenticated to see this.'})\n\n\n@api_view(['GET'])\ndef private(request):\n    return JsonResponse({'message': 'Hello from a private endpoint! You need to be authenticated to see this.'})\n```\n\nUse the `requires_scope` decorator in the methods that require specific scopes granted. The method below requires the `read:messages` scope granted.\n\n```\n# auth0authorization/views.py\n\n@api_view(['GET'])\n@requires_scope('read:messages')\ndef private_scoped(request):\n    return JsonResponse({'message': 'Hello from a private endpoint! You need to be authenticated and have a scope of read:messages to see this.'})\n```\n\n### Add URL mappings\n\nIn previous steps, we added methods to the `views.py` file. We need to map those methods to URLs.\n\nDjango has a [URL dispatcher](https://docs.djangoproject.com/en/2.2/topics/http/urls/) that lets you map URL patterns to views.\n\nCreate the file `urls.py` in your application folder. Add the URL patterns.\n\n```\n# auth0authorization/urls.py\n\nfrom django.urls import path\n\nfrom . import views\n\nurlpatterns = [\n    path('api/public', views.public),\n    path('api/private', views.private),\n    path('api/private-scoped', views.private_scoped),\n]\n```\n\nThe Django project also has a `urls.py` file. Add a reference to your application's `urls.py` file.\n\n```\n# apiexample/urls.py\n\nfrom django.contrib import admin\nfrom django.urls import include, path\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('auth0authorization.urls'))\n]\n```",
  "title": "Auth0 Django API SDK Quickstarts: Authorization",
  "description": "This tutorial demonstrates how to add authorization to a Django REST Framework API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/golang",
  "markdown": "# Auth0 Go SDK Quickstarts: Login\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Regular Web App](https://auth0.com/docs/quickstart/webapp)\n*   [Go](https://auth0.com/docs/quickstart/webapp/golang)\n\nThis tutorial demonstrates how to add user login to a Go web application using Auth0. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Go 1.21+\n\n## Configure Auth0\n\n### Get Your Application Keys\n\nWhen you signed up for Auth0, a new application was created for you, or you could have created a new one. You will need some details about that application to communicate with Auth0. You can get these details from the [Application Settings](https://manage.auth0.com/#/applications) section in the Auth0 dashboard.\n\n![App Dashboard](https://auth0.com/docs/media/articles/dashboard/client_settings.png)\n\nYou need the following information:\n\n*   **Domain**\n*   **Client ID**\n*   **Client Secret**\n\n### Configure Callback URLs\n\nA callback URL is a URL in your application where Auth0 redirects the user after they have authenticated. The callback URL for your app must be added to the **Allowed Callback URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log in to the application and will get an error.\n\n### Configure Logout URLs\n\nA logout URL is a URL in your application that Auth0 can return to after the user has been logged out of the authorization server. This is specified in the `returnTo` query parameter. The logout URL for your app must be added to the **Allowed Logout URLs** field in your [Application Settings](https://manage.auth0.com/#/applications). If this field is not set, users will be unable to log out from the application and will get an error.\n\n## Configure Go to Use Auth0\n\n### Download dependencies\n\nStart by adding a `go.mod` file to list all the dependencies to be used.\n\n```\n// go.mod\n\nmodule 01-Login\n\ngo 1.21\n\nrequire (\n\tgithub.com/coreos/go-oidc/v3 v3.8.0\n\tgithub.com/gin-contrib/sessions v0.0.5\n\tgithub.com/gin-gonic/gin v1.9.1\n\tgithub.com/joho/godotenv v1.5.1\n\tgolang.org/x/oauth2 v0.15.0\n)\n```\n\nWe can now make the dependencies available for us by running the following shell command:\n\n### Configure your application\n\nCreate a `.env` file within the root of your project directory to store the app configuration, and fill in the environment variables:\n\n```\n# The URL of our Auth0 Tenant Domain.\n# If you're using a Custom Domain, be sure to set this to that value instead.\nAUTH0_DOMAIN='{yourDomain}'\n\n# Our Auth0 application's Client ID.\nAUTH0_CLIENT_ID='{yourClientId}'\n\n# Our Auth0 application's Client Secret.\nAUTH0_CLIENT_SECRET='{yourClientSecret}'\n\n# The Callback URL of our application.\nAUTH0_CALLBACK_URL='http://localhost:3000/callback'\n```\n\n### Configure OAuth2 and OpenID Connect packages\n\nCreate a file called `auth.go` in the `platform/authenticator` folder. In this package you'll create a method to configure and return [OAuth2](https://godoc.org/golang.org/x/oauth2) and [oidc](https://godoc.org/github.com/coreos/go-oidc) clients, and another one to verify an ID Token.\n\n```\n// platform/authenticator/auth.go\n\npackage authenticator\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"os\"\n\n\t\"github.com/coreos/go-oidc/v3/oidc\"\n\t\"golang.org/x/oauth2\"\n)\n\n// Authenticator is used to authenticate our users.\ntype Authenticator struct {\n\t*oidc.Provider\n\toauth2.Config\n}\n\n// New instantiates the *Authenticator.\nfunc New() (*Authenticator, error) {\n\tprovider, err := oidc.NewProvider(\n\t\tcontext.Background(),\n\t\t\"https://\"+os.Getenv(\"AUTH0_DOMAIN\")+\"/\",\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconf := oauth2.Config{\n\t\tClientID:     os.Getenv(\"AUTH0_CLIENT_ID\"),\n\t\tClientSecret: os.Getenv(\"AUTH0_CLIENT_SECRET\"),\n\t\tRedirectURL:  os.Getenv(\"AUTH0_CALLBACK_URL\"),\n\t\tEndpoint:     provider.Endpoint(),\n\t\tScopes:       []string{oidc.ScopeOpenID, \"profile\"},\n\t}\n\n\treturn &Authenticator{\n\t\tProvider: provider,\n\t\tConfig:   conf,\n\t}, nil\n}\n\n// VerifyIDToken verifies that an *oauth2.Token is a valid *oidc.IDToken.\nfunc (a *Authenticator) VerifyIDToken(ctx context.Context, token *oauth2.Token) (*oidc.IDToken, error) {\n\trawIDToken, ok := token.Extra(\"id_token\").(string)\n\tif !ok {\n\t\treturn nil, errors.New(\"no id_token field in oauth2 token\")\n\t}\n\n\toidcConfig := &oidc.Config{\n\t\tClientID: a.ClientID,\n\t}\n\n\treturn a.Verifier(oidcConfig).Verify(ctx, rawIDToken)\n}\n```\n\n### Setting up your application routes\n\nCreate a file called `router.go` in the `platform/router` folder. In this package you'll create a method to configure and return our routes using [github.com/gin-gonic/gin](https://github.com/gin-gonic/gin). You will be passing an instance of `Authenticator` to the method, so it can be used within the `login` and `callback` handlers.\n\n```\n// platform/router/router.go\n\npackage router\n\nimport (\n\t\"encoding/gob\"\n\t\"net/http\"\n\n\t\"github.com/gin-contrib/sessions\"\n\t\"github.com/gin-contrib/sessions/cookie\"\n\t\"github.com/gin-gonic/gin\"\n\n\t\"01-Login/platform/authenticator\"\n\t\"01-Login/platform/middleware\"\n\t\"01-Login/web/app/callback\"\n\t\"01-Login/web/app/login\"\n\t\"01-Login/web/app/logout\"\n\t\"01-Login/web/app/user\"\n)\n\n// New registers the routes and returns the router.\nfunc New(auth *authenticator.Authenticator) *gin.Engine {\n\trouter := gin.Default()\n\n\t// To store custom types in our cookies,\n\t// we must first register them using gob.Register\n\tgob.Register(map[string]interface{}{})\n\n\tstore := cookie.NewStore([]byte(\"secret\"))\n\trouter.Use(sessions.Sessions(\"auth-session\", store))\n\n\trouter.Static(\"/public\", \"web/static\")\n\trouter.LoadHTMLGlob(\"web/template/*\")\n\n\trouter.GET(\"/\", func(ctx *gin.Context) {\n\t\tctx.HTML(http.StatusOK, \"home.html\", nil)\n\t})\n\trouter.GET(\"/login\", login.Handler(auth))\n\trouter.GET(\"/callback\", callback.Handler(auth))\n\trouter.GET(\"/user\", user.Handler)\n\trouter.GET(\"/logout\", logout.Handler)\n\n\treturn router\n}\n```\n\n### Serving your application\n\nNext, let's create our application's entry point `main.go` and wire everything up together:\n\n```\n// main.go\n\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/joho/godotenv\"\n\n\t\"01-Login/platform/authenticator\"\n\t\"01-Login/platform/router\"\n)\n\nfunc main() {\n\tif err := godotenv.Load(); err != nil {\n\t\tlog.Fatalf(\"Failed to load the env vars: %v\", err)\n\t}\n\n\tauth, err := authenticator.New()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to initialize the authenticator: %v\", err)\n\t}\n\n\trtr := router.New(auth)\n\n\tlog.Print(\"Server listening on http://localhost:3000/\")\n\tif err := http.ListenAndServe(\"0.0.0.0:3000\", rtr); err != nil {\n\t\tlog.Fatalf(\"There was an error with the http server: %v\", err)\n\t}\n}\n```\n\n## Logging In\n\nCreate a file called `login.go` in the `web/app/login` folder, and add a `Handler` function to handle the `/login` route.\n\n```\n// web/app/login/login.go\n\npackage login\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"net/http\"\n\n\t\"github.com/gin-contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n\n\t\"01-Login/platform/authenticator\"\n)\n\n// Handler for our login.\nfunc Handler(auth *authenticator.Authenticator) gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\tstate, err := generateRandomState()\n\t\tif err != nil {\n\t\t\tctx.String(http.StatusInternalServerError, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// Save the state inside the session.\n\t\tsession := sessions.Default(ctx)\n\t\tsession.Set(\"state\", state)\n\t\tif err := session.Save(); err != nil {\n\t\t\tctx.String(http.StatusInternalServerError, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tctx.Redirect(http.StatusTemporaryRedirect, auth.AuthCodeURL(state))\n\t}\n}\n\nfunc generateRandomState() (string, error) {\n\tb := make([]byte, 32)\n\t_, err := rand.Read(b)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tstate := base64.StdEncoding.EncodeToString(b)\n\n\treturn state, nil\n}\n```\n\nAdd a link to `/login` route in the `home.html` template.\n\n```\n<!-- web/template/home.html -->\n\n<div>\n    <h3>Auth0 Example</h3>\n    <p>Zero friction identity infrastructure, built for developers</p>\n    <a href=\"/login\">SignIn</a>\n</div>\n```\n\n## Handling Authentication Callback\n\nOnce users have authenticated using Auth0's Universal Login Page, they'll return to the app at the `/callback` route that will be handled in the following `Handler` function:\n\n```\n// web/app/callback/callback.go\n\npackage callback\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n\n\t\"01-Login/platform/authenticator\"\n)\n\n// Handler for our callback.\nfunc Handler(auth *authenticator.Authenticator) gin.HandlerFunc {\n\treturn func(ctx *gin.Context) {\n\t\tsession := sessions.Default(ctx)\n\t\tif ctx.Query(\"state\") != session.Get(\"state\") {\n\t\t\tctx.String(http.StatusBadRequest, \"Invalid state parameter.\")\n\t\t\treturn\n\t\t}\n\n\t\t// Exchange an authorization code for a token.\n\t\ttoken, err := auth.Exchange(ctx.Request.Context(), ctx.Query(\"code\"))\n\t\tif err != nil {\n\t\t\tctx.String(http.StatusUnauthorized, \"Failed to exchange an authorization code for a token.\")\n\t\t\treturn\n\t\t}\n\n\t\tidToken, err := auth.VerifyIDToken(ctx.Request.Context(), token)\n\t\tif err != nil {\n\t\t\tctx.String(http.StatusInternalServerError, \"Failed to verify ID Token.\")\n\t\t\treturn\n\t\t}\n\n\t\tvar profile map[string]interface{}\n\t\tif err := idToken.Claims(&profile); err != nil {\n\t\t\tctx.String(http.StatusInternalServerError, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tsession.Set(\"access_token\", token.AccessToken)\n\t\tsession.Set(\"profile\", profile)\n\t\tif err := session.Save(); err != nil {\n\t\t\tctx.String(http.StatusInternalServerError, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// Redirect to logged in page.\n\t\tctx.Redirect(http.StatusTemporaryRedirect, \"/user\")\n\t}\n}\n```\n\n## Displaying User Information\n\nYou can access the user information via the `profile` you stored in the session previously.\n\n```\n// web/app/user/user.go\n\npackage user\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\n\n// Handler for our logged-in user page.\nfunc Handler(ctx *gin.Context) {\n\tsession := sessions.Default(ctx)\n\tprofile := session.Get(\"profile\")\n\n\tctx.HTML(http.StatusOK, \"user.html\", profile)\n}\n```\n\n```\n<!-- web/template/user.html -->\n\n<div>\n    <img class=\"avatar\" src=\"{{ .picture }}\"/>\n    <h2>Welcome {{.nickname}}</h2>\n</div>\n```\n\nFor information about the userinfo hash, see [User Profile](https://auth0.com/docs/users/concepts/overview-user-profile).\n\n## Logging Out\n\nTo log the user out, clear the data from the session and redirect the user to the Auth0 logout endpoint. You can find more information about this in the [logout documentation](https://auth0.com/docs/logout).\n\nCreate a file called `logout.go` in the folder `web/app/logout/logout.go`, and add the function `Handler` to redirect the user to Auth0's logout endpoint.\n\n```\n// web/app/logout/logout.go\n\npackage logout\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\n// Handler for our logout.\nfunc Handler(ctx *gin.Context) {\n\tlogoutUrl, err := url.Parse(\"https://\" + os.Getenv(\"AUTH0_DOMAIN\") + \"/v2/logout\")\n\tif err != nil {\n\t\tctx.String(http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tscheme := \"http\"\n\tif ctx.Request.TLS != nil {\n\t\tscheme = \"https\"\n\t}\n\n\treturnTo, err := url.Parse(scheme + \"://\" + ctx.Request.Host)\n\tif err != nil {\n\t\tctx.String(http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tparameters := url.Values{}\n\tparameters.Add(\"returnTo\", returnTo.String())\n\tparameters.Add(\"client_id\", os.Getenv(\"AUTH0_CLIENT_ID\"))\n\tlogoutUrl.RawQuery = parameters.Encode()\n\n\tctx.Redirect(http.StatusTemporaryRedirect, logoutUrl.String())\n}\n```\n\nCreate a file called `user.js` in the folder `web/static/js`, and add the code to remove the cookie from a logged-in user.\n\n```\n$(document).ready(function () {\n    $('.btn-logout').click(function (e) {\n        Cookies.remove('auth-session');\n    });\n});\n```\n\n## Optional Steps\n\n### Checking if the user is authenticated\n\nCreate a middleware that will check if the user is authenticated or not based on the `profile` session key:\n\n```\n// platform/middleware/isAuthenticated.go\n\npackage middleware\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\n\n// IsAuthenticated is a middleware that checks if\n// the user has already been authenticated previously.\nfunc IsAuthenticated(ctx *gin.Context) {\n\tif sessions.Default(ctx).Get(\"profile\") == nil {\n\t\tctx.Redirect(http.StatusSeeOther, \"/\")\n\t} else {\n\t\tctx.Next()\n\t}\n}\n```\n\nFinally, set up this middleware for any route that needs authentication by adding it to the router.\n\n```\n// platform/router/router.go\n\nrouter.GET(\"/user\", middleware.IsAuthenticated, user.Handler)\n```",
  "title": "Auth0 Go SDK Quickstarts: Login",
  "description": "This tutorial demonstrates how to add user login to a Go web application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens",
  "markdown": "# Get Access Tokens\n\nTo access your API, you must request an [access token](https://auth0.com/docs/secure/tokens/access-tokens) when authenticating a user.\n\nTo request an access token, make a POST call to the [token URL](https://auth0.com/docs/api/authentication#client-credentials-flow).\n\n#### Example POST to token URL\n\n*   [cURL](#d73c598283194c6bb9214bd195de631d_shell)\n*   [C#](#d73c598283194c6bb9214bd195de631d_csharp)\n*   [Go](#d73c598283194c6bb9214bd195de631d_go)\n*   [Java](#d73c598283194c6bb9214bd195de631d_java)\n*   [Node.JS](#d73c598283194c6bb9214bd195de631d_node)\n*   [Obj-C](#d73c598283194c6bb9214bd195de631d_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data client_id=YOUR_CLIENT_ID \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data audience=YOUR_API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: 'YOUR_CLIENT_ID',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: 'YOUR_API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id=YOUR_CLIENT_ID\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=YOUR_API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id=YOUR_CLIENT_ID\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=YOUR_API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to \"client\\_credentials\". |\n| `client_id` | Your application's Client ID. You can find this value on the [application's settings tab](https://manage.auth0.com/#/applications). |\n| `client_secret` | Your application's Client Secret. You can find this value on the [application's settings tab](https://manage.auth0.com/#/applications). To learn more about available application authentication methods, read [Application Credentials](https://auth0.com/docs/secure/application-credentials). |\n| `audience` | The audience for the token, which is your API. You can find this in the **Identifier** field on your [API's settings tab](https://manage.auth0.com/#/apis). |\n\n#### Response\n\nYou receive an `HTTP 200` response with a payload containing `access_token`, `token_type`, and `expires_in` values:\n\n```\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n## Control access token audience\n\nWhen a user authenticates, you request an access token and include the target audience and scope of access in your request. The application uses the `/authorize` endpoint to request access. This access is both requested by the application and granted by the user during authentication\n\nYou can configure your tenant to always include a default audience.\n\n| Token Use | Format | Requested Audience | Requested Scope |\n| --- | --- | --- | --- |\n| /userinfo endpoint | Opaque | tenant name (`{yourDomain}`), no value for `audience` parameter, no `audience` parameter passed | `openid` |\n| Auth0 Management API | JWT | Management API v2 identifier (`https://{tenant}.auth0.com/api/v2/`) |     |\n| Your own custom API | JWT | The API Identifier for your custom API registered in the Auth0 Dashboard |     |\n\nIn only one specific instance, access tokens can have multiple target audiences. This requires that your custom API's signing algorithm is set to **RS256**. To learn more, read [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices).\n\n### Multiple audiences\n\nIf you specify an audience of your custom API identifier and a scope of `openid`, then the resulting access token's `aud` claim will be an array rather than a string, and the access token will be valid for both your custom API and for the `/userinfo` endpoint. Your access tokens can have two or more audiences only if you use a single custom API as well as Auth0's `/userinfo` endpoint, y.\n\n### Custom domains and the Auth0 Management API\n\nAuth0 issues tokens with an issuer (`iss)` claim of whichever domain you used when requesting the token. [Custom domain](https://auth0.com/docs/customize/custom-domains) users can use either their custom domain or their Auth0 domain.\n\nFor example, suppose you have a custom domain, `https://login.northwind.com`. If you request an access token from `https://login.northwind.com/authorize`, your token's `iss` claim will be `https://login.northwind.com/`. However, if you request an access token from `https://northwind.auth0.com/authorize`, your token's `iss` claim will be `https://northwind.auth0.com/`.\n\nIf you request an access token from your custom domain with the target audience of the Auth0 Management API, then you **must** call the Auth0 Management API from your custom domain. Otherwise your access token is considered invalid.\n\n## Renew access tokens\n\nBy default, an access token for a custom API is valid for 86400 seconds (24 hours). You can [shorten the time period before the token expires](https://auth0.com/docs/secure/tokens/access-tokens/update-access-token-lifetime).\n\nAfter an access token has expired, you can renew your access token. To do so either re-authenticate the user using Auth0 or use a [](https://auth0.com/docs/tokens/concepts/refresh-tokens)[refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\n## Learn more\n\n*   [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens)\n*   [Use Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/use-access-tokens)\n*   [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens)\n*   [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens)\n*   [Identity Provider Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/identity-provider-access-tokens)\n*   [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens)",
  "title": "Get Access Tokens",
  "description": "Learn how to request Access Tokens using the Authorize endpoint when authenticating users and include the target audience and scope of access requested by the app and granted by the user.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/rbac",
  "markdown": "# Role-Based Access Control\n\nRole-based access control (RBAC) refers to the idea of assigning permissions to users based on their role within an organization. It offers a simple, manageable approach to access management that is less prone to error than assigning permissions to users individually.\n\nWhen using RBAC for Role Management, you analyze the needs of your users and group them into roles based on common responsibilities. You then assign one or more roles to each user and one or more permissions to each role. The user-role and role-permissions relationships make it simple to perform user assignments since users no longer need to be managed individually, but instead have privileges that conform to the permissions assigned to their role(s).\n\nFor example, if you were using RBAC to control access for an HR application, you could give HR managers a role that allows them to update employee details, while other employees would be able to view only their own details.\n\nWhen planning your access control strategy, it's best practice to assign users the fewest number of permissions that allow them to get their work done.\n\n## Benefits of RBAC\n\nWith RBAC, access management is easier as long as you adhere strictly to the role requirements. RBAC helps you:\n\n*   create systematic, repeatable assignment of permissions\n    \n*   easily audit user privileges and correct identified issues\n    \n*   quickly add and change roles, as well as implement them across APIs\n    \n*   cut down on the potential for error when assigning user permissions\n    \n*   integrate third-party users by giving them pre-defined roles\n    \n*   more effectively comply with regulatory and statutory requirements for confidentiality and privacy\n    \n\n## RBAC Model\n\n### Roles\n\nEssentially, a role is a collection of permissions that you can apply to users. Using roles makes it easier to add, remove, and adjust permissions than assigning permissions to users individually. As your user base increases in scale and complexity, roles become particularly useful.\n\nYou can also use roles to collect permissions defined for various APIs. For example, say you have a marketing module that allows users to create and distribute newsletters to customers. Your marketing content specialist creates all of the newsletters and prepares them for distribution. Similarly, you have an event module that allows users to create, publish, and manage event registration. Your event coordinator creates the events. Once the VP of Marketing approves the newsletters and events, their assistant publishes the events and distributes the newsletters. In this case, your Newsletter API could have a `distribute:newsletters` permission and your Event API could have a `publish:events` permission. These permissions could then be gathered into a role called `Marketing Publisher` and assigned to the VP of Marketing's assistant.\n\nIn addition, Organization-specific roles can be [added to Organization members](https://auth0.com/docs/manage-users/organizations/configure-organizations/add-member-roles) and used to allow access in your application based on the organizations with which an end-user is logging in. This is particularly useful when supporting multi-tenant & SaaS products, where a particular user might have a privileged role in one organization, but not in others.\n\n## Overlapping role assignments\n\nRBAC is an additive model, so if you have overlapping role assignments, your effective permissions are the union of your role assignments.\n\nFor example, let's say you have an API that provides data for an event application. You create a role of `Organizer` and assign it permissions that allow it to view, create, and edit events. You also create a role of `Registrant` and assign it permissions that allow it to view and register for events. Any users with both `Organizer` and `Registrant` roles will be able to view, create, edit, and register for events.\n\n## Role-based access control in Auth0\n\nCurrently, we provide two ways of implementing role-based access control (RBAC), which you can use in place of or in combination with your API's own internal access control system:\n\n*   [Authorization Core](https://auth0.com/docs/manage-users/access-control/configure-core-rbac)\n    \n*   [Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension)\n    \n\nWe are expanding our Authorization Core feature set to match the functionality of the Authorization Extension. Our new core RBAC implementation improves performance and scalability and will eventually provide a more flexible RBAC system than the Authorization Extension.\n\nFor now, both implement the key features of RBAC and allow you to restrict the custom scopes defined for an API to those that have been assigned to the user as permissions. For a comparison, see [Authorization Core vs. Authorization Extension](https://auth0.com/docs/manage-users/access-control/authorization-core-vs-authorization-extension).\n\n### Extending RBAC\n\nYou can provide more control by using [rules](https://auth0.com/docs/customize/rules) to restrict access based on a combination of attributes, such as user department, time of day, location of access, or any other user or API attribute (for example, username, security clearance, or API name).\n\nFor more info about using rules with authorization policies, see [Rules with Authorization Policies](https://auth0.com/docs/manage-users/access-control/rules-for-authorization-policies).\n\n## Learn more\n\n*   [Enable Role-Based Access Control for APIs](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis)\n*   [Troubleshoot Role-Based Access Control and Authorization](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-rbac-authorization)\n*   [Troubleshoot Authorization Extension](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-authorization-extension)",
  "title": "Role-Based Access Control",
  "description": "Understand the concept of role-based access control and how it applies in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens",
  "markdown": "# Validate Access Tokens\n\nAn access token is meant for an API and should be validated only by the API for which it was intended.\n\nIf any of these checks fail, the token is considered invalid, and the request must be rejected with `401 Unauthorized` result.\n\n1.  **Perform standard JWT validation.** Because the access token is a JWT, you need to perform the standard JWT validation steps. See [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens) for details.\n    \n2.  **Verify token audience claims.** If you've performed the standard JWT validation, you have already decoded the JWT's payload and looked at its standard claims. The token audience claim (`aud`, array of strings) depends on the initial token request. The `aud` field could contain both an audience corresponding to your custom API and an audience corresponding to the `/userinfo` endpoint. At least one of the audience values for the token must match the unique identifier of the target API as defined in your [API's Settings](https://manage.auth0.com/#/apis) in the **Identifier** field. See [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens) for details.\n    \n3.  **Verify permissions (scopes).** Verify that the application has been granted the permissions required to access your API. To do so, you will need to check the `scope` claim (`scope`, space-separated list of strings) in the decoded JWT's payload. It should match the permissions required for the endpoint being accessed. For example, if your custom API provides three endpoints to read, create, or delete a user record, when you registered your API with Auth0, you created three corresponding permissions:\n    \n    1.  `create:users` provides access to the `/create` endpoint\n        \n    2.  `read:users` provides access to the `/read` endpoint\n        \n    3.  `delete:users` provides access to the `/delete` endpoint\n        \n    \n    In this case, if an application requests access the `/create` endpoint, but the access token's `scope` claim does not include the value `create:users`, then the API should reject the request.\n    \n\n## Learn more\n\n*   [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens)\n*   [Use Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/use-access-tokens)\n*   [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens)\n*   [Get Management API Access Tokens for Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Validate Access Tokens",
  "description": "Describes how to validate an access token.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/flows/concepts/auth-code",
  "markdown": "# Authorization Code Flow\n\nThe Authorization Code Flow (defined in [OAuth 2.0 RFC 6749, section 4.1](https://tools.ietf.org/html/rfc6749#section-4.1)), involves exchanging an authorization code for a token.\n\nThis flow can only be used for confidential applications (such as Regular Web Applications) because the application's authentication methods are included in the exchange and must be kept secure.\n\n![Auth - Auth code flow- Authorization sequence diagram](https://images.ctfassets.net/cdy7uua7fh8z/7mWk9No612EefC8uBidCqr/821eb60b0aa953b0d8e4afe897228844/Auth-code-flow-diagram.png)\n\n1.  User selects **Login** within application.\n    \n2.  Auth0's SDK redirects user to Auth0 Authorization Server ([`/authorize` endpoint](https://auth0.com/docs/api/authentication#authorization-code-grant)).\n    \n3.  Auth0 Authorization Server redirects user to login and authorization prompt.\n    \n4.  User authenticates using one of the configured login options, and may see a consent prompt listing the permissions Auth0 will give to the application.\n    \n5.  Auth0 Authorization Server redirects user back to application with single-use authorization code.\n    \n6.  Auth0's SDK sends authorization code, application's client ID, and application's credentials, such as client secret or Private Key JWT, to Auth0 Authorization Server ([`**/oauth/token**` endpoint](https://auth0.com/docs/api/authentication?http#authorization-code-flow43)).\n    \n7.  Auth0 Authorization Server verifies authorization code, application's client ID, and application's credentials.\n    \n8.  Auth0 Authorization Server responds with an ID token and access token (and optionally, a refresh token).\n    \n9.  Application can use the access token to call an API to access information about the user.\n    \n10.  API responds with requested data.\n    \n\n## How to implement Authorization Code Flow\n\nThe easiest way to implement the Authorization Code Flow is to follow our [Regular Web App Quickstarts](https://auth0.com/docs/quickstart/webapp).\n\nAlternatively, you can use the Authentication API to implement the Authorization Code Flow. For more information, read [Add Login Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow) or [Call Your API Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/call-your-api-using-the-authorization-code-flow).\n\n## Learn more\n\n*   [Auth0 Rules](https://auth0.com/docs/customize/rules)\n*   [Auth0 Hooks](https://auth0.com/docs/customize/hooks)\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)",
  "title": "Authorization Code Flow",
  "description": "Learn how the Authorization Code flow works and why you should use it for regular web apps.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/architecture-scenarios/web-app-sso",
  "markdown": "# Regular Web Applications with Single Sign-On\n\nIn this scenario, we will build a web application for a fictitious company named ExampleCo. The app is meant to be used by ExampleCo's employees and contractors. Employees will use their existing corporate directory (Active Directory), while contractors will be managed in a separate user store.\n\n### TL;DR\n\n*   Auth0 supports open standards such as OAuth 2.0 and OpenID Connect (OIDC) for authentication and authorization (see [Which protocol to use](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-1#which-protocol-to-use))\n*   OIDC supports several different authorization flows - the most appropriate one for Web Applications being the Authorization Code Flow (see [Authentication Flow](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-1#authentication-flow))\n*   Your application will be configured in Auth0 as an application (see [Application](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-2#application))\n*   Identity Providers will be configured in Auth0 as a Connection (see [Connections](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-2#connections))\n*   Auth0 provides a Lock widget, which allow users to log in to the application (see [User Login](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-3#user-login))\n*   The web application needs to manage session state to keep track of the fact that the user is logged in. Along with this, Auth0 and the Identity Provider is also managing session information. (see [Session Management](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-3#session-management))\n*   Conversely, logging a user out also involves three layers of session management (see [User Logout](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-3#user-logout))\n*   Access Control can be managed with the Auth0 Authorization Extension (see [Access Control](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-3#access-control))\n\n## The Premise\n\nExampleCo is a consulting startup company. Currently they have approximately 100 employees and they also outsource several activities to external contractors. Most of the employees work from the company's main office, but there are some teams that work remotely. Additionally, some employees frequently travel to customer locations and work from mobile devices.\n\nAll employees and external contractors are required to fill in their timesheets every week using spreadsheets. The current system is inefficient and the company decided that they need to move to a better and more automated solution.\n\nThe company evaluated several of the available timesheets application and concluded that it would be more cost-effective to build their own in-house solution, since they are looking for a very simple application at the moment. The app will be built using ASP.NET Core, since their developers are already using this technology and they can have the app ready in a week or so.\n\n### Goals & Requirements\n\nExampleCo wants to launch the new solution quickly so they chose to start simple and build into it as they gather feedback from their employees.\n\nThe application should be available to logged in users only. Each user will have a role, and based on this role, they should be able to perform certain actions and view specific data.\n\n### Authentication vs Authorization\n\nExampleCo wants to **authenticate** and **authorize** each user. Authentication has to do with identity: verifying that the user is indeed who they claim to be. Authorization is about deciding which resources a user should have access to, and what they should be allowed to do with those resources.\n\nExampleCo's timesheets app needs to support two roles: User and Admin:\n\n*   Someone with the User role can add timesheet entries, by specifying the date, the application and the hours worked. The Admin role also has this same right.\n    \n*   Those with the User role should have access only to their own timesheets entries.\n    \n*   Someone with the Admin role can additionally:\n    \n    *   Approve or reject timesheet entries of other users.\n        \n    *   Edit the application drop-down list of values (add, edit, delete).\n        \n\nEach user will be required to fill in their timesheets by the end of the week. They can either choose to register daily their timesheets or add the entries for the whole week together. The timesheets will have to be reviewed and approved by an Admin. The rejected entries will have to be updated by each employee and re-submitted for approval.\n\nThe company uses Active Directory for all employees and employees will sign into the Timesheet application using their Active Directory credentials. The external contractors can sign in with a username and password. Contractors are not on ExampleCo's corporate directory.\n\nExampleCo wants to minimize user login burden, but wants to maintain a level of security depending on the operation: submitting timesheet entries is lower risk than approving them. However the approved timesheets are used for customer charging so security is definitely a requirement. The authentication strategy should be flexible so it can adapt as the company grows. For example, they should easily be able to add additional authentication requirements, like multi-factor authentication, for Admins.\n\nThe solution should be available both to the employees with a physical presence in the company office, as well as to those working remotely, without the overhead of a VPN connection, hence the app should be deployed on a cloud provider like Heroku or Microsoft Azure.\n\n![Diagram of the solution](https://images.ctfassets.net/cdy7uua7fh8z/7hg1vqzNEJ2RG1JYw0pxFp/d5e88b45ef76d06b1e8d35ab49186e1d/solution-diagram.png)\n\n## Learn more\n\n*   [Solution Overview (Web Apps + SSO)](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-1)\n*   [Auth0 Configuration (Web Apps + SSO)](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-2)\n*   [Application Implementation (Web Apps + SSO)](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-3)\n*   [ASP.NET Core Implementation (Web Apps + SSO)](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/implementation-aspnetcore)\n*   [Conclusion (Web Apps + SSO)](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps/part-4)",
  "title": "Regular Web Applications with Single Sign-On",
  "description": "Regular web app scenario which needs to authenticate users using OpenID Connect (OIDC) single sign-on.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/tokens/concepts/signing-algorithms",
  "markdown": "# Signing Algorithms\n\nSigning algorithms are algorithms used to sign tokens issued for your application or API. A signature is part of a [JSON Web Token (JWT)](https://auth0.com/docs/secure/tokens/json-web-tokens) and is used to verify that the sender of the token is who it says it is and to ensure that the message wasn't changed along the way.\n\nYou can select from the following signing algorithms:\n\n*   **RS256 (RSA Signature with SHA-256)**: An asymmetric algorithm, which means that there are two keys: one public key and one private key that must be kept secret. Auth0 has the private key used to generate the signature, and the consumer of the JWT retrieves a public key from the metadata endpoints provided by Auth0 and uses it to validate the JWT signature.\n    \n*   **HS256 (HMAC with SHA-256)**: A symmetric algorithm, which means that there is only one private key that must be kept secret, and it is shared between the two parties. Since the same key is used both to generate the signature and to validate it, care must be taken to ensure that the key is not compromised. This private key (or secret) is created when you register your application (client secret) or API (signing secret) and choose the HS256 signing algorithm.\n    \n*   **PS256 (RSA Signature with SHA-256)**: An asymmetric algorithm, which means that there are two keys: one public key and one private key that must be kept secret. Auth0 has the private key used to generate the signature, and the consumer of the JWT retrieves a public key from the metadata endpoints provided by Auth0 and uses it to validate the JWT signature. Unlike RS256, the same JWT header and payload will generate a different signature each time.\n    \n\nThe most secure practice, and our recommendation, is to use RS256 because:\n\n*   With RS256, you are sure that only the holder of the private key (Auth0) can sign tokens, while anyone can check if the token is valid using the public key.\n    \n*   With RS256, if the private key is compromised, you can implement key rotation without having to re-deploy your application or API with the new secret (which you would have to do if using HS256).\n    \n\nFor troubleshooting help, review [Troubleshooting Invalid Token Errors](https://auth0.com/docs/troubleshoot/basic-issues/invalid-token-errors).\n\n## Learn more\n\n*   [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens)\n*   [Change Application Signing Algorithms](https://auth0.com/docs/get-started/applications/change-application-signing-algorithms)\n*   [Signing Keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys)\n*   [Rotate Signing Keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys/rotate-signing-keys)\n*   [Revoke Signing Keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys/revoke-signing-keys)\n*   [View Signing Certificates](https://auth0.com/docs/get-started/tenant-settings/signing-keys/view-signing-certificates)",
  "title": "Signing Algorithms",
  "description": "Describes signing algorithms and recommendations for configuring them in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/scopes/current/oidc-scopes",
  "markdown": "# OpenID Connect Scopes\n\nThis document discusses scopes included within the OpenID Connect (OIDC) authentication protocol. For more info about OIDC itself, read [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol).\n\nOpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to a user's details, like name and picture. Each scope returns a set of user attributes, which are called claims. The scopes an application should request depend on which user attributes the application needs. Once the user authorizes the requested scopes, the claims are returned in an ID Token and are also available through the [`/userinfo` endpoint](https://auth0.com/docs/api/authentication#get-user-info).\n\nFor example, let's say you have built a regular web application, registered it with Auth0, and have configured it to allow a user to log in using a username and password. Once a user logs in to your app, you want to auto-generate and send a personalized welcome email, including the user's name.\n\n1.  A user clicks **Login** within your app.\n    \n2.  Your app redirects the user to the Auth0 Authorization Server (`**/authorize**` endpoint), including the following scopes:\n    \n    *   `openid` (required; to indicate that the application intends to use OIDC to verify the user's identity)\n        \n    *   `profile` (so you can personalize the email with the user's name)\n        \n    *   `email` (so you know where to send the welcome email)\n        \n3.  Your Auth0 Authorization Server redirects the user to the login prompt.\n    \n4.  The user authenticates and sees a consent page listing the scopes Auth0 will give to your app, which include access to their profile information and email address.\n    \n5.  The user accepts and authorizes your app to have this level of access to their information stored by Auth0.\n    \n6.  Your app now has access to the user's profile information and email address.\n    \n\n## Standard claims\n\nStandard claims are intended to provide an application with user details, such as name, email, and picture, and are pre-defined for the OIDC protocol. These claims are returned in an ID Token and are also available through the [`/userinfo` endpoint](https://auth0.com/docs/api/authentication#get-user-info).\n\nYou can also create custom claims, which are claims that you define, control, and add to a token using [Auth0 Actions](https://auth0.com/docs/customize/actions/actions-overview). To learn more, read [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims).\n\nThe basic (and required) scope for OIDC is `openid`, which indicates that an application intends to use the OIDC protocol to verify a user's identity. Beyond that, an application can ask for additional scopes by listing the requested scope names in the `scope` parameter, separated by spaces.\n\nStandard claims included in the most commonly-used scopes are listed below, but for a full list of available standard claims, read [OIDC specification: Standard Claims on openid.net](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). For a full list of Scopes, see [OIDC specification: Requesting Claims Using Scope Values on openid.net](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims).\n\n| Scope | Claims |\n| --- | --- |\n| `openid` | (required) Returns the `sub` claim, which uniquely identifies the user. In an ID Token, `iss`, `aud`, `exp`, `iat`, and `at_hash` claims will also be present. To learn more about the ID Token claims, read [ID Token Structure](https://auth0.com/docs/tokens/id-tokens/id-token-structure). |\n| `profile` | Returns claims that represent basic profile information, including `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `picture`, and `updated_at`. |\n| `email` | Returns the `email` claim, which contains the user's email address, and `email_verified`, which is a boolean indicating whether the email address was verified by the user. |\n\nFor an example showing how to request standard claims for your application, read [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims).\n\n## Learn more\n\n*   [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims)\n*   [Scopes](https://auth0.com/docs/get-started/apis/scopes)\n*   [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims)",
  "title": "OpenID Connect Scopes",
  "description": "Understand scopes and claims used with the OpenID Connect (OIDC) protocol.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/social/devkeys",
  "markdown": "# Test Social Connections with Auth0 Developer Keys\n\nWhen using any of the available [social identity providers](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers), you need to register your application with the relevant identity provider in order to obtain a Client ID and Client Secret.\n\nAuth0 developer keys are not available in [Private Cloud deployments](https://auth0.com/docs/deploy-monitor).\n\nFor production environments, make sure to [follow the steps for your chosen provider](https://auth0.com/docs/authenticate/identity-providers) to obtain the Client ID and Client Secret from the provider to avoid the [limitations](#limitations-of-developer-keys) of using developer keys. For instructions on converting Google developer keys to production keys, [read this Auth0 Developer Lab.](https://developer.auth0.com/resources/labs/authentication/google-social-connection-to-login#set-up-google-production-keys)\n\n#### Custom developer keys\n\nOne or more connections are using Auth0 development keys which are only intended for use in development and testing. The connections should be configured with your own Developer Keys to enable the consent page to show your logo instead of Auth0's and to configure Single Sign-on (SSO) for these connections. Auth0 development keys are not recommended for Production environments.\n\n#### Client ID and Client Secret\n\nThe exact terminology of a Client ID / Client Secret may differ between various Identity Providers. For example, X refers to these as a Consumer Key / Consumer Secret and LinkedIn refers to an API Key / Secret Key.\n\n## Limitations of developer keys\n\nThe Auth0 developer keys are to be used for testing purposes so there are a few caveats you need to be aware of when using them. These may cause your application to behave differently--or some functionality to not work at all--depending on whether you use your own Client ID and Client Secret, or whether you use the Auth0 developer keys.\n\nWhen using the Auth0 developer keys, the authentication flow for the various identity providers may display Auth0's name, logo, and information to your users. When you register your own application, you have the opportunity to use your own logo and other application information instead.\n\n![Consent screen](https://images.ctfassets.net/cdy7uua7fh8z/5YcLIDCt3RaAkmK1cTeCJL/e85e16195e84aa52f7675faacd126853/consent-screen.png)\n\n## Limitations of developer keys when using Universal Login\n\nIf you are using the [Classic Login experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience) - and in some circumstances, the [Universal Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/new-experience) - the follow limitations also apply:\n\n1.  You cannot use developer keys with [custom domains](https://auth0.com/docs/customize/custom-domains).\n    \n2.  [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on) will not function properly when using the Auth0 developer keys. The reason for this is that the Auth0 developer applications with all the relevant Identity Providers are configured to call back to the URL `https://login.auth0.com/login/callback` instead of the **callback URL** for your own tenant, for example `https://{yourDomain}/login/callback`. This results in the SSO cookie not being set on your own tenant domain, so the next time a user authenticates, no SSO cookie will be detected, even if you configured your application to **Use Auth0 instead of the Identity Provider to do Single Sign-on** (legacy tenants only).\n    \n3.  [Redirecting users from Rules](https://auth0.com/docs/customize/rules/redirect-users) will not function properly. This is because redirect rules are resumed on the endpoint `https://{yourDomain}/continue`. When using Auth0's developer keys, the session is established on a special endpoint that is generic and tenant agnostic, and calling `/continue` will not find your previous session, resulting in an error.\n    \n4.  [Federated Logout](https://auth0.com/docs/authenticate/login/logout) does not work. When using the Auth0 developer keys, calling `/v2/logout?federated` will sign the user out of Auth0, but not out of the Social Identity Provider.\n    \n5.  `prompt=none` won't work on the [/authorize](https://auth0.com/docs/api/authentication/reference#social) endpoint. [Auth0.js](https://auth0.com/docs/libraries/auth0js)' checkSession() method uses `prompt=none` internally, so that won't work either.\n    \n6.  If Auth0 is acting as a SAML Identity Provider, and you use a social connection with the Auth0 developer keys, the generated SAML response will have some errors, like a missing `InResponseTo` attribute or an empty `AudienceRestriction` element.\n    \n7.  [Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication) will not function properly. When MFA authentication is successful, a post will generate in `https://{yourDomain}/mf`. When using Auth0's developer keys, the session is established on a special endpoint that is generic and tenant agnostic, and calling `/mf` will not find your previous session, resulting in an error",
  "title": "Test Social Connections with Auth0 Developer Keys",
  "description": "Explore what you need to be aware of when using Auth0 Developer Keys with social identity providers.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/identity-providers-social",
  "markdown": "# Social Identity Providers\n\nAuth0 supports multiple social identity providers for web applications out of the box, so you can gather up-to-date user information without creating friction or compromising the user experience. To explore the full list of Auth0-supported and partner-supported social identity providers, visit [Auth0 Marketplace: Social Connections](https://marketplace.auth0.com/features/social-connections).\n\nIf you don't see what you're looking for, you can also [create a connection to any OAuth2 Authorization Server](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/oauth2).\n\nFinally, Auth0 supports the following social providers specifically for native applications:\n\n*   [Sign In with Apple](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/apple-native)\n    \n*   [Facebook Login](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/facebook-native)",
  "title": "Social Identity Providers",
  "description": "Learn about the social identity providers supported by Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/java-spring-security5/02-using",
  "markdown": "# Auth0 Spring Boot API SDK Quickstarts: Using Your API\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [Spring Boot API](https://auth0.com/docs/quickstart/backend/java-spring-security5)\n*   [Using Your API](https://auth0.com/docs/quickstart/backend/java-spring-security5/02-using)\n\nThis tutorial will show you how to use your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Calling the API From Your Application\n\nYou can call the API from your application by passing an Access Token in the `Authorization` header of your HTTP request as a Bearer token.\n\n*   [cURL](#f59d2052c0b1427cbb89dafcc9d3019e_shell)\n*   [C#](#f59d2052c0b1427cbb89dafcc9d3019e_csharp)\n*   [Go](#f59d2052c0b1427cbb89dafcc9d3019e_go)\n*   [Java](#f59d2052c0b1427cbb89dafcc9d3019e_java)\n*   [Node.JS](#f59d2052c0b1427cbb89dafcc9d3019e_node)\n*   [Obj-C](#f59d2052c0b1427cbb89dafcc9d3019e_objc)\n*   [...](#)\n    *   [PHP](#f59d2052c0b1427cbb89dafcc9d3019e_php)\n    *   [Python](#f59d2052c0b1427cbb89dafcc9d3019e_python)\n    *   [Ruby](#f59d2052c0b1427cbb89dafcc9d3019e_ruby)\n    *   [Swift](#f59d2052c0b1427cbb89dafcc9d3019e_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Obtaining an Access Token\n\nIf you are calling the API from a Single-Page Application or a Mobile/Native application, after the authorization flow is completed, you will get an Access Token. How you get the token and how you make the call to the API will be dependent on the type of application you are developing and the framework you are using. For more information refer to the relevant application Quickstarts which contain detailed instructions:\n\n*   [Single-Page Applications](https://auth0.com/docs/quickstart/spa)\n*   [Mobile / Native Application](https://auth0.com/docs/quickstart/native)\n\nIf you are calling the API from a command-line tool or another service, where there isn't a user entering their credentials, you need to use the [OAuth Client Credentials flow](https://auth0.com/docs/api/authentication#client-credentials). To do that, register a [Machine to Machine Application](https://manage.auth0.com/#/applications), and then subsequently use the **Client ID** and **Client Secret** of this application when making the request below and pass those along in the `client_id` and `client_secret` parameters respectively. Also include the Audience for the API you want to call.\n\n*   [cURL](#812cec98be354b339ac474913b0faae2_shell)\n*   [C#](#812cec98be354b339ac474913b0faae2_csharp)\n*   [Go](#812cec98be354b339ac474913b0faae2_go)\n*   [Java](#812cec98be354b339ac474913b0faae2_java)\n*   [Node.JS](#812cec98be354b339ac474913b0faae2_node)\n*   [Obj-C](#812cec98be354b339ac474913b0faae2_objc)\n*   [...](#)\n    *   [PHP](#812cec98be354b339ac474913b0faae2_php)\n    *   [Python](#812cec98be354b339ac474913b0faae2_python)\n    *   [Ruby](#812cec98be354b339ac474913b0faae2_ruby)\n    *   [Swift](#812cec98be354b339ac474913b0faae2_swift)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data 'client_id={yourClientId}' \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data audience=YOUR_API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: 'YOUR_API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=YOUR_API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=YOUR_API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nFor testing purposes, you can also get an Access Token from the **Test** tab in your [API settings](https://manage.auth0.com/#/apis).\n\n## Test Your API\n\n**1\\. Calling the secure endpoint**\n\nYou can make a request to the `/api/private` endpoint without passing any Access Token:\n\n*   [cURL](#6206f74ff49d439f91a814c0915e0df5_shell)\n*   [C#](#6206f74ff49d439f91a814c0915e0df5_csharp)\n*   [Go](#6206f74ff49d439f91a814c0915e0df5_go)\n*   [Java](#6206f74ff49d439f91a814c0915e0df5_java)\n*   [Node.JS](#6206f74ff49d439f91a814c0915e0df5_node)\n*   [Obj-C](#6206f74ff49d439f91a814c0915e0df5_objc)\n*   [...](#)\n    *   [PHP](#6206f74ff49d439f91a814c0915e0df5_php)\n    *   [Python](#6206f74ff49d439f91a814c0915e0df5_python)\n    *   [Ruby](#6206f74ff49d439f91a814c0915e0df5_ruby)\n    *   [Swift](#6206f74ff49d439f91a814c0915e0df5_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {method: 'GET', url: 'http://localhost:3010/api/private'};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nconn.request(\"GET\", \"/api/private\")\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe API will return a 401 HTTP (Unauthorized) status code:\n\n![Response for unauthorized API request](https://auth0.com/docs/media/articles/server-apis/using/private-unauthorized.png)\n\nOnce again, make the same request but this time pass along the Access Token as a Bearer token in the **Authorization** header of the request:\n\n*   [cURL](#4ef0c904d2e5470ab9ad7a9df8388686_shell)\n*   [C#](#4ef0c904d2e5470ab9ad7a9df8388686_csharp)\n*   [Go](#4ef0c904d2e5470ab9ad7a9df8388686_go)\n*   [Java](#4ef0c904d2e5470ab9ad7a9df8388686_java)\n*   [Node.JS](#4ef0c904d2e5470ab9ad7a9df8388686_node)\n*   [Obj-C](#4ef0c904d2e5470ab9ad7a9df8388686_objc)\n*   [...](#)\n    *   [PHP](#4ef0c904d2e5470ab9ad7a9df8388686_php)\n    *   [Python](#4ef0c904d2e5470ab9ad7a9df8388686_python)\n    *   [Ruby](#4ef0c904d2e5470ab9ad7a9df8388686_ruby)\n    *   [Swift](#4ef0c904d2e5470ab9ad7a9df8388686_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThis time the API will return a successful response:\n\n![Response for authorized API request](https://auth0.com/docs/media/articles/server-apis/using/private.png)\n\n**2\\. Testing the scoped endpoint**\n\nTo test the endpoint that requires a scope, pass the Access Token containing the correct scope as a Bearer token in the Authorization header:\n\n*   [cURL](#ad464c7dcf524407919e8fe5cd4eb4c2_shell)\n*   [C#](#ad464c7dcf524407919e8fe5cd4eb4c2_csharp)\n*   [Go](#ad464c7dcf524407919e8fe5cd4eb4c2_go)\n*   [Java](#ad464c7dcf524407919e8fe5cd4eb4c2_java)\n*   [Node.JS](#ad464c7dcf524407919e8fe5cd4eb4c2_node)\n*   [Obj-C](#ad464c7dcf524407919e8fe5cd4eb4c2_objc)\n*   [...](#)\n    *   [PHP](#ad464c7dcf524407919e8fe5cd4eb4c2_php)\n    *   [Python](#ad464c7dcf524407919e8fe5cd4eb4c2_python)\n    *   [Ruby](#ad464c7dcf524407919e8fe5cd4eb4c2_ruby)\n    *   [Swift](#ad464c7dcf524407919e8fe5cd4eb4c2_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private-scoped \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private-scoped\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private-scoped\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private-scoped\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private-scoped',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private-scoped\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private-scoped\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private-scoped\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private-scoped\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private-scoped\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the required scope is present, the API call is successful:\n\n![Response for scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped.png)\n\nIf the required scope is not present, the API returns a 403 HTTP Status (Forbidden):\n\n![Response for forbidden scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped-forbidden.png)",
  "title": "Auth0 Spring Boot API SDK Quickstarts: Using Your API",
  "description": "This tutorial will show you how to use your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes",
  "markdown": "# Configure Default Login Routes\n\nIn certain cases (described below), Auth0 may need to redirect back to the application's Login Initiation endpoint, using OIDC third-party initiated login. To learn more, read [Initiating Login from a Third Party](https://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin) at the [OpenID Foundation](https://openid.net/).\n\nYou can configure these URIs with the Dashboard in [Application Settings](https://manage.auth0.com/#/applications/settings) or [Tenant Advanced Settings](https://manage.auth0.com/#/tenant/advanced) or with the Management API.\n\n*   [cURL](#0670cd400b5541eab60c976994e504f0_shell)\n*   [C#](#0670cd400b5541eab60c976994e504f0_csharp)\n*   [Go](#0670cd400b5541eab60c976994e504f0_go)\n*   [Java](#0670cd400b5541eab60c976994e504f0_java)\n*   [Node.JS](#0670cd400b5541eab60c976994e504f0_node)\n*   [Obj-C](#0670cd400b5541eab60c976994e504f0_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/clients/{yourClientId}' \\\n  --header 'authorization: Bearer API2_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{\"initiate_login_uri\": \"<login_url>\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/clients/{yourClientId}\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer API2_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{\\\"initiate_login_uri\\\": \\\"<login_url>\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/clients/{yourClientId}\"\n\n\tpayload := strings.NewReader(\"{\\\"initiate_login_uri\\\": \\\"<login_url>\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer API2_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/clients/{yourClientId}\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer API2_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{\\\"initiate_login_uri\\\": \\\"<login_url>\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/clients/{yourClientId}',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer API2_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {initiate_login_uri: '<login_url>'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer API2_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"initiate_login_uri\": @\"<login_url>\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/clients/{yourClientId}\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/clients/{yourClientId}\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"initiate_login_uri\\\": \\\"<login_url>\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer API2_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"initiate_login_uri\\\": \\\"<login_url>\\\"}\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer API2_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/clients/{yourClientId}\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/clients/{yourClientId}\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer API2_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{\\\"initiate_login_uri\\\": \\\"<login_url>\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer API2_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"initiate_login_uri\": \"<login_url>\"] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/clients/{yourClientId}\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n* * *\n\nThe `login_url` should point to a route in the application that ends up redirecting to Auth0's `/authorize` endpoint, e.g. `https://mycompany.org/login`. Note that it requires `https` and it cannot point to `localhost`. `login_url` can include query parameters and a URI fragment.\n\nAs per the OIDC Third Party Initiated Login specification, the `iss` parameter containing Issuer Identifier will be added as a query string parameter to `login_url` before redirecting.\n\n## Redirect default login route scenarios\n\n### Users bookmark login page\n\nWhen an application initiates the login process, it navigates to `https://{yourDomain}/authorize` with a set of [required parameters](https://auth0.com/docs/api/authentication#login). Auth0 then redirects end-users to an `https://{yourDomain}/login` page, with a URL that looks like:\n\n`https://{yourDomain}/login?state=g6Fo2SBjNTRyanlVa3ZqeHN4d1htTnh&...`\n\nThe `state` parameter points to a record in an internal database where we track the status of the authorization transaction. Whenever the transaction completes, or after a set time passes, the record is deleted from the internal database.\n\nIf you are using Organizations and the end-user bookmarks the organization login prompt, Auth0 also includes the `organization` parameter when it redirects the user to the default login route.\n\nSometimes users bookmark the login page, and when they navigate to the bookmarked `/login` URL, the transaction record is no longer there and Auth0 cannot continue with the login flow. In that case, Auth0 will redirect to the default client URL if configured, or the tenant level URL if not. If no default login URL is set, Auth0 will render an error page.\n\n### Complete password reset flow\n\nAfter completing the password reset flow and the default URI for the application or tenant is configured, users will see a button that will let them navigate back to the login page.\n\nThis behavior only happens when you enable the Universal Login experience. With Classic Login, you need to configure the redirect URL in the Change Password template. To learn more, read [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\nFor tenants using Universal Login, the [`/post-password-change`](https://auth0.com/docs/api/management/v2/#!/Tickets/post_password_change) endpoint supports redirecting users back to a specific application. When `client_id` is specified and the application's login URI is set, users will see a button sending them back to the application after completing a password reset.\n\n*   [cURL](#5937f03c89064ad5b2a5a0a03c04737e_shell)\n*   [C#](#5937f03c89064ad5b2a5a0a03c04737e_csharp)\n*   [Go](#5937f03c89064ad5b2a5a0a03c04737e_go)\n*   [Java](#5937f03c89064ad5b2a5a0a03c04737e_java)\n*   [Node.JS](#5937f03c89064ad5b2a5a0a03c04737e_node)\n*   [Obj-C](#5937f03c89064ad5b2a5a0a03c04737e_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/tickets/password-change' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"user_id\": \"A_USER_ID\", \"client_id\": \"A_CLIENT_ID\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/tickets/password-change\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"application/json\", \"{ \\\"user_id\\\": \\\"A_USER_ID\\\", \\\"client_id\\\": \\\"A_CLIENT_ID\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/tickets/password-change\"\n\n\tpayload := strings.NewReader(\"{ \\\"user_id\\\": \\\"A_USER_ID\\\", \\\"client_id\\\": \\\"A_CLIENT_ID\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/tickets/password-change\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ \\\"user_id\\\": \\\"A_USER_ID\\\", \\\"client_id\\\": \\\"A_CLIENT_ID\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/tickets/password-change',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN'\n  },\n  data: {user_id: 'A_USER_ID', client_id: 'A_CLIENT_ID'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\nNSDictionary *parameters = @{ @\"user_id\": @\"A_USER_ID\",\n                              @\"client_id\": @\"A_CLIENT_ID\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/tickets/password-change\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/tickets/password-change\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"user_id\\\": \\\"A_USER_ID\\\", \\\"client_id\\\": \\\"A_CLIENT_ID\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"user_id\\\": \\\"A_USER_ID\\\", \\\"client_id\\\": \\\"A_CLIENT_ID\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/tickets/password-change\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/tickets/password-change\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ \\\"user_id\\\": \\\"A_USER_ID\\\", \\\"client_id\\\": \\\"A_CLIENT_ID\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"\n]\nlet parameters = [\n  \"user_id\": \"A_USER_ID\",\n  \"client_id\": \"A_CLIENT_ID\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/tickets/password-change\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Complete email verification flow\n\nAs part of the signup process, users get an email to verify their email address. If they click on the link, they will land on a page that says that the email was verified, with a button to go back to the application. When clicked, users will be redirected to the login page, and if they already have a valid session, they'll end up being redirected to the application.\n\nThis behavior only happens when the Universal Login experience is enabled. With Classic Login, you need to configure the redirect URL in the Verification Email template.\n\n### Invite organization members\n\nWhen users are invited to join an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview), they receive an invitation link by email. If they select the link, they are redirected to the configured default login route with invitation-specific parameters appended.\n\nFor example, if you have an organization-enabled application with an **Application Login URI** set to `https://myapp.com/login`, then the link sent in the email invitation that an end-user receives will be: `https://myapp.com/login?invitation={invitation_ticket_id}&organization={organization_id}&organization_name={organization_name}`.\n\nThus, the route in your application must accept `invitation` and `organization` parameters through the query string. To start the invitation acceptance transaction, it should forward both parameters along with the end-user to your Auth0 `/authorize` endpoint.\n\n### Disabled cookies\n\nIf a user navigates to `https://{yourDomain}/authorize` with cookies disabled in their browser, Auth0 redirects the user to the application login URI. If the application login URI is not set, the redirect is sent to the tenant login URI instead.\n\nSending the user back to the login page can potentially cause a redirect loop. To avoid this issue, use a landing page to check the availability of cookies; if disabled, warn the user to enable them if they wish to continue.\n\n## Learn more\n\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Check Error Messages](https://auth0.com/docs/troubleshoot/basic-issues/check-error-messages)\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)",
  "title": "Configure Default Login Routes",
  "description": "Learn how to configure your tenant's and application's default login routes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/architecture-scenarios/application/spa-api",
  "markdown": "# Single-Page Applications (SPA) with API\n\nIn this scenario, we will build a timesheet API for a fictitious company named ExampleCo. The API will allow adding timesheet entries for an employee or a contractor.\n\nWe will also be building a single-page application (SPA) which will be used to log timesheet entries and send them to the centralized timesheet database using the API.\n\n### TL;DR\n\n*   Auth0 provides API Authentication and Authorization as a means to secure access to API endpoints (see [API Authentication and Authorization](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-1#api-authentication-and-authorization))\n*   For authorizing a user of a SPA, Auth0 supports the Implicit Grant (see [Implicit Grant](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-1#implicit-grant))\n*   Both the SPA and the API must be configured in the Auth0 Dashboard (see [Auth0 Configuration](https://auth0.com/docs/architecture-scenarios/spa-api/part-2#auth0-configuration))\n*   User Permissions can be enforced using the Authorization Extension (see [Configure the Authorization Extension](https://auth0.com/docs/architecture-scenarios/spa-api/part-2#configure-the-authorization-extension))\n*   The API will be secured by ensuring that a valid Access Token is passed in the HTTP Authorization header when calls are made to the API (see [Implement the API](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-3#implement-the-api))\n*   The Auth0.js library can be used to authorize the user of the SPA and obtain a valid Access Token which can be used to call the API (see [Authorize the User](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-3#authorize-the-user))\n*   The SPA can pass the Access Token in the HTTP Authorization header when making calls to the API (see [Call the API](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-3#call-the-api))\n*   The SPA can display UI elements conditionally based on scopes granted to user (see [Display UI Elements Conditionally Based on Scope](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-3#display-ui-elements-conditionally-based-on-scope))\n\n## The Premise\n\nExampleCo is a consulting startup company. Currently, they have approximately 100 employees and they also outsource several activities to external contractors. All employees and external contractors are required to fill in their timesheets every week.\n\nThe company has built a timesheets application, a scenario we covered in [Single Sign-On for Regular Web Apps](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps). The internal employees use this web app to fill in their timesheets but the company wants to replace it with a SPA. The app will be used to log timesheet entries and send the data to the centralized timesheet database using the API. The app will also allow managers to approve timesheet entries.\n\n## Goals & Requirements\n\nExampleCo wants to build a flexible solution. At the moment only a SPA is required to capture timesheet entries but in the future, the company plans on launching more applications, like a mobile app to accommodate their sales teams. Hence the company has decided to develop a single Timesheets API which will be used to log time not only by this server process but by all future applications as well. They want to put in place a security architecture that is flexible enough to accommodate this. ExampleCo wants to ensure that a large part of the code and business logic for the application can be shared across the different applications.\n\nIt is required that only authorized users and applications are allowed access to the Timesheets API.\n\nTwo kinds of users will use this SPA: employees and managers. The employees should be able to read, create and delete their own timesheet entries, while the managers should be able to approve timesheets as well.\n\n## Learn more\n\n*   [Solution Overview (SPAs + API)](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-1)\n*   [Auth0 Configuration (SPAs + API)](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-2)\n*   [API and SPA Configuration (SPAs + API)](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-3)\n*   [Node.js API Implementation (SPAs + API)](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/api-implementation-nodejs)\n*   [SPA Angular 2 Implementation (SPAs + API)](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/spa-implementation-angular2)\n*   [Conclusion (SPAs + API)](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-4)",
  "title": "Single-Page Applications (SPA) with API",
  "description": "Explains the architecture scenario where a single-page application (SPA) talks to an API using OpenID Connect (OIDC), and the OAuth 2.0 Implicit Grant Flow, to authenticate users with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/nativesocial/facebook",
  "markdown": "# Add Facebook Login to Native Apps\n\nYou can add functionality to your native application to allow your users to authenticate using Facebook natively, within the application. This does not require redirection via a web browser and will let mobile applications comply with the [Facebook Developer Policy](https://developers.facebook.com/policy/), which requires that mobile applications use the Facebook SDK for [Android](https://developers.facebook.com/docs/android) or [iOS](https://developers.facebook.com/docs/ios) to authenticate.\n\n## How it works\n\nThe Native Facebook login flow works as follows:\n\n*   **Step 1**: The application authenticates a user via the Facebook SDK and acquires an Access Token.\n    \n*   **Step 2**: The application uses that Access Token to request a special [Facebook Session Info Access Token](https://developers.facebook.com/docs/facebook-login/access-tokens/session-info-access-token).\n    \n*   **Step 3**: Use the Facebook SDK to retrieve the users's profile.\n    \n*   **Step 4**: The application can then use the Facebook Session Info token to authenticate with Auth0.\n    \n\n## Prerequisites\n\nBefore you configure Native Facebook login for your native app via Auth0, you must:\n\n1.  [Set up Facebook as an Auth0 connection](https://marketplace.auth0.com/integrations/facebook-social-connection)\n    \n2.  [Use the relevant Facebook SDK in your application](https://developers.facebook.com/docs/apis-and-sdks/)\n    \n3.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and create an application with Auth0 (if you have not already).\n    \n4.  At the bottom of the settings page, select **Show Advanced Settings** and then the **Device Settings** view. Under **Native Social Login**, enable the **Enable Sign In with Facebook** toggle.\n    \n    ![Native Social Login Settings](https://images.ctfassets.net/cdy7uua7fh8z/5p2RaaeAtZyJzcoCfkF4tW/19b4592f966f983229e3d9ece67d0089/dashboard-applications-edit_view-settings-advanced_device-settings_facebook-enabled.png)\n\n## Implementation\n\nThe process to authenticate a user profile using Native Facebook login is a four-step one, from your application's perspective:\n\n### Step 1\n\nThe application authenticates a user via the Facebook SDK. It will obtain an Access Token from Facebook.\n\n## Step 2\n\nThe application uses the Access Token to request a [Facebook Session Info Access Token](https://developers.facebook.com/docs/facebook-login/access-tokens/session-info-access-token).\n\nThis request will look similar to the following:\n\n```\nGET https://graph.facebook.com/v5.0/oauth/access_token?grant_type=fb_attenuate_token&client_id=457704041391802&fb_exchange_token=<facebook_access_token>\n```\n\nand the response:\n\n```\n{\n    \"access_token\": \"XAAGgR4b...1lHWNCpqrAhcpoAZDZD\",\n    \"token_type\": \"bearer\",\n    \"expires_in\": 5183924\n}\n```\n\n### Step 3\n\nThe application needs to retrieve the user profile from Facebook using the Facebook SDK, which will end in a request similar to the following:\n\n```\nGET https://graph.facebook.com/v5.0/<facebook user id>?access_token=<facebook access token>&fields=email,name\n```\n\n### Step 4\n\nThe application can then use the session info Access Token and the Facebook user profile to authenticate with Auth0 by calling Auth0's `/oauth/token` endpoint using the Token Exchange flow with the `facebook-session-access-token` token type. If all goes well, Auth0 will return a normal response from the exchange, with the addition of the user profile. The user profile should be a JSON object, encoded as a string.\n\nto configure this snippet with your account\n\n```\nPOST https://{yourDomain}/oauth/token\n\ngrant_type: 'urn:ietf:params:oauth:grant-type:token-exchange'\nsubject_token_type: 'http://auth0.com/oauth/token-type/facebook-info-session-access-token'\naudience: 'your-api'\nscope: 'read:appointments openid profile email email_verified'\nsubject_token: 'XAAGgR4b...1lHWNCpqrUHZAEtUuZAhcpoAZDZD'\nclient_id: '{yourClientId}'\nuser_profile: '{\"email\":\"john@example.com\", \"name\":\"John Doe\"}'\n```\n\nand the response from Auth0:\n\n```\n{\n    \"access_token\": \"eyJ0eXA..yXQaPLVXg\",\n    \"id_token\": \"eyJ0.tFE5HPipdOsA\",\n    \"scope\": \"openid profile email read:appointments\",\n    \"expires_in\": 86400,\n    \"token_type\": \"Bearer\"\n}\n```\n\n## User Profile and Email Validation\n\nIn the previous example, you had to retrieve the User Profile from Facebook and include it in the call to `/oauth/token`. This is because the Facebook Session Access Token cannot be used to directly retrieve the profile, and the Facebook Access Token cannot be sent directly to the server, due to [Apple's AppStore Review Guidelines](https://developer.apple.com/app-store/review/guidelines). Therefore, it must be retrieved in the client and sent to Auth0 in this fashion.\n\nGiven that Auth0 can't guarantee that the user profile is the same that was returned by Facebook, it will set the `email_verified` field to `false`.\n\n## Logout\n\nSince the native login implementation does not make use of standard browser-based flows, application owners must also take care to perform logout appropriately. When an application needs to perform a logout, it should also [Revoke the Auth0 Refresh Token](https://auth0.com/docs/api/authentication#revoke-refresh-token).\n\n## Keep reading\n\n*   [Native Facebook Login with iOS Swift](https://auth0.com/docs/quickstart/native/ios-swift-facebook-login)\n    \n*   [Native Facebook Login with Android](https://auth0.com/docs/quickstart/native/android-facebook-login)\n    \n*   [Rate Limits on Native Social Logins](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy)",
  "title": "Add Facebook Login to Native Apps",
  "description": "Learn how to add login functionality to your native app with Facebook. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-android",
  "markdown": "# Auth0.Android\n\nAuth0.Android is a client-side library you can use with your Android app to authenticate users and access [Auth0 APIs](https://auth0.com/docs/api).\n\nCheck out the [Auth0.Android repository](https://github.com/auth0/Auth0.Android) on GitHub.\n\n## Requirements\n\nAndroid API version 21 or newer is required.\n\n## Installation\n\nAdd the [](https://github.com/auth0/Auth0.Android)SDK into your project. The library will make requests to Auth0's Authentication and Management APIs.\n\n### Add Auth0 to Gradle\n\nIn your app's `build.gradle` dependencies section, add the following:\n\n```\ndependencies {\n  // Add the Auth0 Android SDK\n  implementation 'com.auth0.android:auth0:2.+'\n}\n```\n\nIf Android Studio lints the `+` sign, or if you want to use a fixed version, check for the latest in [Maven](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22auth0%22%20g%3A%22com.auth0.android%22) or [JCenter](https://bintray.com/auth0/android/auth0).\n\n#### Sync project with Gradle\n\nRemember to synchronize using the Android Studio prompt or run `./gradlew clean build` from the command line. For more information about Gradle usage, check [their official documentation](http://tools.android.com/tech-docs/new-build-system/user-guide).\n\nIn the `android` section, target Java 8 byte code for Android and Kotlin plugins respectively.\n\n```\nandroid {\n  compileOptions {\n    sourceCompatibility JavaVersion.VERSION_1_8\n    targetCompatibility JavaVersion.VERSION_1_8\n  }\n  kotlinOptions {\n    jvmTarget = '1.8'\n  }\n}\n```\n\n### Permissions\n\nOpen your application's `AndroidManifest.xml` file and add the following permission.\n\n```\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n## Configure for Universal Login\n\nFirst, go to [Dashboard > Applications](https://manage.auth0.com/#/applications) and click the name of the application you want to edit. In **Allowed Callback URLs**, make sure your URL follows this format: `https://YOUR_DOMAIN/android/{YOUR_APP_PACKAGE_NAME}/callback`\n\nNext, replace `{YOUR_APP_PACKAGE_NAME}` with your actual application's package name. You can find this in your `app/build.gradle` file as the `applicationId` value.\n\nThen, in your `app/build.gradle` file, add the [Manifest Placeholders](https://developer.android.com/studio/build/manifest-build-variables.html) for the Auth0 Domain and the Auth0 Scheme properties, which the library will use to register an intent-filter that captures the callback URI.\n\n```\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 30\n    defaultConfig {\n        applicationId \"com.auth0.samples\"\n        minSdkVersion 21\n        targetSdkVersion 30\n        //...\n\n        //---> Add the next line\n        manifestPlaceholders = [auth0Domain: \"@string/com_auth0_domain\", auth0Scheme: \"https\"]\n        //<---\n    }\n    //...\n}\n```\n\n## Initialize Auth0\n\nCreate a new `Auth0` object using your Auth0 client ID and domain value. Objects will later use this when interacting with Auth0's endpoints.\n\n```\nval auth0 = Auth0(\"YOUR_CLIENT_ID\", \"YOUR_DOMAIN\")\n```\n\nYou can also initialize this object using an Android Context, as shown in [this usage example](https://github.com/auth0/Auth0.Android/tree/master#usage).\n\n## Next steps\n\n[Log users in and out of your application](https://auth0.com/docs/libraries/auth0-android/auth0-android-login-logout-and-user-profiles) using the `WebAuthProvider` class.\n\n### Reset user password\n\nTo initiate a password reset for a user, call `resetPassword` with the user's email address and the database connection name as parameters.\n\nPassword reset requests will fail on network-related errors, but will not fail if the designated email does not exist in the database (for security reasons).\n\n## Learn more\n\n*   [Auth0.Android Login, Logout, and User Profiles](https://auth0.com/docs/libraries/auth0-android/auth0-android-login-logout-and-user-profiles)\n*   [Auth0.Android Configuration Options](https://auth0.com/docs/libraries/auth0-android/auth0-android-configuration)\n*   [Auth0.Android Database Authentication](https://auth0.com/docs/libraries/auth0-android/auth0-android-database-authentication)\n*   [Auth0.Android Passwordless Authentication](https://auth0.com/docs/libraries/auth0-android/auth0-android-passwordless)\n*   [Auth0.Android Save and Renew Tokens](https://auth0.com/docs/libraries/auth0-android/auth0-android-save-and-renew-tokens)\n*   [Auth0.Android: User Management](https://auth0.com/docs/libraries/auth0-android/auth0-android-user-management)",
  "title": "Auth0.Android",
  "description": "Learn how to install, initialize, and use Auth0.Android",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/users/user-profile-structure",
  "markdown": "# User Profile Structure\n\nAuth0's normalized user profile consists of a few different components:\n\n*   **Details**: Core User Profile object, which contains basic info, such as name, email, and timestamp of the user's latest login, in pre-defined attributes. This object may also contain info from a user's source connection. Most of the user attributes are root attributes (attributes stored at the first, or root, level of the `user` object), and some of these are editable.\n    \n*   **Metadata**: Two sub-objects that operate as secondary storage to store additional user info in customizable attributes: `user_metadata` and `app_metadata`. To learn more, including when to use `app_metadata` and `user_metadata`, read [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata).\n    \n\n## User profile attributes\n\nThe following attributes are available on the user profile. Many are root attributes (attributes stored at the first, or root, level of the `user` object), and some may be updated, imported, and exported, as noted below.\n\nIf there are user fields that should not be stored by Auth0 due to privacy reasons, you can add the attributes you do not want persisting in Auth0 databases to the DenyList. To learn more, read [Add User Attributes to the DenyList](https://auth0.com/docs/secure/security-guidance/data-security/denylist).\n\nBy default, user profile attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable because they are updated from the identity provider each time the user logs in.\n\nTo be able to edit the `name`, `nickname`, `given_name`, `family_name`, or `picture` root attributes on the normalized user profile, you must [configure your connection sync with Auth0](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0) so that user attributes will be updated from the identity provider only on user profile creation. These root attributes will then be available to be edited individually or by bulk imports\n\n| Name | Type | Description | [Search?](https://auth0.com/docs/users/search) | [Update?](https://auth0.com/docs/api/management/guides/users/update-root-attributes-users) | [Import?](https://auth0.com/docs/users/guides/bulk-user-imports) | [Upsert during import?](https://auth0.com/docs/users/guides/bulk-user-imports#request-bulk-import) | [Export?](https://auth0.com/docs/users/guides/bulk-user-exports) |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| `app_metadata` | object | Custom fields that store info about a user that influences the user's access, such as support plan, security roles (if not using the Authorization Core feature set), or access control groups. To learn more, read [Metadata Overview](https://auth0.com/docs/users/concepts/overview-user-metadata). | Y   | Y   | Y   | Y   | Y   |\n| `blocked` | boolean | Indicates whether the user has been blocked. Importing enables subscribers to ensure that users remain blocked when migrating to Auth0. | Y   | Y   | Y   | N   | Y   |\n| `blocked_for` | array (object) | IP addresses that have been blocked under suspicion of a bruteforce attack. | N   | N   | N   | N   | N   |\n| `created_at` | date time | Timestamp indicating when the user profile was first created. | Y   | N   | N   | N   | Y   |\n| `email` | text | (unique) The user's email address. | Y   | Y   | Y   | N   | Y   |\n| `email_verified` | boolean | Indicates whether the user has verified their email address. | Y   | Y   | Y   | Y   | Y   |\n| `family_name` | text | The user's family name. | Y   | Y   | Y   | Y   | Y   |\n| `given_name` | text | The user's given name. | Y   | Y   | Y   | Y   | Y   |\n| `guardian_authenticators` | array (object) | Detailed information about the guardian backup authorization methods the user has set up, including SMS and Recovery Codes. | N   | N   | N   | N   | N   |\n| `identities` | array (object) | Contains info retrieved from the identity provider with which the user originally authenticates. Users may also [link their profile to multiple identity providers](https://auth0.com/docs/users/concepts/overview-user-account-linking); those identities will then also appear in this array. The contents of an individual identity provider object varies by provider, but it will typically include the following:<br><br>*   `connection` (text): Name of the Auth0 connection used to authenticate the user.<br>*   `isSocial` (boolean): Indicates whether the connection is a social one.<br>*   `provider` (text): Name of the entity that is authenticating the user, such as Facebook, Google, SAML, or your own provider.<br>*   `user_id` (text): User's unique identifier for this connection/provider.<br>*   `profileData` (object): User info associated with the connection. When profiles are linked, it is populated with the associated user info for secondary accounts.<br><br>In some cases, it will also include an API Access Token to be used with the provider. | Y   | N   | N   | N   | Y   |\n| `last_ip` | text | IP address associated with the user's last login. | Y   | N   | N   | N   | Y   |\n| `last_login` | date time | Timestamp indicating when the user last logged in. If a user is blocked and logs in, the blocked session updates `last_login`. If you are using this property from inside a [Rule](https://auth0.com/docs/rules) using the `user<` object, its value will be associated with the login that triggered the rule; this is because rules execute after login. | Y   | N   | N   | N   | Y   |\n| `last_password_reset` | date time | Timestamp indicating the last time the user's password was reset/changed. At user creation, this field does not exist. This property is only available for Database connections. | N   | N   | N   | N   | N   |\n| `logins_count` | integer | Number of times the user has logged in. If a user is blocked and logs in, the blocked session is counted in `logins_count`. | Y   | N   | N   | N   | Y   |\n| `multifactor` | array (string) | List of multi-factor providers with which the user is enrolled. | N   | N   | N   | N   | Y   |\n| `multifactor_last_modified` | date time | Date and time of the last update to a user's multifactor authentication. | N   | N   | N   | N   | Y   |\n| `name` | text | The user's full name. | Y   | Y   | Y   | Y   | Y   |\n| `nickname` | text | The user's nickname. | Y   | Y   | Y   | Y   | Y   |\n| `phone_number` | text | The user's phone number. Only valid for users with SMS connections. | Y   | Y   | N   | N   | Y   |\n| `phone_verified` | boolean | Indicates whether the user has been verified their phone number. Only valid for users with SMS connections. | Y   | Y   | N   | N   | Y   |\n| `picture` | text | URL pointing to [the user's profile picture](https://auth0.com/docs/users/guides/change-user-pictures). | N   | Y   | Y   | Y   | Y   |\n| `tenant` | text | Name of the tenant being used. | N   | N   | N   | N   | N   |\n| `updated_at` | date time | Timestamp indicating when the user's profile was last updated/modified. Changes to `last_login` are considered updates, so most of the time, `updated_at` will match `last_login`. | Y   | N   | N   | N   | Y   |\n| `user_id` | text | (unique) The user's identifier. Importing allows user records to be synchronized across multiple systems without using mapping tables. | Y   | N   | Y   | N   | Y   |\n| `user_metadata` | object | Custom fields that store info about a user that does not impact what they can or cannot access, such as work address, home address, or user preferences. To learn more, read [Metadata Overview](https://auth0.com/docs/users/concepts/overview-user-metadata). | Y   | Y   | Y   | Y   | Y   |\n| `username` | text | (unique) The user's username. | Y   | Y   | Y   | N   | Y   |\n\nThree other fields are not technically part of the user profile, but may be of interest when importing users:\n\n*   `password_hash` (text): Hashed password for the user's connection. When users are created, Auth0 uses [bcrypt](https://auth0.com/blog/hashing-in-action-understanding-bcrypt/) to secure the password. Importing compatible hashed passwords allows users to retain their passwords, thereby providing a smoother experience. Compatible passwords should be hashed using bcrypt $2a$ or $2b$ and have 10 saltRounds. Note that you can provide this field only when the user is first imported; you cannot update it later.\n    \n*   `custom_password_hash` (object): Hashed password for the user's connection when created using an alternate algorithm. Used in place of the `password_hash` field. During the bulk import process, you can update the `custom_password_hash` if the user did not login using the initially imported `custom_password_hash.`\n    \n\n## Learn more\n\n*   [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports)\n*   [Bulk User Import Database Schema and Examples](https://auth0.com/docs/manage-users/user-migration/bulk-user-import-database-schema-and-examples)\n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles)",
  "title": "User Profile Structure",
  "description": "Lists the attributes that are available on the Auth0 user profile",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/dashboard/guides/applications/register-app-native",
  "markdown": "# Register Native Applications\n\nTo integrate Auth0 with a native application, you must first register your app with Auth0 using the Auth0 Dashboard. These apps may include mobile, desktop, or hybrid apps running natively in a device (for example, i0S, Android).\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click **Create Application**.\n    \n2.  Enter a descriptive name for your application, select **Native**, and click **Create**.\n    \n    ![Auth0 Create Application](https://images.ctfassets.net/cdy7uua7fh8z/128mqeFl3vNb1lcyU38pnc/3e9ca9cc08aae6b9ff504b537a350cfb/Screen_Shot_2021-06-03_at_4.15.16_PM.png)\n    \n    Once the new application is created, you will be directed to **Application** **Settings** which includes the following tabs:\n    \n    | **Settings Tab** | **Description** |\n    | --- | --- |\n    | **Quick Start** | Shows all the available documentation for your application type. |\n    | **Settings** | Shows all available settings for your application. By default, most of the settings will be created for you. To learn more, read [Application Settings](https://auth0.com/docs/get-started/dashboard/application-settings). |\n    | **Credentials** | Shows the application’s authentication method and configured credentials. To learn more, read [Application Credentials](https://auth0.com/docs/secure/application-credentials) |\n    | **Add-ons** | Allows you to enable plugins associated with an application. These are SAML or WS-Fed web apps for which Auth0 generates access tokens. To learn more, read [Enable SAML2 Web App Addon](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon) and [Configure WS-Fed Applications](https://auth0.com/docs/protocols/configure-ws-fed-applications). |\n    | **Connections** | Allows you to enable connections for your application. Connections are sources of users; they can be enabled and shared between multiple applications. To learn more, read [Connections](https://auth0.com/docs/connections). |\n    | **Organizations** | Allows you to authenticate users into organizations to which they belong. To learn more, read [Organizations](https://auth0.com/docs/organizations). |\n    \n    To learn more, read [Application Settings](https://auth0.com/docs/get-started/applications/application-settings).\n3.  If you're developing a mobile app, provide the necessary iOS/Android parameters in the **Advanced Settings** area, and click **Save Changes**.\n    \n    *   For iOS apps, [provide your **Team ID** and **App Bundle Identifier**](https://auth0.com/docs/get-started/applications/enable-universal-links-support-in-apple-xcode).\n        \n    *   For Android apps, [provide your **App Package Name** and your **Key Hashes**](https://auth0.com/docs/get-started/applications/enable-android-app-links-support).\n        \n\n## Next steps\n\nOnce you have registered and configured your application, some common next steps are:\n\n*   Configure a connection and enable it for your application.\n    \n*   Modify your app code to use your Auth0-registered application. See our [Auth0 Quickstarts](https://auth0.com/docs/quickstarts), where you'll find detailed instructions and samples for a variety of technologies. You'll also learn how to implement login and logout, handle your user sessions, retrieve and display user profile information, and more.\n    \n*   Use [Auth0 APIs](https://auth0.com/docs/api).\n    \n    *   The [Authentication API](https://auth0.com/docs/api/authentication) handles all primary identity-related functions (for example, login, logout, and get user profile). Most users consume this API through our Quickstarts, the [Auth0.js library](https://auth0.com/docs/libraries/auth0js), or the [Lock widget](https://auth0.com/docs/libraries/lock). However, if you are building all of your authentication UI manually, you will have to interact with this API directly.\n        \n    *   The [Management API](https://auth0.com/docs/api/management/v2) allows you to automate various tasks that can also be accessed via the Dashboard in Auth0 (for example: creating users, setting application grant types).\n        \n\n## Learn more\n\n*   [Application Settings](https://auth0.com/docs/get-started/applications/application-settings)\n*   [Add Bot Detection to Native Applications](https://auth0.com/docs/secure/attack-protection/bot-detection/bot-detection-native-apps)",
  "title": "Register Native Applications",
  "description": "Learn how to register and configure a native application using the Auth0 Dashboard. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-android/save-and-refresh-tokens",
  "markdown": "# Lock.Android: Refresh JSON Web Tokens\n\nWhen authentication is performed with the `offline_access` scope included, a Refresh Token is returned with the credentials. This value can be used to request a new Access Token and avoid asking the user their credentials again.\n\nTokens must be stored in a secure storage after a successful authentication. Keep in mind that Refresh Tokens **never expire**. To request a new token, use A`uth0.Android`'s `AuthenticationAPIClient`.\n\n## Using Refresh Token\n\n```\nval refreshToken: String = // Retrieve Refresh Token from secure storage\nval account = Auth0(this)\n\nval client = AuthenticationAPIClient(account)\nclient.renewAuth(refreshToken)\n  .start(object: Callback<Credentials, AuthenticationException> {\n  override fun onFailure(exception: AuthenticationException) {\n       // Error\n   }\n\n   override fun onSuccess(credentials: Credentials) {\n       // Use the credentials\n   }\n})\n```",
  "title": "Lock.Android: Refresh JSON Web Tokens",
  "description": "This page describes how to keep your user logged in with Refresh Tokens",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/flows/concepts/device-auth",
  "markdown": "# Device Authorization Flow\n\nWith input-constrained devices that connect to the internet, rather than authenticate the user directly, the device asks the user to go to a link on their computer or smartphone and authorize the device. This avoids a poor user experience for devices that do not have an easy way to enter text. To do this, device apps use the Device Authorization Flow (ratified in [OAuth 2.0](https://tools.ietf.org/html/rfc8628)), in which they pass along their Client ID to initiate the authorization process and get a token.\n\n## How it works\n\nThe Device Authorization Flow contains two different paths; one occurs on the device requesting authorization and the other occurs in a browser. The browser flow path, wherein a device code is bound to the session in the browser, occurs in parallel to part of the device flow path.\n\n![Flows - Device Authorization - Authorization sequence diagram](https://images.ctfassets.net/cdy7uua7fh8z/1A6jpG3W1H6SC9ZK92NyKd/40af53209f90a7c392f621f329fb4424/auth-sequence-device-auth.png)\n\n### Device Flow\n\n1.  The user starts the app on the device.\n    \n2.  The device app requests authorization from the Auth0 Authorization Server using its Client ID (`/oauth/device/code` endpoint).\n    \n3.  The Auth0 Authorization Server responds with a `device_code`, `user_code`, `verification_uri`, `verification_uri_complete` `expires_in` (lifetime in seconds for `device_code` and `user_code`), and polling `interval`.\n    \n4.  The device app asks the user to activate using their computer or smartphone. The app may accomplish this by:\n    \n    *   asking the user to visit the `verification_uri` and enter the `user_code` after displaying these values on-screen\n        \n    *   asking the user to interact with either a QR Code or shortened URL with embedded user code generated from the `verification_uri_complete`\n        \n    *   directly navigating to the verification page with embedded user code using `verification_uri_complete`, if running natively on a browser-based device\n        \n5.  The device app begins polling your Auth0 Authorization Server for an Access Token (**/oauth/token** endpoint) using the time period specified by `interval` and counting from receipt of the last polling request's response. The device app continues polling until either the user completes the browser flow path or the user code expires.\n    \n6.  When the user successfully completes the browser flow path, your Auth0 Authorization Server responds with an Access Token (and optionally, a Refresh Token). The device app should now forget its `device_code` because it will expire.\n    \n7.  Your device app can use the Access Token to call an API to access information about the user.\n    \n8.  The API responds with requested data.\n    \n\n### Browser Flow\n\n1.  The user visits the `verification_uri` on their computer, enters the `user_code` and confirms that the device that is being activated is displaying the `user_code`. If the user visits the `verification_uri_complete` by any other mechanism (such as by scanning a QR code), only the device confirmation will be needed.\n    \n2.  Your Auth0 Authorization Server redirects the user to the login and consent prompt, if needed.\n    \n3.  The user authenticates using one of the configured login options and may see a consent page asking to authorize the device app.\n    \n4.  Your device app is authorized to access the API.\n    \n\n## How to implement it\n\nThe easiest way to implement the Device Authorization Flow is to follow our tutorial: [Call API Using Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow/call-your-api-using-the-device-authorization-flow).\n\nTo force the user to reauthorize a device, you must revoke the Refresh Token assigned to the device. To learn how, read [Unlink Devices from Users](https://auth0.com/docs/manage-users/user-accounts/unlink-devices-from-users). Note that the device will not be forced to reauthorize until the current Access Token expires and the application tries to use the revoked Refresh Token. To learn more about Refresh Tokens, read [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\n## Learn more\n\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)\n*   [Auth0 Actions](https://auth0.com/docs/customize/actions)",
  "title": "Device Authorization Flow",
  "description": "Learn how the Device Authorization flow works and why you should use it for input-constrained devices, such as smart TVs and media consoles. For use with native apps.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/dashboard/guides/connections/set-up-connections-social",
  "markdown": "loading",
  "title": "",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://auth0.com/docs/dashboard/guides/connections/set-up-connections-database",
  "markdown": "# Set Up Database Connections\n\nYou can set up database connections for applications using the Auth0 Dashboard. The configured database connections can be used to log in to your application. To set up a connection, follow the steps below.\n\n## Learn more\n\n*   [Test Database Connections](https://auth0.com/docs/get-started/applications/test-database-connections)",
  "title": "Set Up Database Connections",
  "description": "Describes how to set up database connections for applications using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/dashboard/guides/applications/update-grant-types",
  "markdown": "# Update Grant Types\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/clients/%7ByourClientId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"grant_types\": \"{grantTypes}\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"grant_types\\\": \\\"{grantTypes}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\"\n\n\tpayload := strings.NewReader(\"{ \\\"grant_types\\\": \\\"{grantTypes}\\\" }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"grant_types\\\": \\\"{grantTypes}\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/clients/%7ByourClientId%7D',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer {yourMgmtApiAccessToken}',\n    'cache-control': 'no-cache'\n  },\n  data: {grant_types: '{grantTypes}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"grant_types\": @\"{grantTypes}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"grant_types\\\": \\\"{grantTypes}\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"grant_types\\\": \\\"{grantTypes}\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/clients/%7ByourClientId%7D\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"grant_types\\\": \\\"{grantTypes}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"grant_types\": \"{grantTypes}\"] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Update Grant Types",
  "description": "Learn how to update an application's grant types using the Auth0 Dashboard or the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/architecture-scenarios/mobile-api/part-2",
  "markdown": "# Auth0 Configuration (Mobile Apps + API)\n\nIn this section we will review all the configurations we need to apply at the [Auth0 Dashboard](https://manage.auth0.com/#).\n\n## Create the API\n\nClick on the [APIs menu option](https://manage.auth0.com/#/apis) on the left, and click the Create API button.\n\nYou will be required to supply the following details for your API:\n\n*   **Name**: a friendly name for the API. Does not affect any functionality.\n    \n*   **Identifier**: a unique identifier for the API. We recommend using a URL but note that this doesn't have to be a publicly available URL, Auth0 will not call your API at all. This value cannot be modified afterwards.\n    \n*   **Signing Algorithm**: the algorithm to sign the tokens with. The available values are `HS256` and `RS256`. When selecting RS256 the token will be signed with the tenant's private key. To learn more about signing algorithms, see [Signing Algorithms](https://auth0.com/docs/get-started/applications/signing-algorithms).\n    \n\n![Dashboard - Applications - APIs - Create API - Popup](https://images.ctfassets.net/cdy7uua7fh8z/4kIH4BQc4vDel2zhJ6lwCE/6812a7ec36119cde0fbe10801e4c0394/dashboard-apis-create_create-popup_default-empty.png)\n\nFill in the required information and click the **Create** button.\n\n#### Signing Algorithms\n\nWhen you create an API you have to select the algorithm your tokens will be signed with. The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way.\n\nTo create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that. That algorithm, which is part of the JWT header, is the one you select for your API: `HS256` or `RS256`.\n\n*   **RS256** is an [asymmetric algorithm](https://en.wikipedia.org/wiki/Public-key_cryptography) which means that there are two keys: one public and one private (secret). Auth0 has the secret key, which is used to generate the signature, and the consumer of the JWT has the public key, which is used to validate the signature.\n    \n*   **HS256** is a [symmetric algorithm](https://en.wikipedia.org/wiki/Symmetric-key_algorithm) which means that there is only one secret key, shared between the two parties. The same key is used both to generate the signature and to validate it. Special care should be taken in order for the key to remain confidential.\n    \n\nThe most secure practice, and our recommendation, is to use **RS256**. Some of the reasons are:\n\n*   With RS256 you are sure that only the holder of the private key (Auth0) can sign tokens, while anyone can check if the token is valid using the public key.\n    \n*   Under HS256, If the private key is compromised you would have to re-deploy the API with the new secret. With RS256 you can request a token that is valid for multiple audiences.\n    \n*   With RS256 you can implement key rotation without having to re-deploy the API with the new secret.\n    \n\n### Configure the Permissions\n\nOnce the application has been created you will need to configure the Permissions which applications can request during authorization.\n\nIn the settings for your API, go to the **Permissions** tab. In this section you can add all four of the scopes which were discussed before, namely `read:timesheets`, `create:timesheets`, `delete:timesheets`, `approve:timesheets`.\n\n![Dashboard - Applications - APIs - Permissions](https://images.ctfassets.net/cdy7uua7fh8z/xxMOKezob6gNHJ0CcKhcg/4a8d4bcffc6a641ae3d0fa1416687390/dashboard-apis-edit_view-permissions.png)\n\n## Create the Application\n\nThere are four application types in Auth0: **Native App** (used by mobile or desktop apps), **Single-Page Web App**, **Regular Web App**, and **Machine to Machine App** (used by CLIs, Daemons, or services running on your backend). For this scenario we want to create a new Application for our mobile application, hence we will use Native as the application type.\n\nTo create a new Application, navigate to the [dashboard](https://manage.auth0.com/#) and click on the [Applications](https://manage.auth0.com/#/applications) menu option on the left. Click the **\\+ Create Application** button.\n\nSet a name for your Application (we will use `Timesheets Mobile`) and select `Native App` as the type.\n\nClick **Create**.\n\n![Dashboard - Applications - Create Application](https://images.ctfassets.net/cdy7uua7fh8z/2xSOsGL6qUAN8DfJ2KnMwp/a5f512f8d7ad3a04d5aa842d8a25718e/dashboard-applications-list.png)\n\nYou will need to ensure that the Authorization Extension is installed for your tenant. You can refer to the [Authorization Extension documentation](https://auth0.com/docs/customize/extensions/authorization-extension) for details on how to do this.\n\n### Define Permissions\n\nYou will need to define Permissions which correlates with the scopes you have already defined. In the Authorization Extension, click the Permissions tab, and then click on the **Create Permission** button. In the dialog, capture the details for each permission. Ensure that the name of the permission is exactly the same as the corresponding scope:\n\n![Dashboard - Extensions - Authorization Extension - Create Permission](https://images.ctfassets.net/cdy7uua7fh8z/7dWoFZlOPP2ZyUN49B50k/0a084b082e07f70e6dfbcc2e4b7167cd/create-permission.png)\n\nProceed to create the permissions for all the remaining scopes:\n\n![Dashboard - Extensions - Authorization Extension - Permissions](https://images.ctfassets.net/cdy7uua7fh8z/6vaEh4vh8gi39UDpYtxvhr/72759ea17f47b21eb94d5e261ea481cd/permissions.png)\n\n### Define Roles\n\nHead over to the Roles tab and create two Roles. Click the **Create Role** button and select the **Timesheets SPA** application. Give the Role a name and description of Employee, and select the `delete:timesheets`, `create:timesheets` and `read:timesheets` permissions. Click on **Save**.\n\n![Dashboard - Extensions - Authorization Extension - Create Employee Role](https://images.ctfassets.net/cdy7uua7fh8z/3DjpNcalart6zQeOSdeQoZ/b8b44cdc7120497142e397ba9dac0a67/create-employee-role.png)\n\nNext, follow the same process to create a **Manager** role, and ensure that you have selected all the permissions:\n\n![Dashboard - Extensions - Authorization Extension - Create Manager Role](https://images.ctfassets.net/cdy7uua7fh8z/3ver0yyJpTLypmcIDzwSNt/d880e8ae74e6e973c7ce1c8b0f7e7c87/create-manager-role.png)\n\n### Assign Users to Roles\n\nYou will need to assign all users to either the Manager or the User role. You can do this by going to the Users tab in the Authorization Extension and selecting a user. On the user information screen, go to the Roles tab. You can add a role to the user by clicking the **Add Role to User** button, and selecting the appropriate role for the user.\n\n![Dashboard - Extensions - Authorization Extension - Add User to Role](https://images.ctfassets.net/cdy7uua7fh8z/46pOmEIjr5ct2KJfd4jb2/d5ebf5a3705fe965f0ce55b12cd2b343/add-user-role.png)\n\n### Configuring the Authorization Extension\n\nYou will also need to ensure that the Rule for the Authorization Extension is published. You can do this by clicking on your user avatar in to top right of the Authorization Extension, and selecting the **Configuration** option:\n\n![Dashboard - Extensions - Authorization Extension - Navigate to Configuration](https://images.ctfassets.net/cdy7uua7fh8z/2OdiLzYMcrlS7Sh84qEmom/8e29123022cf3137cd04162b94b6582d/select-configuration.png)\n\nEnsure that you have enabled **Permissions** and then click the **Publish Rule** button.\n\n### Create a Rule to validate token scopes\n\nThe final step in this process is to create a Rule which will validate that the scopes contained in an Access Token is valid based on the permissions assigned to the user. Any scopes which are not valid for a user should be removed from the Access Token.\n\nIn your Auth0 Dashboard, go to the Rules tab. You should see the Rule created by the Authorization Extension.\n\nClick on the **Create Rule** button and select the **Empty Rule** template. You can give the Rule a name, such as **Access Token Scopes**, and then specify the following code for the Rule:\n\n```\nfunction (user, context, callback) {\n  if (context.clientName !== 'Timesheets SPA') {\n    return callback(null, user, context);\n  }\n\n  var permissions = user.permissions || [];\n  var requestedScopes = context.request.body.scope || context.request.query.scope;\n  var filteredScopes = requestedScopes.split(' ').filter( function(x) {\n    return x.indexOf(':') < 0;\n  });\n  Array.prototype.push.apply(filteredScopes, permissions);\n  context.accessToken.scope = filteredScopes.join(' ');\n\n  callback(null, user, context);\n}\n```\n\nThe code above will ensure that all Access Tokens will only contain the properly-formatted scopes (e.g., `action:area` or `delete:timesheets`) which are valid according to a user's permissions. Once you are done you can click on the **Save** button.\n\nRules execute in the order they are displayed on the Rules page, so ensure that the new rule you created is positioned below the rule for the Authorization Extension, so it executes after the Authorization Extension rule.\n\nPREVIOUS TUTORIAL [1\\. Solution Overview](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/part-1)\n\nNEXT TUTORIAL [3\\. API + Mobile Implementation](https://auth0.com/docs/get-started/architecture-scenarios/mobile-api/api-implementation-nodejs)",
  "title": "Auth0 Configuration (Mobile Apps + API)",
  "description": "Auth0 Configuration for the Mobile + API architecture scenario",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/native/android/01-user-metadata",
  "markdown": "# Auth0 Android SDK Quickstarts: User Metadata\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Native/Mobile App](https://auth0.com/docs/quickstart/native)\n*   [Android](https://auth0.com/docs/quickstart/native/android)\n*   [User Metadata](https://auth0.com/docs/quickstart/native/android/01-user-metadata)\n\nThis quickstart demonstrates how to make API calls to the Auth0 Management API to read and update user metadata. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to integrate with my app\n\n15 minutes\n\n1.  [Read User Metadata](#read-user-metadata)\n2.  [Update User Metadata](#update-user-metadata)\n\nOr\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Android Studio 4.1.0 | Android SDK 30 | Emulator - Android 11.0\n\nAs an example of using the SDK to call APIs that may require custom scopes and audiences, we will demonstrate these settings by reading and updating user profile information.\n\n## Read User Metadata\n\nIn [the previous chapter](https://auth0.com/docs/quickstart/native/android/00-login#show-user-profile-information), you saw how to access [basic user profile information](https://auth0.com/docs/users/user-profiles) using the `/userinfo` endpoint. This profile information may not include everything about a user that you might need. For example, in order to access the user's metadata, you must make an API call to the Management API using the user ID and the access token. With the Android SDK, this is done using the `UsersAPIClient` object.\n\nTo be able to correctly read and update the user metadata, ensure the authorization server allows you to read and edit the current user profile by specifying the `openid profile email read:current_user update:current_user_metadata` scopes. In addition, specify the audience for the [Auth0 Management API](https://auth0.com/docs/api), which happens to include the User Info audience as well.\n\nFind the code in your project that initializes the `WebAuthProvider` class, and make the following changes if necessary:\n\n*   amend the argument given to `withScope` to be `openid profile email offline_access read:current_user update:current_user_metadata`\n*   add a call to `withAudience` and pass the audience for the Auth0 Management API: `https://{yourDomain}/api/v2/` (please note the trailing slash - this is required)\n\n```\nWebAuthProvider.login(account)\n  .withScheme(\"demo\")\n  // modify the scopes to enable read and write of user_metadata\n  .withScope(\"openid profile email read:current_user update:current_user_metadata\")\n  // specify the audience for the Auth0 Management API  \n  .withAudience(\"https://{yourDomain}/api/v2/\")\n  .start(this, /* .. callback .. */)\n```\n\nOnce you have a `UserProfile` instance (retrieved by calling `userInfo` from the previous chapter), get the user's ID and then use the `UsersAPIClient` to get the full profile for the user in another `UserProfile` instance. This profile will include all of the previous user profile information, as well as additional fields such as `user_metadata` and `app_metadata`.\n\nThe metadata can then be retrieved by using the `getUserMetadata` method on the `UserProfile` object.\n\n```\nfun getUserMetadata(userId: String, accessToken: String) {\n  // Get the user ID and call the full getUser Management API endpoint, to retrieve the full profile information\n  // Create the user API client using the account details and the access token from Credentials\n  val usersClient = UsersAPIClient(account, accessToken)\n\n  // Get the full user profile\n  usersClient\n    .getProfile(userId)\n    .start(object: Callback<UserProfile, ManagementException> {\n      override fun onFailure(exception: ManagementException) {\n          // Something went wrong!\n      }\n\n      override fun onSuccess(profile: UserProfile) {\n          // Retrieve the \"country\" field, if one appears in the metadata\n          val country = profile.getUserMetadata()[\"country\"] as String?\n      }\n  })\n}\n```\n\n### Checkpoint\n\nAdd the above code to your application at the point where you already get the basic user profile, and observe that you are able to get the \"country\" field, which may be empty if the user does not have that field in their user metadata. In the next section you will see how to update the user with this metadata using the Management API.\n\n## Update User Metadata\n\nUpdating user metadata is done in a very similar fashion. Call the `updateMetadata` method on the `UsersAPIClient` object to update the metadata for a specific user. You must also supply a map of data that is used to update the user metadata with.\n\n```\nfun patchUserMetadata(userId: String, accessToken: String) {\n  // Create the UsersAPIClient with the account details\n  // and the access token from the Credentials object\n  val usersClient = UsersAPIClient(account, accessToken)\n\n  // Create a map of data to update the user metadata with.\n  // In this case, we're adding/updating a custom \"country\" field\n  val metadata = mapOf(\"country\" to \"United States\")\n\n  // Call updateMetadata with the id of the user to update, and the map of data\n  usersClient.updateMetadata(userId, metadata)\n    .start(object: Callback<UserProfile, ManagementException> {\n      override fun onFailure(exception: ManagementException) {\n          // Something went wrong!\n      }\n\n      override fun onSuccess(profile: UserProfile) {\n          // The metadata was updated and we're given the updated user profile.\n          // Retrieve the \"country\" field, if one appears in the metadata\n          val country = profile.getUserMetadata()[\"country\"] as String?\n      }\n  })\n}\n```\n\n### Checkpoint\n\nAdd the above code to your application at the point where you already get the basic user profile, and observe that the `onSuccess` callback is executed. Then, re-run the code to _read_ the user metadata, and you should see that a value for \"country\" is now returned.\n\nYou can also see the updated metadata in the [Auth0 Dashboard](https://manage.auth0.com/) by [inspecting the user](https://auth0.com/docs/users/manage-users-using-the-dashboard) and looking at the metadata collection in your web browser.",
  "title": "Auth0 Android SDK Quickstarts: User Metadata",
  "description": "This quickstart demonstrates how to make API calls to the Auth0 Management API to read and update user metadata.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/scopes",
  "markdown": "# Scopes\n\nDifferent pieces of user information are often stored across a number of online resources. Users may upload and store photos with a service like Flickr, keep digital files on Dropbox, and store contacts and events in Google Calendar or on Facebook.\n\nOften, new applications will want to make use of the information that has already been created in an online resource. To do so, the application must ask for authorization to access this information on a user's behalf. Scopes define the specific actions applications can be allowed to do on a user's behalf.\n\n## Ways to use scopes\n\nWhen an app requests permission to access a resource through an authorization server, it uses the `scope` parameter to specify what access it needs, and the authorization server uses the `scope` parameter to respond with the access that was actually granted (if the granted access was different from what was requested).\n\nGenerally, you use scopes in three ways:\n\n*   From an application, to verify the identity of a user and get basic profile information about the user, such as their email or picture. In this scenario, the scopes available to you include those implemented by the OpenID Connect (OIDC) protocol. To learn more, read [OpenID Connect Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes).\n    \n*   In an [API](https://auth0.com/docs/api), to implement access control. In this case, you need to define custom scopes for your API and then identify these scopes so that calling applications can use them. To learn more, read [API Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes).\n    \n*   From an application, to call an API that has implemented its own custom scopes. In this case, you need to know which custom scopes are defined for the API you are calling. To see examples of calling a custom API from an application, read [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims)\n    \n\n## Best practices\n\nUnderstand your use case and choose the most restrictive scopes possible.\n\nIf you are requesting scopes, make sure you ask for enough access for your application to function, but only request what you absolutely need. Are you establishing a user's identity or asking the user to allow you to interact with their data? There's a big difference between importing a user's Facebook profile information and posting to their wall. By only requesting what you need, you are more likely to gain user consent when required since users are more likely to grant access for limited, clearly specified scopes.\n\nSimilarly, when creating custom scopes for an API, consider what levels of granular access applications may need and design accordingly.\n\n## Requested scopes versus granted scopes\n\nIn certain cases, users get to consent to the access being requested. While usually, the scopes returned will be identical to those requested, users can edit granted scopes (both during initial consent and sometimes after, depending on the resource), thereby granting an app less access than it requested.\n\nAs an application developer, you should be aware of this possibility and handle these cases in your app. For example, your app could warn the user that they will see reduced functionality. It could also send the user back through the authorization flow to ask for additional permissions. But again, remember that when asked for consent, users can always say no.\n\nBy default, Auth0 skips user consent for first-party applications, which are applications that are registered under the same Auth0 domain as the API they are calling; however, you can configure your API in Auth0 to require user consent from first-party applications. Third-party applications, which are external applications, require user consent.\n\n## Learn more\n\n*   [OpenID Connect Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes)\n*   [API Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes)\n*   [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims)\n*   [Enable Role-Based Access Control for APIs](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis)",
  "title": "Scopes",
  "description": "Understand the principle of scopes and explore general examples of their use.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/dashboard/guides/tenants/configure-device-user-code-settings",
  "markdown": "# Configure Device User Code Settings\n\nYou can configure settings for the user code generated by your application during the [Device Authorization Flow](https://auth0.com/docs/flows/concepts/device-auth) using the Auth0 Dashboard.\n\n1.  Go to [Dashboard > Settings](https://manage.auth0.com/#/tenant) and click the **Advanced** tab.\n    \n2.  Scroll to the **Device Flow User Code Format** section, locate **User Code Character Set** and **User Code Mask**, enter the desired settings, and click **Save**.\n    \n    ![Dashboard Tenant Settings Advanced Device Flow User Code Format User Code Character Set and User Code Mask](https://images.ctfassets.net/cdy7uua7fh8z/3C3otUHCrvagqg7DbZN1Xb/7e8a91123f0674fdfa12bc64de719f01/dashboard-settings-advanced-device-user-codes.png)\n    \n    | Setting | Description |\n    | --- | --- |\n    | **Device Flow User Code Format** | Character set used to when randomly generating a user code. |\n    | **User Code Mask** | Mask used to define length and format of a randomly-generated user code. Its purpose is to increase the user code's readability and ease of input. |\n    \n\n## Learn more\n\n*   [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)\n*   [Mobile Device Login Flow Best Practices](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow/mobile-device-login-flow-best-practices)\n*   [Unlink Devices from Users](https://auth0.com/docs/manage-users/user-accounts/unlink-devices-from-users)",
  "title": "Configure Device User Code Settings",
  "description": "Learn how to configure the user code generated by your applications during the device authorization flow using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims",
  "markdown": "# Create Custom Claims\n\nTo read custom claims on access and ID tokens, you must use JSON Web Tokens (JWT) and pass an audience (`aud`) in an OIDC login flow. To learn more, read [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens).\n\nWhen configuring custom claims on JWTs, you want to avoid collisions. To keep your custom claims from colliding with any reserved claims or claims from other resources, give them a collision-resistant name. Auth0 recommends using a namespaced format.\n\n## General restrictions\n\nAuth0 applies the following restrictions to custom claims:\n\n*   Custom claims payload is set to a maximum of 100KB\n    \n*   OPENID standard claims or claims used internally by Auth0 cannot be customized or modified\n    \n*   Access tokens with an Auth0 API audience, excluding the `/userinfo` endpoint, cannot have private, non-namespaced custom claims \n    \n*   Only specified OIDC user profile claims can be added to access tokens\n    \n\nThe following claims are subject to Auth0's restrictions:\n\n*   `acr`\n*   `act`\n*   `active`\n*   `amr`\n*   `at_hash`\n*   `ath`\n*   `attest`\n*   `aud`\n*   `auth_time`\n*   `authorization_details`\n*   `azp`\n*   `c_hash`\n*   `client_id`\n*   `cnf`\n*   `cty`\n*   `dest`\n*   `entitlements`\n*   `events`\n*   `exp`\n*   `groups`\n*   `gty`\n*   `htm`\n*   `htu`\n*   `iat`\n*   `internalService`\n*   `iss`\n*   `jcard`\n*   `jku`\n*   `jti`\n*   `jwe`\n*   `jwk`\n*   `kid`\n*   `may_act`\n*   `mky`\n*   `nbf`\n*   `nonce`\n*   `object_id`\n*   `org_id`\n*   `org_name`\n*   `orig`\n*   `origid`\n*   `permissions`\n*   `roles`\n*   `rph`\n*   `s_hash`\n*   `sid`\n*   `sip_callid`\n*   `sip_cseq_num`\n*   `sip_date`\n*   `sip_from_tag`\n*   `sip_via_branch`\n*   `sub`\n*   `sub_jwk`\n*   `toe`\n*   `txn`\n*   `typ`\n*   `uuid`\n*   `vot`\n*   `vtm`\n*   `x5t#S256`\n\n### Non-restricted claims\n\nYou can create claims for sensitive user information to enhance the user profile and add to the user experience. These claims are consumed by your application from ID tokens. To learn more about using non-restricted claims, read [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens), and keep in mind [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices) if you use them.\n\nThe following claims are only subject to general restrictions:\n\n*   `address`\n*   `birthdate`\n*   `email`\n*   `email_verified`\n*   `family_name`\n*   `gender`\n*   `given_name`\n*   `locale`\n*   `middle_name`\n*   `name`\n*   `nickname`\n*   `phone_number`\n*   `phone_number_verified`\n*   `picture`\n*   `preferred_username`\n*   `profile`\n*   `updated_at`\n*   `website`\n*   `zoneinfo`\n\n## Namespaced guidelines\n\nUse the following guidelines for namespace identifiers:\n\n*   Use any non-Auth0 HTTP or HTTPS URL as a namespace identifier. Auth0 domains cannot be used as namespace identifiers, and include:\n    \n    *   auth0.com\n        \n    *   webtask.io\n        \n    *   webtask.run\n        \n*   Use a URL that you control as a namespace identifier; this allows you to avoid the risk that someone else is using the same namespace. The namespace URL does not have to point to an actual resource. It is only used as an identifier; it will not be called.\n    \n*   Begin the URL with `http://` or `https://`.\n    \n*   Create multiple namespaces, as needed.\n    \n\nOnce you have chosen your namespace, append the claim to it to create a namespaced claim, which can be added to a token. For example:\n\n`http://www.example.com/favorite_color`\n\n## Non-namespaced guidelines\n\nUse the following guidelines for non-namespaced custom claims:\n\n*   Unless absolutely necessary for your application, use public, namespaced custom claims that are collision resistant.\n    \n*   Create claims with meaningful and collision resistant names. For example, use `employee_id` instead of `e_id`.\n    \n*   Keep the claim names and values as light as possible, passing only the data strictly necessary for your application.\n    \n*   Avoid assigning heavy payloads to custom claims.\n    \n\nFor more examples of custom claims added to a token, see [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims).\n\n## Create custom claims\n\nUse Auth0 Actions to create custom claims. The `api` object allows you to use the method `setCustomClaim` on access tokens or ID tokens.\n\n### Example\n\n```\nexports.onExecuteCredentialsExchange = async (event, api) => {\n  api.accessToken.setCustomClaim('myClaim', 'this is a private, non namespaced claim');\n};\n```\n\n## Learn more\n\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [OpenID Connect Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes)",
  "title": "Create Custom Claims",
  "description": "Learn how to create collision-resistant names for custom claims.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/tokens/guides/validate-id-tokens",
  "markdown": "# Validate ID Tokens\n\nAn [ID token](https://auth0.com/docs/secure/tokens/id-tokens), which contains user profile attributes, is consumed by an app and is typically used for user interface display. Auth0 issues all ID tokens in [JSON web token (JWT)](https://auth0.com/docs/secure/tokens/json-web-tokens) format.\n\nIf any of these checks fail, the token is considered invalid, and the request must be rejected.\n\n1.  [Validate the JWT](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens).\n    \n2.  Check additional standard claims. If you've performed the standard JWT validation, you have already decoded the [JWT's Payload](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure) and looked at its standard claims. Additional claims to verify for ID tokens include:\n    \n    *   **Token audience** (`aud`, string): The audience value for the token must match the client ID of the application as defined in your [Application's Settings](https://manage.auth0.com/#/applications) in the **Client ID** field.\n        \n    *   **Nonce** (`nonce`, string): Passing a nonce in the token request is recommended (required for the Implicit Flow) to help prevent replay attacks. The nonce value in the token must exactly match the original nonce sent in the request. See [Mitigate Replay Attacks](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow) for details.\n        \n\n## Learn more\n\n*   [Get ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens/get-id-tokens)\n*   [ID Token Structure](https://auth0.com/docs/secure/tokens/id-tokens/id-token-structure)\n*   [Update ID Token Lifetime](https://auth0.com/docs/secure/tokens/id-tokens/update-id-token-lifetime)\n*   [Mitigate Replay Attacks When Using the Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow)",
  "title": "Validate ID Tokens",
  "description": "Describes how to validate an ID token.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/scopes/current/api-scopes",
  "markdown": "# API Scopes\n\nAs an API developer, you need to:\n\n1.  Decide which information you would like applications to be able to access on a user's behalf.\n    \n2.  Define these access levels as custom scopes. (To learn what scopes are read [Scopes](https://auth0.com/docs/get-started/apis/scopes).)\n    \n3.  Identify these scopes so that calling applications can use them.\n    \n\n## Ways to use API scopes\n\nYou can use API scopes in different ways:\n\n*   In an API where the calling application is a third-party, or external, application. In this case, the calling application will request authorization from the user to access the requested scopes, and the user will approve or deny the request.\n    \n*   In an API where the calling application is a first-party application, or application that is registered under the same Auth0 domain as the API it is calling. In this case, by default, user consent is not requested, but you may configure consent to be required.\n    \n*   In an API where the calling application is a back-end service, whether third-party or first-party, and no user exists. In this case, user consent is never requested.\n    \n\nAll of these examples use scopes to limit access through use of a token. If you so choose, your API may also use additional logic beyond the token to enforce more extensive access control.\n\nFor an example showing how to request custom API access for your application, read [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims).\n\n### Example: An API called by a third-party application\n\nLet's say you are building an API that provides bank account information to online payment applications. At various times, apps may need to read account balances or transfer funds. To do this, you create two scopes for your API: one that authorizes read access to an account balance (`read:balance`), one that authorizes fund transfers (`transfer:funds`). Your API is registered with Auth0.\n\nA calling application will request authorization from the user to access the requested scopes, and the user will approve or deny the request. The app may request read access to the user's balance by including the `read:balance` scope in its request, access to make fund transfers by including the `transfer:funds` scope in its request, or access to both read the user's balance and transfer funds by including both the `read:balance` and `transfer:funds` scopes in its request.\n\nNow, when the app calls your API, it will include a token which verifies that the user has provided authorization to access their content and also indicates which scopes the user has approved. Your API should respect the approved scopes and only release information that was authorized by the user to the calling application.\n\n### Example: An API called by a first-party application\n\nLet's say you are building an API that provides data to an events application, which you have also written. You [implement role-based access control (RBAC)](https://auth0.com/docs/manage-users/access-control/rbac), creating a role of `organizer` and a role of `participant`. Users with a role of `organizer` need to create and update events, whereas users with a role of `participant` need to view events and register for events. To do this, you create four scopes for your API: one that authorizes create access for events(`create:events`), one that authorizes update access for events (`update:events`), one that authorizes read-only access for events (`view:events`), and one that authorizes registration access for events (`register:events`). Both your API and event application are registered with Auth0, and the **Allow Skipping User Consent** for first-party applications option is enabled for your API. You have installed the Authorization Extension and configured an `organizer` role and created the `create:events` and `update:events` scopes for it, and assigned it to User A. You have also configured a `participant` role and created the `view:events` and `register:events` scopes for it, and assigned it to User B.\n\nUser A authenticates with the calling application, which requests the necessary scopes, but because it is a first-party application, user consent will not be requested. The app may request any combination of `create:events`, `update:events`, `view:events`, and `register:events` scopes, but User A is recognized as having the role of `organizer` and therefore is only granted the `create:events` and `update:events` scopes.\n\nNow, when the app calls your API, it will include a token which verifies that it has authorization for only the scopes associated with the role of the authenticated user.\n\n### Example: An API called by a back-end service\n\nLet's say you work for a hospital and have an API that produces large amounts of imaging data whenever a patient gets an MRI. You store the imaging data locally for six months, but the hospital needs the images to be stored long-term for the purpose of regulatory compliance. Because of this, the hospital has a service that copies imaging data to an offsite cold storage solution on a nightly basis and deletes all local medical data after six months of storage.\n\nTo do this, you create two scopes for your API: one that authorizes read access to your imaging data (`read:images`) and one that authorizes delete access to your imaging data (`delete:images`). Your API and automated service are registered with Auth0, and you have authorized the automated service to request tokens for your API.\n\nThe calling automated service will request the necessary scopes, but because there is no user, consent will not be requested. The service may request read access to your imaging data by including the `read:images` scope in its request, delete access by including the `delete:images` scope in its request, or both read and delete access by including the `read:images` and `delete:images` scopes in its request.\n\nNow, when the automated service calls your API, it will include a token which verifies that it has authorization for the requested scopes.\n\n## Limit API scopes\n\nAn application can include any scope defined for an API in its request. Instead of allowing all available scopes to be requested, however, you can limit scopes for certain users. For example, a user of your application can be given a role so that requests on their behalf are limited to just the scopes assigned to that role. To do this, you can [use the Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension) and create a custom rule. To learn more about Rules, read [Auth0 Rules](https://auth0.com/docs/customize/rules).\n\nTo learn about this approach in more depth, read our [SPA+API Architecture Scenario](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-1). Specifically, you can review the [Configure the Authorization Extension](https://auth0.com/docs/get-started/architecture-scenarios/spa-api/part-2#configure-the-authorization-extension) section to learn how to configure the Authorization Extension and create a custom Rule that will ensure scopes are granted based on a user's role.\n\n## Learn more\n\n*   [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims)\n*   [Add API Permissions](https://auth0.com/docs/get-started/apis/add-api-permissions)\n*   [Customize Consent Prompts](https://auth0.com/docs/customize/login-pages/customize-consent-prompts)\n*   [Configure Logical API for Multiple APIs](https://auth0.com/docs/get-started/apis/set-logical-api)\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)\n*   [Get Management API Access Tokens for Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)",
  "title": "API Scopes",
  "description": "Understand the principle of scopes and how it is used with APIs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/tokens/concepts/jwt-claims",
  "markdown": "# JSON Web Token Claims\n\n[JSON web tokens (JWTs)](https://auth0.com/docs/tokens/concepts/jwts) claims are pieces of information asserted about a subject. For example, an [ID token](https://auth0.com/docs/secure/tokens/id-tokens) (which is always a JWT) can contain a claim called `name` that asserts that the name of the user authenticating is \"John Doe\". In a JWT, a claim appears as a name/value pair where the name is always a string and the value can be any JSON value. Generally, when we talk about a claim in the context of a JWT, we are referring to the name (or key). For example, the following JSON object contains three claims (`sub`, `name`, `admin`):\n\n```\n{\n      \"sub\": \"1234567890\",\n      \"name\": \"John Doe\",\n      \"admin\": true\n    }\n```\n\nThere are two types of JWT claims:\n\n*   **Registered**: standard claims registered with the [Internet Assigned Numbers Authority (IANA)](https://www.iana.org/assignments/jwt/jwt.xhtml) and defined by the [JWT specification](https://tools.ietf.org/html/rfc7519) to ensure interoperability with third-party, or external, applications. OIDC standard claims are reserved claims.\n    \n*   **Custom**:  consists of non-registered public or private claims. Public claims are collision-resistant while private claims are subject to possible collisions.\n    \n\n## Registered claims\n\nThe JWT specification defines seven reserved claims that are not required, but are recommended to allow interoperability with [third-party applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications). These are:\n\n*   `iss` (issuer): Issuer of the JWT\n    \n*   `sub` (subject): Subject of the JWT (the user)\n    \n*   `aud` (audience): Recipient for which the JWT is intended\n    \n*   `exp` (expiration time): Time after which the JWT expires\n    \n*   `nbf` (not before time): Time before which the JWT must not be accepted for processing\n    \n*   `iat` (issued at time): Time at which the JWT was issued; can be used to determine age of the JWT\n    \n*   `jti` (JWT ID): Unique identifier; can be used to prevent the JWT from being replayed (allows a token to be used only once)\n    \n\nYou can see a full list of registered claims at the [IANA JSON Web Token Claims Registry](https://www.iana.org/assignments/jwt/jwt.xhtml#claims).\n\n## Custom claims\n\nYou can define your own custom claims which you control and you can add them to a token using Actions. Here are some examples:\n\n*   Add a user's email address to an access token and use that to uniquely identify the user.\n    \n*   Add custom information stored in an Auth0 user profile to an ID token.\n    \n\nAs long as the Action is in place, the custom claims it adds will appear in new tokens issued when using a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\nFor an example showing how to add custom claims to a token, see [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims).\n\n### Public claims\n\nYou can create custom claims for public consumption, which might contain generic information like name and email. If you create public claims, you must either register them or use collision-resistant names through namespacing and take reasonable precautions to make sure you are in control of the namespace you use.\n\nIn the [IANA JSON Web Token Claims Registry](https://www.iana.org/assignments/jwt/jwt.xhtml#claims), you can see some examples of public claims registered by OpenID Connect (OIDC):\n\n*   `auth_time`\n    \n*   `acr`\n    \n*   `nonce`\n    \n\n### Private claims\n\nYou can create private custom claims to share information specific to your application. For example, while a public claim might contain generic information like name and email, private claims would be more specific, such as employee ID and department name.\n\n## Auth0 restrictions\n\nAuth0 enforces the general restrictions on custom claims: \n\n*   custom claims payload is set to a maximum of 100KB\n    \n*   a subset of OIDC and other registered standard claims or claims used internally by Auth0 cannot be customized or modified\n    \n*   access tokens with an Auth0 API audience, excluding the `/userinfo` endpoint, cannot have private, non-namespaced custom claims \n    \n*   only specified OIDC user profile claims can be added to access tokens\n    \n\nTo learn more about custom claims, read [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\n## Learn more\n\n*   [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens)\n*   [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure)\n*   [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets)\n*   [JSON Web Key Set Properties](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-set-properties)",
  "title": "JSON Web Token Claims",
  "description": "Describe JSON web token (JWT) claims and how they are used in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/protocols/oauth2",
  "markdown": "# OAuth 2.0 Authorization Framework\n\nThe [OAuth 2.0](https://tools.ietf.org/html/rfc6749) authorization framework is a protocol that allows a user to grant a third-party web site or application access to the user's protected resources, without necessarily revealing their long-term credentials or even their identity.\n\nOAuth introduces an authorization layer and separates the role of the client from that of the resource owner. In OAuth, the client requests access to resources controlled by the resource owner and hosted by the resource server and is issued a different set of credentials than those of the resource owner. Instead of using the resource owner's credentials to access protected resources, the client obtains an Access Token\\--a string denoting a specific scope, lifetime, and other access attributes. Access tokens are issued to third-party clients by an authorization server with the approval of the resource owner. Then the client uses the access token to access the protected resources hosted by the resource server.\n\nAuth0 generates access tokens for API authorization scenarios, in [JSON web token (JWT) format](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure). The permissions represented by the access token, in OAuth terms, are known as [scopes](https://auth0.com/docs/get-started/apis/scopes). When an application authenticates with Auth0, it specifies the scopes it wants. If those scopes are authorized by the user, then the access token will represent these authorized scopes.\n\n## Roles\n\nAn OAuth 2.0 flow has the following roles:\n\n*   **Resource Owner**: Entity that can grant access to a protected resource. Typically, this is the end-user.\n    \n*   **Resource Server**: Server hosting the protected resources. This is the API you want to access.\n    \n*   **Client**: Application requesting access to a protected resource on behalf of the Resource Owner.\n    \n*   **Authorization Server**: Server that authenticates the Resource Owner and issues access tokens after getting proper authorization. In this case, Auth0.\n    \n\n## Grant types\n\nOAuth 2.0 defines four flows to get an access token. These flows are called grant types. [Deciding which one is suited for your case](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use) depends mostly on your application type.\n\n*   [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow): used by Web Apps executing on a server. This is also used by mobile apps, using the [Proof Key for Code Exchange (PKCE) technique](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).\n    \n*   [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post): used by JavaScript-centric apps (Single-Page Applications) executing on the user's browser.\n    \n*   [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow): used by highly-trusted apps.\n    \n*   [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow): used for machine-to-machine communication.\n    \n\nThe specification also provides an extensibility mechanism for defining additional grant types. To learn more about how each grant type works and when it should be used, see [Authentication and Authorization Flows](https://auth0.com/docs/get-started/authentication-and-authorization-flow).\n\n## Endpoints\n\nOAuth 2.0 uses two endpoints: the `/authorize` endpoint and the `/oauth/token` endpoint.\n\nThe `/authorize` endpoint is used to interact with the resource owner and get the authorization to access the protected resource. To better understand this, imagine that you want to log in to a service using your Google account. First, the service redirects you to Google in order to authenticate (if you are not already logged in) and then you will get a consent screen, where you will be asked to authorize the service to access some of your data (protected resources); for example, your email address and your list of contacts.\n\nThe request parameters of the `/authorize` endpoint are:\n\n| Parameter | Description |\n| --- | --- |\n| `response_type` | Tells the authorization server which grant to execute. |\n| `response_mode` | (Optional) How the result of the authorization request is formatted. Values:  <br>\\- `query`: for Authorization Code grant. `302 Found` triggers redirect.  <br>\\- `fragment`: for Implicit grant. `302 Found` triggers redirect.  <br>\\- `form_post`: `200 OK` with response parameters embedded in an HTML form as hidden parameters.  <br>\\- `web_message`: For Silent Authentication. Uses HTML5 web messaging. |\n| `client_id` | The ID of the application that asks for authorization. |\n| `redirect_uri` | Holds a URL. A successful response from this endpoint results in a redirect to this URL. |\n| `scope` | A space-delimited list of permissions that the application requires. |\n| `state` | An opaque value, used for security purposes. If this request parameter is set in the request, then it is returned to the application as part of the `redirect_uri`. |\n| `connection` | Specifies the connection type for Passwordless connections |\n\nYou can configure custom query parameters when your application makes the initial call to the `/authorize` endpoint to authenticate a user. You can use custom query parameters to provide additional context to the page template for the New Universal Login experience.\n\nYou must enable ID First to use the `connection` parameter. For more information on the `connection` parameter and the New Universal Login experience, review [Passwordless for New Universal Login](https://auth0.com/docs/authenticate/passwordless/passwordless-with-universal-login).\n\nQuery parameters prefixed with `ext-` automatically appear in the [page template context](https://auth0.com/docs/customize/universal-login-pages/universal-login-page-templates#custom-query-parameters).\n\nThis endpoint is used by the Authorization Code and the Implicit grant types. The authorization server needs to know which grant type the application wants to use since it affects the kind of credential it will issue:\n\n*   For the Authorization Code grant, it will issue an authorization code (which can later be exchanged for an access token at the `/oauth/token` endpoint).\n    \n*   For the Implicit grant, it will issue an access token, which is an opaque string (or a JWT in an Auth0 implementation) that denotes who has authorized which permissions (scopes) to which application.\n    \n\nTo inform the authorization server which grant type to use, the `response_type` request parameter is used as follows:\n\n*   For the Authorization Code grant, use `response_type=code` to include the authorization code.\n    \n*   For the Implicit grant, use `response_type=token` to include an access token. An alternative is to use `response_type=id_token token` to include both an access token and an ID token.\n    \n\nAn ID token is a JWT that contains information about the logged in user. It was introduced by OpenID Connect (OIDC).\n\nThe [OAuth 2.0 Multiple Response Type Encoding Practices specification](https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html) added a parameter that specifies how the result of the authorization request is formatted. This parameter is called `response_mode`. It is optional and can take the following values:\n\n| Value | Description |\n| --- | --- |\n| `query` | This is the default for Authorization Code grant. A successful response is `302 Found` which triggers a redirect to the `redirect_uri`. The response parameters are embedded in the query component (the part after `?`) of the `redirect_uri` in the `Location` header.  <br>For example:  <br>`HTTP/1.1 302 Found`  <br>`Location: https://my-redirect-uri.callback?code=js89p2x1` where the authorization code is `js89p21`. |\n| `fragment` | This is the default for Implicit grant. A successful response is `302 Found`, which triggers a redirect to the `redirect_uri` (which is a request parameter). The response parameters are embedded in the fragment component (the part after `#`) of the `redirect_uri` in the `Location` header.  <br>For example:  <br>`HTTP/1.1 302 Found`  <br>`Location: https://my-redirect-uri/callback#access_token=eyB...78f&token_type=Bearer&expires_in=3600`. |\n| `form_post` | The response mode is defined by the [OAuth 2.0 Form Post Response Mode specification](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html). A successful response is `200 OK` and the parameters are embedded in an HTML form as hidden params. The `action` of the form is the `redirect_uri` and the `onload` attribute is configured to submit the form. After the HTML is loaded by the browser, a redirect to the `redirect_uri` is done. |\n| `web_message` | This response mode is defined in [OAuth 2.0 Web Message Response Mode specification](https://tools.ietf.org/html/draft-sakimura-oauth-wmrm-00). It uses HTML5 Web Messaging instead of the redirect for the authorization response from the /authorization endpoint. This is particularly useful when using Silent Authentication. To do this response mode, you must register your app's URL at the **Allowed Web Origins** field in your Auth0 [application settings](https://manage.auth0.com/#/applications/{yourClientId}/settings). |\n\n### Token endpoint\n\nThe `/oauth/token` endpoint is used by the application in order to get an access token or a refresh token. It is used by all flows except for the Implicit Flow because in that case an access token is issued directly.\n\n*   In the Authorization Code Flow, the application exchanges the authorization code it got from the authorization endpoint for an access token.\n    \n*   In the Client Credentials Flow and Resource Owner Password Credentials Grant Exchange, the application authenticates using a set of credentials and then gets an access token.\n    \n\n## State parameters\n\nAuthorization protocols provide a `state` parameter that allows you to restore the previous state of your application. The `state` parameter preserves some state object set by the client in the Authorization request and makes it available to the client in the response. The primary reason for using the state parameter is to mitigate CSRF attacks. See [Use OAuth 2.0 State Parameters](https://auth0.com/docs/secure/attack-protection/state-parameters) for details.\n\n## Learn more\n\n*   [Prevent Attacks and Redirect Users with OAuth 2.0 State Parameters](https://auth0.com/docs/secure/attack-protection/state-parameters)\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)",
  "title": "OAuth 2.0 Authorization Framework",
  "description": "Learn how Auth0 works with the OAuth 2.0 Authorization Framework. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/universal-login/new",
  "markdown": "# Universal Login Experience\n\n[Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) provides the essential feature of an authorization server: the login flow. When a user needs to prove their identity to gain access to your application, you can redirect them to Universal Login and let Auth0 handle the authentication process.\n\nThe Universal Login experience offers a streamlined implementation with easy-to-use customization tools. For advanced customization, you can also create page templates that allow you to modify the code of your login pages. This experience also supports a variety of features, such as [localization](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization), [WebAuthn](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn), [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication), [Auth0 Organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview), and more.\n\nConfiguring Universal Login is dynamic and does not require any application-level changes, as web pages hosted on Auth0’s centralized authentication server drive the login flow. Additionally, you won’t need to manually update your code for your applications to benefit from improvements Auth0 makes to Universal Login.\n\n## Universal Login features and functionality\n\nThe following sections provide additional details about the Universal Login experience. For a feature comparison between Universal Login and Classic Login, review [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login).\n\n### Customization\n\n*   You can specify a Liquid Template for all pages in the login flow with [Page Templates](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates).\n    \n*   You can customize page branding, including colors, fonts, custom logo URLs, and more, with the [no-code editor](https://auth0.com/docs/customize/login-pages/universal-login/customize-themes) in the Auth0 Dashboard, or with the Management API [Branding](https://auth0.com/docs/api/management/v2#!/Branding/patch_branding) endpoints.\n    \n*   You can configure the favicon URL with the Auth0 Management API [Branding](https://auth0.com/docs/api/management/v2#!/Branding/patch_branding) endpoints.\n    \n*   You can customize page text with either the Auth0 Dashboard or the Management API. To learn more, review [Customize Universal Login Text Elements](https://auth0.com/docs/customize/login-pages/universal-login/customize-text-elements).\n    \n*   You can customize signup and login prompts with the Auth0 Management API. To learn more, review [Customize Signup and Login prompts](https://auth0.com/docs/customize/login-pages/universal-login/customize-signup-and-login-prompts).\n    \n\n### Login\n\n*   You can use [Passwordless with WebAuthn with Device Biometrics](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics).\n    \n*   If you are using [development keys](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/devkeys) for social providers:\n    \n    *   Single Sign-on (SSO) and Silent Authentication will work properly. This is not supported in the Classic Login experience.\n        \n    *   Users receive a warning on the login page stating the tenant is configured with development keys.\n        \n*   A button is rendered for each social and enterprise connection.\n    \n*   If you redirect users to the `/login` page directly, they will receive an error unless you configured a default login route. To learn more, review [Configure Default Login Routes](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes). You should always redirect users to the proper authorization request endpoint (e.g., `/authorize` if you are using OpenID Connect).\n    \n*   You can specify the `login_hint` when redirecting to Auth0 and use this information to populate the username/email field for the login or signup page.\n    \n*   Passkeys are available as an authentication method for [database connections](https://auth0.com/docs/authenticate/database-connections). Passkeys are a phishing-resistant alternative to traditional authentication factors (such as username/password) that offer an easier and more secure login experience to users. To learn more, review [Passkeys](https://auth0.com/docs/authenticate/database-connections/passkeys).\n    \n\n### Signup\n\n*   You can have users land directly on the signup page instead of the login page by specifying the `screen_hint=signup` parameter when redirecting to `/authorize`. You can combine this paramter with `prompt=login` to indicate whether you want to always show the authentication page or skip the page if an existing session exists.\n    \n\n| `/authorize` parameters | No existing session | Existing session |\n| --- | --- | --- |\n| no extra parameters | Shows the login page | Redirects to the callback url |\n| `screen_hint=signup` | Shows the signup page | Redirects to the callback url |\n| `prompt=login` | Shows the login page | Shows the login page |\n| `prompt=login&screen_hint=signup` | Shows the signup page | Shows the signup page |\n\n### Multi-factor authentication\n\n*   If users have more than one MFA factor enrolled (e.g., SMS and push notifications), the Universal Login MFA page lets the user choose their preferred option.\n    \n*   You can use voice or email as an MFA factor. To learn more, review [Configure SMS and Voice Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa) and [MFA Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n    \n*   If you are using the Guardian SDK to create your own native application to handle Push Notifications, you can configure the name of the application and the URLs to download them in the **Push via Auth0 Guardian** option in the [Dashboard > Security > Multi-Factor Auth](https://manage.auth0.com/#/mfa) section.\n    \n*   If you have a rule that sets the MFA provider to `google-authenticator`, you must enable that OTP factor in the [Dashboard > Security > Multi-Factor Auth](https://manage.auth0.com/#/mfa) section.\n    \n*   You can use [WebAuthn](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn) for MFA.\n    \n*   Using [Actions](https://auth0.com/docs/customize/actions), you customize your MFA flows to challenge users with a specific factor or series of factors. You can also leverage user metadata, such as roles or Organization memberships, to create more individualized experiences. To learn more, review [Customize MFA Selection in Universal Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-selection-universal-login).\n    \n\n## Password reset\n\n*   The Universal Login experience redirects users to the default login route when it succeeds and handles the error cases as part of the Universal Login flow. The Redirect URL in the email template will be ignored. Note that you must provide an **Application Login URI** in the [Dashboard > Applications > Applications](https://auth0.com/docs/get-started/applications/application-settings) **Settings** tab for the redirect URLs to work.\n    \n*   If the database connection is set to **Require Username**, the password reset flow prompts the user for their username and sends a password reset email to the associated email address. To learn more, review [Adding Username for Database Connections](https://auth0.com/docs/authenticate/database-connections/require-username).\n    \n*   Using [Actions](https://auth0.com/docs/customize/actions), you can incorporate a secondary challenge into your [password reset flows](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset). Specifically, the `post-challenge` trigger allows you to present an additional challenge to users after they complete their first step (typically a link in a password reset email) but before they create their new password. Using this trigger, you can redirect users to an external site, such as a third-party verifier, or challenge them with an additional MFA factor. Users must complete this second challenge in order to update their password.\n    \n    *   **Note**: You can customize the MFA prompts displayed to users during the password reset flow. To learn more, review [Customize Universal Login Text Prompts.](https://auth0.com/docs/customize/login-pages/universal-login/customize-text-elements)\n        \n\n## Custom database connections\n\nWhen using custom database connections:\n\n*   The password reset flow will function properly even if you return errors from the change password script.\n    \n*   The errors returned in `ValidationErrors` or `WrongUsernameOrPasswordError` will be displayed on the corresponding pages. To learn more, review [Troubleshoot Custom Databases](https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling).\n    \n\n## Email verification\n\nAfter a user clicks the email verification link, they'll be redirected to a page that will confirm that their email is verified. If the default login route is configured, users will be able to click a button and get redirected to it.\n\n## Password autocomplete\n\nUniversal Login pages use the [autocomplete attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) for password fields.\n\nOn the signup and password reset pages, `autocomplete` is set to `\"new-password\"`. This signals the password manager to prompt the user to generate a secure, random password. The user has to provide explicit consent to save the password in the password manager.\n\nOn the login page `autocomplete` is set to `\"current-password\"`. The login page automatically fills in the password if it's available in the browser's password manager.\n\nNote that turning off password autocompletion does not increase security:\n\n*   Users need to opt-in for saving the password in the browser’s password manager\n    \n*   Once it’s saved in the password manager, any user with access to the computer can go into the password manager and get the password whether the password is auto-filled on the login screen or not. If users are logged-in to the browser then they are prompted for their password before viewing saved passwords. If not, everyone can see them.\n    \n*   In the case of Safari, users are asked to enter their Mac password or use Touch ID before the password is completed.\n    \n\n## Implement Universal Login\n\nTo learn how to set up your application to use Universal Login, read our [Quickstarts](https://auth0.com/docs/quickstarts). Choose the approach that best fits your technologies, and the Quickstarts walk you through the implementation.\n\n## Learn more\n\n*   [Configure Default Login Routes](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes)\n*   [Configure SMS and Voice Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n*   [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Check Login and Logout Issues](https://auth0.com/docs/troubleshoot/authentication-issues/check-login-and-logout-issues)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
  "title": "Universal Login Experience",
  "description": "An overview of the Universal Login experience",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api-auth/dynamic-client-registration",
  "markdown": "# Dynamic Application Registration\n\nYou can dynamically register third-party applications for your tenant. This feature is based on the [OpenID Connect Dynamic Client Registration specification](https://openid.net/specs/openid-connect-registration-1_0.html).\n\n## Enable dynamic client registration\n\nBy default, dynamic application registration is disabled for all tenants. To change this, you have to set the `enable_dynamic_client_registration` flag to `true` in your tenant's settings.\n\nTo do so, go to [Dashboard > Settings > Advanced](https://manage.auth0.com/#/tenant/advanced) and enable the **OIDC Dynamic Application Registration**.\n\nAlternatively, you can update this flag using the Management API [`/Tenant/patch_settings`](https://auth0.com/docs/api/management/v2#!/Tenants/patch_settings) endpoint.\n\n*   [cURL](#24df2c509ed744b9ba3dabf543cd4019_shell)\n*   [C#](#24df2c509ed744b9ba3dabf543cd4019_csharp)\n*   [Go](#24df2c509ed744b9ba3dabf543cd4019_go)\n*   [Java](#24df2c509ed744b9ba3dabf543cd4019_java)\n*   [Node.JS](#24df2c509ed744b9ba3dabf543cd4019_node)\n*   [Obj-C](#24df2c509ed744b9ba3dabf543cd4019_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/tenants/settings' \\\n  --header 'authorization: Bearer API2_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"flags\": { \"enable_dynamic_client_registration\": true } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/tenants/settings\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer API2_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"flags\\\": { \\\"enable_dynamic_client_registration\\\": true } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/tenants/settings\"\n\n\tpayload := strings.NewReader(\"{ \\\"flags\\\": { \\\"enable_dynamic_client_registration\\\": true } }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer API2_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/tenants/settings\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer API2_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"flags\\\": { \\\"enable_dynamic_client_registration\\\": true } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/tenants/settings',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer API2_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {flags: {enable_dynamic_client_registration: true}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer API2_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"flags\": @{ @\"enable_dynamic_client_registration\": @YES } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/tenants/settings\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/tenants/settings\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"flags\\\": { \\\"enable_dynamic_client_registration\\\": true } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer API2_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"flags\\\": { \\\"enable_dynamic_client_registration\\\": true } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer API2_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/tenants/settings\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/tenants/settings\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer API2_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"flags\\\": { \\\"enable_dynamic_client_registration\\\": true } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer API2_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"flags\": [\"enable_dynamic_client_registration\": true]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/tenants/settings\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou need to update the `API2_ACCESS_TOKEN` with a valid token with the scope `update:tenant_settings`. To learn more, read [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens).\n\n## Use dynamic client registration\n\nIn this section, we will see how you can dynamically register and configure an application.\n\n### Register your application\n\nTo dynamically register an application with Auth0, you need to send an HTTP `POST` message to the Application Registration endpoint: `https://{yourDomain}/oidc/register`. Note that Auth0 supports **Open Dynamic Registration**, which means that the endpoint will accept a registration request without an access token.\n\nTo create an application with the name `My Dynamic application` and the callback URLs `https://application.example.com/callback` and `https://application.example.com/callback2`, use the following snippet:\n\n*   [cURL](#d6947ec9260c4526af4390ae35dd5617_shell)\n*   [C#](#d6947ec9260c4526af4390ae35dd5617_csharp)\n*   [Go](#d6947ec9260c4526af4390ae35dd5617_go)\n*   [Java](#d6947ec9260c4526af4390ae35dd5617_java)\n*   [Node.JS](#d6947ec9260c4526af4390ae35dd5617_node)\n*   [Obj-C](#d6947ec9260c4526af4390ae35dd5617_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oidc/register' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_name\":\"My Dynamic Application\",\"redirect_uris\": [\"https://application.example.com/callback\", \"https://application.example.com/callback2\"]}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oidc/register\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"client_name\\\":\\\"My Dynamic Application\\\",\\\"redirect_uris\\\": [\\\"https://application.example.com/callback\\\", \\\"https://application.example.com/callback2\\\"]}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oidc/register\"\n\n\tpayload := strings.NewReader(\"{\\\"client_name\\\":\\\"My Dynamic Application\\\",\\\"redirect_uris\\\": [\\\"https://application.example.com/callback\\\", \\\"https://application.example.com/callback2\\\"]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oidc/register\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"client_name\\\":\\\"My Dynamic Application\\\",\\\"redirect_uris\\\": [\\\"https://application.example.com/callback\\\", \\\"https://application.example.com/callback2\\\"]}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oidc/register',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_name: 'My Dynamic Application',\n    redirect_uris: [\n      'https://application.example.com/callback',\n      'https://application.example.com/callback2'\n    ]\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_name\": @\"My Dynamic Application\",\n                              @\"redirect_uris\": @[ @\"https://application.example.com/callback\", @\"https://application.example.com/callback2\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oidc/register\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oidc/register\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"client_name\\\":\\\"My Dynamic Application\\\",\\\"redirect_uris\\\": [\\\"https://application.example.com/callback\\\", \\\"https://application.example.com/callback2\\\"]}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"client_name\\\":\\\"My Dynamic Application\\\",\\\"redirect_uris\\\": [\\\"https://application.example.com/callback\\\", \\\"https://application.example.com/callback2\\\"]}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oidc/register\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oidc/register\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"client_name\\\":\\\"My Dynamic Application\\\",\\\"redirect_uris\\\": [\\\"https://application.example.com/callback\\\", \\\"https://application.example.com/callback2\\\"]}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_name\": \"My Dynamic Application\",\n  \"redirect_uris\": [\"https://application.example.com/callback\", \"https://application.example.com/callback2\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oidc/register\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nWhere:\n\n*   **client\\_name**: The name of the Dynamic Application to be created\n    \n*   **redirect\\_uris** (required): An array of URLs that Auth0 will deem valid to call at the end of an authentication flow\n    \n\nOptionally, you can set a value for `token_endpoint_auth_method`, which can be `none` or `client_secret_post` (default value). Use `token_endpoint_auth_method: none` in the request payload if creating a SPA.\n\nThe response includes the basic application information.\n\n```\nHTTP/1.1 201 Created\nContent-Type: application/json\n{\n  \"client_name\": \"My Dynamic Application\",\n  \"client_id\": \"8SXWY6j3afl2CP5ntwEOpMdPxxy49Gt2\",\n  \"client_secret\": \"Q5O...33P\",\n  \"redirect_uris\": [\n    \"https://application.example.com/callback\",\n    \"https://application.example.com/callback2\"\n  ],\n  \"client_secret_expires_at\": 0\n}\n```\n\nWhere:\n\n*   **client\\_id**: Unique client identifier. This is the ID you will use while configuring your apps to use Auth0. It is generated by the system and it cannot be modified.\n    \n*   **client\\_secret**: Alphanumeric 64-bit client secret. This value is used by applications to authenticate to the Authentication API [`/token`](https://auth0.com/docs/api/authentication#get-token) and for signing and validating ID tokens.\n    \n*   **client\\_secret\\_expires\\_at**: Time at which the `client_secret` will expire. For Auth0 this value will always be zero (`0`) which means that the application never expires.\n    \n\nMake a note of the client ID and client secret, as these are the most important pieces for executing authentication and authorization flows. To learn more, read [Authentication and Authorization Flows](https://auth0.com/docs/get-started/authentication-and-authorization-flow).\n\nAlso, keep in mind that third-party developers are not allowed to modify the application settings. In case this is necessary, they need to contact the tenant owner with their request.\n\n### Configure your application\n\nNow that you have a Client ID and Secret, you can configure your application to authenticate users with Auth0.\n\nWe will go through a simple example, that shows how to call an API from a client-side web app, using the [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post).\n\nFirst, you need to configure your application to send the user to the authorization URL:\n\n```\nhttps://{yourDomain}/authorize?\n  audience={API_AUDIENCE}&\n  scope={SCOPE}&\n  response_type={RESPONSE_TYPE}&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  nonce={NONCE}\n  state={OPAQUE_VALUE}\n```\n\nWhere:\n\n*   **audience** (optional): The target API for which the Application is requesting access on behalf of the user. Set this parameter if you need API access.\n    \n*   **scope** (optional): The scopes for which you want to request authorization. These must be separated by a space. You can request any of the [standard OIDC scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) for users, such as `profile` and `email`, custom claims that must conform to a namespaced format, or any scopes supported by the target API (for example, `read:contacts`). Set this parameter if you need API access. To learn more, read [API Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes).\n    \n*   **response\\_type**: The response type. For Implicit Grant you can either use `token` or `id_token token`. This will specify the type of token you will receive at the end of the flow. Use `token` to get only an access token, or `id_token token` to get both an ID token and an access token.\n    \n*   **client\\_id**: Your application's client ID.\n    \n*   **redirect\\_uri**: The URL to which the authorization server (Auth0) will redirect the User Agent (Browser) after authorization has been granted by the User. The access token (and optionally an ID token) will be available in the hash fragment of this URL. This URL must be specified as a valid callback URL under the **Application Settings** of your application.\n    \n*   **state**: An opaque value the applications add to the initial request that the authorization server includes when redirecting the back to the application. This value must be used by the application to prevent CSRF attacks.\n    \n*   **nonce**: A string value that will be included in the ID token response from Auth0, used to prevent token replay attacks. It is required for `response_type=id_token token`.\n    \n\nFor example:\n\n```\n<a href=\"https://{yourDomain}/authorize?scope=appointments%20contacts&audience=appointments:api&response_type=id_token%20token&client_id={yourClientId}&redirect_uri={https://yourApp/callback}\">\n  Sign In\n</a>\n```\n\nThis call will redirect the user to Auth0, and upon successful authentication, back to your application (specifically to the **redirect\\_uri**).\n\nIf you need API access, then following the authentication, you need to extract the access token from the hash fragment of the URL, and use it to make calls to the API, by passing it as a `Bearer` token in the `Authorization` header of the HTTP request.\n\n## Learn more\n\n*   [First-Party and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications)\n*   [User Consent and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications)",
  "title": "Dynamic Application Registration",
  "description": "Learn how to dynamically register applications with Auth0 using the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/users/references/link-accounts-server-side-scenario",
  "markdown": "# User Account Linking: Server-Side Implementation\n\n##### User Account Linking: Server-Side Implementation\n\nManage Users\n\nManage Access\n\nAuth0 supports the linking of user accounts from various identity providers. You can use server-side code to link accounts on a regular web application, engaging the user and asking them for permission before proceeding. Your code will authenticate users and search for and identify users using their email addresses. Your application will then prompt the user to link their accounts by authenticating with the target account's credentials, and later link the accounts.\n\nYou can find the full source of this sample application [on GitHub](https://github.com/auth0-samples/auth0-link-accounts-sample/tree/master/RegularWebApp).\n\n1.  Log the user into your application.\n    \n    The user authenticates to your application using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). To learn more, read the [Regular Web App Quickstart](https://auth0.com/docs/quickstart/webapp), asking for a token for the Auth0 Management API audience (audience=`https://{yourDomain}/api/v2/`).\n    \n2.  Search for users with identical email addresses.\n    \n    You can get the user profile and the list of users with the same verified email.\n    \n    ```\n    router.get(\"/\", async (req, res) => {\n      const { sub, email_verified } = req.openid.user;\n      //fetch user profile containing the user_metadata and app_metadata properties\n      try {\n        let getUsersWithSameVerifiedEmail = [];\n        const getUserProfile = auth0Client.getUser(sub);\n        if (email_verified)\n          // account linking is only offered verified email\n          getUsersWithSameVerifiedEmail = auth0Client.getUsersWithSameVerifiedEmail(\n            req.openid.user\n          );\n    \n        const [user, suggestedUsers] = await Promise.all([\n          getUserProfile,\n          getUsersWithSameVerifiedEmail,\n        ]);\n    \n        const flashError = clear(req);\n        res.render(\"user\", {\n          user,\n          suggestedUsers,\n          wrongAccountError: flashError && flashError === Errors.WrongAccount,\n        });\n      } catch (err) {\n        debug(\"GET /user[s] failed: %o\", err);\n        res.render(\"error\", err);\n      }\n    });\n    ```\n    \n    To get a list of all of the user records with the same email address, your application calls the Auth0 Management API's [Get Users By Email endpoint](https://auth0.com/docs/api/v2#!/users-by-email/get_users_by_email) using a [Management API Access Token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) with the `read:users` scope.\n    \n    ```\n    const request = require('request');\n    class Auth0Client {\n    ...\n    async getUsersWithSameVerifiedEmail({ sub, email }) {\n      return await this.request({\n        url: `${process.env.ISSUER_BASE_URL}/api/v2/users-by-email?email=${email}`,\n      });\n    }\n    ```\n    \n3.  Prompt the user to link accounts.\n    \n    1.  If Auth0 returns one or more records with matching email addresses, the user will see the list along with the following message prompting them to link the accounts.\n        \n    2.  If the user wants to link a given account, they can click **Link** next to the appropriate account.\n        \n        ![Example application with server-side account linking page](https://images.ctfassets.net/cdy7uua7fh8z/7unQjUtxTZUc4tRFOxhaP3/050fb853d2b3be37795ce88b8a60ffed/account-linking-webapp-small__1_.png)\n4.  When the user clicks **Link**, your application will ask the user to authenticate with the target account, and then perform account linking.\n    \n    The following code snippet shows how to verify and merge metadata:\n    \n    ```\n    async function accountLink(req, res, next) {\n    const {\n      linking: { targetUserId },\n    } = req.appSession;\n    const { sub: authenticatedTargetUserId } = req.openidTokens.claims();\n    if (authenticatedTargetUserId !== targetUserId) {\n      debug(\n        \"Skipping account linking as the authenticated user(%s)  is different than target linking user (%s)\",\n        authenticatedTargetUserId,\n        targetUserId\n      );\n      set(req, Errors.WrongAccount);\n      return next();\n    }\n    \n    debug(\n      \"User %s succesfully authenticated. Account linking with %s... \",\n      authenticatedTargetUserId,\n      targetUserId\n    );\n    const { id_token: targetIdToken } = req.openidTokens;\n    const { sub: primaryUserId } = req.appSession.claims;\n    \n    try {\n      await mergeMetadata(primaryUserId, authenticatedTargetUserId);\n      await auth0Client.linkAccounts(primaryUserId, targetIdToken);\n      debug(\"Accounts linked.\");\n    } catch (err) {\n      debug(\"Linking failed %o\", err);\n    } finally {\n      next();\n    }\n    }\n    ```\n    \n5.  Your application calls the Auth0 Management API's [Link a User Account endpoint](https://auth0.com/docs/api/v2#!/Users/post_identities) using a [Management API Access Token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) with the `update:users` scope.\n    \n\n## Metadata merge example\n\nThe following example shows explicitly how the `user_metadata` and `app_metadata` from the secondary account gets merged into the primary account using the [Node.js Auth0 SDK for API V2](https://github.com/auth0/node-auth0).\n\n```\n/*\n * Recursively merges user_metadata and app_metadata from secondary into primary user.\n * Data of primary user takes preponderance.\n * Array fields are joined.\n */\nasync function mergeMetadata(primaryUserId, secondaryUserId) {\n  // load both users with metedata.\n  const [primaryUser, secondaryUser] = await Promise.all(\n    [primaryUserId, secondaryUserId].map((uid) => auth0Client.getUser(uid))\n  );\n\n  const customizerCallback = function (objectValue, sourceValue) {\n    if (_.isArray(objectValue)) {\n      return sourceValue.concat(objectValue);\n    }\n  };\n  const mergedUserMetadata = _.merge(\n    {},\n    secondaryUser.user_metadata,\n    primaryUser.user_metadata,\n    customizerCallback\n  );\n  const mergedAppMetadata = _.merge(\n    {},\n    secondaryUser.app_metadata,\n    primaryUser.app_metadata,\n    customizerCallback\n  );\n  await auth0Client.updateUser(primaryUserId, {\n    user_metadata: mergedUserMetadata,\n    app_metadata: mergedAppMetadata,\n  });\n}\n```\n\n## Learn more\n\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Troubleshoot Invalid Token Errors](https://auth0.com/docs/troubleshoot/basic-issues/invalid-token-errors)\n\nWas this article helpful?",
  "title": "User Account Linking: Server-Side Implementation",
  "description": "Describes how to link user accounts with a regular web app using server-side code using a sample scenario.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/users/references/link-accounts-user-initiated-scenario",
  "markdown": "# User-Initiated Account Linking: Client-Side Implementation\n\nAuth0 supports the linking of user accounts from various identity providers. One way to implement this functionality is to enable the user to explicitly link accounts. In this scenario, the user authenticates through the UI of your Single Page Application (SPA) and can later use a link or button to link another account to the first one. When the user clicks on this link/button, your application makes a call so that when the user logs in with the second provider, the second account is linked with the first.\n\nWhen you initiate account linking, you can select which identity to use as the primary account and which to use as the secondary. This choice depends on which set of attributes you want to retain in the primary profile, as you will only retain the attributes from the primary account.\n\nCreate a React Sample Single Page Application with this project [on GitHub](https://github.com/auth0-samples/auth0-link-accounts-sample/tree/master/SPA).\n\nIn this project, open the `auth_config.json` file in your text editor and update the domain and `client_id` with your details.\n\nAdd `http://localhost:3000` in the “Allowed Callback URLs”, “Allowed Logout URLs”, “Allowed Web Origins” field.\n\n1.  Log the user in to your application.\n    \n    The user authenticates to your SPA using using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login), requesting an [Access Token for the Management API](https://auth0.com/docs/api/management/v2/get-access-tokens-for-spas).\n    \n    In the typical SPA login, the callback is handled client-side by the same page, and a JWT is received after successful authentication. To learn more, read the [Single-Page App Quickstart](https://auth0.com/docs/quickstart/spa).\n    \n2.  The user initiates account linking. Your SPA must provide a UI for the user to initiate a link to their other accounts. For example, your SPA could contain a user's settings page:\n    \n    When the user clicks on the **Link Account** button, your app redirects the user to the Universal Login page, when they log in with the connection they want to link to. After successful authentication, use the obtained token to link the accounts.\n    \n    You could also add a button for each connection (e.g. 'Link Facebook Account', 'Link Google Account') and redirect the user to `/authorize` with the `connection` parameter set (e.g. `/authorize?connection=facebook`).\n    \n    ![Example profile page with user account linking](https://images.ctfassets.net/cdy7uua7fh8z/4qxdXGBnlVRDaTkw2wv9WP/8792cff7c5fc21910ec12495828539da/account-linking-spa.png)\n3.  Link accounts by calling the Auth0 Management API's [Link a User Account endpoint](https://auth0.com/docs/api/v2#!/Users/post_identities).\n    \n4.  In the `linkAccount` function, call the Management API. Authenticate with the API using the primary JWT, which is the Access Token, and link using the primary user's ID and the secondary JWT, which is the secondary user's ID Token.\n    \n    ```\n    const linkAccount = async () => {\n      const accessToken = await auth0.getTokenSilently();\n      const { sub } = await auth0.getUser();\n      // authenticateUser should authenticate the user with the account to be linked\n      // See the Github sample for more details\n      const {\n        __raw: targetUserIdToken,\n        email_verified,\n        email,\n      } = await authenticateUser();\n      if (!email_verified) {\n        throw new Error(\n          `Account linking is only allowed to a verified account. Please verify your email ${email}.`\n        );\n      }\n      await fetch(`https://${config.domain}/api/v2/users/${sub}/identities`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${accessToken}`,\n        },\n        body: JSON.stringify({\n          link_with: targetUserIdToken,\n        }),\n      });\n    };\n    ```\n    \n\n#### Account Linking: Access Tokens vs. ID Tokens\n\nPreviously, in some cases, you could use ID Tokens to link and unlink user accounts. This functionality is being deprecated. You will have to use Access Tokens in all cases. The change in the unlinking of accounts is that you can no longer use an ID Token in the Authorization header. An Access Token must be used instead. The functionality is still available but not recommended and affected users are encouraged to migrate. See [Migration Guide: Account Linking with Access Tokens vs. ID Tokens](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/link-user-accounts-with-access-tokens-migration) for details.\n\n## Learn more\n\n*   [Link User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts)\n*   [Unlink User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/unlink-user-accounts)\n*   [User Account Linking: Server-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)",
  "title": "User-Initiated Account Linking: Client-Side Implementation",
  "description": "Learn how to provide a client-side UI that allows users to authenticate to their other accounts and link these to their primary account using a SPA.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-embedded-login-to-universal-login",
  "markdown": "# Migrate from Embedded Login to Universal Login\n\nWhen you integrate Auth0 into your applications, you have to decide whether you will use embedded or Universal Login.\n\n*   With embedded login the login dialog is hosted in your application. You can use [Lock](https://auth0.com/docs/libraries/lock) or create your own UI and use auth0.js.\n    \n*   With Universal Login, you redirect to an Auth0-hosted login page where the authentication flow is performed.\n    \n\nUniversal Login has several advantages over embedded login. For a detailed analysis refer to [Centralized vs Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login).\n\nYou can also find how to implement Universal Login in multiple technology stacks using [Quickstarts](https://auth0.com/docs/quickstarts).\n\n## Embedded Login Scenarios with Single Sign-On\n\nMigration from legacy versions of Lock and Auth0.js is required. For Single Sign-on (SSO) scenarios, it will imply moving to Universal Login in most cases.\n\n### Single-Page Apps\n\nSingle-Page Applications (SPAs) with embedded login can only achieve SSO if they are on the same top-level domain. If SPAs with embedded login which are on different domains require SSO, the websites will need to migrate to Universal Login.\n\nSSO works by having Auth0 set a cookie that identifies the session in the Auth0 server for a specific domain.\n\nIn order to make embedded login work properly, you need to set up a custom domain that matches your website's top level domain, so as to avoid cross-origin authentication issues.\n\nIf two applications using embedded login are sitting on different top-level domains, they would need to point to two different custom domains in order implement embedded login properly. If they are on different domains, those domains cannot share the same SSO cookie, so you can’t implement SSO across those sites.\n\n### Web Apps\n\nWeb Applications using embedded login that require SSO need to migrate to Universal Login.\n\nThe proper way of implementing embedded login for web applications is by creating a custom form that POSTs credentials to the web application. The web application then validates them with Auth0 using the `/oauth/token` endpoint.\n\nThis approach does not allow for the creation of an SSO session, as the Auth0 server cannot set a cookie in the end-user’s browser. It also prevents Auth0 from performing attack protection.\n\n## Learn more\n\n*   [Migrate from Legacy Authentication Flows](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-legacy-auth-flows)\n*   [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login)",
  "title": "Migrate from Embedded Login to Universal Login",
  "description": "Describes how to migrate from Embedded Login using Lock to Universal Login.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/cross-origin-authentication",
  "markdown": "# Cross-Origin Authentication\n\nAuth0 strongly recommends that authentication transactions be handled via [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) because it is the easiest and most secure way to authenticate users. To learn more, read [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login). There are a limited number of situations that may require that authentication forms be directly embedded in an application. Although not recommended, cross-origin authentication provides a way to do this.\n\n## What is cross-origin authentication?\n\nWhen authentication requests are made from your application (via the Lock widget or a custom login form) to Auth0, the user's credentials are sent to a domain that differs from the one that serves your application. Collecting user credentials in an application served from one origin and then sending them to another origin can present certain security vulnerabilities, including the possibility of a phishing attack.\n\nAuth0 provides a cross-origin authentication flow that uses third-party cookies. The use of third-party cookies allows Lock and Auth0's backend to perform the necessary checks to allow for secure authentication transactions across different origins. This helps to prevent phishing when creating a Single Sign-on experience with the Lock widget or a custom login form in your application and it also helps to create a secure login experience even if SSO is not the goal.\n\nCross-origin authentication is not recommended and is only necessary when authenticating against a directory using a username and password. Social IdPs and enterprise federation use a different mechanism, redirecting via standard protocols like OpenID Connect and SAML. Additionally, cross-origin authentication is only applicable to embedded login on the web (using Lock or auth0.js). Native applications using embedded login make use of the standard OAuth 2.0 Token endpoint.\n\n## Limitations\n\nBecause cross-origin authentication is achieved using third-party cookies, disabling third-party cookies will make cross-origin authentication fail. Some browsers, such as the newest version of Firefox, disable third-party cookies by default, meaning that cross-origin authentication will not work for users on Firefox. The only way to make embedded login work for Firefox users is to use a custom domain, as described below.\n\nThere are two approaches you can follow to remediate the issue:\n\n*   Enable a [Custom Domain](https://auth0.com/docs/customize/custom-domains) on your tenant and host your web application in a domain that has the same top-level domain as your Auth0 custom domain. For example, you host an application at `https://northwind.com` and set your Auth0 custom domain as `https://login.northwind.com`. This way the cookies are no longer third-party (because both your Auth0 tenant and your application are using the same top-level domain), and thus, are not blocked by browsers.\n    \n*   Create and link a cross-origin verification page that will make cross-origin authentication work in a limited number of browsers even with third-party cookies disabled.\n    \n\n## Learn more\n\n*   [Configure Cross-Origin Resource Sharing](https://auth0.com/docs/get-started/applications/set-up-cors)\n*   [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login)\n*   [Migrate from Embedded Login to Universal Login](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-embedded-login-to-universal-login)\n*   [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login)",
  "title": "Cross-Origin Authentication",
  "description": "An explanation of cross-origin authentication in Auth0 and its compatibility with browsers",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/users/guides/unlink-user-accounts",
  "markdown": "# Unlink User Accounts\n\nUse the Auth0 Management API [Unlink a User Account](https://auth0.com/docs/api/management/v2#!/Users/delete_user_identity_by_user_id) endpoint or the Auth0.js library to unlink an identity from the target user account making it a separate user account again.\n\nThe result of the unlinking process is the following:\n\n*   The secondary account is removed from the identities array of the primary account.\n    \n*   A new secondary user account is created.\n    \n*   The secondary account will have no metadata.\n    \n\nIf your goal is to delete the secondary identity entirely, you must first unlink the accounts, and then [delete the newly created secondary account](https://auth0.com/docs/manage-users/user-accounts/delete-users).\n\nDepending on from where you call the endpoint, use one of these two scopes:\n\n*   `update:current_user_identities` from [client-side code](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation)\n    \n*   `update:users` from [server-side code](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)\n    \n\nThe endpoint uses the following parameters:\n\n| Parameter | Type | Description |\n| --- | --- | --- |\n| `id` | `string` | ID of the primary user account (required) |\n| `provider` | `string` | identity provider name of the secondary linked account (e.g. `google-oauth2`) |\n| `user_id` | `string` | ID of the secondary linked account (e.g. `123456789081523216417` part after the \\` |\n\nIf your instance has users from multiple providers, you may also include `[connection_name]|` before the `user_id` string to name the provider (for example, `\"user-id\": \"google-oauth2|123456789081523216417\").`\n\n## Response example\n\n```\n[\n  {\n    \"connection\": \"Initial-Connection\",\n    \"user_id\": \"5457edea1b8f22891a000004\",\n    \"provider\": \"auth0\",\n    \"isSocial\": false,\n    \"access_token\": \"\",\n    \"profileData\": {\n      \"email\": \"\",\n      \"email_verified\": false,\n      \"name\": \"\",\n      \"username\": \"johndoe\",\n      \"given_name\": \"\",\n      \"phone_number\": \"\",\n      \"phone_verified\": false,\n      \"family_name\": \"\"\n    }\n  }\n]\n```\n\n## Use JWT from the primary account\n\nTo unlink accounts, call the Management API [Unlink a User Account endpoint](https://auth0.com/docs/api/v2#!/Users/delete_user_identity_by_user_id) using the JWT from the primary account for authorization:\n\n```\nfunction unlinkAccount(secondaryProvider, secondaryUserId){\n  var primaryUserId = localStorage.getItem('user_id');\n  var primaryJWT = localStorage.getItem('id_token');\n  $.ajax({\n    type: 'DELETE',\n    url: 'https://' + '{yourDomain}' + '/api/v2/users/' + primaryUserId +\n         '/identities/' + secondaryProvider + '/' + secondaryUserId,\n    headers: {\n      'Authorization': 'Bearer ' + primaryJWT\n    }\n  }).then(function(identities){\n    alert('unlinked!');\n    showLinkedAccounts(identities);\n  }).fail(function(jqXHR){\n    alert('Error unlinking Accounts: ' + jqXHR.status + ' ' + jqXHR.responseText);\n  });\n}\n```\n\n## Use Access Token with the update:users scope\n\nIf you need to unlink two or more user accounts, call the Management API [Unlink a User Account endpoint](https://auth0.com/docs/api/v2#!/Users/delete_user_identity_by_user_id) using an [Management API Access Token](https://auth0.com/docs/api/v2/tokens) with the `update:users` scope.\n\n```\nfunction unlinkAccount(secondaryProvider, secondaryUserId) {\n  var primaryUserId = localStorage.getItem('user_id');\n  var primaryAccessToken = localStorage.getItem('access_token');\n\n  // Uses the Access Token of the primary user as a bearer token to identify the account\n  // which will have the account unlinked to, and the user id of the secondary user, to identify\n  // the user that will be unlinked from the primary account.\n\n  $.ajax({\n    type: 'DELETE',\n    url: 'https://' + AUTH0_DOMAIN +'/api/v2/users/' + primaryUserId +\n         '/identities/' + secondaryProvider + '/' + secondaryUserId,\n    headers: {\n      'Authorization': 'Bearer ' + primaryAccessToken\n    }\n  }).then(function(identities){\n    alert('unlinked!');\n    showLinkedAccounts(identities);\n  }).fail(function(jqXHR){\n    alert('Error unlinking Accounts: ' + jqXHR.status + ' ' + jqXHR.responseText);\n  });\n}\n```\n\n## Unlink accounts from server-side code\n\n1.  Update the user in session with the new array of identities (each of which represent a separate user account).\n    \n\n```\nconst ensureLoggedIn = require('connect-ensure-login').ensureLoggedIn();\nconst Auth0Client = require('../Auth0Client');\nconst express = require('express');\nconst router = express.Router();\n...\nrouter.post('/unlink-accounts/:targetUserProvider/:targetUserId',ensureLoggedIn, (req,res,next) => {\n  Auth0Client.unlinkAccounts(req.user.id, req.params.targetUserProvider, req.params.targetUserId)\n  .then( identities => {\n    req.user.identities = req.user._json.identities = identities;\n    res.send(identities);\n  })\n  .catch( err => {\n    console.log('Error unlinking accounts!',err);\n    next(err);\n  });\n});\n```\n\n1.  Call the Management API v2 [Unlink a User Account endpoint](https://auth0.com/docs/api/v2#!/Users/delete_user_identity_by_user_id) using an [Management API Access Token](https://auth0.com/docs/api/v2/tokens) with the `update:users` scope.\n    \n\n```\nconst request = require('request');\n\nclass Auth0Client {\n  ...\n  unlinkAccounts(rootUserId, targetUserProvider, targetUserId){\n    return new Promise((resolve,reject) => {\n      var reqOpts = {\n        method: 'DELETE',\n        url: 'https://{yourDomain}/api/v2/users/' + rootUserId +\n            '/identities/' + targetUserProvider + '/' + targetUserId,\n        headers: {\n          'Authorization': 'Bearer ' + process.env.AUTH0_APIV2_TOKEN\n        }\n      };\n      request(reqOpts,(error, response, body) => {\n        if (error) {\n          return reject(error);\n        } else if (response.statusCode !== 200) {\n          return reject('Error unlinking accounts. Status: '+ response.statusCode + ' ' + JSON.stringify(body));\n        } else {\n          resolve(JSON.parse(body));\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = new Auth0Client();\n```\n\n## Learn more\n\n*   [Link User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts)\n*   [User Account Linking: Server-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)\n*   [User-Initiated Account Linking: Client-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation)",
  "title": "Unlink User Accounts",
  "description": "Learn how to use the Management API Unlink a User Account endpoint to unlink an identity from the target user account making it a separate user account again.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications",
  "markdown": "# User Consent and Third-Party Applications\n\nThe [OIDC](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)\\-conformant authentication pipeline supports defining resource servers (such as APIs) as entities separate from applications. This lets you decouple APIs from the applications that consume them, and also lets you define [third-party applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications) that allow external parties to securely access protected resources behind your API.\n\n## Consent dialog\n\nIf a user authenticates through a third-party application and the application requests authorization to access the user's information or perform some action at an API on their behalf, the user will see a consent dialog.\n\nFor example, this request:\n\n```\nGET /authorize?\nclient_id=some_third_party_client\n&redirect_uri=https://fabrikam.com/contoso_social\n&response_type=token id_token\n&__scope=openid profile email read:posts write:posts__\n&__audience=https://social.contoso.com__\n&nonce=...\n&state=...\n```\n\nWill result in this user consent dialog:\n\n![Authorization - User consent and applications - consent-dialog](https://images.ctfassets.net/cdy7uua7fh8z/5Cz3aZKw8RRVlMkc5Zl6x7/78043c2e1ced8f56378b6f48884a7bd4/consent-dialog.png)\n\nIf the user allows the application's request, this creates a user grant, which represents the user's consent to this combination of application, resource server, and requested scopes. The application then receives a successful authentication response from Auth0 as usual.\n\nOnce consent has been given, the user won't see the consent dialog during subsequent logins until consent is revoked explicitly.\n\n## Scope descriptions\n\nBy default, the consent page will use the scopes' names to prompt for the user's consent. As shown below, you should define scopes using the **action:resource\\_name** format.\n\n![Authorization - User consent and applications - Consent scopes](https://images.ctfassets.net/cdy7uua7fh8z/3Z4Ofbj5yF7eg5cLfcauh9/1978b8c99b06b847ba9ec591995b00de/consent-scopes.png)\n\nThe consent page groups scopes for the same resource and displays all actions for that resource in a single line. For example, the configuration above would result in **Posts: read and write your posts**.\n\nIf you would like to display the **Description** field instead, you can do so by setting the tenant's **use\\_scope\\_descriptions\\_for\\_consent** to **true**. This will affect consent prompts for all of the APIs on that tenant.\n\nTo set the **use\\_scope\\_descriptions\\_for\\_consent** flag, you will need to make the appropriate call to the API:\n\n*   [cURL](#33c1e0ed92a24f278c7824225fc25bc0_shell)\n*   [C#](#33c1e0ed92a24f278c7824225fc25bc0_csharp)\n*   [Go](#33c1e0ed92a24f278c7824225fc25bc0_go)\n*   [Java](#33c1e0ed92a24f278c7824225fc25bc0_java)\n*   [Node.JS](#33c1e0ed92a24f278c7824225fc25bc0_node)\n*   [Obj-C](#33c1e0ed92a24f278c7824225fc25bc0_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/tenants/settings' \\\n  --header 'authorization: Bearer API2_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"flags\": { \"use_scope_descriptions_for_consent\": true } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/tenants/settings\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer API2_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/tenants/settings\"\n\n\tpayload := strings.NewReader(\"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer API2_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/tenants/settings\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer API2_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/tenants/settings',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer API2_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {flags: {use_scope_descriptions_for_consent: true}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer API2_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"flags\": @{ @\"use_scope_descriptions_for_consent\": @YES } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/tenants/settings\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/tenants/settings\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer API2_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer API2_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/tenants/settings\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/tenants/settings\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer API2_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer API2_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"flags\": [\"use_scope_descriptions_for_consent\": true]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/tenants/settings\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Handle rejected permissions\n\nIf a user decides to reject consent to the application, they will be redirected to the `redirect_uri` specified in the request with an `access_denied` error:\n\n```\nHTTP/1.1 302 Found\nLocation: https://fabrikam.com/contoso_social#\n    error=access_denied\n    &state=...\n```\n\n## Skip consent for first-party applications\n\nFirst-party applications can skip the consent dialog, but only if the API they are trying to access on behalf of the user has the **Allow Skipping User Consent** option enabled.\n\n#### User consent and applications\n\nNote that this option only allows verifiable first-party applications to skip consent at the moment. As `localhost` is never a verifiable first-party (because any malicious application may run on `localhost` for a user), Auth0 will always display the consent dialog for applications running on `localhost` regardless of whether they are marked as first-party applications. During development, you can work around this by modifying your `/etc/hosts` file to add an entry such as the following:\n\n`127.0.0.1 myapp.example`\n\nSimilarly, you cannot skip consent (even for first-party applications) if `localhost` appears in any domain in the application's **Allowed Callback URLs** setting (found in [Dashboard > Applications > Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings)). Make sure to update **Allowed Callback URLs** and the callback URL you configured in your application to match the updated domain-mapping.\n\nSince third-party applications are assumed to be untrusted, they are not able to skip consent dialogs.\n\n## Revoke consent\n\nIf a user has provided consent but you would like to revoke it:\n\n1.  Go to [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users), and click the user for whom you would like to revoke consent.\n    \n2.  Click the **Authorized Applications** tab,\n    \n3.  Click **Revoke** next to the appropriate application.\n    \n\n## Password-based flows\n\nWhen using the [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow), no consent dialog is involved because the user directly provides their password to the application, which is equivalent to granting the application full access to the user's account.\n\n### Force users to provide consent\n\nWhen redirecting to the `/authorize` endpoint, including the `prompt=consent` parameter will force users to provide consent, even if they have an existing user grant for the application and requested scopes.\n\n### Customize the consent dialog\n\nThe consent dialog UI cannot be customized or set to a custom domain.\n\n## Learn more\n\n*   [First-Party and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications)\n*   [View Application Ownership](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/view-application-ownership)\n*   [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications)\n*   [Enable Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications)\n*   [Application Grant Types](https://auth0.com/docs/get-started/applications/application-grant-types)",
  "title": "User Consent and Third-Party Applications",
  "description": "Learn how to decouple APIs from applications that consume them and define third-party apps that you don't control or may not trust.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/protocols/oauth2/oauth-state",
  "markdown": "# Prevent Attacks and Redirect Users with OAuth 2.0 State Parameters\n\nAuthorization protocols provide a `state` parameter that allows you to restore the previous state of your application. The `state` parameter preserves some state objects set by the client in the Authorization request and makes it available to the client in the response.\n\n## CSRF attacks\n\nThe primary reason for using the `state` parameter is to mitigate [CSRF attacks](https://en.wikipedia.org/wiki/Cross-site_request_forgery) by using a unique and non-guessable value associated with each authentication request about to be initiated. That value allows you to prevent the attack by confirming that the value coming from the response matches the one you sent.\n\nThe `state` parameter is a string so you can encode any other information in it. You send a random value when starting an authentication request and validate the received value when processing the response. You store something on the client application side (in cookies, session, or localstorage) that allows you to perform the validation. If you receive a response with a state that doesn't match, you can infer that you may be the target of an attack because this is either a response for an unsolicited request or someone trying to forge the response.\n\nA CSRF attack specifically targets state-changing requests to initiate an action instead of getting user data because the attacker has no way to see the response to the forged request. For the most basic cases the state parameter should be a nonce, used to correlate the request with the response received from the authentication.\n\nMost modern OIDC and OAuth SDKs, including Auth0.js in single-page applications, handle the state generation and validation automatically.\n\n### Set and compare state parameter values\n\n1.  Before redirecting a request to the Identity Provider (IdP), have the app generate a random string. For example:\n    \n    The allowed length for state is not unlimited. If you get the error `414 Request-URI Too Large`, try a smaller value.\n2.  Store the string locally. For example:\n    \n    ```\n    storeStateLocally(xyzABC123)\n    ```\n    \n3.  Add the `state` parameter to the request (URL-encoding if necessary). For example:\n    \n    ```\n    // Encode the String   \n    tenant.auth0.com/authorize?...&state=xyzABC123\n    ```\n    \n    After the request is sent, the user is redirected back to the application by Auth0. The `state` value will be included in this redirect. Note that depending on the type of connection used, this value might be in the body of the request or in the query string.\n    \n    ```\n    /callback?...&state=xyzABC123\n    ```\n    \n4.  Retrieve the returned `state` value and compare it with the one you stored earlier. If the values match, then approve the authentication response, else deny it.\n    \n    ```\n    // Decode the String\n    var decodedString = Base64.decode(encodedString);\n    if(receivedState === retrieveStateStoredLocally()) {\n     // Authorized request\n    } \n    else {\n      // This response is not for us, reject it\n    }\n    ```\n    \n\n## Redirect users\n\nYou can use the `state` parameter to encode an application state that will put the user where they were before the authentication process started. For example, if a user intends to access a protected page in your application, and that action triggers the request to authenticate, you can store that URL to redirect the user back to their intended page after the authentication finishes.\n\nGenerate and store a nonce locally (in cookies, session, or local storage) along with any desired state data like the redirect URL. Use the nonce as a state in the protocol message. If the returned state matches the stored nonce, accept the OAuth2 message and fetch the corresponding state data from storage. This is the approach we use in auth0.js.\n\n### Use the stored URL to redirect users\n\n1.  Set the nonce state parameter value that you used to mitigate CSRF attacks as explained above.\n    \n2.  Store the nonce locally, using it as the key to store all the other application state information such as the URL where the user intended to go. For example:\n    \n    ```\n    {\n      \"xyzABC123\" : {\n        redirectUrl: '/protectedResource',\n        expiresOn: [...]\n      }\n    }\n    ```\n    \n3.  Authenticate the user, [sending the generated nonce as the state](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow).\n    \n4.  As part of the callback processing and response validation, verify that the state returned matches the nonce stored locally. If it does, retrieve the rest of the application state (like the `redirectUrl`).\n    \n5.  Once you complete the callback processing, redirect the user to the URL previously stored.\n    \n\n### Alternate redirect method\n\n1.  Generate and store a nonce value locally.\n    \n2.  Encode any desired state (like the redirect URL) along with the nonce in a protected message (that will need to be encrypted/signed to avoid tampering).\n    \n3.  In the response processing, unprotect the message, getting the nonce and other properties stored.\n    \n4.  Validate that the included nonce matches what was stored locally and, if so, accept the OAuth2 message.\n    \n\n## Limitations and considerations\n\n*   Choose a storage method based on your application type.\n    \n    | App Type | Storage Recommendation |\n    | --- | --- |\n    | Regular Web App | Cookie or session |\n    | SPA | Local browser |\n    | Native App | Memory or local |\n    \n*   From a security perspective, neither the request nor the response is integrity-protected so a user can manipulate them. That is true for adding a parameter to the `redirect_uri` as well.\n    \n*   The allowed length for state parameter value is not unlimited. If you get the error `414 Request-URI Too Large`, try a smaller value.\n    \n*   Passing URLs in plaintext or in any predictable way is unsafe. Ensure that the state parameter value is:\n    \n    *   Unique and opaque to ensure that it can be used for defense against CSRF and phishing attacks.\n        \n    *   If stored in a cookie, it should be signed to prevent forgery.\n        \n\n## Learn more\n\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)\n*   [Sessions](https://auth0.com/docs/manage-users/sessions)",
  "title": "Prevent Attacks and Redirect Users with OAuth 2.0 State Parameters",
  "description": "Describes how to use the state parameter in authentication requests to help prevent CSRF attacks and restore state",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/tokens/delegation",
  "markdown": "# Delegation Tokens\n\nA delegation token should be obtained and used when an application needs to call the API of an Application Add-on, such as Firebase or SAP, registered and configured in Auth0, in the same tenant as the calling program.\n\nGiven an existing token, this endpoint will generate a new token signed with the `target` application's secret. This is used to flow the identity of the user from the application to an API.\n\nThe type of the delegation token varies depending on the provider. For example, if it is issued for Azure Blob Storage, it will be an SAS (Shared Access Signature). If it is for the Firebase Add-on, it will be a JWT.\n\nThe ID token for an authenticated user can be used with the `/delegation` endpoint to request a delegation token for a particular target. The target can be an application Add-on configured in Auth0. The Add-ons for which this can be done are those that are not SAML or WS-Fed Add-ons. The Add-on must be configured in Auth0 with secrets obtained from the Add-on service, such as Firebase. Instructions for setting up the secrets are available from the Add-on configuration page for each Add-on. The secrets are used to sign the delegation token so that the Add-on API can validate and trust the token.\n\nThe delegation endpoint allows you to set several parameters which govern the contents of the delegation token including the `target`, the `scope`, the API to be called (`api_type`), and an additional free-form area for additional parameters.\n\n## Auth0.js example\n\nFor an example on how to get a new token for an Add-on that you have activated, using **Auth0.js**, refer to Delegation Token Request. Note that this example is for **version 7** of the **Auth0.js** library; delegation is **not supported** in version 8 of **Auth0.js**.\n\n## Validity period and termination\n\nThe validity period and the ability to revoke a delegation token, varies by individual Add-on. The documentation available from the provider of any Add-on API should be consulted for further information.\n\n## Use Delegation tokens with public applications\n\nThere is an important caveat to note when using the delegation endpoint with Public Applications.\n\nIf you call the `/token` endpoint from a Public Application, the ID Token will be forcibly signed using `RS256`, even if the JsonWebToken Signature Algorithm in the Application settings is configured as `HS256`.\n\nIf you then subsequently call the delegation endpoint with that ID Token, it will fail if the Application's JsonWebToken Signature Algorithm was configured as `HS256`. This is because delegation performs validation according to the Application's settings, but the ID Token was issued with a different algorithm because of the forced algorithm change.\n\nIt is therefore important that if you intend to use delegation with a Public Application, that you configure the JsonWebToken Signature Algorithm of your application as `RS256`.",
  "title": "Delegation Tokens",
  "description": "Describes how Auth0 delegation tokens work in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications",
  "markdown": "# Enable Third-Party Applications\n\nYou can enable third-party applications for your tenant. See [First-Party and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications) for details on the differences between the two types of applications.\n\n1.  [Update your application's ownership to third-party](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/update-application-ownership) in Auth0.\n    \n    By default, applications registered in Auth0 are first-party applications. If you want your application to be a third-party application, you must update its ownership.\n    \n2.  [Promote the connections you will use with third-party applications to domain level](https://auth0.com/docs/authenticate/identity-providers/promote-connections-to-domain-level) in Auth0.\n    \n    Third-party applications can only authenticate users from [connections](https://auth0.com/docs/connections) flagged as domain-level connections. Domain-level connections can be enabled for selected first-party applications while also being open to all third-party application users for authentication.\n    \n3.  Update your application's login page. If you use [Lock](https://auth0.com/docs/libraries/lock/v11) in the [Universal Login Page](https://auth0.com/docs/universal-login/classic), you must also:\n    \n    1.  Upgrade to Lock version 11 or later.\n        \n    2.  Set the `__useTenantInfo: config.isThirdPartyClient` flag when instantiating Lock.\n        \n    3.  For Private Cloud users only: Set the [`configurationBaseUrl` option](https://auth0.com/docs/libraries/lock/v11/configuration#configurationbaseurl-string-) to `https://{config.auth0Domain}/` when instantiating Lock.\n        \n\n## Access token current\\_user\\_\\* scopes\n\nNeither first- nor third-party applications can use ID tokens to invoke Management API endpoints. Instead, they should get access tokens with the following `current_user_*` scopes required by each endpoint:\n\n| Scope | Endpoint |\n| --- | --- |\n| `read:current_user` | List or search users |\n|     | Get a user |\n|     | Get user MFA enrollments |\n| `update:current_user_metadata` | Update a user |\n|     | Delete a user's multi-factor provider |\n| `create:current_user_device_credentials` | Create a device public key |\n| `delete:current_user_device_credentials` | Delete a device credential |\n| `update:current_user_identities` | Link a user account |\n|     | Unlink a user identity |\n\n## Script example\n\n```\n<script src=\"https://cdn.auth0.com/js/lock/11.x.y/lock.min.js\"></script>\n...\n<script>\n  // Decode utf8 characters properly\n  var config = JSON.parse(decodeURIComponent(escape(window.atob('@@config@@'))));\n\n  var connection = config.connection;\n  var prompt = config.prompt;\n  var languageDictionary;\n  var language;\n  if (config.dict && config.dict.signin && config.dict.signin.title) {\n    languageDictionary = { title: config.dict.signin.title };\n  } else if (typeof config.dict === 'string') {\n    language = config.dict;\n  }\n\n  var lock = new Auth0Lock(config.clientID, config.auth0Domain, {\n    auth: {\n      redirectUrl: config.callbackURL,\n      responseType: config.callbackOnLocationHash ? 'token' : 'code',\n      params: config.internalOptions\n    },\n    assetsUrl:  config.assetsUrl,\n    allowedConnections: connection ? [connection] : null,\n    configurationBaseUrl: 'https://' + config.auth0Domain + '/', // for PSaaS only\n    rememberLastLogin: !prompt,\n    language: language,\n    languageDictionary: languageDictionary,\n    closable: false,\n    __useTenantInfo: config.isThirdPartyClient // required for all Tenants\n  });\n\n  lock.show();\n</script>\n```\n\n## Learn more\n\n*   [First-Party and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications)\n*   [User Consent and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications)\n*   [Promote Connections to Domain Level](https://auth0.com/docs/authenticate/identity-providers/promote-connections-to-domain-level)",
  "title": "Enable Third-Party Applications",
  "description": "Describes how to enable third-party applications for your tenant.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/user-account-linking",
  "markdown": "# User Account Linking\n\nAuth0 supports the linking of user accounts from various identity providers. This allows a user to authenticate from any of their accounts and still be recognized by your app and associated with the same user profile.\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nAuth0 treats all identities as separate by default. For example, if a user logs in first against the Auth0 database and then via Google or Facebook, these two attempts would appear to Auth0 as two separate users. You can implement functionality to enable a user to explicitly link accounts. In this scenario, the user would log in with an initial provider, perhaps Google. Your application would provide a link or button to enable them to link another account to the first one. The user would click on this link/button and your application would make a call so that when the user logs in with the second provider, the second account is linked with the first.\n\n## Advantages of linking accounts\n\n*   Allows users to log in with any identity provider without creating a separate profile for each\n    \n*   Allows registered users to use a new social or passwordless login but continue using their existing profile\n    \n*   Allows users that registered using a passwordless login to link to an account with a more complete profile\n    \n*   Allows your apps to retrieve user profile data stored in various connections\n    \n\n## Precautions\n\nInsecurely linking accounts can allow malicious actors to access legitimate user accounts. Please remain aware of the following:\n\nFor both manual and automatic account links, your tenant should request authentication for **both** accounts before linking occurs.\n\nIn addition, **every** manual account link should prompt the user to enter credentials.\n\n## How it works\n\nThe process of linking accounts merges two existing user profiles into a single one. When linking accounts, a **primary account** and a **secondary account** must be specified.\n\nIn the example below you can see how the resulting linked profile will be for the sample primary and secondary accounts.\n\n*   [Profile of primary account](#profile-primary)\n*   [Profile of secondary account](#profile-secondary)\n*   [Linked profile](#profile-linked)\n\n```\n{\n  \"email\": \"your0@email.com\",\n  \"email_verified\": true,\n  \"name\": \"John Doe\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n  \"picture\": \"https://lh3.googleusercontent..../photo.jpg\",\n  \"gender\": \"male\",\n  \"locale\": \"en\",\n  \"user_id\": \"google-oauth2|115015401343387192604\",\n  \"identities\": [\n    {\n      \"provider\": \"google-oauth2\",\n      \"user_id\": \"115015401343387192604\",\n      \"connection\": \"google-oauth2\",\n      \"isSocial\": true\n    }\n  ],\n  \"user_metadata\": {\n    \"color\": \"red\"\n  },\n  \"app_metadata\": {\n    \"roles\": [\n      \"Admin\"\n    ]\n  },\n  ...\n}\n```\n\n```\n{\n  \"phone_number\": \"+14258831929\",\n  \"phone_verified\": true,\n  \"name\": \"+14258831929\",\n  \"updated_at\": \"2015-10-08T18:35:18.102Z\",\n  \"user_id\": \"sms|560ebaeef609ee1adaa7c551\",\n  \"identities\": [\n    {\n      \"user_id\": \"560ebaeef609ee1adaa7c551\",\n      \"provider\": \"sms\",\n      \"connection\": \"sms\",\n      \"isSocial\": false\n    }\n  ],\n  \"user_metadata\": {\n    \"color\": \"blue\"\n  },\n  \"app_metadata\": {\n    \"roles\": [\n      \"AppAdmin\"\n    ]\n  },\n  ...\n}\n```\n\n```\n{\n  \"email\": \"your0@email.com\",\n  \"email_verified\": true,\n  \"name\": \"John Doe\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n  \"picture\": \"https://lh3.googleusercontent..../photo.jpg\",\n  \"gender\": \"male\",\n  \"locale\": \"en\",\n  \"user_id\": \"google-oauth2|115015401343387192604\",\n  \"identities\": [\n    {\n      \"provider\": \"google-oauth2\",\n      \"user_id\": \"115015401343387192604\",\n      \"connection\": \"google-oauth2\",\n      \"isSocial\": true\n    },\n    {\n      \"profileData\": {\n        \"phone_number\": \"+14258831929\",\n        \"phone_verified\": true,\n        \"name\": \"+14258831929\"\n      },\n      \"user_id\": \"560ebaeef609ee1adaa7c551\",\n      \"provider\": \"sms\",\n      \"connection\": \"sms\",\n      \"isSocial\": false\n    }\n  ],\n  \"user_metadata\": {\n    \"color\": \"red\"\n  },\n  \"app_metadata\": {\n    \"roles\": [\n      \"Admin\"\n    ]\n  },\n  ...\n}\n```\n\nNote that:\n\n*   The `user_id` and all other main profile properties continue to be those of the primary identity\n    \n*   The first identity in the `user.identities` array is the primary identity\n    \n*   The secondary account is now embedded in the `user.identities` array of the primary profile\n    \n*   The attributes of the secondary account are placed inside the `profileData` field of the corresponding identity inside the array\n    \n*   The `user_metadata` and `app_metadata` of the primary account have not changed\n    \n*   The `user_metadata` and `app_metadata` of the secondary account are discarded\n    \n*   There is no automatic merging of user profiles with associated identities\n    \n*   The secondary account is removed from the users list\n    \n*   If you delete the primary account, the secondary account is deleted as well\n    \n\n### Metadata merge\n\nMetadata is not automatically merged during account linking. If you want to merge it, you have to do it manually using the Manage API [`/users/patch_users_by_id`](https://auth0.com/docs/api/v2#!/Users/patch_users_by_id) endpoint.\n\nThe [Auth0 Node.js SDK for APIv2](https://github.com/auth0/node-auth0/) is also available.\n\nTo learn more, read [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata)\n\n## Scenarios\n\nThere are two different ways of implementing account linking:\n\n*   User-initiated account linking: allow your users to link their accounts using an admin screen in your app.\n    \n*   Suggested account linking: identify accounts with the same email address and prompt the user in your app to link them.\n    \n\n### User-initiated account linking\n\nTypically, account linking will be initiated by an authenticated user. Your app must provide the UI, such as a **Link accounts** button on the user's profile page.\n\nTo learn more about how to implement user-initiated account linking in a Single Page Application, read [Client-Side Account Linking](https://auth0.com/docs/users/references/link-accounts-client-side-scenario). To learn more about how to implement user-initiated account linking in a Regular Web Application, read [Server-Side Account Linking](https://auth0.com/docs/users/references/link-accounts-server-side-scenario).\n\n### Suggested account linking\n\nYou can find accounts with the same email, and prompt the users to link them. For example, a user can create an account with Google with the user@gmail.com, and then log in with Facebook, with an account linked to the same email.\n\nIf that occurs, you can show users the list of available accounts so they can link them, by first authenticating with the account they will be linking to.\n\nYou can also use the [Account Link Extension](https://auth0.com/docs/extensions/account-link) to achieve the same outcome.\n\n## Learn more\n\n*   [Link User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts)\n*   [Unlink User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/unlink-user-accounts)\n*   [User-Initiated Account Linking: Client-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation)\n*   [User Account Linking: Server-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)",
  "title": "User Account Linking",
  "description": "Understand how user accounts can be linked in Auth0 from various identity providers.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/authentication-issues/renew-tokens-when-using-safari",
  "markdown": "# Troubleshoot Renew Tokens When Using Safari\n\nIn some cases, renewing tokens with silent authentication does not work as expected with the latest version of the Safari browser. Recent versions of the Safari browser introduced a new feature called [Intelligent Tracking Prevention (ITP)](https://webkit.org/blog/category/privacy/). ITP is designed to prevent websites from tracking user activity across multiple websites. By default, ITP is active. You can determine if the Safari version you are using has ITP by going to the **Preferences > Privacy** tab and seeing if the **Prevent cross-site tracking** option is checked.\n\n![Authorization - Renew tokens when using Safari - Safari privacy preferences](https://images.ctfassets.net/cdy7uua7fh8z/2P2xm1fIcKtXcS32zqu4FV/dcf41df330ede20ef5c2df4753d35251/safari-privacy-preferences.png)\n\n## ITP and browser behavior\n\nEnabling ITP causes the browser to behave as if you had disabled third-party cookies in the browser, which makes it impossible to obtain a new token without displaying anything to the user. This is akin to the way OpenID Connect (OIDC) uses iframes for handling [sessions](https://auth0.com/docs/manage-users/sessions) in SPAs.\n\nIn the SPA SDK (which is our recommendation) `getTokenSilently` performs [silent authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication) unless you configure the SDK to use rotating refresh tokens.\n\n## Workarounds\n\nRecent advancements in user privacy controls in browsers adversely impact the user experience by preventing access to third-party cookies. You can use [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation) as an alternative that provides a secure method for using refresh tokens in SPAs while providing end-users with seamless access to resources without the disruption in UX caused by browser privacy technology like ITP.\n\nAlternatively, you can work around the issues posed by ITP by using Auth0's [custom domains](https://auth0.com/docs/customize/custom-domains) functionality, particularly if the custom domain lives on a subdomain of the application's website domain. For example, if your application is hosted on **example.com**, the custom domain would need to be of the format **subdomain.example.com**.\n\n## ITP debug mode\n\n[Safari Technology Preview](https://developer.apple.com/safari/technology-preview/) offers an \"Intelligent Tracking Prevention Debug Mode\" that you can use to troubleshoot ITP issues. You can find instructions on how to debug ITP in [this blog post from WebKit](https://webkit.org/blog/8387/itp-debug-mode-in-safari-technology-preview-62/).\n\n**NOTE**: The instructions mention how to permanently classify a custom domain as having tracking abilities for testing purposes. In later versions of Safari Technology Preview, though, the domain to store the User Defaults for this setting changed from `com.apple.SafariTechnologyPreview` to `com.apple.WebKit.Networking`. If you are having trouble with the commands mentioned in the instructions, try these:\n\n*   Classify a site as having tracking abilities: `defaults write com.apple.WebKit.Networking ResourceLoadStatisticsManualPrevalentResource example.com`\n    \n*   Inspect the setting: `defaults read com.apple.WebKit.Networking ResourceLoadStatisticsManualPrevalentResource`\n    \n*   Delete the setting: `defaults delete com.apple.WebKit.Networking ResourceLoadStatisticsManualPrevalentResource`\n    \n\nYou will need to restart Safari Technology Preview every time you make changes for the settings to take effect.",
  "title": "Troubleshoot Renew Tokens When Using Safari",
  "description": "Issues with token renewal in Safari when ITP is enabled.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/metadata",
  "markdown": "# Understand How Metadata Works in User Profiles\n\nAuth0 provides a comprehensive system for storing metadata in the Auth0 user profile. You can use metadata to do the following activities:\n\n*   Store application-specific data in the user profile.\n    \n*   Record whether or not specific operations have occurred for a user.\n    \n*   Cache the results of expensive operations on the user profile so they can be re-used in future logins.\n    \n*   Store information that does not originate from an identity provider or that overrides what an identity provider supplies.\n    \n\nThe metadata can be modified as part of a user’s login flow.\n\nYou can configure connection sync so that user root attributes are updated by the identity provider only on user profile creation. You can then edit root attributes individually or by bulk import. To learn more, read [Configure Identify Provider Connection for User Profiles Updates](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0).\n\n## Metadata types\n\nAuth0 uses three types of metadata to store specific kinds of information.\n\n| **Metadata Type** | **Field Name** | **Description** |\n| --- | --- | --- |\n| **User Information** | `user_metadata` | Stores user attributes such as preferences that do not impact a user's core functionality. This data **can** be edited by logged in users if you build a form using the Management API and should **not** be used as a secure data store. |\n| **Access Information** | `app_metadata` | Stores information such as permissions, Auth0 plan, and external IDs that can impact user access to features. This data **cannot** be edited by users and there are restrictions for what can be stored in this field. |\n| **Application Information** | `client_metadata` in the `Client` object, `context.clientMetadata` in Rules, and `event.client.metadata` in post-login Actions. | Stores information about an application (or _client_ in OIDC OAuth2 terminology). For example, the URL for the application home page (any value that Auth0 doesn’t set in the application settings). |\n\n## Manage metadata\n\nYou can create and update metadata using Rules, the Authentication API, the Management API, the Auth0 Dashboard, and the Lock library.\n\nIt is not recommended that `app_metadata` or `user_metadata` be returned by\n\n*   custom DB scripts\n    \n*   the `fetchUserProfile` script of custom social connections\n    \n\n### Use Actions\n\n[Actions](https://auth0.com/docs/customize/actions) are secure, tenant-specific, versioned functions written in Node.js that execute at certain points within the Auth0 platform. Actions are used to customize and extend Auth0's capabilities with custom logic.\n\nTo learn more, read [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata).\n\n### Use the Management API\n\nA user can request an access token with the appropriate scopes and use the following [Management API](https://auth0.com/docs/api/management/v2) endpoints to view, create, or update `user_metadata`, or remove an MFA configuration.\n\nAn access token is required to call the Auth0 Management API. To learn more, read [Access Tokens for the Management API](https://auth0.com/docs/api/management/v2/tokens) and [Get Management API Tokens for SPAs](https://auth0.com/docs/api/management/v2/get-access-tokens-for-spas).\n\n### Use the Dashboard\n\nUse the Auth0 Dashboard to configure application metadata which contains key/value pairs. To learn more, read [Configure Application Metadata](https://auth0.com/docs/get-started/applications/configure-application-metadata).\n\n### Use the Lock library\n\nUse the [Lock](https://auth0.com/docs/libraries/lock) library to define, add, read, and update `user_metadata.` Read `user_metadata` properties the same way you would read any other user profile property. For example, the following code snippet retrieves the value associated with `user_metadata.hobby` and assigns it to an element on the page:\n\n```\n// Use the accessToken acquired upon authentication to call getUserInfo\nlock.getUserInfo(accessToken, function(error, profile) {\n  if (!error) {\n    document.getElementById('hobby').textContent = profile.user_metadata.hobby;\n  }\n});\n```\n\nYou can use `additionalSignUpFields` to add custom fields to user sign-up forms. When a user adds data in a custom field, Auth0 stores entered values in that user's `user_metadata`. To learn more about adding `user_metadata` on signup, read [Additional Signup Fields](https://auth0.com/docs/libraries/lock/v10/customization#additionalsignupfields-array-).\n\n## Custom database connections and metadata\n\nIf you have a [custom database connection](https://auth0.com/docs/connections/database#using-your-own-user-store), you can use the Authentication API [`/dbconnections/signup`](https://auth0.com/docs/api/authentication?shell#signup) endpoint to set the `user_metadata` for a user. To learn more about working with metadata during a custom signup process, read [Custom Signup](https://auth0.com/docs/libraries/custom-signup).\n\nWhen you set the `user_metadata` field using the Authentication API `/dbconnections/signup` endpoint, you are limited to a maximum of 10 string fields and 500 characters.\n\n## Custom emails and metadata\n\nUse metadata to store information that you want to use to customize Auth0 emails. For example, use `user_metadata.lang` if you want the user to be able to change the field's value, then use the information to customize the language for an email. To learn more, read [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\nIf you are having issues with Lock, review [Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors). If you are having issues with the Management API, review [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n\n## Learn more\n\n*   [Metadata Field Names and Data Types](https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data)\n*   [Manage Metadata with Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules)\n*   [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api)\n*   [Manage Metadata with Lock](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-lock)\n*   [Configure Application Metadata](https://auth0.com/docs/get-started/applications/configure-application-metadata)\n*   [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata)",
  "title": "Understand How Metadata Works in User Profiles",
  "description": "Describes Auth0 user, application, and client metadata. Learn how you can use metadata to store information that does not originate from an identity provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/users/concepts/overview-user-metadata",
  "markdown": "# Understand How Metadata Works in User Profiles\n\nAuth0 provides a comprehensive system for storing metadata in the Auth0 user profile. You can use metadata to do the following activities:\n\n*   Store application-specific data in the user profile.\n    \n*   Record whether or not specific operations have occurred for a user.\n    \n*   Cache the results of expensive operations on the user profile so they can be re-used in future logins.\n    \n*   Store information that does not originate from an identity provider or that overrides what an identity provider supplies.\n    \n\nThe metadata can be modified as part of a user’s login flow.\n\nYou can configure connection sync so that user root attributes are updated by the identity provider only on user profile creation. You can then edit root attributes individually or by bulk import. To learn more, read [Configure Identify Provider Connection for User Profiles Updates](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0).\n\n## Metadata types\n\nAuth0 uses three types of metadata to store specific kinds of information.\n\n| **Metadata Type** | **Field Name** | **Description** |\n| --- | --- | --- |\n| **User Information** | `user_metadata` | Stores user attributes such as preferences that do not impact a user's core functionality. This data **can** be edited by logged in users if you build a form using the Management API and should **not** be used as a secure data store. |\n| **Access Information** | `app_metadata` | Stores information such as permissions, Auth0 plan, and external IDs that can impact user access to features. This data **cannot** be edited by users and there are restrictions for what can be stored in this field. |\n| **Application Information** | `client_metadata` in the `Client` object, `context.clientMetadata` in Rules, and `event.client.metadata` in post-login Actions. | Stores information about an application (or _client_ in OIDC OAuth2 terminology). For example, the URL for the application home page (any value that Auth0 doesn’t set in the application settings). |\n\n## Manage metadata\n\nYou can create and update metadata using Rules, the Authentication API, the Management API, the Auth0 Dashboard, and the Lock library.\n\nIt is not recommended that `app_metadata` or `user_metadata` be returned by\n\n*   custom DB scripts\n    \n*   the `fetchUserProfile` script of custom social connections\n    \n\n### Use Actions\n\n[Actions](https://auth0.com/docs/customize/actions) are secure, tenant-specific, versioned functions written in Node.js that execute at certain points within the Auth0 platform. Actions are used to customize and extend Auth0's capabilities with custom logic.\n\nTo learn more, read [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata).\n\n### Use the Management API\n\nA user can request an access token with the appropriate scopes and use the following [Management API](https://auth0.com/docs/api/management/v2) endpoints to view, create, or update `user_metadata`, or remove an MFA configuration.\n\nAn access token is required to call the Auth0 Management API. To learn more, read [Access Tokens for the Management API](https://auth0.com/docs/api/management/v2/tokens) and [Get Management API Tokens for SPAs](https://auth0.com/docs/api/management/v2/get-access-tokens-for-spas).\n\n### Use the Dashboard\n\nUse the Auth0 Dashboard to configure application metadata which contains key/value pairs. To learn more, read [Configure Application Metadata](https://auth0.com/docs/get-started/applications/configure-application-metadata).\n\n### Use the Lock library\n\nUse the [Lock](https://auth0.com/docs/libraries/lock) library to define, add, read, and update `user_metadata.` Read `user_metadata` properties the same way you would read any other user profile property. For example, the following code snippet retrieves the value associated with `user_metadata.hobby` and assigns it to an element on the page:\n\n```\n// Use the accessToken acquired upon authentication to call getUserInfo\nlock.getUserInfo(accessToken, function(error, profile) {\n  if (!error) {\n    document.getElementById('hobby').textContent = profile.user_metadata.hobby;\n  }\n});\n```\n\nYou can use `additionalSignUpFields` to add custom fields to user sign-up forms. When a user adds data in a custom field, Auth0 stores entered values in that user's `user_metadata`. To learn more about adding `user_metadata` on signup, read [Additional Signup Fields](https://auth0.com/docs/libraries/lock/v10/customization#additionalsignupfields-array-).\n\n## Custom database connections and metadata\n\nIf you have a [custom database connection](https://auth0.com/docs/connections/database#using-your-own-user-store), you can use the Authentication API [`/dbconnections/signup`](https://auth0.com/docs/api/authentication?shell#signup) endpoint to set the `user_metadata` for a user. To learn more about working with metadata during a custom signup process, read [Custom Signup](https://auth0.com/docs/libraries/custom-signup).\n\nWhen you set the `user_metadata` field using the Authentication API `/dbconnections/signup` endpoint, you are limited to a maximum of 10 string fields and 500 characters.\n\n## Custom emails and metadata\n\nUse metadata to store information that you want to use to customize Auth0 emails. For example, use `user_metadata.lang` if you want the user to be able to change the field's value, then use the information to customize the language for an email. To learn more, read [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\nIf you are having issues with Lock, review [Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors). If you are having issues with the Management API, review [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n\n## Learn more\n\n*   [Metadata Field Names and Data Types](https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data)\n*   [Manage Metadata with Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules)\n*   [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api)\n*   [Manage Metadata with Lock](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-lock)\n*   [Configure Application Metadata](https://auth0.com/docs/get-started/applications/configure-application-metadata)\n*   [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata)",
  "title": "Understand How Metadata Works in User Profiles",
  "description": "Describes Auth0 user, application, and client metadata. Learn how you can use metadata to store information that does not originate from an identity provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/organizations/invite-members",
  "markdown": "# Invite Organization Members\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nIf you would like to assign a member to an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview), but the user does not yet exist in your data store (or the user exists in your data store but is not yet a member of your organization), you can invite them to the organization. In this case, the user will receive an email containing a link that will allow them to create an account or log in and join the organization, optionally with predefined roles, and be redirected to your application so that they can immediately start using it.\n\nTo configure the invitation flow:\n\n1.  [Integrate the membership invitation flow into your application](#integrate-the-membership-invitation-flow-into-your-application)\n    \n2.  [Customize the user invitation flow](#customize-the-user-invitation-flow)\n    \n3.  [Send membership invitations](#send-membership-invitations)\n    \n\n## Integrate the membership invitation flow into your application\n\nFor user invitations to work, you must set up a route in your application as part of the invitation acceptance flow and [configure an associated default login route](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes) for your tenant or application. A link to the configured URI will be included in the email invitation that is sent to users.\n\n### Configure the URI\n\nIf the URI should be shared across all of your applications, you can set the **Tenant Login URL** at [Auth0 Dashboard > Settings > Advanced](https://manage.auth0.com/#/tenant/advanced). Otherwise, you can set the URI on a per-application basis by using **Application Login URI** in your application's settings, which you can reach from [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n\n### Specify route behavior\n\nThe route in your application must accept the `invitation` and `organization` parameters in the query string, and then call the Auth0 Authentication API [Authorization](https://auth0.com/docs/api/authentication#authorize-application) endpoint with both parameters.\n\nFor example, if you have an organization-enabled application with an **Application Login URI** set to `https://myapp.com/login`, then the link in the email invitation sent to the end user would be: `https://myapp.com/login?invitation={invitation_ticket_id}&organization={organization_id}&organization_name={organization_name}`.\n\n## Customize the user invitation flow\n\nTo customize the user invitation prompt and email that the user receives, modify the Universal Login prompt and email templates. To learn more, read these pages:\n\n*   [Universal Login Page Templates](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates)\n    \n*   [Universal Login Internationalization](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization)\n    \n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n    \n\n### Localization\n\nSince the locale of the invited user is not known ahead of time, you can send an optional `user_metadata` parameter to the invitation endpoint using the Management API. When localizing the user invitation flow, you can access this parameter through the **User Invitation** email template and [use the same logic as you would with other multilingual email templates](https://auth0.com/docs/customize/email/email-templates).\n\nFor the invited user to see the invitation in the appropriate language, your application will need to send the `ui_locales` parameter or the invited user's browser must send the appropriate `Accept-Language` header. To learn more, read [Customize Email Templates: Multilingual Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\n## Send membership invitations\n\nYou can [send organization membership invitations](https://auth0.com/docs/manage-users/organizations/configure-organizations/send-membership-invitations) to users using either the Auth0 Dashboard or the Management API. If you prefer to send the invitation using your own email service, you can choose to only generate an invitation URL. Otherwise, the user will receive an email containing the link, which will allow them to log in to the organization using a configured connection.",
  "title": "Invite Organization Members",
  "description": "Learn how to invite members to organizations via email.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/protocols/oidc",
  "markdown": "# OpenID Connect Protocol\n\n## What is OpenID Connect (OIDC)?\n\nOpenID Connect (OIDC) is an identity layer built on top of the OAuth 2.0 framework. It allows third-party applications to verify the identity of the end-user and to obtain basic user profile information. OIDC uses JSON web tokens (JWTs), which you can obtain using flows conforming to the OAuth 2.0 specifications. See our [OIDC Handbook](https://auth0.com/resources/ebooks/the-openid-connect-handbook) for more details.\n\n## OpenID vs. OAuth2\n\nWhile OAuth 2.0 is about resource access and sharing, OIDC is about user authentication. Its purpose is to give you one login for multiple sites. Each time you need to log in to a website using OIDC, you are redirected to your OpenID site where you log in, and then taken back to the website. For example, if you chose to sign in to Auth0 using your Google account then you used OIDC. Once you successfully authenticate with Google and authorize Auth0 to access your information, Google sends information back to Auth0 about the user and the authentication performed. This information is returned in a JWT. You'll receive an access token and if requested, an ID token.\n\n## OpenID and JWTs\n\nJWTs contain [claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims), which are statements (such as name or email address) about an entity (typically, the user) and additional metadata. The [OpenID Connect specification](https://openid.net/specs/openid-connect-core-1_0.html) defines a set of [standard claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). The set of standard claims include name, email, gender, birth date, and so on. However, if you want to capture information about a user and there currently isn't a standard claim that best reflects this piece of information, you can create custom claims and add them to your tokens.\n\n## Configure applications with OIDC and OAuth2\n\nYou can automatically [configure your applications with OIDC discovery](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery).\n\n## Learn more\n\n*   [Configure Applications with OIDC Discovery](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery)\n*   [Force Reauthentication in OIDC](https://auth0.com/docs/authenticate/login/max-age-reauthentication)\n*   [Applications in Auth0](https://auth0.com/docs/get-started/applications)\n*   [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on)\n*   [User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles)",
  "title": "OpenID Connect Protocol",
  "description": "Describes how to use OpenID Connect protocol with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/passwordless/best-practices",
  "markdown": "# Passwordless Connections Best Practices\n\n## Implement login\n\nYou can implement Passwordless authentication by redirecting to Auth0's Universal Login or by embedding login in your application. We always recommend that you implement Universal Login. To learn why, read [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login).\n\nTo learn how to implement Passwordless authentication, read the following articles:\n\n*   [Passwordless with Universal Login](https://auth0.com/docs/authenticate/passwordless/passwordless-with-universal-login)\n    \n*   [Passwordless Authentication with Universal Login](https://auth0.com/docs/authenticate/passwordless/implement-login/universal-login)\n    \n*   [Passwordless Authentication with Embedded Login](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login)\n    \n\n## Use SMS and email as authentication factors\n\nAuth0's passwordless implementation enables authenticating users with a single factor. That single factor can be one-time-use code sent by email or SMS, or a magic link sent by email.\n\nAlthough using email or SMS can be more secure than a weak password, both have known issues:\n\n*   Phone numbers are not sufficient for user authentication. The [SS7 phone routing system used by cellular networks has verified weaknesses](https://thehackernews.com/2017/05/ss7-vulnerability-bank-hacking.html) which have led to it not being recommended as an authentication factor. There are many attack vectors available, ranging from the use of social engineering, to swapping SIM cards and buying access to the SS7 network.\n    \n*   Email address possession is not sufficient for user authentication (aliases, forwarding, multiple users in one account are all examples). Email providers vary in their security practices and some do not require any establishment of a user's identity. SMTP is a very old protocol, and many providers still route SMTP traffic unencrypted leading to an increased chance of an interception attack.\n    \n\nFor these reasons, we recommend that if you use passwordless authentication, you also implement [Multi-factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) with a different factor when the user performs a security-sensitive operation.\n\n## Prevent phishing attacks\n\nAn example of what a possible phishing attack could look like is as follows:\n\n1.  The user clicks a link in a malicious email or website.\n    \n2.  The user lands on the attacker's fake site, where they are prompted to enter their phone number to authenticate.\n    \n3.  The user enters their phone number, and the attacker enters the same phone number in the legitimate application.\n    \n4.  The legitimate application sends an SMS to the user.\n    \n5.  The user types the one-time-use code in the attacker's website.\n    \n6.  The attacker can now log in to the legitimate website.\n    \n\nTo decrease the chances of success for this attack, the user should expect that the SMS clearly identifies the application. You should configure the SMS template so it mentions the tenant name and/or the Application Name:\n\n```\nYour verification code for accessing's Acme @@application.name@@ is @@code@@\n```\n\n## Prevent brute force attacks\n\nAuth0 has the following protections against brute force attacks:\n\n*   Only the most recent one-time-use code (or link) issued will be accepted. Once the latest one is issued, any others are invalidated. Once used, the latest one is also invalidated.\n    \n*   Only three failed attempts to input any single one-time-use code are allowed. After this, a new code will need to be requested.\n    \n*   The one-time-use code issued will be valid for three minutes (by default) before it expires.\n    \n*   If a passwordless user has been blocked [administratively](https://auth0.com/docs/manage-users/user-accounts/block-and-unblock-users), Auth0 will not send any OTP codes over SMS or email until the user is unblocked. This behavior protects your SMS and email providers from receiving unnecessary requests.\n    \n\nThe one-time-use code expiration time can be altered at [Auth0 Dashboard > Authentication > Passwordless](https://manage.auth0.com/#/connections/passwordless).\n\n## Prevent user enumeration attacks\n\nUser enumeration is when a malicious actor uses brute-force techniques to either guess or confirm valid users in a system.\n\nWhen **Disable Sign Ups** is enabled, your application may become vulnerable to user enumeration attacks. Auth0 recommends that you do not enable this setting to ensure the maximum security of your application and its users.\n\nIf you do enable **Disable Signs Ups**, [Brute-force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection) may mitigate the threat of some of these attacks, but it does not fully protect your application.\n\n## Link accounts\n\nUsers might want to authenticate using different passwordless factors during their lifetime. For example, they could initially sign up with an SMS, and later start authenticating with an email. You can achieve that by enabling them to link their different profiles using [account linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts).\n\nThe `/passwordless/start` endpoint has a [rate limit](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy) of 50 requests per hour per IP address. If you call the API from the server-side, your backend's IP may easily hit these rate limits. To learn how to address this issue, read the Rate Limiting in Passwordless Endpoints section of [Using Passwordless APIs](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/relevant-api-endpoints).",
  "title": "Passwordless Connections Best Practices",
  "description": "Learn about best practices when working with Passwordless connections.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api-auth/tutorials/silent-authentication",
  "markdown": "# Configure Silent Authentication\n\nThe [OpenID Connect protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol) supports a `prompt=none` parameter on the authentication request that allows applications to indicate that the authorization server must not display any user interaction (such as authentication, consent, or MFA). Auth0 will either return the requested response back to the application, or return an error if the user is not already authenticated or if some type of consent or prompt is required before proceeding.\n\nUse of the [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post) in SPAs presents security challenges requiring explicit mitigation strategies. You can use the [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) in conjunction with Silent Authentication to renew sessions in SPAs.\n\n## Initiate Silent Authentication requests\n\nTo initiate a silent authentication request, add the `prompt=none` parameter when you redirect a user to the [`/authorize` endpoint of Auth0's authentication API](https://auth0.com/docs/api/authentication#authorize-application). (The individual parameters on the authentication request will vary depending on the specific needs of your app.)\n\nFor example:\n\n```\nGET https://{yourDomain}/authorize\n    ?response_type=id_token token&\n    client_id=...&\n    redirect_uri=...&\n    state=...&\n    scope=openid...&\n    nonce=...&\n    audience=...&\n    response_mode=...&\n    prompt=none\n```\n\nThe `prompt=none` parameter causes Auth0 to immediately send a result to the specified `redirect_uri` (callback URL) using the specified `response_mode` with one of two possible responses: success or error.\n\n### Successful authentication responses\n\nIf the user was already logged in to Auth0 and no other interactive prompts are required, Auth0 will respond exactly as if the user had authenticated manually through the login page.\n\nFor example, when using the Implicit Flow, (`response_type=id_token token`, used for single-page applications), Auth0 will respond with the requested tokens:\n\n```\nGET {https://yourApp/callback}\n    #id_token=...&\n    access_token=...&\n    state=...&\n    expires_in=...\n```\n\nThis response is indistinguishable from a login performed directly without the `prompt=none` parameter.\n\n### Error responses\n\nIf the user was not logged in via Single Sign-on (SSO) or their SSO session had expired, Auth0 will redirect to the specified `redirect_uri` (callback URL) with an error:\n\n```\nGET https://your_callback_url/\n    #error=ERROR_CODE&\n    error_description=ERROR_DESCRIPTION&\n    state=...\n```\n\nThe possible values for `ERROR_CODE` are defined by the [OpenID Connect specification](https://openid.net/specs/openid-connect-core-1_0.html#AuthError):\n\n| Response | Description |\n| --- | --- |\n| `login_required` | The user was not logged in at Auth0, so silent authentication is not possible. This error can occur based on the way the tenant-level **Log In Session Management** settings are configured; specifically, it can occur after the time period set in the **Require log in after** setting. See [Configure Session Lifetime Settings](https://auth0.com/docs/dashboard/guides/tenants/configure-session-lifetime-settings) for details. |\n| `consent_required` | The user was logged in at Auth0, but needs to give consent to authorize the application. |\n| `interaction_required` | The user was logged in at Auth0 and has authorized the application, but needs to be redirected elsewhere before authentication can be completed; for example, when using a [redirect rule](https://auth0.com/docs/rules/redirect). |\n\nIf any of these errors are returned, the user must be redirected to the Auth0 login page without the `prompt=none` parameter to authenticate.\n\n## Renew expired tokens\n\nYou can make a silent authentication request to get new tokens as long as the user still has a valid session at Auth0. The [`checkSession` method from auth0.js](https://auth0.com/docs/libraries/auth0js) uses a silent token request in combination with `response_mode=web_message` for SPAs so that the request happens in a hidden iframe. With SPAs, Auth0.js handles the result processing (either the token or the error code) and passes the information through a callback function provided by the application. This results in no UX disruption (no page refresh or lost state).\n\n### Access Token expiration\n\nAccess Tokens are opaque to applications. This means that applications are unable to inspect the contents of Access Tokens to determine their expiration date.\n\nThere are two options to determine when an Access Token expires:\n\n*   Read the `expires_in` response parameter returned by Auth0.\n    \n*   Ignore expiration dates altogether. Instead, renew the Access Token if your API rejects a request from the application (such as with a 401).\n    \n\nIn the case of the [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post), the `expires_in` parameter is returned by Auth0 as a hash parameter following a successful authentication. In the [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce), it is returned to the backend server when performing the authorization code exchange.\n\nThe `expires_in` parameter indicates how many seconds the Access Token will be valid for, and can be used to anticipate expiration of the Access Token.\n\n### Error response\n\nYou may receive the `timeout` error response which indicates that timeout during executing `web_message` communication has occurred. This error is typically associated with fallback to cross-origin authentication. To resolve, make sure to add all of the URLs from which you want to perform silent authentication in the **Allowed Web Origins** field for your Application using the Auth0 Dashboard.\n\n## Poll with checkSession()\n\nIn some multi-application scenarios, where Single Logout is desired (a user logging out of one application needs to be logged out of other applications), an application can be set up to periodically poll Auth0 using `checkSession()` to see if a session exists. If the session does not exist, you can then log the user out of the application. The same polling method can be used to implement silent authentication for a Single Sign-on (SSO) scenario.\n\nThe poll interval between checks to `checkSession()` should be at least 15 minutes between calls to avoid any issues in the future with rate limiting of this call.\n\n## Silent authentication with Multi-factor Authentication\n\nIn some scenarios, you may want to avoid prompting the user for [Multi-factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) each time they log in from the same browser. To do this, set up a rule so that MFA occurs only once per session. This is useful when performing silent authentication (`prompt=none`) to renew short-lived Access Tokens in a SPA during the duration of a user's session without having to rely on setting `allowRememberBrowser` to `true`.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const authMethods = event.authentication?.methods || []\n\n  const completedMfa = !!authMethods.find((method) => method.name === 'mfa')\n\n  if (!completedMfa) {\n    api.multifactor.enable('any', { allowRememberBrowser: true })\n  }\n};\n```\n\nTo learn more, see [Change Authentication Request Frequency](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa).\n\n## Learn more\n\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Configure Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation)\n*   [Troubleshoot Invalid Token Errors](https://auth0.com/docs/troubleshoot/basic-issues/invalid-token-errors)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
  "title": "Configure Silent Authentication",
  "description": "Learn how to keep users logged in to your application using silent authentication.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/flows/guides/auth-code/call-api-auth-code",
  "markdown": "# Call Your API Using the Authorization Code Flow\n\nAuth0 makes it easy for your app to implement the Authorization Code Flow using:\n\n*   [Regular Web App Quickstarts](https://auth0.com/docs/quickstart/webapp): The easiest way to implement the flow.\n    \n*   [Authentication API](https://auth0.com/docs/api/authentication): If you prefer to build your own solution, keep reading to learn how to call our API directly.\n    \n\n## Prerequisites\n\n**Before beginning this tutorial:**\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps).\n    \n    *   Select an **Application Type** of **Regular Web Apps**.\n        \n    *   Add an **Allowed Callback URL** of `**{https://yourApp/callback}**`.\n        \n    *   Make sure your Application's **Grant Types** include **Authorization Code**. To learn how, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types).\n        \n    *   If you want your Application to be able to use [refresh tokens](https://auth0.com/docs/secure/tokens/refresh-tokens), make sure the Application's **Grant Types** include **refresh token**. To learn how, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types). To learn more about Refresh Tokens, read [refresh tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n        \n*   [Register your API with Auth0](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)\n    \n    *   If you want your API to receive refresh tokens to allow it to obtain new tokens when the previous ones expire, enable **Allow Offline Access**.\n        \n\n## Steps\n\n### Sample use cases\n\n#### Customize tokens\n\nYou can use rules to change the returned scopes of an Access Token and/or add Claims to Access and ID Tokens. (To learn more about rules, read [Auth0 Rules](https://auth0.com/docs/customize/rules).) To do so, add the following rule, which will run after the user authenticates:\n\n```\nfunction(user, context, callback) {\n  // add custom claims to Access Token and ID Token\n  context.accessToken['http://foo/bar'] = 'value';\n  context.idToken['http://fiz/baz'] = 'some other value';\n  // change scope\n  context.accessToken.scope = ['array', 'of', 'strings'];\n  callback(null, user, context);\n}\n```\n\nScopes will be available in the token after all rules have run.\n\n## Learn more\n\n*   [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth)\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)\n*   [Tokens](https://auth0.com/docs/secure/tokens)",
  "title": "Call Your API Using the Authorization Code Flow",
  "description": "Learn how to call your own API from regular web apps using the Authorization Code Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par",
  "markdown": "# Authorization Code Flow with Pushed Authorization Requests (PAR)\n\n[Pushed Authorization Request (PAR)](https://datatracker.ietf.org/doc/html/rfc9126) is a backend protocol to push authorization requests directly to the authorization server. It is a technical component of the [Financial-Grade API (FAPI) Security Profile 1.0](https://openid.net/specs/openid-financial-api-part-2-1_0.html) tasked with protecting APIs in high-value scenarios.\n\n## How it works\n\nPAR allows your application to push the parameters for OAuth 2.0 authorization requests directly to the authorization server’s PAR endpoint. In response, the authorization server sends a request URI value, `request_uri`, to use when you call the `/authorize` endpoint. The `request_uri` is a reference to the stored authorization requests at the `/par` endpoint so these requests are not exposed. To learn more, read [Configure Push Authorization Requests](https://auth0.com/docs/get-started/applications/configure-par).\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/6ivWNzZR7pnV79AXtjhJca/fc90aec5662f04947523a4c7914af1db/image12.png)\n\n## Benefits\n\nOne benefit of using PAR is early validation. In other OAuth 2.0 flows, such as the [Authorization Code Flow](https://auth0.com/docs/login/flows/authorization-code-flow), end users are redirected to the authorization server for validation. In PAR, request parameters are validated at the beginning of the authorization request before the end user is redirected. It is not ideal to redirect users to show them an error page.\n\nPAR also passes authorization requests on the back channel. Front-channel communications rely on an intermediary (e.g. a browser) via appended HTTPS query parameters (GET, POST). Messages are not sent directly. Back-channel communications are passed in the body of an authenticated backend request for a more direct approach.\n\nPush authorization requests travel via the back-channel, which means:\n\n*   The authorization server can trust where the request is coming from, and the requests have not been modified by an end user.\n    \n*   The request details have not been exposed at the browser bar or history and privacy is preserved at that point of the chain.\n    \n*   Restrictions on URL length are not a constraint.\n    \n\n## Limitations\n\n*   Maximum request payload size is limited to 10 KB.\n    \n*   Public applications are not currently supported. To learn more, read [Public and Confidential Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n    \n\n## Call the PAR endpoint\n\n### Requirements\n\nTo make a call to the PAR endpoint, you must:\n\n*   Set the request content type as `application/x-www-form-urlencoded`.\n    \n*   Use strings for all passed parameters.\n    \n*   Include an additional parameter for the application authentication method in the request. Only confidential clients support PAR, so the following [application authentication methods](https://auth0.com/docs/api/authentication#authentication-methods) are available: Client Secret, Private Key JWT, and mTLS. You must use the same application authentication method for the `/token` endpoint when retrieving an access token.\n    \n\n### Supported parameters\n\nPAR endpoint only stores and processes:\n\n*   Standard OAuth 2.0 parameters and applicable extensions, which we recognize at the authorization endpoint.\n    \n*   Up to 10 custom authorization parameters prefixed with `ext-` prefix.\n    \n\nPAR ignores additional custom authorization parameters. Custom authorization parameters are not available in [Auth0 Actions](https://auth0.com/docs/customize/actions) and [Logs](https://auth0.com/docs/deploy-monitor/logs).\n\n### Example PAR request\n\n```\ncurl --location --request POST https://$tenant/oauth/par \\\n  -H \"content-type: application/x-www-form-urlencoded\" \\\n  -d \"client_id=CLIENT_ID\"\\\n\"&client_secret=CLIENT_SECRET\"\\\n\"&redirect_uri=https://jwt.io\"\\\n\"&audience=urn:my-notes-api\"\\\n\"&scope=openid%20profile%20read:notes\"\\\n\"&response_type=code\"\n```\n\n### Example PAR Response\n\nIn the following example PAR response:\n\n*   The `request_uri` is a reference for the stored authorization requests. The request values pass to the GET `/authorize` endpoint as the `request_uri` parameter.\n    \n*   The `expires_in` is the number of seconds the `request_uri` is valid. After this time frame, the `request_uri` expires if not used. The thirty-second expiration time is a static value and can’t be configured.\n    \n\n```\nHTTP/1.1 201 Created\n Content-Type: application/json\n\n {\n  \"request_uri\":\n    \"urn:ietf:params:oauth:request_uri:6esc_11ACC5bwc014ltc14eY22c\",\n  \"expires_in\": 30\n }\n```\n\n### Rate limits\n\nFor Essential, Professional, and Enterprise production tenants, calls to the PAR endpoint are included in the standard Authentication API rate limit. For more information, see [Rate Limit Configurations](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations) and click your subscription type. Then, click **Authentication API**.\n\nYour application uses the `request_uri` value returned from the `/oauth/par` endpoint in the authorization request and redirects the user agent to the authorization endpoint. To learn more about the `request_uri` parameter, read [Configure Push Authorization Requests](https://auth0.com/docs/get-started/applications/configure-par).  \n\nThe following example directs the user agent to make the following HTTP request:\n\n```\nGET /authorize?client_id=CLIENT_ID&request_uri=urn%3Aietf%3Aparam...qrwSI HTTP/1.1 Host: TENANT.auth0.com\n```\n\nIn the case of a valid `request_uri`, the rest of the authorization flow looks the same.\n\n### Validation\n\n*   PAR is validated by the authorization server at this stage again like any other authorization request.\n    \n*   `request_uri` value can be used only one time.\n    \n*   An expired `request_uri` will be rejected by the authorization server.\n    \n*   A non-PAR request is rejected if PAR is required either on the tenant or client level.\n    \n\n## Learn more\n\n*   [Configure Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/applications/configure-par)",
  "title": "Authorization Code Flow with Pushed Authorization Requests (PAR)",
  "description": "Learn how to use Pushed Authorization Requests (PAR) with the Authorization Code Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/database/require-username",
  "markdown": "# Adding Username for Database Connections\n\nFor database connections, you can have your users sign in with a username instead of their email address.\n\n## Require username\n\n1.  Go to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database), and select the name of the connection you want to edit.\n    \n    ![Select connection](https://images.ctfassets.net/cdy7uua7fh8z/6shISO4Uw6XqldxxGnbrqW/0215e069f09c6baebd1d7abb5b3ae253/2024-03-20_16-39-37.png)\n2.  Locate **Requires Username**, and use the toggle to enable or disable requiring a username.\n    \n    ![Enable or disable require username setting](https://images.ctfassets.net/cdy7uua7fh8z/1MlOrFmcSCOCRYKRxWz6xT/aeda72f60869c61a3068bcb9ad5fe023/dashboard-connections-database-settings__1_.png)\n\nTo see how this will affect the login screen, select the **Try Connection** view. Notice that once **Requires Username** is enabled, new users must enter a username and their email address to sign up.\n\n![Login form with username](https://images.ctfassets.net/cdy7uua7fh8z/AiB37UZqyBPb8h55PZtzm/65c820f3637da094ded3d1ba4ed43a10/dashboard-connections-database-edit_view-try-connection-requires-username.png)\n\nUsers can then login with either their username or their email address. Users who registered while **Requires Username** was disabled will not have a Username field stored and will have to log in with their email address.\n\n### Username length\n\nThe default allowed length for usernames is between 1 and 15 characters. However, using the Auth0 Dashboard or via the Management API v2, you can modify the length minimum and maximum (up to a maximum length of 128 characters).\n\n![Username length](https://images.ctfassets.net/cdy7uua7fh8z/1u1fZqgsr7RUUl1s0F7bd7/ae94d939f3e1d9c6462c78c03bb1387e/dashboard-connections-database-settings_requires-username.png)\n\n### Allowed characters\n\nThe username field accepts the following characters:\n\n*   Alphanumeric characters (without accent marks, automatically converted to lowercase);\n    \n*   The at sign (@) character (but email addresses are not allowed);\n    \n*   The caret (^) character;\n    \n*   The dollar sign ($) character;\n    \n*   The dot (.) character;\n    \n*   The exclamation (!) character;\n    \n*   The grave accent (\\\\\\`) character;\n    \n*   The minus (-) character;\n    \n*   The number sign (#) character;\n    \n*   The plus (+) character;\n    \n*   The single quote (') character;\n    \n*   The tilde (~) character;\n    \n*   The underscore (\\_) character;\n    \n\nNo other characters/symbols are allowed, and Auth0 does not validate or sanitize custom database inputs.",
  "title": "Adding Username for Database Connections",
  "description": "Learn how to add a username field for login to database connections.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/applications/concepts/application-grant-types",
  "markdown": "# Application Grant Types\n\nApplication grant types (or flows) are methods through which applications can gain [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens) and by which you grant limited access to your resources to another entity without exposing credentials. The [OAuth 2.0 protocol](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use) supports several types of grants, which allow different types of access.\n\nBased on the needs of your application, some grant types are more appropriate than others. Auth0 provides many different authentication and authorization flows and allows you to indicate which grant types are appropriate based on the `grant_types` property of your application.\n\nFor example, if you want to secure a mobile application, the [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) is the most appropriate.\n\nAlternatively, if you want to secure a client-side application, such as a single-page application (SPA), and aren't passing tokens between servers, the [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post) is the most appropriate.\n\nVarious grant types are valid when registering applications. These can be divided into the following categories:\n\n*   **Specification-conforming grants**: Grants defined by and conforming to external specifications, such as OpenID Connect (OIDC).\n    \n*   **Auth0 extension grants**: Auth0-specific grants that conform to the [OAuth extension mechanism](https://tools.ietf.org/html/rfc6749#section-4.5) to support additional clients or to provide a bridge between OAuth and other trust frameworks.\n    \n*   **Auth0 legacy grants**: Traditional grant types supported for legacy customers only. If you are a legacy customer, we highly recommend moving to a more secure alternative.\n    \n\n## Available grant types\n\n### Specification-conforming grants\n\n### Auth0 extension grants\n\n| Grant Type | Description |\n| --- | --- |\n| `http://auth0.com/oauth/grant-type/password-realm` | Use an extension grant similar to the Resource Owner Password Grant that includes the ability to indicate a specific realm |\n| `http://auth0.com/oauth/grant-type/mfa-oob` | Multi-factor Authentication OOB Grant Request |\n| `http://auth0.com/oauth/grant-type/mfa-otp` | Multi-factor Authentication OTP Grant Request |\n| `http://auth0.com/oauth/grant-type/mfa-recovery-code` | Multi-factor Authentication Recovery Grant Request |\n| `http://auth0.com/oauth/grant-type/passwordless/otp` | Embedded Passwordless Login Grant Request |\n\n### Auth0 legacy grants\n\nLegacy grants include:\n\n*   `http://auth0.com/oauth/legacy/grant-type/ro`\n    \n*   `http://auth0.com/oauth/legacy/grant-type/ro/jwt-bearer`\n    \n*   `http://auth0.com/oauth/legacy/grant-type/delegation/refresh_token`\n    \n*   `http://auth0.com/oauth/legacy/grant-type/delegation/id_token`\n    \n*   `http://auth0.com/oauth/legacy/grant-type/access_token`\n    \n\nLegacy grant types are traditional grant types supported for legacy customers only. If you are a legacy customer, we highly recommend moving to a more secure alternative.\n\nAs of 08 June 2017, all applications were given a `grant_types` property that must be populated. To avoid changes in functionality for Auth0 customers at that time, we populated the `grant_types` property for all existing applications with all Auth0 legacy, Auth0 extension, and specification-conforming grant types.\n\nAt this time, new Auth0 customers were no longer able to add legacy grant types to their applications. Legacy grant types are only available for previous customers while they migrate to new flows, to avoid breaking changes. If you were a customer prior to 8 June 2017, you can [enable a legacy grant type](https://auth0.com/docs/get-started/applications/update-grant-types) using either the Auth0 Dashboard or the Auth0 Management API.\n\nIf you're currently using a legacy grant type, refer to the chart below to see which of the secure alternatives you should use instead. For example, if you're implementing Passwordless Authentication,\n\nuse [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) instead of the `oauth/ro` endpoint.\n\n## Grant type mapping\n\nWhen registered, applications have access to different grant types based on their application type, specifically whether the application is confidential or public. Additionally, trusted first-party applications have access to additional grant types.\n\n### Public applications\n\nWhen a Native Application or Single-Page Application (SPA) is registered in the Dashboard, it's automatically flagged as a public application, which is indicated by the `token_endpoint_auth_method` flag being set to `none`. By default, Auth0 creates public applications with the following `grant_types` enabled:\n\n*   `implicit`\n    \n*   `authorization_code`\n    \n*   `refresh_token`\n    \n\nNative Apps can also use the `device_code` grant type.\n\nPublic applications cannot use the `client_credentials` grant type. To use this grant type, you must configure the application to be confidential rather than public. Use the Auth0 Management API [Update a client](https://auth0.com/docs/api/management/v2#!/Clients/patch_clients_by_id) endpoint to set the `token_endpoint_auth_method` to `client_secret_post,` `client_secret_basic`, or `private_key_jwt`. To learn more, read [Application Credentials](https://auth0.com/docs/secure/application-credentials).\n\n### Confidential applications\n\nWhen a Regular Web Application or Machine-to-Machine (M2M) Application is registered in the Auth0 Dashboard, it's automatically flagged as a confidential application, which is indicated by the `token_endpoint_auth_method` flag being set to anything except `none`. By default, Auth0 creates confidential applications with the following `grant_types` enabled:\n\n*   `implicit`\n    \n*   `authorization_code`\n    \n*   `refresh_token`\n    \n*   `client_credentials`\n    \n\n### Trusted first-party applications\n\nTrusted first-party applications have the same `grant_types` enabled as confidential applications, along with the following:\n\n*   `password`\n    \n*   `http://auth0.com/oauth/grant-type/password-realm`\n    \n*   `http://auth0.com/oauth/grant-type/mfa-oob`\n    \n*   `http://auth0.com/oauth/grant-type/mfa-otp`\n    \n*   `http://auth0.com/oauth/grant-type/mfa-recovery-code`\n    \n\nIf you are using the Dashboard to enable or disable these grant types, be aware that all the Password and MFA grant types are enabled when you add the `Password` or `MFA` grant type to your application. You cannot select them individually.\n\n## Learn more\n\n*   [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications)\n*   [Enable Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications)\n*   [First-Party and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications)\n*   [Subdomain URL Placeholders](https://auth0.com/docs/get-started/applications/wildcards-for-subdomains)",
  "title": "Application Grant Types",
  "description": "Describes grant types and how they relate to applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-rar",
  "markdown": "# Authorization Code Flow with Rich Authorization Requests (RAR)\n\n[Rich Authorization Requests (RAR)](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rar) extends the OAuth2 protocol to provide a way for clients to request and obtain fine-grained authorization data from resource owners such as end users during the Authorization Code Flow.\n\nIn traditional OAuth2 flows, clients typically request access to a set of scopes from a resource server, and the resource owner grants access to those resources to the client. However, this approach does not allow for granular control over the access granted to a client and can lead to over-provisioning of access, which can pose security risks.\n\nWith RAR, clients can pass an `authorization_details` parameter to request specific permissions for each resource they wish to access. This allows for more fine-grained control over access and can help mitigate security risks associated with over-provisioning.\n\nOverall, RAR is a powerful extension to the OAuth2 protocol that provides enhanced security and control over resource access for both clients and resource owners.\n\n## How do I use it?\n\nAfter you [configure RAR](https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests) for your API, you can add the `authorization_details` parameter to a request passed to the `/par` endpoint. The parameter is an array of objects. Each object must have a type field, but types do not have to be unique in the array. Here’s an example using the authorization code flow:\n\n```\ncurl --location 'https://$tenant/oauth/par' \\\n--header 'Content-Type: application/x-www-form-urlencoded' \\\n--data-urlencode 'client_id=$client_id' \\\n--data-urlencode 'client_secret=$client_secret' \\\n--data-urlencode 'redirect_uri=https://jwt.io' \\\n--data-urlencode 'audience=urn:my-api' \\\n--data-urlencode 'response_type=code' \\\n--data-urlencode 'authorization_details=[{\"type\": \"money_transfer\", \"instructedAmount\": {\"amount\": 2500, \"currency\": \"USD\"},   \"sourceAccount\": \"xxxxxxxxxxx1234\", \"destinationAccount\": \"xxxxxxxxxxx9876\", \"beneficiary\": \"Hanna Herwitz\", \"subject\": \"A Lannister Always Pays His Debts\"}]'\n```\n\nEach `authorization_details` element can be completely custom as long as it contains a `type` field.\n\nWhen you exchange your authorization code at the `/oauth/token` endpoint, as illustrated by the following code sample:\n\n```\nPOST https://$tenant/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&client_id=[CLIENT_ID]&client_secret=[CLIENT_SECRET]&code=[AUTHZ_CODE]&redirect_uri=https://jwt.io\n```\n\nYou receive a response with the access token and `authorization_details` array:\n\n```\n{\n  \"access_token\": \"ey...ZQ\",\n  \"expires_in\": 86400,\n  \"authorization_details\": [\n{\n  \"type\": \"money_transfer\", \n  \"instructedAmount\": {\"amount\": 2500, \"currency\": \"USD\"},   \n  \"sourceAccount\": \"xxxxxxxxxxx1234\", \n  \"destinationAccount\": \"xxxxxxxxxxx9876\", \n  \"beneficiary\": \"Hanna Herwitz\", \n  \"subject\": \"A Lannister Always Pays His Debts\"\n}\n  ],\n  \"token_type\": \"Bearer\"\n}\n```\n\nThe `authorization_details` array helps the client understand the scope of the authorization granted to it without having to inspect the access token. In general, the client should never inspect the access token, which is detailed in the [IETF’s JSON Web Token Profile for OAuth 2.0 Access Tokens](https://datatracker.ietf.org/doc/html/rfc9068#name-privacy-considerations). Instead, the resource server is the one that needs to inspect the access token.\n\nIf the requested audience is an API configured to use [JWE access tokens](https://auth0.com/docs/secure/tokens/json-web-tokens), all fields apart from `type` will be removed from `authorization_details` elements in the response from the `/oauth/token` endpoint. Access token claims are unaffected.\n\n```\n{\n  \"iss\": \"https://my_tenant.auth0.com/\",\n  \"sub\": \"auth0|me\",\n  \"aud\": \"https://myapi.authzero.com\",\n  \"iat\": 1683661385,\n  \"exp\": 1683747785,\n  \"azp\": \"my_client\",\n  \"authorization_details\": [\n{\n  \"type\": \"money_transfer\", \n  \"instructedAmount\": {\"amount\": 2500, \"currency\": \"USD\"},   \n  \"sourceAccount\": \"xxxxxxxxxxx1234\", \n  \"destinationAccount\": \"xxxxxxxxxxx9876\", \n  \"beneficiary\": \"Hanna Herwitz\", \n  \"subject\": \"A Lannister Always Pays His Debts\"\n}\n  ]\n}\n```\n\nIn addition to the standard protocol support, we also expose RAR inside the post-login Action via the `event.transaction.requested_authorization_details` property. Use this property to make decisions about the transaction, including stepping up Multi-Factor Authentication.\n\n## What doesn’t Auth0 support?\n\nAt this stage, Auth0 doesn’t support:\n\n*   Updating RAR in Actions.\n    \n*   Advertising RAR types for clients to discover.\n    \n\nValidate the RAR objects beyond checking that they have a `type` property that matches allowed types for the API. For more information, see [Configure RAR](https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests).\n\n## Learn more\n\n*   [Configure Rich Authorization Requests (RAR)](https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests)",
  "title": "Authorization Code Flow with Rich Authorization Requests (RAR)",
  "description": "Learn how to use Rich Authorization Requests (RAR) with the Authorization Code Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-par",
  "markdown": "# Configure Pushed Authorization Requests (PAR)\n\nThe Auth0 Push Authorization Request (PAR) implementation is based on the [OAuth RFC0126: Push Authorization Request](https://www.rfc-editor.org/rfc/rfc9126.html) specification. For more information, see [Authorization Code Flow with Pushed Authorization Requests](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par).\n\nBy default, PAR is not required by the authorization server. As a result, you can send authorization requests to the PAR endpoint and the `/authorize` endpoint. However, to fully secure your authorization flow, set PAR as required for an application and/or a tenant via the [Management API](https://auth0.com/docs/api/management/v2) or **Application Settings** on the Auth0 Dashboard.\n\n## Set PAR for an application\n\n1.  Navigate to Auth0 Dashboard > Applications.\n    \n2.  Select the application.\n    \n3.  Select the **Application Settings** tab.\n    \n4.  In the **Authorization Requests** section, enable the toggle **Require Pushed Authorization Requests (PAR)**.\n    \n\n![Set application-level PAR with Auth0 Dashboard](https://images.ctfassets.net/cdy7uua7fh8z/2y2F8ydAHB1O8DbUMlu6vA/f1ed831a1f188bbd721ce4fc2a0207b5/Screenshot_2024-05-28_at_10.24.58_AM.png)\n\n## Set PAR for a tenant\n\nTo set PAR for a tenant, use the [Auth0 Dashboard](https://manage.auth0.com/).\n\n1\\. Navigate to Auth0 Dashboard > Settings > Advanced.\n\n2\\. Scroll down to **Settings** and toggle on **Allow Pushed Authorization Requests (PAR)**.\n\n![Auth0 Dashboard > Settings > Advanced > Allow mTLS endpoint aliases](https://images.ctfassets.net/cdy7uua7fh8z/4FnQEF7eNEgDT5OLcH46c2/745f4a40e5719884fea93d388fdfb587/Screenshot_2024-05-28_at_4.40.48_PM.png)\n\n## Learn more\n\n*   [Authorization Code Flow with Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par)",
  "title": "Configure Pushed Authorization Requests (PAR)",
  "description": "Learn how to configure Pushed Authorization Requests (PAR) for your application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/database/password-strength",
  "markdown": "# Password Strength in Auth0 Database Connections\n\nAn important concern when using passwords for authentication is password strength. A strong password policy will make it difficult, if not improbable, for someone to guess a password through either manual or automated means.\n\nThe following characteristics define a strong password:\n\n*   **Password Length**: Longer passwords include a greater combination of characters making it more difficult to guess. Passwords shorter than 10 characters are considered weak.\n    \n*   **Password Complexity**: Passwords containing a combination of upper-case and lower-case letters, numbers, and special characters are recommended.\n    \n*   **Passphrases**: Sentences or combinations of words can be much longer than typical passwords yet much easier to remember.\n    \n\n## Password policies\n\nAuth0's Password Strength feature allows you to customize the level of enforced complexity for passwords entered during user sign-up. Auth0 offers 5 levels of security to match [OWASP password recommendations](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md).\n\nAt each level, new passwords must meet the following criteria:\n\n*   **None** (default): at least 1 character of any type.\n    \n*   **Low**: at least 6 characters.\n    \n*   **Fair**: at least 8 characters including a lower-case letter, an upper-case letter, and a number.\n    \n*   **Good**: at least 8 characters including at least 3 of the following 4 types of characters: a lower-case letter, an upper-case letter, a number, a special character (such as `!@#$%^&*`).\n    \n*   **Excellent**: at least 10 characters including at least 3 of the following 4 types of characters: a lower-case letter, an upper-case letter, a number, a special character (such as `!@#$%^&*`). Not more than 2 identical characters in a row (for example, `111` is not allowed).\n    \n\n## Minimum password length\n\nYou can set a minimum length requirement for passwords that is independent of the policy strength requirements described in the [Password Policies section](#password-policies).\n\nThe minimum password length you can set is 1 byte, while the maximum is 72 bytes.\n\nIf you opt for a higher-level password policy, but you do not specify a minimum length value, the minimum password length for the policy level will automatically be used:\n\n| Password Policy Level | Minimum Password Length |\n| --- | --- |\n| None | 1   |\n| Low | 6   |\n| Fair | 8   |\n| Good | 8   |\n| Excellent | 10  |\n\nIf you provide a minimum password length, this value supersedes that indicated by the password policy.\n\n### Minimum password length when using Universal Login Pages\n\nIf you are using either the [Universal Login Page](https://auth0.com/docs/authenticate/login/auth0-universal-login) or the [Universal Login Password Reset Page](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page), and you want to set the minimum password length value, you will need to complete a few additional configuration steps using the [Auth0 Dashboard](https://manage.auth0.com/#).\n\n#### Set minimum password length when using Hosted Password Reset Pages\n\nIf you're using a [customized Password Reset Page](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page), and you want to set the password length parameter, you must:\n\n1\\. Update your templates to include library version 1.5.1 or later 2. Add `password_complexity_options` to leverage the new parameter\n\nIf you do not update the Password Reset Page, Auth0 ignores any attempt to set the minimum password length.\n\n##### Step 1: Update the change password library version\n\nTo use the new minimum password length feature, you should update the change password library used to version 1.5.1 (or later):\n\n```\n<script src=\"https://cdn.auth0.com/js/change-password-1.5.1.min.js\"></script>\n```\n\n##### Step 2: Add password\\_complexity\\_options to leverage the new parameter\n\nYou'll need to add `password_complexity_options` to leverage the new parameter. Add this option to the page's script as follows:\n\n```\n<script>\n    //code omitted for brevity\n    new Auth0ChangePassword({\n    container:                    \"change-password-widget-container\",     // required\n    email:                        '{{email}}',                            // DO NOT CHANGE THIS\n    csrf_token:                   '{{csrf_token}}',                       // DO NOT CHANGE THIS\n    ticket:                       '{{ticket}}',                           // DO NOT CHANGE THIS\n    password_policy:              '{{password_policy}}',                  // DO NOT CHANGE THIS\n    password_complexity_options:  {{password_complexity_options}}         // DO NOT CHANGE THIS\n\n    //code omitted for brevity\n\n  });\n</script>\n```\n\nScroll to the bottom, and select **Save**.\n\n#### Set minimum password length when using Universal Login Pages\n\nIf you're using a customized [Login Page](https://auth0.com/docs/authenticate/login/auth0-universal-login) and you want to set the password length parameter, you must [update the page to use Lock version 11.9 or later](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience).\n\n```\n<script src=\"https://cdn.auth0.com/js/lock/11.9/lock.min.js\"></script>\n```\n\nScroll to the bottom, and select **Save**.\n\n## Change your policy\n\nTo change the password strength policy, navigate to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database). Choose the database connection you wish to update and select the Authentication Methods tab. In the Password section, select Configure, then locate the **Password Strength** section:\n\n![Auth0 Database Authentication - Password Policy - Password Strength](https://images.ctfassets.net/cdy7uua7fh8z/5DaTBH1ILrFFYXYPQzaxgl/73f7811885a0dec760b84a0cda0a5a7b/dashboard-connections-database-edit_view-password-policy_password-strength.png)\n\nThe new policy will be enforced on all subsequent user sign-ups and password changes. If the user enters a password that does not match the required criteria, the password will be rejected by Auth0 and the user will be asked to create one that complies with these requirements.\n\n### Lock\n\nAfter password policies have been enabled, users will be notified on signup and reset password Lock modes if their password does not meet the required criteria.\n\nThis is how Lock will appear on the desktop:\n\n![Auth0 Lock Password Strength checks on Desktop](https://images.ctfassets.net/cdy7uua7fh8z/3BOFON1gZiWRHl4Foybm5H/98d045d03e2b497a0eb389168f89978d/7cmjQFY45M.png)\n\nand on mobile:\n\n![Auth0 Lock Password Strength checks on Mobile](https://images.ctfassets.net/cdy7uua7fh8z/01rh02vYW6lBjOxBFh7HVC/619b3cea2e916987e4cfb0d1a835530b/moUbn4XXxR.png)\n\n## Custom signup errors\n\nSign-up errors will return a `400` HTTP status code. The JSON response will contain `code: invalid_password` when the password does not meet the selected password policy criteria.\n\nThe response will also contain additional information that can be used to guide the user to what is incorrect in the selected password:\n\n*   A `message` is ready to be formatted using the `printf` function (or Node.js `util.format`).\n    \n*   `format` is an array with values to be used in the `message`. (`message` is separate from the `format` to allow easier i18n of error messages in custom UIs.)\n    \n*   `verified` can be either `true` or `false`. Returns `false` if the rule has been violated.\n    \n\n### Examples\n\nThis is a sample `description` error report from a `good` policy with `hello` as the password:\n\n```\n{\n  \"rules\":[\n    {\n      \"message\":\"At least %d characters in length\",\n      \"format\":[8],\n      \"verified\":false\n    },\n    {\n      \"message\":\"Contain at least %d of the following %d types of characters:\",\n      \"format\":[3,4],\n      \"items\":[\n        {\n          \"message\":\"lower case letters (a-z)\",\n          \"verified\":true\n        },\n        {\n          \"message\":\"upper case letters (A-Z)\",\n          \"verified\":false\n        },\n        {\n          \"message\":\"numbers (such as 0-9)\",\n          \"verified\":false\n        },\n        {\n          \"message\":\"special characters (such as !@#$%^&*)\",\n          \"verified\":false\n        }\n      ],\n      \"verified\":false\n    }\n  ],\"\n  verified\":false\n}\n```\n\nThis is a sample `description` error report from a `good` policy with `hello1234` as the password:\n\n```\n{\n    \"rules\":[\n      {\"message\":\"At least %d characters in length\",\"format\":[8],\"verified\":true},\n      {\"message\":\"Contain at least %d of the following %d types of characters:\",\"format\":[3,4],\n        \"items\":[\n          {\"message\":\"lower case letters (a-z)\",\"verified\":true},\n          {\"message\":\"upper case letters (A-Z)\",\"verified\":false},\n          {\"message\":\"numbers (such as 0-9)\",\"verified\":true},\n          {\"message\":\"special characters (such as !@#$%^&*)\",\"verified\":false}\n        ],\"verified\":false}\n      ],\"\n      verified\":false\n    }\n```\n\n## Password options\n\nIn addition to the Password Strength feature explained here, the Password Policy settings for a database connection also include various Password Options that can further enhance your connection's password policy and ensure that your users have more secure passwords. To learn more, read [Password Options](https://auth0.com/docs/authenticate/database-connections/password-options).",
  "title": "Password Strength in Auth0 Database Connections",
  "description": "Auth0's Password Strength feature allows you to customize the level of enforced complexity for passwords entered during user sign-up. Auth0 offers 5 levels of security to match OWASP password recommendations.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/flows/guides/auth-code-pkce/call-api-auth-code-pkce",
  "markdown": "# Call Your API Using the Authorization Code Flow with PKCE\n\nAuth0 makes it easy for your app to implement the Authorization Code Flow with Proof Key for Code Exchange (PKCE) using:\n\n*   [Auth0 Mobile SDKs](https://auth0.com/docs/libraries) and [Auth0 Single-Page App SDK](https://auth0.com/docs/libraries/auth0-single-page-app-sdk): The easiest way to implement the flow, which will do most of the heavy-lifting for you. Our [Mobile Quickstarts](https://auth0.com/docs/quickstart/native) and [Single-Page App Quickstarts](https://auth0.com/docs/quickstart/spa) will walk you through the process.\n    \n*   [Authentication API](https://auth0.com/docs/api/authentication): If you prefer to build your own solution, keep reading to learn how to call our API directly.\n    \n\n## Prerequisites\n\n**Before beginning this tutorial:**\n\n*   [Register the Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications/native-apps).\n    \n    *   Select an **Application Type** of **Native** or **Single-Page App**, depending on your application type.\n        \n    *   Add an **Allowed Callback URL** of `**{yourCallbackUrl}**`. Your callback URL format will vary depending on your application type and platform. For details about the format for your application type and platform, see our [Native/Mobile Quickstarts](https://auth0.com/docs/quickstart/native) and [Single-Page App Quickstarts](https://auth0.com/docs/quickstart/spa).\n        \n    *   Make sure the Application's **Grant Types** include **Authorization Code**. To learn how, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types).\n        \n    *   If you want your Application to be able to use Refresh Tokens, make sure the Application's **Grant Types** include **Refresh Token**. To learn how, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types). To learn more about Refresh Tokens, read [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n        \n*   [Register your API with Auth0](https://auth0.com/docs/architecture-scenarios/mobile-api/part-2#create-the-api)\n    \n    *   If you want your API to receive Refresh Tokens to allow it to obtain new tokens when the previous ones expire, enable **Allow Offline Access**.\n        \n\n## Steps\n\n1.  [Create code verifier](#create-code-verifier): Generate a `code_verifier` that will be sent to Auth0 to request tokens.\n    \n2.  [Create code challenge](#create-code-challenge): Generate a `code_challenge` from the `code_verifier` that will be sent to Auth0 to request an `authorization_code`.\n    \n3.  [Authorize user](#authorize-user): Request the user's authorization and redirect back to your app with an `authorization_code`.\n    \n4.  [Request tokens](#request-tokens): Exchange your `authorization_code` and `code_verifier` for tokens.\n    \n5.  [Call API](#call-api): Use the retrieved Access Token to call your API.\n    \n6.  [Refresh tokens](#refresh-tokens): Use a Refresh Token to request new tokens when the existing ones expire.\n    \n\nOptional: [Explore sample use cases](#sample-use-cases).\n\n### Create code verifier\n\nCreate a `code_verifier`, which is a cryptographically-random, Base64-encoded key that will eventually be sent to Auth0 to request tokens.\n\n#### Javascript sample\n\n```\n// Dependency: Node.js crypto module\n// https://nodejs.org/api/crypto.html#crypto_crypto\nfunction base64URLEncode(str) {\n    return str.toString('base64')\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_')\n        .replace(/=/g, '');\n}\nvar verifier = base64URLEncode(crypto.randomBytes(32));\n```\n\n#### Java sample\n\n```\n// Dependency: Apache Commons Codec\n// https://commons.apache.org/proper/commons-codec/\n// Import the Base64 class.\n// import org.apache.commons.codec.binary.Base64;\nSecureRandom sr = new SecureRandom();\nbyte[] code = new byte[32];\nsr.nextBytes(code);\nString verifier = Base64.getUrlEncoder().withoutPadding().encodeToString(code);\n```\n\n#### Android sample\n\n```\n// See https://developer.android.com/reference/android/util/Base64\n// Import the Base64 class\n// import android.util.Base64;\nSecureRandom sr = new SecureRandom();\nbyte[] code = new byte[32];\nsr.nextBytes(code);\nString verifier = Base64.encodeToString(code, Base64.URL_SAFE | Base64.NO_WRAP | Base64.NO_PADDING);\n```\n\n#### Swift 5 sample\n\n```\nvar buffer = [UInt8](repeating: 0, count: 32)\n_ = SecRandomCopyBytes(kSecRandomDefault, buffer.count, &buffer)\nlet verifier = Data(buffer).base64EncodedString()\n    .replacingOccurrences(of: \"+\", with: \"-\")\n    .replacingOccurrences(of: \"/\", with: \"_\")\n    .replacingOccurrences(of: \"=\", with: \"\")\n```\n\n#### Objective-C sample\n\n```\nNSMutableData *data = [NSMutableData dataWithLength:32];\nint result __attribute__((unused)) = SecRandomCopyBytes(kSecRandomDefault, 32, data.mutableBytes);\nNSString *verifier = [[[[data base64EncodedStringWithOptions:0]\n                        stringByReplacingOccurrencesOfString:@\"+\" withString:@\"-\"]\n                        stringByReplacingOccurrencesOfString:@\"/\" withString:@\"_\"]\n                        stringByTrimmingCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@\"=\"]];\n```\n\n### Create code challenge\n\nGenerate a `code_challenge` from the `code_verifier` that will be sent to Auth0 to request an `authorization_code`.\n\n#### Javascript sample\n\n```\n// Dependency: Node.js crypto module\n// https://nodejs.org/api/crypto.html#crypto_crypto\nfunction sha256(buffer) {\n    return crypto.createHash('sha256').update(buffer).digest();\n}\nvar challenge = base64URLEncode(sha256(verifier));\n```\n\n#### Java sample\n\n```\n// Dependency: Apache Commons Codec\n// https://commons.apache.org/proper/commons-codec/\n// Import the Base64 class.\n// import org.apache.commons.codec.binary.Base64;\nbyte[] bytes = verifier.getBytes(\"US-ASCII\");\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nmd.update(bytes, 0, bytes.length);\nbyte[] digest = md.digest();\nString challenge = Base64.encodeBase64URLSafeString(digest);\n```\n\n#### Swift 5 sample\n\n```\nimport CommonCrypto\n\n// ...\n\nguard let data = verifier.data(using: .utf8) else { return nil }\nvar buffer = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))\n_ = data.withUnsafeBytes {\n    CC_SHA256($0.baseAddress, CC_LONG(data.count), &buffer)\n}\nlet hash = Data(buffer)\nlet challenge = hash.base64EncodedString()\n    .replacingOccurrences(of: \"+\", with: \"-\")\n    .replacingOccurrences(of: \"/\", with: \"_\")\n    .replacingOccurrences(of: \"=\", with: \"\")\n```\n\n#### Objective-C sample\n\n```\n// Dependency: Apple Common Crypto library\n// http://opensource.apple.com//source/CommonCrypto\nu_int8_t buffer[CC_SHA256_DIGEST_LENGTH * sizeof(u_int8_t)];\nmemset(buffer, 0x0, CC_SHA256_DIGEST_LENGTH);\nNSData *data = [verifier dataUsingEncoding:NSUTF8StringEncoding];\nCC_SHA256([data bytes], (CC_LONG)[data length], buffer);\nNSData *hash = [NSData dataWithBytes:buffer length:CC_SHA256_DIGEST_LENGTH];\nNSString *challenge = [[[[hash base64EncodedStringWithOptions:0]\n                         stringByReplacingOccurrencesOfString:@\"+\" withString:@\"-\"]\n                         stringByReplacingOccurrencesOfString:@\"/\" withString:@\"_\"]\n                         stringByTrimmingCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@\"=\"]];\n```\n\nOnce you've created the `code_verifier` and the `code_challenge`, you must get the user's authorization. This is technically the beginning of the authorization flow, and this step may include one or more of the following processes:\n\n\\* Authenticating the user; \\* Redirecting the user to an Identity Provider to handle authentication; \\* Checking for active [Single Sign-on (SSO)](https://auth0.com/docs/authenticate/single-sign-on) sessions; \\* Obtaining user consent for the requested permission level, unless consent has been previously given.\n\nTo authorize the user, your app must send the user to the [authorization URL](https://auth0.com/docs/api/authentication#authorization-code-grant-pkce-), including the `code_challenge` you generated in the previous step and the method you used to generate the `code_challenge`.\n\n#### Example authorization URL\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=code&\n    code_challenge={codeChallenge}&\n    code_challenge_method=S256&\n    client_id={yourClientId}&\n    redirect_uri={yourCallbackUrl}&\n    scope=SCOPE&\n    audience={apiAudience}&\n    state={state}\n```\n\n##### Parameters\n\nNote that for authorizing a user when calling a custom API, you:\n\n\\- must include an audience parameter - can include additional scopes supported by the target API\n\n| Parameter Name | Description |\n| --- | --- |\n| `response_type` | Denotes the kind of credential that Auth0 will return (`code` or `token`). For this flow, the value must be `code`. |\n| `code_challenge` | Generated challenge from the `code_verifier`. |\n| `code_challenge_method` | Method used to generate the challenge (e.g., S256). The PKCE spec defines two methods, `S256` and `plain`, the former is used in this example and is the **only** one supported by Auth0 since the latter is discouraged. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `redirect_uri` | The URL to which Auth0 will redirect the browser after authorization has been granted by the user. The Authorization Code will be available in the `code` URL parameter. You must specify this URL as a valid callback URL in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings).<br><br>**Warning:** Per the [OAuth 2.0 Specification](https://tools.ietf.org/html/rfc6749#section-3.1.2), Auth0 removes everything after the hash and does _not_ honor any fragments. |\n| `scope` | The [scopes](https://auth0.com/docs/scopes) for which you want to request authorization. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, [custom claims](https://auth0.com/docs/tokens/concepts/jwt-claims#custom-claims) conforming to a [namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (e.g., `read:contacts`). Include `offline_access` to get a Refresh Token (make sure that the **Allow Offline Access** field is enabled in the [Application Settings](https://manage.auth0.com/#/apis)). |\n| `audience` | The unique identifier of the API your mobile app wants to access. Use the **Identifier** value on the [Settings](https://manage.auth0.com/#/apis) tab for the API you created as part of the prerequisites for this tutorial. |\n| `state` | (recommended) An opaque arbitrary alphanumeric string your app adds to the initial request that Auth0 includes when redirecting back to your application. To see how to use this value to prevent cross-site request forgery (CSRF) attacks, see [Mitigate CSRF Attacks With State Parameters](https://auth0.com/docs/protocols/oauth2/mitigate-csrf-attacks). |\n| `organization` | (optional) ID of the organization to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating. |\n| `invitation` | (optional) Ticket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the `invitation` and `organization` key-value pairs when the user accepts the invitation. |\n\nAs an example, your HTML snippet for your authorization URL when calling an API might look like:\n\n```\n<a href=\"https://{yourDomain}/authorize?\n  response_type=code&\n  client_id={yourClientId}&\n  code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM&\n  code_challenge_method=S256&\n  redirect_uri={yourCallbackUrl}&\n  scope=appointments%20contacts&\n  audience=appointments:api&\n  state=xyzABC123\">\n  Sign In\n</a>\n```\n\n#### Response\n\nIf all goes well, you'll receive an `HTTP 302` response. The authorization code is included at the end of the URL:\n\n```\nHTTP/1.1 302 Found\nLocation: {yourCallbackUrl}?code={authorizationCode}&state=xyzABC123\n```\n\n### Request tokens\n\nNow that you have an Authorization Code, you must exchange it for tokens. Using the extracted Authorization Code (`code`) from the previous step, you will need to `POST` to the [token URL](https://auth0.com/docs/api/authentication#authorization-code-pkce-) sending along the `code_verifier`.\n\n#### Example POST to token URL\n\n*   [cURL](#c500d881d1754540bd1d8571be7010dd_shell)\n*   [C#](#c500d881d1754540bd1d8571be7010dd_csharp)\n*   [Go](#c500d881d1754540bd1d8571be7010dd_go)\n*   [Java](#c500d881d1754540bd1d8571be7010dd_java)\n*   [Node.JS](#c500d881d1754540bd1d8571be7010dd_node)\n*   [Obj-C](#c500d881d1754540bd1d8571be7010dd_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data 'code_verifier={yourGeneratedCodeVerifier}' \\\n  --data 'code={yourAuthorizationCode}' \\\n  --data 'redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    code_verifier: '{yourGeneratedCodeVerifier}',\n    code: '{yourAuthorizationCode}',\n    redirect_uri: '{https://yourApp/callback}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=authorization_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code_verifier={yourGeneratedCodeVerifier}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code={yourAuthorizationCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&redirect_uri={https://yourApp/callback}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=authorization_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code_verifier={yourGeneratedCodeVerifier}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code={yourAuthorizationCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&redirect_uri={https://yourApp/callback}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to \"authorization\\_code\". |\n| `code_verifier` | The cryptographically-random key that was generated in the first step of this tutorial. |\n| `code` | The `authorization_code` retrieved in the previous step of this tutorial. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `redirect_uri` | The valid callback URL set in your Application settings. This must exactly match the `redirect_uri` passed to the authorization URL in the previous step of this tutorial. Note that this must be URL encoded. |\n\n#### Response\n\nIf all goes well, you'll receive an HTTP 200 response with a payload containing `access_token`, `refresh_token`, `id_token`, and `token_type` values:\n\n```\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"refresh_token\":\"GEbRxBN...edjnXbL\",\n  \"id_token\":\"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n[ID tokens](https://auth0.com/docs/secure/tokens/id-tokens) contain user information that must be decoded and extracted.\n\n[Access tokens](https://auth0.com/docs/secure/tokens/access-tokens) are used to call the [Auth0 Authentication API's /userinfo endpoint](https://auth0.com/docs/api/authentication#get-user-info) or another API. If you are calling your own API, the first thing your API will need to do is [verify the Access token](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens).\n\n[Refresh tokens](https://auth0.com/docs/secure/tokens/refresh-tokens) are used to obtain a new access token or ID token after the previous one has expired. The `refresh_token` will only be present in the response if you included the `offline_access` scope and enabled **Allow Offline Access** for your API in the Dashboard.\n\n### Call API\n\nTo call your API from a native/mobile application, the application must pass the retrieved Access Token as a Bearer token in the Authorization header of your HTTP request.\n\n*   [cURL](#1dc2407623b84ff48c5e216d2ac32720_shell)\n*   [C#](#1dc2407623b84ff48c5e216d2ac32720_csharp)\n*   [Go](#1dc2407623b84ff48c5e216d2ac32720_go)\n*   [Java](#1dc2407623b84ff48c5e216d2ac32720_java)\n*   [Node.JS](#1dc2407623b84ff48c5e216d2ac32720_node)\n*   [Obj-C](#1dc2407623b84ff48c5e216d2ac32720_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://myapi.com/api \\\n  --header 'authorization: Bearer {accessToken}' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://myapi.com/api\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {accessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://myapi.com/api\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {accessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://myapi.com/api\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {accessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://myapi.com/api',\n  headers: {'content-type': 'application/json', authorization: 'Bearer {accessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {accessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://myapi.com/api\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://myapi.com/api\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {accessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"myapi.com\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {accessToken}\"\n    }\n\nconn.request(\"GET\", \"/api\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://myapi.com/api\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {accessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {accessToken}\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://myapi.com/api\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Refresh tokens\n\nYou have already received a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens) if you've been following this tutorial and completed the following:\n\n*   configured your API to allow offline access\n    \n*   included the `offline_access` scope when you initiated the authentication request through the [authorize endpoint](https://auth0.com/docs/api/authentication/reference#authorize-application).\n    \n\nYou can use the Refresh Token to get a new access token. Usually, a user will need a new access token only after the previous one expires or when gaining access to a new resource for the first time. It's bad practice to call the endpoint to get a new access token every time you call an API, and Auth0 maintains rate limits that will throttle the amount of requests to the endpoint that can be executed using the same token from the same IP.\n\nTo refresh your token, make a `POST` request to the `/oauth/token` endpoint in the Authentication API, using `grant_type=refresh_token`.\n\n#### Example POST to token URL\n\n*   [cURL](#dfaa674a3053483a99a3e56c295d099a_shell)\n*   [C#](#dfaa674a3053483a99a3e56c295d099a_csharp)\n*   [Go](#dfaa674a3053483a99a3e56c295d099a_go)\n*   [Java](#dfaa674a3053483a99a3e56c295d099a_java)\n*   [Node.JS](#dfaa674a3053483a99a3e56c295d099a_node)\n*   [Obj-C](#dfaa674a3053483a99a3e56c295d099a_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=refresh_token \\\n  --data 'client_id={yourClientId}' \\\n  --data 'refresh_token={yourRefreshToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'refresh_token',\n    client_id: '{yourClientId}',\n    refresh_token: '{yourRefreshToken}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=refresh_token\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&refresh_token={yourRefreshToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=refresh_token\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&refresh_token={yourRefreshToken}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to `refresh_token`. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `refresh_token` | The refresh token to use. |\n| `scope` | (optional) A space-delimited list of requested scope permissions. If not sent, the original scopes will be used; otherwise you can request a reduced set of scopes. Note that this must be URL encoded. |\n\n#### Response\n\nIf all goes well, you'll receive an `HTTP 200` response with a payload containing a new `access_token`, its lifetime in seconds (`expires_in`), granted `scope` values, and `token_type`. If the scope of the initial token included `openid`, then the response will also include a new `id_token`:\n\n```\n{\n  \"access_token\": \"eyJ...MoQ\",\n  \"expires_in\": 86400,\n  \"scope\": \"openid offline_access\",\n  \"id_token\": \"eyJ...0NE\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n### Sample use cases\n\n#### Customize tokens\n\nYou can use rules to change the returned scopes of Access Tokens and/or add claims to Access and ID Tokens. (To learn more about rules, read [Auth0 Rules](https://auth0.com/docs/customize/rules).) To do so, add the following rule, which will run after the user authenticates:\n\n```\nfunction(user, context, callback) {\n  // add custom claims to Access Token and ID Token\n  context.accessToken['http://foo/bar'] = 'value';\n  context.idToken['http://fiz/baz'] = 'some other value';\n  // change scope\n  context.accessToken.scope = ['array', 'of', 'strings'];\n  callback(null, user, context);\n}\n```\n\nScopes will be available in the token after all rules have run.\n\n#### View Sample Application: Mobile App + API\n\nFor a sample implementation, see the [Mobile + API](https://auth0.com/docs/architecture-scenarios/application/mobile-api) architecture scenario. This series of tutorials is accompanied by a [code sample that you can access in GitHub](https://github.com/auth0-samples/auth0-pnp-exampleco-timesheets).\n\n## Learn more\n\n*   [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth)\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)\n*   [Tokens](https://auth0.com/docs/secure/tokens)",
  "title": "Call Your API Using the Authorization Code Flow with PKCE",
  "description": "Learn how to call your API from a native, mobile, or single-page application using the Authorization Code flow using Proof Key for Code Exchange (PKCE).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations",
  "markdown": "# Rate Limit Configurations\n\nAuth0 enforces limitations to protect services from excessive requests and protect customers from service interruptions or degradation. Based on your subscription type, these rate limits may vary. Please see the table below for the rate limits associated with your account configuration.",
  "title": "Rate Limit Configurations",
  "description": "Learn about Auth0 rate limiting policies that help prevent service interruption and degradation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/email-templates",
  "markdown": "# Customize Email Templates\n\nThe **Redirect To** URL is an optional destination to redirect the user to after the relevant action (verify account, reset password, unblock account) was performed.\n\nWith the Universal Login Classic Experience, you can provide a URL to which users are redirected after they reset their password. Auth0 sends a `success` indicator and a `message` to the URL. To learn more about these two parameters, see [Email Template Descriptions](https://auth0.com/docs/customize/email/email-templates/email-template-descriptions).\n\nWith the New Universal Login Experience, Auth0 redirects users to the default log in route when the user succeeds in resetting the password. If not, Auth0 handles the errors as part of the Universal Login flow and ignores the redirect URL provided in the email template.\n\nOnly the following three variables are available on the **Redirect To** URL:\n\n*   `application.name` (or its synonym `client.name`)\n    \n*   `application.clientID`\n    \n*   `application.callback_domain` (or its synonym `client.callback_domain`)\n    \n\nThe `application.callback_domain` variable will contain the origin of the **first** URL listed in the application's **Allowed Callback URL** list. This lets you redirect users to a path of the application that triggered the action by using a syntax like this:\n\n`{{ application.callback_domain }}/result_page`\n\nNote that while the variable is called `callback_domain`, it is really an origin, so it includes the protocol in addition to the domain, e.g. `https://myapp.com`.\n\nIf your application has multiple **Allowed Callback URLs** configured, Auth0 will use the first URL listed. You can also provide a default origin using Liquid syntax:\n\n`{{ application.callback_domain | default: \"https://my-default-domain.com\" }}/result_page`\n\n##### Dynamic redirect to URLs\n\nYou can set up a different Redirect To URLs based on your application name. For example:\n\n`{% if application.name == 'JWT.io' %} https://jwt.io {% else %} https://auth0.com {% endif %}`\n\nBecause the application name is encoded for security, you should always use an encoded value (especially if your application name contains a character that changes once encoded). For example, you'll want to use `My%20App` instead of `My App`.\n\nFor single-page applications (SPAs), the **Redirect To** URL may contain the hash and route for a particular state/view in the app, followed by route parameters. This can cause the following issue with the **Redirect To** URL:\n\n`http://localhost:3000/#/register`\n\nWhich will result in a user getting redirected to the following URL:\n\n```\nhttp://localhost:3000/?supportSignUp=true\n  &supportForgotPassword=true\n  &email=john.doe%40exampleco.com\n  &message=Your%20email%20was%20verified.%20You%20can%20continue%20using%20the%20application.\n  &success=true#/register\n```\n\nThis is described by Internet Standards (to learn more, read the [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) spec by the Internet Engineering Task Force) that define the expected order of a URL as `scheme|authority|path|query|fragment`. However, SPA frameworks (such as Angular) typically expect URLs in the `scheme|authority|path|fragment|query` format (with the query string parameters at the end). This causes the application not to enter the expected state. For example, with the above URL, the app will be routed to `/` instead of `/#/register`.\n\nTo work around this limitation of SPA frameworks, it is recommended to use a server-side callback URL as the **redirect To** URL with a `route` parameter that preserves the SPA app route for the redirect. Once in this server-side URL, simply redirect to the SPA route saved in the `route` parameter along with rest of the query string.\n\n1.  Add a server-side URL as the **redirect To** URL with a `route` parameter that records the SPA route for the redirect. `http://localhost:3001/register?route=register`\n    \n2.  Create a server-side route controller that reads the `route` and other parameters from the URL and redirects to the SPA route specified in `route` parameter. Remember to append the other parameters received from Auth0.\n    \n    ```\n    var express = require('express');\n    var router = express.Router();\n    var qs = require('qs'); // to read query string params and stringify them\n    \n    router.get('/register', function(req, res, next) {\n      var route = req.query.route; // retrieve the route param that contains the SPA client side route user needs to be redirected to.\n    \n      delete req.query.route; // remove it from query params.\n      res.redirect('http://localhost:3000/#/' + route + '?' +  qs.stringify(req.query)); // Send a 302 redirect for the expected route\n    });\n    \n    module.exports = router;\n    ```",
  "title": "Customize Email Templates",
  "description": "Learn how to customize your emails with Liquid templating syntax.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api-auth/tutorials/using-resource-owner-password-from-server-side",
  "markdown": "# Avoid Common Issues with Resource Owner Password Flow and Attack Protection\n\nThough we do not recommend it, highly-trusted applications can call server-side APIs using the [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow), which requests that users provide credentials (username and password), typically using an interactive form. If [brute-force protection is enabled](https://auth0.com/docs/secure/attack-protection/brute-force-protection), when Auth0 validates the credentials, we may also [check for attacks](https://auth0.com/docs/secure/attack-protection) and perform appropriate actions if an attack is detected.\n\nUnfortunately, when using this flow with brute-force protection, some attack protection features may fail. Some common issues, however, can be avoided.\n\n## Attack protection and server-side APIs\n\nBrute-force protection and suspicious IP throttling rely on having the user's IP address. When calling an API from your server, Auth0 treats the IP address of your server as the IP address of the user and provides it as input to the brute-force protection and suspicious IP throttling functionality. This could potentially trigger false positives, causing attack protection to block users or trigger warnings for legitimate requests.\n\nTo avoid this, send the user's IP address to Auth0 along with their credentials, and configure your application to trust the IP address.\n\n### Configure your Application to trust the IP address\n\nRegister either a [regular web application](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps) or a [machine-to-machine application](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps). While configuring the application:\n\n*   Under **Settings**, select a **Token Endpoint Authentication Method** other than `None`.\n    \n*   Under **Advanced Settings**, locate the **OAuth** tab, and enable **Trust Token Endpoint IP Header**, which will set the `auth0-forwarded-for` header as a trusted source of the user's IP address for brute-force protection. This setting will not be available for non-authenticated applications.\n    \n\n### Send the user's IP address from your server\n\n1.  When you request tokens using the [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/call-your-api-using-resource-owner-password-flow), include an `auth0-forwarded-for` header that contains the value of the user's IP address. Be sure that the IP address you provide really belongs to your user.\n    \n2.  Specify AllowLists of IPs to be ignored when triggering brute-force protection and suspicious IP throttling.\n    \n\n#### Allow listing with brute-force protection and suspicious IP throttling\n\nIf your authenticated application is configured to send the `auth0-forwarded-for` header:\n\n*   Only the IP address contained in the `auth0-forwarded-for` header is checked against the brute-force protection and suspicious IP throttling AllowLists.\n    \n*   The proxy IP address is ignored by brute-force protection and suspicious IP throttling, so doesn't need to be added to the AllowLists.\n    \n*   If specific clients that use the proxy should not be subject to brute-force protection or suspicious IP throttling, add them to the AllowLists.\n    \n\nThe `auth0-forwarded-for` header will only be accepted for authenticated calls with the Client Secret. If your application is not authenticated or is not configured to send the `auth0-forwarded-for` header:\n\n*   The originating IP address of each request is checked against the brute-force protection and suspicious IP throttling AllowLists.\n    \n*   If you AllowList the IP proxy, all traffic passing through the proxy will be exempt from brute-force protection and suspicious IP throttling. This is probably not what you want.\n    \n\n### Example\n\n```\nvar request = require(\"request\");\n\napp.post('/api/auth', function(req, res, next) {\n  var options = {\n    method: 'POST',\n    url: 'https://{yourDomain}/oauth/token',\n    headers: {\n      'content-type': 'application/x-www-form-urlencoded',\n      'auth0-forwarded-for': req.ip // End user ip\n    },\n    form: {\n      grant_type: 'password',\n      username: 'USERNAME',\n      password: 'PASSWORD',\n      audience: 'YOUR_API_IDENTIFIER',\n      scope: 'SCOPE',\n      client_id: '{yourClientId}',\n      client_secret: 'YOUR_CLIENT_SECRET' // Client is authenticated\n    }\n  };\n\n  request(options, function (error, response, body) {\n    if (error) return next(error);\n\n    // ...\n  });\n});\n```\n\n### Validate with logs\n\nIf your settings are working correctly, you will see the following in the logs:\n\n```\ntype:  sepft\n...\nip:  <ip from auth0-forwarded-for header>\nclient_ip:  <ip of actual client/proxy>\n...\n```\n\n## Learn more\n\n*   [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n*   [Call Your API Using Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/call-your-api-using-resource-owner-password-flow)\n*   [Attack Protection](https://auth0.com/docs/secure/attack-protection)",
  "title": "Avoid Common Issues with Resource Owner Password Flow and Attack Protection",
  "description": "Learn how to avoid common issues encountered when using the Resource Owner Password Flow to call server-side APIs with attack protection enabled.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api-auth/tutorials/nonce",
  "markdown": "# Mitigate Replay Attacks When Using the Implicit Flow\n\nTo mitigate replay attacks when using the [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post), a nonce must be sent on authentication requests [as required by the OpenID Connect (OIDC) specification](https://openid.net/specs/openid-connect-core-1_0.html#ImplicitAuthRequest).\n\nThe nonce is generated by the application, sent as a `nonce` query string parameter in the authentication request, and included in the ID Token response from Auth0. This allows applications to correlate the ID Token response from Auth0 with the initial authentication request.\n\nTo learn more about where to include the nonce, see [Add Login Using the Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/add-login-using-the-implicit-flow-with-form-post).\n\n## Generate a cryptographically random nonce\n\nOne way to generate a cryptographically random nonce is to use a tool like [Nano ID](https://github.com/ai/nanoid) or similar. This does require you to bundle the tool with your JavaScript code, however. If that's not possible, you can take advantage of the fact that [modern browsers](http://caniuse.com/#feat=cryptography) can use the [Web Crypto API](https://www.w3.org/TR/WebCryptoAPI/) to generate cryptographically secure random strings for use as nonces.\n\n```\nfunction randomString(length) {\n    var charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz+/'\n    result = ''\n\n    while (length > 0) {\n        var bytes = new Uint8Array(16);\n        var random = window.crypto.getRandomValues(bytes);\n\n        random.forEach(function(c) {\n            if (length == 0) {\n                return;\n            }\n            if (c < charset.length) {\n                result += charset[c];\n                length--;\n            }\n        });\n    }\n    return result;\n}\n```\n\n## Persist nonces across requests\n\nThe generated nonce must be persisted in your web application using any of the following methods:\n\n*   `HttpOnly` session cookie\n    \n*   HTML5 local storage value\n    \n\nFor example:\n\n```\nwindow.localStorage.setItem('nonce', randomString(16));\n```\n\n## Validate ID token\n\nOnce Auth0 responds with an [ID Token](https://auth0.com/docs/secure/tokens/id-tokens), this token must be [validated and decoded](https://auth0.com/docs/secure/tokens/id-tokens/validate-id-tokens) as usual. Its `nonce` claim must contain the exact same value that was sent in the request. If not, authentication should be rejected by the application.\n\n```\nvar jwt = '...'; // validated and decoded ID Token body\nif (jwt.nonce === window.localStorage.getItem('nonce')) {\n    // Nonce is OK\n} else {\n    // Nonce is not OK! Token replay attack might be underway\n}\n```\n\n## Learn more\n\n*   [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post)\n*   [Add Login Using the Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/add-login-using-the-implicit-flow-with-form-post)\n*   [Implicit Flow with OIDC](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow)",
  "title": "Mitigate Replay Attacks When Using the Implicit Flow",
  "description": "Learn how to securely generate and validate a cryptographic nonce for use with the Implicit Flow with Form Post.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/database/password-change",
  "markdown": "# Change Users' Passwords\n\nThis topic describes different ways to reset the password for a user in your database. You can change passwords for users in your [database connections](https://auth0.com/docs/authenticate/database-connections) only. Users signing in with [social](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers) or [enterprise](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers) connections must reset their passwords with the identity provider (such as Google or Facebook).\n\nThere are two basic methods for changing a user's password:\n\n*   [Trigger an interactive password reset flow](#trigger-an-interactive-password-reset-flow) that sends the user a link through email. The link opens the Auth0 password reset page where the user can enter a new password.\n    \n*   [Directly set the new password](#directly-set-the-new-password) using the Auth0 Management API or the Auth0 Dashboard.\n    \n\n#### Not what you're looking for?\n\n*   To configure the custom Password Reset page, read [Customize Password Reset Page](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page).\n    \n*   To implement custom behavior after a successful password change, read [Actions Triggers: post-change-password](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow).\n    \n*   To reset the password to your personal Auth0 user account, read [Reset Account Passwords](https://auth0.com/docs/troubleshoot/customer-support/reset-account-passwords).\n    \n\n## Trigger an interactive password reset flow\n\nThere are two ways to trigger an interactive password reset flow, depending on your use case: through the Universal Login page or the Authentication API.\n\n### Universal Login page\n\nIf your application uses Universal Login, the user can use the Lock widget on the Login screen to trigger a password reset email. With Universal Login, the user can click the **Don't remember your password?** link and then enter their email address. This fires off a POST request to Auth0 that triggers the password reset process. The user [receives a password reset email](#password-reset-email).\n\n### Authentication API\n\nIf your application uses an interactive password reset flow through the Authentication API, make a `POST` call. In the `email` field, provide the email address of the user who needs to change their password. If the call is successful, the user [receives a password reset email](#password-reset-email).\n\nIf you call the API from the browser, be sure the origin URL is allowed:\n\nGo to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications/{yourClientId}/settings), and add the URL to the **Allowed Origins (CORS)** list.\n\nIf your connection is a custom database, check to see if the user exists in the database before you invoke the Authentication API for `changePassword`.\n\n*   [cURL](#6d065832f3c2428e9145ab89019ce199_shell)\n*   [C#](#6d065832f3c2428e9145ab89019ce199_csharp)\n*   [Go](#6d065832f3c2428e9145ab89019ce199_go)\n*   [Java](#6d065832f3c2428e9145ab89019ce199_java)\n*   [Node.JS](#6d065832f3c2428e9145ab89019ce199_node)\n*   [Obj-C](#6d065832f3c2428e9145ab89019ce199_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/dbconnections/change_password' \\\n  --header 'content-type: application/json' \\\n  --data '{\"client_id\": \"{yourClientId}\",\"email\": \"\",\"connection\": \"Username-Password-Authentication\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/dbconnections/change_password\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"\\\",\\\"connection\\\": \\\"Username-Password-Authentication\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/dbconnections/change_password\"\n\n\tpayload := strings.NewReader(\"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"\\\",\\\"connection\\\": \\\"Username-Password-Authentication\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/dbconnections/change_password\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"\\\",\\\"connection\\\": \\\"Username-Password-Authentication\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/dbconnections/change_password',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    email: '',\n    connection: 'Username-Password-Authentication'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"email\": @\"\",\n                              @\"connection\": @\"Username-Password-Authentication\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/dbconnections/change_password\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/dbconnections/change_password\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"\\\",\\\"connection\\\": \\\"Username-Password-Authentication\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"\\\",\\\"connection\\\": \\\"Username-Password-Authentication\\\"}\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/dbconnections/change_password\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/dbconnections/change_password\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"client_id\\\": \\\"{yourClientId}\\\",\\\"email\\\": \\\"\\\",\\\"connection\\\": \\\"Username-Password-Authentication\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"email\": \"\",\n  \"connection\": \"Username-Password-Authentication\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/dbconnections/change_password\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Password reset email\n\nRegardless of how the password reset process was triggered, the user receives email containing a link to reset their password.\n\n![Password Reset Email](https://images.ctfassets.net/cdy7uua7fh8z/5IBhcrCJ7XXI6OgQOnHMJa/33cdafbfe7a63a48cfaa2e58a12a2494/password-reset-email.png)\n\nClicking the link sends the user to the [password reset page](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page).\n\nAfter submitting the new password, the user sees confirmation that they can now log in with their new credentials.\n\nNotes on password resets:\n\n*   The reset password link in the email is valid for one use only.\n    \n*   If the user receives multiple password reset emails, only the password link in the most recent email is valid.\n    \n*   The **URL Lifetime** field determines how long the link is valid. From the Auth0 dashboard, you can [customize the Change Password email](https://auth0.com/docs/customize/email/email-templates) and [modify the link's lifetime](https://auth0.com/docs/api/authentication/reference#change-password).\n    \n*   You can extend the password reset flow to include another factor with Auth0 Actions. To learn more, read [Password Reset Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset).\n    \n\nWith [Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience), you can configure a URL to redirect users to after completing the password reset. The URL receives a success indicator and a message. To learn more, read the \"Configuring the Redirect-To URL\" section in [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\n[Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience) redirects the user to the [default login route](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes) when it succeeds, and handles the error cases as part of the Universal Login flow. This experience ignores the Redirect URL in the email template.\n\n#### Generate Password Reset tickets\n\nThe Management API provides the [Create a Password Change Ticket](https://auth0.com/docs/api/management/v2#!/Tickets/post_password_change) endpoint, which generates a URL like the one in the password reset email. You can use the generated URL when the email delivery method is not appropriate. Keep in mind that in the default flow, the email delivery verifies the identity of the user. (An impostor wouldn't have access to the email inbox.) If you use the ticket URL, your application is responsible for verifying the identity of the user in some other way.\n\n## Directly set the new password\n\nTo directly set a new password for the user without sending a password reset email, use either the [Management API](#use-the-management-api) or the [Auth0 Dashboard](#manually-set-users-passwords-using-the-auth0-dashboard).\n\n### Use the Management API\n\nIf you want to implement your own password reset flow, you can directly change a user's password from a server request to the Management API: make a `PATCH` call to the [Update a User endpoint](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id).\n\n*   [cURL](#fe3f80e9252a48218aaf0941dbda0f63_shell)\n*   [C#](#fe3f80e9252a48218aaf0941dbda0f63_csharp)\n*   [Go](#fe3f80e9252a48218aaf0941dbda0f63_go)\n*   [Java](#fe3f80e9252a48218aaf0941dbda0f63_java)\n*   [Node.JS](#fe3f80e9252a48218aaf0941dbda0f63_node)\n*   [Obj-C](#fe3f80e9252a48218aaf0941dbda0f63_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/%7BuserId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"password\": \"newPassword\",\"connection\": \"connectionName\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"application/json\", \"{\\\"password\\\": \\\"newPassword\\\",\\\"connection\\\": \\\"connectionName\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/%7BuserId%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"password\\\": \\\"newPassword\\\",\\\"connection\\\": \\\"connectionName\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{\\\"password\\\": \\\"newPassword\\\",\\\"connection\\\": \\\"connectionName\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/%7BuserId%7D',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer {yourMgmtApiAccessToken}'\n  },\n  data: {password: 'newPassword', connection: 'connectionName'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"password\": @\"newPassword\",\n                              @\"connection\": @\"connectionName\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/%7BuserId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/%7BuserId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"password\\\": \\\"newPassword\\\",\\\"connection\\\": \\\"connectionName\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"password\\\": \\\"newPassword\\\",\\\"connection\\\": \\\"connectionName\\\"}\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/%7BuserId%7D\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{\\\"password\\\": \\\"newPassword\\\",\\\"connection\\\": \\\"connectionName\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\"\n]\nlet parameters = [\n  \"password\": \"newPassword\",\n  \"connection\": \"connectionName\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/%7BuserId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Manually set users' passwords using the Auth0 Dashboard\n\nAnyone with administrative privileges to your Auth0 tenant can manually change a user's password at [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n\n1.  Select the name of the user whose password you want to change.\n    \n2.  Locate the **Danger Zone** at the bottom of the page.\n    \n3.  In the red **Change Password** box, select **Change**.\n    \n    ![Manually set password](https://images.ctfassets.net/cdy7uua7fh8z/5mrEG3UtlZW47AnTikwIGv/e630ad2f291bd9e355c8a6af03e9e168/dashboard-users-edit_view-details_danger-zone__1_.png)\n4.  Enter the new password, and select **Save**.",
  "title": "Change Users' Passwords",
  "description": "Describes the different ways to reset users' passwords for your Auth0 applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/flows/guides/client-credentials/call-api-client-credentials",
  "markdown": "# Call Your API Using the Client Credentials Flow\n\nAuth0 makes it easy for your application to implement the Client Credentials Flow. Following successful authentication, the application will have access to an access token, which can be used to call your protected APIs. To learn more about access tokens, read [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens).\n\n## Prerequisites\n\n**Before beginning this tutorial:**\n\n*   [Register your API with Auth0](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)\n    \n    *   [Add appropriate API permissions](https://auth0.com/docs/get-started/apis/add-api-permissions)\n        \n*   [Register the M2M Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps).\n    \n    *   Select an **Application Type** of **Machine to Machine Applications**.\n        \n    *   Choose your previously-registered API.\n        \n    *   Authorize the M2M Application to call your API.\n        \n\n## Steps\n\n1.  [Request tokens](#request-tokens): From the authorized application, request an access token for your API.\n    \n2.  [Call API](#call-api): Use the retrieved access token to call your API.\n    \n\nOptional: [Explore sample use cases](#sample-use-cases)\n\n### Request tokens\n\nTo access your API, you must request an access token for it. To do so, you will need to `POST` to the [token URL](https://auth0.com/docs/api/authentication#client-credentials).\n\n#### Example POST to token URL\n\n*   [cURL](#9181d0de22754f69927bb1b4c5c5c1e4_shell)\n*   [C#](#9181d0de22754f69927bb1b4c5c5c1e4_csharp)\n*   [Go](#9181d0de22754f69927bb1b4c5c5c1e4_go)\n*   [Java](#9181d0de22754f69927bb1b4c5c5c1e4_java)\n*   [Node.JS](#9181d0de22754f69927bb1b4c5c5c1e4_node)\n*   [Obj-C](#9181d0de22754f69927bb1b4c5c5c1e4_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data client_id=YOUR_CLIENT_ID \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data audience=YOUR_API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: 'YOUR_CLIENT_ID',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: 'YOUR_API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id=YOUR_CLIENT_ID\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=YOUR_API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id=YOUR_CLIENT_ID\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=YOUR_API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to \"client\\_credentials\". |\n| `client_id` | Your application's Client ID. You can find this value on the [application's settings tab](https://manage.auth0.com/#/applications). |\n| `client_secret` | Your application's Client Secret. You can find this value on the [application's settings tab](https://manage.auth0.com/#/applications). To learn more about available application authentication methods, read [Application Credentials](https://auth0.com/docs/secure/application-credentials). |\n| `audience` | The audience for the token, which is your API. You can find this in the **Identifier** field on your [API's settings tab](https://manage.auth0.com/#/apis). |\n\n#### Response\n\nIf all goes well, you'll receive an `HTTP 200` response with a payload containing `access_token`, `token_type`, and `expires_in` values:\n\n```\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### Call API\n\nTo call your API from the M2M application, the application must pass the retrieved access token as a Bearer token in the Authorization header of your HTTP request.\n\n*   [cURL](#79b0c47bbcfc47f8b706f8a83a80b458_shell)\n*   [C#](#79b0c47bbcfc47f8b706f8a83a80b458_csharp)\n*   [Go](#79b0c47bbcfc47f8b706f8a83a80b458_go)\n*   [Java](#79b0c47bbcfc47f8b706f8a83a80b458_java)\n*   [Node.JS](#79b0c47bbcfc47f8b706f8a83a80b458_node)\n*   [Obj-C](#79b0c47bbcfc47f8b706f8a83a80b458_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://myapi.com/api \\\n  --header 'authorization: Bearer ACCESS_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://myapi.com/api\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://myapi.com/api\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://myapi.com/api\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://myapi.com/api',\n  headers: {'content-type': 'application/json', authorization: 'Bearer ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://myapi.com/api\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://myapi.com/api\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"myapi.com\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer ACCESS_TOKEN\"\n    }\n\nconn.request(\"GET\", \"/api\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://myapi.com/api\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer ACCESS_TOKEN\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://myapi.com/api\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Sample use cases\n\n#### Customize tokens\n\nYou can use [Actions](https://auth0.com/docs/customize/actions) to deny access tokens based on custom logic and/or add claims to access tokens. Auth0 invokes Actions attached to the client credentials grant at runtime to execute your custom logic.\n\nTo learn more, read about the Actions [Machine to Machine Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow).\n\n#### View sample application: server client + API\n\nFor a sample implementation, read the [Server Client + API](https://auth0.com/docs/architecture-scenarios/application/server-api) architecture scenario. This series of tutorials is accompanied by a [code sample that you can access in GitHub](https://github.com/auth0-samples/auth0-pnp-exampleco-timesheets).\n\nOnce your API receives a request with an access token, it will need to validate the token. To learn more, read [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens).\n\n## Learn more\n\n*   [Customize Tokens Using Hooks with Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/customize-tokens-using-hooks-with-client-credentials-flow)\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)\n*   [Tokens](https://auth0.com/docs/secure/tokens)",
  "title": "Call Your API Using the Client Credentials Flow",
  "description": "Learn how to call your API from a machine-to-machine (M2M) application using the Client Credentials Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/database/password-options",
  "markdown": "# Password Options in Auth0 Database Connections\n\nWhen using passwords for authentication, you should enforce the creation of unique passwords. A strong password policy will make it difficult, if not improbable, for a bad actor to guess a password through either manual or automated means.\n\nImportant facets of strong passwords are their uniqueness and difficulty to guess. Auth0's password options for database connections allow you to force your users to make better decisions when choosing their passwords.\n\n![Password Options](https://images.ctfassets.net/cdy7uua7fh8z/1vqXxz0OD7hNLYLwrZZzIe/adf82ab79709eede8ae3ed7354460dfd/2024-04-15_11-14-00.png)\n\nThe Password Options area is located at [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database). Choose the database connection you wish to update and select the **Authentication Methods** tab. In the Password section, select **Configure**.\n\nThe **Password Policy** settings page contains the ability to configure the [Password Strength Policy](https://auth0.com/docs/authenticate/database-connections/password-strength) as well as the following password options.\n\n## Password history\n\nEnabling this option disallows users from setting passwords that repeat passwords they've used in the recent past. Auth0 can retain a password history for each user, up to a maximum of 24 entries per user. Note that when this option is enabled, only password changes going forward will be affected because the history will not have been kept prior to that point.\n\nEven if you do not have a required password change policy (for example, forcing users to change passwords every six months), you still may want to disallow the use of previous passwords. For example, if a security breach in your organization causes you to force users to change their passwords everywhere, you will want to ensure they aren't just re-using passwords that might be compromised.\n\n## Password dictionary\n\nEnabling this option disallows users from setting passwords to common options included in a [default dictionary list](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Common-Credentials/10k-most-common.txt). You may also include your own prohibited passwords by entering them in the text field in this section.\n\nNote that Auth0 uses case-insensitive comparison with the Password Dictionary feature.\n\n## Personal data\n\nEnabling this option disallows users from setting passwords that contain any part of their personal data. This includes:\n\n*   `name`\n    \n*   `username`\n    \n*   `nickname`\n    \n*   `user_metadata.name`\n    \n*   `user_metadata.first`\n    \n*   `user_metadata.last`\n    \n*   The first part of the user's email will also be checked - `firstpart`@example.com\n    \n\nFor example, if the user's name were \"John\", the user would not be allowed to include \"John\" in their password; `John1234` would not be allowed.\n\n## API access\n\nBecause password options are associated with a Database connection, you can access them using the Management API's [Connections endpoints](https://auth0.com/docs/api/management/v2#!/Connections). Password-related fields are stored in the `options` object. Because these fields are not used for non-database connections, they are not required, so if they are not enabled for a connection, they may not appear.\n\nFor example, after setting a password policy, a MySQL database connection will look like this:\n\n```\n{\n  \"id\": \"con_9dKKcib71UMRiHHW\",\n  \"options\": {\n    \"password_history\": {\n      \"enable\": true,\n      \"size\": 5\n    },\n    \"password_dictionary\": {\n      \"enable\": true,\n      \"dictionary\": [\n        \"entry1\",\n        \"entry2\"\n      ]\n    },\n    \"password_no_personal_info\": {\n      \"enable\": true\n    },\n    \"passwordPolicy\": \"fair\"\n  },\n  \"strategy\": \"auth0\",\n  \"name\": \"MySQL\",\n  \"enabled_clients\": [\n    \"smTzlgPEdqGV0i070t6kPhmG98787987\",\n    \"ztIyxRuiK7Pr2VTzEGvRqxfuh7DgePbF\"\n  ]\n}\n```\n\nIn this example, we can see from the `options` object that all three password options are enabled, password history will store the 5 most recent passwords, and each password will be cross-checked against two dictionaries: `entry1` and `entry2`.\n\nIf you are [creating a connection](https://auth0.com/docs/api/management/v2#!/Connections/post_connections) or [updating an existing connection](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id) using the Management API, you can update the password policy for the connection using these fields.",
  "title": "Password Options in Auth0 Database Connections",
  "description": "Auth0's Password Options allow you to disallow users from repeating prior passwords, to customize a password dictionary of passwords to disallow, and to disallow passwords related to the user's personal data.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api-auth/config/asking-for-access-tokens",
  "markdown": "# Call Your API Using the Client Credentials Flow\n\nAuth0 makes it easy for your application to implement the Client Credentials Flow. Following successful authentication, the application will have access to an access token, which can be used to call your protected APIs. To learn more about access tokens, read [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens).\n\n## Prerequisites\n\n**Before beginning this tutorial:**\n\n*   [Register your API with Auth0](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)\n    \n    *   [Add appropriate API permissions](https://auth0.com/docs/get-started/apis/add-api-permissions)\n        \n*   [Register the M2M Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps).\n    \n    *   Select an **Application Type** of **Machine to Machine Applications**.\n        \n    *   Choose your previously-registered API.\n        \n    *   Authorize the M2M Application to call your API.\n        \n\n## Steps\n\n1.  [Request tokens](#request-tokens): From the authorized application, request an access token for your API.\n    \n2.  [Call API](#call-api): Use the retrieved access token to call your API.\n    \n\nOptional: [Explore sample use cases](#sample-use-cases)\n\n### Request tokens\n\nTo access your API, you must request an access token for it. To do so, you will need to `POST` to the [token URL](https://auth0.com/docs/api/authentication#client-credentials).\n\n#### Example POST to token URL\n\n*   [cURL](#9181d0de22754f69927bb1b4c5c5c1e4_shell)\n*   [C#](#9181d0de22754f69927bb1b4c5c5c1e4_csharp)\n*   [Go](#9181d0de22754f69927bb1b4c5c5c1e4_go)\n*   [Java](#9181d0de22754f69927bb1b4c5c5c1e4_java)\n*   [Node.JS](#9181d0de22754f69927bb1b4c5c5c1e4_node)\n*   [Obj-C](#9181d0de22754f69927bb1b4c5c5c1e4_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data client_id=YOUR_CLIENT_ID \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data audience=YOUR_API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: 'YOUR_CLIENT_ID',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: 'YOUR_API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id=YOUR_CLIENT_ID\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=YOUR_API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=YOUR_CLIENT_ID&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id=YOUR_CLIENT_ID\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=YOUR_API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to \"client\\_credentials\". |\n| `client_id` | Your application's Client ID. You can find this value on the [application's settings tab](https://manage.auth0.com/#/applications). |\n| `client_secret` | Your application's Client Secret. You can find this value on the [application's settings tab](https://manage.auth0.com/#/applications). To learn more about available application authentication methods, read [Application Credentials](https://auth0.com/docs/secure/application-credentials). |\n| `audience` | The audience for the token, which is your API. You can find this in the **Identifier** field on your [API's settings tab](https://manage.auth0.com/#/apis). |\n\n#### Response\n\nIf all goes well, you'll receive an `HTTP 200` response with a payload containing `access_token`, `token_type`, and `expires_in` values:\n\n```\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n### Call API\n\nTo call your API from the M2M application, the application must pass the retrieved access token as a Bearer token in the Authorization header of your HTTP request.\n\n*   [cURL](#79b0c47bbcfc47f8b706f8a83a80b458_shell)\n*   [C#](#79b0c47bbcfc47f8b706f8a83a80b458_csharp)\n*   [Go](#79b0c47bbcfc47f8b706f8a83a80b458_go)\n*   [Java](#79b0c47bbcfc47f8b706f8a83a80b458_java)\n*   [Node.JS](#79b0c47bbcfc47f8b706f8a83a80b458_node)\n*   [Obj-C](#79b0c47bbcfc47f8b706f8a83a80b458_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://myapi.com/api \\\n  --header 'authorization: Bearer ACCESS_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://myapi.com/api\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://myapi.com/api\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://myapi.com/api\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://myapi.com/api',\n  headers: {'content-type': 'application/json', authorization: 'Bearer ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://myapi.com/api\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://myapi.com/api\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"myapi.com\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer ACCESS_TOKEN\"\n    }\n\nconn.request(\"GET\", \"/api\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://myapi.com/api\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer ACCESS_TOKEN\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://myapi.com/api\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Sample use cases\n\n#### Customize tokens\n\nYou can use [Actions](https://auth0.com/docs/customize/actions) to deny access tokens based on custom logic and/or add claims to access tokens. Auth0 invokes Actions attached to the client credentials grant at runtime to execute your custom logic.\n\nTo learn more, read about the Actions [Machine to Machine Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow).\n\n#### View sample application: server client + API\n\nFor a sample implementation, read the [Server Client + API](https://auth0.com/docs/architecture-scenarios/application/server-api) architecture scenario. This series of tutorials is accompanied by a [code sample that you can access in GitHub](https://github.com/auth0-samples/auth0-pnp-exampleco-timesheets).\n\nOnce your API receives a request with an access token, it will need to validate the token. To learn more, read [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens).\n\n## Learn more\n\n*   [Customize Tokens Using Hooks with Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/customize-tokens-using-hooks-with-client-credentials-flow)\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)\n*   [Tokens](https://auth0.com/docs/secure/tokens)",
  "title": "Call Your API Using the Client Credentials Flow",
  "description": "Learn how to call your API from a machine-to-machine (M2M) application using the Client Credentials Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/mfa/concepts/mfa-api",
  "markdown": "# Auth0 MFA API\n\nAuth0 provides a built-in multi-factor authentication (MFA) enrollment and authentication flow using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). Use the [MFA API](https://auth0.com/docs/api/authentication#multi-factor-authentication) in the following scenarios if you want to:\n\n*   [Authenticate users with the Resource Owner Password Grant](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n    \n*   Build an interface to let [users manage their own authentication factors](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api).\n    \n\nTo use the MFA API, you must enable the MFA grant type for your application. To enable the MFA grant in the Auth0 Dashboard, go to [Dashboard > Applications > Advanced Settings > Grant Types](https://manage.auth0.com/#/applications) and select **MFA**. See [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa) for details.\n\n## Limitations\n\nThe MFA API is designed to work with SMS, Voice, push via the Auth0 Guardian app, email, and OTP factors. It does not currently support enrolling with Duo or WebAuthn.\n\n## Learn more\n\n*   [Customize Multi-Factor Authentication Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa)\n*   [Authenticate Using the Resource Owner Password Flow with MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa)\n*   [Multi-Factor Authentication Developer Resources](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources)\n*   [Create Custom Enrollment Tickets](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets)",
  "title": "Auth0 MFA API",
  "description": "Describes the Auth0 MFA API which allows you to enroll and manage MFA for users.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/mfa/guides/mfa-api/multifactor-resource-owner-password",
  "markdown": "# Authenticate Using the Resource Owner Password Flow with MFA\n\nYou can use the [Auth0 MFA API](https://auth0.com/docs/api/authentication#multi-factor-authentication) to complete the authentication flow using the [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow) when MFA is enabled.\n\n## Prerequisites\n\nBefore you can use the MFA APIs, you'll need to enable the MFA grant type for your application. Go to [Auth0 Dashboard > Applications > Advanced Settings > Grant Types](https://manage.auth0.com/#/applications) and select **MFA**.\n\n## Authenticate user\n\nWhen you use the Resource Owner Password Flow to authenticate, you call the `/oauth/token` endpoint with the user's username and password.\n\n*   [cURL](#62894de16af5416292d79cbd935147e6_shell)\n*   [C#](#62894de16af5416292d79cbd935147e6_csharp)\n*   [Go](#62894de16af5416292d79cbd935147e6_go)\n*   [Java](#62894de16af5416292d79cbd935147e6_java)\n*   [Node.JS](#62894de16af5416292d79cbd935147e6_node)\n*   [Obj-C](#62894de16af5416292d79cbd935147e6_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=password \\\n  --data username=user@example.com \\\n  --data password=pwd \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data audience=https://someapi.com/api \\\n  --data 'scope=openid profile read:sample'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=password&username=user%40example.com&password=pwd&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2Fsomeapi.com%2Fapi&scope=openid%20profile%20read%3Asample\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=password&username=user%40example.com&password=pwd&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2Fsomeapi.com%2Fapi&scope=openid%20profile%20read%3Asample\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=password&username=user%40example.com&password=pwd&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2Fsomeapi.com%2Fapi&scope=openid%20profile%20read%3Asample\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'password',\n    username: 'user@example.com',\n    password: 'pwd',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    audience: 'https://someapi.com/api',\n    scope: 'openid profile read:sample'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=password\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&username=user@example.com\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&password=pwd\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=https://someapi.com/api\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&scope=openid profile read:sample\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=password&username=user%40example.com&password=pwd&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2Fsomeapi.com%2Fapi&scope=openid%20profile%20read%3Asample\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=password&username=user%40example.com&password=pwd&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2Fsomeapi.com%2Fapi&scope=openid%20profile%20read%3Asample\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=password&username=user%40example.com&password=pwd&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2Fsomeapi.com%2Fapi&scope=openid%20profile%20read%3Asample\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=password\".data(using: String.Encoding.utf8)!)\npostData.append(\"&username=user@example.com\".data(using: String.Encoding.utf8)!)\npostData.append(\"&password=pwd\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=https://someapi.com/api\".data(using: String.Encoding.utf8)!)\npostData.append(\"&scope=openid profile read:sample\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nWhen MFA is enabled, the response includes an `mfa_required` error and a `mfa_token`.\n\n```\n{\n    \"error\": \"mfa_required\",\n    \"error_description\": \"Multifactor authentication required\",\n    \"mfa_token\": \"Fe26...Ha\"\n}\n```\n\n## Retrieve enrolled authenticators\n\nAfter getting the error above, you need to find out if the user has an MFA factor enrolled or not. Call the [MFA Authenticators endpoint](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api), using the MFA token obtained in the previous section.\n\n*   [cURL](#cbfd44952cc04a2eb8fb23976b531a17_shell)\n*   [C#](#cbfd44952cc04a2eb8fb23976b531a17_csharp)\n*   [Go](#cbfd44952cc04a2eb8fb23976b531a17_go)\n*   [Java](#cbfd44952cc04a2eb8fb23976b531a17_java)\n*   [Node.JS](#cbfd44952cc04a2eb8fb23976b531a17_node)\n*   [Obj-C](#cbfd44952cc04a2eb8fb23976b531a17_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/mfa/authenticators\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/mfa/authenticators\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou will get an array with the available authenticators. The array will be empty if the user did not enroll a factor.\n\n```\n[\n    {\n        \"id\": \"recovery-code|dev_O4KYL4FtcLAVRsCl\",\n        \"authenticator_type\": \"recovery-code\",\n        \"active\": true\n    },\n    {\n        \"id\": \"email|dev_NU1Ofuw3Cw0XCt5x\",\n        \"authenticator_type\": \"oob\",\n        \"active\": true,\n        \"oob_channel\": \"email\",\n        \"name\": \"email@address.com\"\n    }\n]\n```\n\n## Enroll MFA factor\n\nIf the user is not enrolled in MFA, use the MFA token obtained earlier and enroll it using the MFA Associate endpoint. See the following links to implement this flow based on the authentication factor:\n\n*   [SMS or voice](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n    \n*   [One-time password (OTP)](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n    \n*   [Push](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)\n    \n*   [Email](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n    \n\n## Challenge user with MFA\n\nIf the user is already enrolled in MFA, you need to challenge the user with one of the existing factors. Use the `authenticator_id` return by the MFA Authenticators endpoint when calling the MFA Challenge endpoint.\n\nAfter the challenge is complete, call `/oauth/token` endpoint again to finalize the authentication flow and get the authentication tokens.\n\nSee the links below to implement this flow depending on the authentication factor:\n\n*   [SMS or voice](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n    \n*   [One-time password (OTP)](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n    \n*   [Push](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)\n    \n*   [Email](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n    \n\n## Learn more\n\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n*   [Enroll and Challenge OTP Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n*   [Enroll and Challenge Push Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)\n*   [Enroll and Challenge Email Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n*   [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors)",
  "title": "Authenticate Using the Resource Owner Password Flow with MFA",
  "description": "Learn how to authenticate users using the Resource Owner Password Flow with MFA.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api-auth/tutorials/password-grant",
  "markdown": "# Call Your API Using Resource Owner Password Flow\n\nAuth0 makes it easy for your app to implement the Resource Owner Password Flow using the [Authentication API](https://auth0.com/docs/api/authentication). Keep reading to learn how to call our API directly.\n\n## Prerequisites\n\n**Before beginning this tutorial:**\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps).\n    \n    *   Select an **Application Type** of **Regular Web Apps**.\n        \n    *   Add an **Allowed Callback URL** of `**{https://yourApp/callback}**`. This field cannot be undefined or an error message will be returned.\n        \n    *   Make sure your Application's **Grant Types** include **Password**. To learn how, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types).\n        \n    *   If you want your Application to be able to use Refresh Tokens, make sure the Application's **Grant Types** include **Refresh Token**. To learn how, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types). To learn more about Refresh Tokens, read [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n        \n*   [Register your API with Auth0](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)\n    \n    *   If you want your API to receive Refresh Tokens to allow it to obtain new tokens when the previous ones expire, enable **Allow Offline Access**.\n        \n*   Set up a connection\n    \n    *   Make sure your connection is capable of authenticating users by username and password (for example, [database connections](https://auth0.com/docs/get-started/applications/set-up-database-connections), or AD/LDAP, ADFS, or Azure Active Directory [enterprise connections](https://auth0.com/docs/connections/identity-providers-enterprise)).\n        \n*   Update or disable any [rules](https://auth0.com/docs/rules), so they only impact specific connections. If you get an `access_denied` error while testing the Password Owner Resource Grant, this could be due to an access control rule.\n    \n\n## Steps\n\n1.  [Configure tenant](#configure-tenant): Set the tenant's default connection.\n    \n2.  [Request tokens](#request-tokens): Exchange your authorization code for tokens.\n    \n3.  [Call API](#call-api): Use the retrieved Access Token to call your API.\n    \n4.  [Refresh tokens](#refresh-tokens): Use a Refresh Token to request new tokens when the existing ones expire.\n    \n\nOptional: [Explore sample use cases](#sample-use-cases)\n\nOptional: [Configure realm support](#configure-realm-support)\n\nOptional: [Configure MFA](#configure-mfa)\n\nOptional: [Configure attack protection](#configure-anomaly-detection)\n\n### Configure tenant\n\nThe Resource Owner Password Flow relies on a connection that is capable of authenticating users by username and password, so you must set the default connection for the tenant.\n\n1.  Go to [Auth0 Dashboard > Tenant Settings](https://manage.auth0.com/#/tenant), and scroll down to locate the **Default Directory** setting.\n    \n2.  Enter the name of the connection you would like to use. Make sure it is capable of authenticating users by username and password.\n    \n\n### Request tokens\n\nTo call your API, you must first get the user's credentials, typically through an interactive form. Once your application has the credentials, you must exchange them for tokens. To do so, you must `POST` to the [token URL](https://auth0.com/docs/api/authentication#resource-owner-password).\n\n#### Example POST to token URL\n\n*   [cURL](#65485bf5e58f401eaa5c7ae0c86a15c1_shell)\n*   [C#](#65485bf5e58f401eaa5c7ae0c86a15c1_csharp)\n*   [Go](#65485bf5e58f401eaa5c7ae0c86a15c1_go)\n*   [Java](#65485bf5e58f401eaa5c7ae0c86a15c1_java)\n*   [Node.JS](#65485bf5e58f401eaa5c7ae0c86a15c1_node)\n*   [Obj-C](#65485bf5e58f401eaa5c7ae0c86a15c1_objc)\n*   [...](#)\n\nto configure this snippet with your account\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=password \\\n  --data 'username={username}' \\\n  --data 'password={password}' \\\n  --data 'audience={yourApiIdentifier}' \\\n  --data scope=read:sample \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=password&username=%7Busername%7D&password=%7Bpassword%7D&audience=%7ByourApiIdentifier%7D&scope=read%3Asample&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=password&username=%7Busername%7D&password=%7Bpassword%7D&audience=%7ByourApiIdentifier%7D&scope=read%3Asample&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=password&username=%7Busername%7D&password=%7Bpassword%7D&audience=%7ByourApiIdentifier%7D&scope=read%3Asample&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\")\n  .asString();\n```\n\nto configure this snippet with your account\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'password',\n    username: '{username}',\n    password: '{password}',\n    audience: '{yourApiIdentifier}',\n    scope: 'read:sample',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\nto configure this snippet with your account\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=password\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&username={username}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&password={password}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience={yourApiIdentifier}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&scope=read:sample\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=password&username=%7Busername%7D&password=%7Bpassword%7D&audience=%7ByourApiIdentifier%7D&scope=read%3Asample&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=password&username=%7Busername%7D&password=%7Bpassword%7D&audience=%7ByourApiIdentifier%7D&scope=read%3Asample&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=password&username=%7Busername%7D&password=%7Bpassword%7D&audience=%7ByourApiIdentifier%7D&scope=read%3Asample&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\nto configure this snippet with your account\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=password\".data(using: String.Encoding.utf8)!)\npostData.append(\"&username={username}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&password={password}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience={yourApiIdentifier}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&scope=read:sample\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to `password`. |\n| `username` | The username entered by the user. |\n| `password` | The password entered by the user. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `client_assertion` | A JWT containing a signed assertion with your application credentials. Required when Private Key JWT is your application authentication method. |\n| `client_assertion_type` | The value is `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`. Required when Private Key JWT is the application authentication method. |\n| `client_secret` | Your application's Client Secret. Required when Client Secret is the application authentication method. [Application Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings) is `Post` or `Basic`. If your application is not highly trusted (for example, a SPA), then do not set this parameter. |\n| `audience` | The audience for the token, which is your API. You can find this in the **Identifier** field on your [API's settings tab](https://manage.auth0.com/#/apis). |\n| `scope` | Specifies the [scopes](https://auth0.com/docs/scopes) for which you want to request authorization, which dictate which claims (or user attributes) you want returned. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` or `email`, [custom claims](https://auth0.com/docs/tokens/concepts/jwt-claims#custom-claims) conforming to a [namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (e.g., `read:contacts`). Include `offline_access` to get a Refresh Token (make sure that the **Allow Offline Access** field is enabled in the [Application Settings](https://manage.auth0.com/#/applications)). |\n\n#### Response\n\nIf all goes well, you'll receive an `HTTP 200` response with a payload containing `access_token`, `refresh_token`, `id_token`, `token_type`, and `expires_in` values:\n\n```\n{\n  \"access_token\": \"eyJz93a...k4laUWw\",\n  \"refresh_token\": \"GEbRxBN...edjnXbL\",\n  \"id_token\": \"eyJ0XAi...4faeEoQ\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 36000\n}\n```\n\n#### Resource Owner Password flow and standard scopes\n\nBecause providing a password gives full access, any password-based exchange gives access to all scopes. For example, if you include no [API scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes) in the request, all API scopes will be included in the Access Token. Similarly, if you include only the `openid` scope in the request, all `openid` standard [OpenID Connect scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes) will be returned. In these cases, the `scope` parameter will be included in the response and will list the issued scopes.\n\n#### Get user information without an ID Token\n\nIf you need the user's information, include the `openid` scope in your request. If the API uses `RS256` as the [signing algorithm](https://auth0.com/docs/get-started/applications/signing-algorithms), the Access Token will include `/userinfo` as a valid audience, which means you can use it to invoke the [/userinfo endpoint](https://auth0.com/docs/api/authentication#get-user-info) and retrieve the user's claims.\n\n### Call API\n\nTo call your API, the application must pass the retrieved Access Token as a Bearer token in the Authorization header of your HTTP request.\n\n*   [cURL](#2bf48a5b4fa74287aaef215babfce95f_shell)\n*   [C#](#2bf48a5b4fa74287aaef215babfce95f_csharp)\n*   [Go](#2bf48a5b4fa74287aaef215babfce95f_go)\n*   [Java](#2bf48a5b4fa74287aaef215babfce95f_java)\n*   [Node.JS](#2bf48a5b4fa74287aaef215babfce95f_node)\n*   [Obj-C](#2bf48a5b4fa74287aaef215babfce95f_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://myapi.com/api \\\n  --header 'authorization: Bearer {accessToken}' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://myapi.com/api\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {accessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://myapi.com/api\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {accessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://myapi.com/api\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {accessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://myapi.com/api',\n  headers: {'content-type': 'application/json', authorization: 'Bearer {accessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {accessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://myapi.com/api\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://myapi.com/api\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {accessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"myapi.com\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {accessToken}\"\n    }\n\nconn.request(\"GET\", \"/api\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://myapi.com/api\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {accessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {accessToken}\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://myapi.com/api\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Refresh tokens\n\nYou have already received a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens) if you've been following this tutorial and completed the following:\n\n*   configured your API to allow offline access\n    \n*   included the `offline_access` scope when you initiated the authentication request through the [authorize endpoint](https://auth0.com/docs/api/authentication/reference#authorize-application).\n    \n\nYou can use the Refresh Token to get a new access token. Usually, a user will need a new access token only after the previous one expires or when gaining access to a new resource for the first time. It's bad practice to call the endpoint to get a new access token every time you call an API, and Auth0 maintains rate limits that will throttle the amount of requests to the endpoint that can be executed using the same token from the same IP.\n\nTo refresh your token, make a `POST` request to the `/oauth/token` endpoint in the Authentication API, using `grant_type=refresh_token`.\n\n#### Example POST to token URL\n\n*   [cURL](#d50f4e46d5774d5e9a97ec0a335ae123_shell)\n*   [C#](#d50f4e46d5774d5e9a97ec0a335ae123_csharp)\n*   [Go](#d50f4e46d5774d5e9a97ec0a335ae123_go)\n*   [Java](#d50f4e46d5774d5e9a97ec0a335ae123_java)\n*   [Node.JS](#d50f4e46d5774d5e9a97ec0a335ae123_node)\n*   [Obj-C](#d50f4e46d5774d5e9a97ec0a335ae123_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=refresh_token \\\n  --data 'client_id={yourClientId}' \\\n  --data 'refresh_token={yourRefreshToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'refresh_token',\n    client_id: '{yourClientId}',\n    refresh_token: '{yourRefreshToken}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=refresh_token\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&refresh_token={yourRefreshToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=refresh_token\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&refresh_token={yourRefreshToken}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to `refresh_token`. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `refresh_token` | The refresh token to use. |\n| `scope` | (optional) A space-delimited list of requested scope permissions. If not sent, the original scopes will be used; otherwise you can request a reduced set of scopes. Note that this must be URL encoded. |\n\n#### Response\n\nIf all goes well, you'll receive an `HTTP 200` response with a payload containing a new `access_token`, its lifetime in seconds (`expires_in`), granted `scope` values, and `token_type`.\n\n```\n{\n  \"access_token\": \"eyJ...MoQ\",\n  \"expires_in\": 86400,\n  \"scope\": \"openid offline_access\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n### Sample use cases\n\n#### Customize tokens\n\nYou can use rules to change the returned scopes of Access Tokens and/or add claims to Access and ID Tokens. (To learn more about rules, read [Auth0 Rules](https://auth0.com/docs/customize/rules).) To do so, add the following rule, which will run after the user authenticates:\n\n```\nfunction(user, context, callback) {\n  // add custom claims to Access Token and ID Token\n  context.accessToken['http://foo/bar'] = 'value';\n  context.idToken['http://fiz/baz'] = 'some other value';\n  // change scope\n  context.accessToken.scope = ['array', 'of', 'strings'];\n  callback(null, user, context);\n}\n```\n\nScopes will be available in the token after all rules have run.\n\n### Configure realm support\n\nAuth0 provides an extension grant that offers similar functionality to the Resource Owner Password grant, but allows you to keep separate user directories (which map to separate connections) and specify which one to use during the flow.\n\nTo use this variation, you must:\n\n*   Set the `grant_type` request parameter to `http://auth0.com/oauth/grant-type/password-realm`.\n    \n*   Send an additional request parameter called `realm`, and set it to the name of the realm to which the user belongs. For example, if you have configured a database connection for internal employees named `employees`, and your user belongs to it, then set `realm` to `employees`.\n    \n\n### Configure MFA\n\nIf you need to use the Resource Owner Password Flow, but require stronger authentication, you can add multi-factor authentication (MFA). To learn how, read [Authenticate Using the Resource Owner Password Flow with MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n\n### Configure attack protection\n\nWhen using the Resource Owner Password Flow with brute-force protection, some attack protection features may fail. Some common issues, however, can be avoided. To learn more, read [Avoid Common Issues with Resource Owner Password Flow and Attack Protection](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection).\n\n## Learn more\n\n*   [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth)\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)\n*   [Tokens](https://auth0.com/docs/secure/tokens)",
  "title": "Call Your API Using Resource Owner Password Flow",
  "description": "Learn how to call your own API from highly-trusted applications using the Resource Owner Password Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt",
  "markdown": "# Authenticate with Private Key JWT\n\nYou need to complete two steps when authenticating with `private_key_jwt:`\n\n1.  Build the client assertion. This assertion is a JWT signed by the private key when you generated the key pair. To learn how to generate a key pair, read [Configure Private Key JWT Authentication](https://auth0.com/docs/get-started/applications/configure-private-key-jwt).\n    \n2.  Use the assertion to authenticate against Auth0.\n    \n\n## Build the assertion\n\nYou can use one of Auth0’s SDKs to build an assertion automatically for you. If you don’t use our SDKs, you will need to construct the assertion yourself.\n\nThe assertion is a JSON Web Token (JWT) that should contain the following properties and claims:\n\n*   Header\n    \n    *   `alg`: The algorithm used to sign the assertion. The algorithm must match the algorithm specified when you created your application credential. \n        \n    *   `kid`**:** (optional) The Auth0 generated `kid` of the credential. The `kid` is created when you created the credential.\n        \n*   Payload\n    \n    *   `iss`**:** Your application's Client ID. You can find this value in your application settings under [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/dashboard/#/applications/) and select the **Settings** tab.\n        \n    *   `sub`**:** Your application's Client ID. You also can find this value in your application settings. You can find this value in your application settings under [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/dashboard/#/applications/) and select the **Settings** tab.\n        \n    *   `aud`**:** The URL of the Auth0 tenant or custom domain that receives the assertion. For example: `https://{yourTenant}.auth0.com/`**.** Include the trailing slash.\n        \n    *   `iat` (optional) and `exp`: Issued At and Expiration claims set to the correct timestamps. The client assertion is a one-time use token, and we recommend the shortest possible expiry time. Auth0 supports a maximum of 5 minutes for the lifetime of a token.\n        \n    *   `jti`: A unique claim ID created by the client. We recommend using the Universally Unique Identifier (UUID) format.\n        \n\nThe token must then be signed with the private key you generated when you created or configured your application for Private Key JWT Authentication. To learn how, review the [JSON Web Token specification](https://www.rfc-editor.org/rfc/rfc7519#section-7.1).\n\nWe recommend you construct the token using standard tooling or third party libraries that support this functionality out of the box, rather than implementing from scratch yourself.  To learn more about supporting libraries, read the listing at [JWT.io](https://jwt.io/libraries).\n\n### Example\n\nIn the example below, the Node.js script uses a [jose package](https://github.com/panva/jose) to generate the assertion:\n\n```\nconst { SignJWT } = require('jose')\nconst crypto = require(\"crypto\");\nconst uuid = require(\"uuid\");\n\nasync function main() {\n const privateKeyPEM = crypto.createPrivateKey(/**\n   Read the content of your private key here. We recommend to store your private key\n   in a secure infrastructure. \n */);\n\n const jwt = await new SignJWT({})\n   .setProtectedHeader({ \n      alg: 'RS256', // or RS384 or PS256\n      kid: '(OPTIONAL) KID_GENERATED_BY_AUTH0' \n   })\n   .setIssuedAt()\n   .setIssuer('CLIENT_ID')\n   .setSubject('CLIENT_ID')\n   .setAudience('https://YOUR_TENANT.auth0.com/') // or your CUSTOM_DOMAIN\n   .setExpirationTime('1m')\n   .setJti(uuid.v4())\n   .sign(privateKeyPEM);\n  console.log(jwt)\n}\n\nmain();\n```\n\nExample client assertion signed with a private key:\n\n![private key example](https://images.ctfassets.net/cdy7uua7fh8z/4O8zb1gZnEmUQ6FrRkfmlc/a30b73e09d51ca0b4bf929b91571a80a/2023-03-13_16-53-54.png)\n\nCorresponds to:\n\n```\n{\n  \"alg\": \"RS256\",\n  \"kid\": \"my kid\"\n}\n{\n  \"iat\": 1626684584,\n  \"iss\": \"my client id\",\n  \"sub\": \"my client id\",\n  \"aud\": \"https://mytenant.auth0.com/\",\n  \"exp\": 1626684644,\n  \"jti\": \"e4dc8ed1-b108-4901-8bbc-c07a791817e7\"\n}\n```\n\nAfter you generate the JWT with the required information, you are ready to authenticate your application against Auth0.\n\n## Exchange assertion for access tokens\n\nTo exchange the JWT assertion for an access token, call the Authentication API [token endpoint](https://auth0.com/docs/api/authentication#authenticate-user) with the following parameters:\n\n*   `$client_assertion`: JWT assertion\n    \n*   `$resource_server_identifier`: resource server identifier. To learn more, read [Register APIs](https://auth0.com/docs/get-started/auth0-overview/set-up-apis).\n    \n\n```\ncurl --location --request POST 'https://$tenant/oauth/token' \\\n  --header 'Content-Type: application/x-www-form-urlencoded' \\\n  --data-urlencode 'grant_type=client_credentials' \\\n  --data-urlencode 'client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer' \\\n  --data-urlencode 'client_assertion=$client_assertion' \\\n  --data-urlencode 'audience=$resource_server_idenifier'\n```\n\n## Supported endpoints\n\nIn addition to the [https://$tenant/oauth/token](https://auth0.com/docs/api/authentication#get-token) endpoint, the following Auth0 Authentication API endpoints support `private_key_jwt` authentication for configured applications:\n\n*   [POST /oauth/revoke](https://auth0.com/docs/api/authentication#revoke-refresh-token)\n    \n*   [POST /mfa/challenge](https://auth0.com/docs/api/authentication#challenge-request)\n    \n*   [POST /passwordless/start](https://auth0.com/docs/api/authentication#get-code-or-link)\n    \n\n## Assertion limits\n\nThe maximum length of the JWT assertion is 2048 bytes.\n\nClaims within the assertion have the following limits:\n\n*   `iss`: 64 characters\n    \n*   `sub`: 64 characters\n    \n*   `jti`: 64 characters\n    \n*   `alg`: 16 characters",
  "title": "Authenticate with Private Key JWT",
  "description": "Describes how to build an assertion to use Private Key JWT Authentication.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/protocols/saml",
  "markdown": "# SAML Configuration\n\n## SAML service providers\n\nApplications, especially custom ones, can authenticate users against an external IdP using protocols such as OpenID Connect (OIDC) or OAuth 2.0. However, you might want to leverage an enterprise SAML provider for authentication, even if you wrote your application to use either protocol.\n\n![Protocols SAML SPs Diagram](https://images.ctfassets.net/cdy7uua7fh8z/F29Tn5sjo1hqHSxslyHhR/52e6ef8ca4e1c9b68be4290011b21afa/saml-case1.png)\n\n## SAML identity providers\n\nSome applications (such as Salesforce, Box, and Workday) allow users to authenticate against an external IdP using the SAML protocol. You can then integrate the application with Auth0, which serves as the application's SAML IdP. Application users will be redirected to Auth0 to log in, and Auth0 can authenticate them using any backend authentication connection, such as an LDAP directory, a database, or another SAML IdP or Social Provider. Once the user is authenticated, Auth0 returns a SAML assertion to the application that indicates such.\n\n![Protocols SAML IdP Diagram](https://images.ctfassets.net/cdy7uua7fh8z/2fREft2nQOfBNh1cZfgsZH/7dcb4e85d171601025423d71a1d8fe19/saml-case2.png)\n\nHere is a list of IdP services known to support the SAML protocol. There may be additional services beyond what is shown below. The following providers have participated in a Kantara interoperability test and are therefore likely to conform well to the SAML spec.\n\n*   adAS\n    \n*   ADFS\n    \n*   Dot Net Workflow\n    \n*   Elastic SSO Team & Enterprise\n    \n*   Entrust GetAccess & IdentityGuard (check protocol supported)\n    \n*   EIC (check protocol supported)\n    \n*   Ilex Sign&go\n    \n*   iWelcome\n    \n*   NetIQ Access Manager\n    \n*   OpenAM\n    \n*   RCDevs Open SAMPL IdP\n    \n*   Optimal IdM VIS Federation Services\n    \n*   Oracle Access Manager (Oracle Identity Federation merged into this)\n    \n*   PingFederate (IDP Light)\n    \n*   RSA Federated Identity (IDP Light)\n    \n*   SecureAuth\n    \n*   Symplified\n    \n*   Tivoli Federated Identity Manager\n    \n*   TrustBuilder\n    \n*   Ubisecure SSO\n    \n*   WSO2 Identity Server\n    \n\nAuth0 provides specific instructions to configure the following SAML identity providers with Auth0:\n\n*   [ADFS](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-adfs-saml-connections)\n    \n*   [Okta](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-okta-as-saml-identity-provider)\n    \n*   [OneLogin](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-onelogin-as-saml-identity-provider)\n    \n*   [PingFederate 7](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-pingfederate-as-saml-identity-provider)\n    \n*   [Salesforce](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-salesforce-as-saml-identity-provider)\n    \n*   [SiteMinder](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-siteminder-as-saml-identity-provider)\n    \n*   [SSOCircle](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-ssocircle-as-saml-identity-provider)\n    \n\n## Auth0 as service provider\n\nIf Auth0 serves as the service provider in a SAML federation, Auth0 can route authentication requests to an identity provider without already having an account pre-created for a specific user. Using the assertion returned by the identity provider, Auth0 can capture information needed to create a user profile for the user (this process is sometimes called just-in-time provisioning). To learn more, read [Select from Multiple Connection Options](https://auth0.com/docs/libraries/lock/selecting-from-multiple-connection-options).\n\nEven though Auth0 doesn't require pre-created user accounts prior to the authentication process, the application integrated with Auth0 might. If this is the case, you have several options when it comes to handling this:\n\n*   After the identity provider creates the user, you can use an out-of-band process can create the accompanying user in the application (or Auth0) and add any user profile attributes required by the application. If, after authentication, any attributes are missing in the profile, the application can obtain them from the appropriate source and store them in the Auth0 user profile. The additional attributes are then sent to the application (in addition to any added by the identity provider) the next time the user logs in.\n    \n*   You can use an Auth0 rule to call an API to retrieve any missing information and dynamically add it to the Auth0 profile (which is then returned to the application). Rules execute after successful authentication, and your application can retrieve profile attributes each time or you can save the attributes to the Auth0 profile.\n    \n*   Auth0 can pass the basic profile information from the identity provider to the application, which then retrieves any missing information from another source. With the two sets of information, the application creates a local user profile.\n    \n\nYou can specify email domains as part of the Auth0 SAMLP Connection configuration to control the IDP that handles a select group of users. For example, if you add email domain `example.com` to the Auth0 SAMLP Connection configuration for Company X, all users with emails with the `example.com` domain get handled by the specific IDP for Company X.\n\n## Auth0 as identity provider\n\nIf Auth0 serves as the identity provider in a SAML federation, user accounts may be created multiple ways:\n\n*   Using a back-end authentication system, such as an LDAP directory, a database, or another SAML identity provider.\n    \n*   Using the Auth0 Dashboard.\n    \n*   Calling the Auth0 Management API.\n    \n*   Implementing self-service user signup.\n    \n\nIf your application is written to retrieve user profile information from a local store, you'll need to create the local profile after the accounts have been created in Auth0. Some of the ways you might do this include:\n\n*   An out-of-band process creating user profiles in the application;\n    \n*   An Auth0 rule that executes on first login that calls an application API to create the user profile in the application;\n    \n*   Modifying the application to create user profiles dynamically, based on information in the SAML assertion.\n    \n\n## Test SAML SSO using Auth0 as service and identity provider\n\nYou can use Auth0 as both the SAML service provider and the SAML identity provider for testing purposes.\n\n![Protocols Auth0 as SAML SP and IdP Diagram](https://images.ctfassets.net/cdy7uua7fh8z/7Ds9dLC3HaxGBLsG3ry7B9/0c08d51b6d6bb57ef6eff3796ca4cd21/saml-case3.png)\n\n## Learn more\n\n*   [SAML Single Sign-On Integrations](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations)\n*   [Configure Auth0 as SAML Service Provider](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider)\n*   [Configure Auth0 as SAML Identity Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider)\n*   [Test SAML SSO with Auth0 as Service Provider and Identity Provider](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/configure-auth0-as-service-and-identity-provider)\n*   [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings)\n*   [Customize SAML Assertions](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/customize-saml-assertions)",
  "title": "SAML Configuration",
  "description": "Describes how Auth0 works with Security Assertion Markup Language (SAML) protocol.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/tokens/refresh-tokens/revoke-refresh-tokens",
  "markdown": "# Revoke Refresh Tokens\n\nYou can revoke refresh tokens in case they become compromised. Auth0 handles token revocation as though the token has been potentially exposed to malicious adversaries.\n\nYou can also use [refresh token rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation) so that every time a client exchanges a refresh token to get a new access token, a new refresh token is also returned. Therefore, you no longer have a long-lived refresh token that, if compromised, could provide illegitimate access to resources. As refresh tokens are continually exchanged and invalidated, the threat is reduced.\n\nYou can revoke a refresh token in the following ways:\n\n*   In the Dashboard\n    \n*   Post a request to the Authentication API `/oauth/revoke` endpoint\n    \n*   Post a request to the Management API `/api/v2/device-credentials` endpoint\n    \n\n## Refresh tokens and grants\n\nA grant provides an application with access to a resource on another entity without exposing user credentials. Tokens are issued in the context of a grant, and when a grant is revoked, so are all tokens issued in the context of that grant. When, on the other hand, a token is revoked, this does not necessarily mean that the grant is revoked.\n\nYou can choose the revocation behavior in the Dashboard tenant settings when a device is unlinked from a user in Auth0, using either the Dashboard or the Management API.\n\n1.  Go to [Dashboard > Tenant Settings > Advanced](https://manage.auth0.com/#/tenant/advanced) and scroll to the **Settings** section.\n    \n2.  Enable or disable the **Refresh Token Revocation Deletes Grant** toggle depending on how you want the revocation to work.\n    \n    1.  Enable the toggle to delete the underlying grant when you revoke the refresh token. Each revocation request invalidates not only the specific token but all other tokens based on the same authorization grant. This means that all refresh tokens that have been issued for the same user, application, and audience will be revoked.\n        \n    2.  Disable the toggle to retain the underlying grant when you revoke the refresh token. When a device is unlinked, only the associated refresh token is revoked, leaving the grant intact.\n        \n\n## Use the Dashboard\n\nYou can use the Dashboard to revoke a user's authorized access to the application that issued the token. This renders the refresh token invalid, which is functionally identical to revoking the token itself.\n\n1.  Go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users), and click the name of the user to view.\n    \n2.  Select the **Authorized Applications** tab. This page lists all the applications to which the user has authorized access.\n    \n3.  To revoke the user's access to an authorized application, and hence invalidate the refresh token, click **Revoke**.\n    \n\n![Dashboard - Users - Revoke Refresh Token](https://images.ctfassets.net/cdy7uua7fh8z/76GtqCfeJFc3UPGc8MefeZ/299dfb54e07ae504253022bc2f048e56/dashboard-users-edit_view-authorized-applications.png)\n\n## Use the Authentication API\n\nTo revoke a refresh token, send a `POST` request to `https://{yourDomain}/oauth/revoke`.\n\nThe `/oauth/revoke` endpoint revokes the entire grant, not just a specific token. Use the `/api/v2/device-credentials` endpoint to revoke refresh tokens. The API first validates the application credentials and then verifies whether the token was issued to the application making the revocation request. If this validation fails, the request is refused, and the application is informed of the error. Next, the API invalidates the token. The invalidation takes place immediately, and the token cannot be used again after the revocation. Each revocation request invalidates all the tokens that have been issued for the same authorization grant.\n\n*   [cURL](#e5f1455a64d142d99b7212a09fe1c914_shell)\n*   [C#](#e5f1455a64d142d99b7212a09fe1c914_csharp)\n*   [Go](#e5f1455a64d142d99b7212a09fe1c914_go)\n*   [Java](#e5f1455a64d142d99b7212a09fe1c914_java)\n*   [Node.JS](#e5f1455a64d142d99b7212a09fe1c914_node)\n*   [Obj-C](#e5f1455a64d142d99b7212a09fe1c914_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/revoke' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"client_id\": \"{yourClientId}\", \"client_secret\": \"{yourClientSecret}\", \"token\": \"{yourRefreshToken}\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/revoke\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"token\\\": \\\"{yourRefreshToken}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/revoke\"\n\n\tpayload := strings.NewReader(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"token\\\": \\\"{yourRefreshToken}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/revoke\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"token\\\": \\\"{yourRefreshToken}\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/revoke',\n  headers: {'content-type': 'application/json'},\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    token: '{yourRefreshToken}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"token\": @\"{yourRefreshToken}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/revoke\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/revoke\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"token\\\": \\\"{yourRefreshToken}\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"token\\\": \\\"{yourRefreshToken}\\\" }\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/revoke\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/revoke\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"token\\\": \\\"{yourRefreshToken}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"token\": \"{yourRefreshToken}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/revoke\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nWhere:\n\n| Attribute | Description |\n| --- | --- |\n| `client_id`  <br>Required | Your application's Client ID. The application should match the one the Refresh Token was issued for. |\n| `client_secret` | Your application's Client Secret. Required for [confidential applications](https://auth0.com/docs/applications/concepts/app-types-confidential-public#confidential-applications). |\n| `token`  <br>Required | The Refresh Token you want to revoke. |\n\nThe application should match the one for which the refresh token was issued.\n\n### Revoke tokens without the client secret\n\nFor applications that cannot keep the client secret safe (such as native apps), the `/oauth/revoke` endpoint supports access without the client secret. However, the application itself must have the property `tokenEndpointAuthMethod` set to `none`. You can change the `tokenEndpointAuthMethod` value, either from the [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), or using the Management API.\n\nIf the request is valid, the refresh token is revoked, and the response is `HTTP 200`, with an empty response body. Otherwise, the response body contains the error code and description.\n\n```\n{\n      \"error\": \"invalid_request|invalid_client\",\n      \"error_description\": \"Description of the error\"\n    }\n```\n\nThe possible responses are:\n\n| HTTP Status | Description |\n| --- | --- |\n| 200 | The Refresh Token is revoked, does not exist, or was not issued to the application making the revocation request. The response body is empty. |\n| 400 | The required parameters were not sent in the request (`\"error\": \"invalid_request\"`). |\n| 401 | The request is not authorized (`\"error\": \"invalid_client\"`). Check that the application credentials (`client_id` and `client_secret`) are present in the request and hold valid values. |\n\n## Use the Management API\n\nTo revoke a refresh token using the Auth0 Management API, you need the `id` of the refresh token you wish to revoke. To obtain a list of existing refresh tokens, call the [](https://auth0.com/docs/api/management/v2#!/Device_Credentials/get_device_credentials)[](https://auth0-docs-staging.herokuapp.com/docs/api/management/v2#!/Device_Credentials/get_device_credentials)`/api/v2/device-credentials` [endpoint](https://auth0.com/docs/api/management/v2#!/Device_Credentials/get_device_credentials), specifying `type=refresh_token` and `user_id` with an access token containing `read:device_credentials` scope. To narrow the results, you can also specify the `client_id` associated with the token (if known).\n\n```\nGET https://{yourDomain}/api/v2/device-credentials?\n      type=refresh_token\n      &client_id=\n      &user_id=\n    \n    {\n      \"Authorization\":   \"Bearer {your_access_token}\"\n    }\n```\n\nResponse body:\n\n```\n[\n      {\n    \"id\": \"dcr_dFJiaAxbEroQ5xxx\",\n    \"device_name\": \"my-device\" // the value of 'device' provided in the /authorize call when creating the token\n      }\n    ]\n```\n\nTo revoke a refresh token, call the `/api/v2/device-credentials` endpoint with an access token containing `delete:device_credentials` scope and the value of ID obtained above:\n\n```\nDELETE https://{yourDomain}/api/v2/device-credentials/{id}\n    \n    {\n      \"Authorization\":   \"Bearer {your_access_token}\"\n    }\n```\n\nThe response will be `HTTP 204: The credential no longer exists.`\n\n## Considerations and limitations\n\nWith the [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow), the only way to force a device to reauthorize is to revoke the refresh token assigned to the device. See [Unlink Devices from Users](https://auth0.com/docs/manage-users/user-accounts/unlink-devices-from-users) for details. The device will not be forced to reauthorize until the current access token expires and the application tries to use the revoked refresh token.\n\nWhen using [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation), if a previously invalidated token is used, the entire set of refresh tokens issued since that invalidated token was issued will immediately be revoked, requiring the end-user to re-authenticate.\n\n*   Use the Authentication API `/oauth/revoke` [endpoint](https://auth0.com/docs/api/authentication#revoke-refresh-token) to revoke a refresh token. This endpoint does not delete the underlying grant. You can change this behavior to also delete the underlying grant in the Dashboard: [Dashboard > Tenant Settings > Advanced](https://manage.auth0.com/#/tenant/advanced). Scroll to **Settings** and enable the **Refresh Token Revocation Deletes Grant** toggle.\n    \n*   Use the Management API `/api/v2/device-credentials` [endpoint](https://auth0.com/docs/api/management/v2#!/Device_Credentials/get_device_credentials) to revoke refresh tokens configured for rotation.\n    \n\n## Learn more\n\n*   [Get Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/get-refresh-tokens)\n*   [Use Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-tokens)\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)",
  "title": "Revoke Refresh Tokens",
  "description": "Learn how to revoke a refresh token if it gets compromised using the Authentication API, the Management API, or the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/confidential-and-public-applications/view-application-type",
  "markdown": "# Check if Application is Confidential or Public\n\nYou can check whether an application is registered with Auth0 as a confidential or public application. To learn more, read [Confidential and Public Application](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n\nAuth0 determines if an application is confidential or public based on the **Authentication Method** setting, which defines how an application authenticates against the Auth0 Authentication API [Get Token](https://auth0.com/docs/api/authentication#get-token) endpoint.\n\n1.  In the Auth0 Dashboard, go to [Applications > Applications](https://manage.auth0.com/#/applications), and then select the name of the application to view.\n    \n2.  If the **Credentials** view is not available, the application is a public application.\n    \n3.  If the **Credentials** view is available, then select it and locate the **Authentication Method** field.\n    \n    ![Configure Private Key JWT Authentication - Auth0 Dashboard instructions](https://images.ctfassets.net/cdy7uua7fh8z/33kfi48tkbMIOQJ8PBxj76/45004e5e46516daa3fa66408c5601487/2023-04-10_15-11-53.png)\n\nUse the applicable method:\n\n*   **None**: Public application without a client secret.\n    \n*   **Client Secret Post**: Application using POST request body parameters to send a client secret.\n    \n*   **Client Secret Basic**: Application using the HTTP BASIC authentication scheme to send a client secret.\n    \n*   **Private Key JWT**: Application using asymmetric authentication.\n    \n\nThese values map to confidential and public applications as follows:\n\n| **Application Type** | **Example** | **Token Endpoint Authentication Method** |\n| --- | --- | --- |\n| **Public** | Single-page or native | **None** |\n| **Confidential** | Regular web or machine-to-machine | **Basic**, **Post**, **Private Key JWT**, **Unspecified** |\n\nPublic applications cannot maintain the confidentiality of the credentials required for Token endpoint authentication methods like **Post** and **Basic**.",
  "title": "Check if Application is Confidential or Public",
  "description": "Describes how to check whether an application is registered with Auth0 as a confidential or public app using the Auth0 Management Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/apple-siwa/add-siwa-to-native-app",
  "markdown": "# Add Sign In with Apple to Native iOS Apps\n\nYou can add functionality to your native iOS application to allow your users to authenticate using Sign In with Apple. For more implementation details, you can try the Auth0 [iOS Swift - Sign In with Apple Quickstart](https://auth0.com/docs/quickstart/native/ios-swift-siwa).\n\n## How it works\n\nFor a native app, the Sign in with Apple login flow works as follows:\n\n![Diagram of the Sign In with Apple Authentication Flow](https://images.ctfassets.net/cdy7uua7fh8z/I7xtPQoqoAFiHQiT2p7p5/8646a5231491dfbe64bd6a825ccc8ce7/apple-siwa-authn-flow.png)\n\n*   **Steps 1 & 2**: User authenticates via Apple's SDK on their iOS device, and receive an authorization code in the response. The user does not have to leave the app and use a browser to log in.\n    \n*   **Step 3**: The application calls Auth0's `/oauth/token` endpoint to exchange the Apple authorization code for Auth0 tokens.\n    \n*   **Step 4 & 5**: The Auth0 platform exchanges the Authorization code with Apple for tokens. Auth0 validates the tokens, and uses the claims in the tokens to construct the identity of the user.\n    \n*   **Step 6**: Auth0 saves the user profile, executes rules and authorization, then issues Auth0 access tokens (refresh tokens and ID tokens) as requested. These tokens are used to protect your APIs and users managed by Auth0.\n    \n\n## Prerequisites\n\nBefore you configure Sign In with Apple for your native app in Auth0, you must:\n\n*   Have an [Apple Developer](https://developer.apple.com/programs/) account, which is a paid account with Apple. (There is no free trial available unless you are part of their [iOS Developer University Program](https://developer.apple.com/support/compare-memberships/).)\n    \n*   [Register Your App in the Apple Developer Portal](https://marketplace.auth0.com/integrations/apple-social-connection) if you have not already done so. Make a note of the following IDs and key for the application connection settings in the Auth0 Dashboard:\n    \n    *   App ID\n        \n    *   Apple Team ID\n        \n    *   Client Secret Signing Key\n        \n    *   Key ID\n        \n*   If you are using the Classic Login flow or embedding `Lock.js` in your application, make sure you are using `Lock.js` version 11.16 or later.\n    \n\n## Configure and enable the connection in Auth0\n\nOnce you have the credentials you need from your Apple Developer account, you need to configure the application client and the connection settings in Auth0.\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), choose your application, and select the gear icon to view the settings page.\n    \n2.  At the bottom of the page, select **Show Advanced Settings** and then the **Device Settings** view. Under **Native Social Login**, enable the **Enable Sign In with Apple** toggle.\n    \n    ![Application Client Settings: Advanced Device Settings](https://images.ctfassets.net/cdy7uua7fh8z/2xkQ13r9yCb4GBZdeczZjJ/5e95b6039b77bf9cfd6067fba343db8e/dashboard-applications-edit_view-settings-advanced_device-settings_native_apple-enabled.png)\n3.  Under **iOS**, fill in the **App ID** field with the native app's App ID/Bundle Identifier.\n    \n4.  Navigate to [Auth0 Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social), and select **Create Connection**.\n    \n5.  Select the **Apple** connection and consent.\n    \n6.  On the **Settings** tab, fill in the following fields:\n    \n    *   **Apple Team ID**\n        \n    *   **Client Secret Signing Key**\n        \n    *   **Key ID**\n        \n        ![Apple Social Connection Settings](https://images.ctfassets.net/cdy7uua7fh8z/3mTTVYnrwbVYnUx5Mzy0V9/0ab8174a812908c9290663d3d9d05286/dashboard-connections-social-create_enter-details_apple.png)\n7.  Select the **Applications** view to enable this connection for your application.\n    \n8.  Click **Save**.\n    \n\n## Logout\n\nSince the Native iOS login implementation does not make use of standard browser-based flows, application owners must also take care to perform logout appropriately. When an application needs to perform a logout, it must take the following actions:\n\n*   [Revoke the Auth0 Refresh Token](https://auth0.com/docs/api/authentication#revoke-refresh-token)\n    \n*   Delete the Auth0 refresh token stored in the iCloud Keychain\n    \n*   Delete the Apple user identifier stored in the iCloud keychain Also, keep in mind that logout can result from user actions (for example, clicking a \"log out\" button) or from a user revoking access to the given app. The latter will be indicated through the native [ASAuthorizationAppleIDProvider.getCredentialState](https://developer.apple.com/documentation/authenticationservices/asauthorizationappleidprovider/3175423-getcredentialstate) method.\n    \n\n## Learn more\n\n*   [Rate Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy)",
  "title": "Add Sign In with Apple to Native iOS Apps",
  "description": "Learn how to add native login functionality to your native app with Apple. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client",
  "markdown": "# Configure mTLS for a Client\n\nThis article explains how to use the [Management API](#configure-mtls-with-management-api) and [Auth0 Dashboard](#configure-mtls-with-auth0-dashboard) to configure mTLS authentication for a client.\n\n## Configure mTLS with Management API\n\nUse the [Auth0 Management API](https://auth0.com/docs/api/management/v2) to configure mTLS for a client:\n\n*   [Self-signed certificates](#self-signed-certificates)\n    \n*   [Certificate authority signed certificates](#certificate-authority-signed-certificates)\n    \n*   [Revert a client to use a Client Secret](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#revert-a-client-to-use-a-client-secret)\n    \n*   [Enable Token Binding](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#enable-token-binding-)\n    \n\n### Self-signed certificates\n\nUse self-signed certificates to verify the client’s identity during mTLS authentication. However, self-signed certificates have the following limitations\n\n*   Self-signed certificates are not accepted by some cloud providers such as Amazon.\n    \n*   To ensure the stability of our platform, Auth0 limits customers to two registered certificates.\n    \n\n#### Generate a certificate\n\nTo authenticate using self-signed mTLS, you must create a new self-signed client certificate. \n\nThe following code sample generates a new self-signed certificate:\n\n```\nopenssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -sha256 -days 365 -nodes -subj \"/C=XX/ST=StateName/L=CityName/O=CompanyName/OU=CompanySectionName/CN=CommonNameOrHostname\"\n```\n\nIf using curl or Wget, the PEM certificate must be JSON escaped before you pass it to Auth0. For example, replace a newline is with `\\r\\n`:\n\n```\n-----BEGIN PRIVATE KEY-----\\r\\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDDXAVKQo2SUMHH\\r\\no9ecWYNiL5\\/yva5NSj8uQjKoeRAsOIOAyOBTLxgwmno13xZ8VDkcT1cHTlC+2CkE\\r\\noBII4OUbHPVof+dtknkL+jUBdIPX1QvlGSUbzduZE4hEEQ8zH6w4EAA2VN72Bymn\\r\\nT8i\\/+Tz9Dx6M1nkuXPCwM7sYEuq5OrqT5yVB6KByKKElp\\/tauJkHp0st04iGDgl2\\r\\nFJUt3QJFCFewTDDdGq62otVJxHfouXPmHBQjzf+f1CZy+N0q2z+JGRt44YZq+F9y\\r\\ne3RWawvv2x3TXgRBLpvIKqf99LoPVdwozHl8QODu52dyelvLQ866XLhAALuMwic\\/\\r\\nbQbolnMpAgMBAAECggEAf6LliekFmezNTmQLgIkzP7kh5XRsJu81bEGv20aNfHbH\\r\\n5CJZ\\/b8tLMQgyIWiqURVs9taXtmaA7YyxmTWo5pb1WUMKWQ3je0+zMaCTxsS8Lau\\r\\n+NV+2zWaHd8XDnGe3qX43QAHQ3gb294+JqQH4vUyFZwFN7sAnXv3fQevW0Ewvics\\r\\nOua\\/xNa7y5hbJUPZiQjRhO+n+gTEqpfsnPWNlm9hk\\/wVnnjKvMfstN4zUbznRAoN\\r\\nW8TK82tiVWAXW4CjgIBtVRZjTA9x3UOtbhcvNzaTRxc+scCpIpAVuurS+ZIKZdpm\\r\\nNnhiOk3akpLU3KZrm8C5JQRn8cupY9WkfCiLXbMFAQKBgQD9JfVMv6zDeNvExneR\\r\\n7fZDIT2UAEhYExwRJwQPyxkVPwev9HBYuuaaknIbomWTkt\\/B6Q3k3p6VI4lxhnVl\\r\\nbkpOYl5UquP3VoVROEJts224hKgVcLw6s+i+lZDOAleNgbN7rj82l4BIu+SEj\\/7c\\r\\nz94hAa\\/wRRvsW+QnxF1sZnpY+QKBgQDFj2h8I4noFJk3sbbk3qQdi5+49ibWSuhc\\r\\nXVpU+0dQ1lRlhXYT9cDMc22HRt8hjXUNRhdpXvOqVaFiBjv9wBsmFyaJO3tOK3uE\\r\\ndBgD4lF03bnbGI7\\/I3DivW\\/tyEMS5JXI\\/qrpdWor+wR30c5M\\/45y2AGpjwnoGf+D\\r\\nX8SAMzknsQKBgQCrSljuIrBK3+eNAWH821CL4d0h3QMWnW+bZ5QG\\/70sNCcGd1bh\\r\\noy3Qn5EYg81JitNfCUw+dihF7\\/LbX0jmZjdfTI5Zqfxw6xlweKnyQrvWY+S8BTlI\\r\\nW138P4Xo74rAlGeXI7NgRCkojgK1dB3W2cyK9vJOmOSpDRCXm\\/Y\\/GCRnOQKBgCE\\/\\r\\n75\\/lA1LSFK9w8401g32NgEZK92JdnRnehFOFLw2F5RJpEeRuGhLO4oJABVHKUwb2\\r\\n4v3TA0OJwe2Tiwk8CdWxU8UJA8m2O8WhHGGa94apwpwDWB3MwzUGGQ52BAPsAOGh\\r\\nKva70jCwwKHB5+zBniHqBO2aq1oq9fwQZCwHcvkhAoGBAIa8QMHNrX7AuCSAeR4\\/\\r\\n\\/7XrGU1a4oExz417AYgZOuGaYQAI5BMIjRZZ3JTzO\\/QsmkzeS1tFuBlih8li\\/t4l\\r\\nE2TdnKhy376A6QWfbTDkJN6gzFeaMKwe98mOHKeq0KZITGYVTSa2AYH5zaro0Yku\\r\\nonOH1NdyEKFFgxGLg7wveYUW\\r\\n-----END PRIVATE KEY-----\n```\n\n#### Create a new client\n\nTo create a new client, make a POST call to the [`/clients`](https://auth0.com/docs/api/management/v2/clients/post-clients) endpoint with the following payload:\n\n*   `$client_name`**:** the name for the new client\n    \n*   `$credential_name`**:** the name for the public key \n    \n*   `$credential_certificate`: the content of `$certificate_pem` generated in the previous step\n    \n\n```\ncurl --location --request POST 'https://$tenant/api/v2/clients' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"name\": \"$client_name\",\n  \"app_type\": \"non_interactive\",\n  \"client_authentication_methods\": {\n    \"self_signed_tls_client_auth\": {\n      \"credentials\": [{ \n        \"name\": \"$credential_name\", \n        \"credential_type\": \"x509_cert\", \n        \"pem\": \"$credential_certificate\"\n      }]\n    }\n  },\n  \"jwt_configuration\": {\n    \"alg\": \"RS256\"\n  }\n}'\n```\n\nFor more information, see the [Create a client](https://auth0.com/docs/api/management/v2/clients/post-clients) API documentation.\n\n#### Patch an existing client\n\nYou can update an existing client to accept mTLS client authentication by removing any value in the `token_endpoint_auth_method` field and creating values in the `client_authentication_methods` field.\n\n##### Create the credential resource\n\nOnce you [generate a certificate](#generate-a-certificate), create the credential resource:\n\n```\ncurl --location --request POST 'https://$tenant/api/v2/clients/$client_id/credentials' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"name\": \"$credential_name\", \n  \"credential_type\": \"x509_cert\", \n  \"pem\": \"$credential_certificate\"\n}'\n```\n\nAuth0 returns a credential ID in the response that you will need to associate the credential with the client.\n\nFor more information, see the [Create a client credential](https://auth0.com/docs/api/management/v2/clients/post-credentials) API documentation.\n\n#### Associate the credential with the client and disable token\\_endpoint\\_auth\\_method\n\nUploaded credentials are not automatically enabled for client authentication. You need to update the client authentication to use the new self-signed client certificate.\n\nThe following PATCH request sets the `token_endpoint_auth_method` to `null`, thus disabling Client Secret authentication. It also updates `client_authentication_methods` with the credential ID:\n\n```\ncurl --location --request PATCH 'https://$tenant/api/v2/clients/$client_id' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"token_endpoint_auth_method\": null, \n  \"client_authentication_methods\": {\n    \"self_signed_tls_client_auth\": {\n      \"credentials\": [{ \"id\": $credential.id }]\n    }\n  }\n}'\n```\n\nOnce this request has completed, a Client Secret will no longer be accepted and clients must authenticate using mTLS.\n\nFor more information, see the [Update a client](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id) API documentation.\n\nUnlike self-signed certificates that are generated by the client and have no trust chain, certificate authority (CA) signed certificates are considered more trustworthy since they are issued by a trusted third party. CA-signed certificates are the only type of certificate accepted by some cloud providers such as Amazon.\n\nCA-signed certificates have embedded in their identity information the notion of a Distinguished Name (DN). While each individual certificate created by a given CA is unique, they can share a common DN. When using CA-signed certificates, Auth0 stores the DN and compares forwarded client certificates with registered DNs.\n\n##### Generate a certificate\n\nThe method of generating a CA-signed client certificate is highly dependent on the Public Key Infrastructure and outside of the scope of this document. We recommend generating at least a [2048-bit RSA key pair](https://auth0.com/docs/secure/application-credentials/generate-rsa-key-pair).\n\n##### Create a new client\n\nTo create a client, make a POST call to the [`/clients`](https://auth0.com/docs/api/management/v2/clients/post-clients) endpoint with the following payload:\n\n*   `$client_name`**:** the name for the new client\n    \n*   `$credential_name`**:** the name for the public key \n    \n*   `$credential_certificate`: the content of `$certificate_pem` generated by the CA\n    \n\n```\ncurl --location --request POST 'https://$tenant/api/v2/clients' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"name\": \"$client_name\",\n  \"app_type\": \"non_interactive\",\n  \"client_authentication_methods\": {\n    \"tls_client_auth\": {\n      \"credentials\": [{ \n        \"name\": \"$credential_name\", \n        \"credential_type\": \"cert_subject_dn\", \n        \"pem\": \"$credential_certificate\"\n      }]\n    }\n  },\n  \"jwt_configuration\": {\n    \"alg\": \"RS256\"\n  }\n}'\n```\n\nInstead of passing the full PEM file, you can also pass the subject DN. The subject DN must match the extracted Distinguished Name (DN) of the client certificates sent during the mTLS handshake.\n\nThe following POST request creates a new client with the subject DN:\n\n```\ncurl --location --request POST 'https://$tenant/api/v2/clients' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"name\": \"$client_name\",\n  \"app_type\": \"non_interactive\",\n  \"client_authentication_methods\": {\n    \"tls_client_auth\": {\n      \"credentials\": [{ \n        \"name\": \"$credential_name\", \n        \"credential_type\": \"cert_subject_dn\", \n        \"subject_dn\": \"C=XX\\nST=StateName\\nL=CityName\\nO=CompanyName\\nOU=CompanySectionName\\nCN=CommonNameOrHostname\"\n      }]\n    }\n  },\n  \"jwt_configuration\": {\n    \"alg\": \"RS256\"\n  }\n}'\n```\n\nFor more information, see the [Create a client](https://auth0.com/docs/api/management/v2/clients/post-clients) API documentation.\n\n##### Patch an existing client\n\nIf you don’t want to create a new client to use mTLS, you can update an existing client to accept mTLS client authentication. This involves removing any value in the `token_endpoint_auth_method` field and creating values in the `client_authentication_methods` field.\n\n##### Create the credential resource\n\nOnce you have [generated a key pair](https://auth0.com/docs/secure/application-credentials/generate-rsa-key-pair) exclusively for mTLS, create the credential resource. Make the following POST request to the `/clients` endpoint:\n\n```\ncurl --location --request POST 'https://$tenant/api/v2/clients/$client_id/credentials' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"name\": \"$credential_name\", \n  \"credential_type\": \"cert_subject_dn\", \n  \"pem\": \"$credential_certificate\"\n}'\n```\n\nInstead of passing the full PEM file, you can pass the subject DN. The subject DN must match the extracted Distinguished Name (DN) of the client certificates sent during the mTLS handshake.\n\nThe following code sample creates the credential resource using the Subject DN:\n\n```\ncurl --location --request POST 'https://$tenant/api/v2/clients/$client_id/credentials' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"name\": \"$credential_name\", \n  \"credential_type\": \"cert_subject_dn\", \n  \"subject_dn\": \"C=XX\\nST=StateName\\nL=CityName\\nO=CompanyName\\nOU=CompanySectionName\\nCN=CommonNameOrHostname\"\n}'\n```\n\nWhen using either method, remember that the credential ID that gets returned in the response is needed to [associate the credential with the client](#associate-the-credential-with-the-client-and-disable-token_endpoint_auth_method).\n\nFor more information, see the [Create a client credential](https://auth0.com/docs/api/management/v2/clients/post-credentials) API documentation.\n\n##### Associate the credential with the client and disable token\\_endpoint\\_auth\\_method\n\nAlthough we have created the credential, we have not yet associated the credential with the client.\n\nTo do so, update  `client_authentication_methods` by making the following PATCH request to the `/clients` endpoint. In the same request, set `token_endpoint_auth_method` to `null`:\n\n​​\n\n```\ncurl --location --request PATCH 'https://$tenant/api/v2/clients/$client_id' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"token_endpoint_auth_method\": null, \n  \"client_authentication_methods\": {\n    \"tls_client_auth\": {\n      \"credentials\": [{ \"id\": $credential.id }]\n    }\n  }\n}'\n```\n\nOnce this request has completed, the client can only be authenticated using mTLS.\n\nFor more information, see the [Update a client](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id) API documentation.\n\n### Revert a client to use a Client Secret\n\nTo restore your client’s configuration to authenticate using a Client Secret, disable `client_authentication_methods` and re-enable `token_endpoint_auth_method` with your desired authentication method.\n\nIn the following PATCH request, set `token_endpoint_auth_method` to `client_secret_post` to re-enable Client Secret authentication:\n\n```\ncurl --location --request PATCH 'https://$tenant/api/v2/clients/$client_id' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"token_endpoint_auth_method\": \"client_secret_post\", \n  \"client_authentication_methods\": null\n}'\n```\n\nFor more information, see the [Update a client](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id) API documentation.\n\n#### Enable Token Binding\n\nYou can enable mTLS Token Binding independently of mTLS client authentication. For example, Token Binding can be used with [Private Key JWT client authentication (JWTCA)](https://auth0.com/docs/get-started/applications/configure-private-key-jwt). You can enable Token Binding when creating or updating a client.\n\n##### Create a new client\n\n```\ncurl --location --request POST 'https://$tenant/api/v2/clients' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"name\": \"$client_name\",\n  \"app_type\": \"non_interactive\",\n  \"access_token\": {\n    \"tls_client_certificate_binding\": true\n  }\n}'\n```\n\n##### Patch an existing client\n\n```\ncurl --location --request PATCH 'https://$tenant/api/v2/clients/$client_id' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"access_token\": {\n    \"tls_client_certificate_binding\": true\n  }\n}'\n```\n\n##### Disable Token Binding\n\n```\ncurl --location --request PATCH 'https://$tenant/api/v2/clients/$client_id' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"access_token\": {\n    \"tls_client_certificate_binding\": false\n  }\n}'\n```\n\nFor more information, see the [Create a client](https://auth0.com/docs/api/management/v2/clients/post-clients) and [Update a client](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id) API documentation.\n\n## Configure mTLS with Auth0 Dashboard\n\nYou can use the Auth0 Dashboard to configure mTLS for a client to enable mTLS client authentication to the Authorization Server.\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Select the application you want to use with mTLS or [create a new application](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n3.  Select the **Credentials** tab.\n    \n4.  Choose the required **Authentication Method**, which can be either: \n    \n    *   mTLS with a [self-signed certificate](https://auth0.com/docs/customize/custom-domains/self-managed-certificates)\n        \n    *   mTLS with a certificate authority signed certificate\n        \n        ![Auth0 Dashboard > Applications > Application Settings > Authentication Method](https://images.ctfassets.net/cdy7uua7fh8z/7KTskx1k6wDDT0q49X6A50/1fd2b40216acf24c3772b13eca602544/2024-05-28_15-03-09.png)\n5.  Once you select your preferred type of certificate, you can:\n    \n    *   Assign an existing credential (certificate) to the client application\n        \n        ![Auth0 Dashboard > Applications > Settings > Authentication Method > existing credential](https://images.ctfassets.net/cdy7uua7fh8z/1naxKdrbbiQCypue6nK2qx/036ca4ac2615126c39f40989ee5654a1/2024-05-28_15-29-49.png)\n    *   Add a new credential by uploading a certificate\n        \n        ![Auth0 Dashboard > Applications > Settings > Authentication Method > new credential](https://images.ctfassets.net/cdy7uua7fh8z/28jk9KD9g7fpDXsDF84rC4/b696d477140c6ddbff1a6c2c34b27f86/2024-05-28_15-30-04.png)\n\n## Learn more\n\n*   [Authenticate with mTLS](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls)\n*   [Set up the Customer Edge](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge)\n*   [Configure mTLS for a Tenant](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-tenant)",
  "title": "Configure mTLS for a Client",
  "description": "Describes how to configure mTLS for a client.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/tutorials/calling-an-external-idp-api",
  "markdown": "# Call an Identity Provider API\n\nOnce you successfully authenticate a user with an external Identity Provider (IdP), such as Facebook or GitHub, the IdP often includes an Access Token in the user profile it returns to Auth0.\n\nYou can retrieve and use this token to call the IdP's API.\n\nThe process you will follow differs depending on whether your code runs in the backend or the frontend:\n\n*   If your code runs in the backend, then we can assume that your server is trusted to safely store secrets (as you will see, we use a secret in the backend scenario). If that's the case, proceed to the [backend section](#from-the-backend) of this article.\n    \n*   If your code runs in the frontend (for example, it's a SPA, native desktop, or mobile app), then your app cannot hold credentials securely and has to follow an alternate approach. In this case, proceed to the [frontend section](#from-the-frontend) of this article.\n    \n\n## From the backend\n\nOnce you authenticate a user, the IdP often includes an Access Token in the user profile it returns to Auth0.\n\nFor security and compliance reasons, Auth0 does not send this token to your app as part of the user profile. To get it, you must access the Auth0 Management API and retrieve the full user's profile:\n\n1.  Get an Access Token that allows you to call the [Auth0 Management API](https://auth0.com/docs/api/management/v2).\n    \n2.  Call the Auth0 Management API's [Get Users by ID endpoint](https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id) using the Access Token obtained in step one. This endpoint returns the full user's profile, which contains the IdP Access Token.\n    \n3.  Extract the IdP Access Token from the response and use it to call the IdP's API.\n    \n\n### Step 1: Get a Token\n\nYou will need an Access Token to call the [Management API](https://auth0.com/docs/api/management/v2).\n\n#### Create a test application for the Management API\n\nIf this is the first time you are requesting a [Management APIv2 Token](https://auth0.com/docs/api/management/v2/tokens), you will need to create and configure an application that can be used to call the Management API:\n\n1.  Navigate to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis), and select the [Auth0 Management API](https://manage.auth0.com/#/apis/management/authorized-clients).\n    \n2.  Select the **API Explorer** view, and click **Create & Authorize a Test Application**.\n    \n\nThis will create a new application and grant all scopes of the Management API, which means that the tokens generated for this application will be able to access all Management API endpoints.\n\n#### Can't see the button?\n\nIf you don't see this button, it means that you already have at least one authorized application for the Management API. In this case, you can either update the scopes of the existing application and use that, or create a new one following these steps:\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select **Create Application**.\n    \n2.  Select **Machine to Machine Applications**, and then **Create**.\n    \n3.  From the **Select an API** dropdown, select `Auth0 Management API`.\n    \n4.  Enable required scopes, and select **Authorize**.\n    \n5.  Select the **APIs** view, and enable the toggle for **Auth0 Management API**.\n    \n\nTo grant or remove scopes from the [registered Auth0 Management API](https://manage.auth0.com/#/apis/management/authorized-clients), select the [**Machine to Machine Applications** view](https://manage.auth0.com/#/apis/management/authorized-clients):\n\n![Edit the scopes granted to the Application](https://images.ctfassets.net/cdy7uua7fh8z/6nuMjQMrTWhoVqtRwJBQz7/c0608d7a19addef1acb143532004dba8/dashboard-apis-edit_view-m2m_mgmt-api-permissions.png)\n\n#### Get the Management API Token\n\nYou are now done with configuration and are ready to get your Management API token:\n\n1.  From the [registered Auth0 Management API](https://manage.auth0.com/#/apis/management/authorized-clients), select the [**Test** view](https://manage.auth0.com/#/apis/management/test).\n    \n2.  Choose your application from the **Application** dropdown to pre-populate the ready-to-use snippets with customized variables.\n    \n3.  Choose your language of preference for the snippet, and copy and run it.\n    \n4.  Extract the `access_token` property from the response. This is what you will use to access the Management API.\n    \n\n#### Token expiration\n\nBy default, the token you received expires in 24 hours (86,400 seconds). To change this:\n\n1.  Navigate to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis), and select the [Auth0 Management API](https://manage.auth0.com/#/apis/management/authorized-clients).\n    \n2.  Select the **Settings** view, locate the **Token Expiration (Seconds)** field, enter a new value, and click **Save**. The maximum value you can set is 2,592,000 seconds (30 days), though we recommend that you keep the default value.\n    \n\nThe next token you generate will use the updated expiration time.\n\n### Step 2: Get the full User Profile\n\nTo get a user's profile, call the [Get a User endpoint](https://auth0.com/docs/api/management/v2#!/Users/get_users_by_id) of the Management API using the Access Token you extracted in the previous section:\n\n*   [cURL](#7c25cd17489e43a1b54ce26a366e3bf1_shell)\n*   [C#](#7c25cd17489e43a1b54ce26a366e3bf1_csharp)\n*   [Go](#7c25cd17489e43a1b54ce26a366e3bf1_go)\n*   [Java](#7c25cd17489e43a1b54ce26a366e3bf1_java)\n*   [Node.JS](#7c25cd17489e43a1b54ce26a366e3bf1_node)\n*   [Obj-C](#7c25cd17489e43a1b54ce26a366e3bf1_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users/%7BuserId%7D' \\\n  --header 'authorization: Bearer {yourAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/%7BuserId%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\")\n  .header(\"authorization\", \"Bearer {yourAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users/%7BuserId%7D',\n  headers: {authorization: 'Bearer {yourAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/%7BuserId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/%7BuserId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users/%7BuserId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/%7BuserId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nReplace these values:\n\n*   `{userId}`: ID of the user for whom you want to call the IdP's API.\n    \n*   `{yourAccessToken}`: Access Token you extracted in the previous section.\n    \n\n#### Where do I find the User ID?\n\n*   For testing purposes, you can find a user ID at [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users). Locate a user, and copy the value of the **user\\_id** field.\n    \n\n*   For your implementation, you can either extract the user ID from the `sub` claim in the [ID Token](https://auth0.com/docs/secure/tokens/id-tokens), or call the [/userinfo endpoint](https://auth0.com/docs/api/authentication#get-user-info) of the Authentication API and extract it from the `user_id` response property.\n    \n\nYou can find the Access Token used to call the IdP's API within the user's `identities` array: `user.identities[0].access_token`.\n\nIn most cases, the user will only have one identity, but if the user has signed in multiple times through different connections and you have used [account linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts), there may be more.\n\nIn this sample response, we see that our user has only one identity: `google-oauth2`.\n\n```\n{\n  \"email\": \"john.doe@test.com\",\n  \"email_verified\": true,\n  \"name\": \"John Doe\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n  \"picture\": \"https://myavatar/photo.jpg\",\n  \"gender\": \"male\",\n  \"locale\": \"en\",\n  \"updated_at\": \"2017-03-15T07:14:32.451Z\",\n  \"user_id\": \"google-oauth2|111199914890750704174\",\n  \"nickname\": \"john.doe\",\n  \"identities\": [\n    {\n      \"provider\": \"google-oauth2\",\n      \"access_token\": \"ya29.GlsPBCS6ahokDlgCYnVLnDKNE71HBXPEzNhAPoKJLAGKDSe1De3_xclahNcdZXoU-26hCpa8h6240TV86dtaEQ4ZWoeeZduHDq_yeu9QyQqUr--S9B2CR9YJrLTD\",\n      \"expires_in\": 3599,\n      \"user_id\": \"111199914890750704174\",\n      \"connection\": \"google-oauth2\",\n      \"isSocial\": true\n    }\n  ],\n  \"created_at\": \"2017-03-15T07:13:41.134Z\",\n  \"last_ip\": \"127.0.0.1\",\n  \"last_login\": \"2017-03-15T07:14:32.451Z\",\n  \"logins_count\": 99\n}\n```\n\nYou are now ready to call the IdP's API. Please refer to the IdP's documentation for specifics on how to do so.\n\n## From the frontend\n\nIf you are working with a public application (SPA, native desktop, or mobile app), then this is the place to be.\n\nWhen working with a frontend app, the process for calling IdP APIs differs from the backend process because frontend apps are public applications that **cannot hold credentials securely**. Because SPA code can be viewed and altered, and native/mobile apps can be decompiled and inspected, they cannot be trusted to hold sensitive information like secret keys or passwords.\n\nSpecifically, they cannot securely hold the **Client Secret** for the Machine to Machine Application, which you use to call `/oauth/token` during the first step of the backend process.\n\nInstead, you must build a proxy for your backend and expose it to your application as an API.\n\n### Build a proxy\n\nFirst, you will build a process in your backend that will implement the steps included in [the backend section](#from-the-backend) of this article, and expose it to your application as an API.\n\nYou will call the IdP's API from the same backend process, so the Access Token is never exposed to your public application.\n\nThen, you will call your proxy API from your public application using the [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).",
  "title": "Call an Identity Provider API",
  "description": "Describes how to call an external Identity Provider API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/mfa/guides/mfa-api/otp",
  "markdown": "# Enroll and Challenge OTP Authenticators\n\nAuth0 provides a built-in MFA enrollment and authentication flow using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). However, if you want to create your own user interface, you can use the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) to accomplish it.\n\n## Prerequisites\n\nBefore you can use the MFA APIs, you'll need to enable the MFA grant type for your application. Go to [Auth0 Dashboard > Applications > Advanced Settings > Grant Types](https://manage.auth0.com/#/applications) and select **MFA**.\n\n*   [Configure OTP](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa) as a factor in the Dashboard or using the [Management API](https://auth0.com/docs/api/management/v2#!/Guardian/put_factors_by_name).\n    \n\n## Enroll with OTP\n\n### Get MFA token\n\nDepending on when you are triggering enrollment, you can obtain an access token for using the MFA API in different ways:\n\n*   If you are enrolling during authentication, see [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n    \n*   If you want to let the user enroll a factor at any moment, see [Manage MFA Factor Enrollments](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api).\n    \n\n### Enroll authenticator\n\nMake a `POST` request to the MFA Associate endpoint to enroll the user's authenticator. The bearer token required by this endpoint is the MFA token obtained in the previous step.\n\nTo enroll with OTP, set the `authenticator_types` parameter to `[otp]`.\n\n*   [cURL](#c67037cdde834956a7fad57130f8349e_shell)\n*   [C#](#c67037cdde834956a7fad57130f8349e_csharp)\n*   [Go](#c67037cdde834956a7fad57130f8349e_go)\n*   [Java](#c67037cdde834956a7fad57130f8349e_java)\n*   [Node.JS](#c67037cdde834956a7fad57130f8349e_node)\n*   [Obj-C](#c67037cdde834956a7fad57130f8349e_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/associate' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"authenticator_types\": [\"otp\"] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/associate\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"authenticator_types\\\": [\\\"otp\\\"] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/associate\"\n\n\tpayload := strings.NewReader(\"{ \\\"authenticator_types\\\": [\\\"otp\\\"] }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/associate\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"authenticator_types\\\": [\\\"otp\\\"] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/associate',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'},\n  data: {authenticator_types: ['otp']}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"authenticator_types\": @[ @\"otp\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/associate\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/associate\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"authenticator_types\\\": [\\\"otp\\\"] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"authenticator_types\\\": [\\\"otp\\\"] }\"\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/associate\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/associate\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"authenticator_types\\\": [\\\"otp\\\"] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"authenticator_types\": [\"otp\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/associate\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf successful, you receive a response like this:\n\n```\n{\n  \"authenticator_type\": \"otp\",\n  \"secret\": \"EN...S\",\n  \"barcode_uri\": \"otpauth://totp/tenant:user?secret=...&issuer=tenant&algorithm=SHA1&digits=6&period=30\",\n  \"recovery_codes\": [ \"N3B...XC\"]\n}\n```\n\nIf you get a `User is already enrolled` error, the user already has an MFA factor enrolled. Before associating another factor with the user, you must challenge the user with the existing factor.\n\nIf this is the first time the user is associating an authenticator, you'll notice the response includes `recovery_codes`. Recovery codes are used to access the user's account in the event that they lose access to the account or device used for their second-factor authentication. These are one-time usable codes, and new ones are generated as necessary.\n\n### Confirm OTP enrollment\n\nTo confirm the enrollment, the end user will need to enter the secret obtained in the previous step in an OTP generator application like Google Authenticator. They can enter the secret by scanning a QR code with the `barcode_uri` or by typing the secret code manually in that OTP application. You should provide users a way to get the secret as text in case they cannot scan the QR code (for example, if they are enrolling from a mobile device, or using a desktop OTP application).\n\nAfter the user enters the secret, the OTP application will display a 6-digit code, that the user should enter in your application. The application should then make a `POST` request to the OAuth Token endpoint, including that `otp` value.\n\n*   [cURL](#017aebdde879477ea6c70a0f6c8698d5_shell)\n*   [C#](#017aebdde879477ea6c70a0f6c8698d5_csharp)\n*   [Go](#017aebdde879477ea6c70a0f6c8698d5_go)\n*   [Java](#017aebdde879477ea6c70a0f6c8698d5_java)\n*   [Node.JS](#017aebdde879477ea6c70a0f6c8698d5_node)\n*   [Obj-C](#017aebdde879477ea6c70a0f6c8698d5_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-otp \\\n  --data 'client_id={yourClientId}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'otp={userOtpCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&mfa_token=%7BmfaToken%7D&client_secret=%7ByourClientSecret%7D&otp=%7BuserOtpCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&mfa_token=%7BmfaToken%7D&client_secret=%7ByourClientSecret%7D&otp=%7BuserOtpCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&mfa_token=%7BmfaToken%7D&client_secret=%7ByourClientSecret%7D&otp=%7BuserOtpCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-otp',\n    client_id: '{yourClientId}',\n    mfa_token: '{mfaToken}',\n    client_secret: '{yourClientSecret}',\n    otp: '{userOtpCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-otp\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&otp={userOtpCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&mfa_token=%7BmfaToken%7D&client_secret=%7ByourClientSecret%7D&otp=%7BuserOtpCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&mfa_token=%7BmfaToken%7D&client_secret=%7ByourClientSecret%7D&otp=%7BuserOtpCode%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&mfa_token=%7BmfaToken%7D&client_secret=%7ByourClientSecret%7D&otp=%7BuserOtpCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-otp\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&otp={userOtpCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the call was successful, you'll receive a response in the following format, containing the access token:\n\n```\n{\n  \"id_token\": \"eyJ...i\",\n  \"access_token\": \"eyJ...i\",\n  \"expires_in\": 600,\n  \"scope\": \"openid profile\",\n  \"token_type\": \"Bearer\"\n}\n```\n\nAt this point, the authenticator is fully associated and ready to be used, and you have the authentication tokens for the user.\n\nYou can check at any point to verify whether an authenticator has been confirmed by calling the MFA Authenticators endpoint. If the authenticator is confirmed, the value returned for `active` is `true`.\n\n## Challenge with OTP\n\n### Get MFA token\n\nGet an MFA token following the steps described in [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n\n### Retrieve enrolled authenticators\n\nTo challenge the user, you need the `authenticator_id` for the factor you want to challenge. You can list all enrolled authenticators using the MFA Authenticators endpoint:\n\n*   [cURL](#1ec7b45cf8f341abb8d1e64e3bbb3a8b_shell)\n*   [C#](#1ec7b45cf8f341abb8d1e64e3bbb3a8b_csharp)\n*   [Go](#1ec7b45cf8f341abb8d1e64e3bbb3a8b_go)\n*   [Java](#1ec7b45cf8f341abb8d1e64e3bbb3a8b_java)\n*   [Node.JS](#1ec7b45cf8f341abb8d1e64e3bbb3a8b_node)\n*   [Obj-C](#1ec7b45cf8f341abb8d1e64e3bbb3a8b_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/mfa/authenticators\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/mfa/authenticators\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou will get a list of authenticators with the following format:\n\n```\n[\n    {\n        \"id\": \"recovery-code|dev_qpOkGUOxBpw6R16t\",\n        \"authenticator_type\": \"recovery-code\",\n        \"active\": true\n    },\n    {\n        \"id\": \"totp|dev_6NWz8awwC8brh2dN\",\n        \"authenticator_type\": \"otp\",\n        \"active\": true\n    }\n]\n```\n\n### Challenge user with OTP\n\nTo trigger an OTP challenge, `POST` to the MFA Challenge endpoint using the corresponding `authenticator_id` and the `mfa_token`.\n\n*   [cURL](#dfb56fd34aca4302ab51a8ea05224ebc_shell)\n*   [C#](#dfb56fd34aca4302ab51a8ea05224ebc_csharp)\n*   [Go](#dfb56fd34aca4302ab51a8ea05224ebc_go)\n*   [Java](#dfb56fd34aca4302ab51a8ea05224ebc_java)\n*   [Node.JS](#dfb56fd34aca4302ab51a8ea05224ebc_node)\n*   [Obj-C](#dfb56fd34aca4302ab51a8ea05224ebc_objc)\n*   [...](#)\n\nto configure this snippet with your account\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/challenge' \\\n  --data '{ \"client_id\": \"{yourClientId}\", \"challenge_type\": \"otp\", \"mfa_token\": \"{mfaToken}\", \"authenticator_id\" : \"totp|dev_6NWz8awwC8brh2dN\" }'\n```\n\nto configure this snippet with your account\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/challenge\");\nvar request = new RestRequest(Method.POST);\nrequest.AddParameter(\"undefined\", \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"challenge_type\\\": \\\"otp\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\", \\\"authenticator_id\\\" : \\\"totp|dev_6NWz8awwC8brh2dN\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\nto configure this snippet with your account\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/challenge\"\n\n\tpayload := strings.NewReader(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"challenge_type\\\": \\\"otp\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\", \\\"authenticator_id\\\" : \\\"totp|dev_6NWz8awwC8brh2dN\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\nto configure this snippet with your account\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/challenge\")\n  .body(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"challenge_type\\\": \\\"otp\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\", \\\"authenticator_id\\\" : \\\"totp|dev_6NWz8awwC8brh2dN\\\" }\")\n  .asString();\n```\n\nto configure this snippet with your account\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/challenge',\n  data: {\n    client_id: '{yourClientId}',\n    challenge_type: 'otp',\n    mfa_token: '{mfaToken}',\n    authenticator_id: 'totp|dev_6NWz8awwC8brh2dN'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\nto configure this snippet with your account\n\n```\n#import <Foundation/Foundation.h>\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"challenge_type\": @\"otp\",\n                              @\"mfa_token\": @\"{mfaToken}\",\n                              @\"authenticator_id\": @\"totp|dev_6NWz8awwC8brh2dN\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/challenge\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\nto configure this snippet with your account\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/challenge\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"challenge_type\\\": \\\"otp\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\", \\\"authenticator_id\\\" : \\\"totp|dev_6NWz8awwC8brh2dN\\\" }\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\nto configure this snippet with your account\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"challenge_type\\\": \\\"otp\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\", \\\"authenticator_id\\\" : \\\"totp|dev_6NWz8awwC8brh2dN\\\" }\"\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/challenge\", payload)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\nto configure this snippet with your account\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/challenge\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest.body = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\", \\\"challenge_type\\\": \\\"otp\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\", \\\"authenticator_id\\\" : \\\"totp|dev_6NWz8awwC8brh2dN\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\nto configure this snippet with your account\n\n```\nimport Foundation\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"challenge_type\": \"otp\",\n  \"mfa_token\": \"{mfaToken}\",\n  \"authenticator_id\": \"totp|dev_6NWz8awwC8brh2dN\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/challenge\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Complete authentication using received code\n\nIf successful, you receive the following response:\n\n```\n{\n  \"challenge_type\": \"otp\"\n}\n```\n\nThe user will collect a one time password, which you will then collect from them. You can verify the code and get authentication tokens using the OAuth0 Token endpoint, specifying the one time password in the `otp` parameter:\n\n*   [cURL](#47dd6242fa544db2a99b07575d4fb2d6_shell)\n*   [C#](#47dd6242fa544db2a99b07575d4fb2d6_csharp)\n*   [Go](#47dd6242fa544db2a99b07575d4fb2d6_go)\n*   [Java](#47dd6242fa544db2a99b07575d4fb2d6_java)\n*   [Node.JS](#47dd6242fa544db2a99b07575d4fb2d6_node)\n*   [Obj-C](#47dd6242fa544db2a99b07575d4fb2d6_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-otp \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'otp={userOtpCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&otp=%7BuserOtpCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&otp=%7BuserOtpCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&otp=%7BuserOtpCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-otp',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    mfa_token: '{mfaToken}',\n    otp: '{userOtpCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-otp\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&otp={userOtpCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&otp=%7BuserOtpCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&otp=%7BuserOtpCode%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-otp&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&otp=%7BuserOtpCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-otp\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&otp={userOtpCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the call was successful, you'll receive a response in the format below, containing the access token:\n\n```\n{\n  \"id_token\": \"eyJ...i\",\n  \"access_token\": \"eyJ...i\",\n  \"expires_in\": 600,\n  \"scope\": \"openid profile\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n## Learn more\n\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n*   [Configure OTP Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa)\n*   [Challenge with Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes)\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n*   [Enroll and Challenge Email Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n*   [Enroll and Challenge Push Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)",
  "title": "Enroll and Challenge OTP Authenticators",
  "description": "Describes how to build your own MFA flows using one-time password (OTP) as an authentication factor.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/mfa/guides/mfa-api/oob",
  "markdown": "# Enroll and Challenge SMS and Voice Authenticators\n\nAuth0 provides a built-in MFA enrollment and authentication flow using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). However, if you want to create your own user interface, you can use the [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) to accomplish it.\n\n## Prerequisites\n\nBefore you can use the MFA APIs, you'll need to enable the MFA grant type for your application. Go to [Auth0 Dashboard > Applications > Advanced Settings > Grant Types](https://manage.auth0.com/#/applications) and select **MFA**.\n\n*   [Configure phone as a factor](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa) in the Dashboard or using the [Management API](https://auth0.com/docs/api/management/v2#!/Guardian/put_factors_by_name).\n    \n\n## Enroll with SMS or voice\n\n### Get MFA token\n\nDepending on when you are triggering enrollment, you can obtain an access token for using the MFA API in different ways:\n\n*   If you are enrolling during authentication, see [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n    \n*   If you want to let the user enroll a factor at any moment, see [Manage MFA Factor Enrollments](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api).\n    \n\n### Enroll authenticator\n\nMake a `POST` request to the MFA Associate endpoint to enroll the user's authenticator. The bearer token required by this endpoint is the MFA token obtained in the previous step.\n\nTo enroll with SMS or voice, they enroll with a phone number that can be challenged either with SMS or voice. Specific the parameters below to call the endpoint. The `oob_channels` parameter indicates how you want to send the code to the user (SMS or voice).\n\n*   [cURL](#cabfa6aec76b4c4db6f9984979a0a92a_shell)\n*   [C#](#cabfa6aec76b4c4db6f9984979a0a92a_csharp)\n*   [Go](#cabfa6aec76b4c4db6f9984979a0a92a_go)\n*   [Java](#cabfa6aec76b4c4db6f9984979a0a92a_java)\n*   [Node.JS](#cabfa6aec76b4c4db6f9984979a0a92a_node)\n*   [Obj-C](#cabfa6aec76b4c4db6f9984979a0a92a_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/associate' \\\n  --header 'authorization: Bearer {mfaToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"authenticator_types\": [\"oob\"], \"oob_channels\": [\"sms\"], \"phone_number\": \"+11...9\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/associate\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {mfaToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"sms\\\"], \\\"phone_number\\\": \\\"+11...9\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/associate\"\n\n\tpayload := strings.NewReader(\"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"sms\\\"], \\\"phone_number\\\": \\\"+11...9\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {mfaToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/associate\")\n  .header(\"authorization\", \"Bearer {mfaToken}\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"sms\\\"], \\\"phone_number\\\": \\\"+11...9\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/associate',\n  headers: {authorization: 'Bearer {mfaToken}', 'content-type': 'application/json'},\n  data: {authenticator_types: ['oob'], oob_channels: ['sms'], phone_number: '+11...9'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {mfaToken}\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"authenticator_types\": @[ @\"oob\" ],\n                              @\"oob_channels\": @[ @\"sms\" ],\n                              @\"phone_number\": @\"+11...9\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/associate\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/associate\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"sms\\\"], \\\"phone_number\\\": \\\"+11...9\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {mfaToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"sms\\\"], \\\"phone_number\\\": \\\"+11...9\\\" }\"\n\nheaders = {\n    'authorization': \"Bearer {mfaToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/associate\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/associate\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {mfaToken}'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"authenticator_types\\\": [\\\"oob\\\"], \\\"oob_channels\\\": [\\\"sms\\\"], \\\"phone_number\\\": \\\"+11...9\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {mfaToken}\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\n  \"authenticator_types\": [\"oob\"],\n  \"oob_channels\": [\"sms\"],\n  \"phone_number\": \"+11...9\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/associate\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Parameter | Value |\n| --- | --- |\n| `authentication_types` | `[oob]` |\n| `oob_channels` | `[sms]` or `[voice]` |\n| `phone_number` | `+11...9`, the phone number [E.164 format](https://en.wikipedia.org/wiki/e.164) |\n\nIf successful, you receive a response like this:\n\n```\n{\n  \"authenticator_type\": \"oob\",\n  \"binding_method\": \"prompt\",\n  \"recovery_codes\": [ \"N3BGPZZWJ85JLCNPZBDW6QXC\" ],\n  \"oob_channel\": \"sms\",\n  \"oob_code\": \"ata6daXAiOi...\"\n}\n`\n```\n\nIf you get a `User is already enrolled` error, the user already has an MFA factor enrolled. Before associating another factor with the user, you must challenge the user with the existing factor.\n\nIf this is the first time the user is associating an authenticator, you'll notice the response includes `recovery_codes`. Recovery codes are used to access the user's account in the event that they lose access to the account or device used for their second-factor authentication. These are one-time usable codes, and new ones are generated as necessary.\n\n### Confirm SMS or voice enrollment\n\nUsers should receive a message with a 6-digit code that they need to provide to the application.\n\nTo complete enrollment, make a `POST` request to the OAuth Token endpoint. You need to include the `oob_code` returned in the previous response, and the `binding_code` with the value received in the message.\n\n*   [cURL](#2d7ddfa576ec4451bb68a99d03144446_shell)\n*   [C#](#2d7ddfa576ec4451bb68a99d03144446_csharp)\n*   [Go](#2d7ddfa576ec4451bb68a99d03144446_go)\n*   [Java](#2d7ddfa576ec4451bb68a99d03144446_java)\n*   [Node.JS](#2d7ddfa576ec4451bb68a99d03144446_node)\n*   [Obj-C](#2d7ddfa576ec4451bb68a99d03144446_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'authorization: Bearer {mfaToken}' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-oob \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'oob_code={oobCode}' \\\n  --data 'binding_code={userOtpCode}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {mfaToken}\");\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserOtpCode%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserOtpCode%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {mfaToken}\")\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"authorization\", \"Bearer {mfaToken}\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserOtpCode%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {\n    authorization: 'Bearer {mfaToken}',\n    'content-type': 'application/x-www-form-urlencoded'\n  },\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    mfa_token: '{mfaToken}',\n    oob_code: '{oobCode}',\n    binding_code: '{userOtpCode}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {mfaToken}\",\n                           @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&oob_code={oobCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&binding_code={userOtpCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserOtpCode%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {mfaToken}\",\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserOtpCode%7D\"\n\nheaders = {\n    'authorization': \"Bearer {mfaToken}\",\n    'content-type': \"application/x-www-form-urlencoded\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {mfaToken}'\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=%7BuserOtpCode%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {mfaToken}\",\n  \"content-type\": \"application/x-www-form-urlencoded\"\n]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&oob_code={oobCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&binding_code={userOtpCode}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the call was successful, you'll receive a response in the following format, containing the access token:\n\n```\n{\n  \"id_token\": \"eyJ...i\",\n  \"access_token\": \"eyJ...i\",\n  \"expires_in\": 600,\n  \"scope\": \"openid profile\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n## Challenge with SMS or voice\n\n### Get MFA token\n\nGet an MFA token following the steps described in [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n\n### Retrieve enrolled authenticators\n\nTo challenge the user, you need the `authenticator_id` for the factor you want to challenge. You can list all enrolled authenticators using the MFA Authenticators endpoint:\n\n*   [cURL](#d8df820d8b66410fa6a87e5781aba1a2_shell)\n*   [C#](#d8df820d8b66410fa6a87e5781aba1a2_csharp)\n*   [Go](#d8df820d8b66410fa6a87e5781aba1a2_go)\n*   [Java](#d8df820d8b66410fa6a87e5781aba1a2_java)\n*   [Node.JS](#d8df820d8b66410fa6a87e5781aba1a2_node)\n*   [Obj-C](#d8df820d8b66410fa6a87e5781aba1a2_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/mfa/authenticators\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/mfa/authenticators\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou will get a list of authenticators with the following format:\n\n```\n[\n    {\n        \"id\": \"recovery-code|dev_O4KYL4FtcLAVRsCl\",\n        \"authenticator_type\": \"recovery-code\",\n        \"active\": true\n    },\n    {\n        \"id\": \"sms|dev_NU1Ofuw3Cw0XCt5x\",\n        \"authenticator_type\": \"oob\",\n        \"active\": true,\n        \"oob_channel\": \"sms\",\n        \"name\": \"XXXXXXXX8730\"\n    },\n        {\n        \"id\": \"voice|dev_NU1Ofuw3Cw0XCt5x\",\n        \"authenticator_type\": \"oob\",\n        \"active\": true,\n        \"oob_channel\": \"voice\",\n        \"name\": \"XXXXXXXX8730\"\n    }\n]\n```\n\n### Challenge user with OTP\n\nTo trigger a challenge, `POST` to the MFA Challenge endpoint using the corresponding `authenticator_id` and the `mfa_token`.\n\n*   [cURL](#f02a757353a04cefb17df1f0ce347077_shell)\n*   [C#](#f02a757353a04cefb17df1f0ce347077_csharp)\n*   [Go](#f02a757353a04cefb17df1f0ce347077_go)\n*   [Java](#f02a757353a04cefb17df1f0ce347077_java)\n*   [Node.JS](#f02a757353a04cefb17df1f0ce347077_node)\n*   [Obj-C](#f02a757353a04cefb17df1f0ce347077_objc)\n*   [...](#)\n\nto configure this snippet with your account\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/mfa/challenge' \\\n  --data '{ \"client_id\": \"{yourClientId}\",  \"client_secret\": \"{yourClientSecret}\", \"challenge_type\": \"oob\", \"authenticator_id\": \"sms|dev_NU1Ofuw3Cw0XCt5x\", \"mfa_token\": \"{mfaToken}\" }'\n```\n\nto configure this snippet with your account\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/challenge\");\nvar request = new RestRequest(Method.POST);\nrequest.AddParameter(\"undefined\", \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"sms|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\nto configure this snippet with your account\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/challenge\"\n\n\tpayload := strings.NewReader(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"sms|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\nto configure this snippet with your account\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/mfa/challenge\")\n  .body(\"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"sms|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\")\n  .asString();\n```\n\nto configure this snippet with your account\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/mfa/challenge',\n  data: {\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    challenge_type: 'oob',\n    authenticator_id: 'sms|dev_NU1Ofuw3Cw0XCt5x',\n    mfa_token: '{mfaToken}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\nto configure this snippet with your account\n\n```\n#import <Foundation/Foundation.h>\nNSDictionary *parameters = @{ @\"client_id\": @\"{yourClientId}\",\n                              @\"client_secret\": @\"{yourClientSecret}\",\n                              @\"challenge_type\": @\"oob\",\n                              @\"authenticator_id\": @\"sms|dev_NU1Ofuw3Cw0XCt5x\",\n                              @\"mfa_token\": @\"{mfaToken}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/challenge\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\nto configure this snippet with your account\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/challenge\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"sms|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\nto configure this snippet with your account\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"sms|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\"\n\nconn.request(\"POST\", \"/{yourDomain}/mfa/challenge\", payload)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\nto configure this snippet with your account\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/challenge\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest.body = \"{ \\\"client_id\\\": \\\"{yourClientId}\\\",  \\\"client_secret\\\": \\\"{yourClientSecret}\\\", \\\"challenge_type\\\": \\\"oob\\\", \\\"authenticator_id\\\": \\\"sms|dev_NU1Ofuw3Cw0XCt5x\\\", \\\"mfa_token\\\": \\\"{mfaToken}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\nto configure this snippet with your account\n\n```\nimport Foundation\nlet parameters = [\n  \"client_id\": \"{yourClientId}\",\n  \"client_secret\": \"{yourClientSecret}\",\n  \"challenge_type\": \"oob\",\n  \"authenticator_id\": \"sms|dev_NU1Ofuw3Cw0XCt5x\",\n  \"mfa_token\": \"{mfaToken}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/challenge\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Complete authentication using received code\n\nIf success, you receive the following response:\n\n```\n{\n  \"challenge_type\": \"oob\",\n  \"oob_code\": \"asdae35fdt5...\",\n  \"binding_method\": \"prompt\"\n}\n```\n\nYour application needs to prompt the user for the 6-digit code sent in the message and should be set in the `binding_code` parameter. You can verify the code and get authentication tokens using the OAuth0 Token endpoint, specifying the `binding_code` and `oob_code` returned by the previous call:\n\n*   [cURL](#76adc44ecf794d7190e3292cd53a24b9_shell)\n*   [C#](#76adc44ecf794d7190e3292cd53a24b9_csharp)\n*   [Go](#76adc44ecf794d7190e3292cd53a24b9_go)\n*   [Java](#76adc44ecf794d7190e3292cd53a24b9_java)\n*   [Node.JS](#76adc44ecf794d7190e3292cd53a24b9_node)\n*   [Obj-C](#76adc44ecf794d7190e3292cd53a24b9_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=http://auth0.com/oauth/grant-type/mfa-oob \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'mfa_token={mfaToken}' \\\n  --data 'oob_code={oobCode}' \\\n  --data binding_code=USER_OTP_CODE\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=USER_OTP_CODE\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=USER_OTP_CODE\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=USER_OTP_CODE\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    mfa_token: '{mfaToken}',\n    oob_code: '{oobCode}',\n    binding_code: 'USER_OTP_CODE'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&mfa_token={mfaToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&oob_code={oobCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&binding_code=USER_OTP_CODE\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=USER_OTP_CODE\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=USER_OTP_CODE\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=http%3A%2F%2Fauth0.com%2Foauth%2Fgrant-type%2Fmfa-oob&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&mfa_token=%7BmfaToken%7D&oob_code=%7BoobCode%7D&binding_code=USER_OTP_CODE\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=http://auth0.com/oauth/grant-type/mfa-oob\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&mfa_token={mfaToken}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&oob_code={oobCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&binding_code=USER_OTP_CODE\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the call was successful, you'll receive a response in the format below, containing the access token:\n\n```\n{\n  \"id_token\": \"eyJ...i\",\n  \"access_token\": \"eyJ...i\",\n  \"expires_in\": 600,\n  \"scope\": \"openid profile\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n**Note:** SMS and invalid code returns are subject to rate limiting. SMS codes can be sent 10 times and refill once per hour, while invalid codes can be returned 10 times and refill once every six minutes.\n\n## Learn more\n\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n*   [Configure SMS and Voice Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n*   [Challenge with Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes)\n*   [Enroll and Challenge Email Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n*   [Enroll and Challenge OTP Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n*   [Enroll and Challenge Push Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)",
  "title": "Enroll and Challenge SMS and Voice Authenticators",
  "description": "Describes how to build your own MFA flows using SMS and/or voice as an authentication factor.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls",
  "markdown": "# Authenticate with mTLS\n\n## mTLS in OAuth/OIDC\n\nDefault OAuth/OIDC flows are not always secure because of the following issues:\n\n*   The use of a shared Client Secret as a form of client authentication.\n    \n*   The ability for an access token to be used by unintended parties.\n    \n\nIn 2020, the Internet Engineering Task Force (IETF) released [RFC 8705](https://www.rfc-editor.org/rfc/rfc8705) to address these issues with mTLS authentication. In mTLS authentication, the client certificate functions like a Client Secret in an OAuth/OIDC flow to verify the client’s identity. If a client is already authenticated at the network layer, there’s no need for a Client Secret at the application layer. Additionally, client certificates can be used with multiple servers to prove a client’s identity to a resource server. Note there are other approaches to solve these problems, namely [Private Key JWT](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt) and [DPoP](https://datatracker.ietf.org/doc/html/rfc9449) respectively.\n\nTo secure an OAuth flow with mTLS, clients send a mTLS certificate to the SSL termination point on the customer edge network when the TLS connection is being established. Before the authorization server processes the request, it must first verify the client’s mTLS certificate.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/4SlprP2uTYMCoLIPLsOl4v/d17575139419453d8772081ad20b7499/HRI_diagrams_-_mtls_diagram_1__2_.png)\n\nmTLS also ensures an access token is only used by the intended party, known as Sender Constraining or Token Binding. When the client calls the `/oauth/token` endpoint on the authorization server using an mTLS connection, the resulting access token contains information that the resource server uses to verify that the client’s TLS certificate matches that of the access token.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7qocbfqySAnu85ph6WVSGU/ee8cd3514ed1bb6fea554cbd63d230cf/HRI_diagrams_-_mtls_diagram_2__1_.png)\n\n**Note**: mTLS client authentication and mTLS Token Binding can be used independently of each other. mTLS client authentication can be used without mTLS Token Binding, and mTLS Token Binding can be used with other forms of client authentication such as Client Secret or Private Key JWT. Even if other forms of client authentication are used, the client still sends the client certificate to the authorization server for mTLS Token Binding.\n\n## mTLS at Auth0\n\nmTLS for Auth0 builds on [custom domains](https://auth0.com/docs/customize/custom-domains) and leverages the customer’s existing mTLS infrastructure to perform certificate provisioning and verification.\n\nAuthenticated client calls to Auth0 that normally require a Client Secret are first sent to the customer edge. This already happens for custom domains that use self-signed certificates. The customer edge performs the mTLS handshake with the client and validates the client certificate. Once the client certificate is verified, the request is then forwarded to the tenant’s edge domain at Auth0, including the validated client certificate in an HTTP header along with the correct `cname-api-key` as per the custom domains functionality.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7p3tqUtBeMAp4fBbbemhOh/379a6d3b91ad37beb8cd01a20c1b13e5/HRI_diagrams_-_mtls_diagram_3__1_.png)\n\nSince mTLS serves both client authentication and access token binding, the client must know whether these features are enabled on the authorization server. In addition, an authorization server’s mTLS endpoints and non-mTLS endpoints may be exposed on different domains.\n\nTo get configuration details about the authorization server, the client sends a GET request to the [OpenID Connect Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html) endpoint: `https://<custom-domain>/.well-known/openid-configuration`\n\nA successful response returns the OIDC discovery document, or a JSON object listing the authorization server’s properties and endpoints, including those related to mTLS.\n\nIf mTLS client authentication is enabled, the OIDC discovery document includes the `token_endpoint_auth_methods_supported` property, which contains either `tls_client_auth` or `self_signed_tls_client_auth`:\n\n```\n{\n  ...\n  \"token_endpoint_auth_methods_supported\": [\"tls_client_auth\"]\n  ...\n}\n```\n\nIf mTLS Token Binding is enabled, the OIDC discovery document sets the  `tls_client_certificate_bound_access_tokens` property to `true:`\n\n```\n{\n  ...\n  \"tls_client_certificate_bound_access_tokens\": true\n  ...\n}\n```\n\nEnvironments that support mTLS endpoint aliases expose a new property, `mtls_endpoint_aliases`, that contains a list of endpoints that support mTLS. For clients that support mTLS, the endpoints listed under `mtls_endpoint_aliases` take precedence over the same endpoints exposed outside of `mtls_endpoint_aliases`.\n\nIn the following code sample, the `token_endpoint` property is exposed twice. The endpoint to use for mTLS calls is listed under `mtls_endpoint_aliases`, or `https://mtls.auth.bank.com/oauth/token`:\n\n```\n{\n  ...\n  \"mtls_endpoint_aliases\": {\n\"token_endpoint\": \"https://mtls.auth.bank.com/oauth/token\"\n  },\n  \"token_endpoint\": \"https://auth.bank.com/oauth/token\",\n  \"pushed_authorization_request_endpoint\": \"https://auth.bank.com/oauth/par\",\n  ...\n}\n```\n\nIf an endpoint is not listed under `mtls_endpoint_aliases`, use the same endpoint listed outside of `mtls_endpoint_aliases`. In the example above, `pushed_authorization_request_endpoint` is not listed under `mtls_endpoint_aliases`. As a result, use the `pushed_authorization_request_endpoint` exposed outside of `mtls_endpoint_aliases`, or `https://auth.bank.com/oauth/par`.\n\nFor more information, see RFC 8705’s [section on endpoint aliases](https://www.rfc-editor.org/rfc/rfc8705#name-metadata-for-mutual-tls-end).\n\n## Call the resource server\n\nOnce a client receives an access token, it can access protected resources on a resource server. If mTLS Token Binding is enabled, the authorization server returns the OIDC discovery document that contains the `tls_client_certificate_bound_access_tokens` property. \n\nWhen the client calls the resource server with a mTLS-bound access token, the resource server requests a mTLS certificate from the client during the TLS handshake. The resource server should reject requests with an access token that does not match that client certificate with a 401 HTTP status code and an `invalid_token` error code. To learn more, read [Set up the resource server for Token Binding](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-resource-server-for-token-binding).\n\n## Learn more\n\n*   [Configure mTLS Authentication](https://auth0.com/docs/get-started/applications/configure-mtls)",
  "title": "Authenticate with mTLS",
  "description": "Learn how to authenticate a client using mTLS. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-mtls/set-up-the-customer-edge",
  "markdown": "# Set up the Customer Edge\n\nThis section explains how to set up the customer edge network. The specifics of configuring different edge networks are out of the scope of this document. For more information, see the [custom domains](https://auth0.com/docs/customize/custom-domains) documentation.\n\nThe customer’s edge domain must match the registered custom domain. If mTLS endpoint aliases are enabled, the customer edge must also accept requests on the subdomain used by the mTLS aliases. All requests that arrive at the mTLS subdomain should request a client TLS certificate and verify that the certificate is registered for use. For more information, see [Verify the client certificate](#verify-the-client-certificate).\n\nThe mTLS handshake occurs before the edge infrastructure can determine the requested path. Once the TLS session is established, the customer may wish to inspect the path and only forward requests for the following endpoints:\n\n*   `/oauth/token`\n    \n*   `/oauth/par`\n    \n*   `/userinfo`\n    \n\nIf your installation aims for FAPI compliance, additional requirements related to TLS are placed on your edge network. For more information, see the [FAPI1 Baseline](https://openid.net/specs/openid-financial-api-part-1-1_0.html#tls-and-dnssec-considerations), [FAPI1 Advanced](https://openid.net/specs/openid-financial-api-part-2-1_0.html#tls-considerations), and [FAPI2 Baseline](https://openid.net/specs/fapi-2_0-baseline.html#name-network-layer-protections) specifications.\n\n## Verify the client certificate\n\nThe customer edge network performs validations that depend on the expected type of the client certificate. To avoid common security problems and pitfalls, use a well-vetted certificate validation library when possible. When the client certificate fails validation, the expected behavior is dependent on the installation and outside of the scope of this document.\n\n### CA-signed certificates\n\nWhen a certificate is signed by a certificate authority, the trust chain of the certificate must be verified, including the root certificate. The certificate may also be compared against an allow or deny list to ensure the certificate is registered and has not been revoked. Do not use a public certificate authority (e.g. LetsEncrypt) to sign your client certificates, as there is a risk of impersonating your clients.\n\n### Self-signed certificates\n\nSelf-signed certificates are not backed by a chain of trust so a certificate chain cannot be checked. Instead, the certificate thumbprint could be checked against a registered certificate database or forwarded directly to Auth0 to perform this check.\n\n## Forward the request\n\nOnce the certificate is verified, requests are forwarded along with several special headers from the customer to the same endpoint on the custom domain’s forwarding target at [Auth0's edge network](https://auth0.com/docs/customize/custom-domains/self-managed-certificates). The forwarded request must include the following headers:\n\n*   The Custom Domain API key as the `cname-api-key` header.\n    \n*   The client certificate as the `client-certificate` header. **Note**: Since HTTP headers must be text, the certificate must be converted to a URL component encoded PEM. The header value is limited to 4096 bytes. Therefore, only the first certificate in the chain should be forwarded to Auth0.\n    \n*   The client certificate CA verification status as the `client-certificate-ca-verified` header. The `client-certificate-ca-verified` header can have the following values:\n    \n    *   **SUCCESS**: indicates that the client certificate is valid and has been verified by a certificate authority.\n        \n    *   **FAILED:** indicates that the presented client certificate is valid, however the certificate's trust chain has NOT been verified by a certificate authority. In other words, it’s a self-signed certificate. May include an optional failure reason.\n        \n\nIf your configuration supports only CA-signed certificates, you don't need to forward self-signed certificates to the Auth0 edge network, and you can terminate the request earlier. However, if your clients are configured to authenticate using self-signed certificates, Auth0 expects your network edge to send a `client-certificate-ca-verified:FAILED` header. Depending on this header value, Auth0 knows which client authentication method has been used and which client credentials need to be verified against.\n\n## Learn more\n\n*   [Authenticate with mTLS](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls)\n*   [Configure mTLS for a Tenant](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-tenant)\n*   [Configure mTLS for a Client](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client)",
  "title": "Set up the Customer Edge",
  "description": "Learn how to set up your customer edge for mTLS authentication. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/extensions/authentication-api-debugger",
  "markdown": "# Authentication API Debugger Extension\n\nThe Authentication API Debugger extension allows you to test various endpoints of the Auth0 Authentication API.\n\n## Install the extension\n\nTo install this extension:\n\n1.  Navigate to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **Auth0 Authentication API Debugger**. The **Install Extension** window opens.\n    \n    ![Dashboard - Extensions - Auth API Debugger - Install](https://images.ctfassets.net/cdy7uua7fh8z/LCCCdFE4z9OJ4gW3C3hs9/bb81a0762c423bd3da6d9454b6b42359/Dashboard_-_Extensions_-_Auth_API_Debugger_-_Install.png)\n2.  Select **Install**.\n    \n\nBecause the extension will communicate with the Management API on your behalf to retrieve details about the Applications you have configured in your Auth0 Dashboard, you will need to authorize its access.\n\nTo authorize the extension:\n\n1.  If you're following this guide, you should already be on the [Installed Extensions](https://manage.auth0.com/#/extensions) view of [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions). Select **Auth0 Authentication API Debugger** to launch the extension. A consent dialog will appear, requesting access to your account.\n    \n    ![Dashboard - Extensions - Authentication API Debugger - Consent](https://images.ctfassets.net/cdy7uua7fh8z/5jT4QiRzF9sNZfDxqdNFxm/9a1aea3acc11172ec07d88b9c7d1c11d/Dashboard-Extensions-API-Debugger_Authorize.png)\n2.  Consent to allow the extension to access your account. After you consent, the extension launches.\n    \n\n## Configure the extension\n\nAfter the extension is installed, you should apply the basic configuration. To configure the extension:\n\n1.  If you're following this guide, you should already have launched the extension. Select the **Configuration** view.\n    \n    ![Dashboard - Extensions - Authentication API Debugger - Configuration](https://images.ctfassets.net/cdy7uua7fh8z/5riI24ArqUAKRXhZfNWIQ5/ab7d6825288752132d14e54db1e563d0/configuration.png)\n2.  Set the following configuration parameters, and select **Save**:\n    \n\n*   **Domain**: The domain for your tenant. This field is read-only and is displayed for informational purposes.\n    \n*   **Application**: The Application for which you want to initiate any authentication flows. You can manage your Applications at [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n*   **Callback URL**: The callback URL for this extension. You must also add this URL to the **Allowed Callback URLs** in the selected Application's settings.\n    \n*   **State**: Optional state information that can be sent with the authentication flow.\n    \n*   **Connection**: The name of the connection with which you want to log in. You can use this parameter to bypass the main login screen and go directly for the login screen of the relevant Identity Provider.\n    \n\n## Execute the flows\n\nAfter configuring the extension, you can execute any of the flows by selecting the **OAuth2/OIDC** view.\n\n![Dashboard - Extensions - Authentication API Debugger - OAuth OIDC Settings](https://images.ctfassets.net/cdy7uua7fh8z/72iYPxZU9OiHkKkHtgPTjI/fc166f3ae74e595c8d916276e78edb99/oauth-oidc-settings.png)\n\nOnce you have executed a particular flow, you will see a screen that displays the information returned from Auth0. The exact information returned will depend on which flow was executed. An example of the results after executing a normal **OAuth2/OIDC Login** flow is as follows:\n\n![Dashboard - Extensions - Authentication API Debugger - Flow Executed](https://images.ctfassets.net/cdy7uua7fh8z/13TRS8SQUd4OsfLYRWMoe6/3478778905ad253160022db1f1f6f31a/flow-executed.png)\n\nTo execute another flow, select the **Login** view to return to the **Configuration** screen.",
  "title": "Authentication API Debugger Extension",
  "description": "Learn how to configure and use the Auth0 Authentication API Debugger extension.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/adding-scopes-for-an-external-idp",
  "markdown": "# Add Scopes/Permissions to Call Identity Provider APIs\n\nOnce a user is logged in, you can get their user profile and then the associated `accessToken` to call the Identity Provider (IdP) APIs as described in [Call an Identity Provider API](https://auth0.com/docs/authenticate/identity-providers/calling-an-external-idp-api).\n\nHowever, if you are receiving `Access Denied` when calling the IdP API, you probably have not requested the correct permissions for the user during login. You can request the correct permissions in one of two ways.\n\n## Change Identity Provider Settings\n\nTo configure the scopes/permissions needed from the user, go to [Auth0 Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social), and select an IdP. You can select the required permissions listed on the configuration screen.\n\nFor example, if you click the **Google / Gmail** connection, you can configure Google-specific per