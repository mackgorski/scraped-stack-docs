missions:\n\n![Permissions for Google](https://images.ctfassets.net/cdy7uua7fh8z/61ACa6hnMtO5aUjus0fCb7/f06dbb20388edcaa30ea85d81cd725b5/dashboard-connections-social-create_google.png)\n\nYou can also pass the scopes/permissions you wish to request as a comma-separated list in the `connection_scope` parameter when calling the [authorize endpoint](https://auth0.com/docs/api/authentication#login). For example, if you want to request the `https://www.googleapis.com/auth/contacts.readonly` and `https://www.googleapis.com/auth/analytics` scopes from Google, you can pass these along with the `connection` parameter to ensure the user logs in with their Google account:\n\n```\nhttps://{yourDomain}/authorize\n  ?response_type=id_token\n  &client_id={yourClientId}\n  &redirect_uri={https://yourApp/callback}\n  &scope=openid%20profile\n  &connection=google-oauth2\n  &connection_scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fanalytics%2Chttps%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcontacts.readonly\n  &nonce=abc\n```",
  "title": "Add Scopes/Permissions to Call Identity Provider APIs",
  "description": "Describes how to add scopes to your IdP connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/tokens/overview-idp-access-tokens",
  "markdown": "# Identity Provider Access Tokens\n\nIdentity providers issue third-party access tokens after users authenticate with that provider. You can use these access tokens to call the API of the third-party provider that issued them. For example, you can use an access token issued after a user authenticates with Facebook to call the Facebook Graph API.\n\nFor individual users, the identity provider tokens are available in the `identities` array on the `user` object under the element for the particular connection. To securely access tokens for a specific user, you need an [access token for the Management API](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) that includes the `read:user_idp_tokens` scope. Then, you can make an HTTP GET call to the [Get a User endpoint](https://auth0.com/docs/api/management/v2/#!/Users/get_users_by_id) to retrieve the tokens.\n\nFor admin users of Enterprise connections set up using an OAuth 2.0 consent flow, the identity provider tokens are available in the `connection` object. To securely access tokens for a connection, you need an [access token for the Management API](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) that includes the `read:connections` scope. Then, you can make an HTTP GET call to the [Get a Connection endpoint](https://auth0.com/docs/api/management/v2/connections/get-connections-by-id) to retrieve the tokens.\n\n## Renew third-party tokens\n\nThere is no standard way to renew identity provider access tokens through Auth0. The mechanism for renewing identity provider access tokens varies for each provider. For certain identity providers, Auth0 can store a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens), which you can use to obtain a new access token for the identity provider. Here is a list of some of the identity providers:\n\n*   BitBucket\n    \n*   Google OAuth 2.0 (pass the parameter `access_type=offline`, as well the `connection_scope` parameter with required scopes, when calling the Auth0 `/authorize` endpoint)\n    \n*   Any other OAuth 2.0 identity provider\n    \n*   SharePoint\n    \n*   Azure AD\n    \n\nYou can retrieve refresh tokens in the same manner you retrieve access tokens. Review the guidelines above for more information.\n\n## Validate third-party tokens\n\nIn general, if you have received an access token from an identity provider, you don't need to validate it. You can pass it to the issuer, and the issuer takes care of the rest.\n\n## Learn more\n\n*   [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens)",
  "title": "Identity Provider Access Tokens",
  "description": "Understand third-party access tokens issued by identity providers after user authentication and how to use them to call the third-party APIs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/protocols/ws-fed",
  "markdown": "# Web Services Federation Protocol\n\nWeb Services Federation (WS-Federation or WS-Fed) is part of the larger WS-Security framework and an extension to the functionality of WS-Trust. The features of WS-Federation can be used directly by SOAP applications and web services. WS-Fed is a protocol that can be used to negotiate the issuance of a token. You can use this protocol for your applications (such as a Windows Identity Foundation-based app) and for identity providers (such as Active Directory Federation Services or Azure AppFabric Access Control Service).\n\n## For applications\n\nWhen you register an application in Auth0, it will automatically be assigned a WS-Fed endpoint of the form:\n\n`https://{yourDomain}/wsfed/{yourClientId}`\n\nYou can find all available options for configuring WS-Fed under the [advanced settings](https://manage.auth0.com/#/applications/{yourClientId}/settings) area for your application.\n\nYou will need to configure the **Relying Party**, which can be done using the following metadata endpoint:\n\n`https://{yourDomain}/wsfed/FederationMetadata/2007-06/FederationMetadata.xml`\n\nYou can also use the **samlConfiguration** object, available in [rules](https://auth0.com/docs/customize/rules), to configure claims sent via the token, as well as other lower-level WS-Fed and SAML\\-P settings.\n\nWhen redirecting your users to your WS-Fed endpoint, you can use the following (optional) parameters:\n\n| Parameter | Description |\n| --- | --- |\n| `wa=wsignin1.0` | Whether Auth0 should issue a token for the relying party (default) |\n| `wa=wsignout1.0` | Whether Auth0 should clear the user session/log the user out |\n| `wreply={callback_URL}` | Where the response should be sent |\n| `wctx={state}` | Your application's state |\n| `whr={connection_name}` | Connection to be used (allows users to skip the Auth0 login page) |\n| `wfresh=0` | Whether the user must re-authenticate, even if there's a session in place (`0` requires re-authentication) |\n\nHere's a sample of what your URL with the optional parameters might look like:\n\n`https://{yourDomain}/wsfed/{yourClientId}?whr=google-oauth2`\n\n## Identity providers\n\nIf you're using Auth0 with an identity provider that uses the WS-Federation protocol (such as Active Directory Federation Services, Azure AppFabric Access Control Service, and IdentityServer), the easiest way to set up your integration is to create and use the ADFS connection type in the Dashboard. There are two ways to accomplish this:\n\n*   Import the Federation Metadata file\n    \n*   Enable the Federation Metadata endpoint to check for changes\n    \n\n### Import Federation metadata file\n\nWhen setting up an ADFS-based connection, you can import the required parameters by providing Auth0 with the Federation Metadata endpoint or by importing/uploading your federation metadata file.\n\n![Protocols WS-Fed Import Federation Metadata File ADFS Connection Screen](https://images.ctfassets.net/cdy7uua7fh8z/35pGg8AnNcx2ZIfQIixt1J/2dd75754a7810fac4eb5dfb82fd11dc5/create-adfs-connection.png)\n\nYou will be presented with the instructions you need to finish configuring the integration.\n\n### Enable the Federation Metadata endpoint\n\nThe federation metadata file contains information about the identity provider's certificates. If you provide the Federation Metadata endpoint (typically of the form ending with `/FederationMetadata/2007-06/FederationMetadata.xml`), Auth0 can check daily for changes in the configuration, such as the addition of a new signing certificate that was added in preparation for a rollover. Because of this, enabling the Federation Metadata endpoint is preferred to providing a standalone metadata file. If you provide a standalone metadata file, we will notify you via email when the certificates are close to their expiration date.\n\nIf the Federation Metadata contains both the primary and secondary certificates, you can use both in Auth0.\n\nTo roll over certificates using the Federation Metadata endpoint:\n\n1.  Generate a new certificate, and add it as the secondary certificate for your ADFS environment. This should be done at least **two days** before the expiration of your active primary certificate.\n    \n2.  Allow Auth0 to obtain your new certificate from the Federation Metadata endpoint. Auth0 checks your endpoints once a day, so be sure to allow sufficient time for Auth0 to complete this step. Alternatively, you can manually complete this step by logging in to the Auth0 Dashboard, navigating to the appropriate ADFS connection, and click **Save**. This action results in Auth0 downloading the certificates immediately.\n    \n3.  Set the now-secondary certificate as the primary certificate before the existing primary certificate expires in your ADFS environment.\n    \n\n## Learn more\n\n*   [Configure WS-Fed Applications](https://auth0.com/docs/get-started/applications/configure-ws-fed-applications)",
  "title": "Web Services Federation Protocol",
  "description": "Describes how Auth0 works with the Web Services Federation (WS-Fed) protocol.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock-ios/touchid-authentication",
  "markdown": "# Lock.swift: Passwordless\n\nLock Passwordless handles passwordless authentication using email and sms connections. To use Passwordless Authentication you need Lock.Swift version 2.14.0 or greater.\n\nTo show Lock, add the following snippet in your `UIViewController`.\n\n```\nLock\n    .passwordless()\n    .withOptions {\n         $0.oidcConformant = true\n    }\n    // withConnections, withOptions, withStyle, and so on.\n    .onAuth { credentials in\n      // Save the Credentials object\n    }\n    .present(from: self)\n```\n\nPasswordless can only be used with a single connection and will prioritize the use of email connections over SMS.\n\n### Passwordless Method\n\nWhen using Lock Passwordless the default `passwordlessMethod` is `.code` which sends the user a one time passcode to login. If you want to use [Universal Links](https://auth0.com/docs/get-started/applications/enable-universal-links-support-in-apple-xcode) you can add the following:\n\n```\n.withOptions {\n    $0.passwordlessMethod = .magicLink\n}\n```\n\n### Activity callback\n\nIf you are using Lock Passwordless and have specified the `.magicLink` option to send the user a universal link then you will need to add the following to your `AppDelegate.swift`:\n\n```\nfunc application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([Any]?) -> Void) -> Bool {\n    return Lock.continueAuth(using: userActivity)\n}\n```",
  "title": "Lock.swift: Passwordless",
  "description": "Using Passwordless authentication with Lock for iOS v2",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/flows/concepts/implicit",
  "markdown": "# Implicit Flow with Form Post\n\nYou can use OpenID Connect (OIDC) with many different flows to achieve web sign-in for a traditional web app. In one common flow, you obtain an ID token using authorization code flow performed by the app backend. This method is effective and robust, however, it requires your web app to obtain and manage a secret. You can avoid that burden if all you want to do is implement sign-in and you don’t need to obtain access tokens for invoking APIs.\n\nImplicit Flow with Form Post flow uses OIDC to implement web sign-in that is very similar to the way SAML and WS-Federation operates. The web app requests and obtains tokens through the front channel, without the need for secrets or extra backend calls. With this method, you don’t need to obtain, maintain, use, and protect a secret in your application.\n\n## How it works\n\n![Flows - Implicit with Form Post - Authorization sequence diagram](https://images.ctfassets.net/cdy7uua7fh8z/6m0uE4E7Hpzbdhyh9dEuYK/e36c910ff47a7540bf27e23c02822624/auth-sequence-implicit-form-post.png)\n\n1.  The user clicks **Login** in the app.\n    \n2.  Auth0's SDK redirects the user to the Auth0 Authorization Server (`/authorize` endpoint) passing along a `response_type` parameter of `id_token` that indicates the type of requested credential. It also passes along a `response_mode` parameter of `form_post` to ensure security.\n    \n3.  Your Auth0 Authorization Server redirects the user to the login and authorization prompt.\n    \n4.  The user authenticates using one of the configured login options and may see a consent page listing the permissions Auth0 will give to the app.\n    \n5.  Your Auth0 Authorization Server redirects the user back to the app with an ID Token.\n    \n\n## How to implement it\n\nYou can [use our Express OpenID Connect SDK](https://www.npmjs.com/package/express-openid-connect) to securely implement the Implicit Flow with Form Post.\n\nFinally, you can follow our tutorials to use our API endpoints to [Add Login Using the Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/add-login-using-the-implicit-flow-with-form-post).\n\n## Learn more\n\n*   [Auth0 Rules](https://auth0.com/docs/customize/rules)\n*   [Auth0 Hooks](https://auth0.com/docs/customize/hooks)\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)\n*   [Mitigate Replay Attacks When Using the Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow)",
  "title": "Implicit Flow with Form Post",
  "description": "Learn how the Implicit flow with Form Post works and why you should use it for traditional web apps that need only an ID Token to perform user authentication.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/policies/rate-limits",
  "markdown": "# Rate Limit Policy\n\nAuth0 limits the use of services to assure optimal performance and protection from bad actors, technical errors, or excessive legitimate traffic.  We recommend you review how Auth0 enforces limits to configure your application for the best user experience.\n\n## Introduction to Rate Limits\n\nAuth0 enforces limitations to protect services from excessive requests and protect customers from service interruptions or degradation.\n\nAuth0 observes, and in many cases, enforces an array of limits, including:\n\n*   Requests to environments (Private Cloud Only)\n    \n*   Requests to tenants via API or API Endpoint\n    \n*   Miscellaneous Limits\n    \n\n### Environment request limits (Private Cloud Only)\n\nIn Private Cloud, environment request limits are based on the Private Cloud Performance Tier.  To learn more, read [Private Cloud for AWS](https://auth0.com/docs/deploy-monitor/deploy-private-cloud/private-cloud-on-aws) or [Private Cloud for Azure](https://auth0.com/docs/deploy-monitor/deploy-private-cloud/private-cloud-on-azure).\n\nCurrently,  Private Cloud environment rate limits represent the highest load under which the Auth0 product will meet SLAs.  However, at this time, Auth0 only enforces and notifies customers when rate limits have been exceeded on a specific tenant within the environment.  Under most Private Cloud use cases, where customers maintain a single Production Tenant, this is not a problem; however, use cases that provision more than one production tenant should consider the expected load across all tenants in the environment and implement additional monitoring as necessary.   \n\nAs an example, consider a Performance Plus environment, where the environment rate limit is 1500 rps.  It is possible to create two tenants in this environment, one serving clients at 1400 rps, and another serving clients at 900 rps.  Neither tenant will be rate limited, but a combined load across the environment of 2300 rps exceeds the environment rate limit by 800 rps.  As a result, user experience may be degraded, and the availability of the environment might fall below published SLAs.\n\nFor Private Cloud load testing considerations, refer to [Private Cloud on AWS](https://auth0.com/docs/deploy-monitor/deploy-private-cloud/private-cloud-on-aws) and [Private Cloud on Azure](https://auth0.com/docs/deploy-monitor/deploy-private-cloud/private-cloud-on-azure).\n\n### Tenant request limits\n\nAuth0 limits the number of requests that can be made on a tenant.  These limits are configured depending on the API, and further by specific endpoints on each API.\n\n#### API rate limits\n\nAuth0 limits the number of requests that can be made to a specific API, regardless of the API endpoint.  API limits may vary by: \n\n*   API\n    \n*   Tenant type\n    \n*   Subscription level\n    \n\nFor example, a free, non-production tenant could have different limits than a production tenant with a paid subscription.\n\n#### Endpoint rate limits\n\nAuth0 limits the number of requests made to API endpoints and, in some cases, the number of endpoint operations.  API endpoint limits also vary by:\n\n*   API\n    \n*   Tenant type\n    \n*   Subscription level\n    \n\nFor example, a free, non-production tenant with a will have different limits than a production tenant with a paid subscription.\n\n### Tenant request limits order\n\nAs requests to your tenant are made, Auth0 evaluates requests against the global limit for the API, and then evaluates requests against the rate limit for specific API endpoints.\n\n### Miscellaneous Limits\n\n#### Database login limits\n\nFor database connections, Auth0 limits certain types of repeat login attempts depending on the user account and IP address. To protect the overall health of the system, Auth0 employs user/password rate limits that mitigate load. Auth0's high degree of customization can put us at risk of service degradation. Causes can include:\n\n*   High-load stress tests\n    \n*   Benchmark tests\n    \n*   Inefficient code that causes users to log in multiple times\n    \n\nRequests are subject to limits as outlined in the individual policies for Auth0 APIs.\n\nIn addition, there is a same user login rate limit: If one IP address makes 20 login attempts in one minute to the same user account, the rate limit comes into effect. After that, Auth0 allows the user 10 attempts per minute. Any combination of successful and failed login attempts count toward this limit.\n\n#### SMS message limits for multi-factor authentication (end-users only)\n\nIf you attempt to send more than 10 SMS messages to your device within one hour, you will receive an error message about a rate limit exception.\n\nWhen you exceed your messaging limit, you need to wait at least one hour after the first message request before requesting another. You will receive an additional attempt after the passage of each additional hour.\n\nLimits applied to Native Social login flow requests are identified based on the body of the requests with the following initial criteria:\n\n| Request Type | Body |\n| --- | --- |\n| `grant_type` | `urn:ietf:params:oauth:grant-type:token-exchange` |\n| `subject_token_type` | `http://auth0.com/oauth/token-type/apple-authz-code` |\n\n#### Public Performance\n\nThe Public Performance SKU enhances the existing Public Cloud deployment by increasing the API Request Limit to a Peak Performance Request Limit of 2X.\n\n**Customers may exceed this API Request Limit, up to the Peak Performance Request Limit, for up to 48 hours monthly, in 15-minute increments for a total of 192 15-minute increments.**\n\nIf the transaction limit bursts above the API-Request limit and exhausts the limit threshold of 100 RPS, then one 15-minute increment will be deducted, and the customer must use the remainder of that 15-minute increment to consume at the Peak Performance Request Limit within the 15-minute time frame before another increment is deducted.\n\nFor more information, see [Enterprise](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-configurations/enterprise-public).\n\n#### Extensibility concurrency limits\n\nTo ensure system availability and fair use of system resources, Auth0 limits the number of concurrent in-flight requests across all extensibility products. Tenants that exceed their concurrent request limits should expect errors for new requests until in-flight requests are completed. The concurrency limits are defined below:\n\n| Subscription | Concurrency limit |\n| --- | --- |\n| Public Cloud | 250 |\n| Tier Dev Private Cloud | 100 |\n| Private Cloud Basic 100 RPS (1x) | 200 |\n| Private Cloud Performance 500 RPS (5x) | 400 |\n| Private Cloud Performance 1500 RPS (15x) | 1200 |\n| Private Cloud Performance 3000 RPS (30x) | 1200 |\n| Private Cloud Performance 6000 RPS (60x) | 1200 |\n\nConcurrency can be calculated by multiplying expected RPS by the latency of each request. For example, a tenant that has two bound post-login Actions, which each take 250ms with a total login RPS of 400 have an expected concurrency of (2 \\* (400 requests / 1 second) \\* (.25 seconds / 1 request)) = 200.\n\nTo ensure that your tenant is not impacted by these concurrency limits, please ensure that potentially long-running extensibility logic, such as calls to external APIs, have reasonable timeouts.\n\n## Rate limit algorithm\n\nAuth0 sets rate limits and burst limits for its APIs. While the rate limit is the maximum sustainable amount of traffic the system allows on a sustained basis, the burst limit is the maximum short-term traffic volume the system allows within one time interval. Auth0 rate limits and burst limits work together to provide better limiting functionality for dynamic traffic volume.\n\nAuth0 rate limits use a token bucket algorithm containing the following configurations:\n\n*   **Limit keys:**  \n    \n    *   Typically, a rate limit key is based on a two main factors:\n        \n        *   API and endpoint\n            \n        *   Tenant type \n            \n    *   In some cases, additional factors include:\n        \n        *   Source IP\n            \n        *   Target User ID \n            \n*   **Limit values:**\n    \n    *   **Bucket size:** The maximum number of requests an API or endpoint receives in general, or receives from a specific user or IP address, before new requests are added.  \n        \n    *   **Refill rate:**  The rate new requests are added to the bucket. \n        \n\nFrom these two numbers, Auth0 calculates the burst limit and sustained rate limit:\n\n*   **Burst limit:**  Equal to bucket size. \n    \n*   **Sustained rate limit:**  Refill rate in requests per minute or second.\n    \n\nIf the sustained rate limit is calculated in Requests per Second, new requests are added by milliseconds. If the sustained rate limit is calculated in Requests per Minute, new requests are added on a second basis.\n\n## Learn more\n\n*   [Entity Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/entity-limit-policy)\n*   [Rate Limit Use Cases](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy/rate-limit-use-cases)",
  "title": "Rate Limit Policy",
  "description": "Describes Auth0's rate limit policy.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api-auth/grant/password",
  "markdown": "# Resource Owner Password Flow\n\nThough we do not recommend it, highly-trusted applications can use the Resource Owner Password Flow (defined in [OAuth 2.0 RFC 6749, section 4.3](https://tools.ietf.org/html/rfc6749#section-4.3)), which requests that users provide credentials (username and password), typically using an interactive form. Because credentials are sent to the backend and can be stored for future use before being exchanged for an Access Token, it is imperative that the application is absolutely trusted with this information.\n\nEven if this condition is met, the Resource Owner Password Flow should only be used when redirect-based flows (like the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)) cannot be used.\n\n## How it works\n\n![Diagram - Resource Owner Password Flow](https://images.ctfassets.net/cdy7uua7fh8z/4EeYNcnVX1RFcTy5z4lP4v/c3e4d22e6f8bf558caf07338a7388097/ROP_Grant.png)\n\n1.  The user clicks **Login** within the application and enters their credentials.\n    \n2.  Your application forwards the user's credentials to your Auth0 Authorization Server ([`**/oauth/token**` endpoint](https://auth0.com/docs/api/authentication#resource-owner-password)).\n    \n3.  Your Auth0 Authorization Server validates the credentials.\n    \n4.  Your Auth0 Authorization Server responds with an Access Token (and optionally, a Refresh Token).\n    \n5.  Your application can use the Access Token to call an API to access information about the user.\n    \n6.  The API responds with requested data.\n    \n\n## How to implement it\n\nThe easiest way to implement the Resource Owner Password Flow is to follow our tutorial to use our API endpoints to [Call Your API Using the Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/call-your-api-using-resource-owner-password-flow).\n\n## Realm support\n\nAuth0 provides an extension grant that offers similar functionality to the Resource Owner Password grant, but allows you to keep separate user directories (which map to separate connections) and specify which one to use during the flow.\n\nFor example, let's say you want to present a dropdown on your application's login user interface that allows users to choose their user type: `Employees` or `Customers`. In this case, you would configure `Employees` and `Customers` as realms (and set up a corresponding connection for each), which allows employee and customer credentials to be kept in separate user directories. When you request a token, you will submit the realm value along with the user's credentials and the submitted realm will be used to verify the password.\n\nTo learn more about implementing this extension grant, read [Call Your API Using Resource Owner Password Flow: Configure Realm Support](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/call-your-api-using-resource-owner-password-flow).\n\n## Rules\n\nRules will run for the Resource Owner Password Flow (including the Realm extension grant). However, redirect rules won't work. If you try to perform a redirect by specifying `context.redirect` in your rule, the authentication flow will return an error. To learn more about rules, read [Auth0 Rules](https://auth0.com/docs/customize/rules). To learn more about redirect rules, read [Redirect Users from Within Rules](https://auth0.com/docs/customize/rules/redirect-users).\n\n## MFA support\n\nIf you need to use the Resource Owner Password Flow, but require stronger authentication, you can add multi-factor authentication (MFA). To learn how, read [](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa)[Authenticate Using the Resource Owner Password Flow with MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n\n## Attack protection\n\nWhen using the Resource Owner Password Flow with brute-force protection, some attack protection features may fail. Some common issues, however, can be avoided. To learn more, read [Avoid Common Issues with Resource Owner Password Flow and Attack Protection](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection).\n\n## Learn more\n\n*   [Auth0 Rules](https://auth0.com/docs/customize/rules)\n*   [Auth0 Hooks](https://auth0.com/docs/customize/hooks)\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)",
  "title": "Resource Owner Password Flow",
  "description": "Learn how the Resource Owner Password flow works and why you should use it for highly-trusted applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/flows/concepts/client-credentials",
  "markdown": "# Client Credentials Flow\n\nThe Client Credentials Flow (defined in [OAuth 2.0 RFC 6749, section 4.4](https://tools.ietf.org/html/rfc6749#section-4.4)) involves an application exchanging its application credentials, such as client ID and client secret, for an access token.\n\nThis flow is best suited for Machine-to-Machine (M2M) applications, such as CLIs, daemons, or backend services, because the system must authenticate and authorize the application instead of a user.\n\n## How it works\n\n![Flows - Client Credentials - Authorization sequence diagram(w/Border)](https://images.ctfassets.net/cdy7uua7fh8z/4Ph562CAccmCUkKNXuEIlQ/47581872e40e87b2cca95aecf7f42c5b/diagram.png)\n\n1.  Application sends application's credentials to the Auth0 Authorization Server. To learn more about client authentication methods, read [Application Credentials](https://auth0.com/docs/secure/application-credentials).\n    \n2.  Auth0 Authorization Server validates application's credentials.\n    \n3.  Auth0 Authorization Server responds with an access token.\n    \n4.  Application can use the access token to call an API on behalf of itself. For more information on this process, see [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens).\n    \n5.  API responds with requested data.\n    \n\n## How to implement it\n\nThe easiest way to implement the Client Credentials Flow is to follow our [Backend Quickstarts](https://auth0.com/docs/quickstart/backend).\n\nAlternatively, you can use the Auth0 Authentication API to implement the Client Credentials Flow. For more information, read [Call Your API Using the Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow/call-your-api-using-the-client-credentials-flow).\n\n## Learn more\n\n*   [Auth0 Rules](https://auth0.com/docs/customize/rules)\n*   [Auth0 Hooks](https://auth0.com/docs/customize/hooks)\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)",
  "title": "Client Credentials Flow",
  "description": "Learn how the Client Credentials flow works and why you should use it for machine-to-machine (M2M) applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/api-auth/which-oauth-flow-to-use",
  "markdown": "# Which OAuth 2.0 Flow Should I Use?\n\nThe [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth) supports several different flows (or grants). Flow are ways of retrieving an Access Token. Deciding which one is suited for your use case depends mostly on your [application type](https://auth0.com/docs/get-started/applications), but other parameters weigh in as well, like the level of trust for the client, or the experience you want your users to have.\n\n## OAuth 2.0 terminology\n\n*   **Resource Owner**: Entity that can grant access to a protected resource. Typically, this is the end-user.\n    \n*   **Client**: Application requesting access to a protected resource on behalf of the Resource Owner.\n    \n*   **Resource Server**: Server hosting the protected resources. This is the API you want to access.\n    \n*   **Authorization Server**: Server that authenticates the Resource Owner and issues Access Tokens after getting proper authorization. In this case, Auth0.\n    \n*   **User Agent**: Agent used by the Resource Owner to interact with the Client (for example, a browser or a native application).\n    \n\n## Is the Client the Resource Owner?\n\nThe first decision point is about whether the party that requires access to resources is a machine. In the case of machine-to-machine authorization, the Client is also the Resource Owner, so no end-user authorization is needed. An example is a cron job that uses an API to import information to a database. In this example, the cron job is the Client and the Resource Owner since it holds the Client ID and Client Secret and uses them to get an Access Token from the Authorization Server.\n\nIf this case matches your needs, then to learn how this flow works and how to implement it, see [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow).\n\n## Is the Client a web app executing on the server?\n\nIf the Client is a regular web app executing on a server, then the Authorization Code Flow is the flow you should use. Using this the Client can retrieve an Access Token and, optionally, a Refresh Token. It's considered the safest choice since the Access Token is passed directly to the web server hosting the Client, without going through the user's web browser and risking exposure.\n\nIf this case matches your needs, then to learn how this flow works and how to implement it, see [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow).\n\n## Is the Client absolutely trusted with user credentials?\n\nThis decision point may result in the Resource Owner Password Credentials Grant. In this flow, the end-user is asked to fill in credentials (username/password), typically using an interactive form. This information is sent to the backend and from there to Auth0. It is therefore imperative that the Client is absolutely trusted with this information.\n\nThis grant should only be used when redirect-based flows (like the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)) are not possible. If this is your case, then to learn about how this flow works and how to implement it, see [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow).\n\n## Is the Client a Single-Page App?\n\nIf the Client is a Single-Page App (SPA), an application running in a browser using a scripting language like JavaScript, there are two grant options: the Authorization Code Flow with Proof Key for Code Exchange (PKCE) and the Implicit Flow with Form Post. For most cases, we recommend using the Authorization Code Flow with PKCE because the Access Token is not exposed on the client side, and this flow can return [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n\nTo learn more about how this flow works and how to implement it, see [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce). The [Auth0 Single-Page App SDK](https://auth0.com/docs/libraries/auth0-single-page-app-sdk) provides high-level API for implementing Authorization Code Flow with PKCE in SPAs.\n\nIf your SPA doesn't need an Access Token, you can use the Implicit Flow with Form Post. To learn more about how this flow works and how to implement it, see [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post).\n\n## Is the Client a Native/Mobile App?\n\nIf the Application is a native app, then use the **Authorization Code Flow with Proof Key for Code Exchange (PKCE)**.\n\nTo learn more about how this flow works and how to implement it, see [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).\n\n## I have an application that needs to talk to different resource servers\n\nIf a single application needs access tokens for different resource servers, then multiple calls to `/authorize` (that is, multiple executions of the same or different Authorization Flow) needs to be performed. Each authorization will use a different value for `audience`, which will result in a different access token at the end of the flow. For more information, see the [OAuth 2.0: Audience Information Specification](https://tools.ietf.org/html/draft-tschofenig-oauth-audience-00#section-3).\n\n## Can I try the endpoints before I implement my application?\n\nSure! You can use our [Authentication API Debugger Extension](https://auth0.com/docs/customize/extensions/authentication-api-debugger-extension). You can find detailed instructions per `/grant` endpoint at our [Authentication API Reference](https://auth0.com/docs/api/authentication).\n\n*   For the Authorize endpoint, go to [Authorize Application](https://auth0.com/docs/api/authentication#authorize-application) and read the \"Test this endpoint\" paragraph for the grant you want to test.\n    \n*   For the Token endpoint, go to [Get Token](https://auth0.com/docs/api/authentication#get-token) and read the \"Test this endpoint\" section for the grant you want to test.",
  "title": "Which OAuth 2.0 Flow Should I Use?",
  "description": "Learn how to identify the proper OAuth 2.0 flow for your use case.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/migrations/past-migrations",
  "markdown": "# Past Migrations\n\nThese are migrations that have already been enabled for all customers. If you have any questions, create a ticket in our [Support Center](https://support.auth0.com/).\n\n## Password Reset and Email Verification Links in Tenant Logs Deprecation\n\n**Deprecated**: December 7, 2023\n\n**End of life**: February 5, 2024\n\nPassword reset and email verification links will no longer be logged to tenant logs. These links can be retrieved from the password reset or email verification Management API request response.\n\n## Reducing Maximum Expiration Time for Login Transactions\n\n**Deprecated**: September 5, 2023 (Public Cloud), November 21, 2023 (Private Cloud)\n\n**End of life**: February 21, 2024\n\nWith this change, we will enforce a maximum lifetime of 1 hour for redirection-based login flows. Login flows that take longer than 1 hour to complete will expire in both Universal and Classic Login. After expiration, subsequent actions from the end user’s browser (e.g. input email/password, redirect back to Actions/Rules, etc.) will result in either:\n\n*   A redirect to the associated application’s default login route to reinitiate the flow as a new login transaction, or\n    \n*   An error page if the default login route is not configured.\n    \n\n## Unregistered Scopes in Refresh Tokens Deprecation\n\n**Deprecated**: July 12, 2023\n\n**End of life**: January 17, 2024\n\nWe are improving scope evaluation during refresh token exchange to ensure that unregistered scopes cannot be requested. Custom scope values not registered against the `aud` or `audience` value (for an API registered in your tenant) are considered unregistered scopes.\n\nWith this change, the API scope evaluation will include any custom scopes requested during user authentication or injected through extensibility, such as [Rules](https://auth0.com/docs/customize/rules). This evaluation will validate that all scopes are registered, returning an error if any are not registered.\n\n## auth0-cordova, angular-auth0, and express-oauth2-bearer Repo Deprecations\n\n**Deprecated**: April 27, 2023\n\n**End of life**: June 30, 2023 (express-oauth2-bearer), October 27, 2023 (angular-auth0 and auth0-cordova)\n\nWe have deprecated the following repos:\n\n*   [express-oauth2-bearer](https://github.com/auth0/express-oauth2-bearer) | [migration guide](https://github.com/auth0/express-oauth2-bearer/blob/master/MIGRATION_GUIDE.md)\n    \n*   [angular-auth0](https://github.com/auth0/angular-auth0) | [migration guide](https://github.com/auth0/angular-auth0/blob/master/MIGRATION_GUIDE.md)\n    \n*   [auth0-cordova](https://github.com/auth0/auth0-cordova) | [migration guide](https://github.com/auth0/auth0-cordova/blob/master/MIGRATION_GUIDE.md)\n    \n\nThese libraries will no longer be supported. Please remove these libraries from any active projects before these dates.\n\nIf you have any questions or concerns, please reach out to us on GitHub.\n\n## Actions Migration from Node.js 16 to Node.js 18\n\n**Target migration**: Sept 11, 2023\n\nAs part of our mission to support every future version of LTS Node.js through Actions, and to be in line with the Node JS developer community, we are releasing Node 18 while Node 16 is still in Active LTS. We urge all customers to transition today to Node 18 and make the most of its LTS. Remember, while Node 16 LTS remains available until September, their use may involve certain risks following the conclusion of LTS and we recommend you to update to Node 18.\n\nNode.js 18 is now generally available (GA) across our entire suite of extensibility offerings. This includes Actions, Rules, Hooks, Database Scripts, and Custom Social Connections. We strongly encourage everyone to update to Node 18 by Sept 11, 2023, to adhere to best code security practices.\n\n## Support for edge.js in Extensibility Features\n\n**Deprecated:** December 21, 2022\n\n**End of life:** June 21, 2023\n\nAfter June 21, 2023, Auth0 will no longer support running .NET and C# from Node.js in Extensibility features. Auth0 previously supported a subset of the C# language to write extensibility code for Rules, Hooks, and Custom Database Scripts via a Node.js module called edge.js.\n\nDeprecating support for running .NET and C# from Node.js in Extensibility is critical to maintaining a performant and secure platform for running untrusted code. This change will allow us to continue improving our next-generation Extensibility offerings. To learn more, read [Migrate from edge.js extensibility features](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations/migrate-from-edge-js-extensibility-features).\n\n## Support for oracledb in Extensibility Features\n\n**Deprecated:** December 21, 2022\n\n**End of life:** June 21, 2023\n\nAuth0 will no longer support the auth0-claims-provider add-on for Sharepoint 2010/2013 after July 31, 2023.\n\nAfter June 21, 2023, Auth0 will no longer support connecting to Oracle Databases from Node.js in Extensibility features. Auth0 previously supported connecting to Oracle Databases from extensibility code for Rules, Hooks, and Custom Database Scripts via a Node.js module called [oracledb](https://www.npmjs.com/package/oracledb).\n\nDeprecating support for connecting to Oracle Databases from Node.js in Extensibility is critical to maintaining a performant and secure platform for running untrusted code. This change will allow us to continue improving our next-generation Extensibility offerings.\n\nTo learn more, read [Migrate from oracledb extensibility features](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations/migrate-from-oracledb-extensibility-features).\n\n## Auth0 Claims Provider for SharePoint 2010 / 2013\n\n**Deprecated:** January 31, 2023\n\n**End of life:** July 31, 2023\n\nAuth0 will no longer support the auth0-claims-provider add-on for Sharepoint 2010/2013 after July 31, 2023. Without this add-on, you won’t be able to use the “Sharepoint People Picker” with Auth0 connections to assign permissions to Sharepoint 2010/2013 users.\n\nYou must remove any integrations with the auth0-claims-provider add-on before July 31, 2023. After that date, any remaining integrations with the auth0-claims-provider add-on will cease to function properly and may impact users of your applications.\n\n**Deprecated:** November 9, 2022\n\n**End of life:** May 9, 2023\n\nTo improve performance, the Get Role Users Management API endpoint will only return greater than 1,000 total results if the checkpoint pagination method is used. This pagination method is optimized to support large quantities of results. The offset pagination method will be capped at 1,000 results.\n\nFor implementation details for the two pagination methods, read the [Management API documentation for the Get Role Users endpoint](https://auth0.com/docs/api/management/v2/roles/get-role-user).\n\n## Legacy Custom Claims\n\n**Deprecated:** July 28, 2022 (Public Cloud), August 31, 2022 (Private Cloud)\n\n**End of life:** January 30, 2023 (Public Cloud), April 18, 2023 (Private Cloud)\n\nBeginning January 30, 2023 in Public Cloud and April 18, 2023 in Private Cloud, Auth0 will allow the addition of non-namespaced custom claims to JWT tokens using Auth0 Actions and in responses from the Authentication API `/userinfo` endpoint. Previously, Auth0 allowed namespaced claims on access and ID tokens via extensibility code ([Rules](https://auth0.com/docs/customize/rules) / [Hooks](https://auth0.com/docs/customize/hooks) / [Actions](https://auth0.com/docs/customize/actions)). The migration to custom claims allows private, non-namespaced custom claims and OIDC user profile claims to be added to access tokens; ID tokens currently support user profile claims and will additionally support private, non-namespaced custom claims. These claims will also be added to the Auth0 `/userinfo` response. To begin the migration, read the [Custom Claims Migration Guide](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations/custom-claims-migration).\n\nIf your tenant is running extensibility code ([Rules](https://auth0.com/docs/customize/rules) / [Hooks](https://auth0.com/docs/customize/hooks) / [Actions](https://auth0.com/docs/customize/actions)) that tries to set non-namespaced custom claims that are being ignored until this deprecation, then those claims will begin to appear on the tokens and the `/userinfo` response. We recommend you review your configuration and Auth0 logs.\n\nWith the addition of non-namespaced, private claims, Auth0 is enforcing the following restrictions that could potentially affect your tenant:\n\n*   Auth0 will restrict the custom claims payload to a maximum of 100KB. \n    \n*   Auth0 will restrict the customization/modification of OPENID standard claims or claims used internally by Auth0. \n    \n*   In the future, Auth0 may restrict the use of other claims not included in the above list. In those cases, customers will be notified with a reasonable time to migrate.\n    \n*   Auth0 will restrict the creation of private, non-namespaced custom claims on access tokens with an Auth0 audience, excluding the `/userinfo` endpoint.\n    \n*   Only specified OIDC user profile claims can be added to access tokens.\n    \n*   Auth0 will restrict creating a custom claim starting with a $ character.\n    \n\nTo learn more about custom claims, review [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\n## Legacy Private Cloud Platform \n\n**Deprecated:** June 13, 2022\n\n**End of life:** January 31, 2023\n\nWe’re making improvements to the underlying infrastructure that supports Auth0 Private Cloud by introducing a modern Kubernetes-based technology stack, as well as database upgrades. We are currently working with all Auth0 Private Cloud customers to schedule the upgrade of their private cloud deployment to the new infrastructure stack during the course of this year, and will be discontinuing the older stack by January 31, 2023.\n\nIn addition, 2205 (May 2022 release) is the last official release for the legacy Private Cloud platform. Any bugs or security vulnerabilities will be assessed and addressed in patch releases as necessary.  Prior to upgrading to the new infrastructure stack, environments will need to be updated to the minimum compatible version to support the upgrade efforts.\n\nPlease reach out to your Technical Account Manager with any questions.\n\n## Log Extensions\n\n**Deprecated:** May 4, 2022 (Public Cloud), June 9, 2022 (Private Cloud release 2205)\n\n**End of life:** May 2, 2023 (Public Cloud), January 6, 2023 (Private Cloud)\n\nBeginning May 4, 2022, in Public Cloud and June 9th, 2022, in Private Cloud, the following Auth0 Log Extensions will be deprecated:\n\n*   Auth0 Authentication API Webhooks\n    \n*   Auth0 Management API Webhooks\n    \n*   Logs to Cloudwatch\n    \n*   Logs to Logentries\n    \n*   Logs to Loggly\n    \n*   Logs to Logstash\n    \n*   Logs to Papertrail\n    \n*   Logs to Splunk\n    \n*   Logs to Sumo Logic\n    \n\n**Deprecated:** November 2, 2022 (Public Cloud), December 21, 2022 (Private Cloud)\n\n**End of life:** May 2, 2023 (Public Cloud), May 31, 2023 (Private Cloud)\n\nBeginning November 2, 2022 in Public Cloud and December 21, 2022 in Private Cloud, the following Auth0 Log Extensions will be deprecated:\n\n*   Logs to Segment\n    \n*   Logs to Mixpanel\n    \n*   Logs to AppInsights\n    \n*   Logs to Azure Blob Storage\n    \n\nAll the Log extensions listed above are now deprecated. You can set up equivalent functionality using log event streams or integrations on the [Auth0 Marketplace](https://marketplace.auth0.com/). On November 2, 2022 in Public Cloud and December 21, 2022 in Private Cloud, Auth0 will no longer support the installed log extensions from the list above. For more information, read [Migrate from Log Extensions](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations/migrate-from-log-extensions).\n\n## Tenant Hostname Validation\n\n**Deprecated**: December 9, 2021 and December, 2021 (Private Cloud Release 2112.2)\n\n**End of life**: June 9, 2022 and September 9, 2022 (Private Cloud)\n\nAs of June 9, 2022 in Public Cloud and September 9, 2022 in Private Cloud, Auth0 will increase the security of API calls by adding a validation step for tenant hostnames to the Authentication API’s identification process. When a call is made, the Authentication API will validate the entity identifier (eg: `client_id`) of the requesting tenant as well as the tenant name in the URL domain. The tenant owning the identifier **must** be from the same tenant in the URL domain or the request will be rejected.\n\nIf your application or API calls any of the listed endpoints, you must configure your API calls to make sure the identifier of the requesting tenant and hostname are the same: \n\n*   `/oauth/token`\n    \n*   `/co/authenticate`\n    \n*   `/userinfo`\n    \n*   `/login`\n    \n*   `/oauth/revoke`\n    \n*   `/mfa/challenge`\n    \n*   `/p/<connection-type>/<ticket>` (Enterprise connection provisioning endpoint)\n    \n\nTo learn more, read [Tenant Hostname Validation Migration](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/tenant-hostname-migration).\n\n## Node.js 16 Migration\n\n**End of life**: April 30, 2022\n\nOn 30 Apr 2022, [Node.js v12 went out of long-term support (LTS)](https://github.com/nodejs/Release#release-schedule), which means that the Node.js development team no longer back-ports critical security fixes to this version. This could potentially expose your extensibility code to security vulnerabilities. Therefore, Auth0 is migrating from Node 12 to Node 16.\n\nAlthough the Node 16 update will not introduce any breaking changes in the Node.js standard library (Rules and Custom Database Action Scripts are affected; see the [Breaking changes - Rules and Custom Database Action Scripts only](#breaking-changes-rules-only) section), we encourage customers on Node version 12 to stay current with Active Long-Term Support (LTS) Node versions for security and compliance purposes. Customers who are still on Node 8 are out of security compliance and must migrate to Node 16 to eliminate security risks. We removed the Node 8 runtime on 22 Feb 2022 for Public Cloud tenants and removed it in the April 2022 Private Cloud release. After these dates, tenants still set to Node 8 run the risk of a service interruption.\n\n**Deprecated**: October 7, 2021 (Public Cloud), December 2021 (Private Cloud)\n\n**End of life**: April 12, 2022 (Public Cloud), June 30, 2022 (Private Cloud)\n\nBeginning April 12, 2022 in Public Cloud and with the December 2021 Private Cloud, access token and authorization codes will be issued with varied lengths to support [OAuth specification RFC6749](https://datatracker.ietf.org/doc/html/rfc6749) to avoid clients making assumptions about authorization code and access token values. Currently, the access token and authorization code sizes are fixed. The current size of the authorization code is shorter than what some security practitioners recommend. Through this change, Auth0 provides a stronger code and token while also improving the performance of Auth0 systems.\n\nCustomers with systems configured to rely on specific-sized authorization code and access token length must change from fixed-sized to variable-sized configurations before April 12, 2022 in Public Cloud or the June 30, 2022 Private Cloud release.\n\n## Node.js v8 Extensibility Runtime End of Life\n\n**Deprecated**: 15 April 2020\n\n**End of life**: 25 February 2022 (Public Cloud), April 2022 (Private Cloud release)\n\nBeginning 13 December 2019, [Node.js v8 was no longer under long-term support (LTS)](https://github.com/nodejs/Release#release-schedule). This means that critical security fixes were no longer back-ported to this version. Customers who are still on Node 8 are out of security compliance and must migrate to Node 12 to eliminate security risks. To learn more about how to migrate your tenant-level Node version from 8 to 12, read [Migrate from Node.js 8 to Node.js 12](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-nodejs-12).\n\nBecause Node.js v12 is also going out of LTS in 2022, we also highly encourage all customers using Rules and Hooks to migrate to Actions using Node 16 as soon as possible, and before Node 12 support expires formally from the Node.js community on 30 April 2022. To learn more about required migration steps, read [Migrate Rules and Hooks to Actions](https://auth0.com/docs/customize/actions/migrate/migrate-from-rules-to-actions).\n\n## Legacy Network Edge Deprecation\n\n**Deprecated**: 05 May 2021 (Public Cloud)\n\n**End of life**: 03 November 2021 (Public Cloud)\n\nAuth0 legacy network edge will cease to function on Public Cloud. After 03 November 2021, Public Cloud tenants who have not completed a migration to the new Auth0 network edge will no longer receive traffic. All new custom domains are automatically created on the new network edge.\n\n## Unpaginated Management API v2 Request deprecation\n\n**Deprecated**: 21 July 2020 (Public Cloud)\n\n**End of life**: 26 January 2021 (Public Cloud), February 2022 (Private Cloud release)\n\nAfter 26 January 2021, requests to the following Management API v2 endpoints will return a maximum of 50 items for Public Cloud tenants. To retrieve more items, you must include `page` and `per_page` parameters. Beginning on 21 July 2020, Auth0 will display tenant logs and a migration toggle to help you prepare for this change.\n\n*   [`GET /api/v2/clients`](https://auth0.com/docs/api/management/v2#!/Clients/get_clients)\n    \n*   [`GET /api/v2/client-grants`](https://auth0.com/docs/api/management/v2#!/Clients/client_grants)\n    \n*   [`GET /api/v2/grants`](https://auth0.com/docs/api/management/v2#!/Clients/grants)\n    \n*   [`GET /api/v2/connections`](https://auth0.com/docs/api/management/v2#!/Clients/connections)\n    \n*   [`GET /api/v2/device-crecentials`](https://auth0.com/docs/api/management/v2#!/Clients/device_credentials) (when the `type` query parameter is used)\n    \n*   [`GET /api/v2/resource-servers`](https://auth0.com/docs/api/management/v2#!/Clients/resource_servers)\n    \n*   [`GET /api/v2/rules`](https://auth0.com/docs/api/management/v2#!/Clients/rules)\n    \n\nAll Public Cloud tenants are affected that are created before 21 July 2020 and are actively calling affected endpoints without passing the `per_page` parameter for queries that can return more than 1 result. Tenants are not affected if they are created after 21 July 2020, are not using the affected endpoints, are using the affected endpoints and passing the `per_page` parameter, or are making queries that always return only 1 result. To learn more, read [Migrate to Management API v2 Endpoint Paginated Queries](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-paginated-queries).\n\n## Private Cloud Custom Domain Deprecation\n\n**Deprecated**: 17 June 2021\n\n**End of life**: 20 December 2021 \n\nTo achieve consistency across all Auth0 deployments and focus on enhancing the Auth0 Custom Domain feature, we are discontinuing the Private Cloud Custom Domain capability on December 20, 2021. Consistency enables us to enhance the feature and fix reliability issues faster, improving operational efficiency and enabling customers to get value out of custom domains more quickly. To learn more about migration to Auth0 Custom Domains, read [Migrate Private Cloud Custom Domains](https://auth0.com/docs/migrate-private-cloud-custom-domains).\n\n## Logout Redirect Validation\n\n**Deprecated**: 25 May 2021\n\n**End of life**: 01 December 2021 \n\nOn 01 December 2021, the logout behavior will change to always redirect users to the URI passed to the Auth0 logout APIs instead of using the `returnTo` query parameter passed by Identity Providers to `/login/callback` during the execution of the logout. If Auth0 does not have a record of a preceding call to one of these APIs, logout will complete, but redirection will not occur and an error page will be displayed to end users. To learn more, read [Logout Redirects Migration Guide](https://auth0.com/docs/product-lifecycle/deprecations-and-migrations/logout-return-to).\n\n## Application Admin Dashboard Role deprecation\n\n**Deprecated**: 01 February 2021\n\n**End of life**: 30 September 2021 (Public Cloud), September 2021 (Private Cloud monthly release)\n\nAuth0 is changing the role-based access control to the Dashboard. The Application Administrator role as defined today is being deprecated. After 01 February 2021, administrators won't be able to invite members with the deprecated Application Administrator role. Existing application-specific administrators will continue to be able to use the Dashboard with the existing permission set until the end of life date.\n\nA new set of Dashboard roles is available for improved and more secure collaboration among team members, including viewer and editor roles with limited access. A new **Editor - Specific Apps** role replaces the previous **Application Administrator** role for subscription plans where editor roles are supported.\n\nYour tenants will be affected by this deprecation if the following criteria are met:\n\n*   Created before 01 February 2021\n    \n*   Have at least one tenant member with the **Application Admin** role\n    \n*   Haven't opted-in to the Dashboard roles feature preview\n    \n\nBeginning on 01 February 2021, Auth0 will display a migration toggle to help you prepare for this change. To learn more, read [Migrate to Manage Dashboard New Roles](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-tenant-member-roles).\n\n## Legacy TLS Deprecation\n\n**Deprecated**: 19 January 2021\n\n**End of life**: 10 May 2021 (Public Cloud), June Private Cloud Release (v2106)\n\nAs of 10 May 2021 for Public Cloud and the June Private Cloud Release (v2106), the Auth0 network edge will no longer accept TLS 1.0 or TLS 1.1 traffic.  These legacy protocols are insecure, with well-known weaknesses and vulnerabilities within the industry.  For maximum security, all Auth0 clients must upgrade to TLS 1.2 or later. The exact details and steps required will vary, depending on your application. To learn more, read [Upgrade to TLS 1.2, what action to take?](https://community.auth0.com/t/upgrade-to-tls-1-2-what-actions-to-take/56547) posted in the Auth0 Community.\n\n## Auth0-analytics.js deprecation\n\n**Deprecation**: January 2018\n\n**End of life**: January 2021\n\nAuth0 has deprecated the use of the [auth0-analytics.js library](https://github.com/auth0/auth0-analytics.js/) that adds Facebook and Google Analytics integration with Lock. It listens for events in Lock and passes them to the Auth0-tag-manager.js library. It may still function in some legacy cases. This library is no longer maintained. You may need to write custom code to use [auth0-tag-manage.js](https://github.com/auth0/auth0-tag-manager) to manage proxy requests to third-party analytics libraries such as Facebook, Twitter, and Google.\n\n## Device credential metadata without user\\_id deprecation\n\n**Deprecated**: 31 August 2020\n\n**End of life**: 17 December 2020\n\nAuth0 now requires that you provide the `user_id` when you use the [GET /api/v2/device-credentials endpoint](https://auth0.com/docs/api/management/v2/#!/Device_Credentials/get_device_credentials). If your request does not provide a `user_id`, it will return a 400 status code. Check the `depnote` in your tenant logs to see if you are affected by this deprecation. To learn more, read [Check Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors).\n\nAuth0 has identified tenants affected by this deprecation and contacted the administrators for those tenants. If your tenant is currently making requests without a `user_id`, you should make the change as soon as possible.\n\n**Deprecated**:\n\n*   Public Cloud: 18 November 2020\n    \n*   Private Cloud: 01 December 2020\n    \n\n**End of life**:\n\n*   Public Cloud: 18 May 2021\n    \n*   Private Cloud: June Private Cloud Release (v2106)\n    \n\nAuth0 previously set the `email_verified` field to true in Azure AD and ADFS connections. If you used Azure AD/ADFS connections before this deprecation date, you have a tenant setting that overrides the connection setting for email verification and keeps the previous behavior.\n\nOn 18 May 2021 in Public Cloud and the June Private Cloud Release (v2106), Auth0 begins using the connection-level property for all Azure AD/ADFS connections. You should make sure all your connections are configured properly before that date. To learn more, read [Email Verification for Azure AD and ADFS](https://auth0.com/docs/connections/azuread-adfs-email-verification).\n\n## sameSite cookie attribute changes\n\n**Effective**: February 2020\n\nGoogle Chrome v80 is changing the way it handles cookies. To that end, Auth0 will implement the following changes in the way it handles cookies:\n\n*   Cookies without the `samesite` attribute set will be set to `lax`\n    \n*   Cookies with `sameSite=none` must be secured, otherwise they cannot be saved in the browser's cookie jar\n    \n\nThe goal of these changes is to improve security and help mitigate CSRF attacks. For details, see [sameSite Cookie Attribute Changes](https://auth0.com/docs/manage-users/cookies/samesite-cookie-attribute-changes).\n\n## User Search v2 deprecation\n\n**Deprecated**: 10 November 2018\n\n**End of life**: 30 June 2019 (Public Cloud), May 2021 (Private Cloud monthly release)\n\nFor Public Cloud, User Search v2 was deprecated and you should have taken action before 30 June 2019. Notifications were sent to customers that need to complete this migration.\n\nFor Private Cloud, User Search v1 and v2 endpoints will be no longer be available after the May Private Cloud monthly release and have been replaced with the new User Search v3 endpoint.\n\n## Passwordless Endpoint from Confidential Applications deprecation\n\nAuth0 has deprecated the use of the `/passwordless/start` endpoint from confidential applications when Auth0 cannot authenticate that the call is made on behalf of the application. To learn more, read [Migrate to Passwordless Endpoint from Confidential Applications](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-passwordless).Clickjacking Protection for Universal Login changes\n\nTo prevent clickjacking, in cases where you render your login page in an iframe, Auth0 has added an opt-in to add headers which we strongly recommend you enable. For details, see [Clickjacking Protection for Universal Login Change](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/clickjacking-protection-for-universal-login).\n\n## Management API endpoints using ID token credentials deprecation\n\n**Deprecation**: 31 March 2018\n\n**End of life**: TBD\n\nAuth0 is deprecating the use of ID tokens as credentials to call some of the users and device endpoints and replacing it with the use of access tokens instead. For details, see [Migrate to Management API Endpoints with Access Tokens](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-calling-api-with-access-tokens) and [Migrate to Link User Accounts with Access Tokens](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/link-user-accounts-with-access-tokens-migration).\n\n## Resource Owner Password /oauth/ro deprecation\n\n**Deprecation**: 08 July 2017\n\n**End of life**: TBD\n\nAs of 08 July 2017 Auth0 has deprecated the `/oauth/ro` endpoint for both password and passwordless connections. You can now implement the same functionality using the `/oauth/token` endpoint. To learn more, read [Resource Owner Password Flow Migration](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migration-oauthro-oauthtoken).\n\n## Management API v1 deprecation\n\n**Deprecation**: October 2016\n\n**End of life**:\n\n*   Public Cloud: 13 July 2020\n    \n*   Private Cloud: November 2020 monthly release\n    \n\nManagement API v1 will reach its End of Life in the Public Cloud on 13 July 2020. Management API v1 will be included in the Private Cloud until the November 2020 monthly release, which is the first release that will not include Management API v1. You may be required to take action before that date to ensure no interruption to your service. Notifications have been and will continue to be sent to customers that need to complete this migration.\n\n## Instagram connection deprecation\n\n**Deprecated**: 05 March 2020\n\n**End of life**: 31 March 2020\n\nFacebook announced that on 31 March 2020 that they will turn off the Instagram legacy APIs, and they won't provide an alternative to implement login with Instagram. For details, see [Instagram Connection Deprecation](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/instagram-connection-deprecation).\n\n## Yahoo API changes\n\n**Deprecated**: 01 March 2020\n\n**End of life**: 01 March 2020\n\nYahoo changed the way to retrieve the user profile and the information included in it. For details, see [Yahoo API Changes](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/yahoo-api-changes).\n\n## Google Cloud Messaging deprecation\n\n**Deprecation**: 11 April 2019\n\n**End of life**: 11 April 2019\n\nAs of 11 April 2019, [Google deprecated](https://firebase.googleblog.com/2018/04/time-to-upgrade-from-gcm-to-fcm.html) and replaced Google Cloud Messaging (GCM) with Firebase Cloud Messaging (FCM). For details, see [Google to Firebase Cloud Messaging Migration](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/google-firebase-migration).\n\n**Deprecation**: 30 April 2019\n\n**End of life**: 30 July 2019\n\nOn 30 April 2019, Facebook deprecated the use of the **Social Context** field for new applications. For details, see [Facebook Social Context Field Deprecation](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/facebook-social-context-field-deprecation).\n\n## Facebook Graph API changes\n\n**Deprecation**: 01 August 2018\n\n**End of life**: Graph API v3 released 08 January 2019\n\nAs of 01 August 2018, Facebook has changed the Facebook Graph API permissions and fields that can be requested. Auth0 has updated Facebook Connections to reflect these changes and modified the connection interface for clarity. See [Facebook Login Changelog: Recent Changes to Facebook Login](https://developers.facebook.com/docs/facebook-login/changelog#2018-07-02) for complete details and key dates. For details, see [Facebook Graph API Changes](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/facebook-graph-api-changes).\n\n## Lock v11 and Auth0.js v9\n\nWe are continually improving the security of our service. As part of this effort, we have deprecated the Legacy Lock API, which consists of the `/usernamepassword/login` and `/ssodata` endpoints. These endpoints are used by Lock.js v8, v9, and v10 and Auth0.js, v6, v7, and v8, and can also be called directly from applications.\n\nAs of August 6, 2018, Auth0 has permanently disabled the Legacy Lock API. This removal of service fully mitigates the CSRF vulnerability [disclosed in April 2018](https://auth0.com/blog/managing-and-mitigating-security-vulnerabilities-at-auth0/). This also ends the soft removal grace period that was [first announced on 16 July 2018](https://community.auth0.com/t/auth0-legacy-lock-api-disabled-grace-period-available/12949), meaning the Legacy Lock API can no longer be re-enabled.\n\nIf your Legacy Lock API migration has not yet been completed, your users may experience an outage, failed logins, or other adverse effects. You will need to complete your migration in order to restore normal functionality. Check deprecation errors to identify the source(s) of any errors in your tenant logs related to deprecations.\n\n### Features affected\n\nIf you are currently implementing login in your application with Lock v8, v9, or v10, or Auth0.js v6, v7, or v8, you are affected by these changes. Additionally, you are affected if your application calls the `/usernamepassword/login` or `/ssodata` endpoints directly via the API.\n\nWe recommend that applications using Universal Login update the library versions they use inside of the login page.\n\nHowever, those who are using Lock or Auth0.js embedded within their applications, or are calling the affected API endpoints directly, are required to update, and applications which still use deprecated endpoints will cease to function properly after the removal of service date.\n\nLibraries and SDKs not explicitly named here are not affected by this migration.\n\n## Tenant Log Search v2 deprecation\n\n**Deprecation**: 21 May 2019\n\n**End of life**:\n\n*   Free: 09 July 2019\n    \n*   Essential (former Developer): 20 August 2019\n    \n*   Professional (former Developer Pro): 20 August 2019\n    \n*   Enterprise: 04 November 2019\n    \n\nTo provide our customers with the most reliable and scalable solution, Auth0 has deprecated Tenant Logs Search Engine v2 in favor of v3. Auth0 is proactively migrating customers unaffected by this change, while those who are potentially affected are being notified to opt in for v3 during the provided grace period. For details, see [Migrate to Tenant Log Search v1 to V2](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-tenant-log-search-v3).\n\n## New IP addresses for Allowlisting in Australia\n\nAs of 30 September 2017, Auth0 updated its cloud environments and traffic from Australia originates from new IP addresses. If you are allowlisting IP addresses, you will need to add the new addresses to your firewall rules.\n\n### Features affected\n\nIf you are using a custom database connection, rule, and/or custom email provider that connects to your environment, **and** you have implemented firewall restrictions for IP address ranges, then you are affected by this change. You will need to make sure the following IP addresses are allowed to go through your firewall:\n\n`13.55.232.24, 13.54.254.182, 13.210.52.131, 52.62.91.160, 52.63.36.78, 52.64.84.177, 52.64.111.197, 52.64.120.184, 54.66.205.24, 54.79.46.4, 54.153.131.0`\n\n## New IP addresses for allowlisting in Europe\n\nAs of 30 September 2017, Auth0 updated its cloud environments and traffic from Europe originates from new IP addresses. If you are allowlisting IP addresses, you will need to add the new addresses to your firewall rules.\n\n### Features affected\n\nIf you are using a custom database connection, rule, and/or custom email provider that connects to your environment, and you have implemented firewall restrictions for IP address ranges, then you are affected by this change. You will need to make sure the following IP addresses are allowed to go through your firewall:\n\n`34.253.4.94, 35.156.51.163, 35.157.221.52, 52.16.193.66, 52.16.224.164, 52.28.45.240, 52.28.56.226, 52.28.184.187, 52.28.212.16, 52.29.176.99, 52.50.106.250, 52.57.230.214, 52.211.56.181, 52.213.216.142, 52.213.38.246, 52.213.74.69`\n\n## CDN provider migration in the Europe and Australia environments\n\nAs of 12 July 2017, Auth0 has improved the Auth0 CDN scaling and availability. We now use Amazon CloudFront. We have already made this change in the US environment, and are now ready to do so in Europe and Australia.\n\n### Features affected\n\nYou are affected if you use Lock (hosted by our CDN) in Europe or Australia. This change shouldn't cause any disruption or change in behavior in your applications, so you don't have to do anything. This notification is for information only.\n\n## Password and refresh token exchange rules migration\n\nOn 31 May 2017, as part of Auth0's efforts to improve security, we added the ability to execute rules during the OAuth 2.0 Resource Owner Password Grant exchange (the password exchange) and the refresh token exchange.\n\n### Features affected\n\nYou are using this feature if you are calling the `/oauth/token` endpoint of our Authentication API with `grant_type = \"password\"` , `grant_type = \"http://auth0.com/oauth/grant-type/password-realm\"`, or `grant_type = \"refresh_token\"`.\n\nYou could be impacted if you are currently using these exchanges and have rules defined in Dashboard. In order to ensure a smooth transition, we have disabled the rules execution on these specific exchanges for your tenant. These rules will now execute for all new customers, as well as customers who have not yet used these exchanges.\n\nYou can add logic to your rules to alter their behavior for these exchanges by checking the `context.protocol` property:\n\n*   `oauth2-password` indicates the password (and password-realm) exchange\n    \n*   `oauth2-refresh-token` indicates the Refresh Token exchange\n    \n\nIf you would like to enable the new behavior on this tenant for testing before the mandatory opt-in date, login to [Dashboard](https://manage.auth0.com/#) and enable the **Run Rules on Password and Refresh Token Exchanges** toggle in [Tenant Settings > Advanced](https://manage.auth0.com/#/tenant/advanced).\n\n## Account linking removal\n\nOn 01 March 2017, as part of Auth0's efforts to improve security and standards compliance, we stopped supporting account linking as part of the authorization callback (that is, accepting an access token as part of the authorize call).\n\n### Features affected\n\nIf you received an email notification about it, then you are impacted by this change. As you work to update your applications to use the Management API to link accounts, you can check if you are still impacted, by checking your tenant logs for warnings. These entries will be logged if you are sending an Access Token in your authorize calls.\n\n## Allowlist IP address ranges\n\nAs of 20 February 2017, Auth0 expanded into new US regions and traffic originating from these regions will have new IP addresses. If you allowlist IP addresses you will need to add the new addresses to your firewall rules.\n\n### Features affected\n\nIf you are using a custom database connection, rule, and/or custom email provider that connects to your environment, and you have implemented firewall restrictions for IP address ranges, then you are affected by this change. You will need to add the following IP addresses to your firewall rules:\n\n`138.91.154.99, 54.183.64.135, 54.67.77.38, 54.67.15.170,54.183.204.205, 54.173.21.107, 54.85.173.28, 35.167.74.121, 35.160.3.103,35.166.202.113, 52.14.40.253,52.14.38.78, 52.14.17.114, 52.71.209.77, 34.195.142.251, 52.200.94.42`\n\n## Vulnerable password flow\n\nPrior to 01 February 2017, Auth0's password reset flow allowed a user to enter their email and a new password. This triggered a confirmation email that to be sent to the user asking them to confirm that they requested a password reset.\n\n### Features affected\n\nThe issue is that the confirmation link could be inadvertently clicked by a user which would result in the user's password being changed by an attacker.\n\nLock version 9 and above uses the new password reset flow exclusively. Lock 8 and below does not handle the new password reset flow. We strongly recommend upgrading to Lock 9 or greater as soon as possible.\n\n## State parameter required on redirect from rule\n\nAs of 06 December 2016, when a redirect is done from an Auth0 rule, Auth0 generates and sends a state parameter in HTTP and check for a valid state parameter when flow returns to the `/continue` endpoint. The site to which the redirect goes has to capture the value of the state parameter and return it by adding it as a parameter when returning to the `/continue` endpoint.\n\n### Features affected\n\nYou are affected by the change only if you redirect from rules, and do not yet capture and return (to the /continue end point) the state parameter.\n\n## Delete all users endpoint change\n\nPrior to 13 September 2016, the previous endpoint for deleting all users was `DELETE /api/v2/users`. This is similar to the endpoint to delete one user: DELETE `/api/v2/users`. To prevent accidental requests to the delete all users endpoint, the url has been changed to `DELETE /api/v2/allusers`. This should ensure that only intentional calls to this endpoint get made.\n\n### Features affected\n\nYou are affected by the change only if you currently make use of the delete all users endpoint. If so, the only change you need to make is to change the URL as explained above.\n\n## Email delivery template customization changes\n\nAs of 29 August 2016, Auth0's built-in email provider is longer be supported for use in a production environment. The emails sent using the Auth0 provider will no longer be customizable. They will be restricted to the template and you will not be able to change the from address or subject line.\n\nThe built-in email service may still be used for test purposes but you must switch to an Auth0-supported third-party service ([Amazon SES](https://aws.amazon.com/ses/), [Mandrill](https://www.mandrill.com/signup/), [SendGrid](https://sendgrid.com/pricing)) or another SMTP-based provider before moving your apps to production. If you already use a custom email provider, no action is necessary.\n\n## Identity provider access tokens removed from user profile and ID token\n\nAs of 08 August 2016, the format of the user profile JSON object (ID token) that is returned by Auth0 Authentication APIs changed to remove the identity provider access token and included in the user profile `identities` array.\n\nTo obtain a user's identity provider access token, you will need to make an HTTP GET call to the `/api/v2/users/{user-id}` endpoint containing an API token generated with `read:user_idp_tokens` scope. You will still have access to the identity provider access token in the `user` argument in Auth0 rules.\n\n### Features affected\n\nYou are affected by the change only if you are using the Identity Provider Access Token (`identities[0].access_token` in the user profile) outside of rules to call other services from the Identity Provider (such as Facebook Graph API, Google APIs, etc.). If your tenant was created after the change the update will be done automatically.\n\n## Tokeninfo endpoint validation\n\nAs of 01 June 2016, when calling the Tokeninfo endpoint, the URL of the API call (for example `https://{yourDomain}/`) must match the value of the `iss` attribute of the ID Token being validated. If these values do not match, the response will be `HTTP 400 - Bad Request`.\n\n### Features affected\n\nIf you are calling the Tokeninfo endpoint directly, make sure that the value of the `iss` attribute of the ID Token being validated matches your Auth0 tenant namespace: `https://{yourDomain}/`. You can use [jwt.io](https://jwt.io/) to decode the token to confirm the `iss` attribute value.\n\n## Email delivery from address changes\n\nOn 27 April 2016, Auth0's built-in email provider started sending all emails from a predefined from address (`no-reply@auth0user.net`). Custom Email Providers are now free. To customize the \"from\" address, you can switch to an Auth0-supported third-party service ([Amazon SES](https://aws.amazon.com/ses/), [Mandrill](https://www.mandrill.com/signup/), [SendGrid](https://sendgrid.com/pricing)) or another SMTP-based provider. If you already use a custom email provider, nothing will change.\n\n## Patch and Post endpoints no longer accept secret\\_encoded flag\n\nThe `jwt_configuration.secret_encoded` configuration is no longer accepted by the PATCH and POST applications endpoints.\n\nIn order to further comply with the OIDC specification, Auth0 will no longer generate or accept base64 encoded application secrets for new applications.\n\nExisting applications with encoded secrets stored will remain intact and unchanged, but new applications will no longer use base64 encoding. The `secret_encoded` flag is no longer accepted or necessary, as a result.\n\n### Features affected\n\nYou are affected by this change only if you interact with these endpoints directly.",
  "title": "Past Migrations",
  "description": "List of Auth0 updates that have already been enabled for all customers.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/mfa/guides/mfa-api/manage",
  "markdown": "# Manage Authentication Factors with Authentication API\n\nAuth0 provides several [API endpoints](https://auth0.com/docs/api/authentication#multi-factor-authentication) to help you manage the authenticators you're using with an application for multi-factor authentication (MFA). You can use these endpoints to build a complete user interface for letting users manage their authenticator factors.\n\n## Get MFA API access tokens\n\nTo call the MFA API to manage enrollments, you first need to obtain an access token for the MFA API.\n\nTo use the MFA API as part of an authentication flow, you can follow the steps detailed in [Authenticate With Resource Owner Password Grant and MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa). If you are building a user interface to manage authentication factors, you'll need to obtain a token you can use for the MFA API at any moment, not only during authentication.\n\n### Universal Login\n\nIf you are using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login), redirect to the Authorize endpoint, specifying the `https://{yourDomain}/mfa/` audience, before using calling the MFA API.\n\n### Resource owner password grant\n\nIf you are using the Resource Owner Password Grant (ROPG), you have 3 options:\n\n*   Ask for the `https://{yourDomain}/mfa/` audience when logging-in, and use a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens) to refresh it later.\n    \n*   If you need to list and delete authenticators, ask the user to [authenticate again](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa) with `/oauth/token`, specifying the `https://{yourDomain}/mfa/` audience. Users will need to complete MFA before being able to list and/or delete authentication factors.\n    \n*   If you only need to list authenticators, ask the user to [authenticate again](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa) using `/oauth/token` with username/password. The endpoint will return an `mfa_required` error, and an `mfa_token` you can use to list authenticators. Users will need to provide their password to see their authenticators.\n    \n\n### Scopes\n\nWhen you request a token for the MFA audience, you can request the following scopes:\n\n| Scope | Description |\n| --- | --- |\n| `enroll` | To enroll a new authenticator. |\n| `read:authenticators` | To list existing authenticators. |\n| `remove:authenticators` | To delete an authenticator. |\n\n## List authenticators\n\nTo get a list of the authenticators for a user, you can call the MFA Authenticators endpoint:\n\n*   [cURL](#372b2f0fcacb45409052d6d1f05bdbfe_shell)\n*   [C#](#372b2f0fcacb45409052d6d1f05bdbfe_csharp)\n*   [Go](#372b2f0fcacb45409052d6d1f05bdbfe_go)\n*   [Java](#372b2f0fcacb45409052d6d1f05bdbfe_java)\n*   [Node.JS](#372b2f0fcacb45409052d6d1f05bdbfe_node)\n*   [Obj-C](#372b2f0fcacb45409052d6d1f05bdbfe_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer MFA_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/mfa/authenticators\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {authorization: 'Bearer MFA_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MFA_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/mfa/authenticators\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MFA_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou should receive information about the authenticator type(s) in the response:\n\n```\n[\n  {\n    \"authenticator_type\": \"recovery-code\",\n    \"id\": \"recovery-code|dev_IsBj5j3H12VAdOIj\",\n    \"active\": true\n  },\n  {\n    \"authenticator_type\": \"otp\",\n    \"id\": \"totp|dev_nELLU4PFUiTW6iWs\",\n    \"active\": true,\n  },\n  {\n    \"authenticator_type\": \"oob\",\n    \"oob_channel\": \"sms\",\n    \"id\": \"sms|dev_sEe99pcpN0xp0yOO\",\n    \"name\": \"+1123XXXXX\",\n    \"active\": true\n  }\n]\n```\n\nFor the purposes of building a user interface for end users to manage their factors, you should ignore authenticators that have `active` as `false`. Those authenticators are not confirmed by users, so they can't be used to challenge for MFA.\n\nThe MFA API will list the following enrollments depending on the authenticator type:\n\n| Authenticator | Actions |\n| --- | --- |\n| **Push and OTP** | If push is enabled, Auth0 also creates an OTP enrollment. You will see both when listing enrollments. |\n| **SMS and Voice** | If both SMS and voice are enabled, when a user enrolls with either SMS or voice, Auth0 automatically creates two authenticators for the phone number, one for SMS and another for voice. |\n| **Email** | All verified emails will be listed as authenticators. |\n\n## Enroll authenticators\n\nSee the following links for details on how to enroll authenticators for different factors:\n\n*   [SMS or voice](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n    \n*   [One-time password (OTP)](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n    \n*   [Push](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)\n    \n*   [Email](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n    \n\nYou can also use the [Universal Login flow](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets) for enrolling users at any time.\n\n## Delete authenticators\n\nTo delete an associated authenticator, send a `DELETE` request to the MFA Authenticators endpoint replacing the `AUTHENTICATOR_ID` with the relevant authenticator ID. You can get the ID when you list authenticators.\n\nIf an `mfa_token` was used to list authenticators, users will need to [complete MFA to obtain an access token](https://auth0.com/docs/api/authentication#verify-with-one-time-password-otp-) with an audience of `https://{yourDomain}/mfa/` in order to delete an authenticator.\n\n*   [cURL](#1a7e49cf80394260b5ab2e77dacf0b9d_shell)\n*   [C#](#1a7e49cf80394260b5ab2e77dacf0b9d_csharp)\n*   [Go](#1a7e49cf80394260b5ab2e77dacf0b9d_go)\n*   [Java](#1a7e49cf80394260b5ab2e77dacf0b9d_java)\n*   [Node.JS](#1a7e49cf80394260b5ab2e77dacf0b9d_node)\n*   [Obj-C](#1a7e49cf80394260b5ab2e77dacf0b9d_objc)\n*   [...](#)\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID' \\\n  --header 'authorization: Bearer ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\")\n  .header(\"authorization\", \"Bearer ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID',\n  headers: {authorization: 'Bearer ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer ACCESS_TOKEN\" }\n\nconn.request(\"DELETE\", \"/{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators/AUTHENTICATOR_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the authenticator was deleted, a 204 response is returned.\n\nWhen you delete an authenticator, the following actions take place depending on the authenticator type:\n\n| Authenticator | Action |\n| --- | --- |\n| **Push and OTP** | When a user enrolls a push authenticator, Auth0 also enrolls OTP. If you delete either of them, the other one will also be deleted. |\n| **SMS and Voice** | When a user enrolls in either SMS or Voice,. Auth0 creates two authenticators, SMS and voice. If you delete either of them, the other will will also be deleted. |\n| **Email** | All verified emails listed as authenticators, but you can't delete them. You can only delete email authenticators that are enrolled explicitly. |\n\n## Regenerate recovery codes\n\nTo delete a recovery code and generate a new one, get an Auth0 [Management API access token](https://auth0.com/docs/api/management/v2/tokens) and use the Management API [Recovery Code Regeneration endpoint](https://auth0.com/docs/api/management/v2/#!/Users/post_recovery_code_regeneration).\n\n*   [cURL](#9bfe8a485a2a467ba5165623251ad014_shell)\n*   [C#](#9bfe8a485a2a467ba5165623251ad014_csharp)\n*   [Go](#9bfe8a485a2a467ba5165623251ad014_go)\n*   [Java](#9bfe8a485a2a467ba5165623251ad014_java)\n*   [Node.JS](#9bfe8a485a2a467ba5165623251ad014_node)\n*   [Obj-C](#9bfe8a485a2a467ba5165623251ad014_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration' \\\n  --header 'authorization: Bearer MANAGEMENT_API_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MANAGEMENT_API_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\"\n\n\treq, _ := http.NewRequest(\"POST\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MANAGEMENT_API_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\")\n  .header(\"authorization\", \"Bearer MANAGEMENT_API_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration',\n  headers: {authorization: 'Bearer MANAGEMENT_API_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MANAGEMENT_API_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MANAGEMENT_API_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MANAGEMENT_API_TOKEN\" }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MANAGEMENT_API_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MANAGEMENT_API_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID/recovery-code-regeneration\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou will get a new recovery code that the end user will need to capture, for example:\n\n```\n{  \n   \"recovery_code\": \"FA45S1Z87MYARX9RG6EVMAPE\"\n}\n```\n\n## Learn more\n\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n*   [Enroll and Challenge OTP Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n*   [Enroll and Challenge Push Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)\n*   [Enroll and Challenge Email Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n*   [Challenge with Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes)",
  "title": "Manage Authentication Factors with Authentication API",
  "description": "Describes how to manage MFA authenticator factor enrollments for applications using the Auth0 MFA API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connector",
  "markdown": "# AD/LDAP Connector\n\nAuth0 integrates with Active Directory (AD) using Lightweight Directory Access Protocol (LDAP) through an Active Directory/LDAP Connector that you install on your network.\n\nThe AD/LDAP Connector (1), is a bridge between your Active Directory/LDAP (2) and the Auth0 Service (3). This bridge is necessary because AD/LDAP is typically restricted to your internal network, and Auth0 is a cloud service running in a completely different context.\n\n![AD/LDAP Connector - integrate AD/LDAP with Auth0 - diagram](https://images.ctfassets.net/cdy7uua7fh8z/1xMpdHrtor0TR7F1gZ96zL/130e13f59b728fe14e00f1815b90103f/ldap-connect.png)\n\nWhen a user authenticates with Auth0, they are redirected to the AD/LDAP Connector which validates the user against your AD service and then sends the results of the validation back to Auth0. The AD/LDAP Connector supports authentication based LDAP, [](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos)Kerberos, and [](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-client-certificates)client certificates.\n\nTo learn more, see [Configure AD/LDAP Connector Authentication with Kerberos](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos) and [Configure AD/LDAP Connector Authenticator with Client Certificates](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-client-certificates).\n\n## Caches\n\nThe AD/LDAP Connector caches user profiles and credentials (Auth0 stores a hash of the user's password) to ensure optimal uptime and performance, and updates the data each time a user logs in. The cache is only used when the connector is down or unreachable. The cached data is always stored unless you disable caching credentials in the Dashboard. Values in the cache are case-sensitive, which means that login attempts will only succeed if users provide the exact username that was cached.\n\n## High-availability and load balancing\n\nFor high-availability and load balancing, you can install multiple instances of the connector. All connections are outbound from the connector to the Auth0 Server, so changes to your firewall are generally unnecessary.\n\nEach instance of the high-availability cluster will be always up and running and connected to Auth0. Auth0 will send login transactions and other requests to any of the available connectors. If one of the instances fails because of a network or a hardware issue, Auth0 will redirect the login transactions to the other connector. Having a highly available deployment also allows you to update the connector with zero downtime.\n\n## OpenLDAP directories\n\nThe Connector comes by default highly optimized for Active Directory. To configure it any other LDAP directories (such as OpenLDAP) you will have to customize these settings in the `config.json` file:\n\n```\n\"LDAP_USER_BY_NAME\": \"(cn={0})\",\n      \"LDAP_SEARCH_QUERY\": \"(&(objectClass=person)(cn={0}))\",\n      \"LDAP_SEARCH_ALL_QUERY\": \"(objectClass=person)\",\n```\n\nIn some cases, instead of `cn` it might be better to use `uid`.\n\n### OpenDJ example\n\nWith the **OpenDJ Control Panel** you can retrieve the list of attributes for each user. This list can help you decide which attribute will be used as the username when authenticating with Auth0.\n\n![AD/LDAP Connector OpenDJ Example diagram](https://images.ctfassets.net/cdy7uua7fh8z/14fTMlPqtzUicW2VTZPLPG/3ffa90a44eb864455ad3b77406f8ad32/opendj-attributes.png)\n\nIn this example John's `cn` is **johndoe** and the `mail` field is set to **johndoe@contoso.com**. If your organization wants users to authenticate using their username (`cn`) you can set the `LDAP_USER_BY_NAME` setting to `(cn={0})`, but if users should authenticate using their email address you should set it to `(mail={0})`.\n\n## Learn more\n\n*   [AD/LDAP Connector System Requirements](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-requirements)\n*   [Install and Configure AD/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/install-configure-ad-ldap-connector)\n*   [Configure AD/LDAP Connector Authentication with Client Certificates](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-client-certificates)\n*   [Configure AD/LDAP Connector Authentication with Kerberos](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos)\n*   [Import and Export AD/LDAP Connector Configurations](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/import-export-ad-ldap-connector-configs)\n*   [Troubleshoot AD/LDAP Connector](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-ad-ldap-connector)",
  "title": "AD/LDAP Connector",
  "description": "Describes the Active Directory LDAP Connector and how it works.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/enterprise/azure-active-directory",
  "markdown": "# Connect Your App to Microsoft Azure Active Directory\n\nYou can integrate with Microsoft Azure Active Directory (AD) if you want to let users:\n\n*   From within your company use your application from an Azure AD controlled by you or your organization.\n    \n*   From other companies' Azure ADs use your application. (We recommend that you configure external directories as different connections.)\n    \n\n## Steps\n\nTo connect your application to Azure AD, you must:\n\n1.  [Register your app with Azure AD](#register-your-app-with-azure-ad)\n    \n2.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0)\n    \n3.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application)\n    \n4.  [Test the connection](#test-the-connection)\n    \n\n### Register your app with Azure AD\n\nTo register your app with Azure AD, see Microsoft's [Quickstart: Register an application with the Microsoft identity platform](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app).\n\nDuring registration, configure the following settings:\n\n| Option | Setting |\n| --- | --- |\n| **Supported account types** | To allow users from external organizations (like other Azure AD directories) choose the appropriate multitenant option. Multitenant options include the following: **Accounts in any organizational directory (Any Azure AD directory - Multitenant)**. |\n| **Redirect URI** | Select a Redirect URI type of **Web**, and enter your callback URL: `https://{yourDomain}/login/callback`. |\n\n#### Find your Auth0 domain name for redirects\n\nIf your Auth0 domain name is not shown above and you are not using our [custom domains](https://auth0.com/docs/customize/custom-domains) feature, your domain name is a concatenation of your tenant name, your regional subdomain, and `auth0.com`, separated by the dot (`.`) symbol.\n\nFor example, if your tenant name is `exampleco-enterprises`, and your tenant is in the US region, your Auth0 domain name would be `exampleco-enterprises.us.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.us.auth0.com/login/callback`.\n\nHowever, if your tenant is in the US region and was created before June 2020, then your Auth0 domain name would be `exampleco-enterprises.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.auth0.com/login/callback`.\n\nIf you are using [custom domains](https://auth0.com/docs/customize/custom-domains), your **Redirect URI** would be `https://<YOUR CUSTOM DOMAIN>/login/callback`.\n\nDuring this process, Microsoft generates an **Application (client) ID** for your application; you can find this on the app's **Overview** screen. **Make note of this value.**\n\n#### Create a client secret\n\nTo create a client secret, see Microsoft's [Quickstart: Configure a client application to access web APIs - Add Credentials to your web application](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app#add-credentials).\n\nOnce generated, **make note of this value**.\n\n#### Add permissions\n\nTo add permissions, see Microsoft's [Quickstart: Configure a client application to access web APIs - Add permissions to access web APIs](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-permissions-to-access-web-apis).\n\nWhile configuring permissions, consider the following:\n\nIf you want to enable extended attributes (such as E**xtended Profile** or **Security Groups**), then you will need to configure the following permissions for the **Microsoft Graph API**.\n\n| Delegated Permissions | Description |\n| --- | --- |\n| **Users > User.Read** | So your app can sign in users and read the signed-in users' profiles. |\n| **Directory > Directory.Read.All** | So your app can read directory data on the signed-in user's behalf. |\n\n### Create an enterprise connection in Auth0\n\nCreate and configure an Azure AD Enterprise Connection in Auth0. Make sure you have the **Application (client) ID** and the **Client secret** generated when you set up your app in the Microsoft Azure portal.\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **Microsoft Azure AD**, and select its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create**:\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant. Once set, this name can't be changed. |\n    | **Microsoft Azure AD Domain** | Your Azure AD domain name. You can find this on your Azure AD directory's overview page in the Microsoft Azure portal. |\n    | **Client ID** | Unique identifier for your registered Azure AD application. Enter the saved value of the **Application (client) ID** for the app you just registered in Azure AD. |\n    | **Client Secret** | String used to gain access to your registered Azure AD application. Enter the saved value of the **Client secret** for the app you just registered in Azure AD. |\n    | **Use common endpoint** | (Optional) When enabled, your application will dynamically accept users from new directories. Typically enabled if you selected a multi-tenant option for **Supported account types** for the application you just registered in Azure AD. When enabled, Auth0 will redirect users to Azure's common login endpoint, and Azure will perform _Home Realm Discovery_ based on the domain of the user's email address. |\n    | **Identity API** | API used by Auth0 to interact with Azure AD endpoints. Learn about the differences in behavior in Microsoft's [Why update to Microsoft identity platform (v2.0)](https://docs.microsoft.com/en-us/azure/active-directory/develop/azure-ad-endpoint-comparison) doc. |\n    | **Attributes** | Basic attributes for the signed-in user that your app can access. Indicates how much information you want stored in the Auth0 User Profile. |\n    | **Extended Attributes** (optional) | Extended attributes for the signed-in user that your app can access. |\n    | **Auth0 APIs** (optional) | When selected, indicates that we require the ability to make calls to the Azure AD API, which allows us to search for users in the Azure AD Graph even if they never logged in to Auth0. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    | **Email Verification** | Choose how Auth0 sets the `email_verified` field in the user profile. To learn more, see [Email Verification for Azure AD and ADFS](https://auth0.com/docs/connections/azuread-adfs-email-verification). |\n    \n    ![Create new Azure AD connection](https://images.ctfassets.net/cdy7uua7fh8z/1r6WTgLJUlbiV9jligIwER/4fd549986503d804ffbcc785b4ef70df/Azure_AD_Connection.png)\n3.  In the **Login Experience** view, you can configure how users log in with this connection.\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Identity Provider domains** | A comma-separated list of the domains that can be authenticated in the Identify Provider. This is only applicable when using [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication with Universal Login. |\n    | **Add button** (Optional) | Display a button for this connection in the login page. |\n    | **Button display name** (Optional) | Text used to customize the login button for Universal Login. When set the button reads: \"Continue with {Button display name}\". |\n    | **Button logo URL** (Optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    \n4.  If you have appropriate Azure AD administrative permissions to give consent to the application so users can log in, then click **Continue**. You will be asked to [log in to your Azure AD account](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent#requesting-consent-for-an-entire-tenant) and give consent. Otherwise, provide the given URL to your administrator so that they can give consent.\n    \n\n### Enable the enterprise connection for your Auth0 application\n\nTo use your new Azure AD enterprise connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n### Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).\n\n## Troubleshooting\n\nHere are some troubleshooting tips:\n\n**I registered my application with Azure AD, but when I go back to my Azure Active Directory App registrations, I can't see my application.**\n\nYou may have accidentally registered your app in the wrong Azure AD directory (or not have created an Azure AD directory at all before registering your app). It's likely easiest to re-register your app in Azure AD. Make sure you are in the correct directory when you register the app. If you need to create an Azure AD directory, follow Microsoft's [Quickstart: Create a new tenant in Azure Active Directory - Create a new tenant for your organization](https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-access-create-new-tenant#create-a-new-tenant-for-your-organization).\n\n**I receive the following error message: \"Access cannot be granted to this service because the service listing is not properly configured by the publisher\".**\n\nTo resolve this, try changing the **Supported account types** for your registered Azure AD app. Make sure you have chosen an appropriate multitenant option in the Azure AD app's Authentication settings. Multitenant options include the following: **Accounts in any organizational directory (Any Azure AD directory - Multitenant)**.\n\n**When users try to log in, we receive the following error message: \"invalid\\_request; failed to obtain access token\".**\n\nThe most likely reason for this error is an invalid or expired Azure AD **Client secret**. To resolve this, generate a new **Client secret** for your app in Azure AD, then update the **Client Secret** in the enterprise connection configured with Auth0.\n\n## Signing Key Rollover in Azure AD\n\nSigning keys are used by the identity provider to sign the authentication token it issues, and by the consumer application (Auth0 in this case) to validate the authenticity of the generated token.\n\nFor security purposes, Azure AD’s signing key [rolls on a periodic basis](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-signing-key-rollover). If this happens, **you do not need to take any action**. Auth0 will use the new key automatically.\n\n## Remove unverified label\n\nIf you're using a custom domain, the application consent prompt for Azure AD login may label your domain as \"unverified\". To remove the unverified label:\n\n1.  Verify the domain for the Auth0 application: [Add your custom domain name using the Azure Active Directory portal](https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/add-custom-domain#add-your-custom-domain-name-to-azure-ad).\n    \n2.  Assign the verified domain to the Auth0 application: [How to: Configure an application's publisher domain](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-configure-publisher-domain#configure-publisher-domain-using-the-azure-portal).\n    \n\n## Next Steps\n\n*   [Integrate with Auth0 using one of our libraries](https://auth0.com/docs/libraries)\n    \n*   [Integrate with Auth0 using our Authentication API](https://auth0.com/docs/api/authentication)\n    \n*   [Read more about the authentication flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow)\n    \n*   [Pass additional parameters to the Identity Provider](https://auth0.com/docs/authenticate/identity-providers/pass-parameters-to-idps)\n    \n*   [Re-prompt users for permissions](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/reprompt-permissions)",
  "title": "Connect Your App to Microsoft Azure Active Directory",
  "description": "Learn how to connect your app to Microsoft Azure Active Directory using an enterprise connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications",
  "markdown": "# Log Users Out of Applications\n\nEnterprise users typically have Single Sign-on (SSO) enabled for multiple applications (e.g., SharePoint, a few .NET applications, a few Java applications, Zendesk). In this case, when users sign out, often they must be signed out for all of their applications.\n\nThe Auth0 [RP-initiated logout endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0) works in one of two ways:\n\n*   Invalidates the Single Sign-on (SSO) cookie in Auth0. (The cookie still remains in the browser.)\n    \n*   Signs the user out from the identity provider (IdP) (such as ADFS or Google).\n    \n\nRedirecting users to the logout endpoint does not cover the scenario where users need to be signed out of all of the applications they used. If you need to provide this functionality you will have to handle this in one of two ways:\n\n*   Have short timeouts on your local session and redirect to Auth0 at short intervals to re-authenticate. This can be done by calling `checkSession` from the client which does this redirect in a hidden iFrame. If you take the hidden iFrame approach you need to be aware of [rate limits](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy) and third-party [cookie](https://auth0.com/docs/manage-users/cookies) issues.\n    \n*   Handle this entirely at the application level by providing your applications a way to notify all other applications when a logout occurs.\n    \n\nIf you are using the alternative logout endpoint, review the [API documentation](https://auth0.com/docs/api/authentication#logout).\n\n## Learn more\n\n*   [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0)\n*   [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n*   [Redirect Users with Alternative Logout](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout)",
  "title": "Log Users Out of Applications",
  "description": "Describes how to force a user to log out of applications using the Auth0 logout endpoint.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps",
  "markdown": "# Log Users Out of SAML Identity Providers\n\nSingle Logout (SLO) is a feature that allows a user to terminate multiple authentication sessions by performing a single logout action.\n\nAuth0 supports SLO when you [connect your application to a SAML Identity Provider (IdP)](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/saml) and supports limited SLO when you [configure Auth0 as a SAML IdP](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider).\n\n## Configure SLO when application is connected to a SAML IdP\n\nIf you’d like Auth0 to [log a user out of their identity provider](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps), include the `federated` parameter when you call the [Auth0 Authentication API Logout endpoint](https://auth0.com/docs/api/authentication#logout).\n\nYou may need to configure additional settings for the SAML connection to ensure that Auth0 sends the logout request to the SAML IdP's logout endpoint:\n\n1.  Go to [Auth0 Dashboard > Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp) and select your connection.\n    \n2.  Toggle on **Enable Sign Out**.\n    \n3.  Enter the SAML Logout URL provided by the SAML IdP in the **Sign Out URL** field. If you leave this field blank, Auth0 will default to the URL in the **Sign In URL** field.\n    \n4.  Confirm that the value in the **Protocol Binding** field matches the protocol binding expected by the SAML IdP.\n    \n\n## Configure SLO when Auth0 is the SAML IdP\n\nWhen Auth0 is the SAML IdP, there are two logout scenarios to consider:\n\n*   Application-initiated\n    \n*   IdP-initiated\n    \n\nFor both scenarios, you must [configure the SAML2 Web App addon](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon) to know where to send logout responses:\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select your application.\n    \n2.  Navigate to the **Addons** tab and select **SAML2 Web App**.\n    \n3.  Go to the **Settings** tab.\n    \n4.  Locate the **Settings** box and add (or update) the `logout` object with the following properties:\n    \n    *   `callback`: Enter the SLO URL of the application.\n        \n    *   `slo_enabled`: Enter `true` if you would like to enable IdP-initiated SLO in which Auth0 sends a SAML logout request to the application when the user logs out of the Auth0 SAML IdP. Otherwise, enter `false`.\n        \n        ```\n        {\n          \"logout\": {\n            \"callback\": \"https://myapp.exampleco.com/saml/logout\",\n            \"slo_enabled\": true\n          }\n        }\n        ```\n        \n\nBy default, Auth0 sends SAML logout responses with the `HTTP-POST` protocol binding. If your application expects the `HTTP-Redirect` protocol binding, add (or update) the `binding` property like so:\n\n```\n{\n  \"binding\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\"\n}\n```\n\n### Application-initiated logout\n\nWhen the user initiates logout from an application, it must send a request to the Authentication API [SAML Logout endpoint](https://auth0.com/docs/api/authentication#saml-logout) to trigger SLO.\n\nIf your application does not support SLO but does support a redirect URL to send the user to after logout, set the redirect URL to the Authentication API [OIDC Logout endpoint](https://auth0.com/docs/api/authentication#oidc-logout) (or the Authentication API [Auth0 Logout endpoint](https://auth0.com/docs/api/authentication#auth0-logout) if you're using legacy logout). Auth0 won't notify other session participants that a logout was initiated, but we will remove the user’s [Auth0 session](https://auth0.com/docs/manage-users/sessions/session-layers).\n\n### IdP-initiated logout\n\nWhen a user initiates logout from an Auth0 SAML IdP, Auth0 sends a SAML logout response to the URL in the `logout.callback` property within the SAML2 Web App addon’s Settings. You can only specify a single URL for this property.\n\nDue to this constraint, Auth0 does not natively support the scenario where a user needs to be signed out of multiple applications connected to your Auth0 SAML IdP.\n\nYou can achieve functionality similar to SLO by configuring your applications to regularly check the status of the user’s Auth0 session and terminate the application session accordingly. To learn more, read about [Session Lifetime Limits](https://auth0.com/docs/manage-users/sessions/session-lifetime-limits).\n\n## Learn more\n\n*   [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications)\n*   [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0)\n*   [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps)\n*   [Redirect Users with Alternative Logout](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)\n*   [Troubleshoot SAML Errors](https://auth0.com/docs/troubleshoot/authentication-issues/saml-errors)",
  "title": "Log Users Out of SAML Identity Providers",
  "description": "Describes how to log users out of an external SAML identity provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon",
  "markdown": "# Enable SAML2 Web App Addon\n\nYou can configure a SAML2 Web Application add-on for use with an application.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Identify the application with which you want to use a SAML2 Web Application, and click the Application's name to go to its configuration settings.\n    \n3.  Go to the **Addons** tab.\n    \n4.  In the **SAML2 Web App** box, click the slider to enable the Addon.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n5.  Go to the **Settings** tab and provide your **Application Callback URL** that receives the SAML response, as well as the **Settings**. On the **Settings** tab, there is a sample object that you can use when determining which settings you want to enable.\n    \n6.  Click **Debug** to test if your provided parameters are valid.\n    \n7.  Click **Save** when done.\n    \n\n## Provide application details\n\nWhile the specific steps for providing your application details to your SAML2 Web App will vary, you can get the configuration information you need from the **Usage** tab after you set up the addon.\n\n![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n\n## Integrations\n\nYou can choose from the following integrations:\n\n*   [Amazon Web Services](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws)\n    \n*   [GitHub Enterprise Cloud](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-cloud)\n    \n*   [GitHub Enterprise Server](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server)\n    \n*   [Heroku](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-heroku)\n    \n*   [Oracle Eloqua Marketing Cloud](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-addon-eloqua)\n    \n\n## Limitation\n\nThe SAML2 Web App addon does not support passive SAML requests (e.g. where `isPassive=true`).\n\n## Learn more\n\n*   [Configure Amazon Web Services as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws)\n*   [Configure GitHub Enterprise Cloud as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-cloud)\n*   [Configure GitHub Enterprise Server as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server)\n*   [Configure Heroku as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-heroku)\n*   [Configure Oracle Eloqua Marketing Cloud as SAML Service Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-addon-eloqua)\n*   [CVE-2017-16897: Security Update for passport-wsfed-saml2 Passport Strategy Library](https://auth0.com/docs/secure/security-guidance/security-bulletins/cve-2017-16897)",
  "title": "Enable SAML2 Web App Addon",
  "description": "Learn how to enable the SAML2 web app add-on for use with Auth0 as a SAML single sign-on (SSO) identity provider. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/connections/social/oauth2",
  "markdown": "# Connect Apps to Generic OAuth2 Authorization Servers\n\nThe most common [identity providers (IdP)](https://auth0.com/docs/authenticate/identity-providers) are available in [Auth0 Dashboard](https://manage.auth0.com/#) and in the [Auth0 Marketplace](https://marketplace.auth0.com/features/social-connections). You can, however, add any OAuth 2.0 provider as a **Custom Social Connection** in the Auth0 Dashboard.\n\n1.  In the Dashboard, go to [Authentication > Social](https://manage.auth0.com/#/connections/social).\n    \n2.  Select **Create Connection**, go to the bottom of the list, and then select **Create Custom**.\n    \n\nThe form that appears contains several fields that you must use to configure the custom connection:\n\n*   **Connection Name**: Logical identifier for the Connection you are creating. This name cannot be changed, must start and end with an alphanumeric character, and can only contain alphanumeric characters and dashes.\n    \n*   **Authorization URL**: URL to which users are redirected to log in.\n    \n*   **Token URL**: URL used to exchange the received authorization code for access tokens and, if requested, ID tokens.\n    \n*   **Scope**: `scope` parameters to send with the authorization request. Separate multiple scopes with spaces.\n    \n*   **Separate scopes using a space**: Toggle that determines how scopes are delimited if the `connection_scope` parameter is included when [calling the IdP's API](https://auth0.com/docs/authenticate/identity-providers/calling-an-external-idp-api). By default, scopes are delimited by a comma. If the toggle is enabled, scopes are delimited by a space. To learn more, read [Add Scopes/Permissions to Call Identity Provider APIs](https://auth0.com/docs/authenticate/identity-providers/adding-scopes-for-an-external-idp).\n    \n*   **Client ID**: Client ID for Auth0 as an application used to request authorization and exchange the authorization code. To get a Client ID, you will need to register with the identity provider.\n    \n*   **Client Secret**: Client Secret for Auth0 as an application used to exchange the authorization code. To get a Client Secret, you will need to register with the identity provider.\n    \n*   **Fetch User Profile Script**: Node.js script used to call a userinfo URL with the provided access token. To learn more about this script, see [Fetch User Profile Script](#fetch-user-profile-script).\n    \n\nOnce you create the custom connection, you will see the **Applications** view. Here, you can enable and disable applications for which you would like the connection to appear.\n\n## Update authentication flow\n\nWhen you create a connection, the default OAuth 2.0 grant type assigned to the connection is Authorization Code Flow. If you have a public application unable to store a Client Secret, such single-page or native applications, you can use the Management API to update the connection to use [Authorization Code Flow + PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce). To learn more about authorization flows, read [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)\n\n1.  Make a `GET` request to the [`/get-connections-by-id`](https://auth0.com/docs/api/management/v2/connections/get-connections-by-id) endpoint. The response will be similar to:\n    \n    ```\n    {\n      \"id\": \"[connectionID]\",\n      \"options\": {\n        \"email\": true,\n        \"scope\": [\n          \"email\",\n          \"profile\"\n        ],\n        \"profile\": true\n      },\n      \"strategy\": \"google-oauth2\",\n      \"name\": \"google-oauth2\",\n      \"is_domain_connection\": false,\n      \"enabled_clients\": [\n        \"[yourAuth0Domain]\"\n      ],\n      \"realms\": [\n        \"google-oauth2\"\n      ]\n    }\n    ```\n    \n2.  Copy the entire `options` object.\n    \n3.  Make a [`PATCH`](https://auth0.com/docs/api/management/v2/connections/patch-connections-by-id) request with the `options` object and add `\"pkce_enabled\":` `true`.\n    \n\n## Fetch User Profile Script\n\nThe fetch user profile script is called after the user has logged in with the OAuth2 provider. Auth0 executes this script to call the OAuth2 provider API and get the user profile:\n\n```\nfunction fetchUserProfile(accessToken, context, callback) {\n  request.get(\n    {\n      url: 'https://auth.example.com/userinfo',\n      headers: {\n        'Authorization': 'Bearer ' + accessToken,\n      }\n    },\n    (err, resp, body) => {\n      if (err) {\n        return callback(err);\n      }\n      if (resp.statusCode !== 200) {\n        return callback(new Error(body));\n      }\n      let bodyParsed;\n      try {\n        bodyParsed = JSON.parse(body);\n      } catch (jsonError) {\n        return callback(new Error(body));\n      }\n      const profile = {\n        user_id: bodyParsed.account.uuid,\n        email: bodyParsed.account.email\n      };\n      callback(null, profile);\n    }\n  );\n}\n```\n\nThe `user_id` property in the returned profile is required, and the `email` property is optional but highly recommended. To learn more about what attributes can be returned, see [User Profile Root Attributes](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/update-root-attributes-for-users).\n\nYou can filter, add, or remove anything from the profile returned from the provider. However, it is recommended that you keep this script as simple as possible. More sophisticated manipulation of user information can be achieved through the use of [Rules](https://auth0.com/docs/customize/rules). One advantage of using Rules is that they apply to any connection.\n\n## Log in using the custom connection\n\nYou can use any of the Auth0 standard mechanisms to log a user in with your custom connection. A direct link would look like:\n\n```\nhttps://{yourDomain}/authorize\n  ?response_type=code\n  &client_id={yourClientId}\n  &redirect_uri={https://yourApp/callback}\n  &scope=openid%20profile%20email\n  &connection=NAME_OF_CONNECTION\n```\n\n## Modify the icon and display name\n\nTo add an icon to the identity provider's login button or change the text used on the login button, you can use the `icon_url` property of the `options` object and the `display_name` property, respectively, via the [Management API](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id).\n\n*   [cURL](#f321801e2890408f9efd68fb924d2d4a_shell)\n*   [C#](#f321801e2890408f9efd68fb924d2d4a_csharp)\n*   [Go](#f321801e2890408f9efd68fb924d2d4a_go)\n*   [Java](#f321801e2890408f9efd68fb924d2d4a_java)\n*   [Node.JS](#f321801e2890408f9efd68fb924d2d4a_node)\n*   [Obj-C](#f321801e2890408f9efd68fb924d2d4a_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/CONNECTION-ID' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"options\": { \"client_id\": \"...\", \"client_secret\": \"...\", \"icon_url\": \"https://cdn.example.com/assets/icon.png\", \"scripts\": { \"fetchUserProfile\": \"...\" }, \"authorizationURL\": \"https://public-auth.example.com/oauth2/authorize\", \"tokenURL\": \"https://auth.example.com/oauth2/token\", \"scope\": \"auth\" }, \"enabled_clients\": [ \"...\" ] }, \"display_name\": \"Connection Name\"'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"icon_url\\\": \\\"https://cdn.example.com/assets/icon.png\\\", \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }, \\\"display_name\\\": \\\"Connection Name\\\"\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"icon_url\\\": \\\"https://cdn.example.com/assets/icon.png\\\", \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }, \\\"display_name\\\": \\\"Connection Name\\\"\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"icon_url\\\": \\\"https://cdn.example.com/assets/icon.png\\\", \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }, \\\"display_name\\\": \\\"Connection Name\\\"\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/CONNECTION-ID',\n  headers: {'content-type': 'application/json'},\n  data: '{ \"options\": { \"client_id\": \"...\", \"client_secret\": \"...\", \"icon_url\": \"https://cdn.example.com/assets/icon.png\", \"scripts\": { \"fetchUserProfile\": \"...\" }, \"authorizationURL\": \"https://public-auth.example.com/oauth2/authorize\", \"tokenURL\": \"https://auth.example.com/oauth2/token\", \"scope\": \"auth\" }, \"enabled_clients\": [ \"...\" ] }, \"display_name\": \"Connection Name\"'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{ \"options\": { \"client_id\": \"...\", \"client_secret\": \"...\", \"icon_url\": \"https://cdn.example.com/assets/icon.png\", \"scripts\": { \"fetchUserProfile\": \"...\" }, \"authorizationURL\": \"https://public-auth.example.com/oauth2/authorize\", \"tokenURL\": \"https://auth.example.com/oauth2/token\", \"scope\": \"auth\" }, \"enabled_clients\": [ \"...\" ] }, \"display_name\": \"Connection Name\"\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"icon_url\\\": \\\"https://cdn.example.com/assets/icon.png\\\", \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }, \\\"display_name\\\": \\\"Connection Name\\\"\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"icon_url\\\": \\\"https://cdn.example.com/assets/icon.png\\\", \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }, \\\"display_name\\\": \\\"Connection Name\\\"\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/CONNECTION-ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"icon_url\\\": \\\"https://cdn.example.com/assets/icon.png\\\", \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }, \\\"display_name\\\": \\\"Connection Name\\\"\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\n\nlet postData = NSData(data: \"{ \"options\": { \"client_id\": \"...\", \"client_secret\": \"...\", \"icon_url\": \"https://cdn.example.com/assets/icon.png\", \"scripts\": { \"fetchUserProfile\": \"...\" }, \"authorizationURL\": \"https://public-auth.example.com/oauth2/authorize\", \"tokenURL\": \"https://auth.example.com/oauth2/token\", \"scope\": \"auth\" }, \"enabled_clients\": [ \"...\" ] }, \"display_name\": \"Connection Name\"\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n![Login screen showing a custom OAuth2 connection with a custom icon and name.](https://images.ctfassets.net/cdy7uua7fh8z/6A2EFnYtrkvMdaPkjUvvv9/98b3f4f0bedff9cde6032c07a013e290/custom-connection-icon.png)\n\n## Pass provider-specific parameters\n\nYou can pass provider-specific parameters to the Authorization endpoint of OAuth 2.0 providers. These can be either static or dynamic.\n\n### Pass static parameters\n\nTo pass static parameters (parameters that are sent with every authorization request), you can use the `authParams` element of the `options` when configuring an OAuth 2.0 connection via the [Management API](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id). The call below will set a static parameter of `custom_param` set to `custom.param.value` on all authorization requests:\n\n*   [cURL](#f6fa5b44bf304c3da2b574bc4e5a9d4b_shell)\n*   [C#](#f6fa5b44bf304c3da2b574bc4e5a9d4b_csharp)\n*   [Go](#f6fa5b44bf304c3da2b574bc4e5a9d4b_go)\n*   [Java](#f6fa5b44bf304c3da2b574bc4e5a9d4b_java)\n*   [Node.JS](#f6fa5b44bf304c3da2b574bc4e5a9d4b_node)\n*   [Obj-C](#f6fa5b44bf304c3da2b574bc4e5a9d4b_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/CONNECTION-ID' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"options\": { \"client_id\": \"...\", \"client_secret\": \"...\", \"authParams\": { \"custom_param\": \"custom.param.value\" }, \"scripts\": { \"fetchUserProfile\": \"...\" }, \"authorizationURL\": \"https://public-auth.example.com/oauth2/authorize\", \"tokenURL\": \"https://auth.example.com/oauth2/token\", \"scope\": \"auth\" }, \"enabled_clients\": [ \"...\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParams\\\": { \\\"custom_param\\\": \\\"custom.param.value\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParams\\\": { \\\"custom_param\\\": \\\"custom.param.value\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParams\\\": { \\\"custom_param\\\": \\\"custom.param.value\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/CONNECTION-ID',\n  headers: {'content-type': 'application/json'},\n  data: {\n    options: {\n      client_id: '...',\n      client_secret: '...',\n      authParams: {custom_param: 'custom.param.value'},\n      scripts: {fetchUserProfile: '...'},\n      authorizationURL: 'https://public-auth.example.com/oauth2/authorize',\n      tokenURL: 'https://auth.example.com/oauth2/token',\n      scope: 'auth'\n    },\n    enabled_clients: ['...']\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"options\": @{ @\"client_id\": @\"...\", @\"client_secret\": @\"...\", @\"authParams\": @{ @\"custom_param\": @\"custom.param.value\" }, @\"scripts\": @{ @\"fetchUserProfile\": @\"...\" }, @\"authorizationURL\": @\"https://public-auth.example.com/oauth2/authorize\", @\"tokenURL\": @\"https://auth.example.com/oauth2/token\", @\"scope\": @\"auth\" },\n                              @\"enabled_clients\": @[ @\"...\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParams\\\": { \\\"custom_param\\\": \\\"custom.param.value\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParams\\\": { \\\"custom_param\\\": \\\"custom.param.value\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/CONNECTION-ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParams\\\": { \\\"custom_param\\\": \\\"custom.param.value\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"options\": [\n    \"client_id\": \"...\",\n    \"client_secret\": \"...\",\n    \"authParams\": [\"custom_param\": \"custom.param.value\"],\n    \"scripts\": [\"fetchUserProfile\": \"...\"],\n    \"authorizationURL\": \"https://public-auth.example.com/oauth2/authorize\",\n    \"tokenURL\": \"https://auth.example.com/oauth2/token\",\n    \"scope\": \"auth\"\n  ],\n  \"enabled_clients\": [\"...\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Pass dynamic parameters\n\nIn certain circumstances, you may want to pass a dynamic value to an OAuth 2.0 Identity Provider. In this case, you can use the `authParamsMap` element of the `options` to specify a mapping between one of the existing additional parameters accepted by the [Auth0 `/authorize` endpoint](https://auth0.com/docs/api/authentication#social) to the parameter accepted by the Identity Provider.\n\nUsing the same example above, let's assume that you want to pass the `custom_param` parameter to the authorization endpoint, but you want to specify the actual value of the parameter when calling the Auth0 `/authorize` endpoint.\n\nIn this case, you can use one of the existing addition parameters accepted by the `/authorize` endpoint, such as `access_type`, and map that to the `custom_param` parameter:\n\n*   [cURL](#1aa1ad36fbeb40d3b3bb323d01e674fd_shell)\n*   [C#](#1aa1ad36fbeb40d3b3bb323d01e674fd_csharp)\n*   [Go](#1aa1ad36fbeb40d3b3bb323d01e674fd_go)\n*   [Java](#1aa1ad36fbeb40d3b3bb323d01e674fd_java)\n*   [Node.JS](#1aa1ad36fbeb40d3b3bb323d01e674fd_node)\n*   [Obj-C](#1aa1ad36fbeb40d3b3bb323d01e674fd_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/CONNECTION-ID' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"options\": { \"client_id\": \"...\", \"client_secret\": \"...\", \"authParamsMap\": { \"custom_param\": \"access_type\" }, \"scripts\": { \"fetchUserProfile\": \"...\" }, \"authorizationURL\": \"https://auth.example.com/oauth2/authorize\", \"tokenURL\": \"https://auth.example.com/oauth2/token\", \"scope\": \"auth\" }, \"enabled_clients\": [ \"...\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParamsMap\\\": { \\\"custom_param\\\": \\\"access_type\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParamsMap\\\": { \\\"custom_param\\\": \\\"access_type\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParamsMap\\\": { \\\"custom_param\\\": \\\"access_type\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/CONNECTION-ID',\n  headers: {'content-type': 'application/json'},\n  data: {\n    options: {\n      client_id: '...',\n      client_secret: '...',\n      authParamsMap: {custom_param: 'access_type'},\n      scripts: {fetchUserProfile: '...'},\n      authorizationURL: 'https://auth.example.com/oauth2/authorize',\n      tokenURL: 'https://auth.example.com/oauth2/token',\n      scope: 'auth'\n    },\n    enabled_clients: ['...']\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"options\": @{ @\"client_id\": @\"...\", @\"client_secret\": @\"...\", @\"authParamsMap\": @{ @\"custom_param\": @\"access_type\" }, @\"scripts\": @{ @\"fetchUserProfile\": @\"...\" }, @\"authorizationURL\": @\"https://auth.example.com/oauth2/authorize\", @\"tokenURL\": @\"https://auth.example.com/oauth2/token\", @\"scope\": @\"auth\" },\n                              @\"enabled_clients\": @[ @\"...\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParamsMap\\\": { \\\"custom_param\\\": \\\"access_type\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParamsMap\\\": { \\\"custom_param\\\": \\\"access_type\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/CONNECTION-ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParamsMap\\\": { \\\"custom_param\\\": \\\"access_type\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"options\": [\n    \"client_id\": \"...\",\n    \"client_secret\": \"...\",\n    \"authParamsMap\": [\"custom_param\": \"access_type\"],\n    \"scripts\": [\"fetchUserProfile\": \"...\"],\n    \"authorizationURL\": \"https://auth.example.com/oauth2/authorize\",\n    \"tokenURL\": \"https://auth.example.com/oauth2/token\",\n    \"scope\": \"auth\"\n  ],\n  \"enabled_clients\": [\"...\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nNow when calling the `/authorize` endpoint, you can pass the access type in the `access_type` parameter, and that value will in turn be passed along to the authorization endpoint in the `custom_param` parameter.\n\nIn some instances, you will need to pass extra headers to the Token endpoint of an OAuth 2.0 provider. To configure extra headers, open the Settings for the Connection, and in the **Custom Headers** field, specify a JSON object with the custom headers as key-value pairs:\n\n```\n{\n    \"Header1\" : \"Value\",\n    \"Header2\" : \"Value\"\n}\n```\n\nLet's use an example where an Identity Provider may require you to pass an `Authorization` header with [Basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication) credentials. In this scenario, you can specify the following JSON object in the **Custom Headers** field:\n\n```\n{\n  \"Authorization\": \"Basic [your credentials]\"\n}\n```\n\nWhere `[your credentials]` are the actual credentials to send to the Identity Provider.\n\n## Learn more\n\n*   [Social Identity Providers](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers)\n*   [Identity Providers](https://auth0.com/docs/authenticate/identity-providers)\n*   [Protocols](https://auth0.com/docs/authenticate/protocols)",
  "title": "Connect Apps to Generic OAuth2 Authorization Servers",
  "description": "Learn how to add any OAuth2 provider using Auth0 Custom Social Connections.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock/v11/configuration",
  "markdown": "# Lock Configuration Options\n\nLock can be configured through the `options` parameter sent to the constructor. These options can alter the way that the Lock widget behaves, how it deals with connections, additional signup fields that you require for your project, the language and text values, colors, and images on the widget, and many more. Take a look at the index below if you know what you are looking for, or browse the options for more details.\n\n## UI\n\n| Option | Description |\n| --- | --- |\n| [allowAutocomplete](#allowautocomplete-boolean-) | Enable or disable autocompletion on the email or username inputs |\n| [allowPasswordAutocomplete](#allowpasswordautocomplete-boolean-) | Enable or disable autocompletion on password input |\n| [allowShowPassword](#allowshowpassword-boolean-) | Specifies if the user can choose to show password while typing it |\n| [allowedConnections](#allowedconnections-array-) | List of connections that will be available to perform authentication |\n| [autoclose](#autoclose-boolean-) | Specifies if Lock closes after a login |\n| [autofocus](#autofocus-boolean-) | Specifies if focus is set on the first input field |\n| [avatar](#avatar-object-) | Specifies if an avatar and a username should be displayed on the Lock's header once an email or username has been entered and how to obtain it |\n| [closable](#closable-boolean-) | Determines whether or not Lock can be closed |\n| [container](#container-string-) | The HTML element where Lock will be rendered. This causes Lock to appear inline instead of in a modal window |\n| [flashMessage](#flashmessage-object-) | Shows an `error` or `success` flash message when Lock is shown |\n| [language](#language-string-) | Specifies the language of the widget |\n| [languageDictionary](#languagedictionary-object-) | Customize text used for widget elements (such as labels and placeholders) |\n| [popupOptions](#popupoptions-object-) | Customize the location of the popup in the screen |\n| [rememberLastLogin](#rememberlastlogin-boolean-) | Whether or not to show a screen that allows you to quickly log in with the account you used the last time |\n| [scrollGlobalMessagesIntoView](#scrollglobalmessagesintoview-boolean-) | Specify if a globalMessage should be scrolled into the user's viewport |\n\n## Theme\n\nTheme options are grouped in the `theme` property of the `options` object.\n\n| Option | Description |\n| --- | --- |\n| [authButtons](#authbuttons-object-) | Customize the appearance of specific connection buttons |\n| [labeledSubmitButton](#labeledsubmitbutton-boolean-) | whether or not the submit button has text |\n| [logo](#logo-string-) | What logo should be used |\n| [primaryColor](#primarycolor-string-) | Color of the primary button on the widget |\n\n## Authentication\n\nAuthentication options are grouped in the `auth` property of the `options` object.\n\n| Option | Description |\n| --- | --- |\n| [audience](#audience-string-) | The API which will be consuming your Access Token |\n| [autoParseHash](#autoparsehash-boolean-) | Whether or not to automatically parse hash and continue |\n| [connectionScopes](#connectionscopes-object-) | Specify connection scopes |\n| [params](#params-object-) | Option to send parameters at login |\n| [redirect](#redirect-boolean-) | Whether or not to use redirect mode |\n| [redirectUrl](#redirecturl-string-) | The URL to redirect to after auth |\n| [responseMode](#responsemode-string-) | Option to send response as POST |\n| [responseType](#responsetype-string-) | Response as a code or token |\n| [sso](#sso-boolean-) | Determines whether Single Sign-On is enabled or not in Lock |\n\n## Database\n\n| Option | Description |\n| --- | --- |\n| [additionalSignUpFields](#additionalsignupfields-array-) | Additional fields collected at signup |\n| [allowLogin](#allowlogin-boolean-) | Whether or not to allow login on widget |\n| [allowForgotPassword](#allowforgotpassword-boolean-) | Whether or not to allow forgot password on widget |\n| [allowSignUp](#allowsignup-boolean-) | Whether or not to allow signup on widget |\n| [defaultDatabaseConnection](#defaultdatabaseconnection-string-) | Default shown DB connection |\n| [initialScreen](#initialscreen-string-) | Which screen to show when the widget is opened |\n| [loginAfterSignUp](#loginaftersignup-boolean-) | After signup, whether or not to auto login |\n| [forgotPasswordLink](#forgotpasswordlink-string-) | Link to a custom forgot password page |\n| [showTerms](#showterms-boolean-) | Specify if signup terms should be display |\n| [mustAcceptTerms](#mustacceptterms-boolean-) | Whether or not terms must be accepted (checkbox) |\n| [prefill](#prefill-object-) | Prefill values for email/username fields |\n| [signUpLink](#signuplink-string-) | Set a custom url to fire when clicking \"sign up\" |\n| [usernameStyle](#usernamestyle-string-) | Limit username field to accept only \"username\" values or only \"email\" values |\n\n## Enterprise\n\n| Option | Description |\n| --- | --- |\n| [defaultEnterpriseConnection](#defaultenterpriseconnection-string-) | Specifies a connection if more than one present |\n\n## Passwordless\n\n| Option | Description |\n| --- | --- |\n| [passwordlessMethod](#passwordlessmethod-string-) | When using `Auth0LockPasswordless` with an email connection, you can use this option to pick between sending a [code](https://auth0.com/docs/connections/passwordless/spa-email-code) or a [magic link](https://auth0.com/docs/connections/passwordless/spa-email-link) to authenticate the user |\n\n### Other\n\n| Option | Description |\n| --- | --- |\n| [configurationBaseUrl](#configurationbaseurl-string-) | Override your application's base URL |\n| [languageBaseUrl](#languagebaseurl-string-) | Override your language file base URL |\n| [hashCleanup](#hashcleanup-boolean-) | Override the default removal of the hash from the URL |\n| [connectionResolver](#connectionresolver-function-) | Optional callback function for choosing a connection based on the username information |\n\n* * *\n\n## UI Options\n\n### allowAutocomplete {Boolean}\n\nDetermines whether or not the email or username fields will allow autocomplete (`<input autocomplete />`). Defaults to `false`.\n\n`allowAutocomplete: true`\n\n### allowPasswordAutocomplete {Boolean}\n\nDetermines whether or not the password field will allow autocomplete (`<input autocomplete />`). Defaults to `false`.\n\nSet `allowPasswordAutocomplete` to `true` for password manager support and to avoid other cases of adverse behavior.\n\n`allowPasswordAutocomplete: true`\n\n### allowShowPassword {Boolean}\n\nThis option determines whether or not to add a checkbox to the UI which, when selected, will allow the user to show their password when typing it. The option defaults to `false`.\n\n`allowShowPassword: true`\n\nLock with `allowShowPassword` set to `true` and toggled to show the password:\n\n![Lock Option: Allow Show Password](https://images.ctfassets.net/cdy7uua7fh8z/6G8LJaNjaMl5zUrwGi5UJQ/44dc951b70077b0ec6bc04d2f0413b12/lock-allowshowpassword.png)\n\n### allowedConnections {Array}\n\nArray of connections that will be used for the `signin|signup|reset` actions. Defaults to all enabled connections.\n\n`allowedConnections: ['Username-Password-Authentication']`\n\n`allowedConnections: ['twitter', 'facebook', 'linkedin']`\n\n`allowedConnections: ['qraftlabs.com']`\n\nExamples of `allowedConnections`:\n\n![Lock Option: Allowed Connections - Database](https://images.ctfassets.net/cdy7uua7fh8z/1mllPDLFCCETwQ9MeGEf3W/763728971302656618ef3bd131ab83b1/lock-allowedconnections-database.png)![Lock Option: Allowed Connections - Social](https://images.ctfassets.net/cdy7uua7fh8z/7uYN4ebrLLM8bjx1fee8j0/1e716cca3e1bae990063e9226dfe9ac2/lock-allowedconnections-social.png)\n\n### autoclose {Boolean}\n\nDetermines whether or not the Lock will be closed automatically after a successful sign in. Defaults to false. If the Lock is not `closable` it won't be closed, even if this option is set to true.\n\n`autoclose: true`\n\n### autofocus {Boolean}\n\nIf true, the focus is set to the first field on the widget. Defaults to `false` when being rendered on a mobile device, or if a `container` option is provided; defaults to `true` in all other cases.\n\n`autofocus: false`\n\n### avatar {Object}\n\nBy default, Gravatar is used to fetch the user avatar and display name, but you can obtain them from anywhere with the `avatar` option.\n\n```\nvar options = {\n  avatar: {\n    url: function(email, cb) {\n      // Obtain the avatar url for the email input by the user, Lock\n      // will preload the image before displaying it.\n      // Note that in case of an error you call cb with the error in\n      // the first arg instead of `null`.\n      var url = obtainAvatarUrl(email);\n      cb(null, url);\n    },\n    displayName: function(email, cb) {\n      // Obtain the display name for the email input by the user.\n      // Note that in case of an error you call cb with the error in\n      // the first arg instead of `null`.\n      var displayName = obtainDisplayName(email);\n      cb(null, displayName);\n    }\n  }\n};\n```\n\nOr, if you want to display no avatar at all, simply pass in `null`.\n\n`avatar: null`\n\nDefault behavior with Gravatar:\n\n![Lock Option: Avatar](https://images.ctfassets.net/cdy7uua7fh8z/69Nz0QoQifPWpfBZwX15J0/204aad93cde406f0ed3771ce38766f56/lock-avatar.png)\n\n### closable {Boolean}\n\nDetermines whether or not the Lock can be closed. When a `container` option is provided its value is always `false`, otherwise it defaults to `true`.\n\n`closable: false`\n\n![Lock Option: Closable](https://images.ctfassets.net/cdy7uua7fh8z/2qwXtPQev1nlpyOQauXKBO/f967e1157972ecbf5b030b3be3600f2e/lock-closable.png)\n\n### container {String}\n\nThe `id` of the html element where the widget will be shown.\n\nThis makes the widget appear inline within your `div` instead of in a modal pop-out window.\n\n```\n<div id=\"hiw-login-container\"></div>\n\n<script>\n  var options = {\n    container: 'hiw-login-container'\n  };\n\n  // initialize\n  var lock = new Auth0Lock('xxxxxx', '<account>.auth0.com', options);\n\n  // render\n  lock.show();\n</script>\n```\n\n![Lock Option: Container](https://images.ctfassets.net/cdy7uua7fh8z/5L4S47Yfset2DR9pjcqVrX/1c4d1928cf75acf40129ffd01394bf33/lock-container.png)\n\n### flashMessage {Object}\n\nShows an `error` or `success` flash message when Lock is shown. This object has the following properties:\n\n*   type {String}: The message type, supported types are `error`, `info`, and `success`\n    \n*   text {String}: The text to show.\n    \n\n```\nvar options = {\n  flashMessage: {\n    type: 'success',\n    text: 'Welcome!'\n  }\n};\n```\n\n### language {String}\n\nSpecifies the language of the widget. Defaults to \"en\". See the [internationalization directory](https://github.com/auth0/lock/blob/master/src/i18n/) for a current list of provided languages.\n\n`language: 'es'`\n\n![Lock Option: Language](https://images.ctfassets.net/cdy7uua7fh8z/3u3lytCUBDbcKmXFV34OUv/5cf5d7e1af9593a3b094f32815a4da11/lock-language.png)\n\n### languageDictionary {Object}\n\nAllows customization of every piece of text displayed in the Lock. Defaults to {}. See English language [Language Dictionary Specification](https://github.com/auth0/lock/blob/master/src/i18n/en.js) for the full list of `languageDictionary` values able to be altered with this object.\n\n```\nvar options = {\n  languageDictionary: {\n    emailInputPlaceholder: \"something@youremail.com\",\n    title: \"Log me in\"\n  },\n};\n```\n\n![Lock Option: Language Dictionary](https://images.ctfassets.net/cdy7uua7fh8z/5203ofwtagtIKGT4HnIPmk/8ad9cdd151a2cdb18b8a42ee47dbf679/lock-languagedictionary.png)\n\nAdditionally, check out the [Customizing Error Messages](https://auth0.com/docs/customize/login-pages/classic-login/customize-lock-error-messages) page or the [Internationalization](https://auth0.com/docs/customize/internationalization-and-localization/lock-internationalization) page for more information about the use of the `languageDictionary` option.\n\nAllows the customization the location of the popup in the screen. Any position and size feature allowed by window.open is accepted. Defaults to {}.\n\nOptions for the `window.open` features. This only applies if `redirect` is set to `false`.\n\n```\nvar options = {\n  auth: {\n      redirect: false\n  },\n  popupOptions: { width: 300, height: 400, left: 200, top: 300 }\n};\n```\n\n### rememberLastLogin {Boolean}\n\nDetermines whether or not to show a screen that allows you to quickly log in with the account you used the last time. Requests Single Sign-on (SSO) data and enables a **Last time you signed in with** message. Defaults to `true`. This information comes from the user's Auth0 session, so this ability will last as long as their Auth0 session would (which is configurable).\n\n`rememberLastLogin: false`\n\nNew tenants [automatically have Seamless SSO enabled](https://auth0.com/docs/get-started/tenant-settings/enable-sso-for-legacy-tenants). With this enabled, the `rememberLastLogin` option will not be relevant because if there is a session in place then the Universal Login page will not be displayed at all. Using Seamless SSO is highly recommended because it provides a seamless authentication experience: users log in once and won’t have to enter credentials again when they navigate either through the applications you have built, or third party apps. If the user is not logged in they will be redirected to the login screen, as expected. Additionally, the **Last time you signed in with** message will not be available under the following circumstances:\n\n*   You used Lock in a [Hosted Login Page](https://auth0.com/docs/authenticate/login/auth0-universal-login) with the session established using [Passwordless authentication](https://auth0.com/docs/connections/passwordless).\n    \n*   You used Lock in an [embedded login scenario](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login) where `responseType: code` (indicating the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow), which is used for Regular Web Apps).\n    \n\n### scrollGlobalMessagesIntoView {Boolean}\n\nDetermines whether or not a `globalMessage` should be scrolled into the user's viewport. Defaults to `true`.\n\n`scrollGlobalMessagesIntoView: false`\n\n## Theme Options\n\nTheme options are grouped in the `theme` property of the `options` object.\n\n```\nvar options = {\n  theme: {\n    labeledSubmitButton: false,\n    logo: \"https://example.com/assets/logo.png\",\n    primaryColor: \"green\",\n    authButtons: {\n      connectionName: {\n        displayName: \"...\",\n        primaryColor: \"...\",\n        foregroundColor: \"...\",\n        icon: \"https://.../logo.png\"\n      }\n    }\n  }\n};\n```\n\n### authButtons {Object}\n\nAllows the customization of buttons in Lock with custom OAuth2 connections. Each custom connection whose button you desire to customize should be listed by name, each with their own set of parameters. The customizable parameters are listed below:\n\n*   **displayName** {String}: The name to show instead of the connection name when building the button title, such as `LOGIN WITH MYCONNECTION` for login).\n    \n*   **primaryColor** {String}: The button's background color. Defaults to `#eb5424`.\n    \n*   **foregroundColor** {String}: The button's text color. Defaults to `#FFFFFF`.\n    \n*   **icon** {String}: The URL of the icon for this connection. For example: `http://site.com/logo.png`.\n    \n\n```\nvar options = {\n  theme: {\n    authButtons: {\n      \"testConnection\": {\n        displayName: \"Test Conn\",\n        primaryColor: \"#b7b7b7\",\n        foregroundColor: \"#000000\",\n        icon: \"http://example.com/icon.png\"\n      },\n      \"testConnection2\": {\n        primaryColor: \"#000000\",\n        foregroundColor: \"#ffffff\",\n      }\n    }\n  }\n};\n```\n\n### labeledSubmitButton {Boolean}\n\nThis option indicates whether or not the submit button should have a label, and defaults to `true`. When set to `false`, an icon will be shown instead.\n\n```\nvar options = {\n  theme: {\n    labeledSubmitButton: false\n  }\n};\n```\n\n![Lock Option: Labeled Submit Button](https://images.ctfassets.net/cdy7uua7fh8z/5PNCvsbYa98pKZwWHVPS9S/39cb5ac63818ec5558c451b1e37f735f/lock-theme-labeledsubmitbutton.png)\n\nIf the label is set to true, which is the default, the label's text can be customized through the [languageDictionary](#languagedictionary-object-) option.\n\n### logo {String}\n\nThe value for `logo` is a URL for an image that will be placed in the Lock's header, and defaults to Auth0's logo. It has a recommended max height of `58px` for a better user experience.\n\n```\nvar options = {\n  theme: {\n    logo: 'https://example.com/logo.png'\n  }\n};\n```\n\n![Lock UI customization - Logo](https://images.ctfassets.net/cdy7uua7fh8z/FdOAKKy71rTbFjIlZEL8D/2eef96008095d85388daaa461707901d/lock-theme-logo.png)\n\n### primaryColor {String}\n\nThe `primaryColor` property defines the primary color of the Lock; all colors used in the widget will be calculated from it. This option is useful when providing a custom `logo`, to ensure all colors go well together with the `logo`'s color palette. Defaults to `#ea5323`.\n\n```\nvar options = {\n  theme: {\n    logo: 'https://example.com/logo.png',\n    primaryColor: '#31324F'\n  }\n};\n```\n\n![Lock UI customization - primary color](https://images.ctfassets.net/cdy7uua7fh8z/1qQjeTmXJyIziv400VPaOn/48dd3cb8a72a6e88b2634b4b8a8bed63/lock-theme-primarycolor.png)\n\n## Authentication Options\n\nAuthentication options are grouped in the `auth` property of the `options` object.\n\nThe default scope used by Lock is `openid profile email`.\n\n```\nvar options = {\n  auth: {\n   params: {\n    param1: \"value1\",\n    scope: \"openid profile email\"\n   },\n   autoParseHash: true,\n   redirect: true,\n   redirectUrl: \"some url\",\n   responseMode: \"form_post\",\n   responseType: \"token\",\n   sso: true,\n   connectionScopes: {\n    connectionName: [ 'scope1', 'scope2' ]\n   }\n  }\n};\n```\n\n### audience {String}\n\nThe `audience` option indicates the API which will be consuming the Access Token that is received after authentication.\n\n```\nvar options = {\n  auth: {\n    audience: 'https://{yourDomain}/userinfo',\n  }\n}\n```\n\n### autoParseHash {Boolean}\n\nWhen `autoParseHash` is set to `true`, Lock will parse the `window.location.hash` string when instantiated. If set to `false`, you'll have to manually resume authentication using the [resumeAuth](https://auth0.com/docs/libraries/lock/lock-api-reference) method.\n\n```\nvar options = {\n  auth: {\n    autoParseHash: false\n  }\n};\n```\n\n### connectionScopes {Object}\n\nThis option allows you to set scopes to be sent to the oauth2/social connection for authentication.\n\n```\nvar options = {\n  auth: {\n    connectionScopes: {\n      'facebook': ['scope1', 'scope2']\n    }\n  }\n};\n```\n\nA listing of particular scopes for your social connections can be acquired from the provider in question. For example, [Facebook for Developers](https://developers.facebook.com/docs/facebook-login/permissions/) reference has a listing of separate permissions that can be requested for your connection.\n\n### params {Object}\n\nYou can send parameters when starting a login by adding them to the options object. The example below adds a `state` parameter with a value equal to `foo` and also adds a `scope` parameter (which includes the scope, and then the requested attributes).\n\n```\nvar options = {\n  auth: {\n    params: {\n      state: 'foo',\n      scope: 'openid email user_metadata app_metadata picture'\n    }\n  }\n};\n```\n\nFor more details about supported parameters, see [Lock Authentication Parameters](https://auth0.com/docs/libraries/lock/lock-authentication-parameters).\n\n### redirect {Boolean}\n\nDefaults to true. When set to true, redirect mode will be used. If set to false, [popup mode](https://auth0.com/docs/libraries/lock/lock-authentication-modes) is chosen.\n\n```\nvar options = {\n  auth: {\n    redirect: false\n  }\n};\n```\n\n### redirectUrl {String}\n\nThe URL Auth0 will redirect back to after authentication. Defaults to the empty string \"\" (no redirect URL).\n\n```\nvar options = {\n  auth: {\n    redirectUrl: 'http://testurl.com'\n  }\n};\n```\n\nWhen the `redirectUrl` is provided (set to non blank value) the `responseType` option will be defaulted to `code` if not manually set.\n\n### responseMode {String}\n\nShould be set to `\"form_post\"` if you want the code or the token to be transmitted via an HTTP POST request to the `redirectUrl`, instead of being included in its query or fragment parts.\n\nOtherwise, this option should be omitted, and is omitted by default.\n\n```\nvar options = {\n  auth: {\n    responseMode: 'form_post'\n  }\n};\n```\n\n### responseType {String}\n\nThe value of `responseType` should be set to \"token\" for Single-Page Applications, and \"code\" otherwise. Defaults to \"code\" when redirectUrl is provided, and to \"token\" otherwise.\n\n```\nvar options = {\n  auth: {\n    responseType: 'token'\n  }\n};\n```\n\nWhen the `responseType` is set to `code`, Lock will never show the **Last time you logged in with** message, and will always prompt the user for credentials.\n\n## sso {Boolean}\n\nDefaults to true. When set to true, enables [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on) in Lock.\n\n```\nvar options = {\n  auth: {\n    sso: false\n  }\n};\n```\n\n## Database Options\n\n### additionalSignUpFields {Array}\n\nExtra input fields can be added to the sign up screen with the `additionalSignUpFields` option. Each option added in this manner will then be added to that user's `user_metadata`. To learn more, read [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata). Every input must have a `name` and a `placeholder`, and an `icon` URL can also be provided. Also, the initial value can be provided with the `prefill` option, which can be a string with the value or a function that obtains it. Other options depend on the type of the field, which is defined via the type option and defaults to \"text\".\n\n#### Option additionalSignUpFields Intended for use with database signup only\n\nThe `additionalSignUpFields` are intended for use with database signups only. If you have social sign ups too, you can ask for the additional information after the users sign up (see this [page about custom signup](https://auth0.com/docs/libraries/custom-signup) for more details). You can use the `databaseAlternativeSignupInstructions` i18n key to display these instructions.\n\nThe new fields are rendered below the regular sign up input fields in the order they are provided.\n\n#### Text Fields\n\nText fields are the default type of additional signup field. Note that a `validator` function can also be provided.\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    name: \"address\",\n    placeholder: \"enter your address\",\n    // The following properties are optional\n    icon: \"https://example.com/assests/address_icon.png\",\n    prefill: \"street 123\",\n    validator: function(address) {\n      return {\n         valid: address.length >= 10,\n         hint: \"Must have 10 or more chars\" // optional\n      };\n    }\n  },\n  {\n    name: \"full_name\",\n    placeholder: \"Enter your full name\"\n  }]\n}\n```\n\nIf you don't specify a `validator` the text field will be **required**. If you want to make the text field optional, use a validator that always returns `true` like this:\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    name: \"favorite_color\",\n    placeholder: \"Enter your favorite color (optional)\",\n    validator: function() { \n      return true;\n    }\n  }]\n}\n```\n\nIf you want to save the value of the attribute in the root of your profile, use `storage: 'root'`. Only a subset of values can be stored this way. The list of attributes that can be added to your root profile is [here](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id). By default, every additional sign up field is stored inside the user\\_metadata object.\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    name: \"name\",\n    storage: \"root\"\n  }]\n};\n```\n\n![Lock Option: Additional Signup Fields](https://images.ctfassets.net/cdy7uua7fh8z/2KPDGZb3caq57caJ90w53k/e092bdb4a4d93589aa006f796ff20fca/lock-additionalsignupfields.png)\n\n#### Select Field\n\nThe signup field `type: \"select\"` will allow you to use select elements for the user to choose a value from.\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    type: \"select\",\n    name: \"location\",\n    placeholder: \"choose your location\",\n    options: [\n      {value: \"us\", label: \"United States\"},\n      {value: \"fr\", label: \"France\"},\n      {value: \"ar\", label: \"Argentina\"}\n    ],\n    // The following properties are optional\n    icon: \"https://example.com/assests/location_icon.png\",\n    prefill: \"us\"\n  }]\n}\n```\n\nThe `options` array items for `select` fields must adhere to the following format: `{label: “non empty string”, value: “non empty string”}`, and at least one option must be defined.\n\nThe `options` and `prefill` values can be provided through a function:\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    type: \"select\",\n    name: \"location\",\n    placeholder: \"choose your location\",\n    options: function(cb) {\n      // obtain options, in case of error you call cb with the error in the\n      // first arg instead of null\n      cb(null, options);\n    },\n    icon: \"https://example.com/assests/location_icon.png\",\n    prefill: function(cb) {\n      // obtain prefill, in case of error you call cb with the error in the\n      // first arg instead of null\n      cb(null, prefill);\n    }\n  }]\n}\n```\n\n#### Checkbox Field\n\nThe third type of custom signup field is the `type: \"checkbox\"`. The `prefill` value can determine the default state of the checkbox (`true` or `false`), and it is required.\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    type: \"checkbox\",\n    name: \"newsletter\",\n    prefill: \"true\",\n    placeholder: \"I hereby agree that I want to receive marketing emails from your company\"\n  }]\n}\n```\n\n#### Hidden field\n\nThe signup field `type: \"hidden\"` will allow you to use a hidden input with a fixed value.\n\n```\nvar options = {\n  additionalSignUpFields: [{\n    type: \"hidden\",\n    name: \"signup_code\",\n    value: \"abc123\"\n  }]\n}\n```\n\nSome use cases may be able to use `additionalSignUpFields` data for email templates, such as an option for language preferences, the value of which could then be used to set the language of templated email communications.\n\n### allowLogin {Boolean}\n\nWhen set to `false` the widget won't display the login screen. This is useful if you want to use the widget just for signups (the login and signup tabs in the signup screen will be hidden) or to reset passwords (the back button in the forgot password screen will be hidden). In such cases you may also need to specify the `initialScreen`, `allowForgotPassword` and `allowSignUp` options. It defaults to `true`.\n\n`allowLogin: false`\n\n![Lock Option: Allow Login](https://images.ctfassets.net/cdy7uua7fh8z/6gI4aSLHXLzhcHiR9aWMET/d05c2a08a3895278b01150ecf894cb5f/lock-allowlogin.png)\n\n### allowForgotPassword {Boolean}\n\nWhen set to false, `allowForgotPassword` hides the \"Don't remember your password?\" link in the Login screen, making the Forgot Password screen unreachable. Defaults to true. If you are using a database connection with a custom database which doesn't have a change password script the Forgot Password screen won't be available.\n\n`allowForgotPassword: false`\n\n![Lock Option: Allow Forgot Password](https://images.ctfassets.net/cdy7uua7fh8z/1L6wJS3UnWK1VGKYMFhAB9/2ddcf2d462255e78a8b78958c2503809/lock-allowforgotpassword.png)\n\n### allowSignUp {Boolean}\n\nWhen set to `false`, hides the login and sign up tabs in the login screen, making the sign up screen unreachable. Defaults to `true`. Keep in mind that if the database connection has sign ups disabled or you are using a custom database which doesn't have a create script, then the sign up screen won't be available.\n\nAlso bear in mind that this option **only** controls client-side appearance, and does not completely stop new sign ups from determined anonymous visitors. If you are looking to fully prevent new users from signing up, you must use the **Disable Sign Ups** option in the dashboard, in the connection settings.\n\n`allowSignUp: false`\n\n![Lock Option: Allow Signup](https://images.ctfassets.net/cdy7uua7fh8z/2BNlYe99EFlRmIlhoLZiEB/f280d865cb16fa5fecda952271cb18bf/lock-allowsignup.png)\n\n### defaultDatabaseConnection {String}\n\nSpecifies the database connection that will be used when there is more than one available.\n\n`defaultDatabaseConnection: 'test-database'`\n\n### initialScreen {String}\n\nThe name of the screen that will be shown when the widget is opened. Valid values are `login`, `signUp`, and `forgotPassword`. If this option is left unspecified, the widget will default to the first screen that is available from that list.\n\n`initialScreen: 'forgotPassword'`\n\n### loginAfterSignUp {Boolean}\n\nDetermines whether or not the user will be automatically signed in after a successful sign up. Defaults to `true`.\n\n`loginAfterSignUp: false`\n\n### forgotPasswordLink {String}\n\nSet the URL for a page that allows the user to reset their password. When set to a non-empty string, the user will be sent to the provided URL when clicking the \"Don't remember your password?\" link in the login screen.\n\n`forgotPasswordLink: 'https://yoursite.com/reset-password'`\n\n### showTerms {Boolean}\n\nWhen set to `true` displays the `languageDictionary.signUpTerms` string. Defaults to `true`.\n\n`showTerms: false`\n\n### mustAcceptTerms {Boolean}\n\nWhen set to `true` displays a checkbox input alongside the terms and conditions that must be checked before signing up. The terms and conditions can be specified via the `languageDictionary` option. This option will only take effect for users signing up with database connections. Defaults to `false`.\n\n`mustAcceptTerms: true`\n\n### prefill {Object}\n\nAllows to set the initial value for the email and/or username inputs. When omitted, no initial value will be provided.\n\n```\nvar options = {\n  prefill: {\n    email: \"someone@auth0.com\",\n    username: \"someone\",\n    phoneNumber: \"+1234567890\"\n  }\n};\n```\n\n### signUpLink {String}\n\nSet the URL to be requested when clicking on the Signup button. When set to a non empty string, this option forces `allowSignUp` to `true`.\n\n`signUpLink: 'https://yoursite.com/signup'`\n\n### usernameStyle {String}\n\nDetermines what will be used to identify the user for a Database connection that has the `requires_username` flag set (if it is not set, `usernameStyle` option will be ignored). Possible values are `\"username\"` and `\"email\"`. By default both `username` and `email` are allowed; setting this option will limit logins to use one or the other.\n\n`usernameStyle: 'username'`\n\n## Enterprise Options\n\n### defaultEnterpriseConnection {String}\n\nSpecifies the enterprise connection which allows to login using a username and a password that will be used when there is more than one available or there is a database connection. If a `defaultDatabaseConnection` is provided the database connection will be used and this option will be ignored.\n\n`defaultEnterpriseConnection: 'test-database'`\n\n### defaultADUsernameFromEmailPrefix {Boolean}\n\nResolve the AD placeholder username from the email's prefix. Defaults to `true`.\n\n`defaultADUsernameFromEmailPrefix: false`\n\n## Passwordless Options\n\n### passwordlessMethod {String}\n\nWhen using `Auth0LockPasswordless` with an email connection, you can use this option to pick between sending a [code](https://auth0.com/docs/connections/passwordless/spa-email-code) or a [magic link](https://auth0.com/docs/connections/passwordless/spa-email-link) to authenticate the user. Available values for email connections are `code` and `link`. Defaults to `code`. SMS passwordless connections will always use `code`.\n\n`passwordlessMethod: code`\n\n## Other Options\n\n### configurationBaseUrl {String}\n\nOverrides the application settings base URL. By default, it uses the provided domain. This option is only necessary if your specific use case dictates that your application does not use the default behavior.\n\n`configurationBaseUrl: \"https://www.example.com\"`\n\n### languageBaseUrl {String}\n\nOverrides the language source url for Auth0's provided translations. By default, this option uses Auth0's CDN URL `https://cdn.auth0.com` since this is where all of the provided translations are stored. By providing another value, you can use another source for the language translations if needed.\n\n`languageBaseUrl: \"https://www.example.com\"`\n\n### hashCleanup {Boolean}\n\nWhen the `hashCleanup` option is enabled, it will remove the hash part of the callback URL after the user authentication. It defaults to true.\n\n`hashCleanup: false`\n\n### connectionResolver {Function}\n\nWhen in use, provides an extensibility point to make it possible to choose which connection to use based on the username information.\n\nHas `username`, `context`, and `callback` as parameters. The callback expects an object like: `{type: 'database', name: 'connection name'}`. **This only works for database connections.** Keep in mind that this resolver will run in the form's `onSubmit` event, so keep it simple and fast.\n\nThis is a beta feature. If you find a bug, please open a GitHub [issue](https://github.com/auth0/lock/issues/new).\n\n### leeway {Integer}\n\nThe `leeway` option can be set to an integer - a value in seconds - which can be used to account for clock skew in ID Token expirations. Typically the value is no more than a minute or two at maximum.\n\n`leeway: 30`",
  "title": "Lock Configuration Options",
  "description": "Lock has many configurable options that allow you to change the behavior, appearance, and connectivity of the Lock widget - this resource provides the details on those options for you!",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock/lock-api-reference",
  "markdown": "# Lock API Reference\n\nLock has many methods, features, and configurable options. This reference is designed to direct you to the ones that you need, and discuss how to use them. Click below to go straight the method you're looking for, or just browse! If you're looking for information about events emitted by Lock, they're listed under the [on()](#on-) method section!\n\n*   [new Auth0Lock](#auth0lock) - Instantiating Lock\n    \n*   [getUserInfo()](#getuserinfo-) - Obtaining the profile of a logged in user\n    \n*   [show()](#show-) - Showing the Lock widget\n    \n*   [on()](#on-) - Listening for events\n    \n*   [resumeAuth()](#resumeauth-) - Use to complete authentication flow when `autoParseHash` is false\n    \n*   [checkSession()](#checksession-) - Get a new token from Auth0 for an authenticated user\n    \n*   [logout()](#logout-) - Log out the user\n    \n\n## Auth0Lock\n\n`new Auth0Lock(clientID, domain, options)`\n\nInitializes a new instance of `Auth0Lock` configured with your application's `clientID` and your account's `domain` from your [Auth0](https://manage.auth0.com/#/) management dashboard. The third and optional parameter is an `options` object used to configure Lock for your application's needs. You can find this information at your [application settings](https://manage.auth0.com/#/applications).\n\n*   **clientId {String}**: Required parameter. Your application's clientId in Auth0.\n    \n*   **domain {String}**: Required parameter. Your Auth0 domain. Usually your-account.auth0.com.\n    \n*   **options {Object}**: Optional parameter. Allows for the configuration of Lock's appearance and behavior. See [the configuration options page](https://auth0.com/docs/libraries/lock/lock-configuration) for details.\n    \n\nto configure this snippet with your account\n\n```\nvar Auth = (function() {\n\n  var privateStore = {};\n\n  function Auth() {\n    // Instantiate Lock - without custom options\n    this.lock = new Auth0Lock(\n      '<{yourClientId}>',\n      '<{yourDomain}>'\n    );\n  }\n\n  Auth.prototype.getProfile = function() {\n    return privateStore.profile;\n  };\n\n  Auth.prototype.authn = function() {\n    // Listening for the authenticated event and get profile\n    this.lock.on(\"authenticated\", function(authResult) {\n      // Use the token in authResult to getUserInfo() and save it if necessary\n      this.getUserInfo(authResult.accessToken, function(error, profile) {\n        if (error) {\n          // Handle error\n          return;\n        }\n\n        //save Access Token only if necessary\n        privateStore.accessToken = accessToken;\n        privateStore.profile = profile;\n\n        // Update DOM\n      });\n    });\n  };\n  return Auth;\n}());\n```\n\n## getUserInfo()\n\n`getUserInfo(accessToken, callback)`\n\nOnce the user has logged in and you are in possession of a token, you can use that token to obtain the user's profile with `getUserInfo`. This method replaces the deprecated `getProfile()`.\n\n*   **accessToken {String}**: User token.\n    \n*   **callback {Function}**: Will be invoked after the user profile been retrieved.\n    \n\n```\nlock.getUserInfo(accessToken, function(error, profile) {\n  if (!error) {\n    alert(\"hello \" + profile.name);\n  }\n});\n```\n\n## show()\n\n`show(options)`\n\nThe `show` method displays the widget. Beginning with Lock version 10.2.0, the `show` method can now accept an `options` object as a parameter. Note that this parameter is meant to be used as a way to override your Lock's `options` for this particular displaying of the widget - options should be set when instantiating Lock, and overridden, only if needed for your specific use case, here.\n\nThe following subset of `options` to be overridden from the values they were given (or their defaults) when Lock was instantiated:\n\n*   allowedConnections\n    \n*   auth.params\n    \n*   allowLogin\n    \n*   allowSignUp\n    \n*   allowForgotPassword\n    \n*   initialScreen\n    \n*   rememberLastLogin\n    \n\nFor more detail on the entire list of configurable options that can be chosen when instantiating Lock, as opposed to the limited subset above that can be overridden in the `show` method, please see the [user configurable options page](https://auth0.com/docs/libraries/lock/lock-configuration).\n\nOptions override examples:\n\n```\n// Show the Lock widget, without overriding any options\nlock.show();\n\n// Show the Lock widget, overriding some options\nlock.show({\n  allowedConnections: [\"twitter\", \"facebook\"],\n  allowSignUp: false\n});\n```\n\nOptions should be set when first instantiating Lock `var lock = new Auth0Lock(clientId, domain, options);`. Options should only be passed to `show` in order to override your previously set options while displaying the widget at this particular time and place.\n\nThere is an additional option that can be set in the `show` method called `flashMessage`.\n\n### flashMessage\n\nThis object is only available as an option for the `show` method, not for use in the normal `options` object when instantiating Lock. The `flashMessage` object shows an error or success flash message when Lock is shown. It has the following parameters:\n\n*   **type** {String}: The message type, it should be either `error` or `success`.\n    \n*   **text** {String}: The text to show.\n    \n\n```\nlock.show({\n  flashMessage:{\n    type: 'success',\n    text: 'Amazing Success!!'\n  }\n});\n```\n\nA practical application of the `flashMessage` option is to handle authorization errors. The `flashMessage` can be populated with error description text.\n\n```\nlock.on('authorization_error', function(error) {\n  lock.show({\n    flashMessage: {\n      type: 'error',\n      text: error.errorDescription\n    }\n  });\n});\n```\n\nSo, if `tester@example.com` were now to try to sign in, being a user who is blocked, the user will be shown Lock again, with a top bar displaying the error message, rather than simply failing to login and Lock closing.\n\n## hide()\n\n`hide()`\n\nThe `hide` method closes the widget if it is currently open. The widget closes itself under most circumstances, so this method would primarily be invoked in specific use cases only. For instance, one might wish to listen for the `unrecoverable_error` event and then `hide` the Lock and redirect to their own custom error page. Another example is users who are implementing [popup mode](https://auth0.com/docs/libraries/lock/lock-authentication-modes), and might need to manually `hide` the widget after the `authenticated` event fires.\n\nExample usage to hide (close) the Lock widget in popup mode:\n\n```\n// Listen for authenticated event and hide Lock\nlock.on(\"authenticated\", function() {\n  lock.hide();\n\n  // Whatever else you'd like to do on authenticated event\n\n});\n```\n\n## on()\n\nLock will emit events during its lifecycle. The `on` method can be used to listen for particular events and react to them.\n\n*   `show`: emitted when Lock is shown. Has no arguments.\n    \n*   `hide`: emitted when Lock is hidden. Has no arguments.\n    \n*   `unrecoverable_error`: emitted when there is an unrecoverable error, for instance when no connection is available. Has the error as the only argument.\n    \n*   `authenticated`: emitted after a successful authentication. Has the authentication result as the only argument. The authentication result contains the token which can be used to get the user's profile or stored to log them in on subsequent checks.\n    \n*   `authorization_error`: emitted when authorization fails. Has error as the only argument.\n    \n*   `hash_parsed`: every time a new Auth0Lock object is initialized in redirect mode (the default), it will attempt to parse the hash part of the url looking for the result of a login attempt. This is a low level event for advanced use cases and `authenticated` and `authorization_error` should be preferred when possible. After that this event will be emitted with `null` if it couldn't find anything in the hash. It will be emitted with the same argument as the `authenticated` event after a successful login or with the same argument as `authorization_error` if something went wrong. This event won't be emitted in [popup mode](https://auth0.com/docs/libraries/lock/lock-authentication-modes) because there is no need to parse the url's hash part.\n    \n*   `forgot_password ready`: emitted when the \"Forgot password\" screen is shown. (Only in Version >`10.18`)\n    \n*   `forgot_password submit`: emitted when the user clicks on the submit button of the \"Forgot password\" screen. (Only in Version >`10.14`)\n    \n*   `signin ready`: emitted when the \"Sign in\" screen is shown.\n    \n*   `signup ready`: emitted when the \"Sign up\" screen is shown.\n    \n*   `signin submit`: emitted when the user clicks on the submit button of the \"Login\" screen. (Only in Version >`10.18`)\n    \n*   `signup submit`: emitted when the user clicks on the submit button of the \"Sign Up\" screen. (Only in Version >`10.18`)\n    \n*   `federated login`: emitted when the user clicks on a social connection button. Has the connection name and the strategy as arguments. (Only in Version >`10.18`)\n    \n*   `socialOrPhoneNumber ready`: emitted when the Passwordless screen with Social + Phone Number is shown\n    \n*   `socialOrPhoneNumber submit`: emitted when the Passwordless screen with Social + Phone Number is submitted\n    \n*   `socialOrEmail ready`: emitted when the Passwordless screen with Social + Email is shown\n    \n*   `socialOrEmail submit`: emitted when the Passwordless screen with Social + Email is submitted\n    \n*   `vcode ready`: emitted when the Passwordless screen with the one-time-password is shown\n    \n*   `vcode submit`: emitted when the Passwordless screen with the one-time-password is submitted\n    \n\nThe `authenticated` event listener has a single argument, an `authResult` object. This object contains the following properties: `accessToken`, `idToken`, `state`, `refreshToken` and `idTokenPayload`.\n\nAn example use of the `authenticated` event:\n\nto configure this snippet with your account\n\n```\nvar Auth = (function() {\n\n  var privateStore = {};\n\n  function Auth() {\n    this.lock = new Auth0Lock(\n      '<{yourClientId}>',\n      '<{yourDomain}>'\n    );\n  }\n\n  Auth.prototype.getProfile = function() {\n    return privateStore.profile;\n  };\n\n  Auth.prototype.authn = function() {\n    // Listening for the authenticated event\n    this.lock.on(\"authenticated\", function(authResult) {\n      // Use the token in authResult to getUserInfo() and save it if necessary\n      this.getUserInfo(authResult.accessToken, function(error, profile) {\n        if (error) {\n          // Handle error\n          return;\n        }\n\n        privateStore.profile = profile;\n\n      });\n    });\n  };\n  return Auth;\n}());\n```\n\n## resumeAuth()\n\nThis method can only be used when you set the [auth.autoParseHash](https://auth0.com/docs/libraries/lock/lock-configuration) option to `false`. You'll need to call `resumeAuth` to complete the authentication flow. This method is useful when you're using a client-side router that uses a `#` to handle urls (angular2 with `useHash`, or react-router with `hashHistory`).\n\n*   **hash** {String}: The hash fragment received from the redirect.\n    \n*   **callback** {Function}: Will be invoked after the parse is done. Has an error (if any) as the first argument and the authentication result as the second one. If there is no hash available, both arguments will be `null`.\n    \n\n```\nlock.resumeAuth(hash, function(error, authResult) {\n  if (error) {\n    alert(\"Could not parse hash\");\n  }\n  //This is just an example; you should not log Access Tokens in production.\n  console.log(authResult.accessToken);\n});\n```\n\n## checkSession()\n\nThe `checkSession` method allows you to acquire a new token from Auth0 for a user who is already authenticated against Auth0 for your domain. It takes the following parameters:\n\n*   **options** {Object}: Optional. Accepts any valid OAuth2 parameters that would normally be sent to `/authorize`. If you omit them, it will use the ones provided when initializing Auth0.\n    \n*   **callback** {Function}: Will be invoked with the token renewal result. Has an error (if any) as the first argument and the authentication result as the second one.\n    \n\n```\nlock.checkSession({}, function(err, authResult) {\n  // handle error or new tokens\n});\n```\n\n## logout()\n\nLogs out the user.\n\n*   **options** {Object}: This is optional and follows the same rules as auth0.js logout().\n    \n\n```\nlock.logout({\n  returnTo: 'https://myapp.com/bye-bye'\n});\n```",
  "title": "Lock API Reference",
  "description": "Details on the Lock v11 API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/json-web-tokens",
  "markdown": "# JSON Web Tokens\n\nJSON web token (JWT), pronounced \"jot\", is an open standard ([RFC 7519](https://tools.ietf.org/html/rfc7519)) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. Again, JWT is a standard, meaning that all JWTs are tokens, but not all tokens are JWTs.\n\nBecause of its relatively small size, a JWT can be sent through a URL, through a POST parameter, or inside an HTTP header, and it is transmitted quickly. A JWT contains all the required information about an entity to avoid querying a database more than once. The recipient of a JWT also does not need to call a server to validate the token.\n\n## Benefits of JWTs\n\nThere are benefits to using JWTs when compared to simple web tokens (SWTs) and SAML tokens.\n\n*   **More compact**: JSON is less verbose than XML, so when it is encoded, a JWT is smaller than a SAML token. This makes JWT a good choice to be passed in HTML and HTTP environments.\n    \n\n![Encoded JWT Compared to SAML Token](https://images.ctfassets.net/cdy7uua7fh8z/4S6xl4Yvi0H1CUrLB69ZtH/e3e3bf1767d2d29563a99cf71cab158d/comparing-jwt-vs-saml2.png)\n\n*   **More secure**: JWTs can use a public/private key pair in the form of an X.509 certificate for signing. A JWT can also be symmetrically signed by a shared secret using the HMAC algorithm. And while SAML tokens can use public/private key pairs like JWT, signing XML with XML Digital Signature without introducing obscure security holes is very difficult when compared to the simplicity of signing JSON. Read more about JWT [signing algorithms](https://auth0.com/docs/tokens/concepts/signing-algorithms).\n    \n*   **More common**: JSON parsers are common in most programming languages because they map directly to objects. Conversely, XML doesn't have a natural document-to-object mapping. This makes it easier to work with JWT than SAML assertions.\n    \n*   **Easier to process**: JWT is used at internet scale. This means that it is easier to process on users' devices, especially mobile.\n    \n\n## Use JWTs\n\nJWTs can be used in various ways:\n\n*   **Authentication**: When a user successfully logs in using their credentials, an [ID token](https://auth0.com/docs/secure/tokens/id-tokens) is returned. According to the [OpenID Connect (OIDC) specs](https://openid.net/specs/openid-connect-core-1_0.html#IDToken), an ID token is always a JWT.\n    \n*   **Authorization**: Once a user is successfully logged in, an application may request to access routes, services, or resources (e.g., APIs) on behalf of that user. To do so, in every request, it must pass an Access Token, which may be in the form of a JWT. Single Sign-on (SSO) widely uses JWT because of the small overhead of the format, and its ability to easily be used across different domains.\n    \n*   **Information exchange**: JWTs are a good way of securely transmitting information between parties because they can be signed, which means you can be certain that the senders are who they say they are. Additionally, the structure of a JWT allows you to verify that the content hasn't been tampered with.\n    \n\n## Security of JWTs\n\nThe information contained within the JSON object can be verified and trusted because it is digitally signed. Although JWTs can also be encrypted to provide secrecy between parties, Auth0-issued JWTs are JSON Web Signatures (JWS), meaning they are signed rather than encrypted. As such, we will focus on signed tokens, which can verify the integrity of the claims contained within them, while encrypted tokens hide those claims from other parties.\n\nIn general, JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA (although Auth0 supports only HMAC and RSA). When tokens are signed using public/private key pairs, the signature also certifies that only the party holding the private key is the one that signed it.\n\nBefore a received JWT is used, it should be [properly validated using its signature](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens). Note that a successfully validated token only means that the information contained within the token has not been modified by anyone else. This doesn't mean that others weren't able to see the content, which is stored in plain text. Because of this, you should never store sensitive information inside a JWT and should take other steps to ensure that JWTs are not intercepted, such as by sending JWTs only over HTTPS, following [best practices](https://auth0.com/docs/secure/tokens/token-best-practices), and using only secure and up-to-date libraries.\n\n## Learn more\n\n*   [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure)\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens)\n*   [Signing Keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys)\n*   [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets)\n*   [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens)",
  "title": "JSON Web Tokens",
  "description": "Learn about JSON web tokens (JWTs) and how they are used.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/manage-refresh-tokens-with-auth0-management-api",
  "markdown": "# Manage Refresh Tokens with Auth0 Management API\n\nAuth0 issues a refresh token as a credential artifact that your application can use to get a new access token without user interaction. This allows Auth0 to shorten the access token lifetime for security purposes without involving the user when the access token expires.\n\n## Management API endpoints\n\nThe Auth0 Management API provides endpoints to manage refresh tokens individually or as a collection.\n\nThese endpoints complement [alternative refresh-token revocation](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens), superseding the `device-credentials` resource endpoints with extended properties and bulk revocation operations.\n\n### Refresh Token resource\n\nYou can view or revoke a specific refresh token with the following endpoints:\n\n| **Name** | **URL** | **Required scope(s)** |\n| --- | --- | --- |\n| View a refresh token information by ID | `GET /api/v2/refresh-tokens/{tokenId}` | `read:refresh_tokens` |\n| Revoke a refresh token by ID | `DELETE /api/v2/refresh-tokens/{tokenId}` | `delete:refresh_tokens` |\n\n### User resource\n\nYou can list or revoke all refresh tokens for a given user with the following endpoints:\n\n| **Name** | **URL** | **Required scope(s)** |\n| --- | --- | --- |\n| List all refresh tokens for a user | `GET /api/v2/users/{userId}/refresh-tokens` | `read:refresh_tokens` |\n| Revoke all refresh tokens for a user | `DELETE /api/v2/users/{userId}/refresh-tokens` | `delete:refresh_tokens` |\n\n## Refresh token properties\n\nThe refresh token endpoints return relevant information about the token and its history.\n\n| **Field** | **Description** |\n| --- | --- |\n| Refresh Token ID | A unique and tenant-specific identifier of the refresh token in the API. It is not the token itself, which is a secret to exchange with the token endpoint in the authentication API.<br><br>Refresh tokens can outlive a session. The refresh token keeps this information regardless of the session lifecycle. |\n| Session ID | The session ID is a persistent identifier of the session in the Auth0 tenant. Note that the session ID corresponds to the `sid` claim already in ID Tokens and Logout Tokens and can be used to cross-reference these entities.<br><br>The refresh token contains references to the session that was used to create the token. The session ID can be used to retrieve additional information with the Management API [introspect a specific session by ID](https://auth0.com/docs/manage-users/sessions/manage-user-sessions-with-auth0-management-api) endpoint. |\n| Relevant Time | Refresh token creation, and expiry information. |\n| Client and Resource Servers Information | Summary information about the applications and APIs bound to a refresh token. |\n\n## Limitations \n\n*   Refresh token revocation (`DELETE`) operations run asynchronously, and are eventually consistent.\n    \n*   Refresh tokens issued on or after 21-09-2023 (22-02-2024 for tenants in the US-3 region) contain the session ID (`session_id`) property with the appropriate value. Refresh tokens issued before this date contain this property with a `null` value.\n    \n\n## Learn more\n\n*   [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens)\n*   [Revoke Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens)\n*   [Use Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-tokens)",
  "title": "Manage Refresh Tokens with Auth0 Management API",
  "description": "Learn how to manage refresh tokens with the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/security-guidance/data-security/token-storage",
  "markdown": "# Token Storage\n\nSecuring SPAs that make API calls come with their own set of concerns. You'll need to ensure that tokens and other sensitive data are not vulnerable to [cross-site scripting](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)) (XSS) and can't be read by malicious JavaScript.\n\nTo learn more, see [JWT Handbook](https://auth0.com/resources/ebooks/jwt-handbook) and [The Ultimate Guide to Next.js Authentication with Auth0](https://auth0.com/blog/ultimate-guide-nextjs-authentication-auth0/?utm_source=twitter&utm_medium=sc&utm_campaign=nextjs_authn_guide).\n\n#### Next.js static site scenarios\n\nWhen you're building a Next.js application, authentication might be needed in the following cases:\n\n1.  When accessing a page\n    \n2.  When accessing an API route\n    \n3.  When your application calls an API hosted outside of your Next.js application on behalf of the user\n    \n\nWhere a server is available, your app can handle the interaction with Auth0 and create a session, but in this model, we don't have a backend. All of the work happens on the frontend:\n\n1.  The user is redirected to Auth0.\n    \n2.  When the user is successfully signed in, they will be redirected back to the application.\n    \n3.  The client-side will complete the code exchange with Auth0 and retrieve the user's `id_token` and `access_token` which will be stored in memory.\n    \n    ![Token Storage Best Practices In-Memory Storage diagram](https://images.ctfassets.net/cdy7uua7fh8z/6a4aA0TH8PJQpvhkLaGSIp/e38aae00318515f2a0efa0dfce24dca2/in-memory-token-storage.png)\n\nIf your app is using a sign in scenario that doesn't require API calls, only an ID token is required. There is no need to store it. You can validate it and get the data from it that you required.\n\nIf your app needs to call APIs on behalf of the user, access tokens and (optionally) refresh tokens are needed. These can be stored server-side or in a session cookie. The cookie needs to be encrypted and have a maximum size of 4 KB. If the data to be stored is large, storing tokens in the session cookie is not a viable option.\n\nUse the following flow types in these scenarios:\n\n*   [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)\n    \n*   [Regular Web App Quickstarts](https://auth0.com/docs/quickstart/webapp)\n    \n\n### Browser in-memory scenarios\n\nAuth0 recommends storing tokens in browser memory as the most secure option. Using [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) to handle the transmission and storage of tokens is the best way to protect the tokens, as Web Workers run in a separate global scope than the rest of the application. Use Auth0 SPA SDK whose default storage option is in-memory storage leveraging Web Workers.\n\nIf you cannot use Web Workers, Auth0 recommends as an alternative that you use [JavaScript closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#Emulating_private_methods_with_closures) to emulate private methods.\n\nUse Auth0 SPA SDK whose default storage option is in-memory storage to leverage both Web Workers and JavaScript closures depending on the type of token.\n\n### Browser local storage scenarios\n\nUsing browser local storage can be a viable alternative to mechanisms that require retrieving the access token from an iframe and to cookie-based authentication across domains when these are not possible due to browser restrictions (for example, ITP2).\n\nTo reduce security risks if your SPA is using implicit (we recommend using authorization code flow with PKCE instead) or hybrid flows, you can reduce the absolute token expiration time. This reduces the impact of a reflected XSS attack (but not of a persistent one). To reduce the expiration time, go to **Dashboard > APIs > Settings > Token Expiration For Browser Flows (Seconds)**.\n\nReduce the amount of third-party JavaScript code included from a source outside your domain to the minimum needed (such as links to jQuery, Bootstrap, Google Analytics etc.) Reducing third-party JS code reduces the possibility of an XSS vulnerability. Performing [Subresource Integrity (SRI)](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity) checking in third-party scripts (where possible) to verify that the resources fetched are delivered without unexpected manipulation is also more secure.\n\n## Learn more\n\n*   [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens)\n*   [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens)\n*   [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Token Storage",
  "description": "Learn how and where to store tokens used in token-based authentication.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/get-refresh-tokens",
  "markdown": "# Get Refresh Tokens\n\nTo get a refresh token, you must include the `offline_access` [scope](https://auth0.com/docs/get-started/apis/scopes) when you initiate an authentication request through the `/authorize` endpoint. Be sure to initiate Offline Access in your API. For more information, read [API Settings](https://auth0.com/docs/get-started/apis/api-settings).\n\nFor example, if you are using the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow), the authentication request would look like the following:\n\n```\nhttps://{yourDomain}/authorize?\n    audience={API_AUDIENCE}&\n    scope=offline_access&\n    response_type=code&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    state={OPAQUE_VALUE}\n```\n\nThe refresh token is stored in session. Then, when a session needs to be refreshed (for example, a preconfigured timeframe has passed or the user tries to perform a sensitive operation), the app uses the refresh token on the backend to obtain a new ID token, using the `/oauth/token` endpoint with `grant_type=refresh_token`.\n\nOnce the user authenticates successfully, the application will be redirected to the `redirect_uri`, with a `code` as part of the URL: `{https://yourApp/callback}?code=BPPLN3Z4qCTvSNOy`. You can exchange this code with an access token using the `/oauth/token` endpoint.\n\n*   [cURL](#0034efa159e4401abb57f3cfd8aefa8a_shell)\n*   [C#](#0034efa159e4401abb57f3cfd8aefa8a_csharp)\n*   [Go](#0034efa159e4401abb57f3cfd8aefa8a_go)\n*   [Java](#0034efa159e4401abb57f3cfd8aefa8a_java)\n*   [Node.JS](#0034efa159e4401abb57f3cfd8aefa8a_node)\n*   [Obj-C](#0034efa159e4401abb57f3cfd8aefa8a_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'code={yourAuthorizationCode}' \\\n  --data 'redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    code: '{yourAuthorizationCode}',\n    redirect_uri: '{https://yourApp/callback}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=authorization_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code={yourAuthorizationCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&redirect_uri={https://yourApp/callback}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=authorization_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code={yourAuthorizationCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&redirect_uri={https://yourApp/callback}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe response should contain an access token and a refresh token.\n\n```\n{\n      \"access_token\": \"eyJz93a...k4laUWw\",\n      \"refresh_token\": \"GEbRxBN...edjnXbL\",\n      \"token_type\": \"Bearer\"\n    }\n```\n\nIf you are requesting a Refresh Token for a mobile app using the corresponding Native Client (which is public), then you don't need to send the `client_secret` in the request since it's only required for confidential applications.\n\nRefresh Tokens must be stored securely by an application since they allow a user to remain authenticated essentially forever.\n\nFor more information on how to implement this using the Authorization Code Flow, refer to our tutorial, [Call API Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/call-your-api-using-the-authorization-code-flow). For other grants, see [Authentication and Authorization Flows](https://auth0.com/docs/get-started/authentication-and-authorization-flow).\n\n## Learn more\n\n*   [Use Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-tokens)\n*   [Revoke Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens)\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)",
  "title": "Get Refresh Tokens",
  "description": "Describes how to get a Refresh Token when you initiate a request using the Authorize endpoint.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/token-best-practices",
  "markdown": "# Token Best Practices\n\nHere are some basic considerations to keep in mind when using tokens:\n\n*   **Keep it secret. Keep it safe**: The signing key should be treated like any other credential and revealed only to services that need it.\n    \n*   **Do not add sensitive data to the payload**: Tokens are signed to protect against manipulation and are easily decoded. Add the bare minimum number of claims to the payload for best performance and security.\n    \n*   **Give tokens an expiration**: Technically, once a token is signed, it is valid forever—unless the signing key is changed or expiration explicitly set. This could pose potential issues so have a strategy for expiring and/or revoking tokens.\n    \n*   **Embrace HTTPS**: Do not send tokens over non-HTTPS connections as those requests can be intercepted and tokens compromised.\n    \n*   **Consider all of your authorization use cases**: Adding a secondary token verification system that ensures tokens were generated from your server may be necessary to meet your requirements.\n    \n*   **Store and reuse:** Reduce unnecessary roundtrips that extend your application's attack surface, and optimize plan token limits (where applicable) by storing access tokens obtained from the authorization server. Rather than requesting a new token, use the stored token during future calls until it expires. How you store tokens will depend on the characteristics of your application: typical solutions include databases (for apps that need to perform API calls regardless of the presence of a session) and HTTP sessions (for apps that have an activity window limited to an interactive session). For an example of server-side storage and token reuse, see [Token Storage](https://auth0.com/docs/secure/security-guidance/data-security/token-storage).\n    \n\n## Tokens vs. Cookies\n\nTypically, single-page apps (such as React, Vue, and AngularJS + Node), native mobile apps (such as iOS and Android), and web APIs (written in Node, Ruby, ASP.NET, or a mix of those) benefit most from token-based authentication. Traditional, server-side web applications have traditionally used cookie-based authentication.\n\nToken-based authentication is implemented by generating a token when the user authenticates and then setting that token in the `Authorization` header of each subsequent request to your API. You want that token to be something standard, like JSON web tokens since you will find libraries in most of the platforms and you don't want to do your own crypto.\n\nWith both approaches, you can get the same amount of information from the user. That's controlled by the `scope` parameter sent in the login request (either using the Lock, our JavaScript library or a plain link). The `scope` is a parameter of the `.signin({scope: 'openid name email'})` method which ends up being part of the query string in the login request.\n\nBy default, we use `scope=openid` in token-based authentication to avoid having a huge token. You can control any standard OpenID Connect (OIDC) claims that you want to get in the token by adding them as scope values. For example, `scope=openid name email family_name address phone_number`. To learn more, see [Standard Claims on openid.net](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).\n\nYou can mix token-based authentication with cookie-based authentication. Take into account that cookies will work just fine if the web app and the API are served from the same domain, so you might not need token based authentication. If you need to, we also return a JWT on the web app flow. Each of our SDKs will do it differently. If you want to call your APIs from JavaScript(instead of using the existing cookie), then you have to set the access tokens using Web Workers or JavaScript closures to handle token transmissions and storage. To learn more, read the Browser in-memory scenarios section of our [Token Storage](https://auth0.com/docs/secure/security-guidance/data-security/token-storage) page.\n\n## Refresh token usage\n\nYou can only get a Refresh token if you are implementing the following flows:\n\n*   [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow)\n    \n*   [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/add-login-using-the-authorization-code-flow-with-pkce)\n    \n*   [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n    \n*   [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)\n    \n\nIf you limit offline access to your API, a safeguard configured via the **Allow Offline Access** switch at [Auth0 Dashboard > Applications > APIs > Settings](https://manage.auth0.com/#/apis), Auth0 will not return a Refresh Token for the API (even if you include the `offline_access` scope in your request).\n\nRules will run for the refresh token exchange. To execute special logic, you can look at the `context.protocol` property in your rule. If the value is `oauth2-refresh-token`, then the rule is running during the exchange.\n\nWhen trying to get a refresh token, the audience parameter is not available on the Rules context object. If you receive an error when attempting to add the audience parameter, verify that you do not have it set on the token.\n\nIf you try to do a redirect with `context.redirect`, the authentication flow will return an error.\n\nIf you have added custom claims to your tokens using a rule, the custom claims will appear in new tokens issued when using a refresh token for as long as your rule is in place. Although new tokens do not automatically inherit custom claims, rules run during the refresh token flow, so the same code will be executed. This allows you to add or change custom claims in newly-issued tokens without forcing previously-authorized applications to obtain a new refresh token.\n\n### Refresh token limits\n\nAuth0 limits the amount of active refresh tokens to 200 tokens per user per application. This limit only applies to active tokens. If the limit is reached and a new refresh token is created, the system revokes and deletes the oldest token for that user and application. Revoked tokens and expired tokens do not count against the limit.\n\n#### Automated tests\n\nRefresh tokens accumulate due to automated tests and are generally used for the test lifetime. To avoid a token stockpile subject to refresh token limits, you can use the Auth0 Management API to remove unnecessary refresh tokens.\n\n1.  [Create a user](https://auth0.com/docs/api/management/v2#!/Users/post_users) with Management API. You will use this user for testing.\n    \n2.  The response returns a `user_id` that you need to persist during tests to be used later.\n    \n3.  Once tests are complete, [delete the user](https://auth0.com/docs/api/management/v2#!/Users/delete_users_by_id) through Management API. When the test user is deleted, the associated artifacts are also removed, including refresh tokens.\n    \n\nIf you want to keep the test user for future testing:\n\n1.  List the user’s refresh tokens using [Management API's device credential endpoint](https://auth0.com/docs/api/management/v2#!/Device_Credentials/get_device_credentials). The endpoint will return a maximum of 1000 tokens without specific order regardless of accumulated tokens or the use of pagination.\n    \n2.  Delete those credentials [using the DELETE](https://auth0.com/docs/api/management/v2#!/Device_Credentials/delete_device_credentials_by_id) method.\n    \n3.  If the user has more than 1k tokens, repeat listing and deleting tokens until no more tokens left for the user.\n    \n\n#### Configure Expiring Refresh Tokens\n\nWhen users log into your application with Auth0, and when the `offline_access` is requested in the authorization request, a new refresh token is issued to the user. In the case users log out and in again with the same device, a new refresh token is issued. Depending on how your application stores and uses refresh tokens, the old refresh token from the first login might become obsolete, and your application will most likely use the new refresh tokens if both tokens are issued with the same audience. To learn more, read [Token Storage](https://auth0.com/docs/secure/security-guidance/data-security/token-storage).\n\nTo avoid accumulating obsolete refresh tokens, even though the refresh token limit removes the oldest token first, we recommend you configure refresh token expiration. Both rotating and non-rotating (or reusable) refresh tokens can be configured to expire with either idle or absolute expiry values. Both expiration values help remove tokens that are not in active use and avoid accumulating tokens for the user. To learn more, read [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration).\n\n## JWT validation\n\nWe strongly recommend that you use middleware or one of the existing open source third-party libraries to parse and validate JWTs. At [JWT.io](https://jwt.io/#libraries-io), you can find libraries for various platforms and languages, such as .NET, Python, Java, Ruby, Objective-C, Swift, and PHP.\n\n## Signing algorithms\n\nThe algorithm used to sign tokens issued for your application or API. A signature is part of a JWT and is used to verify that the sender of the token is who it says it is and to ensure that the message wasn't changed along the way. To learn more about JWTs, read [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens). To learn more about signatures, read [JSON Web Token Structure](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure).\n\nYou can select from the following signing algorithms:\n\n*   **RS256** (RSA Signature with SHA-256): An asymmetric algorithm, which means that there are two keys: one public key and one private key that must be kept secret. Auth0 has the private key used to generate the signature, and the consumer of the JWT retrieves a public key from the Metadata endpoints provided by Auth0 and uses it to [validate the JWT signature](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens).\n    \n*   **HS256** (HMAC with SHA-256): A symmetric algorithm, which means that there is only one private key that must be kept secret, and it is shared between the two parties. Since the same key is used both to generate the signature and to validate it, care must be taken to ensure that the key is not compromised. This private key (or secret) is created when you register your Application (**Client Secret**) or API (**Signing Secret**) and choose the HS256 signing algorithm.\n    \n\nThe most secure practice, and our recommendation, is to use **RS256** because:\n\n*   With RS256, you are sure that only the holder of the private key (Auth0) can sign tokens, while anyone can check if the token is valid using the public key.\n    \n*   With RS256, you can request a token that is valid for multiple audiences.\n    \n*   With RS256, if the private key is compromised, you can implement key rotation without having to re-deploy your application or API with the new secret (which you would have to do if using HS256).\n    \n*   With HS256, if the secret key is compromised you would have to redeploy the API with the new secret.\n    \n\n## Signing keys\n\nIt's good practice to assume that multiple signing keys could be present in your JWKS. This may seem unnecessary since the Auth0 JWKS endpoint typically contains a single signing key; however, multiple keys can be found in the JWKS when rotating signing certificates.\n\nWe recommend that you cache your signing keys to improve application performance and avoid running into rate limits, but you will want to make sure that if decoding a token fails, you invalidate the cache and retrieve new signing keys before trying **only one** more time.\n\n## Learn more\n\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Token Storage](https://auth0.com/docs/secure/security-guidance/data-security/token-storage)",
  "title": "Token Best Practices",
  "description": "Lists best practices when using tokens in authentication and authorization.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-tokens",
  "markdown": "# Use Refresh Tokens\n\nRefresh tokens are used to request a new access token and/or ID token for a user without requiring them to re-authenticate.\n\nTypically, you should request a new access token before the previous one expires (to avoid any service interruption), but not every time you call an API, as token exchanges are subject to our [Rate Limiting Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy).\n\nYou may also use a refresh token to request a new ID token for a user, and should do so if you need to refresh the claims within the ID token.\n\n## Call the API\n\nTo exchange the refresh token you received during authentication for a new access token, call the Auth0 Authentication API [Get token endpoint](https://auth0.com/docs/api/authentication#refresh-token) in the Authentication API.\n\nTo learn more about the authentication methods available for the Authentication API, read [Authentication Methods](https://auth0.com/docs/api/authentication#authentication-methods).\n\n### Use Basic authentication\n\n*   [cURL](#f967c9c28e964235a8b695985774dbb8_shell)\n*   [C#](#f967c9c28e964235a8b695985774dbb8_csharp)\n*   [Go](#f967c9c28e964235a8b695985774dbb8_go)\n*   [Java](#f967c9c28e964235a8b695985774dbb8_java)\n*   [Node.JS](#f967c9c28e964235a8b695985774dbb8_node)\n*   [Obj-C](#f967c9c28e964235a8b695985774dbb8_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'authorization: Basic {yourApplicationCredentials}' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=refresh_token \\\n  --data 'client_id={yourClientId}' \\\n  --data 'refresh_token={yourRefreshToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddHeader(\"authorization\", \"Basic {yourApplicationCredentials}\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Add(\"authorization\", \"Basic {yourApplicationCredentials}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .header(\"authorization\", \"Basic {yourApplicationCredentials}\")\n  .body(\"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {\n    'content-type': 'application/x-www-form-urlencoded',\n    authorization: 'Basic {yourApplicationCredentials}'\n  },\n  data: new URLSearchParams({\n    grant_type: 'refresh_token',\n    client_id: '{yourClientId}',\n    refresh_token: '{yourRefreshToken}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\",\n                           @\"authorization\": @\"Basic {yourApplicationCredentials}\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=refresh_token\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&refresh_token={yourRefreshToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Basic {yourApplicationCredentials}\",\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\"\n\nheaders = {\n    'content-type': \"application/x-www-form-urlencoded\",\n    'authorization': \"Basic {yourApplicationCredentials}\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest[\"authorization\"] = 'Basic {yourApplicationCredentials}'\nrequest.body = \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/x-www-form-urlencoded\",\n  \"authorization\": \"Basic {yourApplicationCredentials}\"\n]\n\nlet postData = NSMutableData(data: \"grant_type=refresh_token\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&refresh_token={yourRefreshToken}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Use Post authentication\n\n*   [cURL](#2f90907e172e4805836ab4ada4b2ffa5_shell)\n*   [C#](#2f90907e172e4805836ab4ada4b2ffa5_csharp)\n*   [Go](#2f90907e172e4805836ab4ada4b2ffa5_go)\n*   [Java](#2f90907e172e4805836ab4ada4b2ffa5_java)\n*   [Node.JS](#2f90907e172e4805836ab4ada4b2ffa5_node)\n*   [Obj-C](#2f90907e172e4805836ab4ada4b2ffa5_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=refresh_token \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'refresh_token={yourRefreshToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=refresh_token&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&refresh_token=%7ByourRefreshToken%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=refresh_token&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&refresh_token=%7ByourRefreshToken%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=refresh_token&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&refresh_token=%7ByourRefreshToken%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'refresh_token',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    refresh_token: '{yourRefreshToken}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=refresh_token\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&refresh_token={yourRefreshToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=refresh_token&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&refresh_token=%7ByourRefreshToken%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=refresh_token&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&refresh_token=%7ByourRefreshToken%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=refresh_token&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&refresh_token=%7ByourRefreshToken%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=refresh_token\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&refresh_token={yourRefreshToken}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Parameter definition\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `grant_type` | Type of grant to execute. |\n| `client_id` | Application's client ID. |\n| `client_secret` | (Optional) Application's client secret. Only required for confidential applications using the Post token authentication method. |\n| `refresh_token` | Refresh token to exchange. |\n\nThe response will include a new access token, its type, its lifetime (in seconds), and the granted scopes. If the scope of the initial token included `openid`, then a new ID token will be in the response as well.\n\n```\n{\n      \"access_token\": \"eyJ...MoQ\",\n      \"expires_in\": 86400,\n      \"scope\": \"openid offline_access\",\n      \"id_token\": \"eyJ...0NE\",\n      \"token_type\": \"Bearer\"\n    }\n```\n\n## Bypass MFA\n\nIf [Multi-factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) is enabled and refresh token functions fail, you can use the following workaround:\n\n```\nfunction (user, context, callback) {\n  if (context.protocol === 'oauth2-refresh-token'){\n    return callback(null, user, context);\n  }\n\n  // Add MFA logic\n\n  callback(null, user, context);\n}\n```\n\n## Learn more\n\n*   [Get Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/get-refresh-tokens)\n*   [Revoke Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens)\n*   [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)\n*   [Lock.Android: Refresh JSON Web Tokens](https://auth0.com/docs/libraries/lock-android/lock-android-refresh-jwt)",
  "title": "Use Refresh Tokens",
  "description": "Describes how to use a Refresh Token you received during authorization.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration",
  "markdown": "# Configure Refresh Token Expiration\n\nRefresh tokens can be a target for abuse if leaked because they can be used to acquire new access tokens. To mitigate this risk, Auth0 recommends using Automatic Reuse Detection and Refresh Token Rotation. Refresh Token Rotation issues a refresh token that expires after a preset lifetime. After expiration, the user gets a new refresh token in the same family, or refresh tokens that share a family ID, or a new access token/refresh token pair. To learn more, read [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation).\n\nYou can enable and configure two refresh token lifetime settings, absolute and inactivity expiration, using either the Auth0 Dashboard or the Auth0 Management API. You can use a combination of absolute and inactivity expiration periods to create a balance between security and user experience that suits your business needs.\n\n*   **Absolute Lifetime**: Set a refresh token or refresh token family lifetime after which the user must re-authenticate before being issued a new access token. If you disable this setting, the absolute lifetime will be indefinite.\n    \n*   **Inactivity Lifetime**: Set the inactivity lifetime of issued refresh tokens to expire if the user is not active in your application during a specified period.\n    \n\n## Use the Dashboard\n\n1.  Go to [Dashboard > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Select the application you want to configure.\n    \n3.  Go to the **Settings** tab.\n    \n4.  Under **Refresh Token Expiration**, enable **Absolute Expiration**. When enabled, a refresh token will expire based on an absolute lifetime, after which the token can no longer be used. If rotation is enabled, an expiration lifetime must be set.\n    \n    ![Dashboard Applications Applications Settings Tab Refresh Token Expiration](https://images.ctfassets.net/cdy7uua7fh8z/2EnpIEc4kBxjnS3T67xPzC/22af4a1d7fbc26a9bfbd4785ff8cb1a3/dashboard-applications-applications-settings-refresh-token-expiration.png)\n5.  Enter **Absolute Lifetime** in seconds. The refresh token expires after the specified interval and can no longer be used to get a new access token. When rotation is enabled, the absolute expiration also applies to the ability to get new tokens.\n    \n    |     | **Value** |\n    | --- | --- |\n    | Default | 2,592,000 seconds (30 days) |\n    | Minimum | 1 second |\n    | Maximum | 31,557,600 seconds (1 year) |\n    \n6.  Enable **Inactivity Expiration**. When enabled, a refresh token will expire based on a specified inactivity lifetime, after which the token can no longer be used.\n    \n7.  Enter **Inactivity Lifetime** in seconds. If the refresh token is not exchanged within the specified interval, the refresh token expires and can no longer be used to get a new access token. The expiration period is renewed each time the refresh token is exchanged for a new access token within the interval.\n    \n    |     | **Value** |\n    | --- | --- |\n    | Minimum | 1 second |\n    | Maximum | 31,557,600 seconds (1 year) |\n    \n8.  Click **Save Changes**.\n    \n\n## Use the Management API\n\nYou can configure the absolute and inactivity lifetime settings in the payload for the Management API [/api/v2/clients/{id}](https://auth0.com/docs/api/management/v2#!/Clients/patch_clients_by_id) endpoint. Here is an example that sets expiration lifetime for a non-rotating refresh token:\n\n```\nPATCH /api/v2/clients/{id}\n{\n  \"refresh_token\": {\n      \"rotation_type\": \"non-rotating\",\n      \"expiration_type\": \"expiring\",\n      \"token_lifetime\": 2592000,\n      \"infinite_token_lifetime\": false,\n      \"idle_token_lifetime\": 604800,\n      \"infinite_idle_token_lifetime\": false\n  }\n}\n```\n\n## Support and limitations\n\n*   You can opt-in to use refresh token expiration capabilities; no action is required by you. Existing refresh tokens are not affected.\n    \n*   If need to go above the 1 year limitation (up to 5 years), Auth0 can increase the limit for you. Contact your Auth0 Technical Account Manager for details.\n    \n*   Refresh token expiration works with the following flows:\n    \n    *   [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)\n        \n    *   [Authorization Code Flow with Proof Key for Code Exchange](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)\n        \n    *   [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)[](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n        \n    *   [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n        \n*   All Auth0 SDKs support refresh token expiration.\n    \n*   The refresh token expiration feature complies with the [OAuth 2.0 Security BCP recommendations](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-16.html#section-4.13.2).\n    \n\n## Learn more\n\n*   [Get Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/get-refresh-tokens)\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Configure Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation)\n*   [Revoke Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens)",
  "title": "Configure Refresh Token Expiration",
  "description": "Learn how to configure the refresh token expiration lifetimes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-token-rotation",
  "markdown": "# Use Refresh Token Rotation\n\nTo use refresh token rotation, you will use the Auth0 Single Page App SDK. The Auth0 SPA SDK handles token storage, session management, and other details for you.\n\n## Prerequisite\n\n[Configure refresh token rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation) to enable offline access and request the offline access scope in the client SDK.\n\n## Enable useRefreshTokens\n\nIn compliance with the OAuth2 specifications, when a browser requests a refresh token from the /token endpoint, Auth0 will only return a refresh token if Refresh Token Rotation is enabled for that client.\n\nUse the option `useRefreshTokens` on `createAuth0Client` which defaults to `false`. With this option set to `false`, when `getTokenSilently()` is invoked and a new Access Token is required, the SDK attempts to acquire a new Access Token using a hidden iframe and `prompt=none`.\n\nIf you set to this option to `true`, the `offline_access` scope is automatically requested when using `loginWithRedirect(), loginWithPopup()` and `getTokenSilently()`. When `getTokenSilently()` is invoked and the Access Token has expired, the SDK attempts to renew the ID and Access Tokens by calling the `/token` endpoint using the `refresh_token` grant type along with the Refresh Token from the cache.\n\nSilent re-authentication is achieved by sending a `prompt=none` parameter upon the authentication request and using a hidden iframe, provided that there is an active user session on the authorization server. The SDK uses the iframe method if you have set `useRefreshTokens` to `true` but no Refresh Token is available in the cache. This helps users to silently migrate to using Refresh Tokens without making them log in again.\n\nIf the exchange fails because `useRefreshTokens` is `true` but there isn't a Refresh Token in the cache, then it falls back to the iframe method (which could also fail if third-party cookies are blocked).\n\n## Token storage\n\nWith SPAs, ID and Access Tokens are obtained from the authorization server and typically cached in memory. Token renewal (due to refreshing the browser, memory cache eviction budgets, or expiration) is handled by the SDK.\n\n## Example\n\nThe following example shows how to configure the SDK to use both local storage and refresh tokens:\n\n```\nconst auth0 = await createAuth0Client({\n    domain: '<your Auth0 domain>',\n    client_id: '<your Auth0 client ID>',\n    cacheLocation: 'localstorage',\n    useRefreshTokens: true\n    });\n    \n    // Logging-in will automatically request the offline_access scope\n    // and store the resulting refresh token\n    auth0.loginWithRedirect();\n    \n    // Silently refreshing the access token will use the /token endpoint\n    // with ‘refresh_token’ grant and the refresh token from the cache\n    await auth0.getTokenSilently();\n```\n\n## Learn more\n\n*   [Configure Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation)\n*   [Disable Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/disable-refresh-token-rotation)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Use Refresh Token Rotation",
  "description": "Describes how to use Refresh Token rotation for you received during authorization.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation",
  "markdown": "# Configure Refresh Token Rotation\n\nConfigure refresh token rotation for each application using the Dashboard or the [Auth0 SPA SDK](https://auth0.com/docs/libraries/auth0-single-page-app-sdk). When refresh token rotation is enabled, the transition for the user is seamless. The application uses the previous, unexpired non-rotating refresh token and swaps it for a rotating refresh token.\n\nMigration scenarios accommodate automatic token revocation when migrating from a non-rotating refresh token to a rotating refresh token and vice-versa.\n\n*   Exchanging a non-rotating refresh token when refresh token rotation is enabled deletes all the non-rotating tokens issued for the same `client_id`, resource server, and user and tenant.\n    \n*   Exchanging a rotating refresh token when refresh token rotation is disabled issues a non-rotating refresh token and revokes the rotating refresh token family issued for the same `client_id`, resource server, and user and tenant.\n    \n\n## Configure in the Dashboard\n\n1.  Go to [Dashboard > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Select the application you want to configure.\n    \n3.  Go to the **Settings** tab.\n    \n4.  Under **Refresh Token Rotation**, enable **Rotation**.\n    \n    ![Dashboard Applications Applications Settings Tab Refresh Token Rotation](https://images.ctfassets.net/cdy7uua7fh8z/Rk6i8MUVWZG34P7K6aurb/c1906bf4e4066a26965e012b61237af3/dashboard-applications-applications-settings-refresh-token-rotation.png)\n5.  Enter **Reuse Interval** (in seconds) for the refresh token to account for leeway time between request and response before triggering automatic reuse detection. This interval helps to avoid concurrency issues when exchanging the rotating refresh token multiple times within a given timeframe. During the leeway window the breach detection features don't apply and a new rotating refresh token is issued. Only the previous token can be reused; if the second-to-last one is exchanged, breach detection will be triggered.\n    \n6.  Click **Save Changes**.\n    \n\n## Configure with the Auth0 SPA SDK\n\nYou can use the Auth0 SPA SDK to enable refresh token rotation. You must enable offline access and request the offline access scope in the client SDK.\n\n1.  Install the latest version of the `auth0-spa-js` SDK: `npm install @auth0/auth0-spa-js`\n    \n2.  Enable the feature on the SDK by setting `useRefreshTokens: true` to start sending the `offline_access` scope.\n    \n    to configure this snippet with your account\n    \n    ```\n    const auth0 = await createAuth0Client({\n          domain: '{yourDomain}',\n          client_id: '{yourClientId}',\n          audience: '{yourApiIdentifier}',\n          useRefreshTokens: true\n        });\n    ```\n    \n3.  Configure the Refresh Token rotation settings. For example:\n    \n    ```\n    PATCH /api/v2/clients/{client_id}\n        {\n          \"refresh_token\": {\n            \"rotation_type\": \"rotating\",\n            \"expiration_type\": \"expiring\",\n            \"token_lifetime\": \"2592000\",\n            \"leeway\": 3\n          }\n        }\n    ```\n    \n    | **Attribute** | **Description** |\n    | --- | --- |\n    | `rotation_type` | Text string: \"rotating\" or \"non-rotating\" |\n    | `expiration_type` | Text string: \"expiring\" or \"non-expiring\" |\n    | `token_lifetime` | The default refresh token expiration period, when **Refresh Token Rotation** is enabled, is 30 days (2,592,000 seconds). You can configure up to 1 year (31,557,600 seconds). **The lifetime does not extend when tokens are rotated.** |\n    | `leeway` | Allow the same refresh token to be used within the time period to account for potential network concurrency issues that would otherwise invalidate the token should the client attempt to retry using the same refresh token. By default leeway is disabled. Configurable in seconds. |\n    \n\n## Automatic reuse detection\n\nIf a previously invalidated token is used, the entire set of refresh tokens issued since that invalidated token was issued will immediately be revoked along with the grant, requiring the user to re-authenticate.\n\n## Learn more\n\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Use Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-token-rotation)\n*   [Disable Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/disable-refresh-token-rotation)",
  "title": "Configure Refresh Token Rotation",
  "description": "Describes how to configure refresh token rotation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation",
  "markdown": "# Refresh Token Rotation\n\nRefresh token rotation is a technique for getting new access tokens using refresh tokens that goes beyond [silent authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication). Refresh tokens are typically longer-lived and can be used to request new access tokens after the shorter-lived access tokens expire. Refresh tokens are often used in native applications on mobile devices in conjunction with short-lived access tokens to provide seamless UX without having to issue long-lived access tokens.\n\nWith refresh token rotation enabled in the Auth0 Dashboard, every time an application exchanges a refresh token to get a new access token, a new refresh token is also returned. Therefore, you no longer have a long-lived refresh token that, if compromised, could provide illegitimate access to resources. As refresh tokens are continually exchanged and invalidated, the threat is reduced.\n\nThe way refresh token rotation works in Auth0 conforms with the [OAuth 2.0 BCP](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-4.12) and works with the following flows:\n\n*   [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)\n    \n*   [Authorization Code Flow with Proof Key for Code Exchange](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)\n    \n*   [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)\n    \n*   [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n    \n\n## Maintain user sessions in SPAs\n\nUntil very recently, SPAs maintained the user’s session by using the Authorization Code Flow with PKCE in conjunction with silent authentication. Recent developments in browser privacy technology, such as Intelligent Tracking Prevention (ITP) prevent access to the Auth0 session cookie, thereby requiring users to reauthenticate.\n\n![Refresh Token Rotation Maintain User Sessions in SPAs diagram](https://images.ctfassets.net/cdy7uua7fh8z/3sf7RRsy81bt3zcXMnHUSe/2171fdab4ffeb0987c329aa897038abc/rt-and-at.png)\n\nUnfortunately, long-lived refresh tokens are not suitable for SPAs because there is no persistent storage mechanism in a browser that can assure access by the intended application only. As there are vulnerabilities that can be exploited to obtain these high-value artifacts and grant malicious actors access to protected resources, using refresh tokens in SPAs has been strongly discouraged.\n\nRefresh token rotation offers a remediation to end-user sessions being lost due to side-effects of browser privacy mechanisms. Because refresh token rotation does not rely on access to the Auth0 session cookie, it is not affected by ITP or similar mechanisms.\n\nThe following state diagram illustrates how refresh token rotation is used in conjunction with the Authorization Code Flow with PKCE, but the general principle of getting a new refresh token with each exchange applies to all supported flows.\n\n![Refresh Token Rotation Maintain User Sessions in SPAs State diagram](https://images.ctfassets.net/cdy7uua7fh8z/41avsR2u0B4fSP3Bwh0WZz/d803a9057ea6e606d602c7c97d99fc3a/rtr-state-diagram.png)\n\nThis means you can safely use refresh tokens to mitigate the adverse effects of browser privacy tools and provide continuous access to end-users without disrupting the user experience.\n\n## Automatic reuse detection\n\nWhen a client needs a new access token, it sends the refresh token with the request to Auth0 to get a new token pair. As soon as the new pair is issued by Auth0, the refresh token used in the request is invalidated. This safeguards your app from replay attacks resulting from compromised tokens.\n\nWithout enforcing sender-constraint, it’s impossible for the authorization server to know which actor is legitimate or malicious in the event of a replay attack. So it’s important that the most recently issued refresh token is also immediately invalidated when a previously-used refresh token (already invalidated) is sent to the authorization server. This prevents any refresh tokens in the same token family (all refresh tokens descending from the original refresh token issued for the client) from being used to get new access tokens.\n\nFor example, consider the following scenario:\n\n![Refresh Token Rotation Reuse Detection state diagram](https://images.ctfassets.net/cdy7uua7fh8z/33fe73R81Cpm6eTmOWfAnm/e7d168edc27861507a121910b32f1ee2/reuse-detection1.png)\n\n1.  Legitimate Client has **refresh token 1**, and it is leaked to or stolen by Malicious Client.\n    \n2.  Legitimate Client uses **refresh token 1** to get a new refresh token/access token pair.\n    \n3.  Auth0 returns **refresh token 2/access token 2**.\n    \n4.  Malicious Client then attempts to use **refresh token 1** to get an access token. Auth0 recognizes that refresh token 1 is being reused, and immediately invalidates the refresh token family, including **refresh token 2**.\n    \n5.  Auth0 returns an access denied response to Malicious Client.\n    \n6.  **Access token 2** expires and Legitimate Client attempts to use **refresh token 2** to request a new token pair. Auth0 returns an access denied response to Legitimate Client.\n    \n7.  Re-authentication is required.\n    \n\nThis protection mechanism works regardless of whether the legitimate client or the malicious client is able to exchange **refresh token 1** for a new token pair before the other. As soon as reuse is detected, all subsequent requests will be denied until the user re-authenticates. When reuse is detected, Auth0 captures detected reuse [events](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes) (such as `ferrt` indicating a failed exchange) in logs. This can be especially useful in conjunction with Auth0’s [log streaming](https://auth0.com/docs/customize/log-streams) capabilities to detect suspicious activity.\n\nAnother example is where the malicious client steals **refresh token 1** and successfully uses it to acquire an access token before the legitimate client attempts to use **refresh token 1**. In this case, the malicious client’s access would be short-lived because **refresh token 2** (or any subsequently issued refresh tokens) is automatically revoked when the legitimate client tries to use **refresh token 1**, as shown in the following diagram:\n\n![Refresh Token Rotation Reuse Detection State diagram](https://images.ctfassets.net/cdy7uua7fh8z/36rAUgLOAqW7k7Fdl1eRN1/c1a57be5093416b50d42ec41a1e3a233/reuse-detection2.png)\n\n## SDK support\n\nThe following SDKs include support for refresh token rotation and automatic reuse detection.\n\n*   Auth0 SPA SDK\n    \n*   Flutter (Web)\n    \n*   Swift (iOS) SDK\n    \n*   Android SDK\n    \n*   Flutter\n    \n*   React Native SDK\n    \n*   WPF / Winforms\n    \n*   Xamarin\n    \n\nFor documentation specific to these SDKs, visit the [Auth0 SDK Libraries](https://auth0.com/docs/libraries) page.\n\nYou can choose to store tokens in either local storage or browser memory. The default is in browser memory. See [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices) for recommendations about token storage. You must enable offline access and request the offline access scope in the client SDK.\n\n## Learn more\n\n*   [Configure Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation)\n*   [Disable Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/disable-refresh-token-rotation)\n*   [Configure Refresh Token Expiration](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-expiration)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Refresh Token Rotation",
  "description": "Describes how refresh token rotation provides greater security by issuing a new refresh token with each request made to Auth0 for a new access token by a client using refresh tokens.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/refresh-tokens/disable-refresh-token-rotation",
  "markdown": "# Disable Refresh Token Rotation\n\nYou can disable refresh token rotation for each application using Dashboard or the Management API.\n\n## Disable with the Dashboard\n\n1.  Go to [Dashboard > Application Settings](https://manage.auth0.com/#/applications) and scroll to the **Application Tokens** section.\n    \n2.  Next to **Refresh Token Behavior** select **Non-Rotating**.\n    \n    ![Disable Refresh Token Rotation Screen](https://images.ctfassets.net/cdy7uua7fh8z/2XKvvu388Zp3SEmzB62ecZ/b1c9eebba8a1906bc3ba877d34420afb/non-rotating-tokens.png)\n3.  Click **Save Changes**.\n    \n\n## Disable with the Management API\n\n1.  Disable refresh token rotation for each application using the Management API:\n    \n    to configure this snippet with your account\n    \n    ```\n    const auth0 = await createAuth0Client({\n          domain: '{yourDomain}',\n          client_id: '{yourClientId}',\n          audience: '{yourApiIdentifier}',\n          useRefreshTokens: false\n        });\n    ```\n    \n2.  Configure the non-rotating refresh token settings as follows:\n    \n    ```\n    PATCH /api/v2/clients/{client_id}\n        {\n          \"refresh_token\": {\n        \"rotation_type\": \"non-rotating\",\n        \"expiration_type\": \"non-expiring\"\n          }\n        }\n    ```\n    \n\n## Learn more\n\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Configure Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation)\n*   [Use Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/use-refresh-token-rotation)",
  "title": "Disable Refresh Token Rotation",
  "description": "Describes how to disable Refresh Token rotation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/apis/api-settings",
  "markdown": "# API Settings\n\nUse the **Settings** tab in the Auth0 Dashboard at [Dashboard > Applications > APIs](https://manage.auth0.com/#/apis) to configure registered APIs that you can consume from your authorized applications. To configure an API's settings, click **...** next to an API in the list and select **Settings** or click the API name. To learn how to create and register an API, read [Register APIs](https://auth0.com/docs/get-started/auth0-overview/set-up-apis).\n\n![Dashboard Applications APIs List](https://images.ctfassets.net/cdy7uua7fh8z/3rhmhghYZDSi6YWHRA5yMQ/c71340259481b0b6787d5f3887cfda0f/dashboard-apis-list.png)\n\n## Settings\n\nUse the settings on this tab to configure token expiration, role-based access control (RBAC), and other access settings. Click **Save** at the bottom of the tab to save changes.\n\n### General Settings\n\nThese fields were set when you initially registered the API, except in the case of the Auth0 Management API. You can only modify the **Name**.\n\n![Dashboard Applications APIs Settings Tab General Settings](https://images.ctfassets.net/cdy7uua7fh8z/QCaXd3FSeP6SYqLfEJWBr/dc2c25654b56bef198dc7d9e6da0d264/dashboard-applications-apis-settings-general-settings.png)\n\n*   **Id**: A unique alphanumeric string generated by Auth0. This information is read-only, and you will only need it if you will be working directly with [Auth0's Management API Resource Servers endpoints](https://auth0.com/docs/api/management/v2#!/Resource_Servers/get_resource_servers_by_id).\n    \n*   **Name**: A friendly name for the API. Does not affect any functionality. The following characters are not allowed: `< >`.\n    \n*   **Identifier**: A unique identifier for your API. This value is set upon API creation and cannot be modified afterward. We recommend using a URL, but this doesn't have to be a publicly available URL; Auth0 will not call your API at all.\n    \n\n### Token Settings\n\n![Dashboard - API - Token Settings - Expiration](https://images.ctfassets.net/cdy7uua7fh8z/2FFfqqmntXL9CnGrSxea9M/810e5542553168ffcd6081a10bc2db2f/image2.png)\n\n*   **Maximum Access Token Lifetime (Seconds)**: The amount of time (in seconds) before an access token expires. The default value is 86400 seconds (24 hours). The maximum value you can set is 2592000 seconds (30 days).\n    \n*   **Implicit / Hybrid Flow Access Token Lifetime (Seconds)**: The amount of time (in seconds) before an access token issued using an implicit or hybrid flow expires. The default value is 86400 seconds (24 hours). The value cannot exceed the maximum access token lifetime.\n    \n*   **JSON Web Token (JWT) Profile**: The profile determines the format of the access tokens issued for the API. The available values are `Auth0` and `RFC 9068`. To learn more, read [Access Token Profiles](https://auth0.com/docs/secure/tokens/access-tokens/access-token-profiles).\n    \n*   **JSON Web Token (JWT) Signing Algorithm**: The algorithm with which to sign the tokens. The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way. The available values are [`HS256`](https://en.wikipedia.org/wiki/Symmetric-key_algorithm) and [`RS256`](https://en.wikipedia.org/wiki/Public-key_cryptography). If you select `RS256` (recommended), the token will be signed with your tenant's private key. This value is set when your API is created and cannot be modified afterward. To learn more about signing algorithms and how they work in Auth0, read [Signing Algorithms](https://auth0.com/docs/get-started/applications/signing-algorithms).\n    \n*   **JSON Web Encryption (JWE):** When enabled, issued access tokens are encrypted using JSON Web Encryption (JWE). format. To learn more, read [JSON Web Encryption](https://auth0.com/docs/secure/tokens/access-tokens/json-web-encryption).\n    \n\n### RBAC Settings\n\n![Auth0 Dashboard API Settings RBAC toggle](https://images.ctfassets.net/cdy7uua7fh8z/65tKb6aj0ktc2qXLUVlV3e/f882509ccdf0c0edf8616d57299092f6/dashboard-apis-edit_view-settings_rbac-settings.png)\n\n*   **Enable RBAC**: Enable this setting for RBAC policies to be enforced for the API. To learn more, read [Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/rbac) and [Enable Role-Based Access Control for APIs](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis). For troubleshooting help, review [Troubleshoot Role-Based Access Control and Authorization](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-rbac-authorization).\n    \n*   **Add Permissions in the Access Token**: Enable this setting to add the Permissions claim to the access token. This setting is only available if you enable RBAC. You can configure permissions on the **Permissions** tab.\n    \n\n### Access Settings\n\n![Dashboard Applications APIs Settings Tab Access Settings](https://images.ctfassets.net/cdy7uua7fh8z/JNlWACqoyfmpE89JwWLKy/9b8953a5e415b07fd49ac5fa51dd2ea0/dashboard-applications-apis-settings-access-settings.png)\n\n*   **Allow Skipping User Consent**: Enable this setting for the API to skip user consent for applications flagged as \"first party.\"\n    \n*   **Allow Offline Access**: Enable this setting to allow applications to ask for refresh tokens for the API.\n    \n\n## Permissions\n\nUse the settings on the **Permissions** tab to define the permissions (scopes) that the API will use. To learn more, read [Add API Permissions](https://auth0.com/docs/get-started/apis/add-api-permissions) and [Delete API Permissions](https://auth0.com/docs/get-started/apis/delete-api-permissions).\n\n![Dashboard Add API Permissions API Define Permissions Screen](https://images.ctfassets.net/cdy7uua7fh8z/32Pb185OFs2mC6z2fmunEw/16cd0e58f892cfed37c31864d0a9356f/dashboard-applications-apis-permissions.png)\n\n## Machine-to-Machine Applications\n\nIf you have machine-to-machine applications, they will appear in a list on this tab. Use the toggles to authorize applications in the list. To learn more, read [Register Machine-to-Machine Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps).\n\n![Dashboard Applications API Machine-to-Machine Applications](https://images.ctfassets.net/cdy7uua7fh8z/7lIxRDYBUf0CxzZkXFZFyI/2023381069429e424d575d200fca572a/dashboard-applications-apis-m2m.png)\n\n## Test\n\nA test application is automatically created by Auth0 to allow to tests with the API. To learn how to create more test machine-to-machine applications for Management API testing, read [Create Machine-to-Machine Applications for Testing](https://auth0.com/docs/get-started/apis/create-m2m-app-test).\n\n![Dashboard Applications APIs Test Tab](https://images.ctfassets.net/cdy7uua7fh8z/iVNH8BQ3GBp90CSJTbArs/4498f598547a7136d96651dfb4a1f1c5/dashboard-applications-apis-test.png)\n\n## Management API Explorer\n\nIf you view the **Settings** for the Auth0 Management API, you will see an additional tab called **API Explorer**.\n\n![Dashboard Applications APIs Management API Explorer](https://images.ctfassets.net/cdy7uua7fh8z/1OSC4OQZkMBQOq9D0PFuHv/a86d888b53536673cc1f60acc0c15b2d/dashboard-applications-apis-api-explorer.png)\n\nFor troubleshooting help, review [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls).\n\n## Learn more\n\n*   [Register APIs](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Signing Algorithms](https://auth0.com/docs/get-started/applications/signing-algorithms)\n*   [API Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes)\n*   [Configure Logical API for Multiple APIs](https://auth0.com/docs/get-started/apis/set-logical-api)\n*   [Create Machine-to-Machine Applications for Testing](https://auth0.com/docs/get-started/apis/create-m2m-app-test)",
  "title": "API Settings",
  "description": "Describes the settings related to APIs available in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/revoke-tokens",
  "markdown": "# Revoke Tokens\n\nOnce issued, access tokens and ID tokens cannot be revoked in the same way as cookies with session IDs for server-side sessions.\n\nAs a result, tokens should be issued for relatively short periods, and then [refreshed](https://auth0.com/docs/secure/tokens/refresh-tokens) periodically if the user remains active.\n\n## Learn more\n\n*   [Revoke Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Revoke Tokens",
  "description": "Describes how to use tokens to control user access.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/access-tokens/update-access-token-lifetime",
  "markdown": "# Update Access Token Lifetime\n\nYou can change the access token lifetime using the Auth0 Dashboard.\n\n## Configure access token lifetime\n\n1.  Go to [Dashboard > Applications > APIs](https://manage.auth0.com/#/apis) and select the name of the API to view.\n    \n    ![Dashboard Applications APIs List](https://images.ctfassets.net/cdy7uua7fh8z/3rhmhghYZDSi6YWHRA5yMQ/c71340259481b0b6787d5f3887cfda0f/dashboard-apis-list.png)\n2.  Locate the **Token Expiration** field under **Token Settings**.\n    \n    ![Dashboard - API - Token Settings - Expiration](https://images.ctfassets.net/cdy7uua7fh8z/2FFfqqmntXL9CnGrSxea9M/810e5542553168ffcd6081a10bc2db2f/image2.png)\n3.  Enter the desired lifetime (in seconds) for access tokens issued for this API.\n    \n    *   Default value is `86,400` seconds (24 hours).\n        \n    *   Maximum value is `2,592,000 seconds` (30 days).\n        \n4.  Select **Save Changes**.\n    \n\n## Token Expiration For Browser Flows\n\nThe **Token Expiration For Browser Flows** field refers to access tokens issued for the API through implicit and hybrid flows and does not cover all flows initiated from browsers.\n\nFor example, the PKCE flow (used in `auth0-js-spa` SDK) can be initiated from the browser, but it references the **Token Expiration** value, not the **Token Expiration For Browser Flows** value.\n\n## Restricted lifetime for MFA access tokens\n\nThe lifetime of access tokens with the `{yourAuth0Domain}/mfa` audience are restricted to `600` seconds (10 minutes) for security reasons and cannot be modified.\n\n## Learn more\n\n*   [Update ID Token Lifetime](https://auth0.com/docs/secure/tokens/id-tokens/update-id-token-lifetime)",
  "title": "Update Access Token Lifetime",
  "description": "Describes how to update the access token lifetime for an API using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/access-tokens/use-access-tokens",
  "markdown": "# Use Access Tokens\n\nAccess tokens are used in token-based authentication to allow an application to access an API. For example, a Calendar application needs access to a Calendar API in the cloud so that it can read the user's scheduled events and create new events.\n\nOnce an application has received an access token, it will include that token as a credential when making API requests. To do so, it should transmit the access token to the API as a **Bearer** credential in an HTTP **Authorization** header.\n\nFor example:\n\n```\nGET /calendar/v1/events\n    Host​: api.example.com\n    \n    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2V4YW1wbGUuYXV0aDAuY29tLyIsImF1ZCI6Imh0dHBzOi8vYXBpLmV4YW1wbGUuY29tL2NhbGFuZGFyL3YxLyIsInN1YiI6InVzcl8xMjMiLCJpYXQiOjE0NTg3ODU3OTYsImV4cCI6MTQ1ODg3MjE5Nn0.CA7eaHjIHz5NxeIJoFK9krqaeZrPLwmMmgI_XiQiIkQ\n```\n\nIn this example, the Access Token is a JWT that decodes to the following claims:\n\n```\n{\n      \"alg\": \"RS256\",\n      \"typ\": \"JWT\"\n    }\n    .\n    {\n      \"iss\": \"https://example.auth0.com/\",\n      \"aud\": \"https://api.example.com/calendar/v1/\",\n      \"sub\": \"usr_123\",\n      \"scope\": \"read write\",\n      \"iat\": 1458785796,\n      \"exp\": 1458872196\n    }\n```\n\nBefore permitting access to the API using this token, the API must [validate the access token](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens).\n\nOnce the Access Token has been successfully validated, the API can be sure that:\n\n*   The token was issued by Auth0.\n    \n*   The token was issued to an application being used by a user with an identifier of `usr_123`.\n    \n*   The user granted the application access to read from and write to their calendar.\n    \n\nThe API can now process the request, allowing the application to read from and write to user `usr_123`'s calendar.\n\n## Learn more\n\n*   [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens)\n*   [Validate Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens)\n*   [Identity Provider Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/identity-provider-access-tokens)\n*   [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens)\n*   [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)",
  "title": "Use Access Tokens",
  "description": "Describes how to use Access Tokens to call APIs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-swift/auth0-swift-save-and-renew-tokens",
  "markdown": "# Auth0.swift: Save and Renew Tokens\n\nWhen an authentication is performed with the `offline_access` scope included, it will return a Refresh Token that can be used to request a new token without asking for credentials again.\n\n## Credentials Manager\n\n[Auth0.swift](https://github.com/auth0/Auth0.swift) provides a utility class to streamline the process of storing and renewing credentials. You can access the `accessToken` or `idToken` properties from the [Credentials](https://github.com/auth0/Auth0.swift/blob/master/Auth0/Credentials.swift) instance. This is the preferred method to manage user credentials.\n\nFirst import the `Auth0` module:\n\n`import Auth0`\n\nNext present the Universal Login page:\n\n```\nlet credentialsManager = CredentialsManager(authentication: Auth0.authentication())\n\nAuth0\n    .webAuth()\n    .scope(\"openid profile offline_access\")\n    .start { result in\n        switch result {\n        case .success(let credentials):\n            // Pass the credentials over to the Credentials Manager\n            credentialsManager.store(credentials: credentials)\n        case .failure(let error):\n            // Handle error\n        }\n}\n```\n\n### Credentials Check\n\nIt can be useful to perform a quick check on app startup to ensure that you have renewable credentials stored in the manager. If not, the user can then be directed to authenticate.\n\n```\nguard credentialsManager.canRenew() else {\n    // Present login page\n}\n```\n\n### Retrieving User Credentials\n\nYou can retrieve the user's credentials as follows:\n\n```\ncredentialsManager.credentials { result in \n    switch result {\n    case .success(let credentials):\n        // Valid credentials; you can access token properties such as\n        // `idToken`, `accessToken`\n    case .failure(let error):\n        // Handle error, present login page\n    }\n}\n```\n\nRenewing a user's credentials works exactly the same way if the token has expired. The Credentials Manager will automatically renew the credentials, store the renewed credentials in the Keychain, then return a `Result` containing either the credentials or an error.\n\n## Alternative Method - SimpleKeychain\n\nThis section is for developers who would prefer not to use the Credentials Manager. We include the SimpleKeychain utility –a light wrapper over the system Keychain– that can be used to store the tokens securely.\n\nFirst import the `SimpleKeychain` module:\n\n`import SimpleKeychain`\n\nNext create an instance and store the tokens you need. In this case, you will store the `access_token` and `refresh_token` in the Keychain after a successful authentication.\n\n```\nlet keychain = SimpleKeychain(service: \"Auth0\")\n\nAuth0\n    .webAuth()\n    .scope(\"openid profile offline_access\")\n    .start { result in\n        switch result {\n        case .success(let credentials):\n            guard let refreshToken = credentials.refreshToken else { \n                // Handle error \n                return\n            }\n            // Store the tokens\n            do {\n                try keychain.set(credentials.accessToken, forKey: \"access_token\")\n                try keychain.set(refreshToken, forKey: \"refresh_token\")\n            } catch {\n                // Handle error\n            }\n            // You might want to route to your app's main flow at this point\n        case .failure(let error):\n            // Handle error\n        }\n}\n```\n\nOnce you have those stored, you can at any point request a fresh [Credentials](https://github.com/auth0/Auth0.swift/blob/master/Auth0/Credentials.swift) instance.\n\n### Renewing User Credentials\n\n```\nlet keychain = SimpleKeychain(service: \"Auth0\")\n\nAuth0\n    .authentication()\n    .renew(withRefreshToken: refreshToken)\n    .start { result in\n        switch(result) {\n        case .success(let credentials):\n            // If you have Refresh Token Rotation enabled, you get a \n            // new refresh token\n            // Otherwise you only get a new access token\n            guard let refreshToken = credentials.refreshToken else { \n                // Handle error \n                return\n            }\n            // Store the new tokens\n            do {\n                try keychain.set(credentials.accessToken, forKey: \"access_token\")\n                try keychain.set(refreshToken, forKey: \"refresh_token\")\n            } catch {\n                // Handle error\n            }\n        case .failure(let error):\n            // Handle error\n        }\n}\n```",
  "title": "Auth0.swift: Save and Renew Tokens",
  "description": "Keeping your user logged in with Auth0.swift",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens",
  "markdown": "# Management API Access Tokens\n\nTo call the [Auth0 Management API v2](https://auth0.com/docs/api/management/v2) endpoints, you need to authenticate with an access token called the Auth0 Management API token. These tokens are [JSON Web Tokens (JWTs)](https://auth0.com/docs/secure/tokens/json-web-tokens) which contain specific grant permissions known as [scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes).\n\n## Get Management API tokens\n\nThe first time you get a Management API token for testing is when you authorize a machine-to-machine application in the Dashboard. Depending on what you are using the Management API for, there are different ways to get Management API tokens:\n\n*   [Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing): You can get a test token [manually](https://manage.auth0.com/#/apis/management/explorer) by following the prompts on the Auth0 dashboard.\n    \n*   [Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production): Auth0 recommends that you get a short-lived token programmatically for production.\n    \n*   [Single page applications (SPAs)](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-tokens-for-single-page-applications): Because SPAs are public clients and cannot securely store sensitive information, they must retrieve Management API tokens from the frontend, unlike other application types. There are some limitations.\n    \n\n## Token lifetime\n\nA Management API token is valid for 24 hours. Create a new access token when the old one expires.\n\n## Token security\n\nWhen using the token for testing purposes, you can change the expiration time, however Auth0 recommends that you use short-lived tokens to minimize security risks. You cannot renew or revoke a Management API token.\n\n*   **Compromised token**: If a token has been compromised, you can delete the application grant to prevent new tokens from being issued using the Management API [`/delete_client_grants_by_id`](https://auth0.com/docs/api/management/v2#!/Client_Grants/delete_client_grants_by_id) endpoint or by manually [deauthorizing the API application](https://manage.auth0.com/#/apis/management/authorized-applications) in the Dashboard.\n    \n*   **Compromised client secret**: If your client secret has been compromised, you can rotate the client secret using the Management API [`/post_rotate_secret`](https://auth0.com/docs/api/management/v2#!/Clients/post_rotate_secret) endpoint or by clicking the **Rotate** icon in the [application's settings](https://manage.auth0.com/#/applications/{yourClientId}/settings) in the Dashboard.\n    \n\n## Token quotas\n\nTokens issued for Auth0 APIs (Management API, Authentication API, MFA API, etc.) do **not** count toward the M2M token quota listed in the Dashboard. Only tokens with external audiences count toward your quota. See [Auth0 Management API Rate Limits](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits) for details.\n\nToken quota limits are broken down by subscription tier. See [Auth0 Pricing](https://auth0.com/pricing/) for details. You can access your current quota in the [Auth0 Support Center](https://support.auth0.com/reports/quota). If you have questions about pricing or quotas, please direct them to our [sales team](https://auth0.com/contact-us).\n\n## Learn more\n\n*   [Get Management API Access Tokens for Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)\n*   [Get Management API Access Tokens for Single-Page Applications](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-tokens-for-single-page-applications)\n*   [Changes in Auth0 Management APIv2 Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/changes-in-auth0-management-apiv2-tokens)\n*   [Migrate to Management API Endpoints with Access Tokens](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-calling-api-with-access-tokens)",
  "title": "Management API Access Tokens",
  "description": "Learn how Auth0 Management APIv2 Access Tokens work and how to use them.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure",
  "markdown": "# JSON Web Token Structure\n\nAll Auth0-issued JWTs have [JSON Web Signatures (JWSs)](https://tools.ietf.org/html/rfc7515), meaning they are signed rather than encrypted. A JWS represents content secured with digital signatures or Message Authentication Codes (MACs) using JSON-based data structures.\n\nA well-formed JWT consists of three concatenated Base64url-encoded strings, separated by dots (`.`):\n\n*   **JOSE Header**: contains metadata about the type of token and the cryptographic algorithms used to secure its contents.\n    \n*   **JWS payload** (set of [claims](https://tools.ietf.org/html/rfc7519#section-4)): contains verifiable security statements, such as the identity of the user and the permissions they are allowed.\n    \n*   **JWS signature**: used to validate that the token is trustworthy and has not been tampered with. When you use a JWT, you **must** [check its signature](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens) before storing and using it.\n    \n\nA JWT typically looks like this:\n\n![JSON Web Token](https://images.ctfassets.net/cdy7uua7fh8z/7FI79jeM55zrNGd6QFdxnc/80a18597f06faf96da649f86560cbeab/encoded-jwt3.png)\n\nTo see for yourself what is inside a JWT, use the [JWT.io Debugger](http://jwt.io/). It allows you to quickly check that a JWT is well formed and to manually inspect the values of the various claims.\n\n![JWT Debugger](https://images.ctfassets.net/cdy7uua7fh8z/5U3Azt2AReuNzNuQqkRs5/9629ab9924a0212b74bee0b8fa88c295/legacy-app-auth-5.png)\n\nJSON object containing the parameters describing the cryptographic operations and parameters employed. The JOSE (JSON Object Signing and Encryption) Header is comprised of a set of Header Parameters that typically consist of a name/value pair: the hashing algorithm being used (e.g., HMAC SHA256 or RSA) and the type of the JWT.\n\n```\n{\n      \"alg\": \"HS256\",\n      \"typ\": \"JWT\"\n    }\n```\n\n## JWS payload\n\nThe payload contains statements about the entity (typically, the user) and additional entity attributes, which are called claims. In this example, our entity is a user.\n\n```\n{\n      \"sub\": \"1234567890\",\n      \"name\": \"John Doe\",\n      \"admin\": true\n    }\n```\n\nWhen working with JWT claims, you should be aware of the different claim types and naming rules.\n\n## JWS signature\n\nThe signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way.\n\nTo create the signature, the Base64-encoded header and payload are taken, along with a secret, and signed with the algorithm specified in the header.\n\nFor example, if you are creating a signature for a token using the HMAC SHA256 algorithm, you would do the following:\n\n```\nHMACSHA256(\n      base64UrlEncode(header) + \".\" +\n      base64UrlEncode(payload),\n      secret)\n```\n\n## Learn more\n\n*   [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims)\n*   [Validate JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens/validate-json-web-tokens)\n*   [JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets)\n*   [JSON Web Key Set Properties](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-set-properties)\n*   [Locate JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/locate-json-web-key-sets)\n*   [Get Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens)",
  "title": "JSON Web Token Structure",
  "description": "Describes how the JSON web tokens with JSON web signatures (JWSs) are structured.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/access-tokens/json-web-encryption",
  "markdown": "# JSON Web Encryption\n\nJSON Web Encryption (JWE) is an [IETF standard](https://datatracker.ietf.org/doc/html/rfc7516) for representing encrypted content using JSON. In Auth0, you can configure APIs to encrypt the details inside an access token using the JWE format. \n\nWhen JWE is used, Auth0 generates a JWT access token containing a set of claims that are signed using JSON Web Signature (JWS). This JWT access token is then encrypted using JWE and serialized using the JWE Compact format. This allows solutions to maintain the confidentiality of data within the access tokens' claims while also ensuring integrity protection using a signature.\n\n#### Generate and validate an access token\n\n[Configure JWE for each API](https://auth0.com/docs/get-started/apis/configure-json-web-encryption). Assuming you have configured the `apiIdentifier` to use JWE, the code sample requests an encrypted access token via the client credentials grant for a machine-to-machine (M2M) application. JWE is available for all grant types supported by Auth0.\n\n```\ncurl -X POST --location \"https://{domain}/oauth/token\" \\\n    -H \"Content-Type: application/x-www-form-urlencoded\" \\\n    -d \"client_id={clientId}&client_secret={clientSecret}&audience={apiIdentifier}&grant_type=client_credentials\"\n```\n\n A successful response contains an encrypted access token:\n\n```\n{\n  \"access_token\": \"eyJ…XAw\",\n  \"expires_in\": 86400,\n  \"token_type\": \"Bearer\"\n}\n```\n\nWhen the access token is used, the resource server must decrypt and validate the JWE token. The JWE token header contains metadata that describes the cryptographic algorithm ([`alg`](https://datatracker.ietf.org/doc/html/rfc7516#section-4.1.1)), the content encryption algorithm ([`enc`](https://datatracker.ietf.org/doc/html/rfc7516#section-4.1.2)), and, if provided when [configuring the API](https://auth0.com/docs/get-started/apis/configure-json-web-encryption), the key id (`kid`) that were used to encrypt the payload. \n\n```\n{\n  …\n  \"alg\": \"A256GCM\",\n  \"enc\": \"RSA-OAEP-256\",\n  \"kid\": \"my-kid\"\n}\n```\n\n \n\nUsing this information, the resource server should be able to decrypt the JWE token. The result is a regular signed JWT, which can be verified using the Auth0’s tenant keys.\n\nTo learn how to configure JWE for your API, read [Configure JSON Web Encryption](https://auth0.com/docs/get-started/apis/configure-json-web-encryption).\n\n## Learn more\n\n*   [Configure JSON Web Encryption (JWE)](https://auth0.com/docs/get-started/apis/configure-json-web-encryption)",
  "title": "JSON Web Encryption",
  "description": "Learn how to encrypt access tokens using JSON Web Encryption. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/access-tokens/token-binding",
  "markdown": "# Token Binding\n\nToken Binding, or sender constraining, enables the binding of access tokens to cryptographic keys, such as a private key. It enforces that only the application that requested the access token can use it to access the associated resource, thus mitigating token theft and replay attacks.\n\nHighly Regulated Identity provides token binding capabilities through [Mutual-TLS Client Certificate-Bound Access Tokens](https://www.rfc-editor.org/rfc/rfc8705), also known as mTLS Token Binding. To learn how to configure a client to support Token Binding, see [Enable Token Binding](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#enable-token-binding).\n\n## How access tokens are bound to a certificate\n\nAfter [configuring your application for mTLS](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client#enable-token-binding), your application can use mutual TLS to request an access token. The authorization server binds the client certificate to the issued access token by including the confirmation claim (cnf) in the access token payload. The cnf contains a hash representing the thumbprint of the client certificate.\n\nThe following code sample represents the payload of a certificate-bound access token:\n\n```\n{\n  \"iss\": \"https://server.example.com\",\n  \"sub\": \"ty.webb@example.com\",\n  \"exp\": 1493726400,\n  \"nbf\": 1493722800,\n  \"cnf\":{\n    \"x5t#S256\": \"bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2\"\n  }\n}\n```\n\n## Token verification\n\nWhen mTLS Token Binding is enabled, access and refresh tokens are constrained to the application that requested them (i.e. the “sender” application). The resource server is responsible for verifying that the client certificate sent in the request has the same thumbprint as the one included in the access/refresh token, otherwise known as proof-of-possession verification.\n\nTo verify that the application is authorized to use the certificate-bound access/refresh token, the resource server must generate the thumbprint of the client certificate used in the request and compare it to the thumbprint in the `cnf` claim. For more information on the format of the `cnf` claim and how to generate the thumbprint of a certificate, see RFC 8705’s section on the [JWT Certificate Thumbprint Confirmation Method](https://www.rfc-editor.org/rfc/rfc8705#name-jwt-certificate-thumbprint-).\n\nIf the application does not send the client certificate in the request, or the thumbprint of the client certificate does not match, the resource server must reject the request using an `HTTP 401` status code and an `invalid_token` error code.\n\nThe following table describes whether issued tokens are sender-constrained based on the mTLS configuration for the [application](https://auth0.com/docs/get-started/applications/configure-mtls/configure-mtls-for-a-client) (OAuth client) and the [API](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-resource-server-for-token-binding) (OAuth resource server). The table covers the following scenarios:\n\n*   The type of audience that was requested: `userinfo` only or a custom audience that may include `userinfo`. \n    \n*   Whether sender constraining is `required` by the client.\n    \n*   Whether sender constraining is configured for the resource server:\n    \n    *   `none`: Sender constraining has not been configured for the resource server. \n        \n    *   `allowed`: Sender constraining has been configured for the resource server by setting mTLS as the sender-constraining method.\n        \n    *   `required`: Sender constraining is required for the resource server, meaning that access tokens must be sender-constrained to an application. Requires a sender-constraining method. \n        \n*   Whether the client application sent a Proof-of-Possession assertion in the token request.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3NRnK4mzW0hBosq9ovUdw1/71ea03b0ef903b97bac3f40db8630377/Screenshot_2024-05-28_at_11.56.40_AM.png)\n\n## Learn more\n\n*   [Configure mTLS Authentication](https://auth0.com/docs/get-started/applications/configure-mtls)",
  "title": "Token Binding",
  "description": "Learn how to use Token Binding to secure access tokens.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/tokens/access-tokens/access-token-profiles",
  "markdown": "# Access Token Profiles\n\nAccess token profiles define the format and claims of access tokens issued for an API. Auth0 supports the following access token profiles, also known as token dialects:\n\n*   Auth0 token profile, or the default access token profile\n    \n*   RFC 9068 token profile, or the access token profile that follows the [IETF JWT Profile for OAuth 2.0 Access Tokens (RFC 9068)](https://datatracker.ietf.org/doc/html/rfc9068)\n    \n\n| **Token Profile** | **Description** | **Token Dialect** |\n| --- | --- | --- |\n| Auth0 token profile | The default token profile. Issues access tokens formatted as a [JSON Web Token (JWT)](https://auth0.com/docs/secure/tokens/json-web-tokens). | The Auth0 token profile is associated with two token dialects:<br><br>*   `access_token`<br>*   `access_token_authz`, or the `access_token` profile with the `permissions` claim included |\n| RFC 9068 token profile | Issues access tokens formatted as a JSON Web Token (JWT) following the [IETF standard](https://datatracker.ietf.org/doc/html/rfc9068) for encoding OAuth 2.0 Access Tokens in JWT format. | The RFC 9068 token profile is associated with two token dialects:<br><br>*   `rfc9068_profile`<br>*   `rfc9068_profile_authz`, or the `rfc9068_profile` profile with the `permissions` claim included |\n\nWhile both access token profiles issue JWTs, the JWTs have [different token formats](#token-profile-differences). Both access token profiles can enable [Role-Based Access Control (RBAC)](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis) and add the permissions claim to the access token. \n\nTo configure the access token profile for an API, read [Configure Access Token Profile](https://auth0.com/docs/get-started/apis/configure-access-token-profile).\n\n### Auth0 profile sample token\n\n```\n{\n  \"iss\": \"https://my-domain.auth0.com/\",\n  \"sub\": \"auth0|123456\",\n  \"aud\": [\n    \"https://example.com/health-api\",\n    \"https://my-domain.auth0.com/userinfo\"\n  ],\n  \"azp\": \"my_client_id\",\n  \"exp\": 1311281970,\n  \"iat\": 1311280970,\n  \"scope\": \"openid profile read:patients read:admin\",\n  \"my_custom_claim\": \"my_custom_value\"\n}\n```\n\n### RFC 9068 profile sample token\n\n```\n{\n  \"iss\": \"https://my-domain.auth0.com/\",\n  \"sub\": \"auth0|123456\",\n  \"aud\": [\n    \"https://example.com/health-api\",\n    \"https://my-domain.auth0.com/userinfo\"\n  ],\n  \"client_id\": \"my_client_id\",\n  \"exp\": 1311281970,\n  \"iat\": 1311280970,\n  \"jti\":\"73WakrfVbNJBaAmhQtEeDv\",\n  \"scope\": \"openid profile read:patients read:admin\",\n  \"my_custom_claim\": \"my_custom_value\"\n}\n```\n\n## Token profile differences\n\nThe Auth0 profile and RFC 9068 profile issue JWTs that have different token formats. The main differences are:\n\n*   The RFC 9068 profile incorporates the `jti` claim, providing a unique identifier for the JWT.\n    \n*   The Auth0 profile uses the `azp` claim to represent the client ID whereas the RFC 9068 profile uses the `client_id` claim.\n    \n*   The RFC 9068 profile does not use the `gty` claim, which is an Auth0-specific claim that represents the authentication flow.\n    \n\n| **Data** | **RFC 9068 Profile** | **Auth0 Profile** |\n| --- | --- | --- |\n| `type` | `at+jwt` | `JWT` |\n| `alg` | Signing algorithm, for example, `RS256` | Signing algorithm, for example, `RS256` |\n\n### Claims\n\n| **Claim** | **Description** | **Present in RFC 9068 Profile** | **Present in Auth0 Profile** | **Sample Claim** |\n| --- | --- | --- | --- | --- |\n| `iss` | Issuer identifier for the Auth0 tenant issuing the access token. | Yes | Yes | Tenant domain: `https://tenant.auth0.com/` |\n| `sub` | The subject claim indicates which user or application the access token was issued for:<br><br>*   For grants where an end user is involved, such as the Authorization Code Flow, the `sub` claim is the `user_id`.<br>*   For Machine-to-Machine applications using the Client Credentials grant where no end user is involved, the `sub` claim is a unique identifier for the application. | Yes | Yes | *   User ID:`auth0\\|6553da60a54af58e29493993`<br>*   Client ID with suffix: `awZfdIir8YFdGZWkvCejDoUb7SjTDicx@clients` |\n| `aud` | The audience claim defines the intended recipient of the access token. | Yes | Yes | `\"https://test-server/api\"` OR `[ \"https://test-server/api\", \"https://test.local.dev.auth0.com/userinfo\" ]` |\n| `client_id` | Client ID of the application that requests the access token. | Yes | No  | Client ID: `K1AUPhZq8mRi0Q0pjhkfu1D7y6KjDQja` |\n| `azp` | Client ID of the application that requests the access token. | No  | Yes | Client ID: `K1AUPhZq8mRi0Q0pjhkfu1D7y6KjDQja` |\n| `exp` | The expiration time on or after which the access token must not be accepted for processing. | Yes | Yes | Epoch timestamp in seconds: `1516238022` |\n| `iat` | Timestamp at which the access token was issued. | Yes | Yes | Epoch timestamp in seconds: `1516239022` |\n| `scope` | Scope of the issued access token. To learn more, read [Scopes](https://auth0.com/docs/get-started/apis/scopes). | Yes | Yes | `\"openid profile offline_access\"` |\n| `jti` | Unique identifier for the access token. | Yes | No  | Unique string identifier: `aBv9njtYfwL4xfPZyEwz9m` |\n| `gty` | [Grant type](https://auth0.com/docs/get-started/applications/application-grant-types) that the application used to request the access token. Only present for `password` and `refresh_token` grant types. | No  | Case-specific | Grant type: `password` |\n| `permissions` | Permissions available to a user or application depending on their role. Included only when the **Enable RBAC** and **Add permissions in the Access Token** settings are enabled for the API. To learn more, read [Enable Role-Based Access Control for APIs.](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis) | Case-specific | Case-specific | `[ \"create:bar\", \"create:foo\", \"read:bar\", \"read:foo\" ]` |\n| `org_id` | Organization ID. Added when a user has authenticated through an Organization. To learn more, read [Work with Tokens and Organizations.](https://auth0.com/docs/manage-users/organizations/using-tokens) | Case-specific | Case-specific | Organization ID: `org_9ybsU1dN2dKfDkBi` |\n| `org_name` | Organization Name. Added when a user has authenticated through an Organization and the **Organization Names in Authentication API** setting is enabled. To learn more, read [Use Organization Names in Authentication API.](https://auth0.com/docs/manage-users/organizations/configure-organizations/use-org-name-authentication-api) | Case-specific | Case-specific | Organization Name: `my_organization` |\n| `authorization_details` | Authorization details used in Rich Authorization Requests (RAR). To learn more, read [Authorization Code Flow with Rich Authorization Requests.](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-rar) | Case-specific | Case-specific | `{ \"type\": \"money_transfer\", \"instructedAmount\": {\"amount\": 2500, \"currency\": \"USD\"}, \"destinationAccount\": \"xxxxxxxxxxx9876\", \"beneficiary\": \"Hanna Herwitz\", }` |\n| `cnf` | Confirmation claim that is supported for [mTLS Token Binding](https://auth0.com/docs/get-started/applications/configure-mtls/set-up-resource-server-for-token-binding). | Case-specific | Case-specific | `{\"x5t#S256\":\"A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0\"}` |\n| Custom claims | Custom claims can be added to access tokens via Actions. To learn more, read [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims). | Case-specific | Case-specific | `\"favorite_color\": “blue”` |",
  "title": "Access Token Profiles",
  "description": "Learn about the access token profiles that Auth0 supports. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/manage-users-using-the-dashboard",
  "markdown": "# Manage Users Using the Dashboard\n\nYou can use the Dashboard to manage your users. To begin, go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users). This is where you create, view, modify, or delete users.\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nBy default, user profile attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable because they are updated from the identity provider each time the user logs in.\n\nTo be able to edit the `name`, `nickname`, `given_name`, `family_name`, or `picture` root attributes on the normalized user profile, you must [configure your connection sync with Auth0](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0) so that user attributes will be updated from the identity provider only on user profile creation. These root attributes will then be available to be edited individually or by bulk imports\n\nTo learn how to manage Auth0 Dashboard access for your team members, read [Manage Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access).\n\n## Learn more\n\n*   [Search for Users](https://auth0.com/docs/manage-users/user-search)\n*   [User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles)\n*   [Import and Export Users](https://auth0.com/docs/manage-users/user-migration)",
  "title": "Manage Users Using the Dashboard",
  "description": "Describes how to manage users in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/verify-emails",
  "markdown": "# Verify Emails using Auth0\n\nWhen using an email address supplied by a user, it is important to verify the user has access to that email. This is true anytime you send an email to a user or if you use email as an index for search. Auth0 does not recommend using an email address as a way to validate that a user is who they say they are.\n\nEmail verification is crucial for applications that:\n\n*   use email addresses as one of the primary ways to index users\n    \n*   send out emails to users\n    \n*   use email addresses to recommend account linking\n    \n*   let users create accounts connected to an email address\n    \n\nAuth0 provides several ways to add email verification to your application.\n\n## Choose the right approach\n\nThere are several ways to mark emails as verified or unverified. To figure out which method is right for you, here are a few questions to ask yourself or your team:\n\n*   Am I storing (or planning to store) usernames and passwords in Auth0 (or in a database connected through Auth0)?\n    \n*   Do I have special email verification requirements that prevent me from using Auth0's built in verify email flow?  \n    \n*   Do I need to bulk set a large number of users to email verified?\n    \n*   Do I have users coming from Azure AD, ADFS, or other enterprise connections that will need their emails verified?\n    \n\nIf you are storing usernames and passwords in Auth0 or using a custom DB connection to store users in your own system then you can likely use Auth0's [built-in email verification flow](#magic-link-in-a-verification-email).\n\nIf you have requirements preventing you from using Auth0's built in flow or you need to bulk set a large number of users, we have [API endpoints](#custom-or-bulk-verification-with-the-management-api) to help.\n\nLastly, if you have users from enterprise connections, some of those connections have special email verification workflows. To learn more, read [Special Verification Support](#special-verification-support).\n\n## Magic link in a verification email\n\nA common way to verify emails with Auth0 is to email a magic link, or verification link, to the user. When the user clicks the link, the user's `email_verified` flag is set to `true`.\n\n**By default, Auth0 emails magic links to users when they sign up.**\n\nYou can also customize when Auth0 sends verification emails. For example, if you need to verify emails in bulk or if you want to delay verification until the user performs an action requiring a verified email.\n\nThere are two ways to control when the user gets the verification email :\n\n*   Use the [email verification job](https://auth0.com/docs/api/management/v2#!/Jobs/post_verification_email). This triggers Auth0 to send the verification email using the verify email template\n    \n*   Create an [email verification ticket](https://auth0.com/docs/api/management/v2#!/Tickets/post_email_verification) and send the email yourself, including the ticket the user should click to verify their email\n    \n\n## Custom or bulk verification with the Management API\n\nIn some cases you may want to verify email through other means. For example, you have a list of users to verify in bulk or you have some other means for verifying a user's email through a custom workflow you've built yourself.\n\nIn these cases you can use the [PATCH `/api/v2/users` endpoint](https://auth0.com/docs/api/management/v2/#!/Users/patch_users_by_id) to set `email_verified` to `true`.\n\n## Special verification support\n\nFor Azure AD and ADFS enterprise connections, Auth0 supports some custom email verification workflows. This can help you ensure users coming from other systems have verified emails in an accurate and secure way. To learn more, read [Email Verification for Azure AD and ADFS](https://auth0.com/docs/connections/azuread-adfs-email-verification).\n\n## Learn more\n\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles)",
  "title": "Verify Emails using Auth0",
  "description": "Overview of the different ways to verify user emails using Auth0",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/manage-users-using-the-management-api",
  "markdown": "# Manage Users Using the Management API\n\nIn addition to using the Dashboard, you can retrieve, create, update or delete users using the [Management API](https://auth0.com/docs/api/management/v2#!/Users/get_users). If you want to call the Management API directly, you will first need to generate the appropriate access token. To learn more, read [Access Tokens for the Management API](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens). Alternatively, you can use an SDK to implement the functionality you need to call the Management API from your application. For a list of available SDKs, read [the SDKs section of our Support Matrix](https://auth0.com/docs/troubleshoot/customer-support/product-support-matrix).\n\nTo learn how to manage Auth0 Dashboard access for your team members, read [Manage Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access).\n\n## Permissions\n\nUse the following permissions to get an access token for the machine-to-machine applications. To learn more, read [Register Machine-to-Machine Applications.](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps)\n\n| Permissions | Descriptions |\n| --- | --- |\n| `read:users` | Applications can search and retrieve any user records stored in an Auth0 tenant. This includes reading via the `/api/v2/users` , `/api/v2/users-by-email`, and `/api/v2/jobs/users-export` endpoints. |\n| `create:users` | Applications can create users in any database or passwordless connection in an Auth0 tenant. This includes creating via the `/api/v2/users` and `/api/v2/jobs/users-import` endpoints.<br><br>The `/api/v2/users` endpoint also requires the client ID to be added to the `enabled_clients` property of the connection, similar to the [sign-up endpoint](https://auth0.com/docs/api/authentication#signup). |\n| `update:users` | Applications can update any user stored in an Auth0 tenant. This includes updating via the `/api/v2/users` endpoint. |\n| `update:users_app_metadata` | Applications can update only the `user.app_metadata` attribute for any user stored in an Auth0 tenant. This includes updating via the `/api/v2/users endpoint`. |\n| `delete:users` | Applications can delete any user stored in an Auth0 tenant. This includes deleting via the `/api/v2/users` endpoint. |\n\n## Limitations\n\nBy default, user profile attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable because they are updated from the identity provider each time the user logs in.\n\nTo be able to edit the `name`, `nickname`, `given_name`, `family_name`, or `picture` root attributes on the normalized user profile, you must [configure your connection sync with Auth0](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0) so that user attributes will be updated from the identity provider only on user profile creation. These root attributes will then be available to be edited individually or by bulk imports\n\nYou can set passwords using the `create` or `update` endpoints, but for security purposes, passwords cannot be viewed with the `get` or `list user` commands. The right side of the API explorer provides hints on the user profile attributes which can be viewed or modified for any given call.\n\n## Endpoints\n\n*   Use the [`/users`](https://auth0.com/docs/api/v2#!/Users/get_users) endpoint to [retrieve information about all users](https://auth0.com/docs/api/v2#!/Users/get_users). You can also include search criteria to find specific users.\n    \n*   Use the [`/user_id`](https://auth0.com/docs/api/v2#!/Users/get_users_by_id) to [retrieve information about one user](https://auth0.com/docs/api/v2#!/Users/get_users_by_id) based on the `user_id`. The `user_id` is an internal identifier that consists of a connection name and a unique identifier for the user. The `user_id` is different from the ID token.\n    \n*   The [`/userinfo`](https://auth0.com/docs/api/authentication/reference#get-user-info) endpoint takes as input the [Auth0 access token and returns user profile information](https://auth0.com/docs/api/authentication/reference#get-user-info). This endpoint will include the results of any rules that may have altered the user profile during the authentication transaction, but the resulting user profile will not be filtered by any [Scoping](https://auth0.com/docs/scopes/api-scopes).\n    \n*   The [`/tokeninfo`](https://auth0.com/docs/api/authentication/reference#get-token-info) endpoint takes as input the [Auth0 ID token and returns user profile information](https://auth0.com/docs/api/authentication/reference#get-token-info). This endpoint will return a result that does not include the results of any rules that alter the user profile.\n    \n\n## Learn more\n\n*   [Check Error Messages](https://auth0.com/docs/troubleshoot/basic-issues/check-error-messages)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles)\n*   [Auth0.swift: User Management](https://auth0.com/docs/libraries/auth0-swift/auth0-swift-user-management)\n*   [Auth0.Android: User Management](https://auth0.com/docs/libraries/auth0-android/auth0-android-user-management)",
  "title": "Manage Users Using the Management API",
  "description": "Learn how to create a user and view users and their profile details using the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/create-users",
  "markdown": "# Create Users\n\nYou can create a user using Auth0's Dashboard or via the [Auth0 Management API](https://auth0.com/docs/api/management/v2/users/post-users).\n\n1.  Go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users) and click **Create User**.\n    \n    ![Auth0 Dashboard List of Users](https://images.ctfassets.net/cdy7uua7fh8z/HCtwONFHssBzi7LSbhKNn/5c1c118902b235c0ffc3686e1c73022a/Screen_Shot_2021-05-18_at_9.45.13_PM.png)\n2.  Enter your user's **Email**, **Password**, and **Repeat Password**, then select the **Connection**.\n    \n    | Attribute | Description |\n    | --- | --- |\n    | Email | The user's email address. The maximum length is 64 characters for the user/local-part and 256 characters for the domain. The character limit for each level of a multi-level subdomain (separated by a period, such as example.example.com) is 63 characters. |\n    | Password | The user's password. There is no maximum limit for password length. |\n    | Repeat Password | Confirm password. |\n    | Connection | The database connection to use to authenticate the user. The dropdown lists all the configured database connections in your tenant. The connection you use must be associated with an application, otherwise you will receive an error message that says the connection is disabled. |\n    \n3.  Click **Create**. The user is created and you will be directed to the newly-created user's profile.\n    \n\nThe **User Details** page will show **pending** when a user is first created until they have logged in for the first time.\n\n## Learn more\n\n*   [Assign Permissions to Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-permissions-to-users)\n*   [Assign Roles to Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-roles-to-users)\n*   [Identify Users](https://auth0.com/docs/manage-users/user-accounts/identify-users)\n*   [Delete Users](https://auth0.com/docs/manage-users/user-accounts/delete-users)",
  "title": "Create Users",
  "description": "Describes how to create users in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/identify-users",
  "markdown": "# Identify Users\n\nThere are two recommended options to uniquely identify your users:\n\n1.  By the `user_id` property. This is guaranteed to be unique (within a tenant) per user (such as `{identity provider id}|{unique id in the provider}` or `facebook|1234567890`). A user may have the same `user_id` property across multiple Auth0 tenants, but consistency is not guaranteed.\n    \n2.  By a natural key, like the `email` property. In this case, it is recommended that you enable email verification and only use this option with providers that require that users verify their emails.\n    \n\nIf you use [custom databases](https://auth0.com/docs/connections/database/mysql), you must return a unique `user_id` property. If you have multiple custom databases and expect possible collisions between ids from different connections, you should use a prefix identifying the connection. For example:\n\n```\nfunction login (email, password, callback) {\n  var user = getUserFromDB(email);\n  var profile = {\n    user_id: 'MyConnection1|' + user.id,\n    email: user.email,\n    [...]\n  };\n  callback(null, profile);\n}\n```",
  "title": "Identify Users",
  "description": "Learn how to uniquely identify users.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/view-user-details",
  "markdown": "# View User Details\n\nThe [Users](https://manage.auth0.com/#/users) page lists the users who are associated with your apps. To open a particular user, click the user profile picture or name in the \"Name\" column. The User Details page will open and display information for that user.\n\nThe User Details page has links for five tabs:\n\n1.  Details\n    \n2.  Devices\n    \n3.  History\n    \n4.  Locations\n    \n5.  Raw JSON\n    \n\n## User Details: Details Tab\n\nThe Details tab contains three sections that provide a high-level overview of the information in the user's profile:\n\n*   **User Identity** provides at-a-glance details about the user, including their email address, associated Connections, and access rights.\n    \n*   **Metadata** displays the `app_metadata` and `user_metadata` information. You can edit these values.\n    \n*   **Identity Provider Attributes** displays the information retrieved from the authentication provider. Note that identity provider attributes are read-only.\n    \n\n## User Details: Devices Tab\n\nThe Devices tab lists the devices with which the user has requested authentication. Requesting authorization on a device links the device to the user's account.\n\nLogin details for the user are associated with the Refresh Token assigned to that device. To revoke the Refresh Token, click **Unlink** next to the device.\n\n## User Details: History Tab\n\nThe History tab displays a log of the user's account activity for the past 2 days.\n\nThe logs include information about:\n\n*   Events that have occurred\n    \n*   When the events occurred\n    \n*   The apps associated with the events\n    \n*   The identity provider used for authentication\n    \n*   The originating IP addresses for the events\n    \n*   Where the events originated\n    \n\n## User Details: Locations Tab\n\nThe Locations tab displays a map with pins indicating the user's location(s) when they logged in to the apps.\n\n## User Details: Raw JSON Tab\n\nThe Raw JSON tab displays all of the information contained on the user's profile in JSON format so you can quickly view all of the available information about the user.",
  "title": "View User Details",
  "description": "How to view users and their profile details.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/change-user-picture",
  "markdown": "# Change User Pictures\n\nAuth0 normalizes common profile properties in the User Profile, this includes the `name`, `picture` field and more. The picture field is populated by either the social provider profile picture or the Gravatar image associated with the user's email address.\n\nBy default, all database users will have a placeholder image with their initials. When you authenticate the user, this picture field is referred to as `user.picture`.\n\n![Dashboard User Management User Details Tab](https://images.ctfassets.net/cdy7uua7fh8z/6LjSQ5sf6OzmbtxYNLppJl/39dc86641cfdd57648b36750f1553dd3/dashboard-user-management-user-details.png)\n\n## Use the Management API\n\nThe `user.picture` attribute is not directly editable when provided by identity providers other than Auth0 such as Google, Facebook, or X. To edit this attribute, you must configure your connection sync with Auth0 so that user attributes will be updated from the identity provider only on user profile creation. To learn more, read [Configure Identity Provider Connection for User Profile Updates](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0). Root attributes will then be available to be edited individually or by bulk import using the Management API. To learn more, read [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports).\n\nAlternatively, you can use metadata to store the picture attribute for users. For example, if your app provides a way to upload profile pictures, once the picture is uploaded, you can set the URL to the picture in the `user.user_metadata.picture`:\n\n*   [cURL](#fe0579cb485b4b0587346c2dea471724_shell)\n*   [C#](#fe0579cb485b4b0587346c2dea471724_csharp)\n*   [Go](#fe0579cb485b4b0587346c2dea471724_go)\n*   [Java](#fe0579cb485b4b0587346c2dea471724_java)\n*   [Node.JS](#fe0579cb485b4b0587346c2dea471724_node)\n*   [Obj-C](#fe0579cb485b4b0587346c2dea471724_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"user_metadata\": {\"picture\": \"https://example.com/some-image.png\"}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"user_metadata\\\": {\\\"picture\\\": \\\"https://example.com/some-image.png\\\"}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID\"\n\n\tpayload := strings.NewReader(\"{\\\"user_metadata\\\": {\\\"picture\\\": \\\"https://example.com/some-image.png\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/USER_ID\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"user_metadata\\\": {\\\"picture\\\": \\\"https://example.com/some-image.png\\\"}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID',\n  headers: {\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {user_metadata: {picture: 'https://example.com/some-image.png'}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"user_metadata\": @{ @\"picture\": @\"https://example.com/some-image.png\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"user_metadata\\\": {\\\"picture\\\": \\\"https://example.com/some-image.png\\\"}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"user_metadata\\\": {\\\"picture\\\": \\\"https://example.com/some-image.png\\\"}}\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/USER_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"user_metadata\\\": {\\\"picture\\\": \\\"https://example.com/some-image.png\\\"}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"user_metadata\": [\"picture\": \"https://example.com/some-image.png\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Use Actions\n\nTo ensure that the picture from the `user_metadata` is returned in the ID Token, we'll need to [create a new Action](https://auth0.com/docs/customize/actions/write-your-first-action) to check whether the `event.user.user_metadata.picture` attribute is present, and if so, replace the `user.picture` attribute with that value. This ensures that the picture from the `user_metadata` is returned in the `picture` claim of the ID Token.\n\n1.  Navigate to [Auth0 Dashboard > Actions > Library](https://manage.auth0.com/#/actions/library), and select **Build Custom**.\n    \n2.  Enter a descriptive **Name** for your Action (for example, `Change user pictures`), select the `Login / Post Login` trigger because you’ll be adding the Action to the Login flow, then select **Create**.\n    \n3.  Locate the Actions Code Editor, copy the following JavaScript code into it, and select **Save Draft** to save your changes:\n    \n    ```\n    exports.onExecutePostLogin = async (event, api) => {\n      const { picture } = event.user.user_metadata;\n      if (picture) {\n        // Return the persisted user_metadata.picture in the ID token\n        api.idToken.setCustomClaim(\"picture\", picture)\n      }\n    };\n    ```\n    \n4.  From the Actions Code Editor sidebar, select Test (play icon), then select **Run** to [test your code](https://auth0.com/docs/customize/actions/test-actions).\n    \n5.  When you’re ready for the Action to go live, select **Deploy**.\n    \n\nFinally, add the Action you created to the [Login Flow](https://manage.auth0.com/#/actions/flows/login/). To learn how to attach Actions to Flows, read the \"Attach the Action to a flow\" section in [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\n## Change default picture for all users\n\nTo change the default picture for all users who have not set a profile picture, you can use an Action. For example:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const DEFAULT_PROFILE_IMAGE = '{yourDefaultImageUrl}';\n  api.idToken.setCustomClaim(\"picture\", {defaultProfileImage});\n};\n```\n\nIn this Action, the custom picture is returned in the ID Token and overrides any `picture` property that may come from an external identity provider login, such as Google.\n\n## Limitations\n\nThe Auth0 data store is limited and to prevent your application's data from exceeding the limits, we recommend that you use an external database to store user pictures. This allows you to keep your Auth0 data store small and to use a more efficient external database to hold the additional data. To learn more, read [User Data Storage](https://auth0.com/docs/secure/security-guidance/data-security/user-data-storage).\n\n## Learn more\n\n*   [User Profile Structure](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure)\n*   [User Profile Root Attributes](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes)\n*   [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata)\n*   [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api)\n*   [Manage Metadata with Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules)\n*   [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports)",
  "title": "Change User Pictures",
  "description": "Learn how to use user metadata to change a user's picture field and how to change the default picture for all users.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/manage-user-access-to-applications",
  "markdown": "# Manage User Access to Applications\n\nAll users associated with a single Auth0 tenant are shared between the tenant's applications (and therefore have access to the applications).\n\n*   To keep users separate and restrict their access, we recommend that you [create an additional tenant](https://auth0.com/docs/get-started/auth0-overview/create-tenants/create-multiple-tenants) with applications you want groups of users to access.\n    \n\n*   To restrict users' access to certain applications, you can use [rules](https://auth0.com/docs/customize/rules).\n    \n    *   Inside a rule, the `context.clientName` and `context.clientID` variables are available to check which application the user is using for login.\n        \n    *   See [this rule for an example](https://github.com/auth0/rules/blob/aeaf93bc058408e260192d0941a688963449d6be/src/rules/simple-user-whitelist-for-app.js).\n        \n\n*   To restrict users from applications by configuring a new connection and only giving access to a specific application.\n    \n    *   Go to [Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social) and click on a connection.\n        \n    *   On the **Applications** tab, enable/disable applications.\n        \n\n*   To disable users' access to your applications, you can [block and unblock users](https://auth0.com/docs/manage-users/user-accounts/block-and-unblock-users) in the Dashboard.\n    \n\n## Learn more\n\n*   [Create Multiple Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants/create-multiple-tenants)\n*   [Select from Multiple Connection Options](https://auth0.com/docs/libraries/lock/selecting-from-multiple-connection-options)\n*   [Set Up Multiple Environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments)",
  "title": "Manage User Access to Applications",
  "description": "Explains the basics of a user profile, how to create a user and view users and their profile details.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/deny-api-access",
  "markdown": "# Deny User Access to an API with Rules\n\nGo to [Dashboard > Auth0 Pipeline > Rules](https://manage.auth0.com/#/rules). You can set up [](https://auth0.com/docs/rules)[Rules](https://auth0.com/docs/customize/rules) for a number of different purposes, from user management to enriching user profiles. If you need to deny a user access to your API, you can create Roles with assigned scopes, then create a rule to remove scopes from the Access Token:\n\n```\n{\nfunction (user, context, callback) {\n  var permissions = user.permissions || [];\n  var requestedScopes = context.request.body.scope || context.request.query.scope;\n  var filteredScopes = requestedScopes.split(' ').filter( function(x) {\n      return x.indexOf(':') < 0;\n  });\n\n  var allScopes = filteredScopes.concat(permissions);\n  context.accessToken.scope = allScopes.join(' ');\n\n  callback(null, user, context);\n}\n```",
  "title": "Deny User Access to an API with Rules",
  "description": "Learn how to use Auth0's Authorization Extension to deny users access to an API using rules.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/unlink-devices-from-users",
  "markdown": "# Unlink Devices from Users\n\nYou can unlink the devices assigned to a user using the Auth0 Dashboard. This revokes the refresh token for the selected device.\n\n1.  Go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users) and click the name of the user.\n    \n    ![Auth0 Dashboard List of Users](https://images.ctfassets.net/cdy7uua7fh8z/HCtwONFHssBzi7LSbhKNn/5c1c118902b235c0ffc3686e1c73022a/Screen_Shot_2021-05-18_at_9.45.13_PM.png)\n2.  Click the **Devices** view, then click the trashcan icon next to the device you want to unlink, and confirm.\n    \n    ![Dashboard - Users & Roles - Users - Devices View](https://images.ctfassets.net/cdy7uua7fh8z/SvkfrGgmpTBLisUq0tViL/ba091efbcc897870d59810b84c753682/Screen_Shot_2021-05-18_at_9.59.16_PM.png)\n\n## Learn more\n\n*   [Configure Device User Code Settings](https://auth0.com/docs/get-started/tenant-settings/configure-device-user-code-settings)\n*   [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)\n\nWas this article helpful?",
  "title": "Unlink Devices from Users",
  "description": "Describes how to unlink devices assigned to a user using the Auth0 Dashboard. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/block-and-unblock-users",
  "markdown": "# Block and Unblock Users\n\nYou can use the Dashboard to block or unblock a specific user's access to your applications. If a blocked user tries to log in to an application, they will be redirected from the application with the error message `user is blocked` in the URL. Blocking users does not expire. You must unblock the user to allow the user to have access to your applications again.\n\n## Block users\n\n1.  Go to the [Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n    \n    ![Auth0 Dashboard List of Users](https://images.ctfassets.net/cdy7uua7fh8z/HCtwONFHssBzi7LSbhKNn/5c1c118902b235c0ffc3686e1c73022a/Screen_Shot_2021-05-18_at_9.45.13_PM.png)\n2.  To the right of the user's name that you want to block, click **...** and choose **Block**. Alternatively, you can click the user's name and scroll to the bottom of the **Details** tab, next to **Block user**, click **Block**.\n    \n\n![Dashboard - User Management - Users - Danger Zone](https://images.ctfassets.net/cdy7uua7fh8z/bWZQONwa0bP9CSIymiaVI/cd20958f4543c8e84a5799c24a1c4010/dashboard-users-edit_view-details_danger-zone.png)\n\n## Unblock users\n\nTo unblock users, we provide multiple methods, which match the way in which the user was blocked. Users can be blocked in a few different ways:\n\n*   blocked automatically due to the user providing an excessive number of incorrect credentials\n    \n*   blocked through the Auth0 Dashboard by an administrator\n    \n*   blocked through the Management API by updating the user profile to set `blocked` to `false`\n    \n\n### Unblock a user who was automatically blocked\n\nWhen a user is blocked due to the user providing an excessive number of incorrect credentials, you can use Auth0's Management API to unblock them.\n\nUse the [Unblock by Identifier endpoint](https://auth0.com/docs/api/management/v2#!/User_Blocks/delete_user_blocks) to pass an identifier (username, phone number, or email):\n\n```\ncurl -X DELETE  https://{yourAuth0Tenant}.auth0.com/api/v2/user-blocks/john.doe%40gmail.com\n```\n\nOr use the [Updat](https://auth0.com/docs/api/management/v2#\\!/Users/patch_users_by_id)[e a User endpoint](https://auth0.com/docs/api/management/v2#\\!/Users/patch_users_by_id) to patch the `user_id`:\n\n```\ncurl -X PATCH -H \"Content-Type: application/json\" -d '{\"blocked\":false}' https://{yourAuth0Tenant}.auth0.com/api/v2/users/{user_id}\n```\n\n### Unblock a user who was blocked through the user profile\n\nWhen a user is blocked through their user profile using either the Management API or by an administrator using the Auth0 Dashboard, you can unblock them in one of two ways: by having an administrator unblock them through their user profile using the Auth0 Dashboard or by updating the `blocked` attribute in their user profile using the Management API.\n\n#### Using the Auth0 Dashboard\n\nTo unblock a user using the Auth0 Dashboard, an administrator should:\n\n1.  Go to the [Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n    \n2.  To the right of the user's name you want to unblock, click **...** and choose **Unblock**. Alternatively, you can click a previously blocked user's name and scroll to the bottom of the **Details** tab, next to **Unblock user**, click **Unblock.**\n    \n\n#### Using the Management API\n\nTo unblock a user using the Management API, use the [Update a User endpoint](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id) to set the `blocked` attribute to `false`:\n\n```\ncurl -X PATCH -H \"Content-Type: application/json\" -d '{\"blocked\":false}' https://{yourAuth0Tenant}.auth0.com/api/v2/users/{user_id}\n```\n\n## Learn more\n\n*   [Manage User Access to Applications](https://auth0.com/docs/manage-users/user-accounts/manage-user-access-to-applications)",
  "title": "Block and Unblock Users",
  "description": "Describes how to block and unblock users.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/get-user-information-on-unbounce-landing-pages",
  "markdown": "# Get User Information on Unbounce Landing Pages\n\n## Auth0 Configuration\n\n1.  Create an Auth0 account and navigate to the [dashboard](https://manage.auth0.com/#).\n    \n2.  Go to [Dashboard > Applications](https://manage.auth0.com/#/applications) and click **\\+ Create Application**. Pick the `Single-Page Application` option and go to **Settings**. Note the **Client ID** and **Domain**.\n    \n3.  Add the `callback URL` in both **Allowed Callback URLs** and **Allowed Origins (CORS)**. Make it your Unbounce page URL. For example: `http://unbouncepages.com/changeit`.\n    \n4.  Go to [Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social) and enable the social providers you want to support.\n    \n\n## Unbounce Configuration\n\n1.  Create a new UI element, like a button, that will trigger the login with the provider. Note the UI element's ID under **Properties > Element Metadata**.\n    \n2.  Add a new JavaScript to your Unbounce landing page, select `Before Body End Tag` under `Placement` and add this code. Also make sure to check jQuery as a dependency.\n    \n\n```\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"application/javascript\">\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}',\n    audience: 'https://{yourClientId}/userinfo'\n    redirectUri:  '{yourUnbouncePageUrl}', // e.g http://unbouncepages.com/changeit\n    scope: 'openid profile email',\n    responseType: 'token id_token',\n  });\n</script>\n```\n\nYou should use the Client ID and Domain of the application you just configured.\n\nNext, you need a way to pass the information coming from the social providers to Unbounce:\n\n1.  Creating a Form and add `Hidden fields` for each field. For example: the `name` and `email` fields.\n    \n2.  Return to the JavaScript editor at Unbounce.\n    \n3.  Add a click handler for each button to trigger the social authentication.\n    \n    1.  Replace the button ID you took note of previously and the [connection name](https://auth0.com/docs/authenticate/identity-providers/locate-the-connection-id). For example, for Google you would use `google-oauth2` and for LinkedIn, `linkedin`.\n        \n    2.  Make sure that you replace the IDs properly. Instead of `#name` and `#email` you should put the ID of the form fields in question (you can see them while editing the form, under `Field Name and ID`).\n        \n\n```\n$('#{buttonId}').bind('click', function() { \n  webAuth.authorize({\n    connection: '{yourConnectionName}'\n  });\n});\n\n// After authentication occurs, the parseHash method parses a URL hash fragment to extract the result of an Auth0 authentication response.\n\nwebAuth.parseHash({ hash: window.location.hash }, function(err, authResult) { \n  if (err) { \n    return console.log(err); \n  }\n\n  if (authResult != null && authResult.accessToken != null) {\n    webAuth.client.userInfo(authResult.accessToken, function(err, user) {\n      $('#name').val(user.name); \n      $('#email').val(user.email); \n    }); \n  } \n\n});\n```\n\nNow you will be able to see the information provided by the IdP in the `Leads` section of your Unbounce Admin Panel, after the user submits the form.",
  "title": "Get User Information on Unbounce Landing Pages",
  "description": "How to get user information with one-click social authentication on Unbounce landing pages.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers",
  "markdown": "# Enterprise Identity Providers\n\nAuth0 supports the following enterprise providers out of the box:\n\n*   [Active Directory/LDAP](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap)\n    \n*   [ADFS](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/adfs)\n    \n*   [Azure Active Directory Native](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory-native)\n    \n*   [Google Workspace](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/google-apps)\n    \n*   [OpenID Connect](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/oidc)\n    \n*   [Okta](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/okta)\n    \n*   [PingFederate](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/ping-federate)\n    \n*   [SAML](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/saml)\n    \n*   [Azure Active Directory](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory/v2)\n    \n\nYou can also explore partner-supported enterprise connections on the [Auth0 Marketplace](https://marketplace.auth0.com/features/enterprise-connections).\n\n## OpenID Connect (OIDC) protocol\n\nEnterprise connections using OpenID Connect or Okta Workforce as the identity provider can support the following:\n\n*   Proof Key for Code Exchange (PKCE)\n    \n    *   For more information on PKCE, review [Protecting Apps with PKCE](https://www.oauth.com/oauth2-servers/pkce/).\n        \n*   Attribute claims and access token mapping\n    \n*   UserInfo integration\n    \n\nYou can currently implement these features for [OpenID Connect](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/oidc) or [Okta Workforce](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/okta) connections. To learn more, review [Configure PKCE and Claim Mapping for OIDC Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc).",
  "title": "Enterprise Identity Providers",
  "description": "Learn about enterprise identity providers supported by Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/legal",
  "markdown": "# Legal Identity Providers\n\nThrough our partner, Criipto, we offer a range of different, and often proprietary, e-ID services of the EU. To explore available options, visit [Auth0 Marketplace: Criipto](https://marketplace.auth0.com/integrations/criipto-verify-e-id).\n\nIf you don't find what you need here, please contact [Criipto](https://criipto.com/).",
  "title": "Legal Identity Providers",
  "description": "Learn about legal identity providers supported by Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/resend-verification-emails",
  "markdown": "# Resend Verification Emails\n\nIf you need to resend a verification email to a user, you can resend it using the Auth0 User Management Dashboard or the Auth0 Management API.\n\nYou can use the Auth0 Dashboard to resend a verification email to a user.\n\n1.  In the Dashboard, go to [**User Management > Users**](https://manage.auth0.com/#/users).\n    \n2.  Select the user.\n    \n3.  Select the **Actions** dropdown menu, and then select **Send Verification Email**.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/2KicMSDUsa6qlpUm3vHOKE/afd7e1bfca40b8b3c072cd2a11025497/user-email-resend.png)",
  "title": "Resend Verification Emails",
  "description": "Describes how to resend verification emails to users via the Auth0 Management Dashboard and the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/view-connections",
  "markdown": "# View Connections\n\nWas this article helpful?",
  "title": "View Connections",
  "description": "Describes how to view enabled connections in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/test-connections",
  "markdown": "# Test Connections\n\nGenerally, to test a connection, you must log in to the Auth0 Dashboard.\n\n1.  Navigate to [Auth0 Dashboard](https://manage.auth0.com/#), and select **Authentication**, then select the type of connection you want to test.\n    \n2.  Locate the connection you want to test, and select **Try Connection** from its **More Options** menu (**...**).\n    \n3.  Log in with the identity provider.\n    \n4.  Wait for the **It Works!** page that displays the result.\n    \n\nAuth0 simulates the authentication flow as if it were an application, displaying the User Profile resulting from a successful authentication.\n\n## Test partner connections\n\nIf you are testing a connection that belongs to someone else, and you don't have test credentials with them, it is not possible to be logged in to the Auth0 Dashboard. This is common when connecting to Enterprise connections, such as SAML Identity Providers (IdPs) or Active Directory. The solution? Your partners can test the new connection.\n\n1.  Register a test app.\n    \n    *   Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select **Create Application**. You can give it any name (for example, `Test App`).\n        \n    *   In the settings of the newly-created app, set **Allowed Callback URLs** to `http://jwt.io`.\n        \n    *   Select **Save Changes**.\n        \n2.  Send your partner the link to log in.\n    \n    ```\n    https://{yourDomain}/authorize?response_type=token&scope=openid%20profile&client_id={yourClientId}&redirect_uri=http://jwt.io&connection={connectionToTest}\n    ```\n    \n    Replace these two parameters:\n    *   `client_id`: Client ID of the application created in Step 1.\n        \n    *   `connection`: Name of the connection you want to test.\n        \n3.  Test the connection. When your partner follows the link, they will be redirected to their configured Identity Provider (the connection). After successful authentication, they will be sent back to [JWT.io](http://jwt.io/) where all user properties will be decoded from the token.",
  "title": "Test Connections",
  "description": "Describes how to test a connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-accounts/delete-users",
  "markdown": "# Delete Users\n\n1.  Go to the [Dashboard > User Management - Users](https://manage.auth0.com/#/users).\n    \n    ![Auth0 Dashboard List of Users](https://images.ctfassets.net/cdy7uua7fh8z/HCtwONFHssBzi7LSbhKNn/5c1c118902b235c0ffc3686e1c73022a/Screen_Shot_2021-05-18_at_9.45.13_PM.png)\n2.  Click the name of the user you want to delete.\n    \n3.  On the **Details** tab, scroll to the bottom, next to **Delete user**, and click **Delete**.\n    \n    ![Dashboard - User Management - Users - Danger Zone](https://images.ctfassets.net/cdy7uua7fh8z/bWZQONwa0bP9CSIymiaVI/cd20958f4543c8e84a5799c24a1c4010/dashboard-users-edit_view-details_danger-zone.png)\n    \n    A popup will warn you that the action cannot be undone and prompt you to confirm that you want to delete the user. Click the **Yes, Delete It** button to confirm. This will permanently delete the user.\n    \n\nWas this article helpful?",
  "title": "Delete Users",
  "description": "Describes how to delete users.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions",
  "markdown": "# Redirect with Actions\n\nYou can use post-login Actions to redirect users before an authentication transaction is complete. This lets you implement custom authentication flows that require additional user interaction beyond the standard login form.\n\nRedirects are commonly used to do custom [Multi-factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) in Auth0, but they can also be used to:\n\n*   Allow for custom privacy policy acceptance, terms of service, and data disclosure forms.\n    \n*   Perform a one-time collection of additional required profile data securely.\n    \n*   Allow remote Active Directory users to change their password.\n    \n*   Require users to provide additional verification when logging in from unknown locations.\n    \n*   Gather more information about your users than they provided at initial signup.\n    \n\n## Overview\n\nAt a high level, a Redirect Action works in the following manner:\n\n1.  An Action issues a redirect to a URL.\n    \n2.  The Actions pipeline is suspended after that Action completes its execution.\n    \n3.  The user is redirected to the URL along with a `state` parameter.\n    \n4.  When the external flow has concluded, the external site redirects the user to a `/continue` endpoint along with the `state` parameter.\n    \n5.  The Actions pipeline is resumed on the same Action that invoked the redirect.\n    \n\n## Start a redirect\n\nCall the `api.redirect.sendUserTo()` function as follows:\n\n```\n/**\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  api.redirect.sendUserTo(\"https://my-app.exampleco.com\");\n};\n```\n\nActions will finish the execution of this Action, and then suspend the actions pipeline to send the user to the `https://my-app.exampleco.com`. In other words, any Actions that are bound to the post-login triggers that run after the Action invoking the redirect will not execute until the authentication flow has been resumed. If you are familiar with Redirect Rules, then note that this is a key difference between Redirect Actions and Redirect Rules.\n\nAfter the Action has finished executing, Auth0 redirects the user to the URL specified in the `api.redirect.sendUserTo()` function. Auth0 also passes a `state` parameter in that URL. For example: \n\n`https://my-app.exampleco.com/?state=abc123`\n\nYour redirect URL will need to extract the `state` parameter and send it back to Auth0 to resume the authentication transaction. State is an opaque value used to prevent [Cross-Site Request Forgery (CSRF) attacks](https://auth0.com/docs/secure/security-guidance/prevent-threats).\n\n## Resume the authentication flow\n\nAfter the redirect, resume authentication by redirecting the user to the `/continue` endpoint and including the `state` parameter you received in the URL. If you do not send the original state back to the `/continue` endpoint, Auth0 will lose the context of the login transaction and the user will not be able to log in due to an `invalid_request` error.\n\nFor example:\n\n`https://{yourAuth0Domain}/continue?state=THE_ORIGINAL_STATE`\n\nIn this example, `THE_ORIGINAL_STATE` is the value that Auth0 generated and sent to the redirect URL. For example, if your Action redirects to `https://my-app.exampleco.com/`, Auth0 would use a redirect URL similar to `https://my-app.exampleco.com/?state=abc123`, making `abc123` the `THE_ORIGINAL_STATE`. To resume the authentication transaction, you would redirect to:\n\n`https://{yourAuth0Domain}/continue?state=abc123`\n\nWhen a user has been redirected to the `/continue` endpoint, the Actions pipeline will resume on the same Action that invoked the redirect by calling the `onContinuePostLogin` function. For redirects to work properly, you must have a function with the following signature in the same Action that invoked the redirect:\n\n```\n/**\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  api.redirect.sendUserTo(\"https://my-app.exampleco.com\");\n};\n\n/**\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\n\nexports.onContinuePostLogin = async (event, api) => {\n}\n```\n\n## Pass data to the external site\n\nTo pass data to the external site, we recommend encoding that data in a signed [JWT](https://auth0.com/docs/secure/tokens/json-web-tokens) so that your application can be certain it was not tampered with during transit. With Actions, this can be done with the `api.redirect.encodeToken` and `api.redirect.sendUserTo` functions:\n\n```\n/**\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  const YOUR_AUTH0_DOMAIN = event.secrets.YOUR_AUTH0_DOMAIN || event.request.hostname\n\n  // Craft a signed session token\n  const token = api.redirect.encodeToken({\n    secret: event.secrets.MY_REDIRECT_SECRET,\n    expiresInSeconds: 60, \n    payload: {\n      // Custom claims to be added to the token\n      email: event.user.email,\n      externalUserId: 1234,\n      continue_uri: `https://${YOUR_AUTH0_DOMAIN}/continue`\n    },\n  });\n\n  // Send the user to https://my-app.exampleco.com along\n  // with a `session_token` query string param including\n  // the email.\n  api.redirect.sendUserTo(\"https://my-app.exampleco.com\", {\n    query: { session_token: token }\n  });\n}\n```\n\nThe code above appends a `session_token` query string parameter to the URL used in the redirect (in addition to the `state` parameter that Auth0 adds automatically). This token will contain the following:\n\n| Token Element | Description |\n| --- | --- |\n| `sub` | Auth0 `user_id` of the user. |\n| `iss` | Hostname of your Auth0 tenant domain (e.g., `example.auth0.com`). |\n| `exp` | Expiration time (in seconds) specified with the `expiresInSeconds` parameter. Should be as short as possible to avoid re-use of the token. Defaults to 900 seconds (15 minutes). |\n| `ip` | IP Address of the originating authentication request. |\n| `email` | Custom claim with a value specified in the `payload.email` parameter. |\n| `externalUserId` | Custom claim with a value specified in the `payload.externalUserId` parameter. |\n| `signature` | Using the secret specified above, the token will be signed with HS256 algorithm. |\n\n### Ensure the token has not been tampered with\n\nThe external system should verify that this token has not been tampered with during transit. To accomplish this, the remote system should ensure the token’s signature is valid and, if applicable, that the session in the external system belongs to the same Auth0 user provided in the `sub` claim of the token.\n\n## Pass data back to Auth0\n\nAfter the user completes the custom flow in the external site, they should be redirected to the `/continue` endpoint. In some situations, you may want to pass data back to Auth0 to impact the authentication or authorization flow for that user (for example, if you are implementing CAPTCHA checks or custom MFA).\n\n### Use app metadata where possible\n\nIf possible, the remote system should use the [Auth0 Management API](https://auth0.com/docs/api/management/v2/) to store custom information as application metadata on the Auth0 user profile. When the Auth0 Action flow is resumed, this information will be available on the `event.user.app_metadata` object. This approach avoids passing sensitive information to Auth0 on the front channel.\n\n### Be selective when storing data on the Auth0 user profile\n\nAvoid storing too much data in the Auth0 profile. This data is intended to be used for authentication and authorization purposes. The metadata and search capabilities of Auth0 are not designed for scenarios that require high search or update frequency, such as marketing research. Your system is likely to run into scalability and performance issues if you use Auth0 for these kinds of purposes.\n\nIf your application requires access to substantive user data, the recommended approach is to store that data in an external system and store a foreign key (the user ID) in Auth0 so that back-end systems can fetch the data if needed.\n\n## Send data on the front channel\n\nPassing information back and forth in the front channel opens up surface area for bad actors to attack. If information must be sent on the front channel, then consider the following guidance:\n\n### Pass information back to the Action\n\nA signed session token should be used to send sensitive information back to Auth0. This token can be easily validated within an Action with the following code:\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onContinuePostLogin = async (event, api) => {\n  const payload = api.redirect.validateToken({\n    secret: event.secrets.PRECONFIGURED_SECRET,\n    tokenParameterName: 'my_token',\n  });\n\n  // use the data encoded in the token, such as: \n  api.idToken.setCustomClaim('color', payload.favorite_color);\n}\n```\n\nThe token will be validated to ensure that:\n\n*   The signature is valid.\n    \n*   The token is not expired.\n    \n*   The `state` claim within the token matches the `state` parameter used as part of the redirect.\n    \n\n| Token Element | Description |\n| --- | --- |\n| `sub` | Auth0 `user_id` of the user. |\n| `iss` | Application that is targeted for the redirect. |\n| `exp` | Should be as short as possible to avoid reuse of the token. |\n| `state` | state parameter sent to the remote site as part of the redirect. This must be included in the token to avoid replay attacks. |\n| `other` | Any other custom claims will be exposed as the `payload` in the code above. |\n| `signature` | Token should be signed with the HS256 algorithm. |\n\nTo avoid replay attacks, the token should be sent back to Auth0 by making a POST request to the `/continue` endpoint. The `tokenParameterName` option in the code allows you to specify the name of the field that contains your token.\n\n## Custom authentication methods\n\nAfter a successful redirect in the login pipeline, Actions can record custom authentication method events in the user's session. The `event.authentication.methods` array will contain an entry for the custom method for the duration of the user's browser session. Each entry in this array has a timestamp indicating when the authentication method was recorded.\n\nA custom action can trigger a redirect if the required custom method is not in the `event.authentication.methods` array or if the entry is too old.\n\nYou can use `api.redirect.sendUserTo()` to send the user to a page that implements a custom authentication method. You can use the `api.authentication.recordMethod()` in the `exports.onContinuePostLogin` handler to store a record of the completed method in the user's session.\n\nThe record stored in the `event.authentication.methods` array will have a `name` property matching the URL chosen in `api.authentication.recordMethod()`. The URL captured here allows you to search through the current transaction's completed authentication methods to determine if your custom method already completed.\n\nYour workflow may require the custom method to be re-performed periodically during the life of a user's session. For example, custom MFA scenarios may require user re-verification after a specified timeframe.\n\nThe example below compares the timestamp of an existing record to determine when to rerun the custom method:\n\n```\nconst CUSTOM_METHOD_URL = \"https://path.to.prompt\";\nconst PROMPT_TTL = 1000 * 60 * 60 * 24; // 24h\n\n/**\n * Handler that will be called during the execution of a PostLogin flow.\n *\n * @param {Event} event - Details about the user and the context in which\n * they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to\n * change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  // Search authentication method records for an entry representing our\n  // custom method.\n  const methodRecord = event.authentication?.methods.find((record) =>\n    validateCustomRecord(record, CUSTOM_METHOD_URL, PROMPT_TTL)\n  );\n\n  if (!methodRecord) {\n    const sessionToken = api.redirect.encodeToken({\n      payload: {\n        user_id: event.user.user_id,\n      },\n      secret: event.secrets.SESSION_TOKEN_SECRET,\n    });\n\n    // We didn't find a valid record, so we send the user to the\n    // URL that implements the custom method with the signed\n    // data we encoded in `sessionToken`.\n    api.redirect.sendUserTo(CUSTOM_METHOD_URL, {\n      query: { session_token: sessionToken },\n    });\n  }\n};\n\n/**\n * Handler that will be invoked when this action is resuming after an\n * external redirect. If your onExecutePostLogin function does not perform\n * a redirect, this function can be safely ignored.\n *\n * @param {Event} event - Details about the user and the context in which\n * they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to\n * change the behavior of the login.\n */\nexports.onContinuePostLogin = async (event, api) => {\n  const payload = api.redirect.validateToken({\n    secret: event.secrets.SESSION_TOKEN_SECRET,\n    tokenParameterName: \"session_token\",\n  });\n\n  if (!validateSessionToken(payload)) {\n    return api.access.deny(\"Unauthorized\");\n  }\n\n  // Record the completion of our custom authentication method.\n  // THIS NEW API IS ONLY AVAILABLE IN `onContinuePostLogin`.\n  api.authentication.recordMethod(CUSTOM_METHOD_URL);\n};\n\nfunction validateCustomRecord(record, url, ttl) {\n  if (!record) {\n    // No record means it isn't valid.\n    return false;\n  }\n\n  if (record.url !== url) {\n    // This isn't a record of our custom method.\n    return false;\n  }\n\n  // Timestamps are rendered as ISO8601 strings.\n  const timestamp = new Date(record.timestamp);\n\n  // The record is valid if it was recorded recently enough.\n  return timestamp.valueOf() >= Date.now() - ttl;\n}\n\nfunction validateSessionToken(payload) {\n  // Custom validation logic for the data returned by the\n  // custom method goes here.\n  return true;\n}\n```\n\nThe `api.authentication.recordMethod()` API is only available in the `exports.onContinuePostLogin` handler. This avoids potential login exploits by recording the custom method after completing the redirect.\n\n## Restrictions and limitations\n\nRedirect Actions won't work with:\n\n*   [Resource Owner endpoint](https://auth0.com/docs/api/authentication/reference#resource-owner)\n    \n*   [Password exchange](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n    \n*   [Refresh Token exchange](https://auth0.com/docs/secure/tokens/refresh-tokens)\n    \n\n### Resource Owner endpoint\n\nIt is impossible to use redirect Actions when you are calling the Authentication API [Get Token](https://auth0.com/docs/api/authentication#resource-owner-password) endpoint for the Resource Owner Password flow. Since the user is not in a redirect flow to begin with, you can not redirect the user in an Action.\n\n### Flows where prompt=none\n\nSince the goal of `prompt=none` is to avoid any scenario where the user will be required to enter input, any redirection will result in an `error=interaction_required`.\n\nSince Actions run after an authentication session is created, you cannot use `prompt=none` if you have a redirect rule that is attempting to block access to tokens under certain conditions (for example, custom MFA, CAPTCHA with login, and so on).\n\nYou cannot create a redirect flow that blocks token access and bypasses the redirect Action if `prompt=none` because after a failed attempt, a user can simply call again with `prompt=none` and get tokens because their authentication session has been created even though Actions failed the first time.\n\n### Refresh tokens\n\nDue to the fact that using a refresh token requires a back-channel call to the Authentication API [Get Token](https://auth0.com/docs/api/authentication#refresh-token) endpoint, this will also fail if attempting to redirect.\n\nIt is difficult to securely verify that any restrictions on login were carried out. There is not a consistent session ID in the context that could be used to collect information associated with the session such as this user passed MFA challenges. Therefore, you cannot use `prompt=none` at all.\n\nAny time `api.redirect.sendUserTo()` is called in an Action, if `prompt=none` was passed, then the authorization fails with `error=interaction_required`, but since the user's session is created even if Actions fail, we can't trust that a user passed redirect challenges and therefore can't use `prompt=none` as a way to get tokens.\n\nIn this specific case, we recommend that you use refresh tokens exclusively, because you can ensure that a user passed challenges if those challenges are required to generate a refresh token.\n\n## Learn more\n\n*   [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata)",
  "title": "Redirect with Actions",
  "description": "Learn how to use post-login Actions to redirect users before an authentication transaction is complete.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/extensions/account-link",
  "markdown": "# Account Link Extension\n\nThe Account Link extension prompts users that may have created a second account by mistake to link the new account with their old one upon their first login. The user may choose to either link the two accounts or keep them separate if creating the second account was intentional.\n\n## How does the extension work?\n\nThe extension triggers after authentication when the email address of the user who authenticated matches the email address of an existing user account attached to a different identity provider.\n\nFor example, if a user logs in with their Facebook account using the email `john@acme.com` and then later authenticates with Google using the same email address, they will be prompted with a page similar to the following:\n\n![Dashboard - Extensions - Account Link - Extension Example](https://images.ctfassets.net/cdy7uua7fh8z/5K3KBOkhyP1SbAVaYg1yxD/618568208eca3cd15000d716ae9a1e00/account-linking-extension.png)\n\nThe extension does not automatically link users with the same email, even if emails are verified, because verified emails are not enough evidence to prove that the user can currently authenticate to both accounts.\n\nIf the user selects **Continue**, they will be redirected to Facebook to authenticate. If the user is already logged in, Facebook will redirect back to the application, and the user will be automatically linked. If they are not logged in, they will be prompted to authenticate with their Facebook credentials. After Facebook redirects back to Auth0, the Facebook account will be linked with the Google account. This process ensures that the user has the credentials to authenticate to both accounts, which allows the accounts to be linked safely and correctly.\n\n### Limitations\n\nNote that the extension does not support passwordless connections, flows started using device authorization, or the SAML and WS-federation protocols. For connections not supported by the Account Link extension, see [Account Linking – Server-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation) and [User Initiated Account Linking – Client-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation) as alternative options.\n\n## Install and configure extension\n\nGo to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **Auth0 Account Link**. The **Install Extension** window opens.\n\nThe extension will create a new application named `auth0-account-link` to use internally and a new rule to redirect users to the extension if they login with a new account that has an email matching an existing account. This application needs to have enabled all the connections that you want to perform account linking with.\n\nTo test, create a React Sample Single Page Application with [this project](https://github.com/auth0-samples/auth0-link-accounts-sample.git).\n\nOpen the `auth_config.json` file in your text editor and update the domain and `client_id` with your details.\n\nAdd `http://localhost:3000` in the “Allowed Callback URLs”, “Allowed Logout URLs”, “Allowed Web Origins” field.\n\nLog in to `http://localhost:3000` and select a connection. Enter an email address that is already associated with a verified user with a different type of connection.\n\nTo link the account, select **Continue.**\n\nOnce logged in, check the user details on the Auth0 dashboard, we can see the user accounts are linked.\n\n## Set up extension\n\n### Change application name\n\nWe recommend changing the name of the default application used for the extension to something descriptive and easy to read for your customers, like `Account Linking`, since it will appear on the **Login Page** when they authenticate their primary account.\n\n### Update the login page\n\nBy default, Auth0's Universal Login allows a user to both log in and sign up, as one may expect. However, when the account linking asks you to authenticate your primary account in order to link it with the new account, providing a signup option can be confusing for users.\n\nTo learn more about what you can do with Universal Login, see [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login).\n\nTo prevent this, we send a query parameter to let the login page know that it should hide the **Sign Up** option. For this query parameter to take effect, however, you must customize the login page.\n\n1.  Go to [Auth0 Dashboard > Branding > Universal Login](https://manage.auth0.com/#/login_settings), and select the **Login** view.\n    \n2.  Enable the **Customize Login Page** switch to enable the custom editor below. In the editor, we're going to add a new line to the Lock config.\n    \n3.  Toward the bottom of the object configuring the Lock widget, add the following line (after the `closable` setting): `allowSignUp: !config.extraParams.prevent_sign_up,`\n    \n    ![Dashboard - Branding - Universal Login - Login Setting - Account Link Hosted Page Code Example](https://images.ctfassets.net/cdy7uua7fh8z/7gejLGgQB5hoLPqEAJXY5w/38b081b3ea4d8ab8cccc8b6c45e798b2/Dashboard_-_Branding_-_Universal_Login_-_Login_Settin_-_Account_Link_Hosted_Page_Code_Example.png)\n4.  Save your changes and attempt to link an account. You'll notice that the **Sign Up** option is no longer present and your users are safe from an extra level of confusion.\n    \n    ![Account Link Hosted Page Example](https://images.ctfassets.net/cdy7uua7fh8z/5LHWcm49M29Y00rI5xDaZV/773621dc56b4bff67ea618b2c919f750/hosted-page-example.png)\n\n## Customize theme\n\nAt installation (or any time after by clicking the **Settings** icon for the Account Link Extension), you can add a URL to a custom stylesheet if you would like to customize the extension page to look a bit different from the default theme.\n\n![Account Link Customize Theme](https://images.ctfassets.net/cdy7uua7fh8z/2as3Sx9y6UB0tyIuyJikR7/ee4ce139c19a0c2b8125e28b9059939e/extension-page-example.png)\n\n## Administration Panel\n\nYou can customize your account linking login page and widget using the extension administration panel.\n\n1.  Go to [Dashboard > Extensions > Installed Extensions > Auth0 Account Link](https://manage.auth0.com/#/extensions/installed).\n    \n    ![Dashboard - Extensions - Installed Extensions - Account Link](https://images.ctfassets.net/cdy7uua7fh8z/5OEQ3IDJfb5JAeVflAXvKl/3fb52ac2285dfebf5758146ec1c79c65/Dashboard_-_Extensions_-_Installed_Extensions_-_Account_Link.png)\n2.  You will be redirected to the admin site. There you can edit the HTML code of your hosted page and change some settings of the account linking widget such as title, logo, color, and language.\n    \n    ![Dashboard - Extensions - Account Link - HTML Editor](https://images.ctfassets.net/cdy7uua7fh8z/1iPL5K5PC7BfvXoFopCpbA/b161073e3903b766184505ac239d3128/html-editor.png)\n\n![Dashboard - Extensions - Account Link - Widget Settings](https://images.ctfassets.net/cdy7uua7fh8z/6rPRc4uxD9g04574WcJps/4b363dfb26563ca9059fafccb0138b71/widget-settings.png)\n\n## Custom domains\n\nIf you're using a custom domain, you'll need to set the configs rule `customDomain` with the custom domain (for example, `auth.custom.com`).\n\n1.  Go to [Auth0 Dashboard > Auth Pipeline > Rules](https://manage.auth0.com/#/rules).\n    \n2.  By default, line 27 of the rule is: `issuer: auth0.domain` You will need to change this to: `issuer: \"myCustomDomain.com\" Make` sure to omit the protocol portion of the URL.\n    \n\n## Learn more\n\n*   [User Account Linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking)\n*   [Link User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts)\n*   [User Account Linking: Server-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)\n*   [User-Initiated Account Linking: Client-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation)\n*   [Migrate to Access Tokens for Account Linking](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/link-user-accounts-with-access-tokens-migration)",
  "title": "Account Link Extension",
  "description": "Learn about the Account Link extension, which allows users with two accounts with the same email to be prompted to link them.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/locate-the-connection-id",
  "markdown": "# Locate the Connection ID or Name\n\nSome user management tasks require a connection ID, which is a unique identifier for a source of users. For example, if you import or export users or connect to identity providers, you must provide a connection ID.\n\n1.  Go to [Auth0 Dashboard](https://manage.auth0.com/#/), select **Authentication**, then select the type of connection for which you need the ID.\n    \n2.  Select the name of the connection for which you need the ID.\n    \n3.  On the **Settings** view, locate the **Name** field; it contains the connection ID.",
  "title": "Locate the Connection ID or Name",
  "description": "Learn how to find the ID of a connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/retrieve-connection-options",
  "markdown": "# Retrieve Connection Options\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/connections/CONNECTION-ID',\n  params: {fields: 'options'},\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/CONNECTION-ID?fields=options\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Retrieve Connection Options",
  "description": "Learn how to retrieve the options object for a connection using the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/pass-parameters-to-idps",
  "markdown": "# Pass Parameters to Identity Providers\n\nYou can pass provider-specific parameters to an Identity Provider (IdP) during authentication. The values can either be static per connection or dynamic per user.\n\n## Limitations\n\nFor this configuration, be aware of the following restrictions:\n\n*   Only [valid OAuth 2.0/OIDC parameters](http://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint) are accepted.\n    \n*   Not all IdPs support upstream parameters. Check with the specific IdP before you proceed with your implementation.\n    \n*   SAML IdPs do not support upstream parameters.\n    \n\n## Static parameters\n\nUse static parameters to configure your connection to send a standard set of parameters to the IdP when a user logs in.\n\nTo configure static parameters, call the Auth0 Management API [Create a connection](https://auth0.com/docs/api/management/v2/#!/Connections/post_connections) or [Update a connection](https://auth0.com/docs/api/management/v2/#!/Connections/patch_connections_by_id) endpoint, and pass the `upstream_params` object in the `options` object with the parameters you'd like to send to the IdP.\n\n### Example: WordPress\n\nWordPress allows you to pass an optional `blog` parameter to its OAuth 2.0 authorization endpoint, and automatically request access to a specified blog for users when they log in. To learn more, read [WordPress's OAuth 2.0 documentation](https://developer.wordpress.com/docs/oauth2/).\n\nTo follow this example, you'll need a working [WordPress Social connection](https://marketplace.auth0.com/integrations/wordpress-social-connection).\n\n#### Get the connection\n\nCall the Management API [Get a connection](https://auth0.com/docs/api/management/v2#!/Connections/get_connections_by_id) endpoint to retrieve the existing values of the `options` object:\n\n*   [cURL](#d004be6840c24017b443e6ce39551c56_shell)\n*   [C#](#d004be6840c24017b443e6ce39551c56_csharp)\n*   [Go](#d004be6840c24017b443e6ce39551c56_go)\n*   [Java](#d004be6840c24017b443e6ce39551c56_java)\n*   [Node.JS](#d004be6840c24017b443e6ce39551c56_node)\n*   [Obj-C](#d004be6840c24017b443e6ce39551c56_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D',\n  headers: {\n    authorization: 'Bearer {yourMgmtApiAccessToken}',\n    'content-type': 'application/json'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe `options` object will look something like this:\n\n```\n{\n  \"options\": {\n    \"client_id\": \"\", \n    \"profile\": true, \n    \"scope\": [\"profile\"]\n  }\n}\n```\n\n#### Update the connection (static)\n\nCopy the existing `options` object, and then add the `upstream_params` object with the `blog` field as an attribute:\n\n```\n{\n  \"options\": {\n    \"client_id\": \"\", \n    \"profile\": true, \n    \"scope\": [\"profile\"],\n    \"upstream_params\": {\n      \"blog\": {\"value\":\"myblog.wordpress.com\"}\n    }\n  }\n}\n```\n\nCall the Management API [Update a connection](https://auth0.com/docs/api/management/v2/#!/Connections/patch_connections_by_id) endpoint with the `options` object in the body:\n\n*   [cURL](#edc1805dc3b840d5bfce317b146c9d49_shell)\n*   [C#](#edc1805dc3b840d5bfce317b146c9d49_csharp)\n*   [Go](#edc1805dc3b840d5bfce317b146c9d49_go)\n*   [Java](#edc1805dc3b840d5bfce317b146c9d49_java)\n*   [Node.JS](#edc1805dc3b840d5bfce317b146c9d49_node)\n*   [Obj-C](#edc1805dc3b840d5bfce317b146c9d49_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"options\":{\"client_id\":\"\",\"profile\":true,\"scope\":[\"profile\"],\"upstream_params\":{\"blog\":{\"value\":\"myblog.wordpress.com\"}}}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"options\\\":{\\\"client_id\\\":\\\"\\\",\\\"profile\\\":true,\\\"scope\\\":[\\\"profile\\\"],\\\"upstream_params\\\":{\\\"blog\\\":{\\\"value\\\":\\\"myblog.wordpress.com\\\"}}}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"options\\\":{\\\"client_id\\\":\\\"\\\",\\\"profile\\\":true,\\\"scope\\\":[\\\"profile\\\"],\\\"upstream_params\\\":{\\\"blog\\\":{\\\"value\\\":\\\"myblog.wordpress.com\\\"}}}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"options\\\":{\\\"client_id\\\":\\\"\\\",\\\"profile\\\":true,\\\"scope\\\":[\\\"profile\\\"],\\\"upstream_params\\\":{\\\"blog\\\":{\\\"value\\\":\\\"myblog.wordpress.com\\\"}}}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D',\n  headers: {\n    authorization: 'Bearer {yourMgmtApiAccessToken}',\n    'content-type': 'application/json'\n  },\n  data: {\n    options: {\n      client_id: '',\n      profile: true,\n      scope: ['profile'],\n      upstream_params: {blog: {value: 'myblog.wordpress.com'}}\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"options\": @{ @\"client_id\": @\"\", @\"profile\": @YES, @\"scope\": @[ @\"profile\" ], @\"upstream_params\": @{ @\"blog\": @{ @\"value\": @\"myblog.wordpress.com\" } } } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"options\\\":{\\\"client_id\\\":\\\"\\\",\\\"profile\\\":true,\\\"scope\\\":[\\\"profile\\\"],\\\"upstream_params\\\":{\\\"blog\\\":{\\\"value\\\":\\\"myblog.wordpress.com\\\"}}}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"options\\\":{\\\"client_id\\\":\\\"\\\",\\\"profile\\\":true,\\\"scope\\\":[\\\"profile\\\"],\\\"upstream_params\\\":{\\\"blog\\\":{\\\"value\\\":\\\"myblog.wordpress.com\\\"}}}}\"\n\nheaders = {\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"options\\\":{\\\"client_id\\\":\\\"\\\",\\\"profile\\\":true,\\\"scope\\\":[\\\"profile\\\"],\\\"upstream_params\\\":{\\\"blog\\\":{\\\"value\\\":\\\"myblog.wordpress.com\\\"}}}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"options\": [\n    \"client_id\": \"\",\n    \"profile\": true,\n    \"scope\": [\"profile\"],\n    \"upstream_params\": [\"blog\": [\"value\": \"myblog.wordpress.com\"]]\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/%7ByourWordpressConnectionId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nNow every time a user authenticates with this connection, the request to the Wordpress authorization endpoint will include the query parameter `blog=myblog.wordpress.com`.\n\n## Dynamic parameters\n\nUse dynamic parameters to configure your connection to send a set of parameters with values specific to the user to the IdP when they log in.\n\nTo configure dynamic parameters, call the Auth0 Management API [Create a connection](https://auth0.com/docs/api/management/v2/#!/Connections/post_connections) or [Update a connection](https://auth0.com/docs/api/management/v2/#!/Connections/patch_connections_by_id) endpoint, pass the `upstream_params` object in the `options` object with the parameters you'd like to send to the IdP, and specify the field that the parameter maps to with the `alias` attribute.\n\nHere's a sample `options` object that we'll revisit later in the X example:\n\n```\n{\n  \"options\": {\n    \"upstream_params\": {\n      \"screen_name\": {\n        \"alias\": \"login_hint\"\n      }\n    }\n  }\n}\n```\n\n### Available fields\n\nThese are the available fields for the `alias` attribute:\n\n*   `acr_values`\n    \n*   `audience`\n    \n*   `client_id`\n    \n*   `display`\n    \n*   `id_token_hint`\n    \n*   `login_hint`\n    \n*   `max_age`\n    \n*   `prompt`\n    \n*   `resource`\n    \n*   `response_mode`\n    \n*   `response_type`\n    \n*   `ui_locales`\n    \n\n### Example: X\n\nX allows you to pass an optional `screen_name` parameter to its OAuth authorization endpoint. The `screen_name` parameter pre-fills the username input box of the login screen with the given value. To learn more, read [X's API reference](https://developer.twitter.com/en/docs/basics/authentication/api-reference/authorize).\n\nTo follow this example, you'll need a working [Twitter Social connection](https://marketplace.auth0.com/integrations/twitter-social-connection).\n\n#### Get the connection\n\nCall the Management API [Get a connection](https://auth0.com/docs/api/management/v2#!/Connections/get_connections_by_id) endpoint to retrieve the existing values of the `options` object:\n\n*   [cURL](#b0ad98d286294affa31a04be0bb7fd43_shell)\n*   [C#](#b0ad98d286294affa31a04be0bb7fd43_csharp)\n*   [Go](#b0ad98d286294affa31a04be0bb7fd43_go)\n*   [Java](#b0ad98d286294affa31a04be0bb7fd43_java)\n*   [Node.JS](#b0ad98d286294affa31a04be0bb7fd43_node)\n*   [Obj-C](#b0ad98d286294affa31a04be0bb7fd43_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D',\n  headers: {\n    authorization: 'Bearer {yourMgmtApiAccessToken}',\n    'content-type': 'application/json'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe `options` object will look something like this:\n\n```\n\"options\": {\n  \"client_id\": \"thisismyid\",\n  \"client_secret\": \"thisismysecret\",\n  \"profile\": true\n}\n```\n\n#### Update the connection (dynamic)\n\nCopy the existing `options` object, add the `upstream_params` object with the `screen_name` field as an attribute, and then set the `alias` attribute to `login_hint`:\n\n```\n{\n  \"options\": {\n    \"client_id\": \"\", \n    \"profile\": true, \n    \"scope\": [\"profile\"],\n    \"upstream_params\": {\n      \"screen_name\": {\n        \"alias\": \"login_hint\"\n      }\n    }\n  }\n}\n```\n\nCall the Management API [Update a connection](https://auth0.com/docs/api/management/v2/#!/Connections/patch_connections_by_id) endpoint with the `options` object in the body:\n\n*   [cURL](#4b8d9e4ebf2b43ce8ea7b6d13ed48ecf_shell)\n*   [C#](#4b8d9e4ebf2b43ce8ea7b6d13ed48ecf_csharp)\n*   [Go](#4b8d9e4ebf2b43ce8ea7b6d13ed48ecf_go)\n*   [Java](#4b8d9e4ebf2b43ce8ea7b6d13ed48ecf_java)\n*   [Node.JS](#4b8d9e4ebf2b43ce8ea7b6d13ed48ecf_node)\n*   [Obj-C](#4b8d9e4ebf2b43ce8ea7b6d13ed48ecf_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"options\": {\"client_id\": \"{clientId}\", \"client_secret\": \"{clientSecret}\", \"profile\": true, \"upstream_params\": {\"screen_name\": {\"alias\": \"login_hint\"}}}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"options\\\": {\\\"client_id\\\": \\\"{clientId}\\\", \\\"client_secret\\\": \\\"{clientSecret}\\\", \\\"profile\\\": true, \\\"upstream_params\\\": {\\\"screen_name\\\": {\\\"alias\\\": \\\"login_hint\\\"}}}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\"\n\n\tpayload := strings.NewReader(\"{\\\"options\\\": {\\\"client_id\\\": \\\"{clientId}\\\", \\\"client_secret\\\": \\\"{clientSecret}\\\", \\\"profile\\\": true, \\\"upstream_params\\\": {\\\"screen_name\\\": {\\\"alias\\\": \\\"login_hint\\\"}}}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"options\\\": {\\\"client_id\\\": \\\"{clientId}\\\", \\\"client_secret\\\": \\\"{clientSecret}\\\", \\\"profile\\\": true, \\\"upstream_params\\\": {\\\"screen_name\\\": {\\\"alias\\\": \\\"login_hint\\\"}}}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D',\n  headers: {\n    authorization: 'Bearer {yourMgmtApiAccessToken}',\n    'content-type': 'application/json'\n  },\n  data: {\n    options: {\n      client_id: '{clientId}',\n      client_secret: '{clientSecret}',\n      profile: true,\n      upstream_params: {screen_name: {alias: 'login_hint'}}\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"options\": @{ @\"client_id\": @\"{clientId}\", @\"client_secret\": @\"{clientSecret}\", @\"profile\": @YES, @\"upstream_params\": @{ @\"screen_name\": @{ @\"alias\": @\"login_hint\" } } } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"options\\\": {\\\"client_id\\\": \\\"{clientId}\\\", \\\"client_secret\\\": \\\"{clientSecret}\\\", \\\"profile\\\": true, \\\"upstream_params\\\": {\\\"screen_name\\\": {\\\"alias\\\": \\\"login_hint\\\"}}}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"options\\\": {\\\"client_id\\\": \\\"{clientId}\\\", \\\"client_secret\\\": \\\"{clientSecret}\\\", \\\"profile\\\": true, \\\"upstream_params\\\": {\\\"screen_name\\\": {\\\"alias\\\": \\\"login_hint\\\"}}}}\"\n\nheaders = {\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"options\\\": {\\\"client_id\\\": \\\"{clientId}\\\", \\\"client_secret\\\": \\\"{clientSecret}\\\", \\\"profile\\\": true, \\\"upstream_params\\\": {\\\"screen_name\\\": {\\\"alias\\\": \\\"login_hint\\\"}}}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"options\": [\n    \"client_id\": \"{clientId}\",\n    \"client_secret\": \"{clientSecret}\",\n    \"profile\": true,\n    \"upstream_params\": [\"screen_name\": [\"alias\": \"login_hint\"]]\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/%7ByourXConnectionId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Call the login endpoint\n\nWhen you call the Authentication API [Login endpoint](https://auth0.com/docs/api/authentication#login) for a user, you can pass their email address to the `login_hint` parameter:\n\n```\nhttps://{yourDomain}/authorize\n  ?client_id={yourClientId}\n  &response_type=token\n  &redirect_uri={https://yourApp/callback}\n  &scope=openid%20name%20email\n  &login_hint=user@domain.com\n```\n\nThis value will then be passed to the X authorization endpoint as the `screen_name` parameter:\n\n```\nhttps://api.twitter.com/oauth/authorize\n  ?oauth_token={yourXAuthToken}\n  &screen_name=user@domain.com\n```",
  "title": "Pass Parameters to Identity Providers",
  "description": "Describes how to pass parameters to an Identity Provider API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/promote-connections-to-domain-level",
  "markdown": "# Promote Connections to Domain Level\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/CONNECTION_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"is_domain_connection\": true }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"is_domain_connection\\\": true }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/CONNECTION_ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"is_domain_connection\\\": true }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"is_domain_connection\\\": true }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/CONNECTION_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {is_domain_connection: true}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"is_domain_connection\": @YES };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/CONNECTION_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"is_domain_connection\\\": true }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"is_domain_connection\\\": true }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/CONNECTION_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/CONNECTION_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"is_domain_connection\\\": true }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"is_domain_connection\": true] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/CONNECTION_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Promote Connections to Domain Level",
  "description": "Learn how to promote a connection to domain level using the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa",
  "markdown": "# Enable Multi-Factor Authentication\n\nYou can enable multi-factor authentication (MFA) for your tenant in the Auth0 Dashboard.\n\nWhen you enable MFA, select the factors (such as push notifications or phone messages) you intend to make available to users and define a policy to determine when you require them to authenticate.\n\n## Select factors\n\nAuth0 supports a variety of factors you can enable for your users to complete authentication.\n\n### Independent factors\n\nYou must enable and configure at least one independent factor to require MFA for users on your tenant. You may enable multiple independent factors simultaneously as you’d like.\n\nAvailable independent factors are:\n\n*   [WebAuthn with FIDO Security Keys](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa)\n    \n*   [One-time Password (OTP)](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa)\n    \n*   [Push Notification using Auth0 Guardian](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa)\n    \n*   [Phone Message](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n    \n*   [Cisco Duo Security](https://auth0.com/docs/secure/multi-factor-authentication/configure-cisco-duo-for-mfa)\n    \n\n### Dependent factors\n\nYou may enable one or more dependent factors once you’ve already enabled and configured at least one independent factor for users on your tenant.\n\nAvailable dependent factors are:\n\n*   [WebAuthn with FIDO Biometrics](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa)\n    \n*   [Email](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-email-notifications-for-mfa)\n    \n*   [Recovery Code](https://auth0.com/docs/secure/multi-factor-authentication/configure-recovery-codes-for-mfa)\n    \n\n## Enable MFA in the Auth0 Dashboard\n\n1.  Go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa).\n    \n    ![Auth0 Dashboard Security Multi-Factor Authentication](https://images.ctfassets.net/cdy7uua7fh8z/4xrjmhY1cLhXhlygZKyN4f/3ec3b4cfc0d4e3ce178b519a0fb7df17/Dashboard_-_Security_-_MFA.png)\n2.  In the **Factors** section, enable and configure the factors you’d like to make available to users.\n    \n3.  In the **Define policies** section, select a policy to determine when users will be prompted for MFA.\n    \n    *   **Never**: MFA is not required for any logins.\n        \n    *   **Use Adaptive MFA**: MFA is required based on Auth0 risk determination. To learn more, read [Enable Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa).\n        \n    *   **Always**: MFA is required for all logins.\n        \n4.  If you choose the **Never** or **Always** policy, the **MFA Risk Assessors** section appears. By default, the **Enable Adaptive MFA Risk Assessment** setting is disabled. Enable the toggle to assess and record risk for all login transactions in your tenant logs.\n    \n5.  In the **Additional Settings** section, configure the following options as needed:\n    \n    *   **Show Multi-factor Authentication options:** Enable this toggle to allow users to select authentication factors upon enrollment. When disabled, Auth0 automatically presents the most secure authentication factors to users upon enrollment.\n        \n        ![Show Multi-factor Authentication options end user view](https://images.ctfassets.net/cdy7uua7fh8z/3Mo3EXUk3ZFK4hZKck0yOO/c6d0faf48fca2017ef17dc36c99a8f7f/image-20230308-003813.png)\n    *   **Customize MFA Factors using Actions**: Enable this toggle to customize your MFA flows using `post-login` [Actions](https://auth0.com/docs/customize/actions). This allows you to challenge users with a specific factor or sequence of factors, as well as use contextual information to create more individualized experiences. To learn more, review [Customize MFA Selection for Universal Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-selection-universal-login).\n        \n6.  Click **Save**.\n    \n\n## Customize MFA flow\n\nYou can use Auth0 Actions to customize the MFA flow for users on your tenant. For example, you can create an Action to require MFA in specific circumstances or to force a particular factor to be used.\n\nTo learn more, read [Customize Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-rules).\n\n## Learn more\n\n*   [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa)\n*   [Configure OTP Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa)\n*   [Configure SMS and Voice Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n*   [Configure Email Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-email-notifications-for-mfa)\n*   [Configure Cisco Duo Security for MFA](https://auth0.com/docs/secure/multi-factor-authentication/configure-cisco-duo-for-mfa)\n*   [Customize Multi-Factor Authentication Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa)",
  "title": "Enable Multi-Factor Authentication",
  "description": "Learn how to enable multi-factor authentication (MFA) in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa",
  "markdown": "# Adaptive MFA\n\nAdaptive MFA is a flexible, extensible MFA policy that can help you protect your tenant from bad actors without increasing friction for real users. It assesses potential risk during every login transaction, and then prompts the user for additional verification if appropriate.\n\n## How it works\n\nDuring a login transaction, Adaptive MFA calculates an overall confidence score based on analysis of three risk assessments:\n\n| **Assessor** | **Risk Signal** | **How it is computed** |\n| --- | --- | --- |\n| `NewDevice` | User attempts to sign in from a device that has not been used to access the account in the last 30 days. | User agent and browser cookies identify a device. At login time, the device information is compared to the list of devices for the account. |\n| `ImpossibleTravel` | User attempts to sign in from a geolocation that indicates an impossible travel situation when compared to the last login. | The distance between the last valid location and the location of the attempted sign in is computed; the time difference between the sign in attempt is used to compute a hypothetical travel velocity. Velocity is compared to a reasonable travel velocity. |\n| `UntrustedIP` | User attempts to sign in from an IP address known to be associated with suspicious behavior. | Auth0 uses intelligence from traffic events to determine the likelihood that the IP address has been used by bad actors to perpetrate high velocity attacks. |\n| Overall Risk Score | A combination of all 3 factors above. | Auth0 uses all 3 scores to assign an overall score. Use [Actions](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa) if you want to implement your own business logic. |\n\nWhen Adaptive MFA determines the overall confidence score is low (that the login transaction is high-risk), it requires the user to verify their identity with MFA. If the user is not enrolled in MFA, they are required to complete additional verification before they are eligible to do so.\n\nAdaptive MFA includes a comprehensive security flow that ensures the authenticity of users:\n\n![Auth0 Login Adaptive multi-factor authentication flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/6NpeGW8jtQIma1jTVydW7U/731ec743802098372a2164300a15c402/adaptive-mfa-flow.png)\n\nAdaptive MFA ignores any and all existing MFA sessions (for example, a user selected **Remember this browser** during a previous MFA flow), and does not allow users to bypass MFA challenges.\n\n## Customize Adaptive MFA\n\nYou can use Actions to customize the MFA flow and provide the best experience for your users.\n\nTo learn more about risk assessments, confidence scores, and customization options, read [Customize Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa).\n\n## Support and limitations\n\nAdaptive MFA is supported by all authentication and authorization flows that start with the end user. To learn more about the different flows and protocols, read [Authentication and Authorization Flows](https://auth0.com/docs/get-started/authentication-and-authorization-flow) and [Protocols](https://auth0.com/docs/authenticate/protocols).\n\n| **Protocol** | **Flow** | **Supported** |\n| --- | --- | --- |\n| OIDC/OAuth2 | Authorization Code Flow | Supported |\n| OIDC/OAuth2 | Authorization Code Flow with PKCE | Supported |\n| OIDC/OAuth2 | Implicit Flow with Form Post | Supported |\n| OIDC/OAuth2 | Hybrid Flow | Supported |\n| OIDC/OAuth2 | Client Credentials | Not supported |\n| OIDC/OAuth2 | Device Authorization | Not supported |\n| OIDC/OAuth2 | Resource Owner Password (ROP) | Not supported |\n| SAML | Service Provider-Initiated (SP-initiated) | Supported |\n| SAML | Identity Provider-Initiated (IdP-initiated) | Not supported\\* |\n| WS-Federation | N/A | Supported |\n| AD/LDAP | N/A | Supported |\n\n\\*Adaptive MFA is not supported for SAML IdP\\-initiated flows, but you can simulate the flow with OIDC applications. To learn more, read [Configure IdP-Initiated SAML Sign-on to OIDC Apps](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-idp-initiated-saml-sign-on-to-oidc-apps).\n\nAdaptive MFA is fully supported for social connection types where an email address is available for each user.\n\nAdaptive MFA requires an email address to complete the email challenge step that occurs when a user is not enrolled in MFA. If an email address is not available, Adaptive MFA cannot perform the email challenge and the transaction will be blocked. This scenario does not introduce a security risk, but it does limit the functionality of the feature.\n\nIf you’ve set up a social connection, and expect an email address to be available but it’s not, verify your configuration and confirm that the correct scopes, claims, and permissions are being requested. To learn more about supported social connections and how to install them, read [Social Connections on Auth0 Marketplace](https://marketplace.auth0.com/features/social-connections).\n\n### Auth0 features\n\nThe following table lists Auth0 implementations and their functionality with Adaptive MFA:\n\n| **Login Flow Implementation** | **Adaptive MFA Support Level** |\n| --- | --- |\n| Universal Login | Supported |\n| Classic Login with no customization | Supported |\n| Classic Login (hosted by Auth0), custom login page with `lock.js` Lock template | Supported |\n| Classic Login (hosted by Auth0), custom login page with `auth0.js` Custom Login Form template | Supported |\n| Classic Login (hosted by Auth0), custom login page with email passwordless flow and `lock.js` Passwordless template | Supported |\n| Classic Login (hosted by Auth0), custom login page with SMS passwordless flow and `lock.js` Passwordless template | Not supported, because it does not make an email address available, which is a requirement. |\n| Web or native apps using Resource Owner Password Grant (ROPG) flow (including those using older versions of `lock.android` and `lock.swift` SDKs | Supported, with the following limitations:  <br>• Works when all end users are already enrolled in MFA (when users are required to enroll on signup). Users who are not already enrolled will be blocked in risky scenarios.  <br>• Risk assessment to determine if a user is logging in from a new device will not work. The ROPG flow does not support the browser cookies needed to determine risk.  <br>• You must pass `auth0-forwarded-for` header with information from the originating IP address for risk assessments for IP reputation to work. |\n| Native apps using newest version of SDKs that support embedded Universal Login | Supported |\n| Native apps using newest version of SDKs and ROPG flow | Supported with the following limitations:  <br>• Works when all end users are already enrolled in MFA (when users are required to enroll on signup). Users who are not already enrolled will be blocked in risky scenarios.  <br>• Risk assessment to determine if a user is logging in from a new device will not work. The ROPG flow does not support the browser cookies needed to determine risk.  <br>• You must pass `auth0-forwarded-for` header with information from the originating IP address for risk assessments for IP reputation to work. |\n| Flows hosted by you (not Auth0) using `lock.js` or `auth0.js` that perform cross-origin authentication (co/authenticate endpoint) | Supported |\n\n## Learn more\n\n*   [Enable Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/enable-adaptive-mfa)\n*   [Customize Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/customize-adaptive-mfa)\n*   [Adaptive MFA Log Events](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa/adaptive-mfa-log-events)",
  "title": "Adaptive MFA",
  "description": "Learn about Adaptive MFA, including how it works, how to customize it, and what flows are supported.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/configure-cisco-duo-for-mfa",
  "markdown": "# Configure Cisco Duo Security for MFA\n\nCisco Duo is a multi-faceted authentication provider and can only be used on your Auth0 tenant if all other factors are disabled. Your Duo account can support push notifications, SMS, OTP, phone callback, and more based on your configuration.\n\nYou cannot also enable Duo if other factors are enabled. Duo is only available to users when it is the sole factor enabled.\n\nThe application will prompt the user for the second factor with Duo, listing the options you have enabled in your Duo account.\n\n![Security Multi-Factor Authentication Cisco Duo Security Login screen example](https://images.ctfassets.net/cdy7uua7fh8z/t2OF0hjHWOPWk3GK5HrcP/d06ef1e506941e177a34e9a697eb9e4b/duo-login.png)\n\nYour users can download Duo from [Google Play](https://play.google.com/store/apps/details?id=com.duosecurity.duomobile) or the [App Store](https://itunes.apple.com/us/app/duo-mobile/id422663827?mt=8) for use as a second factor.\n\n## Configure Duo\n\nTo configure Duo Security, you must pass your Duo credentials to your application in the Auth0 Dashboard.\n\n1.  Go to [Dashboard > Security > Multi-factor Auth > Duo Security](https://manage.auth0.com/#/security/mfa/duo) and enable it.\n    \n2.  Enter the information in the fields to link your Duo account to Auth0.\n    \n    ![Dashboard - Security - Multifactor Auth - Duo Security](https://images.ctfassets.net/cdy7uua7fh8z/7k9AG9OfFJNCbaz4UoFXkq/cf5d3f9b9a052e15d17eb58cc1a26703/Duo_Security_-_Config_Screen__large_.png)\n3.  Select **Save**.\n    \n\n## Use Actions to enable Duo\n\nTo enable Duo within an Action, pass `duo` as the `provider` parameter when you enable multi-factor authentication.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  api.multifactor.enable('duo', { allowRememberBrowser: false });\n};\n```\n\nDuo does not provide an option for \"Remember Me\" behavior. The 30-day MFA session is hard-coded to remember the user after the initial login.\n\nTo force your users to log in with Duo every time, create a rule with `allowRememberBrowser: false`.\n\n## Actions template for Duo\n\nThis template provides an example and starting point to trigger multi-factor authentication with [Duo Security](http://duosecurity.com/) when a condition is met.\n\nUpon first login, the user can enroll the device.\n\nto configure this snippet with your account\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\n\tconst CLIENTS_WITH_MFA = ['{yourClientId}'];\n\t// run only for the specified clients\n\tif (CLIENTS_WITH_MFA.includes(event.client.client_id)) {\n\n\t\t// uncomment the following if clause in case you want to request a second factor only from user's that have user_metadata.use_mfa === true\n\t\t//if (event.user.user_metadata && event.user.user_metadata.use_mfa){\n\n\t\t// optional, defaults to true. Set to false to force DuoSecurity every time.\n\t\t// See https://auth0.com/docs/multifactor-authentication/custom#change-the-frequency-of-authentication-requests for details\n\t\tapi.multifactor.enable('duo', {\n\t\t\tproviderOptions.ikey: configuration.DUO_IKEY,\n\t\t\tproviderOptions.skey: configuration.DUO_SKEY,\n\t\t\tproviderOptions.host: configuration.DUO_HOST,\n\t\t\tallowRememberBrowser: false\n\t\t})\n\n\t\t// optional. Use some attribute of the profile as the username in DuoSecurity. This is also useful if you already have your users enrolled in Duo.\n\t\t// username: event.user.nickname\n\t};\n\t// }\n\n};\n```\n\n## Current limitations\n\n*   You cannot use [Auth0 MFA Enrollment Tickets](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets) to enroll users with Duo. Onboard those users from Duo itself.\n    \n*   If you use Universal Login, you must enable Duo in an Action with `provider` set to `duo` as described previously. You can conditionally use Duo or the built-in Auth0 provider for specific applications.\n    \n\n## Learn more\n\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
  "title": "Configure Cisco Duo Security for MFA",
  "description": "Describes how to configure Cisco Duo Security for MFA.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn",
  "markdown": "# FIDO Authentication with WebAuthn\n\nThe Web Authentication API (also known as WebAuthn) is a [specification](https://www.w3.org/TR/webauthn/) written by the W3C and FIDO, with the participation of Google, Mozilla, Microsoft, Yubico, and others. The API allows users to be authenticated using public key cryptography.\n\nWebAuthn is the most secure and usable authentication method on the web. Some key reasons for this are:\n\n*   It minimizes login friction. A simple and familiar gesture lets users authenticate.\n    \n*   It's the only web authentication method that is phishing resistant.\n    \n*   It's standard based and implemented across browsers and operating systems\n    \n\nWebAuthn let users authenticate with two types of authenticators:\n\n*   **Roaming authenticators** are removable and cross-platform, like a Yubikey, and can be used on multiple devices. To authenticate with a roaming authenticator, you need to connect it to the device (through USB, NFC, or Bluetooth), provide proof of presence (by touching it, for example), and optionally provide user verification, for example, by entering a PIN.\n    \n*   **Platform authenticators** are attached to a device and only work on that device. Some examples are MacBook’s TouchBar, Windows Hello, iOS Touch/FaceId, and Android’s fingerprint/face recognition. Biometric data is stored on the device and never sent to the server. When biometrics cannot be used, alternative authentication methods are usually provided. For example, if you are wearing a mask, instead of using Face ID you can enter your passcode.\n    \n\n## WebAuthn and Web Origins\n\nWebAuthn works by generating a private/public key pair for each [web origin](https://en.wikipedia.org/wiki/Same-origin_policy) which are registered in the device or security key.\n\nSince the key pair is bound to the domain, users are protected from phishing attacks. If the attacker tricks them into using WebAuthn in a different domain, the WebAuthn authenticator will not have a key pair for that domain and authentication will fail. The attacker will not get any data that can identify the user.\n\n## Roaming Authenticators\n\nTo learn how to enable roaming authenticators in Auth0, check the [WebAuthn with Security Keys](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa) documentation.\n\nThe default enrollment flow for security keys in Android displayed below and has the following steps:\n\n*   Users authenticate with username/password.\n    \n*   They are prompted to select the authentication method they want to enroll.\n    \n*   If they pick Security Keys, they are shown a list of instructions.\n    \n*   They are then prompted to enter their security key.\n    \n*   The device shows their native UI to complete the security key challenge.\n    \n*   Users can name the key to later identify it, in case they enroll multiple ones.\n    \n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/47W86ZLKHPc2GjhvBFSvlu/6de067c6c446fab92641d25032840205/security-key-enrollment.png)\n\nIn the challenge flow, the user is prompted for the security key and then it calls the native user interface for the device, which in this example is Android:\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/6cATwflHcqYECdI0J75AXi/1802a4b44aa394b2d7885ccfbaa299be/security-key-challenge.png)\n\n## Platform Authenticators\n\nTo learn how to enable platform authenticators, check the [Webauthn with Device Biometrics](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa) documentation.\n\nGiven platform authenticators can only be used in a single device, it **should not be the only factors that users enroll.** To make sure users are not locked out from their accounts, Auth0 will prompt users to enroll with platform authenticators after they succesfuly authenticated using another authentication method.\n\nAuth0 will try to **progressively enroll** all users' devices. Users will be prompted to enroll their devices' platform authenticators in each device they use.\n\nThe default enrollment flow for Face ID in iOS is displayed below and has the following steps:\n\n*   Users authenticate with username/password.\n    \n*   They enroll another MFA authentication method, like [SMS](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa), [Push](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa) or [Time-Based OTP](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa).\n    \n*   They name their device, to identify it later.\n    \n\n![Device Biometrics MFA Enrollment](https://images.ctfassets.net/cdy7uua7fh8z/1lGCq8BMA0rdkbiG3WZXWr/db44bb26054e6fadc540140f65bbc026/image.png)\n\nThe next time they login from that device, users enter their username/password and complete MFA with their device biometric authenticator.\n\n![WebAuthn Device Biometrics MFA Challenge](https://images.ctfassets.net/cdy7uua7fh8z/Y9gbCvOtQ3uEm7a0lPQwS/1244401ecd935586cf2433173e659751/image.png)\n\n## WebAuthn as Multi Factor Authentication\n\n## Webauthn.me\n\nAuth0 maintains [webauthn.me](https://a0.to/webauthme-auth0-docs), which has [detailed information](https://webauthn.me/introduction) about WebAuthn and an up-to-date list of browsers supporting WebAuthn.\n\n## Learn more\n\n*   [Configure WebAuthn with Device Biometrics for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa)\n*   [Configure WebAuthn with Security Keys for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa)",
  "title": "FIDO Authentication with WebAuthn",
  "description": "Describes Web Authentication API (WebAuthn) and FIDO-based authentication and how it works with Auth0 multi-factor authentication. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/webauthn-as-mfa",
  "markdown": "# WebAuthn as Multi-Factor Authentication\n\nWhen users authenticate with WebAuthn, they use something **they have** as an authentication factor: a security key, or a device.\n\nBoth Security Keys and Device Biometrics support **user verification**, which requires users provide something **they know** (a PIN or a passcode) and something **they are** (like biometric traits).\n\nWhen using Device Biometrics, user verification is always performed. To perform verification with Security Keys, you [need to configure Auth0](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa) to require a PIN. Then users will be asked to enter a PIN, which is only stored in the security key, to complete authentication. Now when user verification is performed, users can login with WebAuthn as the only authentication method to achieve multi-factor authentication.\n\nBy using WebAuthn for authentication combined with user verification, you not only replace the password with something much simpler to use, you also remove the need of having another authentication step when requiring MFA.\n\n## Webauthn.me\n\nAuth0 maintains [webauthn.me](https://a0.to/webauthme-auth0-docs), which has [detailed information](https://webauthn.me/introduction) about WebAuthn and an up-to-date list of browsers supporting WebAuthn.",
  "title": "WebAuthn as Multi-Factor Authentication",
  "description": "Brief overview of how WebAuthn works as a factor for MFA",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication",
  "markdown": "# Add Step-up Authentication\n\nWith step-up authentication, applications that allow access to different types of resources can require users to authenticate with a stronger authentication mechanism to access sensitive resources.\n\nYou can add step-up authentication to your app with Auth0's extensible multi-factor authentication (MFA) support. Your app can verify that the user has logged in using MFA and, if not, require the user to step-up to access certain resources.\n\n## How it works\n\nAs an example, Fabrikam's Intranet requires users to authenticate with their username and password to access customer data. However, a request for access to employee data (which may contain sensitive salary information) triggers a stronger authentication mechanism like MFA.\n\n![MFA Step-up Authentication flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/3w3duzjtD5B2Nu3oVQcbh/22d3a24aa3c3054fa089effbfa9d654c/step-up-flow.png)\n\n## Step-up Authentication for APIs\n\nWhen your audience is an API, you can implement step-up authentication with Auth0 using [scopes](https://auth0.com/docs/get-started/apis/scopes), [access tokens](https://auth0.com/docs/secure/tokens/access-tokens), and [Actions](https://auth0.com/docs/customize/actions). You can use an Action to trigger the step-up authentication mechanism (for example, prompt MFA) whenever the user requests scopes that map to sensitive resources.\n\nIn our example, a user signs into Fabrikam's web app. The standard login gives to this user the ability to interact with their API and fetch the user's account list. This means that the access token that the application receives after the user authentication contains a scope like `read:accounts`.\n\nNow the user wishes to transfer funds from one account to another, which is deemed a high-value transaction. In order to perform this action, the API requires the scope `transfer:funds`.\n\nThe user's current access token does not include this scope and the application knows it (because the application knows the set of scopes it requested in the initial authentication call). The application performs another authentication call, but this time it requests the scope `transfer:funds`. The browser redirects to Auth0. Per Fabrikam's Action, Auth0 challenges the user to authenticate with MFA because a high-value scope was requested. Once the user successfully authenticates with MFA, Auth0 generates and sends a new access token that includes the high-value scope. The application passes the access token to the API, which discards it after verification, thereby treating it as a single-use token.\n\nTo learn more, read [Configure Step-up Authentication for APIs](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-apis).\n\n## Step-up Authentication for web apps\n\nIf it is a web app that verifies the authentication level, and not an API, then you do not have an access token. In this case, you can check if a user has logged in with MFA by reviewing the contents of their ID token. You can then configure your application to deny access to pages with sensitive information if the ID token indicates that the user did not log in with MFA, and use an Action to trigger the step-up authentication mechanism (for example, prompt MFA). For example, you might have an employee app that authenticates users with usernames and passwords, but if a user wants to access salary information, they have to provide a second factor such as a mobile push notification.\n\nYou can implement this by checking the ID token when the user tries to access that page. If the claims show that the user already has authenticated with MFA then display the sensitive information. Otherwise, trigger authentication again and, using an Action, prompt the user to authenticate with MFA.\n\nTo learn more, read [Configure Step-up Authentication for Web Apps](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-web-apps).\n\n## Learn more\n\n*   [Configure Step-up Authentication for APIs](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-apis)\n*   [Configure Step-up Authentication for Web Apps](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-web-apps)",
  "title": "Add Step-up Authentication",
  "description": "Describes how step-up authentication works for APIs and web apps to verify that the user has logged in using MFA and if not, require the user to step-up to access certain resources.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian",
  "markdown": "# Auth0 Guardian\n\nAuth0 Guardian is a mobile application for iOS and Android devices that allows users to complete [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) with push notifications or temporary one-time passwords.\n\nAuth Guardian can deliver push notifications to users’ enrolled devices (typically mobile phones or tablets) or generate one-time passwords directly within the app. Users can then quickly respond to these push notifications or retrieve a one-time password to complete their login.\n\nUsers can download the Auth0 Guardian app from the [Apple App Store](https://apps.apple.com/us/app/auth0-guardian/id1093447833) or the [Google Play Store](https://play.google.com/store/apps/details?id=com.auth0.guardian). Alternatively, you can embed Auth0 Guardian capabilities in your own custom app using the Guardian SDK.\n\n## Push Notifications\n\nIn order to use push notifications, users must have either the Auth0 Guardian app or a custom app built with the Guardian SDK installed on their device. When a user attempts to authenticate, push notifications are sent to the installed app. The user must respond to the notification to complete their login, proving they both know their login information and possess the device set up for MFA. \n\nAuth0 push notifications can be implemented using AWS Simple Notification Service (SNS) or one or more of the following direct-to-vendor services to configure vendor-specific integrations:\n\n*   Firebase Cloud Messaging (FCM)\n    \n*   Apple Push Notification (APN)\n    \n\n![Auth0 Guardian flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/TdN0nXfYs0mqHpi9U3JQ9/7bf919773ed8f94c7d5be25cc345eebd/diagram.png)\n\n### Enroll in push notifications\n\nWhen you use Auth0 Guardian to configure push notifications, users are prompted to download the mobile app when they first sign up or log in to your application. If you use the Guardian SDK to implement push notifications in a custom app, users are not prompted to download any applications during enrollment.\n\nYou can enable push notifications from the Auth0 Dashboard under [Security > Multi-factor Auth > Push Notification using Auth0 Guardian](https://manage.auth0.com/#/security/mfa/guardian).\n\n![Auth0 Dashboard > Security > Multi-factor Auth > Push Notification using Auth0 Guardian](https://images.ctfassets.net/cdy7uua7fh8z/fwjSKFNhsvObzdPDiA79N/65850980f88029cb23eef5eaef4f9b20/Auth0_Dashboard_-_Push_Notification_screen.png)\n\nWhen a user first signs up or logs in to your application, [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) provides a QR code they can use to register the Auth0 Guardian app or custom Guardian SDK app as a secondary authentication factor. The user has a short amount of time to scan this code with the designated app to complete their enrollment.\n\nAfter the user enrolls, they can use push notifications as an authentication factor. Whenever the user attempts to log in to your application, they will receive a push notification on their device via the Auth0 Guardian or custom Guardian SDK app. The user must approve this request to successfully log in to your application.\n\nTo learn how to reset MFA for users who have lost their devices or recovery codes, review [Reset Multi-Factor Authentication and Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa). For additional assistance, review [Troubleshooting Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues).\n\n## Temporary one-time passwords\n\nThe Auth0 Guardian app and the Guardian SDK also support the use of temporary one-time passwords (OTPs) as secondary authentication factors. Both the app and the SDK can generate temporary OTPs that users can use to complete Universal Login MFA challenges. \n\nBy default, the Auth0 Guardian app lists the user’s enrolled applications. After selecting an application, the corresponding OTP for that application displays. Each 6-digit OTP remains valid for 30 seconds. OTPs that are nearing expiration display in red. Upon expiration, the app immediately generates a new OTP. To avoid failed authentications, users should not use any red OTPs\n\nIn custom Guardian SDK apps, OTP appearance may vary.\n\n### Use temporary one-time passwords\n\nYou can leverage OTPs in two primary ways:\n\n*   As a fallback option to push notifications in the event that the Auth0 Guardian app or other custom app does not receive a push request.\n    \n*   As an [MFA challenge](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors) if you enable the One-Time Password factor [in your tenant](https://manage.auth0.com/#/security/mfa).\n    \n\n## Auth0 Guardian app settings\n\n### User security settings\n\nIn the Auth0 Guardian app, users can enable passcodes and biometrics as layers of app security on iOS and Android. If a user enables one or more of these options, they must complete these challenges before they can respond to push notifications or retrieve one-time passwords. \n\nTo enable these options on iOS or Android devices, users can follow the steps below.\n\nTo enable security settings for the Auth0 Guardian app on iOS: \n\n1.  In the app, select the **gear icon** to open the Settings menu. \n    \n2.  Select **Passcode** to enable passcode protection. \n    \n3.  Set and confirm a 6-digit passcode. \n    \n\nThe app is now protected by the passcode. The user must enter this passcode before they can respond to push notifications or retrieve OTPs.\n\n![The Settings menu from the Auth0 Guardian app on iOS devices](https://images.ctfassets.net/cdy7uua7fh8z/6l3sP6IjmSzJmED3Am8pna/82a5517b7639814b8a3d9bd4138a9d70/iOS_settings-small.png)\n\nAfter enabling passcode protection, the user can configure device biometrics as an alternate security measure. To enable device biometrics:\n\n1.  In the app, select the **gear icon** to open the Settings menu.\n    \n2.  Enable device biometrics by selecting one of the available options, such as **Face ID** or **Touch ID**. \n    \n\n### Localization options\n\nThe Auth0 Guardian app supports localization for multiple languages and dialects on iOS and Android.\n\nIn the Language section of the Settings menu, users can select their preferred language. By default, the app uses the same language as the device system.\n\nThe Auth0 Guardian app supports the following languages and dialects:\n\n| **Language** | **Code** |\n| --- | --- |\n| Basque | `eu-ES` |\n| Bosnian | `bs` |\n| Bulgarian | `bg` |\n| Catalan | `ca-ES` |\n| Croatian | `hr` |\n| Czech | `cs` |\n| Chinese (Simplified) | `zh-CN` |\n| Chinese (Traditional) | `zh-TW` |\n| Danish | `da` |\n| Dutch | `nl` |\n| English | `en` |\n| Estonian | `et` |\n| Finnish | `fi` |\n| French | `fr-FR` |\n| French (Canada) | `fr-CA` |\n| Galician | `gl-ES` |\n| German | `de` |\n| Greek | `el` |\n| Hindi | `hi` |\n| Hungarian | `hu` |\n| Indonesian | `id` |\n| Italian | `it` |\n| Icelandic | `is` |\n| Latvian | `lv` |\n| Lithuanian | `lt` |\n| Japanese | `ja` |\n| Korean | `ko` |\n| Norwegian | `no` |\n| Norwegian (Bokmål) | `nb` |\n| Norwegian (Nynorsk) | `nn` |\n| Polish | `pl` |\n| Portuguese (Brazil) | `pt-BR` |\n| Portuguese (Portugal) | `pt-PT` |\n| Romanian | `ro` |\n| Russian | `ru` |\n| Serbian | `sr` |\n| Slovak | `sk` |\n| Slovenian | `sl` |\n| Spanish | `es` |\n| Spanish (Argentina) | `es-AR` |\n| Swedish | `sv` |\n| Thai | `th` |\n| Turkish | `tr` |\n| Ukrainian | `uk` |\n| Vietnamese | `vi` |\n| Welsh | `cy` |\n\n### Guardian app themes\n\nThe Auth0 Guardian app for both iOS and Android supports light and dark mode themes.\n\nIn the Theme section of the Settings menu, users can select the following options:\n\n*   **System**: Uses default system theme\n    \n*   **Light**: Enables the light mode theme\n    \n*   **Dark**: Enables the dark mode theme\n    \n\n### Customization options for protected applications\n\nTo make it easier for users to distinguish between their protected applications in the Auth0 Guardian app, each application can be customized with a distinct name, accent color, and icon. \n\nTo customize a protected application:\n\n1.  Select an application from the list.\n    \n    *   **Tip**: You can also swipe left on the application to reveal Edit and Delete options. \n        \n2.  On the Account Detail page, choose **Edit**. \n    \n3.  Update the application’s name, color, and icon as needed.\n    \n4.  Select **Save**.\n    \n\n![The Account Edit screen of the Auth0 Guardian app displaying customization options](https://images.ctfassets.net/cdy7uua7fh8z/2dXh2M3Rp0oWoJdVFyvRCl/6e77dba1028f598019ba10b608cf8c67/Application_customization_options-small.png)\n\n## Guardian SDKs\n\nYou can [install the Guardian SDK](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/install-guardian-sdk) (available for [iOS](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk) and [Android](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk)) to build your own multi-factor authentication application with complete control over the branding and look-and-feel. With the Guardian SDK, you can build your own custom mobile applications that work like Guardian or integrate some Guardian functionalities, such as receiving push notifications in your existing mobile applications. A typical scenario could be for a banking app. You can use the Guardian SDK in your existing mobile app to receive and confirm push notifications when someone performs an ATM transaction.\n\n## Use Actions to enable Multi-Factor with Auth0 Guardian\n\nTo enable Auth0 Guardian within an Action, pass `guardian` as the `provider` parameter when you enable multi-factor authentication:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  api.multifactor.enable('guardian', { allowRememberBrowser: false });\n};\n```\n\nTo force your users to log in with Auth0 Guardian every time, create the Action with `allowRememberBrowser: false`.\n\nThis template provides an example and starting point to trigger multi-factor authentication with Auth0 Guardian for push notifications when a condition is met.\n\nUpon first login, the user can enroll the device. See [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa) for more information about MFA.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\nconst groups = event.user.app_metadata.authorization.groups;\nconst GROUPS_WITH_MFA = {\n// Add groups that need MFA here\n// Example\nadmins: true\n};\n\nconst needsMFA = !!groups.find(function (group) {\nreturn GROUPS_WITH_MFA[group];\n});\n\nif (needsMFA) {\n// optional, defaults to true. Set to false to force Guardian authentication every time.\n// See https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa#change-frequency-of-mfa-prompts for details\napi.multifactor.enable('guardian', { allowRememberBrowser: false });\n}\n\n};\n```\n\n## Learn more\n\n*   [Install Guardian SDK](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/install-guardian-sdk)\n*   [Guardian.swift iOS SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk)\n*   [Guardian for Android SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk)\n*   [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa)\n*   [Reset User Multi-Factor Authentication and Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa)\n*   [Guardian Error Code Reference](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/guardian-error-code-reference)",
  "title": "Auth0 Guardian",
  "description": "Describes how Guardian works and how the Guardian SDK helps you build your own authenticator and Guardian-like applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/configure-recovery-codes-for-mfa",
  "markdown": "# Configure Recovery Codes for MFA\n\nA recovery code is a unique code, generated by Auth0, allowing a user to regain account access. So if a user cannot access the device or account used for multi-factor authentication (MFA) enrollment, they can use a recovery code to authenticate.\n\n## How it works\n\nWhen using Universal Login with recovery codes enabled:\n\n1.  A user starts MFA enrollment.\n    \n2.  Auth0 generates a recovery code.\n    \n3.  During MFA enrollment the user is shown the recovery code prompt.\n    \n4.  The user saves the recovery code and completes the enrollment process.\n    \n5.  Now the user can complete MFA with the recovery code they saved if they lose access to their device or account they enrolled for MFA.\n    \n\n![Example recovery code prompt during multi-factor authentication enrollment](https://images.ctfassets.net/cdy7uua7fh8z/6LkXKthRal1r4vIPi3137l/b8e3fe552e37ab8dcdcb57df0b24b813/recovery-code-prompt.png)\n\nWhen using Universal Login with recovery codes disabled:\n\n*   Users will not see the recovery code prompt during MFA enrollment.\n    \n*   Users cannot authenticate with a recovery code.\n    \n\n## Enable recovery codes\n\nRecovery codes are disabled by default. You can enable recovery codes by going to [Dashboard > Security > Multifactor Auth](https://manage.auth0.com/#/security/mfa).\n\n## Learn more\n\n*   [Challenge with Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes)",
  "title": "Configure Recovery Codes for MFA",
  "description": "How to configure recovery codes for multi-factor authentication.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis",
  "markdown": "# Manage Authentication Factors with APIs\n\nAuth0 provides two different APIs to help you and your users manage MFA authentication factors.\n\n## Auth0 Authentication API\n\nUse the [Authentication API Multi-factor Authentication endpoints](https://auth0.com/docs/api/authentication#multi-factor-authentication) to allow your users to manage their own MFA authentication factors.\n\nThis method relies on authenticating using the Resource Owner Password Grant (ROPG) authentication flow. To learn more, read [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authentication-methods-with-management-api).\n\n## Auth0 Management API\n\nUse the [Management API Users endpoints](https://auth0.com/docs/api/management/v2) to manage your users' MFA authentication factors.\n\nThis method relies on authenticating using a confidential application. To learn more, read [Manage Authentication Methods with Management API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authentication-methods-with-management-api).\n\n## Learn more\n\n*   [Manage Authentication Methods with Management API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authentication-methods-with-management-api)\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)",
  "title": "Manage Authentication Factors with APIs",
  "description": "Learn how to manage MFA authentication factors with the Authentication API and Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa",
  "markdown": "# Reset User Multi-Factor Authentication and Recovery Codes\n\nIf a user has lost their mobile device, they can use their recovery code to log in. If they do not have a recovery code, they will need their tenant administrator to reset their multi-factor authentication (MFA). This action is equivalent to removing or deleting the user's MFA registration. The MFA settings associated with the user will be removed, which allows them to set up MFA as if they were a new user on their next login attempt. To reset an admin's MFA as opposed to an end user's MFA, please contact [Auth0 Support](https://auth0.com/docs/troubleshoot/customer-support).\n\n## Use the Dashboard\n\n1.  Go to [Dashboard > Users Management > Users](https://manage.auth0.com/#/users).\n    \n2.  Click on the user whose MFA you want to reset.\n    \n3.  Click on the **Actions** button on the top right of the screen.\n    \n4.  Select **Reset Multi-factor** from the dropdown. Admins will also see a **Reset MFA** link at the bottom of the **Multi-Factor Authentication** tab of the **User Details** page if the user is already enrolled in MFA. Both these methods function the same way. There will be a pop-up box to confirm your decision.\n    \n5.  Click **Yes, reset it** to reset the user's MFA.\n    \n\nThe next time the user logs in, they will need to set up their MFA just like a new user.\n\n## Use the Management API\n\nAs an admin, you can also use the Management API to delete a user's MFA enrollment using `DELETE` `/api/v2/users/{id}/authentication-methods`. If the user has more than one enrollment, you will need to repeat the process for each enrollment.\n\n## Recovery codes\n\nWith most MFA factors, the end user will be given a recovery code upon signup, which should be noted and kept secret. If they do not have their device or are otherwise temporarily unable to use their normal MFA process, the user can log in by entering this code after their username and password. If a recovery code is used, a new recovery code will be provided at that time.\n\n![Reset User MFA Recovery Code example](https://images.ctfassets.net/cdy7uua7fh8z/P4BtAvr47zyL2kqhRHTro/3d7f49d9d476270db43c45eb65283e62/recovery-code.png)\n\nIf a user uninstalls then later re-installs Guardian, they may be prompted to enter their recovery code. If the recovery code has been lost, the user can perform a new installation of the app by disabling automatic restoration of their Guardian backup. To do so, the user will need to uninstall Guardian, temporarily disable automatic restoration of backups within their device settings (steps to do so will vary according to the device), then re-install the app. They will then need to add their MFA account(s) to the app as if performing a first-time setup. If automatic backups or automatic restoration are not enabled on the user's device, re-installation of the app will not prompt for a recovery code and the user will be required to add their MFA account(s) as in a first-time configuration.\n\n## Learn more\n\n*   [Reset Account Passwords](https://auth0.com/docs/troubleshoot/customer-support/reset-account-passwords)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
  "title": "Reset User Multi-Factor Authentication and Recovery Codes",
  "description": "Learn how to reset a user's MFA in case they lose their mobile device and do not have a recovery code.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues",
  "markdown": "# Troubleshoot Multi-Factor Authentication Issues\n\n## User issues\n\n### If you do not have your mobile device or your mobile device is turned off\n\nIf you have lost your device, you can finish authentication using the recovery code provided when you first signed up.\n\n1.  Enter your email and password to log in, and click the **Use the recovery code** link.\n    \n2.  Enter your recovery code.\n    \n\nIf you no longer have your recovery code, you will not be able to log in. Contact your system administrator for help accessing your account.\n\n### If you forget your password\n\nIf you have forgotten your password, click the **Don't remember your password?** link located underneath the email and password fields. Then, enter your email address to receive an email containing a link you can use to reset your password.\n\n### If your transaction expires\n\nWhen logging in via MFA, there is a five-minute maximum between providing your first and second factors. You can see how much time has elapsed since you logged in using the first factor by checking the timestamp on the messages provided.\n\nIf more than five minutes have elapsed, you will need to log in again and obtain a new code or notification.\n\nIf you are requesting SMS messages, make sure you are not exceeding rate limits.\n\n### If you need to remove or delete MFA from a user in your tenant\n\nIf you need to remove, delete, or reset MFA for a user, you should [reset MFA](https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa).\n\n### If you did not receive an SMS message\n\nIf you did not receive your six-digit code via SMS, check that the phone number you provided is correct. If it is, make sure you have a cellular signal.\n\nIf you still are not receiving the messages, check with your service provider to confirm that messages are not getting blocked.\n\n### SMS message rate limits\n\nIf you attempt to send more than ten SMS messages to your device within one hour, you will see an error message about a rate limit exception.\n\nWhen you exceed your messaging limit, you'll need to wait at least an hour after your request for your first message before requesting another. You will receive an additional attempt after the passage of each additional hour.\n\n## Rejected codes\n\nIf the 6-digit code in the Guardian or the Google Authenticator app is being rejected for sign in (often with the message `Incorrect Code`), first check that you are selecting the right application from the list in your authenticator app. If you've verified that you're selecting the correct application, make sure that your mobile device's clock settings are correct. One-time passwords are generated using Coordinated Universal Time (UTC), so your device's time must be correct for your code to work.\n\nTo check your clock settings:\n\n*   **Android Devices** - Go to **Settings** > **Date & Time**. Make sure that the box next to **Automatic** is checked. To turn it off, go to **Settings > Date & Time**. Tap the box next to **Automatic** to un-check it.\n    \n*   **iOS Devices** - Go to **Settings** > **General** > **Date & Time**. Enable **Set Automatically**. If this setting was already enabled, you can disable it for a moment, then re-enable.\n    \n\nFor questions or issues specifically regarding Duo, see [Duo's documentation](https://guide.duo.com/).",
  "title": "Troubleshoot Multi-Factor Authentication Issues",
  "description": "Describes basic troubleshooting of MFA issues for your users.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/product-release-stages",
  "markdown": "# Product Release Stages\n\nProduct release stages describe how we stage, release, and retire product functionality. Product features may not progress through all release stages, and the time in each stage will vary depending on the scope and impact of the feature.\n\n## Beta\n\nBeta releases give subscribers time to explore new product capabilities while providing feedback prior to a next stage release (which may be Early Access or General Availability depending on the feature). Beta features have been validated for a set of use cases but might have changes on the road to a General Availability release. Beta releases may be restricted to a select number of subscribers (private) or open to all subscribers (public).\n\nWhen participating in a beta release, you should understand the following:\n\n*   We do not support beta functionalities for production use.\n    \n*   Changes may occur that impact functionality, and we will communicate them as we are made aware.\n    \n*   Your feedback will help prioritize improvements and fixes in a subsequent release.\n    \n\n## Early Access\n\nEarly Access releases are new or enhanced features made available for you to selectively opt-in to and use in both production and non-production environments. Minor changes can be expected on the road to General Availability. Early Access releases may be restricted to a select number of subscribers or rolled out to a subset of tenants (i.e. available only to tenants hosted in Japan).\n\n## General Availability\n\nGeneral Availability releases are fully functional and available to all subscribers (limited by pricing tier or SKU purchase) for production use. Features in General Availability are supported and issues are addressed in accordance with your agreement with Okta.\n\n## Deprecation\n\nDeprecated features are not supported for use by new subscribers, are not actively being enhanced, and are being only minimally maintained. Tenants using the feature at the time of deprecation will continue to have access.\n\nDeprecation begins when we introduce new behavior that customers would experience as a change that impacts core authentication functionality without mediation and ends when the old behavior moves into the End of Life product release stage. During Deprecation, customers should engage in a migration to move away from the deprecated feature or behavior. See [Migration Process](https://auth0.com/docs/troubleshoot/product-lifecycle/migration-process) for details.\n\nAlthough we know that deprecations can be disruptive, they are necessary to allow us to upgrade technology, improve security and service quality, and continue to invest in resources that provide the most value for our customers. As part of our commitment to transparency, we try to proactively notify subscribers when deprecations result in changes that alter use of Auth0. Additionally, we try to provide end-of-life notices with accompanying recommendations for migration and replacement capabilities where available.\n\n## End of Life\n\nFeatures that reach the End of Life stage are removed from the platform. Continued use of these features will likely result in errors.\n\n## Learn more\n\n*   [Deprecations and Migrations](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations)\n*   [Migration Process](https://auth0.com/docs/troubleshoot/product-lifecycle/migration-process)",
  "title": "Product Release Stages",
  "description": "Describes how we stage, release, and retire product functionality.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/migration-process",
  "markdown": "# Migration Process\n\nTo keep our platform stable and secure, we must occasionally modify or remove features or behaviors. These changes will sometimes result in a breaking change.\n\nWhen we must introduce a breaking change, we first deprecate the affected feature or behavior and announce the deprecation to our customers. When a new Deprecation is announced, customers should engage in a migration to move away from the deprecated feature or behavior.\n\n## End of life announcement\n\nWhen we announce a Deprecation, we typically include the date that the feature or behavior will be moved into the End of Life product release stage and removed from the platform. In some cases, we will immediately deprecate a feature to prevent further adoption and will determine the end of life date at a later time. End of life dates can vary between plan types.\n\n## Migration window\n\nWhen we make an end of life announcement, we will also open a migration window to allow customers to prepare for the end of life date.\n\nWhenever possible, we provide at least a six-month migration window between the end of life announcement and the end of life date. In case of emergency (for example, critical vulnerabilities that require remediation or changes required by applicable law or third-party certification standards), we may accelerate this time frame. In such cases, we will provide as much prior notice as is reasonable under the circumstances.\n\n## Migration guides\n\nAuth0 deprecations usually involve replacing deprecated behavior with substantially comparable functionality (although at times, we may elect to discontinue support for some functionality entirely).\n\nTo help you migrate to the new functionality and determine the impact on your tenants, we will publish a migration guide, which will detail any necessary modifications to your application's code, inform you of any other required actions, and instruct you about how you opt in to the new behavior prior to the End of Life date.\n\nOnce the end of life date is reached, the new behavior will automatically be enabled for tenants that did not opt in during the migration window.\n\n## Learn more\n\n*   [Deprecations and Migrations](https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations)\n*   [Past Migrations](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations)\n*   [Product Release Stages](https://auth0.com/docs/troubleshoot/product-lifecycle/product-release-stages)",
  "title": "Migration Process",
  "description": "Describes the migration process at Auth0, including End of Life announcements, migration windows, and migration guides.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/deprecations-and-migrations",
  "markdown": "# Deprecations and Migrations\n\nWe are actively migrating customers to new behaviors for all deprecations listed below. Please review these carefully to ensure you've taken any necessary steps to avoid service disruption. You can also search tenant logs for any errors caused by using deprecated features. To learn more, read [Search Logs for Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/search-logs-for-deprecation-errors).\n\nIf you have any questions, visit the [Community](https://community.auth0.com/) or [create a ticket in our Support Center](https://support.auth0.com/). To learn more, you can also read [Migration Process](https://auth0.com/docs/troubleshoot/product-lifecycle/migration-process).\n\n## Management API Transition: Updating Roles Assignment to Require Create Scope\n\n**Deprecated**: March 7, 2024\n\n**End of life**: September 10, 2024\n\nAuth0 by Okta is updating the Management API scopes for the User-Roles endpoint (`POST /api/v2/users/{id}/roles`) to represent their intended permissions. Currently, roles can be assigned to users with `read:roles` scope via the Management API. This capability is being deprecated, and role updates will require the `create:role_members` scope.\n\n## Update Applications that use Cross-Origin Authentication\n\n**Deprecated**: April 25, 2024\n\n**End of life**: October 10, 2024\n\nNew applications created in Auth0 will have cross-origin authentication disabled by default. Calls to some Management API endpoints ([Get Clients](https://auth0.com/docs/api/management/v2/clients/get-clients), [Get Client by ID](https://auth0.com/docs/api/management/v2/clients/get-clients-by-id)) will need to be modified to use `cross_origin_authentication`.\n\n## Rules and Hooks Deprecations\n\n**Deprecated**: May 16, 2023\n\n**End of life**: November 18, 2024 (note the longer-than-standard migration window of 18 months) \n\nOver the course of the next 18 months, we will be winding down support for Rules and Hooks in our products and navigating all customers to use [Auth0 Actions](https://auth0.com/docs/customize/actions/actions-overview) as the main place for customization and extensibility. Rules and Hooks will continue to receive full maintenance support until end of life; however, no new functionality will be introduced.\n\nIf you are currently using Rules and/or Hooks, please make plans to migrate to Actions prior to the EOL date of **November 18, 2024**. Please see the resources below to aid in your migration planning.\n\nBeginning on **October 16, 2023**, Rules and Hooks functionality will not be present in newly-created tenants. Any tenants created before this date will continue to have access to Rules and Hooks until the EOL date of **November 18, 2024**.\n\nWe recommend that you start building new extensibility use cases in Actions and, if you are able, start migrating your existing Rules and Hooks to Actions. To help aid you in your migration, please review the below documents:\n\n*   [Migrate from Rules to Actions](https://auth0.com/docs/customize/actions/migrate/migrate-from-rules-to-actions)\n    \n*   [Migrate from Hooks to Actions](https://auth0.com/docs/customize/actions/migrate/migrate-from-hooks-to-actions)\n    \n\n## Learn more\n\n*   [Migration Process](https://auth0.com/docs/troubleshoot/product-lifecycle/migration-process)\n*   [Past Migrations](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations)\n*   [Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors)\n*   [Check for Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/search-logs-for-deprecation-errors)",
  "title": "Deprecations and Migrations",
  "description": "Lists all deprecations with active migrations that may impact your tenant.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-legacy-auth-flows",
  "markdown": "# Migrate from Legacy Authentication Flows\n\nWhen using Lock versions below 11 and Auth0.js version below 9, you could use legacy authentication flows that are deprecated. Auth0 recommends that you migrate code from older versions of Auth0.js and Lock to the new OIDC-conformant APIs.\n\n## Renew tokens\n\nLegacy applications used Refresh Tokens and the `refreshToken()` function as a way to get new tokens upon expiration (an example of this is below).\n\nIn auth0.js v9 and Lock 11 you need to use [Silent Authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication) and `checkSession()`(an example of this is below).\n\n## Call APIs\n\nLegacy applications used an ID token to invoke APIs. This is a bad practice, and we recommend that you only use access tokens.\n\nTo call an API, you will need to specify the API identifier as the `audience` parameter when initializing auth0.js or Lock.\n\nIf you specify an audience, then the OIDC flow will be triggered and the user profile data returned by Auth0 in ID tokens or from `/userinfo` will be OIDC conformant. If your application is using any non-standard claim from the user profile, it will break.\n\nSee the **Calling an API** section of our SPA Quickstarts for more information on how to call APIs from SPAs. You will also need to migrate your backend API implementation to use Access Tokens. See API Quickstarts for instructions on how to do this.\n\n## User profiles\n\nThe legacy authentication flows that allow ID Tokens and the `/userinfo` endpoint to include the complete user profile are being deprecated. Make sure the `Legacy User Profile` toggle is turned off after completing the migration to the new OIDC-conformant APIs.\n\nWhen using the legacy authentication flows, the entire user profile is returned in ID Tokens and from `/userinfo`, as demonstrated below.\n\nThe new user profile conforms to the OIDC specification, which allows for certain [standard claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) to be available in the response.\n\nThe contents will vary depending on which scopes are requested. You will need to adjust the scopes you request when configuring Auth0.js or Lock so all the claims you need are available in your application. Note that you can add custom claims to return whatever data you want (for example, user metadata).\n\nAnother approach to get the full user profile is to use the Management API (instead of getting the profile through the authentication flow) as described in the next section.\n\n## User profile with Management API\n\nIn the legacy flows, the Management API supported authentication with an ID Token. This approach has been deprecated, and now you need to call it with an Access Token.\n\nTo get an Access Token, you need to ask Auth0 for one using the `https://{yourDomain}/api/v2/` audience. Auth0 does not currently support specifying two audiences when authenticating, so you will need to still use your application's API audience when initializing Lock or auth0.js. Once the user is authenticated, you can use `checkSession` to retrieve a Management API `access_token`, and then call the `getUser()` endpoint.\n\nYou can ask for the following scopes:\n\n*   `read:current_user`\n    \n*   `update:current_user_identities`\n    \n*   `create:current_user_metadata`\n    \n*   `update:current_user_metadata`\n    \n*   `delete:current_user_metadata`\n    \n*   `create:current_user_device_credentials`\n    \n*   `delete:current_user_device_credentials`\n    \n\nYou could get a `consent_required` error when calling `checkSession()`. If you do, make sure you have **Allow Skipping User Consent** enabled for the Management API and that you are not running from localhost.",
  "title": "Migrate from Legacy Authentication Flows",
  "description": "Describes how to migrate from legacy authentication flows.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors",
  "markdown": "# Multi-Factor Authentication Factors\n\nAuth0 supports a number of different options or factors for protecting user account access with multi-factor authentication (MFA).\n\nTo select the MFA factors to use on your tenant, go to [Dashboard > Security > Multi-factor Auth](https://manage.auth0.com/#/security/mfa). You must enable at least one factor on your tenant to use MFA. Available factors are dependent on your subscription plan. To learn more, read [Auth0 Pricing](https://auth0.com/pricing/).\n\n## Factors\n\nAuth0 supports the following factors for implementing MFA.\n\n### Push notifications\n\nSend users push notifications to their pre-registered devices, typically a mobile phone or tablet, from which a user can immediately allow or deny account access via the simple press of a button. Push factor is offered with the **Auth0 Guardian** mobile app, available for both iOS and Android. To learn more, read [Auth0 Guardian](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian).\n\nIf you don’t want your customers to have to download a separate application, Auth0 also provides a **Guardian SDK** for building a second-factor workflow in your existing mobile device app. To learn more, read [Install Guardian SDK](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/install-guardian-sdk). \n\n### SMS notifications\n\nSend users a one-time code over SMS which the user is then prompted to enter before they can finish authenticating. To learn more, read [Configure SMS and Voice Notifications for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n\n### Voice notifications\n\nDeliver a one-time code to users through voice call which the user is then prompted to enter before they can finish authenticating. To learn more, read [Configure SMS and Voice Notifications for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n\n### One-Time passwords\n\nOne-time passwords allow you to use an authenticator application on the user's personal device, such as Google Authenticator, to generate a one-time password that changes over time and which can be entered as the second factor to validate an account. To learn more, read [Configure OTP Notifications for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa)\n\n### WebAuthn with security keys\n\nEnable users to perform MFA with FIDO compliant Security Keys (e.g. [Yubikey](https://www.yubico.com/), [Google Titan](https://cloud.google.com/titan-security-key)). To learn more, read [Configure WebAuthn with Security Keys for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa)\n\n### WebAuthn with device biometrics\n\nEnable users to perform MFA using platform authenticators such as are MacBook’s TouchBar, Windows Hello, iOS Touch/FaceId, and Android’s fingerprint/face recognition. To learn more, read [Configure WebAuthn with Device Biometrics for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa)\n\n### Email notifications\n\nEnable users to perform MFA using one-time passwords delivered through email when they don't have other authentication factors available. To learn more, read [Configure Email Notifications for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-email-notifications-for-mfa)\n\n### Cisco Duo security\n\nCisco Duo is a multi-faceted provider and can only be used if it's the only factor available for the user. Use your Duo account to manage MFA with Auth0. To learn more, read [Configure Cisco Duo Security for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/configure-cisco-duo-for-mfa)\n\n### Recovery codes\n\nRecovery codes are unique codes allowing users to regain account access if they cannot access the device or account used for MFA enrollment. To learn more, read [Configure Recovery Codes for MFA.](https://auth0.com/docs/secure/multi-factor-authentication/configure-recovery-codes-for-mfa)\n\n## Policies\n\nPolicies determine when a user will be prompted to complete additional steps to prove they own a particular account. Use policies to define your own level of acceptable risk. You can choose between **Never**, **Use Adaptive MFA**, and **Always**.\n\nYou can achieve more refined multi-factor configurations (such as per application, per user, etc.) by using Auth0 Actions. To learn more, read [Auth0 Actions](https://auth0.com/docs/customize/actions).\n\nTo learn more, read [Defined Authentication Policies on OpenID.](http://openid.net/specs/openid-provider-authentication-policy-extension-1_0.html#rfc.section.4)\n\n## Use cases\n\nThere are different ways to manage MFA depending on your environment:\n\n*   B2B: Your customers manage MFA factors for their users.\n    \n*   B2C: End users manage their own MFA factors via an **My MFA Settings** page.\n    \n*   B2E: You manage MFA factors for your users.\n    \n\nTo learn about the API endpoints that you can use to build a user interface to manage MFA factors, see [Manage Authenticator Factors Using the MFA API.](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n\nApplications that allow access to different types of resources can require users to authenticate with a stronger authentication mechanism to access sensitive resources. See [Step-Up Authentication](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication) for details.\n\nTo create an Action go to [Dashboard > Actions > Flows](https://manage.auth0.com/#/actions/flows) and define conditions to trigger authentication challenges. Use Actions to force MFA for users of certain applications, or for users with particular user metadata or IP ranges, among other triggers.\n\nAdd contextual MFA which allows you to define arbitrary conditions that will trigger additional authentication challenges to your customers for increased security, for example, geographic location (geofencing), address or type of network used (IP filtering), time of day, day of the week or change in the location or device being used to log in.\n\n## Learn more\n\n*   [Configure Push Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-push-notifications-for-mfa)\n*   [Configure SMS and Voice Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n*   [Configure OTP Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-otp-notifications-for-mfa)\n*   [Configure Email Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-email-notifications-for-mfa)\n*   [Configure Cisco Duo Security for MFA](https://auth0.com/docs/secure/multi-factor-authentication/configure-cisco-duo-for-mfa)\n*   [Configure WebAuthn with Security Keys for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-security-keys-for-mfa)",
  "title": "Multi-Factor Authentication Factors",
  "description": "Describes multi-factor authentication (MFA) factors, policies, and use cases.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-tenant-log-search-v3",
  "markdown": "# Migrate to Tenant Log Search v3\n\nTo provide our customers with the most reliable and scalable solution, Auth0 has deprecated Tenant Logs Search Engine v2 in favor of v3.\n\nAuth0 proactively migrates customers unaffected by this change, while those who are potentially affected are being notified to opt-in for v3 during the provided grace period.\n\n## Features affected\n\nYou are affected if you meet all of the following criteria:\n\n*   Tenants created before or on 21 May 2019\n    \n*   Tenants hosted in Auth0's public cloud in the AU or EU regions\n    \n*   Use the GET /api/v2/logs or the GET `/api/v2/users/{user_id}/logs` endpoint with the parameter `include_totals=true` or the `q` parameter.\n    \n*   Paginate through more than 1000 results.\n    \n*   Use the Delegated Admin Extension. Older versions of the extension will continue to work after your Tenant is migrated to Logs Search Engine v3, however you might notice pagination totals being incorrect when viewing logs. Updating to v3.7 of the extension addresses this.\n    \n\nThe following tenants are not affected:\n\n*   Cloud tenants in the US region. The US region has been fully migrated and is already using Search Engine v3.\n    \n*   Private Cloud tenants (Migration for Private Cloud customers will begin at a later date.)\n    \n*   Cloud tenants in the EU and AU regions that are:\n    \n    *   Not using the `GET /api/v2/logs` or `GET /api/v2/users/{user_id}/logs` endpoints of Management API at all.\n        \n    *   Consuming the logs from the Dashboard Logs section only.\n        \n    *   Using the `GET /api/v2/logs endpoint` with the by checkpoint method (using `from` parameter).\n        \n    *   Consuming logs using any of the Auth0 Logs to External Service Dashboard extensions (which use the by checkpoint method).\n        \n\n## Verify query migration\n\nAuth0 generates only one log of the same type and description every 60 minutes. No matter how many calls you make using deprecated features to the impacted endpoints, you will still see a single log for each deprecated feature each hour.\n\nIf you implement changes to your queries, you'll need to allow 60 minutes to elapse before you can conclusively determine that the lack of new `depnote` logs means the deprecated behavior has been removed from your code.\n\nYou can search your tenant logs with the following to look for queries that would throw errors after you migrate to v3:\n\n`type:depnote AND description:*logs*`\n\nThese log entries include a `description` field that specifies the deprecated behavior you're using.\n\nYou can also check the `details.request.path` and `client_name` fields to see what application is calling either `GET /api/v2/logs` or `GET /api/v2/users/{user_id}/logs`.\n\n## Changes\n\nThe breaking changes are minor, but you should review your queries to make sure the results you are getting are as expected.\n\nBreaking changes are related to:\n\n*   When your tenant is migrated to logs v3 the value of the `total` field returned in the summary result when calling `GET /api/v2/logs` or `GET /api/v2/users/{user_id}/logs` is changing. When searching for logs using search engine v2, the totals field in your results tells you the number of logs that match the query you provided. However, in v3, the totals field tells you how many logs are returned in the page (similar to what the length field returns). To avoid any potential disruption, if your application relies on the total field for pagination purposes, you should update your logic to handle this change appropriately.\n    \n*   There is an existing limit of 100 logs per request. When your tenant is migrated to logs v3 you may only paginate through a maximum of 1,000 search results, resulting in calls for anything over 1,000 results returning an error. To avoid any potential disruption, you should review your queries to avoid this limit or handle errors accordingly.\n    \n\n### q parameter validation\n\n*   The query syntax when using the `q` parameter in the `GET /api/v2/logs` has minor changes that need to be taken into account. When your tenant is migrated to logs v3 this validation will be enforced resulting in this query returning an error. To avoid any potential disruption, you should review your queries to make sure they comply with the supported query syntax.\n    \n*   The `q` parameter includes an invalid field. When your tenant is migrated to logs v3 this validation will be enforced resulting in this call returning an error. To avoid any potential disruption, you should review your queries to make sure that only searchable fields are included.\n    \n\n## Enable Tenant Log Search v3\n\nAfter reviewing your queries, you can opt-in to Tenant Logs Search Engine v3 via the Dashboard.\n\n1.  Go to [Tenant Settings > Advanced](https://manage.auth0.com/#/tenant/advanced).\n    \n2.  Scroll down to **Migrations**.\n    \n3.  Toggle the **Legacy Logs Search V2** switch to off. Toggling this switch to off disables the deprecated logs search engine v2 and forces the use of search engine v3. If you do not see the **Legacy Logs Search V2** toggle, you've already been migrated to v3. No further action is required.\n    \n\nIf you need help with the migration, contact us using the [Support Center](https://support.auth0.com/).\n\n## Learn more\n\n*   [Logs](https://auth0.com/docs/deploy-monitor/logs)",
  "title": "Migrate to Tenant Log Search v3",
  "description": "Describes how to migrate from Auth0 Logs Search v2 to v3.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-actions-nodejs-16-to-nodejs-18",
  "markdown": "# Migrate Actions from Node.js 16 to Node.js 18\n\nAs part of our mission to support every future version of LTS Node.js through Actions and to be in line with the Node JS developer community, we are releasing Node 18 while Node 16 is still in Active LTS. We urge all customers to transition today to Node 18 and make the most of its LTS. Remember, while Node 16 LTS remains available until September, their use may involve certain risks following the conclusion of LTS and we recommend you to update to Node 18.\n\n## Our recommendations\n\nNode.js 18 is now generally available (GA) across our entire suite of extensibility offerings. This includes Actions, Rules, Hooks, Database Scripts, and Custom Social Connections. We strongly encourage everyone to update to Node 18 by Sept 11, 2023, to adhere to best code security practices.\n\n| Customers Using | Should | Task |\n| --- | --- | --- |\n| Node 16/12 | Update to Node 18 by Sept 11, 2023 | To use new Node 18, create new Actions with Node 18 or update existing Actions by [creating and deploying a new version](https://auth0.com/docs/customize/actions/manage-versions). |\n| Node 18 Beta in Actions | Update to Node 18 by Sept 11, 2023. | To switch to Node 18 GA, simply update existing Actions by [creating and deploying a new version](https://auth0.com/docs/customize/actions/manage-versions). |\n| Oracle | Stop using it. | Remove service. |\n| Node.js C# | Stop using it. | Remove service. |\n| Magic `npm` Modules | Make sure all node modules are added as dependencies on the Actions that use them. | Add as dependencies on the Actions that use them. |\n| Miscellaneous system binaries or programs | Stop using them. | Remove binaries because most of them will become unavailable. |\n| Filesystem write access | Stop writing files to `/tmp` from the different extensibility products. | Remove service. |\n\n### Move to Actions\n\nActions is designed to support multiple versions of Node concurrently, and now supports Node 12, Node 16, and Node 18. In addition, [no-code Actions integrations](https://marketplace.auth0.com/features/actions) follow industry-standard \"always current\" version control with minor versions updated automatically. The underlying code remains current to the latest LTS Node.js. We encourage all customers move to [Actions](https://auth0.com/docs/customize/actions).\n\n## Tasks\n\nThese task are only required if you want to use the Node 18 version.\n\n#### Create new Actions with Node 18\n\nCustomers can start using Node 18 by creating new Actions with Node 18:\n\n1.  Navigate to [Actions > Library](https://manage.auth0.com/#/actions/library), and select **Build Custom**.\n    \n2.  For **Runtime**, select `Node 18`.\n    \n    ![Modal that displays when you go to the Auth0 Dashboard, navigate to Actions, navigate to Library, and select Build Custom. For the Runtime field, Node 18 is selected.](https://images.ctfassets.net/cdy7uua7fh8z/7mlj5BdOc2FU21epuKqKmw/db4a2d5e45cbdb930f03cb83beddc1f4/2023-07-10_18-12-37.png)\n3.  Write your custom Actions in Node 18, test, and deploy when ready.\n    \n    ![The Actions Code Editor where you can write code. Node 18 is the selected version.](https://images.ctfassets.net/cdy7uua7fh8z/32kp3gHIIs9s4AtVg60lRr/c8fd5c8e1b685413a21723b7cfbe008a/actions-write-action-node-18.png)\n\n### Choose Node 18 for other extensibility products\n\nUpdate other extensibility products in Auth0 Dashboard.\n\n1.  Navigate to [Dashboard > Settings > Advanced](https://manage.auth0.com/dashboard/#/tenant/advanced).\n    \n2.  Scroll down to **Extensibility**.\n    \n3.  For **Runtime**, select `Node 18`.\n    \n    ![Dashboard > Settings > Advanced > Extensibility > Runtime](https://images.ctfassets.net/cdy7uua7fh8z/7jy3w6q4Xmcvnm7ebHms0G/7139a20c233b897a357a891c6e14be59/2023-06-21_13-31-09.png)\n\n### Upgrade existing Actions\n\nExisting Actions built on Node 16 can be upgraded to Node 18 and later reverted to a previous version on Node 16 if needed. Upgrade Actions to Node 18 by [creating and deploying a new version](https://auth0.com/docs/customize/actions/manage-versions) set to use Node 18 as the runtime.\n\n### Migrate Rules and Hooks to Actions\n\nWherever possible, migrate Rules and Hooks to Actions. To determine which Rules and Hooks can be migrated, read [Actions Limitations](https://auth0.com/docs/customize/actions/limitations). To learn how to migrate your Rules and Hooks to Actions, see our guides available at [Migrate to Actions](https://auth0.com/docs/customize/actions/migrate).\n\n### Breaking changes\n\nWhile there should be no significant breaking changes as a part of the Actions Node 18, please follow [our recommendations for using Node 18](#our-recommendations).",
  "title": "Migrate Actions from Node.js 16 to Node.js 18",
  "description": "Describes Auth0 Actions items affected by the Node.js v16 to Node.js v18 migration.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-1-hour-expiration",
  "markdown": "# Migrate to 1-Hour Login Flows Expiration\n\nStarting 21 February 2024, Auth0 will enforce a maximum lifetime of 1 hour for redirection-based login flows. Login flows that take longer than 1 hour to complete will expire in both Universal and Classic Login.\n\n## Affected login flows\n\nAuth0 currently allows the following interactive login flows to last up to 3 days to complete:\n\n*   [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow)\n    \n*   [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)\n    \n*   [Cross-Origin Authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication)\n    \n*   [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)\n    \n*   [Hybrid Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/hybrid-flow)\n    \n*   [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post)\n    \n*   [Security Assertion Markup Language (SAML)](https://auth0.com/docs/authenticate/protocols/saml)\n    \n*   [Web Services Federation Protocol (WS-Fed)](https://auth0.com/docs/authenticate/protocols/ws-fed-protocol)\n    \n\nStarting 21 February 2024, Auth0 will enforce a maximum lifetime of 1 hour for the listed authorization flows. Transactions will expire after 1 hour. After expiration, operations from the end user's browser, such as input email and password or redirect back to [Auth0 Actions](https://auth0.com/docs/customize/actions), etc., will:\n\n*   Redirect to the associated application’s default login route to reinitiate the flow with a new login transaction Or\n    \n*   Serve an error page if you have not configured the application's default login route or you are using Classic Login. The end user must return to your application to reinitiate the login transaction. You can customize this error page using Universal Login.\n    \n\n## Actions\n\nWhen [redirecting users after logout](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions), redirect them to a page of your application that allows users to log in again based on some user action (e.g. click the Login button) instead of directly redirecting them to the Universal Login `/authorize` endpoint. The pattern of starting a new login transaction without an explicit user-initiated action is the main source of transactions taking too long to complete, as the new login attempt is left unattended in a browser window and can be subject to malicious attacks.\n\nIf you are using Universal Login:\n\n*   We recommend you [configure default login routes](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes) for your applications in the Auth0 Dashboard or via the Auth0 Management API. This method automatically starts login transactions and results in the best user experience as the login flow seamlessly restarts for active end users when the transaction has expired.\n    \n*   If your configuration doesn’t allow for default login routes, we recommend you [customize Auth0 error pages](https://auth0.com/docs/customize/universal-login-pages/custom-error-pages) to provide a better user experience. You can use the error pages to instruct the user to return to your application to restart the login attempt.\n    \n*   If you don’t do either of the above, we will display the [default Auth0 error page](https://auth0.com/docs/authenticate/login/auth0-universal-login/error-pages):\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7ET2UOsS5DtySCwFP86Ao9/4bbb7e702df15feaaadb3301cd7e29eb/2023-08-01_12-37-25.png)\n\nIf you are using Classic Login, the login widget will display an error and the user will need to return to the application and retry to log in for expired transaction in all cases.\n\n## Review tenant logs\n\nIf you want further insights on how many transactions and Applications are affected in your tenant, review the logs in your tenant under [Auth0 Dashboard > Monitoring > Logs](https://manage.auth0.com/#/monitoring/logs). Look for `Deprecation Notice` logs with this search: `type:depnote AND description:*Long*state*expirations*`. These results will point to login transactions and the applications (i.e. `client_id`) lasting longer than 1 hour.\n\nNote these logs are rate-limited, and you will see one per hour per `client_id`.\n\n![Auth0 Dashboard > Monitoring > Logs Long state expiration description](https://images.ctfassets.net/cdy7uua7fh8z/4DdiuT1ptQbqTZe6Zudme8/9387860291fd32cd12d5aa3680f63ccf/2023-08-01_13-52-03.png)\n\n## Verify migration\n\nAfter configuring default login routes or updating the Auth0 error pages with specific instructions for your end-users, you can (de)activate the 1-hour expiration any time before 21 February 2024 to verify login behavior.\n\n1.  Navigate to [Auth0 Dashboard > Tenant Settings > Advanced](https://manage.auth0.com/#/tenant/advanced) and search for the Migrations section.\n    \n2.  Toggle off **Long state expirations**. Disabling this setting limits transactions to last only 1 hour. Enabling this setting allows transactions to last up to 3 days.\n    \n\n![Auth0 Dashboard > Settings > Advanced](https://images.ctfassets.net/cdy7uua7fh8z/4myUIpSK48kUQD3J0pOfyR/addb602cf04821e378d56cc1e5b46fc9/2023-08-01_14-03-42.png)",
  "title": "Migrate to 1-Hour Login Flows Expiration",
  "description": "Describes how to enable 1-hour expiration for interactive login flows.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-edge-js-extensibility-features",
  "markdown": "# Migrate from edge.js extensibility features\n\nAs of June 21, 2023, Auth0 will no longer support .NET and C# Node.js Extensibility features. \n\n## Affected workflows\n\nReview your Extensibility features for code that contains \\`require(edge)\\`.\n\nReview the following flows or features that allow extensibility code for references to `edge.js`:\n\n*   [Hooks](https://auth0.com/docs/customize/hooks)\n    \n*   [Rules](https://auth0.com/docs/customize/rules)\n    \n*   [Custom Database Scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection#create-database-action-scripts)\n    \n*   [Custom Social Connections](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/oauth2)\n    \n\n## Recommended updates\n\nThere is no official planned replacement for this feature. \n\nOne path for migration is to replace the `edge` logic to a separate service within your own infrastructure. After you create the service in your infrastructure, you can use an Extensibility function to make an HTTP request to trigger the required operation.\n\nFor example, in a Custom Database Login script using `edge`, remove the function that calls `edge` with a generic HTTP client to capture the response.\n\nAnother path for migration is to rewrite the Extensibility feature in JavaScript instead of .NET/C#.\n\nFor more information on creating Actions or migrating to Actions, [review the Auth0 documentation](https://auth0.com/docs/customize/actions).",
  "title": "Migrate from edge.js extensibility features",
  "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-oracledb-extensibility-features",
  "markdown": "# Migrate from oracledb extensibility features\n\nAs of June 21, 2023, Auth0 will no longer support connecting to Oracle Databases from Node.js in Extensibility features. Auth0 previously supported connecting to Oracle Databases via the `oracledb` Node.js module.\n\n## Affected workflows\n\nReview your Extensibility features for code that contains `require(oracledb)` or  `require('oracledb@4.2.0')`.\n\nReview the following flows or features that allow extensibility code for references to [oracledb](https://www.npmjs.com/package/oracledb):\n\n*   [Hooks](https://auth0.com/docs/customize/hooks)\n    \n*   [Rules](https://auth0.com/docs/customize/rules)\n    \n*   [Custom Database Scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection#create-database-action-scripts)\n    \n*   [Custom Social Connections](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/oauth2)\n    \n\n## Recommended updates\n\nThere is no official planned replacement for this feature. Auth0 recommends replacing the `oracledb` logic to a separate service within your own infrastructure. After you create the service in your infrastructure, you can use an Extensibility function to make an HTTP request to trigger the Oracle Database logic. \n\nTo learn more about how to implement the `oracledb` module in your own infrastructure, review the [OracleDB Quickstart guide](https://node-oracledb.readthedocs.io/en/latest/user_guide/installation.html#quickstart).\n\nFor example, in a Custom Database Login script using `oracledb`, remove the function that calls `oracledb` with a generic HTTP client to capture the response.\n\nFor more information on creating Actions or migrating to Actions, [review the Auth0 documentation](https://auth0.com/docs/customize/actions).",
  "title": "Migrate from oracledb extensibility features",
  "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/custom-claims-migration",
  "markdown": "# Migrate Custom Claims\n\nAs of 28 July 2022, Auth0 will allow private, non-namespaced custom claims to be added to access and ID tokens. These same claims will also be added to the response of the [`/userinfo` endpoint](https://auth0.com/docs/api/authentication#get-user-info). To learn more about the types of JWT claims, read [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims).\n\n#### Example\n\nPreviously, Auth0 allowed only namespaced claims on access and ID tokens. With the migration to custom claims, non-namespaced claims can be used on access tokens, ID tokens, and the `/userinfo` endpoint of Auth0's Authentication API.\n\n```\n// an Auth0 action \nexports.onExecutePostLogin = async (event, api) => {\n\n  // public namespaced custom claims \n  api.accessToken.setCustomClaim('https://myDomain.com/myClaim', 'this is a public, namespaced claim');\n  api.idToken.setCustomClaim('https://myDomain.com/myClaim', 'this is a public, namespaced claim');\n\n  // non-namespaced custom claims\n  api.accessToken.setCustomClaim('myClaim', 'this is a private, non namespaced claim');\n  api.idToken.setCustomClaim('myClaim', 'this is a private, non namespaced claim');\n};\n```\n\n## Affected flows\n\nAll OpenID Connect (OIDC) flows that Auth0 supports are affected by this migration. To review the list of flows, read [Authentication and Authorization Flows](https://auth0.com/docs/get-started/authentication-and-authorization-flow).\n\nThe following features are also affected:\n\n*   [Native Social Login](https://auth0.com/docs/get-started/authentication-and-authorization-flow)\n    \n*   [Refresh tokens](https://auth0.com/docs/secure/tokens/refresh-tokens)\n    \n\nThe following features are affected only when used along with [Auth0 Rules](https://auth0.com/docs/customize/rules) and attribute mapping:\n\n*   [Web Services Federation Protocol (WS-Fed)](https://auth0.com/docs/authenticate/protocols/ws-fed-protocol)\n    \n*   [SAML2 Web app add-on](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon)\n    \n\n## Restrictions\n\n### Maximum token size\n\nAuth0 will restrict the custom claims payload to a maximum of 100KB. It is important to make sure the payload does not exceed this limit, otherwise the authentication transaction will fail with an error. We recommend you review your use of extensibility code (i.e. [Rules](https://auth0.com/docs/customize/rules), [Hooks](https://auth0.com/docs/customize/hooks), or [Actions](https://auth0.com/docs/customize/actions)). In particular, review large payloads from external APIs.\n\nTo avoid errors, Auth0 recommends using the smallest token payload necessary for your application to operate. You may need to strip any properties that are not crucial before you set the custom claim value.\n\nThe limit of 100KB is applied to access tokens and ID tokens separately. For example, an access token of 100KB and an ID token of 100KB can be returned in the same transaction.\n\n#### Examples\n\n```\n// an Auth0 action \nexports.onExecutePostLogin = async (event, api) => {\n\n  // fetching a payload that is superior to 100KB\n  const aHeavyPayload = getHeavyPayload();\n\n  // this will fail the authentication\n  api.idToken.setCustomClaim('myclaim', aHeavyPayload);\n\n};\n```\n\n```\n// an Auth0 action \nexports.onExecutePostLogin = async (event, api) => {\n\n  // fetching a payload that is 50KB\n  const a50KBPayload = getHeavyPayload();\n\n  // fetching another payload that is 50KB\n  const another50KBPayload = getHeavyPayload();\n\n  // this will fail the authentication\n  api.idToken.setCustomClaim('myclaim', a50KBPayload);\n  api.idToken.setCustomClaim('https://myDomain.com/myClaim', another50KBPayload);\n\n};\n```\n\n```\n// an Auth0 action \nexports.onExecutePostLogin = async (event, api) => {\n\n  // fetching a payload that is 50KB\n  const a50KBPayload = getHeavyPayload();\n\n  // fetching another payload that is 50KB\n  const another50KBPayload = getHeavyPayload();\n\n  // this will succeed\n  api.accessToken.setCustomClaim('myclaim', a50KBPayload);\n  api.idToken.setCustomClaim('https://myDomain.com/myClaim', another50KBPayload);\n\n};\n```\n\n### Restricted claims\n\nAuth0 will restrict the customization of claims used in the OIDC or OAuth2 standards or claims for internal use. Any attempt to modify one of these claims will be ignored. The transaction won't fail, but the claim will not be added to tokens. Auth0 recommends using a public, namespaced claim.\n\n*   `acr`\n*   `act`\n*   `active`\n*   `amr`\n*   `at_hash`\n*   `ath`\n*   `attest`\n*   `aud`\n*   `auth_time`\n*   `authorization_details`\n*   `azp`\n*   `c_hash`\n*   `client_id`\n*   `cnf`\n*   `cty`\n*   `dest`\n*   `entitlements`\n*   `events`\n*   `exp`\n*   `groups`\n*   `gty`\n*   `htm`\n*   `htu`\n*   `iat`\n*   `internalService`\n*   `iss`\n*   `jcard`\n*   `jku`\n*   `jti`\n*   `jwe`\n*   `jwk`\n*   `kid`\n*   `may_act`\n*   `mky`\n*   `nbf`\n*   `nonce`\n*   `object_id`\n*   `org_id`\n*   `org_name`\n*   `orig`\n*   `origid`\n*   `permissions`\n*   `roles`\n*   `rph`\n*   `s_hash`\n*   `sid`\n*   `sip_callid`\n*   `sip_cseq_num`\n*   `sip_date`\n*   `sip_from_tag`\n*   `sip_via_branch`\n*   `sub`\n*   `sub_jwk`\n*   `toe`\n*   `txn`\n*   `typ`\n*   `uuid`\n*   `vot`\n*   `vtm`\n*   `x5t#S256`\n\n#### Example\n\n```\n// an Auth0 action \nexports.onExecutePostLogin = async (event, api) => {\n\n  // this will be ignored\n  api.accessToken.setCustomClaim('roles', 'this is a role, but Auth0 will ignore it');\n\n  // this will succeed, and appear in the token\n  api.idToken.setCustomClaim('https://myDomain.com/roles', 'this is a role');\n\n};\n```\n\n### Restricted token audience\n\nAuth0 will restrict the creation of private, non-namespaced custom claims on access tokens in which the audience is an Auth0 API. Any attempt to set a private, non-namespaced custom claim on an access token where the audience is an Auth0 API will be ignored. The transaction will not fail, but the claim will not be added to your token. Auth0 recommends not setting custom claims on tokens that are to be consumed by Auth0’s APIs.\n\nThe following audience will restrict the creation of private, non-namespaced custom claims:\n\n*   `https://YOUR_TENANT.auth0.com/api` or `https://YOUR_TENANT.auth0app.com/api`\n    \n*   `https://YOUR_TENANT.auth0.com/api/v2` or `https://YOUR_TENANT.auth0app.com/api/v2`\n    \n*   `https://YOUR_TENANT.auth0.com/mfa` or `https://YOUR_TENANT.auth0app.com/mfa`\n    \n\nThe exception to this restriction is the Auth0 `/userinfo` audience. Private, non-namespaced custom claims are allowed on the following audience:\n\n*   `https://YOUR_TENANT.auth0.com/userinfo`\n    \n*   `https://YOUR_TENANT.auth0app.com/userinfo`\n    \n\n#### Examples\n\n```\n// an Auth0 action \nexports.onExecutePostLogin = async (event, api) => {\n\n  // these will be ignored if the audience is an Auth0 audience\n  api.accessToken.setCustomClaim('myATclaim', 'this is a claim');\n  api.accessToken.setCustomClaim('https://myDomain.com/myATclaim', 'this is a claim');\n\n  // these will succeed, they are not concerned by the audience restriction\n  api.idToken.setCustomClaim('myIdTclaim', 'this is a claim');\n  api.idToken.setCustomClaim('https://myDomain.com/myIdTclaim', 'this is a claim');\n\n};\n```\n\nThe example below demonstrates the returned response with custom claims if the audience is not an Auth0 API:\n\n```\n-- A resource owner password flow \nPOST https://{yourTenant}.auth0.com/oauth/token\n\ngrant_type:password\nusername:***\npassword:***\nclient_id:***\nclient_secret:***\naudience:https://{yourApi}.com -- Note the audience, that is a custom API\nscope:openid profile\n```\n\n```\n// The Access token returned by Auth0\n{\n  \"iss\": \"https://{yourTenant}.auth0.com/\",\n  \"sub\": ***,\n  \"aud\": [\n    \"https://{yourApi}.com\",\n    \"https://{yourTenant}.auth0.com/userinfo\"\n  ],\n  \"iat\": 1655283444,\n  \"exp\": 1655369844,\n  \"azp\": ***,\n  \"scope\": \"openid profile\",\n  \"gty\": \"password\",\n\n  // The custom claims were added, because the Audience is not an Auth0 audience\n  \"myATclaim\": \"this is a claim\",\n  \"https://{yourDomain}.com/{myATclaim}\": \"this is a claim\"\n}\n```\n\nThe example below demonstrates the returned response with custom claims not added with an Auth0 API audience:\n\n```\n-- A resource owner password flow \nPOST https://{yourTenant}.auth0.com/oauth/token\n\ngrant_type:password\nusername:***\npassword:***\nclient_id:***\nclient_secret:***\naudience:https://{yourTenant}.auth0.com/api/v2/ -- This is an Auth0 audience \nscope:openid profile\n```\n\n```\n// The Access token returned by Auth0\n{\n  \"iss\": \"https://{yourTenant}.auth0.com/\",\n  \"sub\": ***,\n  \"aud\": [\n    \"https://{yourTenant}.auth0.com/api/v2/\",\n    \"https://{yourTenant}.auth0.com/userinfo\"\n  ],\n  \"iat\": 1655283444,\n  \"exp\": 1655369844,\n  \"azp\": ***,\n  \"scope\": \"openid profile\",\n  \"gty\": \"password\",\n\n  // The public namespaced custom claims was added, because it is not concerned by this restriction\n  // However, the private non-namespaced custom claim {myATclaim} was ignored\n  \"https://mydomain.com/{myATclaim}\": \"this is a claim\"\n}\n```\n\n## Restriction on Auth0 and Webtask namespaces\n\nAuth0 will restrict the creation of namespaced custom claims with an Auth0 domain as namespace identifier. Auth0 domains are:\n\n*   auth0.com\n    \n*   webtask.io\n    \n*   webtask.run\n    \n\nAny attempt to set a namespaced custom claim on a token with one of the domains above as an identifier will be ignored. The transaction will not fail, but the claim will not be added to your token.\n\n```\n// an Auth0 action \nexports.onExecutePostLogin = async (event, api) => {\n\n  // none of these will be added to tokens nor to /userinfo response\n  api.idToken.setCustomClaim('https://example.auth0.com', 'this is a claim');\n  api.idToken.setCustomClaim('https://example.webtask.io', 'this is a claim');\n  api.idToken.setCustomClaim('https://example.webtask.run', 'this is a claim');\n\n};\n```\n\n### OIDC user profile claims\n\nAuth0 will now allow OIDC user profile claims to be added to access tokens.\n\nAttempts to add OIDC user profile claims to the access token were silently ignored prior to this migration. With the updated behavior, access tokens will contain these OIDC user profile claims.\n\nYou can add the following OIDC user profile claims to access tokens:\n\n*   `address`\n*   `birthdate`\n*   `email`\n*   `email_verified`\n*   `family_name`\n*   `gender`\n*   `given_name`\n*   `locale`\n*   `middle_name`\n*   `name`\n*   `nickname`\n*   `phone_number`\n*   `phone_number_verified`\n*   `picture`\n*   `preferred_username`\n*   `profile`\n*   `updated_at`\n*   `website`\n*   `zoneinfo`\n\n#### Example\n\n```\n// an Auth0 action \nexports.onExecutePostLogin = async (event, api) => {\n\n  // this was ignored so far. From this migration on, the claim will be added to access tokens \n  // if the scope contains 'email'\n  api.accessToken.setCustomClaim('email', 'myemail@domin.com');\n\n  // this was ignored so far. From this migration on, the claim will be added to access tokens \n  // if the scope contains 'profile'\n  api.accessToken.setCustomClaim('family_name', 'A family name');\n\n};\n```\n\n### SAML2 add-on and Web Service Federation Protocol (WS-Fed) attribute mapping with Auth0 Rules\n\nSimilar to using Auth0 Rules to make changes to the user object, `app_metadata` or `user_metadata` pre-migration claims also merge contents when the claim is set on the `context.idToken` object and the names conflict. To learn more about the object properties, read [User Object Properties In Rules](https://auth0.com/docs/customize/rules/user-object-in-rules).\n\nUsing custom claims, however, Auth0 gives precedence to the claim that was set on the `context.idToken object`.\n\nThis change impacts Auth0 Rules that set `app_metadata` and `user_metadata` via `context.id_token` (assigning objects to them) and, at the same time, uses these fields in attribute mapping for SAML add-on or Web Service Federation Protocol (WS-Fed).\n\nExample 1: Auth0 ignores attribute mapping when `context.idToken.app_metadata` is set with an empty object.\n\n```\n// an Auth0 Rule\nfunction (user, context, callback) {\n\n  user.app_metadata.a_claim = 'This is a claim';\n  user.app_metadata.another_claim = 'This is a another claim';\n\n  context.samlConfiguration = context.samlConfiguration || {};\n\n  context.samlConfiguration.mappings = {\n    \"a_claim\": \"app_metadata.a_claim\",\n    \"another_claim\": \"app_metadata.another_claim\"\n  };\n\n  context.idToken.app_metadata = {};\n\n  return callback(null, user, context);\n}\n```\n\nSAML response prior to this migration:\n\n```\n<samlp:Response>\n    (...)\n    <saml:Assertion>\n        (...)\n        <saml:AttributeStatement xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n            <saml:Attribute Name=\"a_claim\" NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:basic\">\n                <saml:AttributeValue xsi:type=\"xs:string\">\n                    This is a claim\n                </saml:AttributeValue>\n            </saml:Attribute>\n            <saml:Attribute Name=\"another_claim\" NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:basic\">\n                <saml:AttributeValue xsi:type=\"xs:string\">\n                    This is a another claim\n                </saml:AttributeValue>\n            </saml:Attribute>\n        </saml:AttributeStatement>\n    </saml:Assertion>\n</samlp:Response>\n```\n\nSAML response with the upgraded behavior:\n\n```\n<samlp:Response>\n    (...)\n    <saml:Assertion>\n        (...)\n        <saml:AttributeStatement xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"/>\n    </saml:Assertion>\n</samlp:Response>\n```\n\nExample 2: The version of `app_metadata` in `context.id_token` takes precedence.\n\n```\n// an Auth0 Rule\nfunction (user, context, callback) {\n\n  user.app_metadata.a_claim = 'This is a claim';\n  user.app_metadata.another_claim = 'This is a another claim';\n\n  context.samlConfiguration = context.samlConfiguration || {};\n\n  context.samlConfiguration.mappings = {\n    \"a_claim\": \"app_metadata.a_claim\",\n    \"another_claim\": \"app_metadata.another_claim\",\n    \"claim_set_via_id_token\": \"app_metadata.claim_set_via_id_token\"\n  };\n\n  context.idToken.app_metadata = {\n  \tclaim_set_via_id_token: \"This is a claim which was set via context.idToken\"\n  };\n\n  return callback(null, user, context);\n}\n```\n\nSAML Response prior to this migration:\n\n```\n<samlp:Response>\n    (...)\n    <saml:Assertion>\n        (...)\n        <saml:AttributeStatement xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n            <saml:Attribute Name=\"a_claim\">\n                <saml:AttributeValue xsi:type=\"xs:anyType\">\n                    This is a claim\n                </saml:AttributeValue>\n            </saml:Attribute>\n            <saml:Attribute Name=\"another_claim\">\n                <saml:AttributeValue xsi:type=\"xs:anyType\">\n                    This is a another claim\n                </saml:AttributeValue>\n            </saml:Attribute>\n            <saml:Attribute Name=\"claim_set_via_id_token\">\n                <saml:AttributeValue xsi:type=\"xs:anyType\">\n                    This is a claim which was set via context.idToken\n                </saml:AttributeValue>\n            </saml:Attribute>\n        </saml:AttributeStatement>\n    </saml:Assertion>\n</samlp:Response>\n```\n\nSAML response with the upgraded behavior:\n\n```\n<samlp:Response>\n    (...)\n    <saml:Assertion>\n        (...)\n        <saml:AttributeStatement xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n            <saml:Attribute Name=\"claim_set_via_id_token\" NameFormat=\"urn:oasis:names:tc:SAML:2.0:attrname-format:basic\">\n                <saml:AttributeValue xsi:type=\"xs:string\">\n                    This is a claim which was set via context.idToken\n                </saml:AttributeValue>\n            </saml:Attribute>\n        </saml:AttributeStatement>\n    </saml:Assertion>\n</samlp:Response>\n```\n\n### Add private, non-namespace claims to tokens\n\nYou can now add private, non-namespaced custom claims to the payload of access and ID tokens.\n\n#### Example\n\n```\n// an Auth0 action \nexports.onExecutePostLogin = async (event, api) => {\n\n  // previously ignored\n  // From this migration on, the claim will be added to access tokens\n  api.accessToken.setCustomClaim('myATclaim', 'this is a claim');\n\n  // previously ignored\n  // From this migration on, the claim will be added to ID tokens\n  api.idToken.setCustomClaim('myIdTclaim', 'this is a claim');\n\n};\n```\n\n### Private, non-namespace claims to /userinfo\n\nAuth0 now returns private, non-namespaced custom claims in the /userinfo response when set on ID tokens.\n\n#### Example\n\n```\n// an Auth0 action \nexports.onExecutePostLogin = async (event, api) => {\n\n  // this was ignored so far. \n  // From this migration on, this claim will be returned in /userinfo\n  api.idToken.setCustomClaim('myIdTclaim', 'this is a claim');\n\n};\n```\n\n```\n-- a call to /userinfo \nGET https://{yourTenant}.auth0.com/userinfo\nAuthorization: Bearer {yourAccessToken}\n```\n\n```\n// the response from /userinfo\n{\n    \"sub\": ***,\n    (...)\n    \"myIdTclaim\": \"this is a claim\"\n}\n```\n\n## Actions\n\n### Review tenant logs\n\nFirst, check your tenant logs for deprecation notices to determine whether your tenant is affected by the migration.\n\n1.  Navigate to Auth0 [Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs).\n    \n2.  Search the logs for `type: depnote AND description: *Custom*claims*`.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/2pYG4hP8bujX0ooAsEjV4l/831256d0c750e7985e079b5f977eee43/customclaims_logs.png)\n\n### Example\n\nProvided below is an example deprecation log that is generated whenever extensibility code triggers.\n\n```\n{\n  \"date\": \"2022-06-28T08:12:52.084Z\",\n  \"type\": \"depnote\",\n  \"description\": \"Custom claims must be namespaced: This feature is being deprecated. Please see details.feature of this log for more information.\",\n  \"connection_id\": \"\",\n  \"client_id\": ****,\n  \"client_name\": ****,\n  \"details\": {\n    \"feature\": {\n      \"grant\": \"password\",\n      \"access_token_claims_to_be_allowed\": [\n        \"myclaim\"\n      ],\n      \"access_token_claims_to_be_disallowed\": [\n        \"gty\"\n      ],\n      \"id_token_claims_to_be_allowed\": [\n        \"myclaim\"\n      ],\n      \"id_token_claims_to_be_disallowed\": [\n        \"gty\"\n      ],\n      \"id\": \"legacy_custom_claims\",\n      \"name\": \"Custom claims must be namespaced when they are added through rules / actions / hooks.\"\n    }\n  },\n  \"log_id\": ****,\n  \"_id\": ****,\n  \"isMobile\": false,\n  \"user_agent\": \"Other 0.0.0 / Other 0.0.0\",\n  \"id\": ****\n}\n```\n\n### Fix Auth0 rules for SAML2 add-on and Web Service Federation Protocol (Ws-Fed)\n\nIf you set `app_metadata` or `user_metadata` claims on the `context.idToken` object using SAML2 add-on or Web Service Federation Protocol (Ws-Fed) with Auth0 Rules along with attribute mapping, you will need to update your configuration to adjust for how Auth0 evaluates conflicting claim names between these objects. There are several possible fixes:\n\n*   Make sure that the code of your Auth0 Rule always gives precedence to the content of objects set on `context.id_token`:\n    \n    ```\n    // my_claim will be ignored, this line of code is not relevant anymore,\n    // prefer setting my_claim on `context.idToken`\n    user.app_metadata.my_claim = 'a value'; \n    \n    // this version of app_metadata will take precedence over any other change \n    context.idToken.app_metadata = {\n      another_claim: 'another value'\n    };\n    \n    // Only `another_claim` will appear in SAML/WsFed responses\n    ```\n    \n*   If you are using SAML2 add-on or Web Service Federation Protocol (Ws-Fed) attribute mapping, Avoid setting `app_metadata` or `user_metadata` claims on the `context.idToken` object. Replace these claims with name-spaced claims when possible:\n    \n    ```\n    context.idToken['https://mydomain.com/app_metadata'] = {\n      my_claim: 'my claim'\n    };\n    ```\n    \n*   Use a condition on the current protocol or on the current client to exclude statements setting `app_metadata` or `user_metadata` when the protocol is `samlp` or `wsfed`.\n    \n    ```\n    if (!['samlp', 'wsfed'].includes(context.protocol)) {\n        context.idToken.app_metadata = {\n          claim_set_via_id_token: \"This is a claim which was set via context.idToken\"\n        };\n    }\n    ```\n    \n\n### Disable legacy behavior\n\n1.  Navigate to [Auth0 Dashboard > Tenant Settings > Advanced](https://manage.auth0.com/dashboard/#/tenant/advanced) and search for **Migrations**.\n    \n2.  Use the toggle to disable **Custom claims must be namespaced**.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/4MtAhToH9yumMruVogrTDK/345e4263ce55fe861fa18544ea916957/custom-claims-migration-toggle.png)",
  "title": "Migrate Custom Claims",
  "description": "Describes migration from Legacy namespaced claims to custom claims.  ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources",
  "markdown": "# Multi-Factor Authentication Developer Resources\n\nUsing Auth0 SDKs, you can customize your users' multi-factor authentication (MFA) experience and even build applications on top of our multi-factor capabilities.\n\n## MFA API\n\n[MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) endpoints allow you to enforce MFA when users interact with the [Token endpoints](https://auth0.com/docs/api/authentication#get-token), as well as enroll and manage MFA factors.\n\n## Create custom MFA pages\n\nUse the following client libraries to customize the look-and-feel of the MFA page so it matches your organization.\n\n*   [Auth0 MFA Client library](https://github.com/auth0/auth0-guardian.js)\n    \n*   [Create Custom MFA Widget](https://github.com/auth0/auth0-guardian.js/tree/master/example)\n    \n\n## Create custom enrollments\n\nYou can [customize the enrollment](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets) process for your users by creating custom enrollment tickets.\n\n## Build custom mobile applications\n\nBuild custom Guardian-like applications or add multi-factor functionality into your applications using our SDKs.\n\n*   [Guardian for Android](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk)\n    \n*   [Guardian for iOS](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk)\n    \n\n## Learn more\n\n*   [Auth0 Guardian](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian)\n*   [Guardian for Android SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk)\n*   [Guardian.swift iOS SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk)\n*   [Auth0 MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api)",
  "title": "Multi-Factor Authentication Developer Resources",
  "description": "Describes developer resources such as the Auth0 MFA API and the Guardian SDKs for multi-factor authentication (MFA).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/tenant-hostname-migration",
  "markdown": "# Migrate Tenant Hostname Validation\n\nAs of June 9, 2022 in Public Cloud and September 9, 2022 in Private Cloud, Auth0 is adding a layer of validation to the Authentication API. If Auth0 has detected that calls from your applications to the Authentication API may be affected by this change, we have provided deprecation notices in tenants logs and a migration flag to prepare you for this change. \n\n### Affected Endpoints\n\nAs of June 9, 2022 in Public Cloud and September 9, 2022 in Private Cloud, any calls to the Authentication API endpoints below that are not properly validated will be rejected. Auth0 recommends that you take action to migrate your application domain URL or API call identifier to the same tenant well before that date.\n\nThe affected endpoints are:\n\n*   `/oauth/token`\n    \n*   `/co/authenticate`\n    \n*   `/userinfo`\n    \n*   `/login`\n    \n*   `/oauth/revoke`\n    \n*   `/mfa/challenge`\n    \n*   `/p/<connection-type>/<ticket>` (Enterprise connection provisioning endpoint)\n    \n\n## Review tenant logs\n\nFirst, check your tenant logs for deprecation notices to verify if you need to migrate your application.\n\n1.  Navigate to [Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs).\n    \n    1.  Search the logs for `type:depnote AND description:ignore*request*host*header*` to find the deprecation notice regarding which applications are affected and need to be migrated.\n        \n        ![Searching tenant logs for deprecation information](https://images.ctfassets.net/cdy7uua7fh8z/3JbJKHpuw0S6cvJiiqgjOU/fe1c259e84135b32121d60a9274f274b/Dashboard_-_Monitoring_-_Logs_-_Tenant_-_Validation.png)\n    2.  Find the **Details > Raw** section of the log. There you can identify the `client_id` of the application to update, or the `connection_id` in the case of a provisioning endpoint.\n        \n2.  Modify all applicable applications.\n    \n    1.  If any misalignments of tenant and domain tenant exist, you need to modify the sent identifiers, or domain URL, along with other misconfigured request parameters.\n        \n    2.  The domain tenant should match the tenant associated with the `client_id` or `connection_id`.\n        \n\nOnce you’ve completed migrating all applicable tenants, tenant  logs will no longer show deprecation notices associated with this migration.\n\n## Verify Migration\n\nOnce you have migrated your applications and configured unvalidated hostnames, verify your changes by disabling the deprecated behavior at a time of your choosing and ahead of June 9, 2022 or September 9, 2022.\n\n1.  Navigate to [Dashboard > Tenant Settings > Advanced > Migrations](https://manage.auth0.com/#/tenant/advanced).\n    \n2.  Disable the **Ignore request Host header** toggle**.**  Deactivating this toggle enforces validation for your tenant and completes the migration.\n    \n\n![Disable this setting when you are sure your URL domain and requesting tenant are the same.](https://images.ctfassets.net/cdy7uua7fh8z/5Zv8FFGSOF6XqdyJ0LsoVJ/831ce96b5d8498c429ac4b884c882073/Dashboard_-_Tenant_Settings_-_Ignore_request_Host_header.png)\n\nIf hostname validation does not work as expected after disabling this toggle, you will receive a 4xx error to indicate your domain tenant and tenant associated with the `client_id` or `connection_id` are not the same.  \n\nOnce all application migrations have been successfully performed and confirmed in production environments, then you can disable the switch permanently to ensure that the deprecated features can no longer be used. After June 9, 2022 in Public Cloud and September 9, 2022 in Private Cloud, Auth0 will enforce hostname validation and  the associated switch will be removed from your tenant settings.",
  "title": "Migrate Tenant Hostname Validation",
  "description": "Describes how to check tenant logs for deprecation notices so you can migrate your application domain ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-log-extensions",
  "markdown": "# Migrate from Log Extensions\n\nThe following Auth0 Log Extensions are now deprecated and will be supported until the end of life (EOL) dates listed below. It is no longer possible to create new extensions from this list of deprecated Log Extensions. You can set up equivalent functionality using log event streams or integrations on the [Auth0 Marketplace](https://marketplace.auth0.com/)\n\nThe following will reach EOL in Private Cloud on **January 6, 2023**:\n\n*   Auth0 Authentication API Webhooks\n    \n*   Auth0 Management API Webhooks\n    \n*   Logs to Cloudwatch\n    \n*   Logs to Logentries\n    \n*   Logs to Loggly\n    \n*   Logs to Logstash\n    \n*   Logs to Papertrail\n    \n*   Logs to Splunk\n    \n*   Logs to Sumo Logic\n    \n\nReach EOL in Public Cloud on **May 2, 2023**:\n\n*   Auth0 Authentication API Webhooks\n    \n*   Auth0 Management API Webhooks\n    \n*   Logs to Cloudwatch\n    \n*   Logs to Logentries\n    \n*   Logs to Loggly\n    \n*   Logs to Logstash\n    \n*   Logs to Papertrail\n    \n*   Logs to Splunk\n    \n*   Logs to Sumo Logic\n    \n*   Logs to Segment\n    \n*   Logs to Mixpanel\n    \n*   Logs to AppInsights\n    \n*   Logs to Azure Blob Storage\n    \n\nAs of the EOL dates listed, Auth0 will no longer support the installed log extensions from the list above. On this page, you'll find instructions for migrating from specific log extensions.\n\n## Auth0 Authentication API Webhooks\n\nMake sure your destination can handle an array of log objects.\n\n1.  [Login to your Auth0 Dashboard](https://manage.auth0.com/).\n    \n2.  Go to **Extensions** and select your **Auth0 Authentication API webhook** in the **Installed Extensions** tab.\n    \n3.  Copy the **Webhook URL** and **Authorization Header** (if you have one).\n    \n4.  Next, go to **Monitoring > Streams > New Event Stream**.\n    \n5.  Select [**Custom Webhook**](https://auth0.com/docs/customize/log-streams/custom-log-streams), enter a name, and click **Create**.\n    \n6.  Configure your webhook.\n    \n    *   For the **Payload URL**, enter the webhook URL you copied from the extension.\n        \n    *   If you have one, set the **Authorization Token** to the Authorization Header you copied from the extension.\n        \n    *   Set **Content Format** to JSON Array.\n        \n7.  Click **Save**.\n    \n8.  Go back to **Extensions > Installed Extensions** and disable your **Auth0 Authentication API webhooks** extension.\n    \n\n## Auth0 Management API Webhooks\n\nMake sure your destination can handle an array of log objects.\n\n1.  [Login to your Auth0 Dashboard](https://manage.auth0.com/).\n    \n2.  Go to **Extensions** and select your **Auth0 Management API webhook** in the **Installed Extensions** tab.\n    \n3.  Copy the **Webhook URL** and **Authorization Header** (if you have one).\n    \n4.  Go to **Monitoring > Streams > New Event Stream**.\n    \n5.  Select [**Custom Webhook**](https://auth0.com/docs/customize/log-streams/custom-log-streams), enter a name, and click **Create**.\n    \n6.  Configure your webhook.\n    \n    *   For the **Payload URL**, enter the webhook URL you copied from the extension.\n        \n    *   If you have one, set the **Authorization Token** to the Authorization Header you copied from the extension.\n        \n    *   Set **Content Format** to JSON Array.\n        \n7.  Click **Save**.\n    \n8.  Go back to **Extensions > Installed Extensions** and disable your **Auth0 Management API webhooks** extension.\n    \n\n## CloudWatch\n\nSet up the [Amazon EventBridge Integration](https://marketplace.auth0.com/integrations/amazon-log-streaming) available on the Auth0 Marketplace. Once the events are available on your event bus, [create rules](https://docs.aws.amazon.com/eventbridge/latest/userguide/create-event-bus.html) to map those events to AWS CloudWatch. Make sure you disable your Auth0 Logs to CloudWatch extension:\n\n1.  [Login to your Auth0 Dashboard](https://manage.auth0.com/).\n    \n2.  Go to **Extensions > Installed Extensions**.\n    \n3.  Disable the **Auth0 Logs to CloudWatch** extension.\n    \n\n## Loggly\n\n1.  [Login to your Loggly account](https://www.loggly.com/login/).\n    \n2.  Open the **Logs** menu and select **Source Setup**.\n    \n3.  Go to the **Customer Tokens** tab.\n    \n4.  Copy your token.\n    \n5.  [Login to your Auth0 Dashboard](https://manage.auth0.com/).\n    \n6.  Go to **Monitoring > Streams > New Event Stream**.\n    \n7.  Select [**Custom Webhook**](https://auth0.com/docs/customize/log-streams/custom-log-streams), enter a name and click **Create**.\n    \n8.  Configure your webhook.\n    \n    *   For the **Payload URL**, replace `LOGGLY_TOKEN` with the token you copied from your Loggly account: `https://logs-01.loggly.com/bulk/{LOGGLY_TOKEN}/tag/auth0-{TENANT_NAME}/`.\n        \n    *   Leave **Authorization Token** blank.\n        \n    *   Set the **Content Type** to `application/json`.\n        \n    *   Set **Content Format** to JSON Lines.\n        \n9.  Click **Save**.\n    \n10.  Go to **Extensions > Installed Extensions** and disable your **Auth0 Logs to Loggly** extension.\n    \n\n## Logstash\n\n1.  [Login to your Auth0 Dashboard](https://manage.auth0.com/).\n    \n2.  Go to **Monitoring > Streams > New Event Stream**.\n    \n3.  Select [**Custom Webhook**](https://auth0.com/docs/customize/log-streams/custom-log-streams), enter a name, and click **Create**.\n    \n4.  Configure your webhook.\n    \n    *   For the **Payload URL**, enter the URL of your Logstash server.\n        \n    *   Set the **Authorization Token** to `Basic <CREDENTIALS>`, replacing `CREDENTIALS` with the Base64 encoding of your Logstash user and password separated by a colon (`<USER:PASSWORD>`). You can find your Logstash HTTP credentials in your Logstash configuration file.\n        \n5.  Click **Save**.\n    \n6.  Go to **Extensions > Installed Extensions** and disable your **Auth0 Logs to Logstash** extension.\n    \n\n## Papertrail\n\n1.  Login to Papertrail.\n    \n2.  Go to [Log Destinations](https://papertrailapp.com/account/destinations) then click [Create Log Destination](https://papertrailapp.com/destinations/new).\n    \n3.  Provide a description and configure the destination settings.\n    \n4.  In the **Accept Connections via ...** pane, select **Token**.\n    \n5.  Click **Create**.\n    \n6.  [Login to your Auth0 Dashboard](https://manage.auth0.com/).\n    \n7.  Go to **Monitoring > Streams > New Event Stream**.\n    \n8.  Select [**Custom Webhook**](https://auth0.com/docs/customize/log-streams/custom-log-streams), enter a name, and click **Create**.\n    \n9.  Configure your webhook.\n    \n    *   Set the **Payload URL** to `https://logs.collector.solarwinds.com/v1/logs`.\n        \n    *   Set the **Authorization Token** to `Basic <CREDENTIALS>`, replacing `CREDENTIALS` with the Base64 encoding of the Papertrail token you got from Papertrail's destination settings.\n        \n    *   Set **Content Format** to JSON Lines.\n        \n10.  Click **Save**.\n    \n11.  Go to **Extensions > Installed Extensions** and disable your **Auth0 Logs to Papertrail** extension.\n    \n\n## Splunk\n\nUse the [Splunk Integration](https://marketplace.auth0.com/integrations/splunk-log-streaming) available on the Auth0 Marketplace. Make sure you disable your Auth0 Logs to Splunk extension:\n\n1.  [Login to your Auth0 Dashboard](https://manage.auth0.com/).\n    \n2.  Go to **Extensions > Installed Extensions**.\n    \n3.  Disable the **Auth0 Logs to Splunk** extension.\n    \n\n## Sumo Logic\n\nUse the [Sumo Logic Integration](https://marketplace.auth0.com/integrations/sumo-logic-log-streaming) available on the Auth0 Marketplace. Make sure you disable your Auth0 Logs to Sumo Logic extension:\n\n1.  [Login to your Auth0 Dashboard](https://manage.auth0.com/).\n    \n2.  Go to **Extensions > Installed Extensions**.\n    \n3.  Disable the **Auth0 Logs to Sumo Logic** extension.\n    \n\n## Logentries\n\nCurrently, there are no instructions for migrating from the Logs to Logentries extension to log streams.\n\n## Segment\n\n1.  Login to your Auth0 dashboard\n    \n2.  Within **Extensions > Installed Extensions**, find your Segment extension.\n    \n3.  Take note of your **Write Key**, as you’ll need it for your new log stream to Segment.\n    \n4.  Disable your Segment extension.\n    \n5.  Take note of the UTC timestamp of the last log you have received in Segment. Knowing that timestamp will allow you to create your new stream while avoiding duplicate logs in Segment.\n    \n6.  Go to **Monitoring > Log Streams**, and create a new Segment log stream. Enter your **Write Key** in the appropriate field and the timestamp you noted in the **Start From** section.\n    \n7.  Create the stream\n    \n\n## Mixpanel\n\n1.  Login to your Mixpanel account, open your **Project Settings**. Take note of your **Project ID** and **Data Residency** (the region).\n    \n2.  Mixpanel no longer recommends using your project token for importing events and recommends using the service account mechanism. Within the **Project Settings** page, select **Service Accounts**, and create a new service account with admin or owner permissions. Take note of the credentials.\n    \n3.  Log in to your Auth0 dashboard.\n    \n4.  In **Monitoring > Log Streams**, create a new Mixpanel stream. Enter the project id, region, service account credentials and create the stream.\n    \n5.  Don’t forget to deactivate your old extension. Go to **Extensions > Installed Extensions** and disable the **Auth0 Logs to Mixpanel extension**.\n    \n\n## AppInsights\n\n1.  Set up an [Azure EventGrid Log Stream](https://marketplace.auth0.com/integrations/azure-log-streaming) or leverage your existing EventGrid stream.\n    \n2.  Follow the [instructions posted by Azure](https://urldefense.com/v3/__https://learn.microsoft.com/en-us/azure/event-grid/auth0-log-stream-app-insights__;!!PwKahg!9T9C3qhBRgQQHChQkQqnmHDDnX99yWJ4W8F4rLVs6qrwwbnFCY3JcCfF486d1DLqRFEghVnJZ9gJnronDv0$) to set a destination for the log events.\n    \n3.  Logs may be transformed differently through Log Streaming. Please reference the deprecated [Log Extenstion code](https://github.com/auth0-extensions/auth0-logs-to-provider/blob/master/server/lib/senders/appinsights.js) for further details\n    \n\nNotable transformations done to the logs include:\n\n*   The appInsight client is overwritten:\n    \n    *   Sets a custom time equivalent to the log time\n        \n    *   OS and OS version to be equivalent to the log information\n        \n    *   Device type tag to hold information on whether the log originated from a mobile source\n        \n    *   IP address tag be equivalent to the log information\n        \n    *   user id, account id, user agent and auth user id tags to be equivalent to the logs\n        \n*   The record is cleaned up to delete the following properties if empty:\n    \n    *   ip\n        \n    *   user\\_id\n        \n    *   user\\_name\n        \n    *   connection\n        \n    *   client\\_name\n        \n    *   description\n        \n*   The record isMobile property is altered to contain either a yes or no string\n    \n*   The record details property is altered to be a string\n    \n*   The record details property is truncated to 8185 characters\n    \n\n## Azure Blob Storage\n\n1.  Set up an [Azure EventGrid Log Stream](https://marketplace.auth0.com/integrations/azure-log-streaming) or leverage your existing EventGrid stream.\n    \n2.  Follow the [instructions posted by Azure](https://urldefense.com/v3/__https://learn.microsoft.com/en-us/azure/event-grid/auth0-log-stream-blob-storage__;!!PwKahg!9T9C3qhBRgQQHChQkQqnmHDDnX99yWJ4W8F4rLVs6qrwwbnFCY3JcCfF486d1DLqRFEghVnJZ9gJ5k9lKMM$) to set a destination for the log events.\n    \n3.  Logs may be transformed differently through Log Streaming. Please reference the deprecated [Log Extenstion code](https://github.com/auth0-extensions/auth0-logs-to-provider/blob/master/server/lib/senders/blobstorage.js) for further details\n    \n\nNotable transformations done to the logs include:\n\n*   The record `type_code` and `type` is adjusted. `Type` is the human-readable description of the `type_code`\n    \n*   Record `os`, `os_version`, `device` and `device_version` is adjusted if the record contains `user_agent` information",
  "title": "Migrate from Log Extensions",
  "description": "Migrate from log extensions to log streams or Auth0 Marketplace integrations.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-nodejs-16",
  "markdown": "# Migrate to Node.js 16\n\nOn 30 Apr 2022, [Node.js v12 went out of long-term support (LTS)](https://github.com/nodejs/Release#release-schedule), which means that the Node.js development team no longer back-ports critical security fixes to this version. This could potentially expose your extensibility code to security vulnerabilities. Therefore, Auth0 is migrating from Node 12 to Node 16.\n\n## Recommendations\n\nAlthough the Node 16 update will not introduce any breaking changes in the Node.js standard library (Rules and Custom Database Action Scripts are affected; see the [Breaking changes - Rules and Custom Database Action Scripts only](#breaking-changes-rules-only) section), we encourage customers on Node version 12 to stay current with Active Long-Term Support (LTS) Node versions for security and compliance purposes. Customers who are still on Node 8 are out of security compliance and must migrate to Node 16 to eliminate security risks. We removed the Node 8 runtime on 22 Feb 2022 for Public Cloud tenants and removed it in the April 2022 Private Cloud release. After these dates, tenants still set to Node 8 run the risk of a service interruption.\n\nActions is designed to support multiple versions of node concurrently, and currently supports both Node 12 and Node 16. In addition, no-code Actions Integrations will follow industry-standard \"always current\" version control with minor versions updated automatically; the underlying code will always remain current and to the latest version of Node.js.\n\n| Customers Using | Should | Task |\n| --- | --- | --- |\n| Actions Node 12 | Update any existing custom Action versions to a new version, which will update to Node 16. | Update all custom Action versions as soon as possible. |\n| Legacy Node 12 (Rules/Hooks/Extensions) | Begin migrating to Actions Node 16. | [Migrate to Actions Node 16](https://auth0.com/docs/customize/actions/migrate) as soon as possible. |\n| Legacy Node 8 | Immediately migrate to Actions wherever possible. For Rules and Hooks that cannot immediately be migrated to Actions, you must, at a minimum, update your code to Node 12 and update tenant settings to Node 12. | [Migrate to Actions Node 16](https://auth0.com/docs/customize/actions/migrate) immediately. |\n\n## Tasks\n\n### Upgrade Actions\n\nExisting Actions built on Node 12 can be upgraded to Node 16 and later reverted to a previous version on Node 12 if needed. Upgrade Actions to Node 16 by [creating and deploying a new version](https://auth0.com/docs/customize/actions/manage-versions) set to use Node 16 as the runtime.\n\n### Migrate Rules and Hooks to Actions\n\nWherever possible, migrate Rules and Hooks to Actions. To determine which Rules and Hooks can be migrated, read [Actions Limitations](https://auth0.com/docs/customize/actions/limitations). To learn how to migrate your Rules and Hooks to Actions, see our guides available at [Migrate to Actions](https://auth0.com/docs/customize/actions/migrate).\n\n### Enable Node 16 runtime\n\nIf you use any legacy extensibility products, like Rules, Hooks, or Extensions, then you must enable the Node 16 runtime at the tenant level. We recommend that you first switch your development tenant to Node 16 runtime, test your configuration, then switch your production tenant.\n\n1.  Enable Node 16 on your development tenant using the **Extensibility** panel on the [Advanced Tenant Settings](https://manage.auth0.com/#/tenant/advanced) page of the Dashboard. Choose **Node 16** from the **Runtime** drop-down.\n    \n2.  Click **Save**.\n    \n3.  Check that you either do not have the items listed below, or have completed the migration steps for each.\n    \n4.  Test your configuration.When you finish testing, repeat steps 1 and 2 above using your production tenant to enable Node 16 in production.\n    \n\n### Breaking changes - Rules and Custom Database Action Scripts only\n\nRules run in a JavaScript sandbox. The sandbox supports the ECMAScript 6 language and a large number of Node.js (version 16+) modules. If you are using any of these global properties within Rules or Custom Database Action Scripts, [look for an alternative in our list of supported sandbox modules](https://auth0-extensions.github.io/canirequire/) and explicitly require it.\n\n*   `_`\n    \n*   `async`\n    \n*   `Auth0`\n    \n*   `azure_storage`\n    \n*   `bcrypt`\n    \n*   `crypto`\n    \n*   `couchbase`\n    \n*   `cql`\n    \n*   `ip`\n    \n*   `jwt`\n    \n*   `Knex`\n    \n*   `mongo`\n    \n*   `mysql`\n    \n*   `mysql_pool`\n    \n*   `ObjectID`\n    \n*   `pbkdf2`\n    \n*   `pg`\n    \n*   `postgres`\n    \n*   `Pubnub`\n    \n*   `q`\n    \n*   `querystring`\n    \n*   `request`\n    \n*   `sqlserver`\n    \n*   `uuid`\n    \n*   `xml2js`\n    \n*   `xmldom`\n    \n*   `xpath`\n    \n*   `xtend`",
  "title": "Migrate to Node.js 16",
  "description": "Describes Auth0 features affected by the Node.js v12 to Node.js v16 migration and provides recommendations for migration.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-v2-v3",
  "markdown": "# Migrate from Search v2 to v3\n\nUser search v2 has reached its end of life as of **June 30, 2019**. We highly recommend migrating user search functionality to [search engine v3](https://auth0.com/docs/manage-users/user-search) (`search_engine=v3`) as soon as possible.\n\n## Migration considerations\n\nBefore you start migrating, there are a few things you should know:\n\n*   To ensure that your queries are using search engine v3 prior to v2 becoming unavailable, you must update all your calls to the `GET /api/v2/users` endpoint to include the `search_engine=v3` parameter. This will enable you to see whether any queries need to be updated, so that you will not experience downtime when v2 becomes unavailable.\n    \n*   If you are performing user search operations through any of the [impacted SDKs](#impacted-sdks), you must also pass the `search_engine=v3` parameter as outlined above.\n    \n*   Search values for the normalized user fields (`email`, `name`, `given_name`, `family_name`, and `nickname`) are case insensitive. All other fields (including all `app_metadata`/`user_metadata` fields) are case sensitive.\n    \n*   v3 limits the number of users you can retrieve to 1000. If you are reaching this limit, we recommend that you redefine your search query to obtain more granular results. If you need a list of more than 1000 users at a given time, we recommend that you use the [Export Job](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports) API endpoint or [User Import / Export Extension](https://auth0.com/docs/manage-users/user-migration/user-import-export-extension) instead.\n    \n*   Range and wildcard searches are not available on `app_metadata`/`user_metadata` fields.\n    \n*   User fields are not tokenized like in v2, so `user_id:auth0` will not match a `user_id` with value `auth0|12345`, instead, use `user_id:auth0*`.\n    \n*   Wildcards can be used for prefix matching, for example `name:j*`. For other uses of wildcards (e.g. suffix matching), literals must have 3 characters or more. For example, `name:*usa` is allowed, but `name:*sa` is not.\n    \n*   The `.raw` field extension is no longer supported and must be removed. In v3, fields match the whole value that is provided and are not tokenized as they were in v2 without the `.raw` suffix.\n    \n*   The `connection` field is not supported in v3. You should use its alias `identities.connection` instead.\n    \n\n## Queries to migrate\n\n| Use case | v2  | v3  |\n| --- | --- | --- |\n| Search by date | `updated_at:>=2018-01-15` | `updated_at:[2018-01-15 TO *]` |\n| Search by date | `updated_at:>2018-01-15` | `updated_at:{2018-01-15 TO *]` |\n| Search by date | `updated_at:<=2018-01-15` | `updated_at:[* TO 2018-01-15]` |\n| Search by date | `updated_at:<2018-01-15` | `updated_at:[* TO 2018-01-15}` |\n| Search by date | `last_login:<=2017-12` | `last_login:[* TO 2017-12]` |\n| String exact match | `name.raw:\"john richard doe\"` | `name:\"john richard doe\"` |\n| Phrase contains a word | `name:\"richard\"`, `name:richard` | `name:*richard*` |\n| Phrase contains a word (with less than 3 characters) | `name:*ri`,`name:*a`, `name:*ab*` | _(not supported)_ |\n\n## Impacted SDKs\n\nThe following SDKs make use of the User Search engine. If you are using them, make sure you are using the versions listed below (or a later version), and pass the `search_engine=v3` parameter when performing user search operations.\n\n| SDK | Version with support for v3 | Impacted methods | Considerations |\n| --- | --- | --- | --- |\n| [Auth0 Java](https://github.com/auth0/auth0-java) | 1.8.0 | com.auth0.client.mgmt.UsersEntity.list | Provide a `UserFilter` with `withSearchEngine(\"v3\")` |\n| [Auth0 Python](https://github.com/auth0/auth0-python) | 3.0.0 | management.Users.list | Provide the parameter `search_engine='v3'` |\n| [Auth0 Node](https://github.com/auth0/node-auth0) | 2.0.0 | UsersManager.getAll, ManagementClient.getUsers | Provide the parameter `search_engine:'v3'` |\n| [Auth0 .NET](https://github.com/auth0/auth0.net) | 3.0.0 or 4.0.0 | Auth0.ManagementApi.IUsersClient.GetAllAsync | Provide a `GetUsersRequest` object with `SearchEngine` = `\"v3\"` |\n| [Auth0 PHP](https://github.com/auth0/auth0-php) | 5.2.0 | Auth0.SDK.API.Management.Users.getAll | Provide the parameter `'search_engine' => 'v3'` |\n| [Auth0 Ruby](https://github.com/auth0/ruby-auth0) | 4.5.0 | Auth0.Api.V2.Users.users | Provide the parameter `search_engine: 'v3'` |\n\n## Impacted Extensions\n\nThe following Extensions make use of the User Search engine. If you have them installed, make sure you are using the versions listed below (or a later version).\n\n| Extension | Version support for v3 | Considerations |\n| --- | --- | --- |\n| [Authorization Extension](https://auth0.com/docs/extensions/authorization-extension/v2) | 2.5.0+ | If you are using an earlier version, you need to manually update the extension from the [Extensions](https://manage.auth0.com/#/extensions) page. |\n| [Delegated Administration](https://auth0.com/docs/extensions/delegated-admin/v3) | 3.1+ | If you are using an earlier version, you need to manually update the extension from the [Extensions](https://manage.auth0.com/#/extensions) page. The `SEARCH_ENGINE` configuration setting no longer exists in 3.1, because only User Search v3 is available. |\n\n## Leverage your tenant logs to find usage of User Search v2\n\nYou can leverage the [logs](https://auth0.com/docs/deploy-monitor/logs) in the [Dashboard](https://manage.auth0.com/#/logs) to find calls to the `/api/v2/users` endpoint that use the User Search v2 engine, including calls performed by SDKs. Those logs will help you identify where code changes might be needed in your applications.\n\nUse the following query to retrieve all the logs related to User Search v2: `type:w AND description:*search_engine*`. The logs will provide additional information in the description field, in the following cases:\n\n*   Queries that might produce different results in v3\n    \n*   Queries with syntax incompatible with v3\n    \n*   Queries that do not meet the paging requirements of v3\n    \n\nIf no additional details are specified in the log entries, it's likely that your queries are compatible with v3. Our recommendation, however, is still that you test the queries before deploying your changes to production.\n\nPlease note that only one log of the same type will be generated within 60 minutes. This means that even though you may be doing multiple calls to the User Search endpoint, you will only see one log of each type per hour.",
  "title": "Migrate from Search v2 to v3",
  "description": "Learn how to migrate from Auth0 Search v2 to v3.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-tenant-member-roles",
  "markdown": "# Migrate to New Tenant Member Roles\n\nThe **Application Admin** Dashboard role will no longer be available after **01 February 2021**. That role is being replaced with the new **Editor - Specific Apps** role. Existing tenants will be able to keep the deprecated role during the grace period. Once the role reaches its end of life, any existing tenant member that has that role will be automatically reassigned to the new **Editor - Specific Apps** role. The new role provides edit access to the same set of applications but will not have permission to access connections and users.\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## What's changing\n\nPreviously, if you were a tenant administrator, you could invite additional administrators to have access to the Auth0 Dashboard and all or specific applications within that tenant. That role was called **Application Admin**. The tenant members with that role were given full access to the selected application(s) settings plus read-access to non-enterprise connections and users. After 01 February 2021, the Application Admin role as defined above will be replaced by a new set of least privileged roles.\n\n### Why are we making this change\n\nThe new set of roles covers a wider range of use cases for Dashboard access. The Application Admin role is replaced by a similar but more restrictive **Editor - Specific Apps** role. The new role has access to the selected application(s), but not to connections and users, securing your data and complying with the least privileged principle. If you have team members who require additional access, you can grant access to connections and users by assigning them additional roles.\n\n### Grace period and end of life\n\nYou will be able to keep the experience for existing members with the Application Admin role during the grace period but you won't be able to invite any new members with that role. Beginning on 01 February 2021 for Public Cloud tenants, and after the March 2021 release for Private Cloud tenants.\n\nYour tenants will be affected by this deprecation if the following criteria are met:\n\n*   Created before 01 February 2021 (Public Cloud tenants) or before upgrading to the March 2021 release (Private Cloud tenants)\n    \n*   Have at least one tenant member with the **Application Admin** role\n    \n*   Haven't opted-in to the Dashboard roles feature preview (only applicable to Public Cloud enterprise tenants)\n    \n\nBeginning on 01 February 2021 for Public Cloud tenants, and after the March 2021 release for Private Cloud tenants, Auth0 will display tenant logs and a migration toggle to help you prepare for this change.\n\nThe Application Admin role will reach its end of life in the Public Cloud on 30 September 2021. Existing Application Admins will be automatically converted to the new Editor Specific Apps role at that time. For plans where the role is not available, any existing tenant member that has the Application Admin role assigned may be removed. You should migrate these members to Admins or remove them from the dashboard to prevent this situation.\n\nThe Application Admin role will be available for affected Private Cloud tenants until September 2021 monthly release which is the first release that will not include the Application Admin role.\n\n## Actions\n\n### Automatically assign new roles\n\nThis will convert any existing members that have the **Application Admin** role to the new **Editor - Specific Apps** role with permission to manage the same set of applications.\n\n1.  Go to [Dashboard > Tenant Settings > Tenant Members](https://manage.auth0.com/#/tenant/admins) and review which members have the **Application Admin** role assigned. (You may want to communicate to those members that their experience in the Dashboard will change: they will lose access to Users and Connections sections.)\n    \n    ![Dashboard - Tenant Settings - Tenant Members](https://images.ctfassets.net/cdy7uua7fh8z/1lsoGSi3Wgou5SF1iGAIgH/93fbd705f03bbdca5791e485e1b23ac1/tenant-settings-tenant-admins.png)\n2.  Go to [Dashboard > Tenant Settings > Advanced](https://manage.auth0.com/#/tenant/advanced) and under **Migrations**, turn off the **Application Admin role** migration toggle.\n    \n    ![Dashboard - Tenant Settings - Advanced - Migrations - Application Admin role](https://images.ctfassets.net/cdy7uua7fh8z/1kP71pL5U6mgcNyx9Ry8OY/b4e69d0cf9d05807a97646f3a76da6a2/tenant-settings-migrations.png)\n    \n    This will convert any existing members that have the **Application Admin** role to the new **Editor - Specific Apps** role with permission to manage the same set of applications.\n    \n3.  If your plan doesn't support the Editor roles, please refer to the [subscription page](https://manage.auth0.com/#/tenant/billing/subscription) for relevant plans to enable the feature and keep it. Otherwise, proceed to manually assign members a supported role.\n    \n\n### Manually assign new roles\n\nDo the following steps to ensure the members are assigned to a role supported by your subscription.\n\n1.  Go to [Dashboard > Tenant Settings > Tenant Members](https://manage.auth0.com/#/tenant/admins) and review which members have the **Application Admin** role assigned.\n    \n    1.  Go to [Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs) and see whether any of those members have used the Dashboard lately.\n        \n    2.  Use the following query to search for related logs: `type:depnote AND description:*Admin*`.\n        \n2.  Go back to the **Tenant Members** tab under **Tenant Settings** and either remove those members or edit their roles to assign them one or more of the new roles that are supported in your subscription plan.\n    \n\n## Learn more\n\n*   [Auth0 Dashboard](https://auth0.com/docs/get-started/auth0-overview/dashboard)\n*   [Manage Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access)\n*   [Dashboard Access by Role](https://auth0.com/docs/get-started/manage-dashboard-access/feature-access-by-role)\n*   [Add Tenant Members](https://auth0.com/docs/get-started/manage-dashboard-access/add-dashboard-users)\n*   [Edit Tenant Members](https://auth0.com/docs/get-started/manage-dashboard-access/edit-dashboard-users)",
  "title": "Migrate to New Tenant Member Roles",
  "description": "Learn how to migrate to the new Dashboard tenant member roles feature.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-nodejs-12",
  "markdown": "# Migrate from Node.js 8 to Node.js 12\n\nAs of December 31, 2019, [Node.js v8 went out of long-term support (LTS)](https://github.com/nodejs/Release#release-schedule), which means that the Node.js development team no longer back-ports critical security fixes to this version. This could potentially expose your extensibility code to security vulnerabilities. Therefore, Auth0 migrated from Node 8 to Node 12.\n\n## Features affected\n\nThe following Auth0 features use Node 8:\n\n*   Rules\n    \n*   Hooks\n    \n*   Custom database connections\n    \n*   Custom social connections\n    \n*   Extensions\n    \n\nIf you do not use any of the extensibility features mentioned above, then you are not affected by this migration.\n\n## Tasks\n\nAs part of the process of introducing Node 12 in our Webtask runtime, we ran a number of tests to determine which modules are not forward-compatible from Node 8 to 12. Most customers should be able to upgrade to Node 12 without any issues.\n\nThat said, before you migrate, we highly recommend testing all of your:\n\n*   Rules\n    \n*   Hooks\n    \n*   Custom database connections and scripts\n    \n*   Custom social connections\n    \n*   Extensions\n    \n\nAuth0 recommends that that you first switch your development tenant to Node 12 runtime, complete testing in your development tenant, and migrate your production tenant only when you see no issues in development.\n\n### Enable Node 12 runtime\n\nThere may be additional behavioral changes as a result of this migration, so we have provided a migration switch that allows you to control the migration of your environment to the new Webtask runtime using Node 12.\n\nAuth0 recommends that that you first switch your development tenant to Node 12 runtime, complete testing in your development tenant, and migrate your production tenant only when you see no issues in development.\n\nYou can query the [Management API](https://auth0.com/docs/api) for your rules, hooks, custom database scripts, and custom social connections. This will make it easier for you to move items from your production tenant to development tenant for testing purposes.\n\nWhen using the Connections endpoints in the Management API, custom database scripts can be retrieved or updated using `options.customScripts`. Similarly, you can find custom social connections in `options.scripts.fetchUserProfile`.\n\n1.  Enable Node 12 on your development tenant using the new **Extensibility** panel on the [Advanced Tenant Settings](https://manage.auth0.com/#/tenant/advanced) page of the Dashboard. Choose **Node 12** from the **Runtime** drop-down.\n    \n2.  Click **Save**.\n    \n3.  If you use the items listed below, complete the migration steps for each of them.\n    \n4.  Test your configuration.\n    \n5.  Once you are sure that nothing has broken, use steps 1 and 2 above to enable Node 12 on your production tenant.\n    \n\n### Allowlist new URLs\n\nThe Delegated Administration Extension and the Single Sign-on (SSO) Dashboard Extension require allowlisting the URLs used to access extensions and custom webtasks. When you upgrade to Node 12, the URLs you use to access extensions and custom webtasks will change. This is a breaking change for these extensions.\n\nIf you use any of these extensions, you must allowlist the new URLs both as Allowed Callback and as Allowed Logout URLs.\n\nThe region portion of the URL will change from 8 to 12. If you access an extension using the URL:\n\n`https://{yourTenant}.us8.webtask.io/dummy-extension-url`\n\nwhen you upgrade to Node 12, the URL will be:\n\n`https://{yourTenant}.us12.webtask.io/dummy-extension-url`\n\n1.  Go to [Dashboard > Applications > Applications > Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings), and add the URL to the fields **Allowed Callback URLs** and **Allowed Logout URLs**.\n    \n2.  The execution URLs will also change for custom webtasks in your Auth0 container. You must update any external applications that call those webtasks.\n    \n\nIf you use the Authorization Extension, it generates an `auth0-authorization-extension` rule. Republish this rule from within the Authorization Extension to update the URLs automatically.\n\n1.  Ensure you have upgraded to the latest version of the Authorization Extension from the **Installed Extensions** tab. If the **Upgrade** button is present, click to upgrade. If the button is not present, you are already on the latest version of the extension.\n    \n2.  Open the **Authorization Extension** configuration page.\n    \n3.  To update the URL in the rule, publish the rule again by clicking the **Publish Rule** button.\n    \n4.  Test to make sure everything is still working. If you see an Invalid API Key error after updating, click the **Rotate** button to generate a new API key.\n    \n    ![Dashboard - Extensions - Authorization Extension - Configuration Menu](https://images.ctfassets.net/cdy7uua7fh8z/4tbAUGHNxx9Bp8qOcmzyLm/d136a1d690dd2285ca93ee97f8849c48/node-auth-ext-config.png)![Authorization Extension Buttons Screen](https://images.ctfassets.net/cdy7uua7fh8z/6eDTw2X06e3Z9UPyEdOdGp/827014067a3f84883c514aa8a8025e0b/node-auth-ext-buttons.png)\n\n### Configure Delegated Administration URLs\n\nIf you use the Delegated Administration Extension, the matrix that follows contains the updated URLs you must configure after you migrate to Node 12. The URL varies based on your location.\n\n| Location | Allowed Callback URL for Node 12 | Allowed Logout URL for Node 12 |\n| --- | --- | --- |\n| US-1 | `https://{yourTenant}.us12.webtask.io/auth0-delegated-admin/login` | `https://{yourTenant}.us12.webtask.io/auth0-delegated-admin` |\n| US-3 | `https://{yourTenant}.us.webtask.run/auth0-delegated-admin/login` | `https://{yourTenant}.us.webtask.run/auth0-delegated-admin` |\n| EU  | `https://{yourTenant}.eu12.webtask.io/auth0-delegated-admin/login` | `https://{yourTenant}.eu12.webtask.io/auth0-delegated-admin` |\n| AU  | `https://{yourTenant}.au12.webtask.io/auth0-delegated-admin/login` | `https://{yourTenant}.au12.webtask.io/auth0-delegated-admin` |\n| JP-1 | `https://{yourTenant}.jp.webtask.run/auth0-delegated-admin/login` | `https://{yourTenant}.jp.webtask.run/auth0-delegated-admin` |\n\nFor example, if you are located in the USA and you use the Delegated Administration, you should update the following fields in your application's settings:\n\n*   **Allowed Callback URLs**: `https://{yourTenant}.us12.webtask.io/auth0-delegated-admin/login`\n    \n*   **Allowed Logout URLs**: `https://{yourTenant}.us12.webtask.io/auth0-delegated-admin`\n    \n\n### Configure SSO Dashboard URLs\n\nThe matrix that follows contains the updated URLs you must configure after you migrate to Node 12. The URL varies based on your location.\n\nThe login URL for Admins:\n\n| Location | Allowed Callback URL |\n| --- | --- |\n| US-1 | `https://{yourTenant}.us12.webtask.io/auth0-sso-dashboard/admins/login` |\n| US-3 | `https://{yourTenant}.us.webtask.run/auth0-sso-dashboard/admins/login` |\n| Europe | `https://{yourTenant}.eu12.webtask.io/auth0-sso-dashboard/admins/login` |\n| Australia | `https://{yourTenant}.au12.webtask.io/auth0-sso-dashboard/admins/login` |\n| Japan | `https://{yourTenant}.jp.webtask.run/auth0-sso-dashboard/admins/login` |\n\nThe login URL for Users:\n\n| Location | Allowed Callback URL |\n| --- | --- |\n| US-1 | `https://{yourTenant}.us12.webtask.io/auth0-sso-dashboard/login` |\n| US-3 | `https://{yourTenant}.us.webtask.run/auth0-sso-dashboard/login` |\n| Europe | `https://{yourTenant}.eu12.webtask.io/auth0-sso-dashboard/login` |\n| Australia | `https://{yourTenant}.au12.webtask.io/auth0-sso-dashboard/login` |\n| Japan | `https://{yourTenant}.jp.webtask.run/auth0-sso-dashboard/login` |\n\n### Update Extensions\n\nMost extensions use the `PUBLIC_WT_URL` hidden secret for authorization. This secret depends on the runtime version and does not update automatically.\n\nTo update it, you need to save the extension's settings (no changes are necessary). To do so, after switching the runtime to `Node 12`, you need to open the extension's settings in the extensions dashboard (gear icon), and click `Save`. After that, the extensions gallery will update the `PUBLIC_WT_URL` secret based on the selected runtime.\n\nIf you do not update the `PUBLIC_WT_URL` hidden secret, you will receive the following error:\n\n![Misconfiguration or Service Outage Error](https://images.ctfassets.net/cdy7uua7fh8z/4mq5ebCa83XNLlbn28pp9s/beb869df9a11d188f30332030655ac9d/node-hidden-secret-error.png)\n\n### Update pinned modules\n\nIf you are using the following built-in modules (that is, modules that you did not explicitly require), please be aware that some versions were updated to work with Node 12. The following table summarizes the changes. These new versions should remain backwards compatible with their previous versions.\n\n| Module name | Old version | New version |\n| --- | --- | --- |\n| couchbase | ~2.5.1 | 2.6.10 |\n| bcrypt | 1.0.3 | 3.0.8 |\n\nIf you have manually pinned modules, you may need to manually update them so that your code runs with Node 12.\n\nFor example, you must change:\n\n`var bcrypt = require(‘bcrypt@1.0.3’);`\n\nto\n\n`var bcrypt = require(‘bcrypt’);`\n\nor, if the module must be pinned to a specific version:\n\n`var bcrypt = require(‘bcrypt@3.0.8’);`",
  "title": "Migrate from Node.js 8 to Node.js 12",
  "description": "Describes Auth0 features affected by the Node.js v8 to Node.js v12 migration and provides recommendations for migration.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/clickjacking-protection-for-universal-login",
  "markdown": "# Clickjacking Protection for Universal Login Change\n\nClickjacking is an attack that tricks a user into clicking a web page element which is invisible or disguised as another element. This is done by loading content in an iframe and rendering elements on top of it. In the context of the Universal Login pages, an attacker could trick the user into clicking a **Login**, or **Reset Password** button.\n\nThis can be prevented by setting the following HTTP headers:\n\n`X-Frame-Options: deny Content-Security-Policy: frame-ancestors 'none'`\n\nEven if the potential attack does not entail significant risk, it's a good security practice to add the headers. It is also detected by security scanners, so reports from penetration testers might mention the lack of these headers.\n\n## Actions\n\nIn cases where you render the login page in an iframe, adding these headers could be a breaking change. Instead of adding these headers for all customers, therefore, Auth0 has allowed you to opt-in for these headers, which we strongly recommend you to enable.\n\nThe following action is not required if you are using the New Universal Login Experience because those headers are always set in that case.\n\nTo opt in to this change:\n\n1.  Go to [Tenant Settings > Advanced Settings](https://manage.auth0.com/#/tenant/advanced).\n    \n2.  Scroll to **Migrations**, and turn off the **Disable clickjacking protection for Classic Universal Login** setting.",
  "title": "Clickjacking Protection for Universal Login Change",
  "description": "Describes how Auth0 is adding a way to prevent the Universal Login pages from being embedded into an iframe to protect against clickjacking attacks.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-passwordless",
  "markdown": "# Migrate to Passwordless Endpoint from Confidential Applications\n\nAuth0 is deprecating the use of the `/passwordless/start` endpoint from confidential applications when Auth0 cannot authenticate that the call is made on behalf of the application.\n\nOAuth uses the term 'confidential' for applications that can store secrets. In Auth0, those are 'Regular Web Applications', which serve web pages from a backend app. Single Page Applications and Native Applications are considered 'public' applications, and are not affected by this change.\n\nAuth0 can authenticate calls to `/passwordless/start` when they include a `client_secret` as a parameter, or when the calls are made from the custom login page in Universal Login and forward the `state` parameter.\n\n## Features affected\n\nIf any of your applications currently call the `/passwordless/start` endpoint directly to begin passwordless authentication from a Web Application, and you are not sending the `client_secret` as a parameter, this deprecation does affect you.\n\nIf you are implementing passwordless authentication through the Universal Login page and you changed the default way Auth0 libraries are initialized, it might also affect you too.\n\nYou can verify whether you are affected by checking the [tenant logs](https://manage.auth0.com/#/logs), filtering by \"Deprecation Notice\" and check for logs saying \"Enforce client authentication for passwordless connections\". You can also perform this search directly with the following query: `type:depnote AND description:*passwordless*`. Note that this specific query will only work for public cloud tenants, as private cloud logs cannot be searched on the description field.\n\n## Actions\n\nIf you are calling the `/passwordless/start` endpoint without proper application authentication you should:\n\n*   Follow the instructions described below to adjust the code to properly call `/passwordless/start`.\n    \n*   Check your [tenant logs](https://manage.auth0.com/#/logs) to verify the change was made correctly and no deprecation logs are being generated for \"Enforce client authentication for passwordless connections\".\n    \n*   In the **Migrations** section of **Advanced Tenant Settings**, turn on the **Enforce client authentication for passwordless connections** toggle.\n    \n\nThere are a few use cases that might be affected, but for each, the migration path is fairly straightforward:\n\n### API calls from backend\n\nFor any calls from your backend to the `/passwordless/start` endpoint, your call must include the client secret as a parameter.\n\nIf making a POST request directly to `/passwordless/start`, include the `client_secret` as part of the payload:\n\nto configure this snippet with your account\n\n```\nPOST https://{yourDomain}/passwordless/start\n    Content-Type: application/json\n    {\n      \"client_id\": \"{yourClientId}\",\n      \"client_secret\": \"{yourClientSecret}\",\n      \"connection\": \"email|sms\",\n      \"email\": \"{userEmailAddress}\", //set for connection=email\n      \"phone_number\": \"{userPhoneNumber}\", //set for connection=sms\n      \"send\": \"link|code\",\n      \"authParams\": { \n          \"scope\": \"openid\",\n          \"state\": \"{yourState}\"\n        }\n      }\n```\n\nIf you are using an SDK, add the parameter to the method that initiates the passwordless flow. This is different for each SDK, and not all SDKs have been updated yet. If you are using an SDK that was not updated, you can make the HTTP call directly until that work is completed.\n\n### Auth0.js or Lock.js in the Universal Login page\n\nIf the Universal Login page is used for Passwordless Authentication for a Web Application, it will be making calls to the `/passwordless/start` endpoint, by either using Lock.js or Auth0.js.\n\nGiven you can't store a client secret in a web page, the way to authenticate the call is by forwarding the `state` parameter that is received in the Universal Login page to the `/passwordless/start` endpoint. That parameter is stored in the `config.internalOptions` field in the custom login page.\n\nThe default templates for customizing the login page use it in the following way when initializing Lock.js or auth0.js:\n\n```\nvar lock = new Auth0Lock(\n  config.clientID, \n  config.auth0Domain, \n  {\n    auth: {\n      // .. other fields set\n      params: {\n       scope: config.internalOptions.scope,\n       _csrf: config.internalOptions._csrf,\n       state: config.internalOptions.state,\n      }\n    }\n  });\n```\n\n```\nvar params = Object.assign({\n    scope: config.internalOptions.scope,\n    _csrf: config.internalOptions._csrf,\n    state: config.internalOptions.state,\n  }, {\n    // ...auth params\n  });\n\nvar webAuth = new auth0.WebAuth(params);\n```\n\nPlease check in your custom page implementation to verify that you have not removed that code.\n\n### Call /passwordless/start from the client in a web application\n\nIf you are calling the `/passwordless/start` endpoint from a page using JavaScript (for example, using Auth0.js on the page) from regular web apps, you will not be able to specify a client secret in a call made using JavaScript. If this is the case for your application, you will need to change your apps so that `/passwordless/start` is called from the backend of your web application, rather than from the frontend.\n\n### Rate Limits\n\nA consequence of adding client authentication to `/passwordless/start` is that Auth0 can trust the headers sent with the request. If you set the `auth0-forwarded-for` header, the IP address will show in the logs and be used for attack protection purposes.\n\nAuthenticated `/passwordless/start` requests will be treated as regular Authenticated API requests and the corresponding global Authentication API rate limit will apply.",
  "title": "Migrate to Passwordless Endpoint from Confidential Applications",
  "description": "Describes the migration steps you need to take because Auth0 is deprecating the usage of the /passwordless/start endpoint from confidential applications without a client secret in the request.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-calling-api-with-access-tokens",
  "markdown": "# Migrate to Management API Endpoints with Access Tokens\n\nUsing ID tokens to call Management API endpoints is being deprecated. You must use access tokens. The grace period for this migration started on **March 31, 2018**.\n\nAfter you complete your migration to access tokens, turn off the **Allow ID Tokens for Management API v2 Authentication** toggle in the Dashboard.\n\nIf you use ID tokens to call any of the following endpoints, then you are affected by this migration. These endpoints can now accept regular access tokens. Nothing else changes in how the endpoints work. You should expect the same request and response schemas and only need to update the token that you use for authorization.\n\n## Endpoints affected\n\n| Endpoint | Use Case |\n| --- | --- |\n| GET /api/v2/users/{id} | Retrieve a user's information |\n| GET /api/v2/users/{id}/enrollments | Retrieve all Guardian MFA enrollments for a user |\n| PATCH /api/v2/users/{id} | Update a user's information |\n| DELETE /api/v2/users/{id}/multifactor/{provider} | Delete the MFA provider settings for a user |\n| POST /api/v2/device-credentials | Create a public key for a device |\n| DELETE /api/v2/device-credentials/{id} | Delete a device credential |\n| POST/api/v2/users/{id}/identities | Link user accounts from various identity providers |\n| DELETE /api/v2/users/{id}/identities/{provider}/{user\\_id} | Unlink user accounts |\n\n## Actions\n\n### Scope changes\n\nThe actions you can perform with the Management API depend on the scopes that your access token contains. With this migration, you can either get a limited access token that can update only the logged-in user's data or an access token that can update the data of any user. In the following matrix, you can see the scopes that your token needs to have per case and per endpoint.\n\nFor example, if you get an access token that contains the scope `read:users`, you can retrieve the data of any user using the `GET /api/v2/users/{id}` endpoint. However, if your token contains the scope `read:current_user`, you can only retrieve the information of the currently logged-in user (the one that the token was issued for).\n\n| Endpoint | Scope for current user | Scope for any user |\n| --- | --- | --- |\n| GET /api/v2/users/{id} | `read:current_user` | `read:users` |\n| GET /api/v2/users/{id}/enrollments | `read:current_user` | `read:users` |\n| POST/api/v2/users/{id}/identities | `update:current_user_identities` | `update:users` |\n| DELETE /api/v2/users/{id}/identities/{provider}/{user\\_id} | `update:current_user_identities` | `update:users` |\n| PATCH /api/v2/users/{id} | `update:current_user_metadata` | `update:users` |\n| PATCH /api/v2/users/{id} | `create:current_user_metadata` | `update:users` |\n| DELETE /api/v2/users/{id}/multifactor/{provider} | `delete:current_user_metadata` | `update:users` |\n| POST /api/v2/device-credentials | `create:current_user_device_credentials` | `create:device_credentials` |\n| DELETE /api/v2/device-credentials/{id} | `delete:current_user_device_credentials` | `delete:device_credentials` |\n\n### Get access tokens\n\nAuth0 has changed how you get a token for the previously mentioned endpoints. There are several variations on how you authenticate a user and get tokens, depending on the technology and the OAuth 2.0 flow you use to authenticate:\n\n*   **SPA running in a browser**: Use the Authorization endpoint.\n    \n*   **Web app running on a server, a mobile app, a server process, or a highly trusted app**: Use the Token endpoint.\n    \n*   **Cross-authentication**: Use embedded Lock or auth0.js to authenticate users when the requests come from different domains.\n    \n\nIn this section, we will use an example to show the differences in how you get a token with the Authorization endpoint. Keep in mind that no matter which endpoint you want to migrate, the changes are the same, the only thing that differs is the scopes that you specify in the request.\n\nIn the example below, you use the `GET User by ID` endpoint to retrieve the full profile information of the logged-in user. To do so, first, we will authenticate the user using the Implicit grant and retrieve the token(s). Below you can see an implementation of the old approach that gets an ID Token and then uses it to call the endpoint.\n\nto configure this snippet with your account\n\n```\nhttps://{yourDomain}/authorize?\n      scope=openid\n      &response_type=id_token\n      &client_id={yourClientId}\n      &redirect_uri=https://{yourApp}/callback\n      &nonce={nonce}\n      &state={opaqueValue}\n```\n\nIn the example below, you can see the new approach that gets an access token.\n\nto configure this snippet with your account\n\n```\nhttps://{yourDomain}/authorize?\n      audience=https://{yourDomain}/api/v2/\n      &scope=read:current_user\n      &response_type=token%20id_token\n      &client_id={yourClientId}\n      &redirect_uri=https://{yourApp}/callback\n      &nonce={nonce}\n      &state={opaqueValue}\n```\n\nTo get an access token that can access the Management API:\n\n*   Set the `audience` to `https://{yourDomain}/api/v2/`\n    \n*   Ask for the scope `${scope}`\n    \n*   Set the `response_type` to `id_token token` so Auth0 will send both an ID token and an access token\n    \n\nIf you decode the received access token and review its contents you will see the following:\n\n```\n{\n      \"iss\": \"https://{yourDomain}/\",\n      \"sub\": \"auth0|5a620d29a840170a9ef43672\",\n      \"aud\": \"https://{yourDomain}/api/v2/\",\n      \"iat\": 1521031317,\n      \"exp\": 1521038517,\n      \"azp\": \"{yourClientId}\",\n      \"scope\": \"${scope}\"\n    }\n```\n\nNotice that `aud` is set to your tenant's API URI, `scope` is set to `${scope}`, and `sub` is set to the user ID of the logged-in user.\n\nOnce you have the access token you can use it to call the endpoint. This part remains the same, nothing else changes in the request except for the value you use as `Bearer` token. The response remains also the same.\n\n#### Token endpoint\n\nIn this section, we will use an example to show the differences in how you get a token with the Token endpoint. Keep in mind though that no matter which endpoint you want to migrate, the changes are the same, the only thing that differs is the scopes that you specify in the request.\n\nIn the example below, you want to use the `GET User by ID` endpoint to retrieve the full profile information of the logged-in user. First, authenticate the user using the Password Exchange grant and then retrieve the token(s). Below you can see an implementation of the old approach that gets an ID Token (and then uses it to call the endpoint).\n\nto configure this snippet with your account\n\n```\nPOST https://{yourDomain}/oauth/token\n    Content-Type: application/x-www-form-urlencoded\n    {\n      \"grant_type\": \"password\",\n      \"username\": \"{yourUsername}\",\n      \"password\": \"{yourPassword}\",\n      \"scope\": \"openid\",\n      \"client_id\": \"{yourClientId}\",\n      \"client_secret\": \"{yourClientSecret}\",\n    }\n```\n\nIn the example below, you can see the new approach that gets an access token as well.\n\nto configure this snippet with your account\n\n```\nPOST https://{yourDomain}/oauth/token\n    Content-Type: application/x-www-form-urlencoded\n    {\n      \"grant_type\": \"password\",\n      \"username\": \"{yourUsername}\",\n      \"password\": \"{yourPassword}\",\n      \"audience\": \"https://{yourDomain}/api/v2/\",\n      \"scope\": \"read:current_user\",\n      \"client_id\": \"{yourClientId}\",\n      \"client_secret\": \"{yourClientSecret}\",\n    }\n```\n\nIn order to get an Access Token that can access the Management API:\n\n*   Set the `aud` to `https://{yourDomain}/api/v2/`\n    \n*   Ask for the scope `read:current_user`\n    \n\nOnce you have the access token you can use it to call the endpoint. This part remains the same, nothing else changes in the request except for the value you use as `Bearer` token. The response remains also the same.\n\n#### Embedded Lock or auth0.js\n\nIf you embed either Lock or auth0.js v9 in your application, then you are using cross-origin authentication. This is used to authenticate users when the requests come from different domains.\n\nIf you use auth0.js to access the Management API and manage your users, then your script will have to be updated.\n\nIn the example below, you can see the old approach.\n\nto configure this snippet with your account\n\n```\n// get an ID Token\n    var webAuth = new auth0.WebAuth({\n      clientID: '{yourClientId}',\n      domain: '{yourDomain}',\n      redirectUri: 'https://{yourApp}/callback',\n      scope: 'openid',\n      responseType: 'id_token'\n    });\n    // create a new instance\n    var auth0Manage = new auth0.Management({\n      domain: '{yourDomain}',\n      token: '{yourIdToken}'\n    });\n```\n\nIn this example, you can see the new approach.\n\nto configure this snippet with your account\n\n```\n// get an Access Token\n    var webAuth = new auth0.WebAuth({\n      clientID: '{yourClientId}',\n      domain: '{yourDomain}',\n      redirectUri: 'https://{yourApp}/callback',\n      audience: 'https://{yourDomain}/api/v2/',\n      scope: 'read:current_user',\n      responseType: 'token id_token'\n    });\n    // create a new instance\n    var auth0Manage = new auth0.Management({\n      domain: '{yourDomain}',\n      token: '{yourMgmtApiAccessToken}'\n    });\n```\n\n*   Ask for both an ID token and an access token in the response\n    \n    `responseType: 'token id_token'`\n    \n*   Set the Management API as the intended audience of the token\n    \n    `audience: 'https://YOUR_DOMAIN/api/v2/'`\n    \n*   Ask for the required permission\n    \n    `scope: 'read:current_user'`\n    \n*   Authenticate with the Management API using the access token\n    \n\n### Account Linking changes\n\nThe changes in this functionality are the following:\n\n*   You can no longer use an ID Token at the `Authorization` header\n    \n*   If you use an access token at the `Authorization` header, with `update:users` as the granted permission, then you can send at the request's body either the `user_id` or the ID Token of the secondary account\n    \n*   If you use an access token at the `Authorization` header, with `update:current_user_metadata` as the granted permission, then you can only send the ID Token of the secondary account in the request's body. The following must apply:\n    \n    *   The ID token must be signed using `RS256` (you can set this value at **Dashboard > Applications > Application Settings > Advanced Settings > OAuth**)\n        \n    *   The claim `aud` of the ID token, must identify the application, and be the same value with the `azp` claim of the access token\n        \n\n## Restrictions\n\nThe access tokens used to access the Management API must only hold one value at the `aud` claim. If your token contains more than one value, then your request to the Management API will error out.\n\n## Learn more\n\n*   [Migrate to Access Tokens for Account Linking](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/link-user-accounts-with-access-tokens-migration)",
  "title": "Migrate to Management API Endpoints with Access Tokens",
  "description": "Describes the deprecation of using ID tokens as credentials for the Management API and how to migrate your configuration to use access tokens.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/resource-owner-passwordless-credentials-exchange",
  "markdown": "# Migrate Your Resource Owner Passwordless Credentials Exchange\n\nSupport for resource owner password was added to `/oauth/token`. Usage of the `/oauth/ro` endpoint was deprecated on 08 July 2017. The `/oauth/ro` endpoint was previously used to exchange a one-time password (OTP) received by the end-user email or SMS for an ID token and an access token. Auth0 has implemented a new API that replaces `/oauth/ro` for this use case and we recommend that you migrate to using the new endpoint.\n\n## Features affected\n\nThis change affects you if you use the resource owner passwordless credentials exchange and call `/oauth/ro` directly without the use of any Auth0 libraries or SDKs.\n\n## Actions\n\n### Request changes\n\nPreviously, the payload of a request to `/oauth/ro` looked similar to this:\n\n```\n{\n      \"grant_type\": \"password\",\n      \"client_id\": \"123\",\n      \"username\": \"alice\",\n      \"password\": \"A3ddj3w\", \n      \"connection\": \"my-database-connection\",\n      \"scope\": \"openid email favorite_color offline_access\",\n      \"device\": \"my-device-name\"\n    }\n```\n\nThese are the changes for the new implementation:\n\n*   The endpoint to execute token exchanges is now `/oauth/token`.\n    \n*   Auth0's own grant type is used to authenticate users from a specific connection (or realm).\n    \n*   Auth0 supports the standard OIDC scopes, along with the scopes which you have defined in your custom API.\n    \n*   A scope that does not fit in one of these categories, such as the above `favorite_color`, is no longer a valid scope.\n    \n*   The `device` parameter is removed.\n    \n*   The `audience` parameter is optional.\n    \n\nHere is an example of the payload of a request to `/oauth/token`:\n\nto configure this snippet with your account\n\n```\n{\n      \"grant_type\" : \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n      \"client_id\": \"{yourClientId}\",\n      \"client_secret\": \"{yourClientSecret}\", // only for web apps, native apps don’t have a client secret\n      \"username\": \"{userEmailAddress}\", // or \"{userPhoneNumber}\"\n      \"otp\": \"CODE\",\n      \"realm\": \"email\", // or \"sms\" \n      \"audience\" : \"{yourApiIdentifier}\", // in case you need an access token for a specific API\n      \"scopes\": \"openid profile email\" // whatever scopes you need\n    }\n```\n\n*   The grant type is specified here as `http://auth0.com/oauth/grant-type/passwordless/otp`.\n    \n*   The parameters `client_id` and `username` are unchanged.\n    \n*   The `client_secret` needs to be specified for confidential clients (e.g. regular web apps).\n    \n*   The one-time password needs to be sent in the `otp` parameter instead of the `password` parameter.\n    \n*   The `realm` is used to identify the connection, and replaces the `connection` parameter from previous calls.\n    \n*   The `scope` parameter is mostly the same, but does not accept non-OIDC values.\n    \n*   The `audience` parameter can be added, indicating the API audience the token will be intended for.\n    \n\n### Response changes\n\nResponses from `/oauth/ro` were similar in format to the following:\n\n```\n{\n      \"access_token\": \"SlAV32hkKG\",\n      \"token_type\": \"Bearer\",\n      \"refresh_token\": \"8xLOxBtZp8\",\n      \"expires_in\": 3600,\n      \"id_token\": \"eyJ...\"\n    }\n```\n\n*   The returned access token is valid for calling the `/userinfo` endpoint (provided that the API specified by the `audience` param uses RS256 as signing algorithm) and optionally the custom API if one was specified.\n    \n*   The ID token will be forcibly signed using RS256 if requested by a public client.\n    \n*   A refresh token will be returned only if the `offline_access` scope was granted and the API has **Allow offline access** set.\n    \n\nHere is an example of the OIDC conformant response from `/oauth/token`:\n\n```\n{\n      \"access_token\": \"eyJ...\",\n      \"token_type\": \"Bearer\",\n      \"refresh_token\": \"8xLOxBtZp8\",\n      \"expires_in\": 3600,\n      \"id_token\": \"eyJ...\"\n    }\n```\n\n### Code changes when using the SDKs\n\nIf your application uses the Auth0 native libraries for Android or iOS, be sure that the version of the library you are including is at least the minimum listed below (or higher). Also, be sure to set the `OIDC Conformant` flag to `true` when configuring the libraries.\n\n| Library | Minimum Version |\n| --- | --- |\n| Android SDK | 1.2 |\n| Lock Android | 2.17 |\n| Swift SDK | 1.20.0 |\n| Lock iOS | 2.14.0 |\n\n### Verify migration\n\n1.  To verify whether you are using the deprecated endpoint, check the [tenant logs](https://manage.auth0.com/#/logs), filter by **Deprecation Notice** and then check for logs that say `**oauth/ro**` **passwordless: This feature is being deprecated**. You can also perform this search directly with the following query: `type:depnote AND description:*passwordless*`.\n    \n2.  Once you have migrated your codebase and are sure that your apps are not calling the endpoint, go to the [Dashboard](https://manage.auth0.com/#/tenant/advanced) under **Tenant Settings > Advanced**.\n    \n3.  Scroll down to **Migrations** and toggle off **Legacy** `**/oauth/ro**` **Endpoint**. Turning off this switch disables the deprecated endpoint for your tenant, preventing it from being used.\n    \n\n![Dashboard - Tenant Settings - Advanced - /oauth/ro Endpoint Migration Toggle Screen](https://images.ctfassets.net/cdy7uua7fh8z/7Ko11jQf8BGwPZ9xLcsAVz/49743a0a67850718c668203e4a8f4a55/dashboard-tenant-edit_view-advanced_migrations_legacy.png)\n\nIf turning this switch off results in failed logins, this is a sign that you have yet to completely remove all instances of legacy code from your applications.\n\nOnce migrations have been successfully performed in production environments, the switch can be toggled off and left off, to ensure that the deprecated features can no longer be used.\n\n## Learn more\n\n*   [Migrate Your Resource Owner Password Flow](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migration-oauthro-oauthtoken)",
  "title": "Migrate Your Resource Owner Passwordless Credentials Exchange",
  "description": "Describes how to migrate your Passwordless API calls and responses from /oauth/ro to /oauth/token.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migration-oauthro-oauthtoken",
  "markdown": "# Migrate Your Resource Owner Password Flow\n\nSupport for resource owner password was added to `/oauth/token`. Usage of the `/oauth/ro` endpoint was deprecated on 08 July 2017. The `/oauth/ro` endpoint was previously used to exchange a one-time password (OTP) received by the end-user email or SMS for an ID token and an access token. Auth0 has implemented a new API that replaces `/oauth/ro` for this use case and we recommend that you migrate to using the new endpoint.\n\n## Features affected\n\nThis change affects you if you use the [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow) and call `/oauth/ro` directly without the use of any Auth0 libraries or SDKs. Auth0 libraries such as Lock or Auth0.js have been updated to stop using `/oauth/ro` internally. If you use the lock-passwordless library, you can now use Passwordless Mode in Lock instead.\n\n## Actions\n\n### Change requests\n\nPreviously, the payload of a request to `/oauth/ro` looked similar to this:\n\n```\n{\n      \"grant_type\": \"password\",\n      \"client_id\": \"123\",\n      \"username\": \"alice\",\n      \"password\": \"A3ddj3w\", \n      \"connection\": \"my-database-connection\",\n      \"scope\": \"openid email favorite_color offline_access\",\n      \"device\": \"my-device-name\"\n    }\n```\n\nThe new implementation contains the following changes:\n\n*   The endpoint to execute token exchanges is now `/oauth/token`.\n    \n*   Auth0's own grant type is used to authenticate users from a specific connection (or realm).\n    \n*   Auth0 supports the standard OIDC scopes, along with the scopes which you have defined in your custom API.\n    \n*   A scope that doesn't fit in one of these categories, such as the above `favorite_color`, is no longer a valid scope.\n    \n*   The `device` parameter is removed.\n    \n*   The `audience` parameter is optional.\n    \n\nHere is an example of the payload of a request to `/oauth/token`:\n\n```\n{\n      \"grant_type\": \"http://auth0.com/oauth/grant-type/password-realm\",\n      \"client_id\": \"123\",\n      \"username\": \"alice\",\n      \"password\": \"A3ddj3w\",\n      \"realm\": \"my-database-connection\",\n      \"scope\": \"openid email offline_access\",\n      \"audience\": \"https://api.example.com\"\n    }\n```\n\n*   The grant type is specified here as `password-realm`, rather than the standard `password`.\n    \n*   The parameters `client_id`, `username`, and `password` are unchanged.\n    \n*   The `realm` is included because we are using Password Realm grant type, and replaces the `connection` parameter from previous calls.\n    \n*   The `scope` parameter is mostly the same, but does not accept non-OIDC values.\n    \n*   The `audience` parameter can be added, indicating the API audience the token will be intended for.\n    \n\n### Response changes\n\nResponses from `/oauth/ro` were similar in format to the following:\n\n```\n{\n      \"access_token\": \"SlAV32hkKG\",\n      \"token_type\": \"Bearer\",\n      \"refresh_token\": \"8xLOxBtZp8\",\n      \"expires_in\": 3600,\n      \"id_token\": \"eyJ...\"\n    }\n```\n\n*   The returned access token is valid for calling the `/userinfo` endpoint (provided that the API specified by the `audience` param uses RS256 as signing algorithm) and optionally the custom API if one was specified.\n    \n*   The ID token will be forcibly signed using RS256 if requested by a public client.\n    \n*   A Refresh Token will be returned only if the `offline_access` scope was granted and the API has **Allow offline access** set.\n    \n\nHere is an example of the OIDC conformant response from `/oauth/token`:\n\n```\n{\n      \"access_token\": \"eyJ...\",\n      \"token_type\": \"Bearer\",\n      \"refresh_token\": \"8xLOxBtZp8\",\n      \"expires_in\": 3600,\n      \"id_token\": \"eyJ...\"\n    }\n```\n\n### Verify migration\n\n1.  Once you have migrated your codebase and are sure that your apps are not calling the endpoint, go to the [Dashboard > Tenant Settings > Advanced](https://manage.auth0.com/#/tenant/advanced).\n    \n2.  Scroll down to **Migrations** and toggle off **Legacy** `**/oauth/ro**` **Endpoint**. Turning off this switch disables the deprecated endpoint for your tenant, preventing it from being used.\n    \n\n![Dashboard - Tenant Settings - Advanced - /oauth/ro Endpoint Migration Toggle Screen](https://images.ctfassets.net/cdy7uua7fh8z/7Ko11jQf8BGwPZ9xLcsAVz/49743a0a67850718c668203e4a8f4a55/dashboard-tenant-edit_view-advanced_migrations_legacy.png)\n\nIf turning this switch off results in failed logins, this is a sign that you have yet to completely remove all instances of legacy code from your applications.\n\nOnce migrations have been successfully performed in production environments, the switch can be toggled off and left off, to ensure that the deprecated features can no longer be used.",
  "title": "Migrate Your Resource Owner Password Flow",
  "description": "Describes how to migrate your password API calls and responses from /oauth/ro to /oauth/token.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa",
  "markdown": "# Customize Multi-Factor Authentication Pages\n\nYou can customize the MFA pages that appear to your users by adjusting the Universal Login branding options in the [Universal Login Settings](https://manage.auth0.com/#/login_settings) section of the Auth0 Dashboard.\n\nIf you are using the Universal Login experience, you can customize the page using its flow customization options.\n\nYou can also customize the full HTML content to reflect your organization's particular user experience requirements. To learn more, read [MFA Widget Theme Options](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-widget-theme-options).\n\nWith the Universal Login Experience, MFA is presented even more simply to the user. Once they have entered their credentials to log in, they are presented with the MFA screen. If they have no MFA factor enrolled, they will be asked to enroll, and if they do, they will be asked to present their MFA credential.\n\n## Use the MFA API\n\nAuth0 provides an [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) for the following scenarios:\n\n*   [Authenticate users with the Resource Owner Password Grant](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n    \n*   Build an interface to [let users manage their own authentication factors](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api).\n    \n*   Invite users to enroll in MFA using [enrollment tickets](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets).\n    \n\nTo use the MFA API, you must enable the MFA grant type for your application. To enable the MFA grant in the Auth0 Dashboard:\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select your application.\n    \n2.  At the bottom of the **Settings** tab, click **Advanced Settings**.\n    \n3.  Click the **Grant Types** tab and select **MFA**.\n    \n    ![Dashboard Applications Applications Advanced Settings Grant Types tab](https://images.ctfassets.net/cdy7uua7fh8z/3knG7flXhvUi0b2yhH0JEp/bd76163ad3d571c7216f22128f63527c/Screen_Shot_2021-05-18_at_2.24.26_PM.png)\n    \n    To learn more, read [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa).\n    \n4.  Click **Save Changes**.\n    \n\n### Limitations\n\nThe MFA API is designed to work with SMS, push notifications within the Guardian application, email, and OTP factors. It does not support enrolling with Duo.\n\n## Customize MFA policy with Actions\n\nYou can use Actions to customize the MFA policy for your tenant, including requiring MFA for users of specific applications, users with specific user metadata or IP ranges, and more.\n\nIf you're unfamiliar with creating Actions, read [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\nWhen writing Actions, you can use the `provider` setting to specify whether to force MFA, and which factor you use. The behavior is different depending on whether you use the Classic or the Universal Login experience:\n\n| Provider | Classic Experience | New Experience |\n| --- | --- | --- |\n| any | Push, SMS, or OTP | Push, SMS, Voice, OTP, Email, or WebAuthN security key (when enabled) |\n| guardian | Push, SMS, or OTP | Push, SMS, OTP, or Email |\n| google-authenticator | Google Authenticator | Push, SMS, OTP, or Email |\n| duo | Duo | Duo |\n\nIf you are using Universal Login you can get the behavior of the Classic Login experience if you enable customization of the MFA login page.\n\nSetting the `provider` to a specific option manually overrides the enabled/disabled toggles in the Dashboard. You can use the following Action to prompt the user to enroll in Duo even if other factors are enabled in the Dashboard:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n    // Forcing the provider to Duo programmatically\n    api.multifactor.enable('duo')\n}\n```\n\n## Common use case examples\n\nHere are some common contextual MFA scenarios that can be handled by Actions.\n\n### Require MFA for specific applications\n\nYou can customize MFA to only trigger when users are logging in to to specific applications.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\tconst CLIENTS_WITH_MFA = [\n\t\t'{yourClientId1}', \n\t\t'{yourClientId2}',\n\t\t'{yourClientId3}'\n\t];\n\n\tif (CLIENTS_WITH_MFA.includes(event.client.client_id)) {\n\t\tapi.multifactor.enable('duo', { allowRememberBrowser: false })\n\t}\n}\n```\n\n### Require MFA for specific users\n\nYou can customize MFA to only trigger for users who are marked to use MFA.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.user.user_metadata && event.user.user_metadata.use_mfa) {\n    api.multifactor.enable('duo', { allowRememberBrowser: false });\n  }\n}\n```\n\n### Change frequency of MFA prompts\n\nIn some scenarios, you may not want to prompt the user for MFA each time they log in from the same browser. You can alter that behavior by using the `allowRememberBrowser` property:\n\n```\nexports.onExecutePostLogin = async (event, api) => {  \n  api.multifactor.enable('any', { allowRememberBrowser: false });\n}\n```\n\nDepending on the property value the behavior will be as follows:\n\n| Value | Description |\n| --- | --- |\n| `true` | When provider is set to `google-authenticator` or `duo`, the user is prompted for MFA once every 30 days. When provider is set to `guardian`, the MFA prompt displays the enrollment checkbox for users to choose whether or not to enroll. Defaults to `false`. To learn more, read [Customize Multi-Factor Authentication Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa) |\n| `false` | The user is prompted for MFA each time they authenticate. |\n\nThe time values are for active users. If a user is inactive for a period of seven days or more, their cookie will expire and they will be prompted for MFA on their next login attempt (regardless if `allowRememberBrowser` is set to `true` and it has not been 30 days since their last MFA prompt).\n\nWhen you allow the user to skip MFA, a cookie is stored in the user's browser. If the user has the cookie set but you still want to require MFA, you have two options:\n\n*   Set `allowRememberBrowser` to `false`\n    \n*   Set `acr_values` to `http://schemas.openid.net/pape/policies/2007/06/multi-factor` when calling the `/authorize` endpoint.\n    \n\nIn situations where a user loses a trusted device, you can prompt the specific user for MFA during their next login by calling the Auth0 Management API [Invalidate Remember Browser](https://auth0.com/docs/api/management/v2#!/Users/post_invalidate_remember_browser) endpoint.\n\n### Require MFA for users outside of the network\n\nAssuming that access to the specified network of internal IP addresses is well controlled, you can also have Auth0 request MFA only from users whose requests originate from outside the corporate network:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const ipaddr = require('ipaddr.js@1.9.0');\n  const corp_network = '192.168.1.134/26';\n  const current_ip = ipaddr.parse(event.request.ip);\n\n  if (!current_ip.match(ipaddr.parseCIDR(corp_network))) {\n    api.multifactor.enable('any', {allowRememberBrowser: false});\n  }\n}\n```\n\n### Bypass MFA for refresh token requests\n\nIf your users report frequent log-outs, you may need to bypass refresh token requests while using MFA. You can alter the default behavior with a filter Action on the `event.transaction.protocol` object property.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.transaction.protocol !== 'oauth2-refresh-token') {\n    // MFA-related commands here\n    api.multifactor.enable('any');\n  }\n};\n```\n\nTo learn more about the Action `event` object, read [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object).\n\n## Learn more\n\n*   [Customize MFA for Classic Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login)\n*   [Authenticate Using the Resource Owner Password Flow with MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa)\n*   [Auth0 MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api)\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n*   [MFA Widget Theme Options](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-widget-theme-options)\n*   [MFA Theme Language Dictionary](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-theme-language-dictionary)",
  "title": "Customize Multi-Factor Authentication Pages",
  "description": "Learn how to customize multi-factor authentication (MFA) pages that appear to users with Universal Login branding options.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/link-user-accounts-with-access-tokens-migration",
  "markdown": "# Migrate to Access Tokens for Account Linking\n\nPreviously you could use ID tokens to link and unlink user accounts for some use cases. Auth0 is deprecating this functionality. You will now need to use access tokens in all cases.\n\n## Features affected\n\nThe changes in account linking are:\n\n*   You can no longer use an ID token at the `Authorization` header, an access token must be used instead.\n    \n*   If you use an access token at the `Authorization` header with `update:users` as the granted permission, then you can send as the request's body either the `user_id` or the ID Token of the secondary account.\n    \n*   If you use an access token at the `Authorization` header with `update:current_user_metadata` as the granted permission, then you can only send the ID token of the secondary account in the request's body.\n    \n*   If you send the ID token of the secondary account in the request's body (the use cases described in the previous two bullets) then the following must apply:\n    \n    *   The ID token must be signed using `RS256` (you can set this value at **Dashboard > Clients > Client Settings > Advanced Settings > OAuth**.\n        \n    *   The claim `aud` of the ID Token, must identify the client and be the same value with the `azp` claim of the access token.\n        \n*   For unlinking accounts, you can no longer use an ID token at the `Authorization` header. You must use an access token instead.\n    \n\nThere are several ways you can link and unlink accounts. In the following list you can see the use cases and how the changes affect them.\n\n| Use Case | Status |\n| --- | --- |\n| Use the Management API `POST /api/v2/users/{id}/identities` endpoint and send the primary account's ID token in the `Authorization` header. | Affected |\n| Use the Management API `POST /api/v2/users/{id}/identities` endpoint and send an access token (with scope `update:users`) in the `authorization` header, and the secondary account's `user_id` in the payload. | Not affected |\n| Use the Management API `POST /api/v2/users/{id}/identities` endpoint and send an access token (with scope `update:current_user_identities`) in the `Authorization` header, and the secondary account's `user_id` in the payload. | Affected |\n| Use the Management API `POST /api/v2/users/{id}/identities` endpoint and send an access token in the `Authorization` header and the secondary account's ID token in the payload. | New use case |\n| Use the auth0.js library and the primary account's ID token to instantiate `auth0.Management`. | Affected |\n| Use the auth0.js library and an access token (with scope `update:users`) to instantiate `auth0.Management`. | Not affected |\n| Use the auth0.js library and an access token (with scope `update:current_user_identities`) to instantiate `auth0.Management`. | Affected |\n| Use the Management API `DELETE /api/v2/users/{id}/identities/{provider}/{user_id}` endpoint and send the primary account's ID token in the `Authorization` header. | Affected |\n| Use the Management API `DELETE /api/v2/users/{id}/identities/{provider}/{user_id}` endpoint and send an access token in the `Authorization` header. | Not affected |\n\n## Actions\n\nReview all your calls to the account linking [Identities endpoint](https://auth0.com/docs/api/management/v2/#!/Users/post_identities) and update those that make use of the vulnerable flow described above. You can update your calls to either of the following:\n\n*   **Client-side / user-initiated linking scenarios:** For client-side linking scenarios, make the call to the Identities endpoint using an access token with the `update:current_user_identities` scope, and provide the ID token of the secondary account in the payload (`link_with`). This ID token must be obtained through an OAuth/OIDC-conformant flow.\n    \n*   **Server-side linking scenarios**: For server-side linking scenarios, make the call to Identities endpoint using an access token with the `update:users` scope and provide the `user_id` of the secondary account in the payload.\n    \n\nSee [Link User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts) for details.\n\n### Link user accounts\n\nTo link user accounts you can either call the [Link a User Account endpoint](https://auth0.com/docs//api/management/v2#!/Users/post_identities) of the Management API or use the [Auth0.js library](https://auth0.com/docs/libraries/auth0js).\n\n#### Link current user accounts with the Management API\n\nA common use case is to allow the logged in user to link their accounts using your app.\n\nPrior to the deprecation you could use the primary user's ID token or access token (which contained the `update:current_user_identities` scope) to authenticate with the Management API and use the [Link a User Account endpoint](https://auth0.com/docs/api/management/v2#!/Users/post_identities).\n\nNow you must get an access token (containing the `update:current_user_identities` scope) and use that to authenticate with the API and use the Link a User Account endpoint. The payload must be the ID token of the secondary user.\n\n1.  Get an access token with the `update:current_user_identities` scope as shown in the following example. The example uses the [implicit flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post), however, you can [get access tokens](https://auth0.com/docs/secure/tokens/access-tokens/get-access-tokens) for any application type.\n    \n2.  Using the previous method using an ID token, your code would look similar to this:\n    \n    to configure this snippet with your account\n    \n    ```\n    https://{yourDomain}/authorize?\n          scope=openid\n          &response_type=id_token\n          &client_id={yourClientId}\n          &redirect_uri=https://{yourApp}/callback\n          &nonce=NONCE\n          &state=OPAQUE_VALUE\n    ```\n    \n    Using the new method using an access token, your code will look similar to this:\n    \n    to configure this snippet with your account\n    \n    ```\n    https://{yourDomain}/authorize?\n          audience=https://{yourDomain}/api/v2/\n          &scope=update:current_user_identities\n          &response_type=token%20id_token\n          &client_id={yourClientId}\n          &redirect_uri=https://{yourApp}/callback\n          &nonce={nonce}\n          &state={opaqueValue}\n    ```\n    \n3.  To get an access token that can access the Management API:\n    \n    1.  Set the `audience` to `https://{yourDomain}/api/v2/`.\n        \n    2.  Ask for the `scope` `${scope}`.\n        \n    3.  Set the `response_type` to `id_token token` so Auth0 will send both an ID token and an access token. If we decode the access token and review its contents we can see the following:\n        \n        ```\n        {\n              \"iss\": \"https://{yourDomain}/\",\n              \"sub\": \"auth0|5a620d29a840170a9ef43672\",\n              \"aud\": \"https://{yourDomain}/api/v2/\",\n              \"iat\": 1521031317,\n              \"exp\": 1521038517,\n              \"azp\": \"{yourClientId}\",\n              \"scope\": \"${scope}\"\n            }\n        ```\n        \n        Notice that the `aud` is set to your tenant's API URI, the `scope` to `${scope}`, and the `sub` to the user ID of the logged-in user.\n4.  The following must apply:\n    \n    1.  The secondary account's ID Token must be signed with `RS256.`\n        \n    2.  The `aud` claim in the secondary account's ID token must identify the client, and hold the same value with the `azp` claim of the access token used to make the request.\n        \n5.  Once you have the access token, you can use it to link user accounts. This part remains the same, nothing else changes in the request except for the value you use as `Bearer` token. The response also remains the same.\n    \n    ```\n    {\n          \"method\": \"POST\",\n          \"url\": \"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\",\n          \"httpVersion\": \"HTTP/1.1\",\n          \"headers\": [{\n          \"name\": \"Authorization\",\n          \"value\": \"Bearer ACCESS_TOKEN\"\n          },\n          {\n          \"name\": \"content-type\",\n          \"value\": \"application/json\"\n          }],\n          \"postData\" : {\n          \"mimeType\": \"application/json\",\n          \"text\": \"{\\\"link_with\\\":\\\"SECONDARY_ACCOUNT_ID_TOKEN\\\"}\"\n          }\n        }\n    ```\n    \n\n#### Link current user accounts with auth0.js\n\nIf you use [auth0.js library](https://auth0.com/docs/libraries/auth0js) to access the Management API and link accounts, then you probably use the ID token of the user's primary identity to instantiate `auth0.Management` and use it to link accounts.\n\n1.  Get an access token with the `update:current_user_identities` scope, then use this token to instantiate `auth0.Management`. The final call to `linkUser` remains the same.\n    \n2.  Using the previous method using an ID token, your code would look similar to this:\n    \n    to configure this snippet with your account\n    \n    ```\n    // get an ID Token\n        var webAuth = new auth0.WebAuth({\n          clientID: '{yourClientId}',\n          domain: '{yourDomain}',\n          redirectUri: 'https://{yourApp}/callback',\n          scope: 'openid',\n          responseType: 'id_token'\n        });\n        // create a new instance\n        var auth0Manage = new auth0.Management({\n          domain: '{yourDomain}',\n          token: '{yourIdToken}'\n        });\n    ```\n    \n    Using the new method using an access token, your code will look similar to this:\n    \n    to configure this snippet with your account\n    \n    ```\n    // get an Access Token\n        var webAuth = new auth0.WebAuth({\n          clientID: '{yourClientId}',\n          domain: '{yourDomain}',\n          redirectUri: 'https://{yourApp}/callback',\n          audience: 'https://{yourDomain}/api/v2/',\n          scope: 'update:current_user_identities',\n          responseType: 'token id_token'\n        });\n        // create a new instance\n        var auth0Manage = new auth0.Management({\n          domain: '{yourDomain}',\n          token: '{yourMgmtApiAccessToken}'\n        });\n    ```\n    \n    1.  Asks for both an Id token and an access token in response (`` responseType: `token id_token` ``).\n        \n    2.  Sets the Management API as the intended audience of the token (`` audience: `https://YOUR_DOMAIN/api/v2/` ``).\n        \n    3.  Asks for the required permission (`` scope: `update:current_user_identities` ``).\n        \n    4.  Authenticates with the Management API using the access token.\n        \n\n#### Link any user account with the Management API\n\nIf you get an access token for account linking that contains the `update:users` scope, and send the secondary account's `user_id` and `provider` in the request, then you don't have to make any changes.\n\nHowever, this new method introduces an alternative to this. You still use an access token that contains the `update:users` scope to authenticate with the API, but in the request's payload you can send the secondary's account ID token (instead of `user_id` and `provider`).\n\n*   [cURL](#a111f5559c7e4a0287f7915d34dfd481_shell)\n*   [C#](#a111f5559c7e4a0287f7915d34dfd481_csharp)\n*   [Go](#a111f5559c7e4a0287f7915d34dfd481_go)\n*   [Java](#a111f5559c7e4a0287f7915d34dfd481_java)\n*   [Node.JS](#a111f5559c7e4a0287f7915d34dfd481_node)\n*   [Obj-C](#a111f5559c7e4a0287f7915d34dfd481_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities' \\\n  --header 'authorization: Bearer ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"link_with\":\"SECONDARY_ACCOUNT_ID_TOKEN\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"link_with\\\":\\\"SECONDARY_ACCOUNT_ID_TOKEN\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\"\n\n\tpayload := strings.NewReader(\"{\\\"link_with\\\":\\\"SECONDARY_ACCOUNT_ID_TOKEN\\\"}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\")\n  .header(\"authorization\", \"Bearer ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"link_with\\\":\\\"SECONDARY_ACCOUNT_ID_TOKEN\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities',\n  headers: {authorization: 'Bearer ACCESS_TOKEN', 'content-type': 'application/json'},\n  data: {link_with: 'SECONDARY_ACCOUNT_ID_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"link_with\": @\"SECONDARY_ACCOUNT_ID_TOKEN\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"link_with\\\":\\\"SECONDARY_ACCOUNT_ID_TOKEN\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"link_with\\\":\\\"SECONDARY_ACCOUNT_ID_TOKEN\\\"}\"\n\nheaders = {\n    'authorization': \"Bearer ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"link_with\\\":\\\"SECONDARY_ACCOUNT_ID_TOKEN\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"link_with\": \"SECONDARY_ACCOUNT_ID_TOKEN\"] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe following must apply:\n\n*   The secondary account's ID token must be signed with `RS256`.\n    \n*   The `aud` claim in the secondary account's ID token must identify the client, and hold the same value with the `azp` claim of the access token used to make the request.\n    \n\n### Unlink user accounts\n\nIf you use ID tokens to unlink accounts then you must update your code to use access tokens.\n\n1.  First, you must get an access token with the `update:current_user_identities` scope.\n    \n2.  Using the previous method using an ID token, your code would look similar to this:\n    \n    to configure this snippet with your account\n    \n    ```\n    https://{yourDomain}/authorize?\n          scope=openid\n          &response_type=id_token\n          &client_id={yourClientId}\n          &redirect_uri=https://{yourApp}/callback\n          &nonce={nonce}\n          &state={opaqueValue}\n    ```\n    \n    Using the new method using an access token, your code will look similar to this:\n    \n    to configure this snippet with your account\n    \n    ```\n    https://{yourDomain}/authorize?\n          audience=https://{yourDomain}/api/v2/\n          &scope=update:current_user_identities\n          &response_type=token%20id_token\n          &client_id={yourClientId}\n          &redirect_uri=https://{yourApp}/callback\n          &nonce={nonce}\n          &state={opaqueValue}\n    ```\n    \n3.  To get an access token that can access the Management API:\n    \n    1.  Set the `audience` to `https://{yourDomain}/api/v2/`.\n        \n    2.  Ask for the `scope` `${scope}`.\n        \n    3.  Set the `response_type` to `id_token token` so Auth0 will send both an ID token and an access token. If we decode the access token and review its contents we can see the following:\n        \n        to configure this snippet with your account\n        \n        ```\n        {\n              \"iss\": \"https://{yourDomain}/\",\n              \"sub\": \"auth0|5a620d29a840170a9ef43672\",\n              \"aud\": \"https://{yourDomain}/api/v2/\",\n              \"iat\": 1521031317,\n              \"exp\": 1521038517,\n              \"azp\": \"{yourClientId}\",\n              \"scope\": \"update:current_user_identities\"\n            }\n        ```\n        \n        Notice that the `aud` is set to your tenant's API URI, the `scope` to `update:current_user_identities`, and the `sub` to the user ID of the logged in user.\n4.  Once you have the access token, you can call the [Unlink a user identity endpoint](https://auth0.com/docs/api/management/v2#!/Users/delete_user_identity_by_user_id) of the Management API, using it in the `Authorization` header.\n    \n5.  Using the previous method, your call would look similar to this:\n    \n    ```\n    DELETE https://YOUR_DOMAIN/api/v2/users/{primaryAccountUserId}/identities/{secondaryAccountProvider}/{secondaryAccountUserId}\n        Authorization: 'Bearer {yourIdTokenOrMgmtApiAccessToken}'\n    ```\n    \n    Using the new method, you call will look similar to this:\n    \n    ```\n    DELETE https://{yourDomain}/api/v2/users/{primaryAccountUserId}/identities/{secondaryAccountProvider}/{secondaryAccountUserId}\n        Authorization: 'Bearer {yourMgmtApiAccessToken}'\n    ```\n    \n\n## Security considerations\n\nWe have identified a weakness in a particular account linking flow that could allow it to be misused in specific circumstances. We have found no evidence that this has been used maliciously but have decided to deprecate the flow to prevent that ever happening.\n\nTherefore, Auth0 requires customers using the affected account linking flow to migrate to a more secure implementation before 19 October 2018. Migration paths are provided in this guide, which should not result in any lost functionality.\n\nOn or after 19 October 2018 the affected account linking flow will be disabled and you will experience run-time errors.\n\nYou are impacted if you call the [Post Identities endpoint](https://auth0.com/docs/api/management/v2#!/Users/post_identities) using a token (ID or access token) with the scope `update:current_user_identities` in the Authorization header and include the secondary account's `user_id` in the payload. No other use cases are impacted.\n\n## Learn more\n\n*   [Migrate to Management API Endpoints with Access Tokens](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-to-calling-api-with-access-tokens)",
  "title": "Migrate to Access Tokens for Account Linking",
  "description": "Describes how to migrate from using ID tokens to access tokens when linking user accounts. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/yahoo-api-changes",
  "markdown": "# Yahoo API Changes\n\nYahoo changed the API that applications need to use to retrieve the User Profile from their [Social Directory API](https://developer.yahoo.com/oauth/social-directory-eol/) to a Yahoo `/userinfo` endpoint. This change implies that the structure of the user profile for Yahoo users in Auth0 will change.\n\nAuth0 previously loaded all the profile data that Yahoo returned, and added these additional fields that were mapped from the Yahoo profile.\n\nYahoo stopped returning `url`, `profileUrl`, `isConnected`, and a set of other fields listed in [Yahoo’s documentation](https://developer.yahoo.com/oauth/social-directory-eol/) (see \"List Of Attributes Deprecated in Social Directory Profile Api\"). Those other fields will also not be part of the profile.\n\nThe Yahoo `/userinfo` endpoint returns different fields depending on the API permissions that you configure in the [Yahoo Application](https://developer.yahoo.com/apps/) definition. Yahoo lets you grant one of four permissions in the **Profile (Social Directory)** permissions section:\n\n*   Read Public Basic\n    \n*   Read Public Extended\n    \n*   Read Write Public\n    \n*   Read Write Public and Private\n    \n\n## Actions\n\nWhen configuring the Yahoo Connection in your Auth0 Dashboard, select the attribute that corresponds to the permissions you granted in your Yahoo setup. If you choose an attribute that does not match what you specified on Yahoo, the login transaction will fail.\n\nIf you do not select any permissions in the Auth0 connection settings, Auth0 will, by default, ask for the `openid` scope which returns the profile fields that correspond to the API permission you specified in the Yahoo Application. For example, if your Yahoo application is configured with the **Read Public Extended** permission, Yahoo returns the following fields:\n\n*   `sub, name`\n    \n*   `given_name`\n    \n*   `family_name`\n    \n*   `locale`\n    \n*   `email`\n    \n*   `email_verified`\n    \n*   `birthdate`\n    \n*   `profile_images`\n    \n*   `picture`\n    \n*   `preferred_username`\n    \n*   `phone_number`\n    \n*   `nickname`\n    \n\nIf you are using the Yahoo connection to authenticate users and get their basic information, your application will continue to work without changes.\n\nIf your application is accessing fields in the user profile that are no longer available, then you will need to enable the correct **Connection Attribute** in the Auth0 Dashboard and adjust your application code to use the proper field names.",
  "title": "Yahoo API Changes",
  "description": "Describes the Yahoo API changes that affect the structure of the user profile.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/instagram-connection-deprecation",
  "markdown": "# Instagram Connection Deprecation\n\nAs of March 31, 2020, Facebook turned off the Instagram legacy APIs in favor of a new set of APIs:\n\n*   [Instagram Graph API](https://developers.facebook.com/docs/instagram-api) designed for Instagram Professional Accounts, not for end-user authentication.\n    \n*   [Instagram Basic Display API](https://developers.facebook.com/docs/instagram-basic-display-api), an OAuth2 API, and enables you to grant access to your basic Instagram account data to a third-party app.\n    \n\nFacebook requires applications to implement Facebook Login for authentication. Facebook will not approve applications that use the Instagram Basic Display API for authentication.\n\n## Actions\n\nTo allow your existing users continue to access your application, you will need to ask users that are authenticating using Instagram to authenticate in a different way, and use Account Linking to link the new identity with the old one.\n\nAn example flow would be:\n\n*   The user authenticates with Instagram.\n    \n*   The application tells the user that they won't be able to authenticate with Instagram anymore, and that they should do it in a different way.\n    \n*   The application lists the options the user has for authentication, for example:\n    \n    *   Facebook\n        \n    *   Username and Password\n        \n*   After the user authenticates in a different way, you link the accounts using Account Linking.\n    \n\nWhile we could replace our current implementation and use the [Instagram Basic Display OAuth flow](https://developers.facebook.com/docs/instagram-basic-display-api/guides/getting-access-tokens-and-permissions), this would not be accepted by Facebook's policies. You would need to create an Instagram application in Facebook and, in that app, there's a notification saying:\n\nThis means that even if Auth0 implemented this flow, your Instagram application would not be approved by Facebook.\n\nIf you need to access Instagram data, you will need to authenticate your user in another way (for example, using Facebook Login or username/password), and implement the Instagram OAuth flow in your application.",
  "title": "Instagram Connection Deprecation",
  "description": "Describes changes occuring due to Instagram deprecating their Authentication API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/google-firebase-migration",
  "markdown": "# Migrate from Google to Firebase Cloud Messaging\n\nAs of April 11, 2019, [Google deprecated](https://firebase.googleblog.com/2018/04/time-to-upgrade-from-gcm-to-fcm.html) and replaced Google Cloud Messaging (GCM) with Firebase Cloud Messaging (FCM).\n\n## Features affected\n\nAuth0’s Guardian SDKs for iOS and Android help you to create custom mobile apps with Guardian functionality, providing secure access to multi-factor authentication (MFA) with push notifications.\n\nAuth0's Guardian Android SDK library was built to send push notifications using GCM. Note that existing applications should [keep working as-is](https://aws.amazon.com/blogs/messaging-and-targeting/the-end-of-google-cloud-messaging-and-what-it-means-for-your-apps/).\n\n## Actions\n\nSee [Google’s documentation](https://developers.google.com/cloud-messaging/android/android-migrate-fcm) to learn how to migrate from GCM to FCM.\n\nThe main difference between how you send notifications to GCM and FCM is in the payload received in the notification. While it was possible for existing customers using the Android SDK to adapt the payload received before calling the SDK method, we have upgraded the library so it accepts the new payload, making it simpler to adopt FCM. More details [here](https://github.com/auth0/Guardian.Android/pull/84).\n\nThe Guardian Android SDK 0.4.0 version is already available in Maven Central and includes this change. The sample application was also upgraded, so it can be tested by providing the `google-services.json` file and a `guardian-url`.",
  "title": "Migrate from Google to Firebase Cloud Messaging",
  "description": "Describes how to migrate your applications based on the Guardian Android SDK to Firebase Cloud Messaging",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/facebook-social-context-field-deprecation",
  "markdown": "# Facebook Social Context Field Deprecation\n\nAs of **July 30, 2020**, Facebook connections that request the `context` field will fail, so Auth0 will stop requesting it for all connections.\n\nOn April 30th [Facebook deprecated](https://developers.facebook.com/docs/graph-api/changelog/4-30-2019-endpoint-deprecations) the use of the **Social Context** field for new applications. Auth0 continued to request that field by default for Facebook connections created before April 30, 2019. You can make sure the field is not requested before July 30 by unchecking the **Social context** field in the User Data connection section:\n\n![Facebook Context Field Deprecation](https://images.ctfassets.net/cdy7uua7fh8z/4oi3foRuwYYOveDlq2vJM/a57cd954ceeaf6d7722796be7c743b76/facebook-context.png)\n\nOnce you uncheck **Social context**, the profile data will not include the context field. The field has the following content:\n\n```\n\"context\": {\n      \"mutual_likes\": {\"data\": [],\"summary\": {\"total_count\": 0}},\n      \"id\": \"dXNlcl9...UZD\"\n    }\n```\n\n## Actions\n\nIf you are not using the `context` field in the Facebook profile returned by Auth0 in your application, then your application will keep working without changes. Otherwise, you will need to adjust your application code so it does not rely on it.\n\nTo ensure that your application is not affected on July 30 we recommend that you uncheck the **Social context** field in the Facebook connection properties.",
  "title": "Facebook Social Context Field Deprecation",
  "description": "Describes changes occuring due to Facebook removing access to the social context field from their profile.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/facebook-graph-api-changes",
  "markdown": "# Facebook Graph API Changes\n\nAs of August 1, 2018, Facebook has changed the Facebook Graph API permissions and fields that can be requested. Auth0 has updated Facebook Connections to reflect these changes and modified the connection interface for clarity. See [Facebook Login Changelog: Recent Changes to Facebook Login](https://developers.facebook.com/docs/facebook-login/changelog#2018-07-02) for complete details and key dates.\n\n## Features affected\n\nThe update may not require changes to your code or configuration, but your application might receive additional profile data if the existing permissions allow it. Keep in mind that:\n\n*   If your Facebook connection is configured to request one of the removed permissions, your Access Token will not get them in scope.\n    \n*   If your Facebook application is marked as \"development\" then you may still see an error temporarily while trying the connection.\n    \n*   If you add new permissions to the connection, end users will be prompted for consent next time they log in. See the Facebook documentation for how to handle actions for users that don't have a specific permission.\n    \n\n### Facebook login permissions\n\n[Facebook Login permissions](https://developers.facebook.com/docs/facebook-login/permissions) are requested by your application when a user logs in using Facebook. If the user is logging in for the first time or if the permissions have changed, they will be shown a consent window in Facebook showing the new permissions requested. Once those permissions are granted, your application can then act on behalf of that user with a Facebook access token.\n\nThe Facebook Connection interface has been updated to show both the regular name as well as the machine name for all permissions displayed. This makes it easier to find the permissions you need and map that to any code you might be running using these permission names.\n\n#### Permissions added\n\nThe following permissions were added to the Facebook connection interface:\n\n*   business\\_management\n    \n*   groups\\_access\\_member\\_info\n    \n*   leads\\_retrieval\n    \n*   pages\\_manage\\_instant\\_articles\n    \n*   publish\\_to\\_groups\n    \n*   publish\\_to\\_groups\n    \n*   user\\_age\\_range\n    \n*   user\\_gender\n    \n*   user\\_link\n    \n\n#### Permissions removed\n\nThe following permissions were removed from the Facebook connection interface:\n\n*   read\\_custom\\_friendlists\n    \n*   rsvp\\_event\n    \n*   user\\_about\\_me\n    \n*   user\\_actions-books\n    \n*   user\\_actions-fitness\n    \n*   user\\_actions-music\n    \n*   user\\_actions-news\n    \n*   user\\_actions-video\n    \n*   user\\_education\\_history\n    \n*   user\\_games\\_activity\n    \n*   user\\_relationship\\_details\n    \n*   user\\_relationships\n    \n*   user\\_religion\\_politics\n    \n*   user\\_website\n    \n*   user\\_work\\_history\n    \n\n#### Permissions moved to deprecated\n\nThe following permissions were moved to the **Deprecated** section and should not be used with the latest version of the Graph API:\n\n*   publish\\_actions\n    \n*   user\\_managed\\_groups\n    \n\n### Facebook Graph API fields\n\nThe [Facebook Graph API](https://developers.facebook.com/docs/graph-api/reference/v3.2/user) is used after a user logs in to retrieve profile data for the Auth0 user. The user data permissions requested determine what information is retrieved from the Graph API. The fields that are returned depend on the permissions requested and the existence of those fields in the Facebook user profile.\n\nThis change upgraded the Graph API from v2.8 to v3.2 and will ask for the following user data fields on login:\n\n*   address (added)\n    \n*   age\\_range\n    \n*   birthday\n    \n*   context\n    \n*   cover\n    \n*   currency (added)\n    \n*   devices\n    \n*   email\n    \n*   favorite\\_athletes\n    \n*   favorite\\_teams\n    \n*   first\\_name\n    \n*   gender\n    \n*   hometown\n    \n*   id\n    \n*   inspirational\\_people\n    \n*   install\\_type (added)\n    \n*   installed\n    \n*   is\\_verified\n    \n*   languages\n    \n*   last\\_name\n    \n*   link\n    \n*   locale\n    \n*   location\n    \n*   meeting\\_for (added)\n    \n*   middle\\_name\n    \n*   name\n    \n*   name\\_format\n    \n*   picture\n    \n*   public\\_key (added)\n    \n*   quotes\n    \n*   security\\_settings (added)\n    \n*   short\\_name (added)\n    \n*   significant\\_other\n    \n*   sports (added)\n    \n*   third\\_party\\_id\n    \n*   timezone\n    \n*   updated\\_time\n    \n*   verified\n    \n*   video\\_upload\\_limits (added)\n    \n*   viewer\\_can\\_send\\_gift (added)",
  "title": "Facebook Graph API Changes",
  "description": "The latest version of the Facebook Graph API changes what permissions and fields can be requested.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/angular/02-calling-an-api",
  "markdown": "# Auth0 Angular SDK Quickstarts: Call an API\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Single-Page App](https://auth0.com/docs/quickstart/spa)\n*   [Angular](https://auth0.com/docs/quickstart/spa/angular)\n*   [Call an API](https://auth0.com/docs/quickstart/spa/angular/02-calling-an-api)\n\nThis tutorial demonstrates how to make API calls to the Auth0 Management API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to integrate with my app\n\n15 minutes\n\n1.  [Provide the HTTP Interceptor](#provide-the-http-interceptor)\n2.  [Make an API Call](#make-an-api-call)\n\nOr\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Angular 12+\n\nThe focus of this guide is to show you how to configure the SDK to call APIs protected by OAuth 2. Instead of creating a demo API to test the client-server connection, you'll use the [Auth0 Management API](https://auth0.com/docs/api#management-api), which comes bundled with your Auth0 tenant. However, you can adapt this guide to work with any API that you are securing with Auth0.\n\nThis article builds upon [the previous chapter](https://auth0.com/docs/quickstart/spa/angular-next), adding the capability to automatically attach an access token to outgoing requests made using Angular's built-in `HttpClient` service.\n\n## Provide the HTTP Interceptor\n\nTo install and configure the HTTP interceptor, perform the following steps:\n\n*   Import the `authHttpInterceptorFn` type from the Auth0 Angular SDK\n*   Import `provideHttpClient` from `@angular/common/http`\n*   Register `authHttpInterceptorFn` in `provideHttpClient` using `withInterceptors`.\n*   Add configuration to specify audience, scope, and which requests should have an `Authorization` header attached automatically\n\nThe following is an example of an Angular module (based upon the default implementation when you create a new app using `ng new`) that supports `AuthHttpInterceptor`, configured to call the Auth0 Management API with the ability to read the current user profile:\n\nTo begin, open your `app.module.ts` file and add the necessary imports at the top:\n\n```\n// Import the injector module and the HTTP client module from Angular\nimport { provideHttpClient, withInterceptors } from '@angular/common/http';\n\n// Import the HTTP interceptor from the Auth0 Angular SDK\nimport { authHttpInterceptorFn } from '@auth0/auth0-angular';\n```\n\nNext, add `provideHttpClient` to the `providers` of the `bootstrapApplication` function, and add `authHttpInterceptorFn` using `withInterceptors`:\n\n```\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideHttpClient(withInterceptors([authHttpInterceptorFn])),\n  ]\n});\n```\n\nFinally, modify the configuration given to `provideAuth0()` to specify the `audience` and `scope` values required by the API you want to call, as well as the API routes that should be intercepted by `authHttpInterceptorFn`.\n\nIn this case, the audience and scope for the Auth0 Management API are given, which allows your app to retrieve information about the current user.\n\n```\nprovideAuth0({\n  // The domain and clientId were configured in the previous chapter\n  domain: '{yourDomain}',\n  clientId: '{yourClientId}',\n\n  authorizationParams: {\n    redirect_uri: window.location.origin,\n    \n    // Request this audience at user authentication time\n    audience: 'https://{yourDomain}/api/v2/',\n\n    // Request this scope at user authentication time\n    scope: 'read:current_user',\n  },\n\n  // Specify configuration for the interceptor              \n  httpInterceptor: {\n    allowedList: [\n      {\n        // Match any request that starts 'https://{yourDomain}/api/v2/' (note the asterisk)\n        uri: 'https://{yourDomain}/api/v2/*',\n        tokenOptions: {\n          authorizationParams: {\n            // The attached token should target this audience\n            audience: 'https://{yourDomain}/api/v2/',\n\n            // The attached token should have these scopes\n            scope: 'read:current_user'\n          }\n        }\n      }\n    ]\n  }\n})\n```\n\nPlease [refer to the docs](https://github.com/auth0/auth0-angular/blob/main/EXAMPLES.md#configure-authhttpinterceptor-to-attach-access-tokens) for more information on the available options for the HTTP interceptor.\n\n## Make an API Call\n\nWith your app module configured with the HTTP interceptor from the Angular SDK, calls you make using Angular's built-in `HttpClient` to the Auth0 Management API will have the appropriate access token specified in the `Authorization` header. Let's use this as an example for showing user metadata.\n\nThe following component demonstrates how to display the `user_metadata` field from the authenticated user's profile, by making a call to the `/api/v2/users` endpoint using `HttpClient`:\n\n```\nimport { Component, OnInit } from '@angular/core';\nimport { concatMap, tap, map } from 'rxjs/operators';\n\n// Import the HttpClient for making API requests\nimport { HttpClient } from '@angular/common/http';\n\n// Import AuthService from the Auth0 Angular SDK to get access to the user\nimport { AuthService } from '@auth0/auth0-angular';\n\n@Component({\n  selector: 'app-metadata',\n  template: `<div *ngIf=\"metadata\">\n    <pre>{{ metadata | json }}</pre>\n  </div>`,\n  standalone: true,\n})\nexport class UserMetadataComponent implements OnInit {\n  metadata = {};\n\n  // Inject both AuthService and HttpClient\n  constructor(public auth: AuthService, private http: HttpClient) {}\n\n  ngOnInit(): void {\n    this.auth.user$\n    .pipe(\n      concatMap((user) =>\n        // Use HttpClient to make the call\n        this.http.get(\n          encodeURI(`https://{yourDomain}/api/v2/users/${user?.sub}`)\n        )\n      ),\n      map((user: any) => user.user_metadata),\n      tap((meta) => (this.metadata = meta))\n    )\n    .subscribe();\n  }\n}\n```\n\nThis call succeeds because the HTTP interceptor took care of making sure the correct access token was included in the outgoing request.\n\n### Checkpoint\n\nYour application will show an empty JSON object if you have not set any `user_metadata` for the logged-in user. To further test out this integration, head to the [Users section of the Auth0 dashboard](https://manage.auth0.com/#/users) and click on the user who is logged in. Update the `user_metadata` section with a value like `{ \"theme\": \"dark\" }` and click \"Save\". Refresh your Angular application and verify that it reflects the new `user_metadata`.\n\nPlease refer to the [Auth0 API quickstarts](https://auth0.com/docs/quickstart/backend) to learn how to integrate Auth0 with your backend platform.",
  "title": "Auth0 Angular SDK Quickstarts: Call an API",
  "description": "This tutorial demonstrates how to make API calls to the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/vanillajs/02-calling-an-api",
  "markdown": "# Auth0 JavaScript SDK Quickstarts: Calling an API\n\nThis tutorial demonstrates how to make API calls for protected resources on your server. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nMost single-page apps use resources from data APIs. You may want to restrict access to those resources, so that only authenticated users with sufficient privileges can access them. Auth0 lets you manage access to these resources using [API Authorization](https://auth0.com/docs/api-auth).\n\nThis tutorial shows you how to access protected resources in your API.\n\n## Create an API\n\nIn the [APIs section](https://manage.auth0.com/#/apis) of the Auth0 dashboard, click **Create API**. Provide a name and an identifier for your API. You will use the identifier later when you're configuring your Javascript Auth0 application instance. For **Signing Algorithm**, select **RS256**.\n\n![Create API](https://auth0.com/docs/media/articles/api-auth/create-api.png)\n\n## Create a Backend API\n\nIn this section, you will modify the [ExpressJS](https://expressjs.com/) that you created in part 1 so that it supports a new endpoint. This endpoint will require a valid access token to be sent in the `Authorization` header for the call to be successful.\n\n### Add middleware to the backend\n\nTo begin, let's install an NPM package that will be used to validate incoming tokens to the server. From the terminal:\n\n```\nnpm install express-oauth2-jwt-bearer\n```\n\nNext, open `server.js` and bring in these libraries as imports at the top of the file. Also bring in the `auth_config.json` file so that the script can get access to the authentication credentials that have been configured:\n\n```\n// .. other imports\n\nconst { auth } = require(\"express-oauth2-jwt-bearer\");\nconst authConfig = require(\"./auth_config.json\");\n```\n\n*   [`express-oauth2-jwt-bearer`](https://npmjs.com/package/express-oauth2-jwt-bearer) - validates JWTs from the `authorization` header and sets the `req.auth` object\n\nThen add a call to `auth()`, which creates the middleware needed in order to validate and parse incoming access tokens. This should go after the `require` statements but before any routes are defined in your app:\n\n```\n// create the JWT middleware\nconst checkJwt = auth({\n  audience: authConfig.audience,\n  issuerBaseURL: `https://${authConfig.domain}`\n});\n```\n\nThis code configures the `express-oauth2-jwt-bearer` middleware with the settings that relate to your Auth0 application.\n\nNext, open the `auth_config.json` file and modify the data so that the `audience` appears as a key within the JSON, using the value that you just used when creating the API:\n\n```\n{\n  \"domain\": \"{yourDomain}\",\n  \"clientId\": \"{yourClientId}\",\n  \"audience\": \"{yourApiIdentifier}\"\n}\n```\n\nThe values for `domain` and `clientId` should have already been specified as part of the [Login tutorial](https://auth0.com/docs/quickstarts/spa/vanillajs/01-login). They should point to the Domain and Client ID values for your Auth0 app respectively.\n\n### Add a protected endpoint\n\nThe last thing to do on the server side is to add an API endpoint that requires an access token to be provided for the call to succeed. This endpoint will use the middleware that you created earlier in the tutorial to provide that protection in a scalable way.\n\nOpen `server.js` and add a new route for `/api/external` above the other routes that returns some JSON:\n\n```\n// ..\n\napp.get(\"/api/external\", checkJwt, (req, res) => {\n  res.send({\n    msg: \"Your access token was successfully validated!\"\n  });\n});\n\n// ..\n```\n\nNote that `checkJwt` is used as the second argument here. This causes `checkJwt` to be executed before the main route handler, and will reject the call and return a 401 response if:\n\n*   there is no access token present in the `Authorization` header,\n*   or the token itself is not valid\n\nFinally, add an error handler so that a JSON response is returned from your API in the event of a missing or invalid token:\n\n```\n// ..\n\napp.use(function(err, req, res, next) {\n  if (err.name === \"UnauthorizedError\") {\n    return res.status(401).send({ msg: \"Invalid token\" });\n  }\n\n  next(err, req, res);\n});\n\n//..\n```\n\nAt the end, your `server.js` file will look something like the following:\n\n```\nconst express = require(\"express\");\nconst { auth } = require(\"express-oauth2-jwt-bearer\");\nconst { join } = require(\"path\");\nconst authConfig = require(\"./auth_config.json\");\n\nconst app = express();\n\n// Serve assets from the /public folder\napp.use(express.static(join(__dirname, \"public\")));\n\n// Create the JWT validation middleware\nconst checkJwt = auth({\n  audience: authConfig.audience,\n  issuerBaseURL: `https://${authConfig.domain}`\n});\n\n// Create an endpoint that uses the above middleware to\n// protect this route from unauthorized requests\napp.get(\"/api/external\", checkJwt, (req, res) => {\n  res.send({\n    msg: \"Your access token was successfully validated!\"\n  });\n});\n\n// Serve the auth configuration file\napp.get(\"/auth_config.json\", (req, res) => {\n  res.sendFile(join(__dirname, \"auth_config.json\"));\n});\n\n// Serve the index page to everything else\napp.get(\"/*\", (req, res) => {\n  res.sendFile(join(__dirname, \"index.html\"));\n});\n\n// Error handler\napp.use(function(err, req, res, next) {\n  if (err.name === \"UnauthorizedError\") {\n    return res.status(401).send({ msg: \"Invalid token\" });\n  }\n\n  next(err, req, res);\n});\n\nmodule.exports = app;\n```\n\n### Test the API\n\nWith this in place, run the application using `npm run dev`. In another terminal window, use the `curl` tool to make a request to this API endpoint and observe the results:\n\n```\ncurl -I localhost:3000/api/external\n```\n\nYou should find that a 401 Unauthorized result is returned, because it requires a valid access token:\n\n```\nHTTP/1.1 401 Unauthorized\nX-DNS-Prefetch-Control: off\nX-Frame-Options: SAMEORIGIN\nStrict-Transport-Security: max-age=15552000; includeSubDomains\nX-Download-Options: noopen\nX-Content-Type-Options: nosniff\nX-XSS-Protection: 1; mode=block\nContent-Security-Policy: default-src 'self'\nContent-Type: text/html; charset=utf-8\nContent-Length: 1582\nDate: Wed, 03 Apr 2019 13:10:43 GMT\nConnection: keep-alive\n```\n\n## Calling the API\n\nNow you can turn your attention to the front-end application. You will update the application to provide a button to call a function which will in turn call the API that you created in the previous section.\n\nOpen `index.html` and add a new button that will invoke the API call, as well as a `pre` element with an ID of `api-call-result` to show the result of the API call in the browser:\n\n```\n<button id=\"btn-call-api\" disabled=\"true\" onclick=\"callApi()\">Call Api</button>\n\n<!-- Add a container to hold the response from the call -->\n<pre id=\"api-call-result\"></pre>\n```\n\nNext, open `public/js/app.js`. Configure the `auth0` client object to specify the audience value that was added earlier to the `auth_config.json` file:\n\n```\nconst configureClient = async () => {\n  const response = await fetchAuthConfig();\n  const config = await response.json();\n\n  auth0 = await auth0Client.createAuth0Client({\n    domain: config.domain,\n    clientId: config.clientId,\n    authorizationParams: {\n      audience: config.audience   // NEW - add the audience value\n    }\n  });\n};\n```\n\nAdd a new function called `callApi` to `app.js`, with the following content:\n\n```\nconst callApi = async () => {\n  try {\n\n    // Get the access token from the Auth0 client\n    const token = await auth0Client.getTokenSilently();\n\n    // Make the call to the API, setting the token\n    // in the Authorization header\n    const response = await fetch(\"/api/external\", {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n\n    // Fetch the JSON result\n    const responseData = await response.json();\n\n    // Display the result in the output element\n    const responseElement = document.getElementById(\"api-call-result\");\n\n    responseElement.innerText = JSON.stringify(responseData, {}, 2);\n\n} catch (e) {\n    // Display errors in the console\n    console.error(e);\n  }\n};\n```\n\nFinally, find the `updateUI` function within `app.js` and modify it so that the button for calling the API is enabled when the user logs in:\n\n```\n// public/js/app.js\n\nconst updateUI = async () => {\n  const isAuthenticated = await auth0Client.isAuthenticated();\n\n  document.getElementById(\"btn-logout\").disabled = !isAuthenticated;\n  document.getElementById(\"btn-login\").disabled = isAuthenticated;\n\n  // NEW - enable the button to call the API\n  document.getElementById(\"btn-call-api\").disabled = !isAuthenticated;\n\n  // .. other code omitted for brevity ..\n};\n```\n\nNow, open the browser in the application at [http://localhost:3000](http://localhost:3000/). If the application has been stopped, run it again from the terminal using `npm run dev`.\n\nWhen the application starts, log in. Then, press the **Call API** button to make a request to the API and put the results on the screen. You should find that the result from the server is displayed on the page.",
  "title": "Auth0 JavaScript SDK Quickstarts: Calling an API",
  "description": "This tutorial demonstrates how to make API calls for protected resources on your server.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/universal-login/classic",
  "markdown": "# Classic Login Experience\n\nClassic Login is an Auth0-hosted login experience that relies on JavaScript for customization. Implementing Classic Login is less complex than embedding the authentication process directly in your app, and it can help prevent the dangers of cross-origin authentication.\n\nClassic Login is built on top of Auth0's JavaScript libraries ([Lock.js](https://auth0.com/docs/libraries/lock), [auth0.js](https://auth0.com/docs/libraries/auth0js), MFA Widget, and Password Reset). When customizing Classic Login pages in the Auth0 Dashboard, the default templates use the same JavaScript libraries to create a more natural transition between the default user interface and a custom one.\n\nAfter choosing a default template for your Classic Login pages, you can modify it to meet your needs. You can also customize a variety of behavioral and appearance elements of the Lock widget. The Auth0.js templates offer additional flexibility as you can create a custom user interface and modify it to match your application's style.\n\n## Implement Classic Login\n\nTo learn how to set up your application to use Classic Login, read our [Quickstarts](https://auth0.com/docs/quickstarts). Choose the approach that best fits your technologies, and the Quickstarts walk you through the implementation.\n\n## Learn more\n\n*   [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login)\n*   [Customize Classic Login](https://auth0.com/docs/customize/login-pages/classic-login)\n*   [Customize Classic Login Pages](https://auth0.com/docs/customize/login-pages/classic-login/customization-classic)\n*   [Customize Classic Login Pages with Lock or SDK](https://auth0.com/docs/customize/login-pages/classic-login/customize-with-lock-sdk)\n*   [Customize MFA for Classic Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login)",
  "title": "Classic Login Experience",
  "description": "An overview of the Classic Login experience",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-android/android-development-keystores-hashes",
  "markdown": "# Android Development Keystores and Key Hashes\n\nWhen creating a new OAuth Credential for many connections you will need to provide the SHA-1 of the certificate you're using to sign your application. When completing your Application's configuration in the [Auth0 Dashboard](https://manage.auth0.com/#) you will also need to provide the SHA-256 value.\n\nLocate the certificate you're using to sign your application. If you don't have one you can generate it. For production applications, you should do this.\n\nDuring development, you can sign your application with the default `android.keystore` certificate that was generated automatically for you when you installed the SDK. In this example we're going to use this default keystore. To generate the key hashes using this keystore follow the examples below.\n\n## Generating your key hashes\n\n**On Windows:**\n\n`keytool -list -v -keystore \"%USERPROFILE%\\.android\\debug.keystore\" -alias androiddebugkey -storepass android -keypass android`\n\n**On Linux / macOS:**\n\n`keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android`\n\n**Sample output:**\n\n`Alias name: androiddebugkey Creation date: Jan 01, 2013 Entry type: PrivateKeyEntry Certificate chain length: 1 Certificate[1]: Owner: CN=Android Debug, O=Android, C=US Issuer: CN=Android Debug, O=Android, C=US Serial number: 4aa9b300 Valid from: Mon Jan 01 08:04:04 UTC 2013 until: Mon Jan 01 18:04:04 PST 2033 Certificate fingerprints: MD5: AE:9F:95:D0:A6:86:89:BC:A8:70:BA:34:FF:6A:AC:F9 SHA1: BB:0D:AC:74:D3:21:E1:43:07:71:9B:62:90:AF:A1:66:6E:44:5D:75 SHA256: 15:B9:F9:33:9F:E4:E3:68:C2:10:49:17:5D:A8:77:12:7C:8E:57:E9:FF:B7:23:EA:CC:DD:56:08:06:C9:5E:33 Signature algorithm name: SHA256withRSA Version: 3`\n\n## Using your key hashes\n\nOnce you have your key hashes output, copy the resulting SHA256 value and go to your application's settings in the [Auth0 Dashboard](https://manage.auth0.com/#/applications). Click \"Show Advanced Settings\", and in the \"Device Settings\" tab, under \"Android\", fill the \"App Package Name\" with your application's package name, and the \"Key Hashes\" field with the SHA256 value you copied. Don't forget to save the changes.\n\nIf you don't add the Callback URL to the application settings nor the Key Hashes to the application's device settings, the Auth0 server won't return the call result to your application.",
  "title": "Android Development Keystores and Key Hashes",
  "description": "Instructions on acquiring development keystores/key hashes during Android app development.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock-android/lock-android-configuration",
  "markdown": "# Lock.Android: Configuration\n\nYou can use the options below to configure functions and design for Lock for Android.\n\nConfigurations options are added to the Lock Builder using the following format:\n\n```\nval lock = Lock.newBuilder(account, callback)\n    // Configuration options\n    .closable(true)\n    .allowSignUp(false)\n    .setPrivacyURL('http://example.com/privacy')\n    .setTermsURL('http://example.com/terms')\n    // End configuration options\n    .build(this)\n```\n\n## General options\n\n*   **closable(boolean)**: Defines if the LockActivity can be closed. By default, it's not closable.\n    \n*   **allowedConnections(List)**: Filters the allowed connections from the list configured in the Dashboard. By default if this value is empty, all the connections defined in the dashboard will be available.\n    \n*   **hideMainScreenTitle(boolean)**: If set to `true`, the header on the main screen won't display the title.\n    \n\n## Authentication options\n\n*   **withAuthenticationParameters(Map<String, Object>)**: Defines extra authentication parameters to be sent on each log-in and sign-up call. The default `scope` used on authentication calls is `openid`. If you want to specify a different one, use `withAuthenticationParameters` and add a different value for the `scope` key.\n    \n*   **withScope(String)**: Changes the scope requested when performing an authentication request.\n    \n*   **withAudience(String)**: Changes the audience requested when performing an authentication request.\n    \n\n## Database options\n\n*   **withUsernameStyle(int)**: Defines if it should ask for email only, username only, or both of them. The accepted values are `USERNAME` and `EMAIL`. By default, it will respect the Dashboard configuration of the parameter `requires_username`.\n    \n*   **loginAfterSignUp(boolean)**: Whether after a `SignUp` event the user should be logged in automatically. Defaults to `true`.\n    \n*   **initialScreen(int)**: Allows to customize which form will first appear when launching Lock. The accepted values are `LOG_IN`, `SIGN_UP`, and `FORGOT_PASSWORD`. By default `LOG_IN` is the initial screen.\n    \n*   **allowSignUp(boolean)**: Shows the signup form if a Database connection is configured and it's allowed from the Dashboard. Defaults to `true`.\n    \n*   **allowLogIn(boolean)**: Shows the login form if a Database connection is configured. Defaults to `true`.\n    \n*   **allowForgotPassword(boolean)**: This shows the Forgot Password form if a Database connection is configured and it's allowed from the Dashboard. Defaults to `true`.\n    \n*   **allowShowPassword(boolean)**: Shows a button to toggle the input visibility of a Password field. Defaults to `true`.\n    \n*   **setDefaultDatabaseConnection(String)**: Defines which will be the default Database connection. This is useful if your application has many Database connections configured.\n    \n*   **enableEnterpriseWebAuthenticationFor(List)**: Filters the enterprise connections that will launch a web authentication flow via the browser when clicked. Only 'ad', 'adfs', or 'waad' strategies are allowed.\n    \n*   **withSignUpFields(List)**: Shows a second screen with extra fields for the user to complete after the username/email and password were completed in the sign-up screen. Values submitted this way can be stored in the user profile using either a root attribute or the `user_metadata` attribute. For more info, see [Lock Android: Custom Fields at Signup](https://auth0.com/docs/libraries/lock-android/lock-android-custom-fields-at-signup).\n    \n*   **setPrivacyURL(String)**: Allows to customize the Privacy Policy URL. Defaults to `https://auth0.com/privacy`.\n    \n*   **setTermsURL(String)**: Allows to customize the Terms of Service URL. Defaults to `https://auth0.com/terms`.\n    \n*   **setSupportURL(String)**: Allows to set a Support URL that will be displayed in case that a non-recoverable error raises on Lock.\n    \n*   **setMustAcceptTerms(boolean)**: Forces the user to accept the Terms&Policy before signing up. Defaults to `false`.\n    \n*   **useLabeledSubmitButton(boolean)**: If set to `true`, it will display a label of the current mode (sign up/ log in) in the submit button instead of an icon. Defaults to `true`. If the `hideMainScreenTitle` option is set to true this setting is ignored and a label will be used anyways.\n    \n\n## OAuth options\n\n*   **withAuthStyle(String, int)**: Customize the look and feel of a given connection (name) with a specific style. See [this document on custom oauth connections](https://auth0.com/docs/libraries/lock-android/lock-android-custom-theming) for more information.\n    \n*   **withConnectionScope(String, String...)**: Allows to specify additional scopes for a given Connection name, which will be requested along with the ones defined in the connection settings in the [Auth0 Dashboard](https://manage.auth0.com/#). The scopes are not validated in any way and need to be recognized by the given authentication provider. For a list, check the [Auth0 Dashboard](https://manage.auth0.com/#) under the settings for the connection in question.\n    \n*   **withScheme(String)**: Allows to change the scheme of the `redirect_uri` sent on the authorize call. By default, the scheme is `https`. If this setting is changed, the manifest placeholder for the `auth0Scheme` and the \"Allowed Callbacks URLs\" on the Auth0 application dashboard must be updated too.\n    \n\n## Passwordless options\n\n*   **useCode()**: Send a code instead of a link via email/SMS for Passwordless authentication.\n    \n*   **useLink()**: Send a link instead of a code via email/SMS for Passwordless authentication.\n    \n*   **rememberLastLogin(boolean)**: Whether the email or phone used in the last successful authentication will be saved to auto-login the next time a Passwordless authentication is requested.",
  "title": "Lock.Android: Configuration",
  "description": "Altering the appearance and behavior of Lock.Android",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/basic-issues/check-error-messages",
  "markdown": "# Check Error Messages\n\nCheck for error messages displayed in any of the following locations:\n\n*   Browsers and HTML page responses\n    \n*   Developer tools network and console tabs\n    \n*   Authorization Server responses\n    \n*   Deprecation errors\n    \n\n## Check browser errors\n\nA HAR file is a JSON formatted log of a web browser's interactions with a web server. If authentication isn't working as expected, you can [generate and analyze HAR files](https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files) to find issues.\n\n## Check login screen\n\nThe Lock login widget shows error messages for certain types of issues, such as an incorrect username or password. Check the **More Information** link if you're using Auth0's standard error page.\n\n## Check logs\n\nAuth0 stores [log data](https://auth0.com/docs/deploy-monitor/logs) including Dashboard administrator actions, successful and failed user authentications, and password change requests. You can view the logs in the [Dashboard](https://manage.auth0.com/#/logs).\n\nSome types of errors do not appear in the logs. For example, if an error occurs at a remote Identity Provider, where authentication doesn’t complete and the user is never returned to Auth0, there will not be any entry in logs.\n\nYou can export Auth0 logs and either store them yourself or automatically push them to external log services. This functionality can help you with data retention requirements, as well as log analysis requirements. You can install and configure an Auth0 Extension to export logs automatically to another provider like Sumo Logic or Loggly. To learn more, navigate to our [log streaming solutions](https://marketplace.auth0.com/features/log-streaming) in Auth0 Marketplace.\n\nYou can also use the Management API to export logs and store them. There are the two available endpoints, each providing slightly different information.\n\n### Search all logs /get\\_logs endpoint\n\nThe [Search log events endpoint](https://auth0.com/docs/api/management/v2#!/Logs/get_logs) retrieves log entries that match the search criteria you provided. If you do not provide any search criteria, you will get a list of all available entries.\n\nYou can provide search criteria using the **q** parameter and retrieve specific fields using the **fields** parameter.\n\nTo access the API, you need a [Management APIv2 token](https://auth0.com/docs/api/management/v2/tokens).\n\nThis sample request retrieves all logs for successful logins (the event acronym for successful login is `s`). The list of fields we will retrieve per log entry is: **date**, **description**, **client\\_id**, and **log\\_id**.\n\nFor details on the search criteria you can use and a list with the event acronyms, see the [Search log events endpoint](https://auth0.com/docs/api/management/v2#!/Logs/get_logs).\n\n### Get a single log entry /get\\_logs\\_by\\_id endpoint\n\nThe [Get a log event by ID endpoint](https://auth0.com/docs/api/management/v2#!/Logs/get_logs_by_id) retrieves the log entry associated with the provided ID.\n\nThis sample request retrieves a single log entry with the ID `90020180129170850881585554625888895190928456277777449010`.\n\n## Check logs for deprecation errors\n\nWhen Auth0 features are deprecated, there may be errors or notices in the tenant logs that show up to indicate that your applications are using the deprecated features. You can [search the logs for specific deprecation entries](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors) that may indicate that a feature has been deprecated.\n\n## Rate limits and other errors\n\nAuth0 provides a unique error code for errors reported when the [rate limit is exceeded](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy). You should set up automatic scanning of logs to check for rate limit errors so you can proactively address activity that hits rate limits before it causes too much trouble for your users. Auth0 also publishes error codes for other types of errors, and you will find it helpful to scan logs for authentication errors as well as errors from Auth0 Management API calls (Management API error codes are shown below each call in the [Management API Explorer](https://auth0.com/docs/api/management/v2)).\n\nAlso note that calling the Management API to retrieve user profile information from within a Rule is a common cause of rate limit errors because such API calls can execute for every login as well as periodic session checks.\n\n## Check real-time webtask logs error console\n\nYou can put `console.log()` statements into Rules, Hooks, custom database scripts, and Webtasks. The output from those statements is viewable in the Realtime Web Log. If you install the Real-time Webtask Logs extension, you can initiate a view of this log console from the **Debug** buttons underneath the Rules, Hooks, and custom DB script editor windows, or from the webtask console for webtasks.\n\n## Learn more\n\n*   [Verify Platform](https://auth0.com/docs/troubleshoot/basic-issues/verify-platform)\n*   [Verify Connections](https://auth0.com/docs/troubleshoot/basic-issues/verify-connections)\n*   [Verify Domain](https://auth0.com/docs/troubleshoot/basic-issues/verify-domain)\n*   [Verify Rules](https://auth0.com/docs/troubleshoot/basic-issues/verify-rules)\n*   [Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors)",
  "title": "Check Error Messages",
  "description": "Learn how to check for error message to troublshoot issues",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock-android/lock-android-passwordless",
  "markdown": "# Lock.Android: Passwordless\n\nLock Passwordless authenticates users by sending them an Email or SMS with a one-time password that the user must enter and confirm to be able to log in, similar to how WhatsApp authenticates. This article will explain how to send a CODE using the `Lock.Android` library.\n\nYou can achieve a similar result by [sending a link that the user can click](https://auth0.com/docs/libraries/lock-android/lock-android-passwordless-with-magic-link) to finish the passwordless authentication automatically, but a few more configuration steps are involved.\n\nIn order to be able to authenticate the user, your application must have the Email/SMS connection enabled and configured in your [Auth0 Dashboard](https://manage.auth0.com/#/connections/passwordless).\n\n## Implementing Code Passwordless\n\n### Configuring the SDK\n\nIn your `app/build.gradle` file add the [Manifest Placeholders](https://developer.android.com/studio/build/manifest-build-variables.html) for the Auth0 Domain and the Auth0 Scheme properties, which are going to be used internally by the library to register an intent-filter that captures the authentication result.\n\n```\nplugins {\n    id \"com.android.application\"\n    id \"kotlin-android\"\n}\n\nandroid {\n    compileSdkVersion 30\n    defaultConfig {\n        applicationId \"com.auth0.samples\"\n        minSdkVersion 21\n        targetSdkVersion 30\n        // ...\n\n        // ---> Add the next line\n        manifestPlaceholders = [auth0Domain: \"@string/com_auth0_domain\", auth0Scheme: \"https\"]\n        // <---\n    }\n}\n```\n\nIt is good practice to add these values to the `strings.xml` file as string resources that can be referenced later from the code.\n\n```\n<resources>\n    <string name=\"com_auth0_client_id\">{yourClientId}</string>\n    <string name=\"com_auth0_domain\">{yourDomain}</string>\n</resources>\n```\n\n### SDK usage\n\nIn the activity where you plan to invoke Lock, create an instance of `Auth0` with your application's information. The easiest way to create it is by passing an Android Context. This will use the values previously defined in the `strings.xml` file. For this to work, the string resources must be defined using the same keys as the ones listed above.\n\n```\nval account = Auth0(context)\n```\n\nDeclare an `AuthenticationCallback` implementation that will handle user authentication events. The `Credentials` object returned in successful authentication scenarios will contain the tokens that your application or API will end up consuming. See [Tokens](https://auth0.com/docs/secure/tokens) for more specifics.\n\n```\nprivate val callback = object : AuthenticationCallback() {\n    override fun onAuthentication(credentials: Credentials) {\n        // Authenticated\n    }\n\n    override fun onError(error: AuthenticationException) {\n        // Exception occurred\n    }\n}\n```\n\nPrepare a new Lock instance by using the Builder class to configure it. Provide the account details and the callback implementation declared above. Values like audience, scope, and available connections, among others, can be configured here. When done, build the Lock instance. This instance is meant to be reused and must be disposed of when it is no longer needed. A good place to do this is in your activity's `onDestroy` method.\n\nThe sample below calls the `useCode()` method to make Lock send a **CODE** to the user's email or phone number.\n\n```\n// This activity will show Passwordless Lock\nclass MyActivity : AppCompatActivity() {\n\n    private lateinit var lock: PasswordlessLock\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val account = Auth0(this)\n        // Instantiate Lock once\n        lock = PasswordlessLock.newBuilder(account, callback)\n            .useCode()\n            // Customize Lock\n            .build(this)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        // Important! Release Lock and its resources\n        lock.onDestroy(this)\n    }\n\n    private val callback = object : AuthenticationCallback() {\n        override fun onAuthentication(credentials: Credentials) {\n            // Authenticated\n        }\n\n        override fun onError(error: AuthenticationException) {\n            // An exception occurred\n        }\n    }\n}\n```\n\nFinally, launch the `PasswordlessLock` widget from inside your activity.\n\n```\nstartActivity(lock.newIntent(this))\n```\n\nDepending on which passwordless connections are enabled, Lock will send the **CODE** in an Email or SMS. The 'email' connection is selected first if available. Then the user must input the CODE in the confirmation step. If the value equals the one the server is expecting, the authentication will be successful.",
  "title": "Lock.Android: Passwordless",
  "description": "Guide on implementing Passwordless authentication with Lock.Android",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock-android/lock-android-custom-theming",
  "markdown": "# Lock.Android: Custom Theming\n\nYou can customize the look and feel of **Lock.Android** UI. Along with various items such as the header logo and title, you can alter some colors, buttons, and other items to fit the theme of your application.\n\n## Supported attributes list\n\n| Name | Type | Description |\n| --- | --- | --- |\n| Auth0.HeaderLogo | drawable - reference | Logo drawable to display inside the header. The minimum recommended resolution is 200 pixels (width) by 200 pixels (height). |\n| Auth0.HeaderTitle | string - reference | Text to display as Title inside the header. |\n| Auth0.HeaderTitleColor | color - reference | Color for the Title text. |\n| Auth0.HeaderBackground | color - reference | Used as background color in the header. |\n| Auth0.PrimaryColor | color - reference | Used as _normal_ state in widgets like the Submit button. Also used as _accent_ color. |\n| Auth0.DarkPrimaryColor | color - reference | Used as _pressed_ state in widgets like the Submit button. |\n\n## Create a New Resource File\n\nFirst, create a new `Theme` that extends from `Lock.Theme`, and override the attributes you want to customize. Those attributes not overridden will default to the ones defined in `Lock.Theme`.\n\n```\n<resources>\n  <style name=\"MyTheme\" parent=\"Lock.Theme\">\n    <item name=\"Auth0.HeaderLogo\">@drawable/com_auth0_lock_header_logo</item>\n    <item name=\"Auth0.HeaderTitle\">@string/com_auth0_lock_header_title</item>\n    <item name=\"Auth0.HeaderTitleColor\">@color/com_auth0_lock_text</item>\n    <item name=\"Auth0.HeaderBackground\">@color/com_auth0_lock_header_background</item>\n    <item name=\"Auth0.PrimaryColor\">@color/com_auth0_lock_submit_normal</item>\n    <item name=\"Auth0.DarkPrimaryColor\">@color/com_auth0_lock_submit_pressed</item>\n  </style>\n</resources>\n```\n\nTo start using the new theme, set up the Activity in the `AndroidManifest.xml` file with the `android:theme` attribute. Depending on if you are using Classic Lock or Passwordless Lock, the activity declaration to update will differ. Because the Lock library declares these activities internally, you need to re-declare them with the special tools`:replace` attribute that will override the library's declaration only for the theme attribute.\n\n```\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.company.app\">\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\">\n        <!-- Classic -->\n        <activity\n            android:name=\"com.auth0.android.lock.LockActivity\"\n            android:theme=\"@style/MyTheme\"\n            tools:replace=\"android:theme\" />\n        <!-- Passwordless -->\n        <activity\n            android:name=\"com.auth0.android.lock.PasswordlessLockActivity\"\n            android:theme=\"@style/MyTheme\"\n            tools:replace=\"android:theme\" />\n    </application>\n</manifest>\n```\n\n## Custom OAuth Connection Buttons\n\nTo customize the style of a third-party identity provider connection, you must create a new connection by using the `Custom Social Connections` [extension](https://manage.auth0.com/#/extensions), filling in every required field before saving the changes.\n\nTo customize the style of a third-party identity provider connection in Lock, call the builder and pass both the `connectionName` and the `style` to use.\n\nFirst, create a custom style that extends `Lock.Theme.AuthStyle.` Define the logo, background color, and name of the connection using names of the keys similar to the example below.\n\n```\n<style name=\"Style.Facebook\" parent=\"Lock.Theme.AuthStyle\">\n    <item name=\"Auth0.BackgroundColor\">@color/facebook_color</item>\n    <item name=\"Auth0.Name\">@string/facebook_name</item>\n    <item name=\"Auth0.Logo\">@drawable/facebook_logo</item>\n</style>\n```\n\nIn the builder's setup, add the `AuthStyle` for the connection name that you want to override.\n\n`builder.withAuthStyle(\"facebook\", R.style.Style_Facebook) .build(...);`\n\nWhen **Lock** needs to display that connection in a **SocialButton**, it will first search for user-overridden styles. If none is found, it will default to the default Lock style. Following the example above, this means that for `facebook` it would use the Facebook background color, Facebook logo and \"`FACEBOOK\"` as name.",
  "title": "Lock.Android: Custom Theming",
  "description": "Customizing the Lock.Android UI",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock-android/lock-android-custom-fields-at-signup",
  "markdown": "# Lock.Android: Custom Fields at Signup\n\n**Lock.Android** allows you to specify additional fields the user must complete before creating a new account. The extra fields will be shown on a second screen after the user completes the basic fields (email, username, password).\n\n## Create the Custom Fields\n\nCreate a new `CustomField` object passing all these 4 mandatory parameters.\n\n1.  Icon: The `int` that points to the resource you want to use as Icon (keep it small).\n    \n2.  Type: The `FieldType` to use in this field. The type defines the keyboard layout and sometimes the input validation.\n    \n3.  Key: The `String` that identifies this value in the result JSON. It shouldn't be repeated! Repeated field keys will result in the second field getting removed from the list.\n    \n4.  Hint: The `@StringRes` of the text to show as hint in the field.\n    \n\nIn addition, you can specify where the field is going to be stored on the user's profile. See the [Storage](#storage) section below for details.\n\nYou can also create fields that will not be shown to the user but can be used to include additional metadata in a dynamic way after sign up.\n\n```\n// Regular field\nval nameField = CustomField(R.drawable.ic_name, FieldType.TYPE_NAME, \"first_name\", R.string.hint_first_name, CustomField.Storage.PROFILE_ROOT)\n\n// Hidden field\nval androidField = HiddenField(\"android_version\", Build.VERSION.SDK_INT.toString(), Storage.USER_METADATA)\n\nval customFields = listOf(nameField, androidField)\n```\n\nRepeat the above steps as many times as fields you need.\n\n## Use the Custom Fields\n\nPass the list of custom fields to the Lock instance while you are building it, using the method `withSignUpFields()`.\n\n```\nval lock = Lock.newBuilder(auth0, callback)\n              .withSignUpFields(customFields)\n              //...\n              .build(this)\n```\n\nIf you have enabled sign up in the Application's Dashboard, users will be prompted to fill the remaining fields after they complete the basic fields (email/username, password) and hit **Submit**. The user must fill all of the custom fields before being able to complete the signup.\n\nDuring sign up, the extra fields are attached to the `user_metadata` attribute or are directly set in the root user profile, depending on the Storage option chosen. You can access these properties by querying the user profile at any time, even from the Dashboard in the User's section.\n\n## Field Types\n\nEach custom field can only have one `FieldType` associated.\n\n*   TYPE\\_NAME\n    \n*   TYPE\\_NUMBER\n    \n*   TYPE\\_PHONE\\_NUMBER\n    \n*   TYPE\\_EMAIL\n    \n\n## Storage\n\nEach custom field can only have one `Storage` associated. You can choose to store it at the root level in a root profile attribute or inside the `user_metadata` attribute. To specify the storage location, use the five-parameter constructor and pass the `Storage` parameter of your choice. By default, fields will be stored inside the `user_metadata` attribute.\n\nAvailable choices:\n\n*   PROFILE\\_ROOT\n    \n*   USER\\_METADATA (default)\n    \n\nFor the fields to be saved at the root level of the user's profile, their keys must match the ones listed in the [endpoint documentation](https://auth0.com/docs/api/authentication#signup).",
  "title": "Lock.Android: Custom Fields at Signup",
  "description": "Adding additional fields to signups with Lock.Android",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/internationalization-and-localization/lock-android-internationalization",
  "markdown": "# Lock.Android Internationalization\n\nBy default, **Lock.Android** displays all text in English. If you wish to display text in another language, you may provide a `strings.xml` file and define values to be used for the various text items that Lock might display.\n\nAndroid asks the device what locale was configured by the user and tries to fetch the list of localized texts for that language. For this to work, the developer needs to add each translation file into the app by using a special folder naming convention as per Android standards. More information can be found in the [Android developer docs](https://developer.android.com/training/basics/supporting-devices/languages).\n\nSome of the default values provided by Lock include:\n\n```\n<resources>\n  <string name=\"com_auth0_lock_social_error_authentication\">Error parsing Authentication data</string>\n  <string name=\"com_auth0_lock_social_error_title\">There was an error during authentication</string>\n  ...\n</resources>\n```\n\nBy providing your own `strings.xml` file, these values can be adjusted as such:\n\n```\n<resources>\n  <string name=\"com_auth0_lock_social_error_authentication\">There was an authentication error!</string>\n  <string name=\"com_auth0_lock_social_error_title\">Social login error!!</string>\n  ...\n</resources>\n```\n\n## Lock String Values\n\nFor a full list of the names used by Lock, see the [default strings.xml file](https://github.com/auth0/Lock.Android/blob/master/lib/src/main/res/values/strings.xml) in the Lock.Android repository.",
  "title": "Lock.Android Internationalization",
  "description": "Internationalization support in Lock.Android",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/auth0-swift",
  "markdown": "# Auth0.swift\n\n## Documentation\n\n*   [Quickstart](https://auth0.com/docs/quickstart/native/ios-swift/interactive): Shows how to integrate Auth0.swift into an iOS / macOS app from scratch.\n    \n*   [Sample App](https://github.com/auth0-samples/auth0-ios-swift-sample/tree/master/Sample-01): A complete, running iOS / macOS app you can try.\n    \n*   [Examples](https://github.com/auth0/Auth0.swift/blob/master/EXAMPLES.md): Explains how to use most features.\n    \n*   [API Documentation](https://auth0.github.io/Auth0.swift/documentation/auth0): Documentation auto-generated from the code comments that explains all the available features.\n    \n    *   [Web Auth](https://auth0.github.io/Auth0.swift/documentation/auth0/webauth)\n        \n    *   [Credentials Manager](https://auth0.github.io/Auth0.swift/documentation/auth0/credentialsmanager)\n        \n    *   [Authentication API Client](https://auth0.github.io/Auth0.swift/documentation/auth0/authentication)\n        \n    *   [Management API Client (Users)](https://auth0.github.io/Auth0.swift/documentation/auth0/users)\n        \n*   [FAQ](https://github.com/auth0/Auth0.swift/blob/master/FAQ.md): Answers some common questions about Auth0.swift.\n    \n*   [Auth0 Documentation:](https://auth0.com/docs) Explore our docs site and learn more about Auth0.\n    \n\n## Getting started\n\n### Requirements\n\n*   iOS 13.0+ / macOS 11.0+ / tvOS 13.0+ / watchOS 7.0+\n    \n*   Xcode 14.x\n    \n*   Swift 5.7+\n    \n\n### Installation\n\n#### Swift Package Manager\n\nOpen the following menu item in Xcode:\n\n**File > Add Packages...**\n\nIn the **Search or Enter Package URL** search box enter this URL:\n\n```\nhttps://github.com/auth0/Auth0.swift\n```\n\nThen, select the dependency rule and press **Add Package**.\n\n#### Cocoapods\n\nAdd the following line to your `Podfile`:\n\nThen, run `pod install`.\n\n#### Carthage\n\nAdd the following line to your `Cartfile`:\n\n```\ngithub \"auth0/Auth0.swift\" ~> 2.0\n```\n\nThen, run `carthage bootstrap --use-xcframeworks`.\n\n### Configure the SDK\n\nGo to the [Auth0 Dashboard](https://manage.auth0.com/#/applications/) and create a new **Native** application.\n\nAuth0.swift needs the **Client ID** and **Domain** of the Auth0 application to communicate with Auth0. You can find these details in the Settings page of your Auth0 application. If you are using a [custom domain](https://auth0.com/docs/customize/custom-domains), use the value of your custom domain instead of the value from the Settings page.\n\n#### Configure Client ID and Domain with a plist\n\nCreate a `plist` file named `Auth0.plist` in your app bundle with the following content:\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>ClientId</key>\n    <string>{yourAuth0ClientId}</string>\n    <key>Domain</key>\n    <string>{yourAuth0Domain}</string>\n</dict>\n</plist>\n```\n\n#### Configure Client ID and Domain programmatically\n\n##### For Web Auth\n\n```\nAuth0\n    .webAuth(clientId: \"{yourAuth0ClientID}\", domain: \"{yourAuth0Domain}\")\n    // ...\n```\n\n##### For the Authentication API client\n\n```\nAuth0\n    .authentication(clientId: \"{yourAuth0ClientID}\", domain: \"{yourAuth0Domain}\")\n    // ...\n```\n\n##### For the Management API client (Users)\n\n```\nAuth0\n    .users(token: credentials.accessToken, domain: \"{yourAuth0Domain}\")\n    // ...\n```\n\n### Configure Web Auth (iOS / macOS)\n\n#### Configure callback URL and logout URL\n\nThe callback URL and logout URL are the URLs that Auth0 invokes to redirect back to your application. Auth0 invokes the callback URL after authenticating the user, and the logout URL after removing the session cookie.\n\nSince the callback URL and logout URL can be manipulated, you will need to add your URLs to the **Allowed Callback URLs** and **Allowed Logout URLs** fields in the Settings page of your Auth0 application. This will enable Auth0 to recognize these URLs as valid. If the callback URL and logout URL are not set, users will be unable to log in and out of the application and will get an error.\n\nGo to the Settings page of your [Auth0 application](https://manage.auth0.com/#/applications/) and add the corresponding URL to **Allowed Callback URLs** and **Allowed Logout URLs**, according to the platform of your application. If you are using a [custom domain](https://auth0.com/docs/customize/custom-domains), replace `{yourAuth0Domain}` with the value of your custom domain instead of the value from the Settings page.\n\n##### iOS\n\n```\n{yourBundleIdentifier}://{yourAuth0Domain}/ios/{yourBundleIdentifier}/callback\n```\n\n##### macOS\n\n```\n{yourBundleIdentifier}://{yourAuth0Domain}/macos/{yourBundleIdentifier}/callback\n```\n\nFor example, if your iOS bundle identifier was `com.example.MyApp` and your Auth0 Domain was `example.us.auth0.com`, then this value would be:\n\n```\ncom.example.MyApp://example.us.auth0.com/ios/com.example.MyApp/callback\n```\n\n#### Configure custom URL scheme\n\nIn Xcode, go to the **Info** tab of your app target settings. In the **URL Types** section, click the **＋** button to add a new entry. There, enter `auth0` into the **Identifier** field and `$(PRODUCT_BUNDLE_IDENTIFIER)` into the **URL Schemes** field.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3ZFJS76F8PEIZuozbjRKwg/c96fec5989ffb925488a94fe30ac22f0/url-scheme.png)\n\nThis registers your bundle identifier as a custom URL scheme, so the callback URL and logout URL can reach your app.\n\n### Web Auth login (iOS / macOS)\n\nImport the `Auth0` module in the file where you want to present the login page.\n\nThen, present the [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) page in the action of your **Login** button.\n\n```\nAuth0\n    .webAuth()\n    .start { result in\n        switch result {\n        case .success(let credentials):\n            print(\"Obtained credentials: \\(credentials)\")\n        case .failure(let error):\n            print(\"Failed with: \\(error)\")\n        }\n    }\n```\n\n#### Using async/await\n\n```\ndo {\n    let credentials = try await Auth0.webAuth().start()\n    print(\"Obtained credentials: \\(credentials)\")\n} catch {\n    print(\"Failed with: \\(error)\")\n}\n```\n\n#### Using Combine\n\n```\nAuth0\n    .webAuth()\n    .start()\n    .sink(receiveCompletion: { completion in\n        if case .failure(let error) = completion {\n            print(\"Failed with: \\(error)\")\n        }\n    }, receiveValue: { credentials in\n        print(\"Obtained credentials: \\(credentials)\")\n    })\n    .store(in: &cancellables)\n```\n\n### Web Auth logout (iOS / macOS)\n\nLogging the user out involves clearing the Universal Login session cookie and then deleting the user's credentials from your application.\n\nCall the `clearSession()` method in the action of your **Logout** button. Once the session cookie has been cleared, [delete the user's credentials](https://github.com/auth0/Auth0.swift/blob/master/EXAMPLES.md#clear-stored-credentials).\n\n```\nAuth0\n    .webAuth()\n    .clearSession { result in\n        switch result {\n        case .success:\n            print(\"Session cookie cleared\")\n            // Delete credentials\n        case .failure(let error):\n            print(\"Failed with: \\(error)\")\n        }\n    }\n```\n\n#### Using async/await\n\n```\ndo {\n    try await Auth0.webAuth().clearSession()\n    print(\"Session cookie cleared\")\n    // Delete credentials\n} catch {\n    print(\"Failed with: \\(error)\")\n}\n```\n\n#### Using Combine\n\n```\nAuth0\n    .webAuth()\n    .clearSession()\n    .sink(receiveCompletion: { completion in\n        switch completion {\n        case .finished:\n            print(\"Session cookie cleared\")\n            // Delete credentials\n        case .failure(let error):\n            print(\"Failed with: \\(error)\")\n        }\n    }, receiveValue: {})\n    .store(in: &cancellables)\n```\n\n### SSO alert box (iOS / macOS)\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/c7JkfRnkm3HC12OqbNcpf/74cad82d875e50b2dca62088d44c2db9/sso-alert.png)\n\nCheck the [FAQ](https://github.com/auth0/Auth0.swift/blob/master/FAQ.md) for more information about the alert box that pops up by default when using Web Auth.\n\n## Next steps\n\nLearn about most features in [Examples](https://github.com/auth0/Auth0.swift/blob/master/EXAMPLES.md):\n\n*   [Store credentials](https://github.com/auth0/Auth0.swift/blob/master/EXAMPLES.md#store-credentials): Store the user's credentials securely in the Keychain.\n    \n*   [Check for stored credentials](https://github.com/auth0/Auth0.swift/blob/master/EXAMPLES.md#check-for-stored-credentials): Check if the user is already logged in when your app starts up.\n    \n*   [Retrieve stored credentials](https://github.com/auth0/Auth0.swift/blob/master/EXAMPLES.md#retrieve-stored-credentials): Get the user's credentials from the Keychain, automatically renewing them if they have expired.\n    \n*   [Clear stored credentials](https://github.com/auth0/Auth0.swift/blob/master/EXAMPLES.md#clear-stored-credentials): Delete the user's credentials to complete the logout process.\n    \n*   [Retrieve user information](https://github.com/auth0/Auth0.swift/blob/master/EXAMPLES.md#retrieve-user-information): Get the latest user information from the `/userinfo` endpoint.",
  "title": "Auth0.swift",
  "description": "How to install and get started with Auth0.swift",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock-swift/lock-swift-customization",
  "markdown": "# Lock.swift: Style Customization Options\n\nThere are numerous options to configure Lock's style and appearance listed below. In addition, there are also quite a few options available to alter Lock's behavior and functionality in the [Behavior Configuration Options](https://auth0.com/docs/libraries/lock-swift/lock-swift-configuration-options) page.\n\n## Customizing Lock's appearance\n\nStyle customization options can be added to your Lock initialization using `withStyle`.\n\n```\nLock\n  .classic()\n  .withStyle {\n\t  $0.title = \"Company LLC\"\n\t  $0.logo = LazyImage(name: \"company_logo\")\n\t  $0.primaryColor = UIColor(red: 0.6784, green: 0.5412, blue: 0.7333, alpha: 1.0)\n\t}\n  .present(from: self)\n```\n\nBlur effect style used. It can be any value defined in `UIBlurEffectStyle`.\n\n```\n.withStyle {\n  $0.headerBlur = .extraLight\n}\n```\n\nColor used as the header background color. By default it has no color, just a blur.\n\n```\n.withStyle {\n  $0.headerColor = UIColor? = nil\n}\n```\n\n### logo\n\nHeader logo image. The minimum recommended resolution is 200 pixels (width) by 200 pixels (height).\n\n```\n.withStyle {\n  $0.logo = LazyImage(name: \"company_logo\")\n}\n```\n\nThe \"close\" icon in the header can be altered.\n\n```\n.withStyle {\n  $0.headerCloseIcon = LazyImage(name: \"ic_close\")\n}\n```\n\nThe \"back\" icon in the header can be altered.\n\n```\n.withStyle {\n  $0.headerBackIcon = LazyImage(name: \"ic_close\")\n}\n```\n\n## Title Style Options\n\n### hideTitle\n\nHide header title and show only the logo. By default this option is false.\n\n```\n.withStyle {\n  $0.hideTitle = false\n}\n```\n\n### title\n\nTitle text used in the header\n\n```\n.withStyle {\n  $0.title = \"Company LLC\"\n}\n```\n\n### titleColor\n\nColor used as the header title color.\n\n```\n.withStyle {\n  $0.titleColor = UIColor.black\n}\n```\n\n## Button and Component Style Options\n\n### buttonTintColor\n\nColor used as the primary button tint color.\n\n```\n.withStyle {\n  $0.buttonTintColor = UIColor.white\n}\n```\n\n### disabledColor\n\nColor used as the Lock disabled component color.\n\n```\n.withStyle {\n  $0.disabledColor = UIColor(red: 0.8902, green: 0.898, blue: 0.9059, alpha: 1.0)\n}\n```\n\n### disabledTextColor\n\nColor used as the Lock disabled component text color.\n\n```\n.withStyle {\n  $0.disabledTextColor = UIColor(red: 0.5725, green: 0.5804, blue: 0.5843, alpha: 1.0)\n}\n```\n\n### hideButtonTitle\n\nHide primary button title and show only the icon. By default this option is false.\n\n```\n.withStyle {\n  $0.hideButtonTitle = false\n}\n```\n\n### primaryColor\n\nColor used as the Lock primary color.\n\n```\n.withStyle {\n  $0.primaryColor = UIColor.orange\n}\n```\n\n## Input Field Styles\n\n### inputTextColor\n\nThe color of input field text.\n\n```\n.withStyle {\n  $0.inputTextColor = UIColor.black\n}\n```\n\n### inputPlaceholderTextColor\n\nThe color of the placeholder text in input fields.\n\n```\n.withStyle {\n  $0.inputPlaceholderTextColor = UIColor(red: 0.780, green: 0.780, blue: 0.804, alpha: 1.00)\n}\n```\n\n### inputBorderColor\n\nThe color of the border of input fields.\n\n```\n.withStyle {\n  $0.inputBorderColor = UIColor(red: 0.780, green: 0.780, blue: 0.804, alpha: 1.00)\n}\n```\n\n### inputBorderColorError\n\nThe color of the border of input fields which have invalid values.\n\n```\n.withStyle {\n  $0.inputBorderColorError = UIColor.red\n}\n```\n\n### inputBackgroundColor\n\nThe color of the background of input fields.\n\n```\n.withStyle {\n  $0.inputBackgroundColor = UIColor.white\n}\n```\n\n### inputIconBackgroundColor\n\nThe color of the background of input field icons.\n\n```\n.withStyle {\n  $0.inputIconBackgroundColor = UIColor(red: 0.9333, green: 0.9333, blue: 0.9333, alpha: 1.0)\n}\n```\n\n### inputIconColor\n\nThe color of the input field icons.\n\n```\n.withStyle {\n  $0.inputIconColor = UIColor(red: 0.5725, green: 0.5804, blue: 0.5843, alpha: 1.0)\n}\n```\n\n## Status Bar Styles\n\n### UIStatusBarAnimation\n\nThe Lock Controller Status Bar update animation.\n\n```\n.withStyle {\n  $0.UIStatusBarAnimation = .none\n}\n```\n\n### statusBarHidden\n\nThe Lock Controller Status Bar's visibility.\n\n```\n.withStyle {\n  $0.statusBarHidden = false\n}\n```\n\n### UIStatusBarStyle\n\nThe Lock Controller Status Bar style.\n\n```\n.withStyle {\n  $0.UIStatusBarStyle = .default\n}\n```\n\n### UISearchBarStyle\n\nThe Lock Passwordless Search Bar style.\n\n```\n.withStyle {\n  $0.UISearchBarStyle = .default\n}\n```\n\n## Other Style Options\n\n### textColor\n\nThe color for the text in the body.\n\n```\n.withStyle {\n  $0.textColor = UIColor.black\n}\n```\n\n### backgroundColor\n\nColor used as the Lock background color.\n\n```\n.withStyle {\n  $0.backgroundColor = UIColor.white\n}\n```\n\n### backgroundImage\n\nImage used as the Lock background\n\n```\n.withStyle {\n  $0.backgroundImage = LazyImage(name: \"company_logo\")\n}\n```\n\n### oauth2\n\nAny non-db OAuth2 connection can have styles customized by mapping a connection name with an `AuthStyle`\n\n```\n.withStyle {\n  $0.oauth2[\"slack\"] = AuthStyle(\n    name: \"Slack\",\n    color: UIColor(red: 0.4118, green: 0.8078, blue: 0.6588, alpha: 1.0),\n    withImage: LazyImage(name: \"ic_slack\")\n  )\n}\n```\n\n### seperatorTextColor\n\nSocial separator label color.\n\n```\n.withStyle {\n  $0.seperatorTextColor = UIColor(red: 0.0, green: 0.0, blue: 0.0, alpha: 0.54)\n}\n```\n\n### secondaryButtonColor\n\nThe color of secondary buttons.\n\n```\n.withStyle {\n  $0.secondaryButtonColor = UIColor.black\n}\n```\n\n### tabTextColor\n\nThe color of the text on the database login tab.\n\n```\n.withStyle {\n  $0.tabTextColor = UIColor(red: 0.3608, green: 0.4, blue: 0.4353, alpha: 0.6)\n}\n```\n\n### tabTintColor\n\nThe color of the tinting on the database login tab.\n\n```\n.withStyle {\n  $0.tabTintColor = UIColor(red: 0.3608, green: 0.4, blue: 0.4353, alpha: 0.6)\n}\n```",
  "title": "Lock.swift: Style Customization Options",
  "description": "Styling and customization options for the style of Lock.Swift",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/react/02-calling-an-api",
  "markdown": "# Auth0 React SDK Quickstarts: Call an API\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Single-Page App](https://auth0.com/docs/quickstart/spa)\n*   [React](https://auth0.com/docs/quickstart/spa/react)\n*   [Call an API](https://auth0.com/docs/quickstart/spa/react/02-calling-an-api)\n\nThis tutorial demonstrates how to make API calls to the Auth0 Management API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to integrate with my app\n\n15 minutes\n\n1.  [Set Up the Auth0 Service](#set-up-the-auth0-service)\n2.  [Get an Access Token](#get-an-access-token)\n\nOr\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: React 18\n\nThe focus of this guide is to show you how to configure the SDK to call APIs protected by OAuth 2. Instead of creating a demo API to test the client-server connection, you'll use the [Auth0 Management API](https://auth0.com/docs/api#management-api), which comes bundled with your Auth0 tenant. However, you can adapt this guide to work with any API that you are securing with Auth0.\n\n## Set Up the Auth0 Service\n\nThe `Auth0Provider` setup is similar to the one discussed in the [Configure the `Auth0Provider` component](https://auth0.com/docs/quickstart/spa/auth0-react#configure-the-auth0provider-component) section: you wrap your root component with `Auth0Provider` to which you pass the `domain` and `clientId` props. The values of these two props come from the [\"Settings\" values](https://auth0.com/docs/quickstart/spa/react#configure-auth0) of the single-page application you've registered with Auth0.\n\nHowever, your React application needs to pass an access token when it calls a target API to access private resources. You can [request an access token](https://auth0.com/docs/tokens/guides/get-access-tokens) in a format that the API can verify by passing the `audience` and `scope` props to `Auth0Provider` as follows:\n\n```\nimport React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport { Auth0Provider } from '@auth0/auth0-react';\nimport App from './App';\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(\n  <Auth0Provider\n    domain=\"{yourDomain}\"\n    clientId=\"{yourClientId}\"\n    authorizationParams={{\n      redirect_uri: window.location.origin,\n      audience: \"https://{yourDomain}/api/v2/\",\n      scope: \"read:current_user update:current_user_metadata\"\n    }}\n  >\n    <App />\n  </Auth0Provider>\n);\n```\n\nAuth0 uses the value of the `authorizationParams.audience` prop to determine which resource server (API) the user is authorizing your React application to access.\n\nThe actions that your React application can perform on the API depend on the [scopes](https://auth0.com/docs/scopes/current) that your access token contains, which you define as the value of `authorizationParams.scope`. Your React application will request authorization from the user to access the requested scopes, and the user will approve or deny the request.\n\n## Get an Access Token\n\nOnce you configure `Auth0Provider`, you can easily get the access token using the [`getAccessTokenSilently()`](https://auth0.github.io/auth0-react/interfaces/Auth0ContextInterface.html#getAccessTokenSilently) method from the [`useAuth0()`](https://auth0.github.io/auth0-react/functions/useAuth0.html) custom React Hook wherever you need it.\n\nTake this `Profile` component as an example:\n\n```\nimport React, { useEffect, useState } from \"react\";\nimport { useAuth0 } from \"@auth0/auth0-react\";\n\nconst Profile = () => {\n  const { user, isAuthenticated, getAccessTokenSilently } = useAuth0();\n  const [userMetadata, setUserMetadata] = useState(null);\n\n  return (\n    isAuthenticated && (\n      <div>\n        <img src={user.picture} alt={user.name} />\n        <h2>{user.name}</h2>\n        <p>{user.email}</p>\n        <h3>User Metadata</h3>\n        {userMetadata ? (\n          <pre>{JSON.stringify(userMetadata, null, 2)}</pre>\n        ) : (\n          \"No user metadata defined\"\n        )}\n      </div>\n    )\n  );\n};\n\nexport default Profile;\n```\n\nAs it is, `userMetadata` is always `null` in the `Profile` component. Add the following `useEffect()` hook to the component to fetch the user metadata from an API:\n\n```\nuseEffect(() => {\n  const getUserMetadata = async () => {\n    const domain = \"{yourDomain}\";\n\n    try {\n      const accessToken = await getAccessTokenSilently({\n        authorizationParams: {\n          audience: `https://${domain}/api/v2/`,\n          scope: \"read:current_user\",\n        },\n      });\n\n      const userDetailsByIdUrl = `https://${domain}/api/v2/users/${user.sub}`;\n\n      const metadataResponse = await fetch(userDetailsByIdUrl, {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n        },\n      });\n\n      const { user_metadata } = await metadataResponse.json();\n\n      setUserMetadata(user_metadata);\n    } catch (e) {\n      console.log(e.message);\n    }\n  };\n\n  getUserMetadata();\n}, [getAccessTokenSilently, user?.sub]);\n```\n\nYou use a React Effect Hook to call an asynchronous `getUserMetadata()` function. The function first calls `getAccessTokenSilently()`, which returns a Promise that resolves to an access token that you can use to make a call to a protected API.\n\nYou pass an object with the `authorizationParams.audience` and `authorizationParams.scope` properties as the argument of `getAccessTokenSilently()` to ensure that the access token you get is for the intended API and has the required permissions to access the desired endpoint.\n\nYou can then include the access token in the authorization header of the API call that you make. The API will take care of validating the access token and processing the request.\n\nUpon success, you extract the `user_metadata` property from the API response and use `setUserMetadata()` to make React aware of it.\n\n### Checkpoint\n\nYour application will show \"No user metadata defined\" if you have not set any `user_metadata` for the logged-in user. To further test out this integration, head to the [Users section of the Auth0 dashboard](https://manage.auth0.com/#/users) and click on the user who is logged in. Update the `user_metadata` section with a value like `{ \"theme\": \"dark\" }` and click \"Save\". Refresh your React application and verify that it reflects the new `user_metadata`.\n\nAs a final reminder, consult the [Auth0 API quickstarts](https://auth0.com/docs/quickstart/backend) to learn how to integrate Auth0 with your backend platform.",
  "title": "Auth0 React SDK Quickstarts: Call an API",
  "description": "This tutorial demonstrates how to make API calls to the Auth0 Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock-swift/lock-swift-configuration-options",
  "markdown": "# Lock.swift: Configuration Options\n\nThere are numerous options to configure Lock's behavior listed below. In addition, there are also quite a few options available to alter Lock's appearance and style in the [Style Customization Options](https://auth0.com/docs/libraries/lock-swift/lock-swift-customization) page.\n\n## Configuring Lock's behavior\n\nConfiguration options can be added to your Lock initialization using `withOptions`.\n\n```\nLock\n  .classic()\n  .withOptions {\n    $0.closable = true\n    $0.usernameStyle = [.Username]\n    $0.allow = [.Login, .ResetPassword]\n  }\n  .present(from: self)\n```\n\n## Behavior Options\n\n### closable\n\nAllows Lock to be dismissed by the user. By default this is `false`.\n\n```\n.withOptions {\n  $0.closable = true\n}\n```\n\n### scope\n\nScope used for authentication. By default is `openid`. It will return not only the **Access Token**, but also an **ID Token** which is a JSON Web Token (JWT) containing user information. See the documentation on [Scopes](https://auth0.com/docs/get-started/apis/scopes) for more information about authentication scopes.\n\n```\n.withOptions {\n  $0.scope = \"openid name email picture\"\n}\n```\n\n#### Refresh Tokens\n\nSpecifying the `offline_access` scope in your Lock options will allow a [Refresh Token](https://auth0.com/docs/secure/tokens/refresh-tokens) to be returned along with the access\\_token and the id\\_token. Refresh Tokens can be saved and used to acquire a new Access Token when the old one expires. For more information about using Refresh Tokens for Auth0 authentication, take a look at the reference documentation for the [Auth0.Swift SDK](https://auth0.com/docs/libraries/auth0-swift), which you would use to implement Refresh Tokens, or at the [Swift Quickstart Guide](https://auth0.com/docs/quickstart/native/ios-swift/03-user-sessions), which provides a comprehensive example of use of Auth0 in Swift development, including the management of Refresh Tokens.\n\n### termsOfService\n\nBy default Lock will use Auth0's [Terms of Service](https://auth0.com/terms) and [Privacy Policy](https://auth0.com/privacy), but other URLs can be filled in to link to other terms and policies.\n\n```\n.withOptions {\n  $0.termsOfService = \"https://mycompany.com/terms\"\n  $0.privacyPolicy = \"https://mycompany.com/privacy\"\n}\n```\n\n### Show Terms of Service\n\nDatabase connections display the Terms of Service dialog. Default is `true`. Note that the Terms of Service will always be shown if the `mustAcceptTerms` flag is enabled.\n\n```\n.withOptions {\n    $0.showTerms = true\n}\n```\n\n### Require users to accept the Terms of Service\n\nDatabase connection require explicit acceptance of the Terms of Service.\n\n```\n.withOptions {\n    $0.mustAcceptTerms = true\n}\n```\n\n## Web Authentication Options\n\n### leeway\n\nClock skew used for ID token validation. It expands the time window in which the ID token will still be considered valid, to account for the difference between server time and client time. By default is **60000 milliseconds** (60 seconds).\n\n```\n.withOptions {\n  $0.leeway = 30000 // 30 seconds\n}\n```\n\n### maxAge\n\nAllowable elapsed time (in milliseconds) since the user last authenticated. Used for ID token validation. If set, the ID token will contain an `auth_time` claim with the authentication timestamp. Defaults to `nil`.\n\n```\n.withOptions {\n  $0.maxAge = 86400000 // 1 day\n}\n```\n\n## Database options\n\n### allow\n\nWhich database screens will be accessible, the default is enable all screens such as `.Login, .Signup, .ResetPassword`.\n\n```\n.withOptions {\n  $0.allow = [.Login, .ResetPassword]\n}\n```\n\n### initialScreen\n\nThe first screen to present to the user. The default is `.Login`, other options include `.Signup` and `ResetPassword`.\n\n```\n.withOptions {\n  $0.initialScreen = .Login\n}\n```\n\n### usernameStyle\n\nSpecify the type of identifier the login will require. The default is either: `[.Username, .Email]`, but it can also accept `[.Username]` or `[.Email]`. However it's important to note that this option is only active if you have set the `requires_username` flag to `true` in your [Auth0 Dashboard](https://manage.auth0.com/#/).\n\n```\n.withOptions {\n  $0.usernameStyle = [.Username]\n}\n```\n\n#### Custom Signup Fields\n\nWhen signing up the default information requirements are the user's email and password. You can expand your data capture requirements as needed. Capturing additional signup fields here will store them in the `user_metadata`, which you can read more about in [Metadata](https://auth0.com/docs/manage-users/user-accounts/metadata). Note that you must specify the icon to use with your custom text field.\n\n```\n.withOptions {\n  $0.customSignupFields = [\n    CustomTextField(name: \"first\\_name\", placeholder: \"First Name\", icon: LazyImage(name: \"ic_person\", bundle: Lock.bundle)),\n    CustomTextField(name: \"last\\_name\", placeholder: \"Last Name\", icon: LazyImage(name: \"ic_person\", bundle: Lock.bundle))\n  ]\n}\n```\n\nYou can also specify icons from other bundles, such as in the following example: CustomTextField(name: \"slack\\_handle\", placeholder: \"Slack Handle\", icon: LazyImage(name: \"ic\\_slack\", bundle: Bundle(identifier: \"CustomBundle\")))\n\n## Enterprise Options\n\nThere are also configuration options specific to Enterprise connections:\n\n### enterpriseConnectionUsingActiveAuth\n\nBy default Enterprise connections will use Web Authentication. However, you can specify which connections will alternatively use credential authentication and prompt for a username and password.\n\n```\n.withOptions {\n  $0.enterpriseConnectionUsingActiveAuth = [\"enterprisedomain.com\"]\n}\n```\n\n### activeDirectoryEmailAsUsername\n\nWhen in credential authentication mode, should the user require their email as an identifier? The default is `false`, and instead requires a username.\n\n```\n.withOptions {\n  $0.activeDirectoryEmailAsUsername = true\n}\n```\n\n## Logging Options\n\nLock provides options to easily turn on and off logging capabilities, as well as adjust other logging related settings.\n\n### logLevel\n\nBy default this is `.off`, Syslog logging levels are supported.\n\n```\n.withOptions {\n  $0.logLevel = .all\n}\n```\n\n### logHttpRequest\n\nWhether or not to log Auth0.swift API requests. By default this is `false`.\n\n```\n.withOptions {\n  $0.logHttpRequest = true\n}\n```\n\n### loggerOutput\n\nSpecify logger output handler, by default this uses the `print` statement.\n\n```\n.withOptions {\n  $0.loggerOutput = CleanroomLockLogger()\n}\n```\n\nIn the code above, the loggerOutput has been set to use [CleanroomLogger](https://github.com/emaloney/CleanroomLogger). This can typically be achieved by implementing the loggerOutput protocol. You can of course use your favorite logger library. Below is an example of usage handling logger output with CleanroomLogger.\n\n```\nclass CleanroomLockLogger: LoggerOutput {\n  func message(_ message: String, level: LoggerLevel, filename: String, line: Int) {\n    let channel: LogChannel?\n    switch level {\n    case .debug:\n        channel = Log.debug\n    case .error:\n        channel = Log.error\n    case .info:\n        channel = Log.info\n    case .verbose:\n        channel = Log.verbose\n    case .warn:\n        channel = Log.warning\n    default:\n        channel = nil\n    }\n    channel?.message(message, filePath: filename, fileLine: line)\n  }\n}\n```",
  "title": "Lock.swift: Configuration Options",
  "description": "Behavior configuration options available with Lock.Swift",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/internationalization-and-localization/lock-swift-internationalization",
  "markdown": "# Lock.swift Internationalization\n\nBy default, **Lock v2 for iOS** displays all text in English. If you wish to display text in another language, or you wish to alter the text values for your application, you may provide a `Lock.strings` file and define values to be used for the various text items that Lock might display.\n\nMore information about how to handle languages can be found in the official Apple documentation on [Internationalization and Localization](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPInternational/Introduction/Introduction.html#//apple_ref/doc/uid/10000171i-CH1-SW1)\n\n## Lock String Values\n\nFor a full list of the terms used by Lock, see the base [Lock.strings](https://raw.githubusercontent.com/auth0/Lock.swift/master/Lock/Base.lproj/Lock.strings) file in the Lock.swift repository.\n\n### Providing alternative English strings\n\nIf you want to change some or all of the existing terms, you can do this by downloading and adding the [Lock.strings](https://raw.githubusercontent.com/auth0/Lock.swift/master/Lock/Base.lproj/Lock.strings) file to your project.\n\nSelect the **Lock.strings** file and in the `File inspector` click on `Localize...`\n\n![Lock.swift: Localize](https://images.ctfassets.net/cdy7uua7fh8z/2dL3QXXrURBjNjyF5R0xYG/68cf0217f351bfb5e5a0bf45a7361b03/xcode_localize.png)\n\nThen select `English`:\n\n![Lock.swift: Localize English](https://images.ctfassets.net/cdy7uua7fh8z/2dffBsE133pnk0Y7Y0nxHU/8b82700bbd844d5df0864287b7a0acdf/xcode_localize_english.png)\n\nNow lets take a couple of terms in **Lock.strings** and update them with alternative text:\n\n`// Forgot password \"com.auth0.lock.database.button.forgot_password\" = \"Did you forget your password?\"; // tos & privacy \"com.auth0.lock.database.button.tos\" = \"Signing up is an indication of your agreement to our terms of\\n service and privacy policy\";`\n\n### Supporting other languages\n\nTo add another language you first of all need to add the new language under `Project/Info`\n\n![Lock.swift: Add language](https://images.ctfassets.net/cdy7uua7fh8z/3mHt6UmbEq7Xl05OZqtF70/20055f0037971f7b8c921d5902559b93/xcode_add_language.png)\n\nAdd the new language and ensure that **Lock.strings** is selected\n\n![Lock.swift: Add Language step 2](https://images.ctfassets.net/cdy7uua7fh8z/6E7BZaCVtkHcCQFhEcgSTq/3314eb8142c03266b25ab84fbefbb8f6/xcode_add_language_step_2.png)\n\nYou will notice under **Lock.strings** a new file has been created for your specified language, based upon the **Reference Language** selection.\n\nNow you are ready to translate to your desired language.\n\n### Notes\n\nSome terms use parameters and it's important to note their placement in your translation. In particular multiple parameter terms such as:\n\n`// No more than %@{count} identical characters in a row (such as, \\\"%@{identical sample}\\\" not allowed) \"com.auth0.lock.error.password.no_more_identical\" = \"No more than %1$d identical characters in a row (such as, \\\"%2$@\\\" not allowed)\";`",
  "title": "Lock.swift Internationalization",
  "description": "Internationalization support in Lock.Swift",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/spa/vuejs/02-calling-an-api",
  "markdown": "# Auth0 Vue SDK Quickstarts: Calling an API\n\nThis quickstart demonstrates how to make calls to an external API from a Vue.JS application using Auth0. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to integrate with my app\n\n15 minutes\n\n1.  [Create an API](#create-an-api)\n2.  [Configuring the plugin](#configuring-the-plugin)\n3.  [Retrieving an Access Token](#retrieving-an-access-token)\n4.  [Calling an API](#calling-an-api)\n\nOr\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Vue 3+\n\n## Create an API\n\nIn the [APIs section](https://manage.auth0.com/#/apis) of the Auth0 dashboard, click **Create API**. Provide a name and an identifier for your API. You will use the identifier later when you're configuring your Javascript Auth0 application instance. For **Signing Algorithm**, select **RS256**.\n\n![Create API](https://auth0.com/docs/media/articles/api-auth/create-api.png)\n\n## Configuring the plugin\n\nTo call an API, configure the plugin by setting the `audience` to the **API Identifier** of the API you want to call:\n\n```\nimport { createAuth0 } from '@auth0/auth0-vue';\n\nconst app = createApp(App);\n\napp.use(\n  createAuth0({\n    domain: \"{yourDomain}\",\n    clientId: \"{yourClientId}\",\n    authorizationParams: {\n      redirect_uri: window.location.origin,\n      audience: \"{yourApiIdentifier}\",\n    }\n  })\n);\n\napp.mount('#app');\n```\n\n## Retrieving an Access Token\n\nWith the plugin configured using an `audience`, Auth0 will return an Access Token that can be sent to your API. You can retrieve an Access Token by using the `getAccessTokenSilently` function thats exposed by our SDK.\n\n```\n<script>\n  import { useAuth0 } from '@auth0/auth0-vue';\n\n  export default {\n    setup() {\n      const { getAccessTokenSilently } = useAuth0();\n\n      return {\n        doSomethingWithToken: async () => {\n          const token = await getAccessTokenSilently();\n        }\n      };\n    }\n  };\n</script>\n```\n\n### Using the Options API\n\nIf you are using the Options API, you can use the same `getAccessTokenSilently` method from the global `$auth0` property through the `this` accessor.\n\n```\n<script>\n  export default {\n    methods: {\n      async doSomethingWithToken() {\n        const token = await this.$auth0.getAccessTokenSilently();\n      }\n    }\n  };\n</script>\n```\n\n## Calling an API\n\nTo call an API, include the token in the `Authorization` header of your request. There are many ways to make HTTP calls with Vue. Here is an example using the `fetch` API with Vue's Composition API:\n\n```\n<script>\n  import { useAuth0 } from '@auth0/auth0-vue';\n\n  export default {\n    setup() {\n      const { getAccessTokenSilently } = useAuth0();\n\n      return {\n        doSomethingWithToken: async () => {\n          const token = await getAccessTokenSilently();\n          const response = await fetch('https://api.example.com/posts', {\n            headers: {\n              Authorization: 'Bearer ' + token\n            }\n          });\n          const data = await response.json();\n        }\n      };\n    }\n  };\n</script>\n```",
  "title": "Auth0 Vue SDK Quickstarts: Calling an API",
  "description": "This quickstart demonstrates how to make calls to an external API from a Vue.JS application using Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/libraries/lock-swift/lock-swift-custom-fields-at-signup",
  "markdown": "# Lock.swift: Custom Fields at Signup\n\n**Lock v2 for iOS** allows you to specify additional fields that the user must complete before creating a new account. The extra fields will be shown after the basic fields (email, username, password).\n\n## Adding custom fields\n\nWhen signing up the default information requirements are the user's email and password. You can expand your data capture requirements as needed. Capturing additional signup fields here will store them in the `user_metadata`, which you can read more about in [Metadata](https://auth0.com/docs/manage-users/user-accounts/metadata).\n\n```\n.withOptions {\n  $0.customSignupFields = [\n    CustomTextField(name: \"first\\_name\", placeholder: \"First Name\", icon: LazyImage(name: \"ic_person\", bundle: Lock.bundle)),\n    CustomTextField(name: \"last\\_name\", placeholder: \"Last Name\", icon: LazyImage(name: \"ic_person\", bundle: Lock.bundle))\n  ]\n}\n```\n\nYou must specify the icon to use with your custom text field.\n\nThat's it! If you have enabled users Sign Up in the Application's Dashboard, after they complete the basic fields (email/username, password) and hit Submit, they will be prompted to fill the remaining fields. The user must fill all of the custom fields before being able to complete signup.\n\nWhen requesting a user Sign Up or Sign In, the extra fields will be attached to the `user_metadata` attribute in the request body. You can access them by querying the user profile at any time, even from the Dashboard in the User's section.",
  "title": "Lock.swift: Custom Fields at Signup",
  "description": "Adding additional fields to signups with Lock.Swift",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/webapp/rails/02-troubleshooting",
  "markdown": "# Auth0 Ruby On Rails SDK Quickstarts: Troubleshooting\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Regular Web App](https://auth0.com/docs/quickstart/webapp)\n*   [Ruby On Rails](https://auth0.com/docs/quickstart/webapp/rails)\n*   [Troubleshooting](https://auth0.com/docs/quickstart/webapp/rails/02-troubleshooting)\n\nTroubleshooting tips for using Rails with Auth0. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n### I want to explore a sample app\n\n2 minutes\n\nGet a sample configured with your account settings or check it out on Github.\n\nSystem requirements: Ruby 2.5.0+ | Rails 6.0+ or Rails 5.0+ or Rails 4.2+\n\n## Troubleshooting\n\nThe following are troubleshooting topics that you might run into when using the Rails quickstart.\n\n## Using a reverse proxy\n\nThe `redirect_uri` parameter that OmniAuth generates when redirecting to login is based on the `Host` header that is passed to Rails. This can cause incorrect callback URLs to be passed when using this strategy (and OmniAuth in general) with a reverse proxy. You can adjust the host used by OmniAuth with the following snippet:\n\n```\nOmniAuth.config.full_host = lambda do |env|\n    scheme         = env['rack.url_scheme']\n    local_host     = env['HTTP_HOST']\n    forwarded_host = env['HTTP_X_FORWARDED_HOST']\n    forwarded_host.blank? ? \"#{scheme}://#{local_host}\" : \"#{scheme}://#{forwarded_host}\"\nend\n```\n\n[See this StackOverflow thread for more information](https://stackoverflow.com/a/7135029/728480).\n\n## ActionController::InvalidAuthenticityToken\n\nThis is likely caused by a missing CSRF token needed to POST the login request. If you inspect the login button in your browser, you should see something like this:\n\n```\n<a data-method=\"post\" href=\"auth/auth0\">Login</a>\n```\n\n... and in the `<head>` element for the page, you should have CSRF meta tags like these:\n\n```\n<meta name=\"csrf-param\" content=\"authenticity_token\">\n<meta name=\"csrf-token\" content=\"UY2XpKwxzwBWalxFVJ8yKsao/33it7If09BnZewpHifVPSpFJd2LrA7xgQn6VQrhZNGjgZoLI3kV+bkQHtr+Rw==\">\n```\n\nWith those elements in place, Rails will convert the login link to POST the CSRF token to the backend to verify it before redirecting to login.\n\n## ActionDispatch::Cookies::CookieOverflow\n\nThis error means that a cookie session is being used and because the whole profile is being stored, it overflows the max-size of 4 kb. If you are unable to access the user profile, or you get an error similar to `NoMethodError`, `undefined method '[]' for nil:NilClass`, try using In-Memory store for development.\n\nGo to `/config/initializers/session_store.rb` (or create it if it does not exist) and add the following:\n\n```\nRails.application.config.session_store :cache_store\n```\n\nGo to `/config/environments/development.rb` and add the following:\n\n```\nconfig.cache_store = :memory_store\n```\n\nRestart your Rails server for these changes to take effect.\n\n## SSL Issues\n\nUnder some configurations, Ruby may not be able to find certification authority certificates (CA certs).\n\nDownload the CA certs bundle to the project directory:\n\n```\ncurl -L -o lib/ca-bundle.crt http://curl.haxx.se/ca/ca-bundle.crt\n```\n\nAdd this initializer to `config/initializers/fix_ssl.rb`:\n\n```\n# config/initializers/fix_ssl.rb\n\nrequire 'open-uri'\nrequire 'net/https'\n\nmodule Net\n  class HTTP\n    alias_method :original_use_ssl=, :use_ssl=\n\n    def use_ssl=(flag)\n      path = ( Rails.env == \"development\") ? \"lib/ca-bundle.crt\" : \"/usr/lib/ssl/certs/ca-certificates.crt\"\n      self.ca_file = Rails.root.join(path).to_s\n      self.verify_mode = OpenSSL::SSL::VERIFY_PEER\n      self.original_use_ssl = flag\n    end\n  end\nend\n```\n\n## \"failure message=invalid\\_credentials\"\n\nThis issue doesn't occur when working locally but may happen in a staging or production environment. The error message may be displayed as:\n\n```\nomniauth: (auth0) Authentication failure! invalid_credentials: OAuth2::Error, server_error: The redirect URI is wrong. You send [wrong url], and we expected [callback url set in your app settings]\n```\n\nTo solve this, add the following to `config/environments/staging.rb` or `production.rb`:\n\n```\nOmniAuth.config.full_host = \"http://www.example.com\"\n```\n\nSubstitute `http://www.example.com` with the actual URL you'll be using in your application.",
  "title": "Auth0 Ruby On Rails SDK Quickstarts: Troubleshooting",
  "description": "Troubleshooting tips for using Rails with Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/users/normalized-user-profiles",
  "markdown": "# Normalized User Profiles\n\nThe normalized user profile is an Auth0-specific way of standardizing and storing user-related information. Because every Identity Provider (IdP) provides a different set of information about a user, Auth0 normalizes common profile properties into a protocol-agnostic representation of the user when storing user-related claims. For example, `family_name` in the normalized user profile contains details that may be returned to an IdP as `surname` or `last_name`.\n\nAs such, the Auth0 claims included in the normalized user profile differ from the standard set of claims that can be returned in ID Tokens from the [Authentication API's `oauth/token` endpoint](https://auth0.com/docs/api/authentication#get-token) or in the response from the [`/userinfo`](https://auth0.com/docs/api/authentication#user-profile) endpoint (both of which follow the requirements detailed in the OIDC specification).\n\nTo learn about the attributes included in the normalized user profile and understand how you can work with them, read [User Profile Structure](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure).\n\n## Learn more\n\n*   [Sample User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles/sample-user-profiles)\n*   [User Profile Root Attributes](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes)\n*   [User Data Storage](https://auth0.com/docs/secure/security-guidance/data-security/user-data-storage)\n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)",
  "title": "Normalized User Profiles",
  "description": "Understand how Auth0 normalizes common user properties in the user profile.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/golang/02-using",
  "markdown": "# Auth0 Go API SDK Quickstarts: Using your API\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [Go API](https://auth0.com/docs/quickstart/backend/golang)\n*   [Using your API](https://auth0.com/docs/quickstart/backend/golang/02-using)\n\nThis tutorial will show you how to use your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Calling the API From Your Application\n\nYou can call the API from your application by passing an Access Token in the `Authorization` header of your HTTP request as a Bearer token.\n\n*   [cURL](#af7e83e419604fb08703df91e2dd3353_shell)\n*   [C#](#af7e83e419604fb08703df91e2dd3353_csharp)\n*   [Go](#af7e83e419604fb08703df91e2dd3353_go)\n*   [Java](#af7e83e419604fb08703df91e2dd3353_java)\n*   [Node.JS](#af7e83e419604fb08703df91e2dd3353_node)\n*   [Obj-C](#af7e83e419604fb08703df91e2dd3353_objc)\n*   [...](#)\n    *   [PHP](#af7e83e419604fb08703df91e2dd3353_php)\n    *   [Python](#af7e83e419604fb08703df91e2dd3353_python)\n    *   [Ruby](#af7e83e419604fb08703df91e2dd3353_ruby)\n    *   [Swift](#af7e83e419604fb08703df91e2dd3353_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Obtaining an Access Token\n\nIf you are calling the API from a Single-Page Application or a Mobile/Native application, after the authorization flow is completed, you will get an Access Token. How you get the token and how you make the call to the API will be dependent on the type of application you are developing and the framework you are using. For more information refer to the relevant application Quickstarts which contain detailed instructions:\n\n*   [Single-Page Applications](https://auth0.com/docs/quickstart/spa)\n*   [Mobile / Native Application](https://auth0.com/docs/quickstart/native)\n\nIf you are calling the API from a command-line tool or another service, where there isn't a user entering their credentials, you need to use the [OAuth Client Credentials flow](https://auth0.com/docs/api/authentication#client-credentials). To do that, register a [Machine to Machine Application](https://manage.auth0.com/#/applications), and then subsequently use the **Client ID** and **Client Secret** of this application when making the request below and pass those along in the `client_id` and `client_secret` parameters respectively. Also include the Audience for the API you want to call.\n\n*   [cURL](#330680a49474411f9ac0edfb9277a923_shell)\n*   [C#](#330680a49474411f9ac0edfb9277a923_csharp)\n*   [Go](#330680a49474411f9ac0edfb9277a923_go)\n*   [Java](#330680a49474411f9ac0edfb9277a923_java)\n*   [Node.JS](#330680a49474411f9ac0edfb9277a923_node)\n*   [Obj-C](#330680a49474411f9ac0edfb9277a923_objc)\n*   [...](#)\n    *   [PHP](#330680a49474411f9ac0edfb9277a923_php)\n    *   [Python](#330680a49474411f9ac0edfb9277a923_python)\n    *   [Ruby](#330680a49474411f9ac0edfb9277a923_ruby)\n    *   [Swift](#330680a49474411f9ac0edfb9277a923_swift)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data 'client_id={yourClientId}' \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data audience=YOUR_API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: 'YOUR_API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=YOUR_API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=YOUR_API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nFor testing purposes, you can also get an Access Token from the **Test** tab in your [API settings](https://manage.auth0.com/#/apis).\n\n## Test Your API\n\n**1\\. Calling the secure endpoint**\n\nYou can make a request to the `/api/private` endpoint without passing any Access Token:\n\n*   [cURL](#5cdd278e85844ed381e93b7209470434_shell)\n*   [C#](#5cdd278e85844ed381e93b7209470434_csharp)\n*   [Go](#5cdd278e85844ed381e93b7209470434_go)\n*   [Java](#5cdd278e85844ed381e93b7209470434_java)\n*   [Node.JS](#5cdd278e85844ed381e93b7209470434_node)\n*   [Obj-C](#5cdd278e85844ed381e93b7209470434_objc)\n*   [...](#)\n    *   [PHP](#5cdd278e85844ed381e93b7209470434_php)\n    *   [Python](#5cdd278e85844ed381e93b7209470434_python)\n    *   [Ruby](#5cdd278e85844ed381e93b7209470434_ruby)\n    *   [Swift](#5cdd278e85844ed381e93b7209470434_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {method: 'GET', url: 'http://localhost:3010/api/private'};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nconn.request(\"GET\", \"/api/private\")\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe API will return a 401 HTTP (Unauthorized) status code:\n\n![Response for unauthorized API request](https://auth0.com/docs/media/articles/server-apis/using/private-unauthorized.png)\n\nOnce again, make the same request but this time pass along the Access Token as a Bearer token in the **Authorization** header of the request:\n\n*   [cURL](#fdbc2f7592ae4337ac80160a7d9c398e_shell)\n*   [C#](#fdbc2f7592ae4337ac80160a7d9c398e_csharp)\n*   [Go](#fdbc2f7592ae4337ac80160a7d9c398e_go)\n*   [Java](#fdbc2f7592ae4337ac80160a7d9c398e_java)\n*   [Node.JS](#fdbc2f7592ae4337ac80160a7d9c398e_node)\n*   [Obj-C](#fdbc2f7592ae4337ac80160a7d9c398e_objc)\n*   [...](#)\n    *   [PHP](#fdbc2f7592ae4337ac80160a7d9c398e_php)\n    *   [Python](#fdbc2f7592ae4337ac80160a7d9c398e_python)\n    *   [Ruby](#fdbc2f7592ae4337ac80160a7d9c398e_ruby)\n    *   [Swift](#fdbc2f7592ae4337ac80160a7d9c398e_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThis time the API will return a successful response:\n\n![Response for authorized API request](https://auth0.com/docs/media/articles/server-apis/using/private.png)\n\n**2\\. Testing the scoped endpoint**\n\nTo test the endpoint that requires a scope, pass the Access Token containing the correct scope as a Bearer token in the Authorization header:\n\n*   [cURL](#ef016eff7f9c4a50a0c360c16969e8ed_shell)\n*   [C#](#ef016eff7f9c4a50a0c360c16969e8ed_csharp)\n*   [Go](#ef016eff7f9c4a50a0c360c16969e8ed_go)\n*   [Java](#ef016eff7f9c4a50a0c360c16969e8ed_java)\n*   [Node.JS](#ef016eff7f9c4a50a0c360c16969e8ed_node)\n*   [Obj-C](#ef016eff7f9c4a50a0c360c16969e8ed_objc)\n*   [...](#)\n    *   [PHP](#ef016eff7f9c4a50a0c360c16969e8ed_php)\n    *   [Python](#ef016eff7f9c4a50a0c360c16969e8ed_python)\n    *   [Ruby](#ef016eff7f9c4a50a0c360c16969e8ed_ruby)\n    *   [Swift](#ef016eff7f9c4a50a0c360c16969e8ed_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private-scoped \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private-scoped\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private-scoped\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private-scoped\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private-scoped',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private-scoped\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private-scoped\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private-scoped\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private-scoped\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private-scoped\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the required scope is present, the API call is successful:\n\n![Response for scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped.png)\n\nIf the required scope is not present, the API returns a 403 HTTP Status (Forbidden):\n\n![Response for forbidden scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped-forbidden.png)",
  "title": "Auth0 Go API SDK Quickstarts: Using your API",
  "description": "This tutorial will show you how to use your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/golang/03-troubleshooting",
  "markdown": "# Auth0 Go API SDK Quickstarts: Troubleshooting\n\nThis document will help you troubleshoot your configuration if you get unexpected responses from your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nIf you configured JWT validation correctly, you will be able to get proper responses from your API when you make requests. However, in the case where you get a 401 (Unauthorized) response from your API, it is because the configuration of your JWT middleware does not match with the JWT which was passed.\n\nThis document will help you troubleshoot your JWT middleware configuration.\n\n## How Does a Token Get Validated?\n\nIn terms of validating a JWT, there are various things to consider:\n\n1.  **Is the token well-formed?** In other words, is this token conforming to the structure of a JSON Web Token (JWT)? To get more information on the structure of a JWT, please refer to [this section on the structure of a JWT](https://auth0.com/docs/jwt#what-is-the-json-web-token-structure-)\n    \n2.  **Has the token been tampered with?** The last part of a JWT is the signature. The signature is used to verify that the token was in fact signed by the sender and not altered in any way.\n    \n3.  **Has the token been received in its validity period?** JWTs are only valid for a specified time period (as expressed in the `exp` claim).\n    \n4.  **Is the token coming from the intended Authority?** This consists of 2 parts\n    \n    *   **Signature Verification**: Can we confirm that the JWT is correctly signed using the key issued by the issuing authority?\n        \n    *   **Issuer Value**: The Issuer is defined in the `iss` claim. Once again does this claim match up with what your application expects?\n        \n5.  **Is the token intended for the current application?** So does the `aud` claim of the JWT match with what your application is expecting?\n    \n\n## Inspecting a Token\n\nA quick way to inspect a JWT is by using the [JWT.io](https://jwt.io/) website. It has a handy debugger which allows you to quickly check that a JWT is well-formed, and also inspect the values of the various claims.\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-rs256.png)\n\nIn the screenshot above you can see that the token was signed using the **RS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://rs256.test.api**.\n\nSo, in other words, these values in your JWT validation configuration registration must match **exactly** - including the trailing slash for the Issuer, such as\n\n```\naudience = \"https://rs256.test.api\",\ndomain = \"https://jerrie.auth0.com/\"\n};\n```\n\nFor a token signed using HS256, the debugger view will look a little different:\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-hs256.png)\n\nIn the screenshot above you can see that the token was signed using the **HS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://hs256.test.api**.",
  "title": "Auth0 Go API SDK Quickstarts: Troubleshooting",
  "description": "This document will help you troubleshoot your configuration if you get unexpected responses from your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/tokens/concepts/jwks",
  "markdown": "# JSON Web Key Sets\n\nThe JSON Web Key Set (JWKS) is a set of keys containing the public keys used to verify any JSON Web Token (JWT) issued by the Authorization Server and signed using the RS256 [signing algorithm](https://auth0.com/docs/get-started/applications/signing-algorithms).\n\nWhen creating applications and APIs in Auth0, two algorithms are supported for signing JWTs: **RS256** and **HS256**. RS256 generates an asymmetric signature, which means a private key must be used to sign the JWT and a different public key must be used to verify the signature.\n\nAuth0 uses the [JSON Web Key (JWK) specification](https://tools.ietf.org/html/rfc7517) to represent the cryptographic keys used for signing RS256 tokens. This specification defines two high-level data structures: **JSON Web Key (JWK)** and **JSON Web Key Set (JWKS)**. Here are the definitions from the specification:\n\n| Item | Description |\n| --- | --- |\n| **JSON Web Key (JWK)** | A JSON object that represents a cryptographic key. The members of the object represent properties of the key, including its value. |\n| **JSON Web Key Set (JWKS)** | A JSON object that represents a set of JWKs. The JSON object MUST have a `keys` member, which is an array of JWKs. |\n\nAuth0 exposes a JWKS endpoint for each tenant, which is found at `https://{yourDomain}/.well-known/jwks.json`. This endpoint will contain the JWK used to verify all Auth0-issued JWTs for this tenant.\n\n## Learn more\n\n*   [Signing Keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys)\n*   [JSON Web Key Set Properties](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-set-properties)\n*   [Locate JSON Web Key Sets](https://auth0.com/docs/secure/tokens/json-web-tokens/locate-json-web-key-sets)\n*   [View Signing Certificates](https://auth0.com/docs/get-started/tenant-settings/signing-keys/view-signing-certificates)",
  "title": "JSON Web Key Sets",
  "description": "A JSON Web Key set is a JSON object which represents a set of JSON Web Keys (a JSON object that represents a cryptographic key).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/rails/03-troubleshooting",
  "markdown": "# Auth0 Ruby On Rails API SDK Quickstarts: Troubleshooting\n\nThis document will help you troubleshoot your configuration if you get unexpected responses from your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nIf you configured JWT validation correctly, you will be able to get proper responses from your API when you make requests. However, in the case where you get a 401 (Unauthorized) response from your API, it is because the configuration of your JWT middleware does not match with the JWT which was passed.\n\nThis document will help you troubleshoot your JWT middleware configuration.\n\n## How Does a Token Get Validated?\n\nIn terms of validating a JWT, there are various things to consider:\n\n1.  **Is the token well-formed?** In other words, is this token conforming to the structure of a JSON Web Token (JWT)? To get more information on the structure of a JWT, please refer to [this section on the structure of a JWT](https://auth0.com/docs/jwt#what-is-the-json-web-token-structure-)\n    \n2.  **Has the token been tampered with?** The last part of a JWT is the signature. The signature is used to verify that the token was in fact signed by the sender and not altered in any way.\n    \n3.  **Has the token been received in its validity period?** JWTs are only valid for a specified time period (as expressed in the `exp` claim).\n    \n4.  **Is the token coming from the intended Authority?** This consists of 2 parts\n    \n    *   **Signature Verification**: Can we confirm that the JWT is correctly signed using the key issued by the issuing authority?\n        \n    *   **Issuer Value**: The Issuer is defined in the `iss` claim. Once again does this claim match up with what your application expects?\n        \n5.  **Is the token intended for the current application?** So does the `aud` claim of the JWT match with what your application is expecting?\n    \n\n## Inspecting a Token\n\nA quick way to inspect a JWT is by using the [JWT.io](https://jwt.io/) website. It has a handy debugger which allows you to quickly check that a JWT is well-formed, and also inspect the values of the various claims.\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-rs256.png)\n\nIn the screenshot above you can see that the token was signed using the **RS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://rs256.test.api**.\n\nSo, in other words, these values in your JWT validation configuration registration must match **exactly** - including the trailing slash for the Issuer, such as\n\n```\naudience = \"https://rs256.test.api\",\ndomain = \"https://jerrie.auth0.com/\"\n};\n```\n\nFor a token signed using HS256, the debugger view will look a little different:\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-hs256.png)\n\nIn the screenshot above you can see that the token was signed using the **HS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://hs256.test.api**.",
  "title": "Auth0 Ruby On Rails API SDK Quickstarts: Troubleshooting",
  "description": "This document will help you troubleshoot your configuration if you get unexpected responses from your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/nodejs/02-using",
  "markdown": "# Auth0 Node (Express) API SDK Quickstarts: Using your API\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [Node (Express) API](https://auth0.com/docs/quickstart/backend/nodejs)\n*   [Using your API](https://auth0.com/docs/quickstart/backend/nodejs/02-using)\n\nThis tutorial will show you how to use your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Calling the API From Your Application\n\nYou can call the API from your application by passing an Access Token in the `Authorization` header of your HTTP request as a Bearer token.\n\n*   [cURL](#8a9c3422a69a4ca28a1a180d7af17d29_shell)\n*   [C#](#8a9c3422a69a4ca28a1a180d7af17d29_csharp)\n*   [Go](#8a9c3422a69a4ca28a1a180d7af17d29_go)\n*   [Java](#8a9c3422a69a4ca28a1a180d7af17d29_java)\n*   [Node.JS](#8a9c3422a69a4ca28a1a180d7af17d29_node)\n*   [Obj-C](#8a9c3422a69a4ca28a1a180d7af17d29_objc)\n*   [...](#)\n    *   [PHP](#8a9c3422a69a4ca28a1a180d7af17d29_php)\n    *   [Python](#8a9c3422a69a4ca28a1a180d7af17d29_python)\n    *   [Ruby](#8a9c3422a69a4ca28a1a180d7af17d29_ruby)\n    *   [Swift](#8a9c3422a69a4ca28a1a180d7af17d29_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Obtaining an Access Token\n\nIf you are calling the API from a Single-Page Application or a Mobile/Native application, after the authorization flow is completed, you will get an Access Token. How you get the token and how you make the call to the API will be dependent on the type of application you are developing and the framework you are using. For more information refer to the relevant application Quickstarts which contain detailed instructions:\n\n*   [Single-Page Applications](https://auth0.com/docs/quickstart/spa)\n*   [Mobile / Native Application](https://auth0.com/docs/quickstart/native)\n\nIf you are calling the API from a command-line tool or another service, where there isn't a user entering their credentials, you need to use the [OAuth Client Credentials flow](https://auth0.com/docs/api/authentication#client-credentials). To do that, register a [Machine to Machine Application](https://manage.auth0.com/#/applications), and then subsequently use the **Client ID** and **Client Secret** of this application when making the request below and pass those along in the `client_id` and `client_secret` parameters respectively. Also include the Audience for the API you want to call.\n\n*   [cURL](#b662559bd8bd4aafbce436a0ec539581_shell)\n*   [C#](#b662559bd8bd4aafbce436a0ec539581_csharp)\n*   [Go](#b662559bd8bd4aafbce436a0ec539581_go)\n*   [Java](#b662559bd8bd4aafbce436a0ec539581_java)\n*   [Node.JS](#b662559bd8bd4aafbce436a0ec539581_node)\n*   [Obj-C](#b662559bd8bd4aafbce436a0ec539581_objc)\n*   [...](#)\n    *   [PHP](#b662559bd8bd4aafbce436a0ec539581_php)\n    *   [Python](#b662559bd8bd4aafbce436a0ec539581_python)\n    *   [Ruby](#b662559bd8bd4aafbce436a0ec539581_ruby)\n    *   [Swift](#b662559bd8bd4aafbce436a0ec539581_swift)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data 'client_id={yourClientId}' \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data audience=YOUR_API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: 'YOUR_API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=YOUR_API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=YOUR_API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nFor testing purposes, you can also get an Access Token from the **Test** tab in your [API settings](https://manage.auth0.com/#/apis).\n\n## Test Your API\n\n**1\\. Calling the secure endpoint**\n\nYou can make a request to the `/api/private` endpoint without passing any Access Token:\n\n*   [cURL](#fd453beaaa8b414587d222e5faa1b91d_shell)\n*   [C#](#fd453beaaa8b414587d222e5faa1b91d_csharp)\n*   [Go](#fd453beaaa8b414587d222e5faa1b91d_go)\n*   [Java](#fd453beaaa8b414587d222e5faa1b91d_java)\n*   [Node.JS](#fd453beaaa8b414587d222e5faa1b91d_node)\n*   [Obj-C](#fd453beaaa8b414587d222e5faa1b91d_objc)\n*   [...](#)\n    *   [PHP](#fd453beaaa8b414587d222e5faa1b91d_php)\n    *   [Python](#fd453beaaa8b414587d222e5faa1b91d_python)\n    *   [Ruby](#fd453beaaa8b414587d222e5faa1b91d_ruby)\n    *   [Swift](#fd453beaaa8b414587d222e5faa1b91d_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {method: 'GET', url: 'http://localhost:3010/api/private'};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nconn.request(\"GET\", \"/api/private\")\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe API will return a 401 HTTP (Unauthorized) status code:\n\n![Response for unauthorized API request](https://auth0.com/docs/media/articles/server-apis/using/private-unauthorized.png)\n\nOnce again, make the same request but this time pass along the Access Token as a Bearer token in the **Authorization** header of the request:\n\n*   [cURL](#f5407a0138ef49ea98a3b776555e8ce7_shell)\n*   [C#](#f5407a0138ef49ea98a3b776555e8ce7_csharp)\n*   [Go](#f5407a0138ef49ea98a3b776555e8ce7_go)\n*   [Java](#f5407a0138ef49ea98a3b776555e8ce7_java)\n*   [Node.JS](#f5407a0138ef49ea98a3b776555e8ce7_node)\n*   [Obj-C](#f5407a0138ef49ea98a3b776555e8ce7_objc)\n*   [...](#)\n    *   [PHP](#f5407a0138ef49ea98a3b776555e8ce7_php)\n    *   [Python](#f5407a0138ef49ea98a3b776555e8ce7_python)\n    *   [Ruby](#f5407a0138ef49ea98a3b776555e8ce7_ruby)\n    *   [Swift](#f5407a0138ef49ea98a3b776555e8ce7_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThis time the API will return a successful response:\n\n![Response for authorized API request](https://auth0.com/docs/media/articles/server-apis/using/private.png)\n\n**2\\. Testing the scoped endpoint**\n\nTo test the endpoint that requires a scope, pass the Access Token containing the correct scope as a Bearer token in the Authorization header:\n\n*   [cURL](#54464b47c50745e8b7e5dc43fa1414e1_shell)\n*   [C#](#54464b47c50745e8b7e5dc43fa1414e1_csharp)\n*   [Go](#54464b47c50745e8b7e5dc43fa1414e1_go)\n*   [Java](#54464b47c50745e8b7e5dc43fa1414e1_java)\n*   [Node.JS](#54464b47c50745e8b7e5dc43fa1414e1_node)\n*   [Obj-C](#54464b47c50745e8b7e5dc43fa1414e1_objc)\n*   [...](#)\n    *   [PHP](#54464b47c50745e8b7e5dc43fa1414e1_php)\n    *   [Python](#54464b47c50745e8b7e5dc43fa1414e1_python)\n    *   [Ruby](#54464b47c50745e8b7e5dc43fa1414e1_ruby)\n    *   [Swift](#54464b47c50745e8b7e5dc43fa1414e1_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private-scoped \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private-scoped\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private-scoped\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private-scoped\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private-scoped',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private-scoped\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private-scoped\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private-scoped\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private-scoped\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private-scoped\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the required scope is present, the API call is successful:\n\n![Response for scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped.png)\n\nIf the required scope is not present, the API returns a 403 HTTP Status (Forbidden):\n\n![Response for forbidden scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped-forbidden.png)",
  "title": "Auth0 Node (Express) API SDK Quickstarts: Using your API",
  "description": "This tutorial will show you how to use your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/rails/02-using",
  "markdown": "# Auth0 Ruby On Rails API SDK Quickstarts: Using your API\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [Ruby On Rails API](https://auth0.com/docs/quickstart/backend/rails)\n*   [Using your API](https://auth0.com/docs/quickstart/backend/rails/02-using)\n\nThis tutorial will show you how to use your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Calling the API From Your Application\n\nYou can call the API from your application by passing an Access Token in the `Authorization` header of your HTTP request as a Bearer token.\n\n*   [cURL](#1366859ad8a44a12b924e04e7ea81d67_shell)\n*   [C#](#1366859ad8a44a12b924e04e7ea81d67_csharp)\n*   [Go](#1366859ad8a44a12b924e04e7ea81d67_go)\n*   [Java](#1366859ad8a44a12b924e04e7ea81d67_java)\n*   [Node.JS](#1366859ad8a44a12b924e04e7ea81d67_node)\n*   [Obj-C](#1366859ad8a44a12b924e04e7ea81d67_objc)\n*   [...](#)\n    *   [PHP](#1366859ad8a44a12b924e04e7ea81d67_php)\n    *   [Python](#1366859ad8a44a12b924e04e7ea81d67_python)\n    *   [Ruby](#1366859ad8a44a12b924e04e7ea81d67_ruby)\n    *   [Swift](#1366859ad8a44a12b924e04e7ea81d67_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Obtaining an Access Token\n\nIf you are calling the API from a Single-Page Application or a Mobile/Native application, after the authorization flow is completed, you will get an Access Token. How you get the token and how you make the call to the API will be dependent on the type of application you are developing and the framework you are using. For more information refer to the relevant application Quickstarts which contain detailed instructions:\n\n*   [Single-Page Applications](https://auth0.com/docs/quickstart/spa)\n*   [Mobile / Native Application](https://auth0.com/docs/quickstart/native)\n\nIf you are calling the API from a command-line tool or another service, where there isn't a user entering their credentials, you need to use the [OAuth Client Credentials flow](https://auth0.com/docs/api/authentication#client-credentials). To do that, register a [Machine to Machine Application](https://manage.auth0.com/#/applications), and then subsequently use the **Client ID** and **Client Secret** of this application when making the request below and pass those along in the `client_id` and `client_secret` parameters respectively. Also include the Audience for the API you want to call.\n\n*   [cURL](#5f9e5bb3d72943229a0cade459ea6b02_shell)\n*   [C#](#5f9e5bb3d72943229a0cade459ea6b02_csharp)\n*   [Go](#5f9e5bb3d72943229a0cade459ea6b02_go)\n*   [Java](#5f9e5bb3d72943229a0cade459ea6b02_java)\n*   [Node.JS](#5f9e5bb3d72943229a0cade459ea6b02_node)\n*   [Obj-C](#5f9e5bb3d72943229a0cade459ea6b02_objc)\n*   [...](#)\n    *   [PHP](#5f9e5bb3d72943229a0cade459ea6b02_php)\n    *   [Python](#5f9e5bb3d72943229a0cade459ea6b02_python)\n    *   [Ruby](#5f9e5bb3d72943229a0cade459ea6b02_ruby)\n    *   [Swift](#5f9e5bb3d72943229a0cade459ea6b02_swift)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data 'client_id={yourClientId}' \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data audience=YOUR_API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: 'YOUR_API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=YOUR_API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=YOUR_API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nFor testing purposes, you can also get an Access Token from the **Test** tab in your [API settings](https://manage.auth0.com/#/apis).\n\n## Test Your API\n\n**1\\. Calling the secure endpoint**\n\nYou can make a request to the `/api/private` endpoint without passing any Access Token:\n\n*   [cURL](#5db23ba05f454cfe821dc1bb6f78d192_shell)\n*   [C#](#5db23ba05f454cfe821dc1bb6f78d192_csharp)\n*   [Go](#5db23ba05f454cfe821dc1bb6f78d192_go)\n*   [Java](#5db23ba05f454cfe821dc1bb6f78d192_java)\n*   [Node.JS](#5db23ba05f454cfe821dc1bb6f78d192_node)\n*   [Obj-C](#5db23ba05f454cfe821dc1bb6f78d192_objc)\n*   [...](#)\n    *   [PHP](#5db23ba05f454cfe821dc1bb6f78d192_php)\n    *   [Python](#5db23ba05f454cfe821dc1bb6f78d192_python)\n    *   [Ruby](#5db23ba05f454cfe821dc1bb6f78d192_ruby)\n    *   [Swift](#5db23ba05f454cfe821dc1bb6f78d192_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {method: 'GET', url: 'http://localhost:3010/api/private'};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nconn.request(\"GET\", \"/api/private\")\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe API will return a 401 HTTP (Unauthorized) status code:\n\n![Response for unauthorized API request](https://auth0.com/docs/media/articles/server-apis/using/private-unauthorized.png)\n\nOnce again, make the same request but this time pass along the Access Token as a Bearer token in the **Authorization** header of the request:\n\n*   [cURL](#c154c3eb8a9d4c369987a3e98e9f1c03_shell)\n*   [C#](#c154c3eb8a9d4c369987a3e98e9f1c03_csharp)\n*   [Go](#c154c3eb8a9d4c369987a3e98e9f1c03_go)\n*   [Java](#c154c3eb8a9d4c369987a3e98e9f1c03_java)\n*   [Node.JS](#c154c3eb8a9d4c369987a3e98e9f1c03_node)\n*   [Obj-C](#c154c3eb8a9d4c369987a3e98e9f1c03_objc)\n*   [...](#)\n    *   [PHP](#c154c3eb8a9d4c369987a3e98e9f1c03_php)\n    *   [Python](#c154c3eb8a9d4c369987a3e98e9f1c03_python)\n    *   [Ruby](#c154c3eb8a9d4c369987a3e98e9f1c03_ruby)\n    *   [Swift](#c154c3eb8a9d4c369987a3e98e9f1c03_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThis time the API will return a successful response:\n\n![Response for authorized API request](https://auth0.com/docs/media/articles/server-apis/using/private.png)\n\n**2\\. Testing the scoped endpoint**\n\nTo test the endpoint that requires a scope, pass the Access Token containing the correct scope as a Bearer token in the Authorization header:\n\n*   [cURL](#77b60247e1dc47a28dd22021face7ddf_shell)\n*   [C#](#77b60247e1dc47a28dd22021face7ddf_csharp)\n*   [Go](#77b60247e1dc47a28dd22021face7ddf_go)\n*   [Java](#77b60247e1dc47a28dd22021face7ddf_java)\n*   [Node.JS](#77b60247e1dc47a28dd22021face7ddf_node)\n*   [Obj-C](#77b60247e1dc47a28dd22021face7ddf_objc)\n*   [...](#)\n    *   [PHP](#77b60247e1dc47a28dd22021face7ddf_php)\n    *   [Python](#77b60247e1dc47a28dd22021face7ddf_python)\n    *   [Ruby](#77b60247e1dc47a28dd22021face7ddf_ruby)\n    *   [Swift](#77b60247e1dc47a28dd22021face7ddf_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private-scoped \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private-scoped\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private-scoped\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private-scoped\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private-scoped',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private-scoped\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private-scoped\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private-scoped\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private-scoped\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private-scoped\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the required scope is present, the API call is successful:\n\n![Response for scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped.png)\n\nIf the required scope is not present, the API returns a 403 HTTP Status (Forbidden):\n\n![Response for forbidden scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped-forbidden.png)",
  "title": "Auth0 Ruby On Rails API SDK Quickstarts: Using your API",
  "description": "This tutorial will show you how to use your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/python/02-using",
  "markdown": "# Auth0 Python API SDK Quickstarts: Using your API\n\n*   [Docs](https://auth0.com/docs)\n*   [Quickstarts](https://auth0.com/docs/quickstarts)\n*   [Backend/API](https://auth0.com/docs/quickstart/backend)\n*   [Python API](https://auth0.com/docs/quickstart/backend/python)\n*   [Using your API](https://auth0.com/docs/quickstart/backend/python/02-using)\n\nThis tutorial will show you how to use your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\n## Calling the API From Your Application\n\nYou can call the API from your application by passing an Access Token in the `Authorization` header of your HTTP request as a Bearer token.\n\n*   [cURL](#0466eda7e5ae4199a50d2561043b4a04_shell)\n*   [C#](#0466eda7e5ae4199a50d2561043b4a04_csharp)\n*   [Go](#0466eda7e5ae4199a50d2561043b4a04_go)\n*   [Java](#0466eda7e5ae4199a50d2561043b4a04_java)\n*   [Node.JS](#0466eda7e5ae4199a50d2561043b4a04_node)\n*   [Obj-C](#0466eda7e5ae4199a50d2561043b4a04_objc)\n*   [...](#)\n    *   [PHP](#0466eda7e5ae4199a50d2561043b4a04_php)\n    *   [Python](#0466eda7e5ae4199a50d2561043b4a04_python)\n    *   [Ruby](#0466eda7e5ae4199a50d2561043b4a04_ruby)\n    *   [Swift](#0466eda7e5ae4199a50d2561043b4a04_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Obtaining an Access Token\n\nIf you are calling the API from a Single-Page Application or a Mobile/Native application, after the authorization flow is completed, you will get an Access Token. How you get the token and how you make the call to the API will be dependent on the type of application you are developing and the framework you are using. For more information refer to the relevant application Quickstarts which contain detailed instructions:\n\n*   [Single-Page Applications](https://auth0.com/docs/quickstart/spa)\n*   [Mobile / Native Application](https://auth0.com/docs/quickstart/native)\n\nIf you are calling the API from a command-line tool or another service, where there isn't a user entering their credentials, you need to use the [OAuth Client Credentials flow](https://auth0.com/docs/api/authentication#client-credentials). To do that, register a [Machine to Machine Application](https://manage.auth0.com/#/applications), and then subsequently use the **Client ID** and **Client Secret** of this application when making the request below and pass those along in the `client_id` and `client_secret` parameters respectively. Also include the Audience for the API you want to call.\n\n*   [cURL](#924512c2943840c195aa2266da05c709_shell)\n*   [C#](#924512c2943840c195aa2266da05c709_csharp)\n*   [Go](#924512c2943840c195aa2266da05c709_go)\n*   [Java](#924512c2943840c195aa2266da05c709_java)\n*   [Node.JS](#924512c2943840c195aa2266da05c709_node)\n*   [Obj-C](#924512c2943840c195aa2266da05c709_objc)\n*   [...](#)\n    *   [PHP](#924512c2943840c195aa2266da05c709_php)\n    *   [Python](#924512c2943840c195aa2266da05c709_python)\n    *   [Ruby](#924512c2943840c195aa2266da05c709_ruby)\n    *   [Swift](#924512c2943840c195aa2266da05c709_swift)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=client_credentials \\\n  --data 'client_id={yourClientId}' \\\n  --data client_secret=YOUR_CLIENT_SECRET \\\n  --data audience=YOUR_API_IDENTIFIER\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: '{yourClientId}',\n    client_secret: 'YOUR_CLIENT_SECRET',\n    audience: 'YOUR_API_IDENTIFIER'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=client_credentials\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret=YOUR_CLIENT_SECRET\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=YOUR_API_IDENTIFIER\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=client_credentials&client_id=%24%7Baccount.clientId%7D&client_secret=YOUR_CLIENT_SECRET&audience=YOUR_API_IDENTIFIER\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=client_credentials\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret=YOUR_CLIENT_SECRET\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=YOUR_API_IDENTIFIER\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nFor testing purposes, you can also get an Access Token from the **Test** tab in your [API settings](https://manage.auth0.com/#/apis).\n\n## Test Your API\n\n**1\\. Calling the secure endpoint**\n\nYou can make a request to the `/api/private` endpoint without passing any Access Token:\n\n*   [cURL](#2939a06685d94a7cb653571fce45bead_shell)\n*   [C#](#2939a06685d94a7cb653571fce45bead_csharp)\n*   [Go](#2939a06685d94a7cb653571fce45bead_go)\n*   [Java](#2939a06685d94a7cb653571fce45bead_java)\n*   [Node.JS](#2939a06685d94a7cb653571fce45bead_node)\n*   [Obj-C](#2939a06685d94a7cb653571fce45bead_objc)\n*   [...](#)\n    *   [PHP](#2939a06685d94a7cb653571fce45bead_php)\n    *   [Python](#2939a06685d94a7cb653571fce45bead_python)\n    *   [Ruby](#2939a06685d94a7cb653571fce45bead_ruby)\n    *   [Swift](#2939a06685d94a7cb653571fce45bead_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {method: 'GET', url: 'http://localhost:3010/api/private'};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nconn.request(\"GET\", \"/api/private\")\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe API will return a 401 HTTP (Unauthorized) status code:\n\n![Response for unauthorized API request](https://auth0.com/docs/media/articles/server-apis/using/private-unauthorized.png)\n\nOnce again, make the same request but this time pass along the Access Token as a Bearer token in the **Authorization** header of the request:\n\n*   [cURL](#bfbc1bede2c9433e962a8967dc2b9a73_shell)\n*   [C#](#bfbc1bede2c9433e962a8967dc2b9a73_csharp)\n*   [Go](#bfbc1bede2c9433e962a8967dc2b9a73_go)\n*   [Java](#bfbc1bede2c9433e962a8967dc2b9a73_java)\n*   [Node.JS](#bfbc1bede2c9433e962a8967dc2b9a73_node)\n*   [Obj-C](#bfbc1bede2c9433e962a8967dc2b9a73_objc)\n*   [...](#)\n    *   [PHP](#bfbc1bede2c9433e962a8967dc2b9a73_php)\n    *   [Python](#bfbc1bede2c9433e962a8967dc2b9a73_python)\n    *   [Ruby](#bfbc1bede2c9433e962a8967dc2b9a73_ruby)\n    *   [Swift](#bfbc1bede2c9433e962a8967dc2b9a73_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThis time the API will return a successful response:\n\n![Response for authorized API request](https://auth0.com/docs/media/articles/server-apis/using/private.png)\n\n**2\\. Testing the scoped endpoint**\n\nTo test the endpoint that requires a scope, pass the Access Token containing the correct scope as a Bearer token in the Authorization header:\n\n*   [cURL](#f64185f45f4347d2af10ce4917f8faec_shell)\n*   [C#](#f64185f45f4347d2af10ce4917f8faec_csharp)\n*   [Go](#f64185f45f4347d2af10ce4917f8faec_go)\n*   [Java](#f64185f45f4347d2af10ce4917f8faec_java)\n*   [Node.JS](#f64185f45f4347d2af10ce4917f8faec_node)\n*   [Obj-C](#f64185f45f4347d2af10ce4917f8faec_objc)\n*   [...](#)\n    *   [PHP](#f64185f45f4347d2af10ce4917f8faec_php)\n    *   [Python](#f64185f45f4347d2af10ce4917f8faec_python)\n    *   [Ruby](#f64185f45f4347d2af10ce4917f8faec_ruby)\n    *   [Swift](#f64185f45f4347d2af10ce4917f8faec_swift)\n\n```\ncurl --request GET \\\n  --url http://localhost:3010/api/private-scoped \\\n  --header 'authorization: Bearer YOUR_ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"http://localhost:3010/api/private-scoped\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"http://localhost:3010/api/private-scoped\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"http://localhost:3010/api/private-scoped\")\n  .header(\"authorization\", \"Bearer YOUR_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'http://localhost:3010/api/private-scoped',\n  headers: {authorization: 'Bearer YOUR_ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer YOUR_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3010/api/private-scoped\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_PORT => \"3010\",\n  CURLOPT_URL => \"http://localhost:3010/api/private-scoped\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer YOUR_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPConnection(\"localhost:3010\")\n\nheaders = { 'authorization': \"Bearer YOUR_ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/api/private-scoped\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\n\nurl = URI(\"http://localhost:3010/api/private-scoped\")\n\nhttp = Net::HTTP.new(url.host, url.port)\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer YOUR_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer YOUR_ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"http://localhost:3010/api/private-scoped\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the required scope is present, the API call is successful:\n\n![Response for scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped.png)\n\nIf the required scope is not present, the API returns a 403 HTTP Status (Forbidden):\n\n![Response for forbidden scoped API request](https://auth0.com/docs/media/articles/server-apis/using/private-scoped-forbidden.png)",
  "title": "Auth0 Python API SDK Quickstarts: Using your API",
  "description": "This tutorial will show you how to use your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/java-spring-security5/03-troubleshooting",
  "markdown": "# Auth0 Spring Boot API SDK Quickstarts: Troubleshooting\n\nThis document will help you troubleshoot your configuration if you get unexpected responses from your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nIf you configured JWT validation correctly, you will be able to get proper responses from your API when you make requests. However, in the case where you get a 401 (Unauthorized) response from your API, it is because the configuration of your JWT middleware does not match with the JWT which was passed.\n\nThis document will help you troubleshoot your JWT middleware configuration.\n\n## How Does a Token Get Validated?\n\nIn terms of validating a JWT, there are various things to consider:\n\n1.  **Is the token well-formed?** In other words, is this token conforming to the structure of a JSON Web Token (JWT)? To get more information on the structure of a JWT, please refer to [this section on the structure of a JWT](https://auth0.com/docs/jwt#what-is-the-json-web-token-structure-)\n    \n2.  **Has the token been tampered with?** The last part of a JWT is the signature. The signature is used to verify that the token was in fact signed by the sender and not altered in any way.\n    \n3.  **Has the token been received in its validity period?** JWTs are only valid for a specified time period (as expressed in the `exp` claim).\n    \n4.  **Is the token coming from the intended Authority?** This consists of 2 parts\n    \n    *   **Signature Verification**: Can we confirm that the JWT is correctly signed using the key issued by the issuing authority?\n        \n    *   **Issuer Value**: The Issuer is defined in the `iss` claim. Once again does this claim match up with what your application expects?\n        \n5.  **Is the token intended for the current application?** So does the `aud` claim of the JWT match with what your application is expecting?\n    \n\n## Inspecting a Token\n\nA quick way to inspect a JWT is by using the [JWT.io](https://jwt.io/) website. It has a handy debugger which allows you to quickly check that a JWT is well-formed, and also inspect the values of the various claims.\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-rs256.png)\n\nIn the screenshot above you can see that the token was signed using the **RS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://rs256.test.api**.\n\nSo, in other words, these values in your JWT validation configuration registration must match **exactly** - including the trailing slash for the Issuer, such as\n\n```\naudience = \"https://rs256.test.api\",\ndomain = \"https://jerrie.auth0.com/\"\n};\n```\n\nFor a token signed using HS256, the debugger view will look a little different:\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-hs256.png)\n\nIn the screenshot above you can see that the token was signed using the **HS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://hs256.test.api**.",
  "title": "Auth0 Spring Boot API SDK Quickstarts: Troubleshooting",
  "description": "This document will help you troubleshoot your configuration if you get unexpected responses from your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-teams/tenant-management",
  "markdown": "# Tenant Management\n\nAccess and modify Team information from within your tenant. If you don't yet have a tenant associated with your account, see [Create Tenants.](https://auth0.com/docs/get-started/auth0-overview/create-tenants)\n\n## Access the Teams Dashboard\n\nIf you are a Team Owner, you can use the Teams Dashboard to:\n\n*   Choose who can create new tenants: Team Owners or all tenant administrators.\n    \n\n*   View all tenants created under your Auth0 subscription or custom agreement.\n    \n*   View and invite Team Owners.\n    \n\nTo access the Teams Dashboard from any of your tenants:\n\n1.  Select your tenant name from the tenant drop-down menu in the [Auth0 Dashboard](https://manage.auth0.com/dashboard).\n    \n2.  Find your Teams name at the bottom of the menu and select **Go to team**.\n    \n\n![Access the Auth0 Team Dashboard](https://images.ctfassets.net/cdy7uua7fh8z/3207T6ELEBc56dLZT84hjT/13779947b38dd52ab4694b3869271961/Tenant_Management_-_Teams.png)\n\nTo access the Teams Dashboard using a URL:\n\n1.  Navigate to `https://accounts.auth0.com/`\n    \n    ![Login with Teams URL](https://images.ctfassets.net/cdy7uua7fh8z/5HLwoWU5Af0ajaaop8Sqaj/5a8b1631d6ec9a9bd588ad2855124e46/Screenshot_2024-06-15_at_11.27.20.png)\n2.  If your user account is a member of only one Team, enter your credentials to be taken to your Teams dashboard. If your user account is a member of one or more Teams, select the Team from the list of Teams your user account is associated with to login.\n    \n\nIf the option for Teams access isn't visible, try the following:\n\n| Possible Cause | Action |\n| --- | --- |\n| The current tenant isn’t in Teams. | Try switching to a different tenant. |\n| You’re not a Teams owner. | Ask a Teams owner to invite you to the team. |\n\n## View tenants\n\nIn the Teams Dashboard, you can view all tenants within your Auth0 custom agreement or subscription present in either the Public or Private Cloud Environment. For each tenant, you can review: \n\n*   Tenant name \n    \n*   Region \n    \n*   Creation date \n    \n*   Environment (Development, Staging, or Production) \n    \n*   Tenant administrators\n    \n\n1.  Select **Tenants** on the left side of the Teams Dashboard.\n    \n    ![Screenshot of Teams Tenant list with updated View Members replacing screenshot showing View Admins](https://images.ctfassets.net/cdy7uua7fh8z/da6blUeUgVIfSkNSNBXEB/7779cbf3ad77fe5a6977d4c73bf130e8/Default_tenant_list__1_.png)\n    \n    For Private Cloud Environments, select the **Overview** menu drop-down to reveal the **Tenants** menu option.\n    \n    ![Teams Tenant List for Private Cloud, overview menu dropdown](https://images.ctfassets.net/cdy7uua7fh8z/XqGQ0R8n5DLdIFnIAKf0o/b7ad39b33aeeb3eaf019d22a47de36af/Tenant_List_Private_Cloud.png)\n2.  If you’re an administrator for a tenant, select the tenant name to access the tenant. If you are not a tenant administrator, you will not be able to select the tenant.\n    \n3.  To review tenant members, select **View Members**.\n    \n\n## View Private Cloud Environments\n\nA list of Private Cloud Environments can be viewed from the Teams Dashboard. You are able to view the following information\n\n*   Environment name\n    \n*   Cloud provider type (AWS or Azure)\n    \n*   Deployment region\n    \n*   Failover region\n    \n*   Current environment release version.\n    \n\n1.  Select the **Overview** menu drop-down to reveal the **Private Cloud** menu option.\n    \n    ![Environment List for Teams Private Cloud, Name, Cloud Provider, Region](https://images.ctfassets.net/cdy7uua7fh8z/52WqWLZ7ttfoU47tkzI6VX/e382d24f0bee319c85169b2c0d699062/Environment_List_Private_Cloud.png)\n\n## Link tenants\n\nLinking tenants allows you to share features and quota limits available within your Team Subscription with the linked tenant. Once linked, that tenants subscriptions will be tied to your Team and you would no longer have to individually manage the subscription for that tenant.\n\nYou are able to link tenants to your team, if the following conditions are true:\n\n*   The tenant is not part of an existing Team.\n    \n*   You are an administrator of the tenant you want to link.\n    \n*   You have a Team Owner role on the team.\n    \n\nIf these conditions are met, the tenant will show up as a possible option to link to your team when you select **Link Existing Tenant** from the Tenants page.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/4UnM47kaHhkCCJhjCZn7Pu/449d269e8491f2ab3ba5af97c4347b6b/Tenants.png)\n\n## Tenant Creation\n\nTeam Owners can create a tenant from within the Teams Dashboard, automatically linking the created tenant with the team, including associating the Team Subscription details (available features and quota limits) with the newly created tenant.\n\nYou can do this by clicking on the **Create New Tenant** button on the Tenants page, which will open the Create Tenant form.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/6xRe8ooVN915kJkjOKqEai/f21c238c01b207acc0d5be89d6764149/Screenshot_2023-08-21_at_11.50.12_AM.png)\n\n## Manage Tenant Creation\n\nYou can control who can create new tenants under your Auth0 custom agreement or subscription under **Team Settings**. When creating a new tenant, administrators can:\n\n*   Link the tenant to custom agreement. The new tenant exists under your custom agreement or subscription. It benefits from the same features, counts toward limits, and is visible to Team Owners. or\n    \n*   Create a tenant under their personal account. The new tenant is not a part of your Teams' custom agreement or subscription. The administrator who creates the tenant can access it with the same login credentials. \n    \n\nTo allow administrators to link a tenant to a custom agreement, the Team Owner must:\n\n1.  Select **Settings** on the left side of the Teams Dashboard.\n    \n    ![Teams-Settings-Perma-link](https://images.ctfassets.net/cdy7uua7fh8z/4FOTqjy9vptHQIROUp4doz/4e3ec299960f207ddcf157ecff26de31/settings.png)\n2.  Select the option **Allow Tenant Admins to Create Tenants under the Teams Account**. If this option is unchecked, then tenant administrators can create personal accounts only.\n    \n3.  Select **Save**.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/1c7QzOKaTGVemnWkfNosXi/44fe024b9c0e0d875557b3854b7a2409/2022-08-10_11-18-32.png)\n\n## View Team Subscription Details\n\nTeam Owners can view Team Subscription details by visiting Subscription tab within the Setting page.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/6S7hWwCfLy4zKmkgfmkNr/a653bd96709b3cfa8f0d55fbc6d9f078/Screenshot_2023-08-21_at_11.42.34_AM.png)",
  "title": "Tenant Management",
  "description": "Manage the Auth0 teams information within a given tenant.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-teams/team-member-management",
  "markdown": "# Team Member Management\n\nTeam Owners can manage and configure Auth0 Teams. Auth0 creates at least one Owner when we provision Teams. We recommend at least two Team Owners, especially if you limit tenant creation to Team Owners.\n\nAs a Team Owner, you can add, change, and remove team members. The supported roles apart from a Team Owner are Report Viewer and Contributor.\n\n### Team Membership Roles\n\n#### Team Owner\n\nMembers with this role have full access to the team dashboard (list of all tenants, tenant creation restriction, team members management) and can access specific tenants of which they are a member.\n\n#### Report Viewer\n\nMembers with this role can view Quarterly Snapshots. The Report Viewer role is available to select enterprise customers that are managed by the Digital Technical Account Manager (DTAM).\n\n#### Contributor\n\nMembers with this role can view and access specific tenants of which they are a member.\n\n### View and add Team Members \n\n#### Invite a New Team Member\n\n1.  On the left side of the Teams Dashboard, select **Members**.\n    \n    ![A view of Auth0 Team Members on the Teams Dashboard](https://images.ctfassets.net/cdy7uua7fh8z/74VH8S63sQ3V6thbkv4Mrm/b3c237a6c707159c66f3056ce4db42a0/Team_Members.png)\n2.  To invite a new Team Owner, select **Invite a Member**.\n    \n3.  Enter the email address of the member to invite and select the access level.\n    \n    ![Team member management screenshot](https://images.ctfassets.net/cdy7uua7fh8z/3qvdCDXWy5dSXokDRXQUnW/f57ff9d38b7d44985f24a3151a2c8820/image__3_.png)\n4.  Select **Send Invite**.\n    \n\n#### Update existing Team Member role\n\n1.  To update the role of an existing Team Member, search for the member in the **Members** list.\n    \n2.  Select the three-dot menu option and click on the **Assign Role** option.\n    \n    ![Update the Team Member role from an existing role](https://images.ctfassets.net/cdy7uua7fh8z/1Q5USpwPqW33FgYWXw8Y6N/96bb3f0190bd1194dedb1683ad4dc599/Team_Member_Asign.png)\n3.  Pick the new role you want to assign the Team Member and click **Assign**.\n    \n\n## Update Team Name\n\nTeams allow you to update the Team name visible on the tenant picker for dashboard users. To update the Team name:\n\n1.  Select **Settings** on the left side of the Teams Dashboard.\n    \n2.  Make the necessary changes to the **Team Name** captured within the **Team Information** section.\n    \n3.  Select **Save**. This change now displays in the tenant picker.\n    \n\n![Screen shot used to explain how to update the team name](https://images.ctfassets.net/cdy7uua7fh8z/3aAkVDVoqZ5ZFlMuRi30cP/c97b5725d6010bc80d27fa7c8deab54d/Team_Name_-_Dashboard_Setting.png)",
  "title": "Team Member Management",
  "description": "Manage and configure members of your team.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-teams/tenant-member-management",
  "markdown": "# Tenant Member Management\n\nTeam Owners are able to centrally manage access of all existing and new dashboard users of tenants under the team. We support adding tenant members through the Team dashboard, while removing and updating members access and [roles](https://auth0.com/docs/get-started/manage-dashboard-access/feature-access-by-role) to one or more tenants still occurs from within the tenant through the Auth0 Dashboard.\n\nTurning on Tenant Member Management allows for greater security control on who has access to tenants and what actions they are permitted to carry out on the tenants. Team Owners are able to delegate tenant administrators the ability to add, remove, and update tenant members from within the Auth0 Dashboard.\n\n### Turn on Tenant Member Management\n\nTenant Member Management can be activated by going into the Settings section of the Teams dashboard, selecting the check box and clicking Save.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3tPZygx5XxpbhXzALMGWcW/9d08c4ff94841f37079eb34cc49e4e4c/Activate_Tenant_Member_Management.png)\n\n### What to expect when the Tenant Member Management is activated\n\n*   A background process is started to replicate all current tenant members as team members with the contributor role.\n    \n*   If user already exists as a Team Member the role with the higher privileges is maintained.\n    \n\n### Assign Team Member to Tenants with Tenant Member Management\n\n1.  Select **Members** on the left side of the Teams Dashboard.\n    \n    ![Member list from Teams Members pages](https://images.ctfassets.net/cdy7uua7fh8z/80UvoKhwRx57y4UxK62sE/cd2ceb394ad407d290451e9fd630ddd3/Tenant_Member_Details.png)\n2.  Select the Team Member name you will like to assign to a Tenant to open up the Member details page.\n    \n    ![Member details page for selected Team Member](https://images.ctfassets.net/cdy7uua7fh8z/6HJ9EoFKUdDaVzvCYHidIW/67712d9623bf9f4335d136b459a4383f/Team_Member_Details_Page.png)\n3.  Click on the **Add Tenant Access** button on the top right to open up the Add Tenant Access window.\n    \n    ![Modal to assign Tenant Access to the Selected Member](https://images.ctfassets.net/cdy7uua7fh8z/7uewUhuOujm0BEhUEPU1qT/e1a7d1fb8709308dda2be9a7896adcf8/Assign_Tenant_Tenant_Member_Management.png)\n4.  Start typing the Tenant name if known within the search window or click the dropdown icon to list tenants.\n    \n    ![Selecting one or more tenant to grant access to Team Member](https://images.ctfassets.net/cdy7uua7fh8z/4tfTxU9AFBFvJDolZtor1C/35698b19a6b4acc95f4e51374574aa14/Select_Tenant_from_list.png)\n5.  Tab to complete if typing or select the tenant from the drop down list. You can select one or more tenants up to 5 from the list of tenants.\n    \n6.  Select one or more of the desired roles to assign to the Team Member for each selected tenants.\n    \n    ![Assigning specific role for the Team member onto the selected tenants.](https://images.ctfassets.net/cdy7uua7fh8z/5GIqv9LkEl7DlKHjAUROoK/678a097ffc4854af3981c757e77047c8/Selecting_Tenant_role.png)\n7.  Click on the Assign button when done to grant access.\n    \n    ![Team Member details page showing list of tenant access and roles confirmation](https://images.ctfassets.net/cdy7uua7fh8z/4OYuguD4f33oRbQ9w7VgyS/26b6aad8ce4cbb8383cf1b3ea0a03d9b/Add_Tenant_Success.png)\n\n### Edit Tenants Membership with Tenant Member Management\n\nEditing of tenant membership is done using the Auth0 Dashboard.\n\n### Delete Tenants Membership with Tenant Member Management\n\nDeleting of tenant membership is done using the Auth0 Dashboard.\n\n### Tenant Membership invite Delegation\n\nTeams owners are able to delegate team and tenant membership invites to Tenant admins through the Just In Time Membership feature under the Security Policies - SSO Enforcement configuration menu.\n\nJust In Time allows for team members accounts to be auto created in Teams based on successful login using the enterprise IdP connection. Thereby tenant admins can continue to invite dashboard users from within the Auth0 Dashboard. Users are able to accept the invite and successfully login using the enterprise IdP.\n\nTeams owners have the option to restrict new team member account creation by toggling off the Just In Time feature for each enterprise IdP. This prevents auto creation of team member accounts.\n\n![Enterprise IdP Connection JIT](https://images.ctfassets.net/cdy7uua7fh8z/72ZH6cTS3BmmYcKrdvlIek/ea1b0d22756be646c32cf9fa4fd20b88/Just_In_Time.png)\n\n## Managing Connections\n\nThe Tenant Member Management feature allows for managing the connection used to accept invite and authenticate dashboard users through [Security Policies](https://auth0.com/docs/get-started/auth0-teams/configure-security-policies).",
  "title": "Tenant Member Management",
  "description": "Describes how to use Auth0 Teams to centrally manage Tenant Membership.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-teams/troubleshoot-teams",
  "markdown": "# Troubleshoot Teams\n\nTo ensure undisrupted service, see below to help troubleshoot any issues associated with an Auth0 Teams membership.\n\n#### Add a missing tenant\n\nIf you are on a self-service subscription plan and you don’t see a tenant under your Teams instance, verify the [subscription](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions) details:\n\n1.  First verify the [subscription](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions) details by checking the tenant's subscription.\n    \n2.  Attempt to link the tenant by following the [Link tenants](https://auth0.com/docs/get-started/auth0-teams/tenant-management) guide.\n    \n\nIf the subscription is an Enterprise Agreement but is not part of your Teams instance, contact [Auth0 Support](http://support.auth0.com/) to assist in adding the tenant.\n\n![Screenshot of what to expect when your tenant subscription is an Enterprise Agreement](https://images.ctfassets.net/cdy7uua7fh8z/480m7MPxpbtaG1dufjiwah/852da2ca0a9e717599db79a7260895a7/Teams_-_Subscription.png)\n\n#### Remove an unrecognized admin\n\nIf a Tenant administrator is listed as part of a tenant and should not be:\n\n1.  If you are a Team Owner and also the tenant admin for the tenant, access the Auth0 Dashboard for the tenant to remove the admin. To learn more, read [Team Member Management](https://auth0.com/docs/get-started/auth0-teams/team-member-management).\n    \n2.  Request a tenant administrator to remove the admin from the tenant.",
  "title": "Troubleshoot Teams",
  "description": "Troubleshoot any issues associated with an Auth0 Teams membership.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-teams/configure-security-policies",
  "markdown": "# Configure Security Policies\n\nSecurity policies allow [team owners](https://auth0.com/docs/get-started/auth0-teams/team-member-management) to configure and implement authentication rules that adhere to your organization's IT security policies for access to infrastructure systems or applications.\n\nSingle Sign On (SSO) enforcement as one of the security policies restricts login access to Teams and the Auth0 Dashboard to your organization's identity provider (IdP).\n\n#### Access Security Policies\n\nYou can access Security Policies by selecting **Security** from the menu in the Teams Dashboard.\n\n#### Enforce SSO\n\nTo enforce SSO, you’ll need to verify that the enterprise IdP is available, then toggle on the **Enforce Single Sign On** setting. To do this:\n\n1.  Select **Security** in the Teams Dashboard.\n    \n2.  [Verify](https://auth0.com/docs/get-started/manage-dashboard-access/configure-single-sign-on-for-auth0-dashboard) that the enterprise IdP is available as an active connection.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/4jgUyHkF8taeoQyjUPv0JK/ba110fd8c086f0dc69c4d6ff45d9f4d1/Auth0_Teams_-__Configure_Security_Policies_-_1-2.png)\n3.  Ensure that you are logged in as a Team Owner using the active **enterprise IdP**. If you are not logged in on this connection, you will be unable to toggle **Enforce Single Sign On**.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/3LFdDLZALsxV9k7cI8qplK/f2810fe059e98010126d34300a0f5afb/Auth0_Teams_-_Configure_Security_Policies_-_2-3.png)\n4.  Select the **Enforce Single Sign On** checkbox, then select **Save**.\n    \n5.  Select **Confirm** to proceed, or select **Cancel** to exit without applying any changes.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/5U7leIZOnxIo3iOOBkFDn2/95bcd346ea99ef39c77864251261cc5a/Enforce_Single_Sign_On.png)",
  "title": "Configure Security Policies",
  "description": "Configure the security policies associated with an Auth0 team.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/python/03-troubleshooting",
  "markdown": "# Auth0 Python API SDK Quickstarts: Troubleshooting\n\nThis document will help you troubleshoot your configuration if you get unexpected responses from your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nIf you configured JWT validation correctly, you will be able to get proper responses from your API when you make requests. However, in the case where you get a 401 (Unauthorized) response from your API, it is because the configuration of your JWT middleware does not match with the JWT which was passed.\n\nThis document will help you troubleshoot your JWT middleware configuration.\n\n## How Does a Token Get Validated?\n\nIn terms of validating a JWT, there are various things to consider:\n\n1.  **Is the token well-formed?** In other words, is this token conforming to the structure of a JSON Web Token (JWT)? To get more information on the structure of a JWT, please refer to [this section on the structure of a JWT](https://auth0.com/docs/jwt#what-is-the-json-web-token-structure-)\n    \n2.  **Has the token been tampered with?** The last part of a JWT is the signature. The signature is used to verify that the token was in fact signed by the sender and not altered in any way.\n    \n3.  **Has the token been received in its validity period?** JWTs are only valid for a specified time period (as expressed in the `exp` claim).\n    \n4.  **Is the token coming from the intended Authority?** This consists of 2 parts\n    \n    *   **Signature Verification**: Can we confirm that the JWT is correctly signed using the key issued by the issuing authority?\n        \n    *   **Issuer Value**: The Issuer is defined in the `iss` claim. Once again does this claim match up with what your application expects?\n        \n5.  **Is the token intended for the current application?** So does the `aud` claim of the JWT match with what your application is expecting?\n    \n\n## Inspecting a Token\n\nA quick way to inspect a JWT is by using the [JWT.io](https://jwt.io/) website. It has a handy debugger which allows you to quickly check that a JWT is well-formed, and also inspect the values of the various claims.\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-rs256.png)\n\nIn the screenshot above you can see that the token was signed using the **RS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://rs256.test.api**.\n\nSo, in other words, these values in your JWT validation configuration registration must match **exactly** - including the trailing slash for the Issuer, such as\n\n```\naudience = \"https://rs256.test.api\",\ndomain = \"https://jerrie.auth0.com/\"\n};\n```\n\nFor a token signed using HS256, the debugger view will look a little different:\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-hs256.png)\n\nIn the screenshot above you can see that the token was signed using the **HS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://hs256.test.api**.",
  "title": "Auth0 Python API SDK Quickstarts: Troubleshooting",
  "description": "This document will help you troubleshoot your configuration if you get unexpected responses from your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-teams/quarterly-snapshot",
  "markdown": "# About the Quarterly Snapshot\n\nThe Quarterly Snapshot provides highlights of usage and value at an account level, including aggregated information on how you’re measuring against quota, your identity environment, and threat detection.\n\nThe feature is automatically enabled when Auth0 Teams is provisioned. It is exclusively available for select enterprise customers managed by the Digital Technical Account Manager (DTAM).\n\nHere are the metrics you may see on your Quarterly Snapshot.\n\n| **Metric** | **What it measures** | **Comments** |\n| --- | --- | --- |\n| Monthly Active Users | Measures the unique monthly active users on the account as compared to your quota. | For detailed information on a tenant level, please reference the [Support Center Quota](https://support.auth0.com/reports/quota) report. |\n| Machine to Machine Tokens | Shows the number of access tokens issued by Auth0 for the [client credentials grant](https://auth0.com/docs/api-auth/grant/client-credentials). Tokens issued for Auth0 Management API or other Auth0 built in APIs are not counted. | For detailed information on a tenant level, please reference the [Support Center Quota](https://support.auth0.com/reports/quota) report. |\n| Active Enterprise Connections | This metric displays the number of enterprise connections an account is using. | For more details about your quota, contact your Account Executive. |\n| New User Signups | This displays how many new users (user registrations) were added to your tenant(s) in the months of this quarter. | Refer to the [Activity Page](https://auth0.com/docs/get-started/auth0-overview/dashboard/activity) for more information on new users. |\n| Dormant Users | This metric represents the monthly average users that haven’t authenticated in the last month. |     |\n| Breached Password | Number of attempts blocked with compromised credentials, as stopped by the [Breached password detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection) feature. | Stay tuned for the [Security Center](https://auth0.com/docs/secure/security-center) add-on coming in 2023. |\n| Brute-force Protection | Requests blocked by the [Brute-force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection) feature, if enabled. This metric summarizes all requests blocked specifically on production tenants. | Stay tuned for the [Security Center](https://auth0.com/docs/secure/security-center) add-on coming in 2023. |\n| Suspicious IP Throttling | Requests blocked by the [Suspicious IP Throttling](https://auth0.com/docs/secure/attack-protection/suspicious-ip-throttling) feature, if enabled. This metric sums all requests blocked specifically on production tenants. | Stay tuned for the [Security Center](https://auth0.com/docs/secure/security-center) add-on coming in 2023. |\n| Bot Detection | Requests failed to solve the CAPTCHA challenge. This metric sums all the bot requests that were blocked by the [Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection) feature after failing to solve a CAPTCHA challenge. | Stay tuned for the [Security Center](https://auth0.com/docs/secure/security-center) add-on coming in 2023. |\n| Adaptive MFA | Requests where [MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa) challenge was issued due to a low confidence score. This metric sums all login attempts where a multi-factor authentication challenge was issued and the calculated confidence score was low. | Stay tuned for the [Security Center](https://auth0.com/docs/secure/security-center) add-on coming in 2023. |",
  "title": "About the Quarterly Snapshot",
  "description": "Learn about the Quarterly Snapshot report available to Auth0 Teams members, including how to access it and how to interpret the provided metrics.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-teams/team-activity",
  "markdown": "# Team Activity\n\nTeam Activity allows Team Owners to view audit logs associated to member activities performed on their Auth0 account.\n\nTeam Activity report is located under the **Reports** section of the Teams Dashboard.\n\n![Location of Team Activity](https://images.ctfassets.net/cdy7uua7fh8z/4pgJk5Jd9wv8sJL4fXOC43/1ab79a77a20249600f55fa7e2e073c56/Team_Activity_2.png)\n\nTeam Activity provides a summary view of the member who generated the event, the event type, and the date the event was generated.\n\nYou can select **View Details** to find more information such as the description of the event, the event status, the IP address of the user who triggered the event, user agent details, and more.\n\n## Event types\n\nTeam Activity event types are described below.\n\n| **Event Type** | **Description** |\n| --- | --- |\n| Team Invitation | Team member invitation created  <br>Team member invitation deleted |\n| Team Member | Team member deleted  <br>Team member role updated |\n| Security Policy | Security policy updated  <br>Social connections updated |\n| Team Setting | Team settings updated |\n\n## Event schema\n\nTeam Activity event schema is described below.\n\n```\n{  \n    \"id\": \"string\", \n    \"team_id\": \"string\",\n    \"user_id\": \"string\",\n    \"type\": \"string\",\n    \"description\": \"string\",\n    \"status\": \"string\",\n    \"details\": \"object\",\n    \"ip\": \"string\",\n    \"hostname\": \"string\",\n    \"user_agent\": \"string\",\n    \"version\": \"string\",\n    \"created_at\": \"date\",\n    \"team_slug\": \"string\",\n    \"user\": \"object\"\n}\n```\n\n| **Name** | **Type** | **Description** |\n| --- | --- | --- |\n| `id` | string | Event log unique identification. |\n| `team_id` | string | Unique team identification. |\n| `user_id` | string | The unique identifier for the user that generated the event. |\n| `type` | string | Event type. |\n| `description` | string | Event type summary. |\n| `status` | string | Event status. Possible values are `Success` or `Failure`. |\n| `details` | object | Details of the logged event. |\n| `ip` | string | IP address of the user that generated the event log. |\n| `hostname` | string | FQDN of the Auth0 App on which the event was performed. |\n| `user_agent` | string | Web browser and Device OS type and version. |\n| `version` | string | Schema version under which the activity log was generated. |\n| `created_at` | datetime | Date and time event log was generated. |\n| `team_slug` | string | Unique text team identifier. |\n| `user` | object | Contains name, avatar URL, and Team membership status (boolean). |\n\n## Audit log retention\n\nThe retention of Team Activity audit logs varies by plan. Read our [Pricing](https://auth0.com/pricing) page for more information.",
  "title": "Team Activity",
  "description": "Team Activity allows Team Owners to view and audit event logs generated by team member.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/dashboard",
  "markdown": "# Auth0 Dashboard\n\nThe [Auth0 Dashboard](https://manage.auth0.com/#) is where you manage all aspects of your Auth0 subscription and configuration.\n\nIt consists of several sections that you can navigate using the sidebar menu on your left.\n\nThe following table contains a brief overview of the different Dashboard sections and what you can do in each.\n\n| **Section** | **Description** |\n| --- | --- |\n| **Applications** | Manage your applications, APIs, and single sign-on (SSO) integrations.  <br>**Applications**: For each of your apps for which you want to authenticate users with Auth0, register an application.  <br>**APIs**: For each of your APIs that you want to secure with Auth0, register an API. Create new APIs and manage existing ones.  <br>**SSO Integrations**: View and enable external services for SSO. Create new SSO integrations and configure, review, and manage integration settings. |\n| **Authentication** | Manage the identity providers through which you allow users to authenticate to your apps.  <br>**Database**: Securely store and manage username/password credentials either in an Auth0 datastore or in your own database. Connect to existing databases using template-based JavaScript scripts that run on Auth0's server during every authentication. Gradually migrate an existing database of legacy credentials to Auth0 as users authenticate (no password reset required).  <br>**Social**: Configure social identity providers (such as Facebook, X, and Github) through which your users can log in.  <br>**Enterprise**: Configure enterprise identity providers (such as Active Directory, SAML, and Office 365) through which your users can log in using their enterprise credentials.  <br>**Passwordless**: Allow your users to sign up and log in using one-time passcodes (delivered by email or SMS) or one-click links, instead of passwords. |\n| **Organizations** | Manage the organizations you do business with, and customize the experience their users have when accessing your applications. |\n| **User Management** | Manage your users' identities and permissions.  <br>**Users**: View and create user profiles, perform password resets, block and delete users, and more.  <br>**Roles**: Create and manage roles for your apps. Roles contain collections of permissions and can be assigned to users. |\n| **Branding** | **Universal Login**: Create and customize a login page to which you can direct users to authenticate.  <br>**Custom Domains**: Create a custom domain to maintain a consistent experience for your users.  <br>**Email Templates**: Use templates to create welcome, password reset, and account verification email-based workflows.  <br>**Email Provider**: Designate and configure your custom email provider information. |\n| **Security** | Configure extra layers of security by enabling shields that protect your users against different types of attacks and user access anomalies.  <br>**Attack Protection**: Manage settings for bot, IP throttling, brute-force, and breached password attacks.  <br>**Multi-factor Auth**: Require additional factors during the login process to prevent unauthorized access.  <br>**Monitoring**: Monitor threat intelligence events with one of our data visualization and alerting integrations. |\n| **Actions** | Configure flows such as login, machine-to-machine, user registration, and password resets. Create and manage customized actions used in flows. |\n| **Auth Pipeline** | **Rules**: Configure custom JavaScript snippets that are executed in Auth0 as part of each user authentication transaction. You can call external APIs, filter which users can log in to your application, use an AllowList, configure geolocated access, and so on.  <br>**Hooks**: Customize the behavior of Auth0 when you use Database Connections by configuring Node.js code that is executed against extensibility points (which are comparable to webhooks that come with a server). |\n| **Monitoring** | **Logs**: View log data of actions taken in the dashboard by administrators and user logins.  <br>**Streams**: Create and manage log event streaming to external data analysis services. |\n| **Marketplace** | Explore integrations that help your business do more with Auth0. |\n| **Extensions** | Extend the Auth0 platform with official and third-party add-ons. |\n| **Settings** | Configure your tenants, manage your Auth0 subscription and payment options, control your tenant administrators and other user roles. Manage other tenant settings related to your custom domains, signing keys, and other advanced settings. |\n| **Get Support** | Go to our [Support Center](https://support.auth0.com/). If your plan does not have access to support services, see the [Auth0 Community](https://community.auth0.com/). |\n\nOn the top left, you can see your tenant's name and icon, and a little arrow. This arrow displays a dropdown menu that you can use to configure different aspects of your account:",
  "title": "Auth0 Dashboard",
  "description": "Describes the Auth0 Dashboard and all the features you can access to implement authentication and authorization with your applications and APIs..",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/create-tenants",
  "markdown": "# Create Tenants\n\nWe will walk through the initial steps of getting started using Auth0 to familiarize you with the key concepts of the Auth0 service. We will use the company **Example-Co** to help describe some of the steps involved.\n\n## Set up an Auth0 account\n\nIf you haven't already [signed up](https://auth0.com/signup) for an Auth0 **account**, do so (it's free). You can either use username and password or log in with a social provider (such as LinkedIn, Microsoft, GitHub, or Google).\n\n## Create a tenant and domain\n\nOnce you create your account you will be asked to create a **tenant**. Everything starts with an Auth0 tenant. This is where you configure your use of Auth0, and then where Auth0 assets - such as [applications](https://auth0.com/docs/get-started/applications), [connections](https://auth0.com/docs/authenticate/identity-providers), and [user profiles](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business/profile-management) - are defined, managed and stored. You access an Auth0 tenant via the Auth0 [Dashboard](https://auth0.com/docs/get-started/auth0-overview/dashboard), where you can also create additional, associated tenants. You can create more than one Auth0 tenant so that you can structure your tenants in a way that will isolate different domains of users and also support your Software Development Life Cycle (SDLC).\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3aqUs6NTb69YhxZt0lpL4f/4c143e071a08cd7a8052b5e4db46e7da/image-20240621-221859.png)\n\n**Tenant names cannot be changed or reused once deleted.** So, make sure you're happy with the name(s) before you create your Auth0 tenants.\n\nDetermining the level of isolation you require when it comes to your user domains is an important step, and together with your branding requirements helps you determine the number of Auth0 tenants needed in your environment. The number of Auth0 tenants you need to manage can quickly grow so consider carefully before creating multiple Auth0 tenants for production.\n\nTenant characteristics:\n\n*   The tenant name has to be unique. It will be used to create your personal domain.\n    \n*   The tenant name can contain only lowercase alphanumeric characters and hyphens (\"-\"). It cannot begin or end with a hyphen.\n    \n*   The tenant name must be a minimum of 3 characters and a maximum of 63 characters.\n    \n*   The tenant name cannot be changed after creation.\n    \n*   You can create more than one tenant; in fact, you are encouraged to do so for each environment you may have such as development, staging, or production. To learn more, read [Set Up Multiple Environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments).\n    \n\nWhen you name your tenant, that name becomes part of your Auth0 **domain** until and unless you create a custom domain. This domain is the base URL used to access the Auth0 API and the URL where your users authenticate.\n\n### Region, locality, and sub-locality\n\nThe domain name is also made up of the locality value from a **region**. We support the following locality values for the [public cloud deployment option](https://auth0.com/docs/deploy-monitor/deployment-options):\n\n| **Region** | **Locality** | **Sub-localities** |\n| --- | --- | --- |\n| Australia | AU  | AU  |\n| Canada | CA  | CA  |\n| Europe | EU  | EU, EU-2 |\n| Japan | JP  | JP  |\n| United Kingdom | UK  | UK  |\n| United States of America | US  | US, US-2, US-3, US-4 |\n\nEach of these localities is separated into a sub-locality (or **tenant environment**) with a digit after the locality, e.g. `EU-2`. Tenant environments cannot be chosen manually, but localities based on the selected region may be specified, which control the assigned tenant domain and the region where your data will be hosted.\n\nIn our example, **Example-Co** chose the name `example-co` and AU as their region. So their domain is `example-co.au.auth0.com`.\n\n## Custom domains\n\nWe recommend the use of custom domains, such as `example-co.com`, in production environments to provide your users with the most secure and seamless experience. This comes with an additional cost.\n\nIf you have a **single-tenant** implementation, you can deploy your custom domain in:\n\n*   The cloud-managed by Auth0\n    \n*   An AWS cloud managed by you\n    \n\nTo learn more, read [Custom Domains](https://auth0.com/docs/customize/custom-domains).\n\n## What's next\n\n*   **Create and register applications**: Now that you have an account and a domain, you need to register each application that will use our services in the [Auth0 Dashboard](https://manage.auth0.com/#/applications). To learn more, read [Applications in Auth0](https://auth0.com/docs/get-started/applications) and [Create Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n*   **Set up connections**: Next, you need to set up how your users will authenticate during log in. Auth0 sits between your app and the identity provider that authenticates your users (such as Google or Facebook). The relationship between Auth0 and the identity provider is referred to as a **connection**. By using this connection layer, Auth0 keeps your app isolated from any changes that occur with the identity provider's implementation. To learn more, read [Authentication and Authorization](https://auth0.com/docs/get-started/identity-fundamentals/authentication-and-authorization) and [Connections](https://auth0.com/docs/authenticate/identity-providers).\n    \n\n## Extend Auth0's functionality\n\nAuth0 offers several ways to extend the platform's functionality:\n\n*   [Actions](https://auth0.com/docs/customize/actions): Actions are secure, tenant-specific, versioned functions written in Node.js that execute at certain points within the Auth0 platform. Use Actions to customize and extend Auth0's capabilities with custom login.\n    \n*   [Rules](https://auth0.com/docs/customize/rules): Rules are functions written in JavaScript or C#, that are executed in Auth0 just after successful authentication and before control returns to your app. Rules can be chained together for modular coding and can be turned on and off individually. You can use Rules for:\n    \n    *   Access control\n        \n    *   Webhooks\n        \n    *   Profile enrichment\n        \n    *   Multi-factor authentication (MFA)\n        \n*   [Hooks](https://auth0.com/docs/customize/hooks): Hooks allow you to customize the behavior of Auth0 using Node.js code that is executed against extensibility points (which are comparable to webhooks that come with a server). They are secure, self-contained functions associated with specific extensibility points of the Auth0 platform. Auth0 invokes the Hooks at runtime to execute your custom logic.\n    \n*   [Extensions](https://auth0.com/docs/customize/extensions): Auth0 Extensions enable you to install applications or run commands/scripts that extend the functionality of the Auth0 base product. You can either use one of the pre-defined extensions, provided by Auth0, or create your own. Some of the actions you can do with extensions include:\n    \n    *   Manage the authorizations for users (using groups, roles, and permissions)\n        \n    *   Import/export users\n        \n    *   Export logs to other services\n        \n    *   Deploy scripts from external repositories\n        \n\n## Learn more\n\n*   [Tenant Settings](https://auth0.com/docs/get-started/tenant-settings)\n*   [Create Multiple Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants/create-multiple-tenants)\n*   [Link Multiple Tenants to a Single Subscription](https://auth0.com/docs/get-started/auth0-overview/create-tenants/child-tenants)\n*   [Set Up Multiple Environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments)",
  "title": "Create Tenants",
  "description": "Describes how to create a tenant and learn the basics of Auth0 and familiarize yourself with the terminology.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/create-applications",
  "markdown": "# Create Applications\n\nAn **application** in Auth0 can be a native app that executes on a mobile device, a single-page web app that executes on a browser, or a regular web application that executes on a server.\n\nWhen you create an application in the Auth0 Dashboard, Auth0 assigns it a **client ID** which is an alphanumeric string that is the unique identifier for your application. You will use this ID in your application code when you call Auth0 APIs. You can't modify the client ID.\n\nAnother important piece of information is the **client secret**. It must be kept confidential at all times. If anyone gains access to your application's client secret, then they can impersonate your application and access protected resources. It is important that you select the correct application type to help Auth0 check for certain security risks.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Click **Create Application**.\n    \n    ![Screenshot for the Create Application choice](https://images.ctfassets.net/cdy7uua7fh8z/1s7PgReuV70gwurZSHFQ4c/340f50d5dcb7f7e4008d147a99d8f136/createapplication.jpg)\n3.  Give your new application a descriptive name.\n    \n4.  Choose from the following app types:\n    \n    *   **Native Applications**: These applications include mobile, desktop, or hybrid apps running natively on a device (e.g., i0S, Android).\n        \n    *   **Single-Page Web Applications**: These applications include JavaScript apps that perform most of their user interface logic in a web browser, communicating with a web server primarily using APIs (e.g., AngularJS + Node.js or React).\n        \n    *   **Regular Web Applications**: These applications are traditional web applications that perform most of their application logic on the server (e.g., Express.js, ASP.NET).\n        \n    *   **Machine-to-Machine Applications**: These applications include non-interactive applications, such as command-line tools, daemons, IoT devices, or services running on your back-end.\n        \n5.  Optionally, choose a **technology** associated with your app.\n    \n6.  Choose **Continue**.\n    \n    The **Application** **Details** page appears which includes the following tabs:\n    \n    | **Settings Tab** | **Description** |\n    | --- | --- |\n    | **Quick Start** | Shows all the available documentation for your application type. |\n    | **Settings** | Shows all available settings for your application. By default, most of the settings will be created for you. To learn more, read [Application Settings](https://auth0.com/docs/get-started/dashboard/application-settings). |\n    | **Credentials** | Shows the application’s authentication method and configured credentials. To learn more, read [Application Credentials](https://auth0.com/docs/secure/application-credentials) |\n    | **Add-ons** | Allows you to enable plugins associated with an application. These are SAML or WS-Fed web apps for which Auth0 generates access tokens. To learn more, read [Enable SAML2 Web App Addon](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon) and [Configure WS-Fed Applications](https://auth0.com/docs/protocols/configure-ws-fed-applications). |\n    | **Connections** | Allows you to enable connections for your application. Connections are sources of users; they can be enabled and shared between multiple applications. To learn more, read [Connections](https://auth0.com/docs/connections). |\n    | **Organizations** | Allows you to authenticate users into organizations to which they belong. To learn more, read [Organizations](https://auth0.com/docs/organizations). |\n    \n\n## Learn more\n\n*   [Register Native Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/native-apps)\n*   [Register Single-Page Web Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/single-page-web-apps)\n*   [Register Regular Web Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps)\n*   [Register Machine-to-Machine Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps)\n*   [Application Settings](https://auth0.com/docs/get-started/applications/application-settings)\n*   [Remove Applications](https://auth0.com/docs/get-started/applications/remove-applications)",
  "title": "Create Applications",
  "description": "Learn how to set up and configure applications in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/identity-fundamentals/identity-and-access-management",
  "markdown": "# Introduction to Identity and Access Management (IAM)\n\n## What is identity and access management (IAM)? \n\nIdentity and access management provides control over user validation and resource access. Commonly known as IAM, this technology ensures that the right people access the right digital resources at the right time and for the right reasons.\n\n## IAM basic concepts\n\nTo understand IAM, you must be familiar with some fundamental concepts:\n\n*   A **digital resource** is any combination of applications and data in a computer system. Examples of digital resources include web applications, APIs, platforms, devices, or databases. \n    \n*   The core of IAM is **identity**. Someone wants access to your resource. It could be a customer, employee, member, participant, and so on. In IAM, a **user** account is a digital identity. User accounts can also represent non-humans, such as software, Internet of Things devices, or robotics.\n    \n\n![Simple diagram showing user accessing resource](https://images.ctfassets.net/cdy7uua7fh8z/4jZPLvwFRGMSCBRv6ksLqb/c177b6d17213af76dfe50fb1aacc27d1/intro-iam-user-wants-resource.png)![Simple diagram showing that the IAM system controls user access to a resource](https://images.ctfassets.net/cdy7uua7fh8z/64NhRWH7dFSSTRGv040nIB/bc921e8aa24b0c01112a18debffb08a2/IAM-verifies-access.png)\n\n*   **Authentication** is the verification of a digital identity. Someone (or something) authenticates to prove that they’re the user they claim to be. \n    \n*   **Authorization** is the process of determining what resources a user can access.  \n    \n\nIt’s common to confuse authentication and authorization because they seem like a single experience to users. They are two separate processes: authentication proves a user’s identity, while authorization grants or denies the user’s access to certain resources. \n\nYou can think of authentication and authorization as the security system for an office building. Users are the people who want to enter the building. Resources that people want to access are areas in the building: floors, rooms, and so on. \n\n**Authentication:** When you enter the building, you must show your photo ID badge to the security guard. The guard compares the photo on the badge to your face. If they match, the guard lets you through the door to try to access different areas of the building. The guard doesn’t tell you what rooms you can access; they only get proof that you are who you claim to be. This is authentication: confirming user identity. \n\n![Diagram showing how authentication is like a security guard checking your badge at the door](https://images.ctfassets.net/cdy7uua7fh8z/2kbfIgTRNIKNdqJBbgmWQ4/9554142db540d35f669084457abac19b/authentication-building.png)\n\n**Authorization:** In this scenario, imagine the elevators and doorways in the building have key sensors for access. The chip in your badge gives you access only to the first floor, which your company occupies. If you swipe your badge to enter any other floor, your access is denied. You can access your private office but not those belonging to your colleagues. You can enter the supply room but not the server room. This is authorization: granting and denying access to different resources based on identity. \n\n![Diagram showing how authorization is like a badge that gives you access to only some rooms in a building](https://images.ctfassets.net/cdy7uua7fh8z/2OGIbazhGLOdDB0OVOTyX8/67a4521bd285d84ff958fc94139ecef7/authorization-building.png)\n\nTo learn more about authentication and authorization, read [Authentication vs. Authorization](https://auth0.com/docs/get-started/identity-fundamentals/authentication-and-authorization).\n\n## What does IAM do?\n\nIdentity and access management gives you control over user validation and resource access: \n\n*   How users become a part of your system\n    \n*   What user information to store\n    \n*   How users can prove their identity\n    \n*   When and how often users must prove their identity\n    \n*   The experience of proving identity\n    \n*   Who can and cannot access different resources\n    \n\nYou integrate IAM with your application, API, device, data store, or other technology. This integration can be very simple. For example, your web application might rely entirely on Facebook for authentication, and have an all-or-nothing authorization policy. Your app performs a simple check: if a user isn’t currently logged in to Facebook in the current browser, you direct them to do so. Once authenticated, all users can access everything in your app. \n\nIt’s unlikely that such a simple IAM solution would meet the needs of your users, organization, industry, or compliance standards. In real life, IAM is complex. Most systems require some combination of these capabilities:\n\n*   **Seamless signup and login experiences:** Smooth and professional login and signup experiences occur within your app, with your brand’s look and language. \n    \n*   **Multiple sources of user identities:** Users expect to be able to log in using a variety of social (such as Google or Linkedin), enterprise (such as Microsoft Active Directory), and other [identity providers](https://auth0.com/docs/authenticate/identity-providers).\n    \n*   **Multi-factor authentication (MFA):** In an age when passwords are often stolen, requiring additional proof of identity is the new standard. Fingerprint authentication and one-time passwords are examples of common authentication methods. To learn more, read [Multi-Factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication).\n    \n*   **Step-up authentication:** Access to advanced capabilities and sensitive information require stronger proof of identity than everyday tasks and data. Step-up authentication requires additional identity verification for selected areas and features. To learn more, read [Add Step-up Authentication](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication).\n    \n*   **Attack protection:** Preventing bots and bad actors from breaking into your system is fundamental to cybersecurity. To learn more, read [Attack Protection](https://auth0.com/docs/secure/attack-protection).\n    \n*   **Role-based access control (RBAC):** As the number of users grows, managing the access of each individual quickly becomes impractical. With RBAC, people who have the same role have the same access to resources. To learn more, read [Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/rbac). \n    \n*   **Fine-grained authorization (FGA):** When you need more options to manage user access to your resources or technologies, you can use relationship-based access control to go beyond role-based. You can give individual users access to certain resources and determine the best solution for your specific use case. To learn more, read [What Is Fine-Grained Authorization?](https://docs.fga.dev/intro/authorization-and-okta-fga#what-is-fine-grained-authorization)\n    \n\nFacing this level of complexity, many developers rely on an IAM platform like Auth0 instead of building their own solutions. \n\n## How does IAM work? \n\n“Identity and access management” is not one clearly defined system. IAM is a discipline and a type of framework for solving the challenge of secure access to digital resources.  There’s no limit to the different approaches for implementing an IAM system. This section explores elements and practices in common implementations. \n\n### Identity providers\n\nIn the past, the standard for identity and access management was for a system to create and manage its own identity information for its users. Each time a user wanted to use a new web application, they filled in a form to create an account. The application stored all of their information, including login credentials, and performed its own authentication whenever a user signed in. \n\nAs the internet grew and more and more applications became available, most people amassed countless user accounts, each with its own account name and password to remember. There are many applications that continue to work this way. But many others now rely on identity providers to reduce their development and maintenance burden and their users’ effort.\n\nAn identity provider creates, maintains, and manages identity information, and can provide authentication services to other applications. For example, Google Accounts is an identity provider. They store account information such as your user name, full name, job title, and email address. Slate online magazine lets you log in with Google (or another identity provider) rather than go through the steps of entering and storing your information anew. \n\n![Screenshot of Slate magazine login](https://images.ctfassets.net/cdy7uua7fh8z/2moycObnuKnYfoqFMSGCO0/12aa20de553bfce8afba3cf4f56cbd8d/Slate-login.png)\n\nIdentity providers don’t share your authentication credentials with the apps that rely on them. Slate, for example, doesn’t ever see your Google password. Google only lets Slate know that you’ve proven your identity. \n\nOther identity providers include social media (such as Facebook or LinkedIn), enterprise (such as Microsoft Active Directory), and legal identity providers (such as Swedish BankID).\n\n### Authentication factors\n\nAuthentication factors are methods for proving a user’s identity. They commonly fall into these basic types:\n\n| Factor type | Examples |\n| --- | --- |\n| Knowledge (something you know) | Pin, password |\n| Possession (something you have) | Mobile phone, encryption key device |\n| Inherence (something you are) | Fingerprint, facial recognition, iris scan |\n\nIAM systems require one or many authentication factors to verify identity.\n\n### Authentication and authorization standards\n\nAuthentication and authorization standards are open specifications and protocols that provide guidance on how to:\n\n*   Design IAM systems to manage identity\n    \n*   Move personal data securely\n    \n*   Decide who can access resources\n    \n\nThese IAM industry standards are considered the most secure, reliable, and practical to implement:\n\n#### OAuth 2.0\n\nOAuth 2.0 is a delegation protocol for accessing APIs and is the industry-standard protocol for IAM. An open authorization protocol, OAuth 2.0 lets an app access resources hosted by other web apps on behalf of a user without ever sharing the user’s credentials. It’s the standard that allows third-party developers to rely on large social platforms like Facebook, Google, and Twitter for login. To learn more, read [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth).\n\n#### Open ID Connect\n\nA simple identity layer that sits on top of OAuth 2.0, OpenID Connect (OIDC) makes it easy to verify a user’s identity and obtain basic profile information from the identity provider. OIDC is another open standard protocol. To learn more, read [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol).\n\n#### JSON web tokens\n\nJSON web tokens (JWTs) are an open standard that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. JWTs can be verified and trusted because they’re digitally signed. They can be used to pass the identity of authenticated users between the identity provider and the service requesting the authentication. They also can be authenticated and encrypted. To learn more, read [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens).\n\n#### Security Assertion Markup Language (SAML)\n\nSecurity Assertion Markup Language (SAML) is an open-standard, XML-based data format that lets businesses communicate user authentication and authorization information to partner companies and enterprise applications that their employees use. To learn more, read [SAML](https://auth0.com/docs/authenticate/protocols/saml).\n\n#### Web Services Federation (WS-Fed)\n\nDeveloped by Microsoft and used extensively in their applications, this standard defines the way security tokens can be transported between different entities to exchange identity and authorization information. To learn more, read [Web Services Federation Protocol](https://auth0.com/docs/authenticate/protocols/ws-fed-protocol).\n\n## Why use an IAM platform?\n\nWhy do so many developers choose to build on an identity and access management platform instead of building their own solution from the ground up?\n\nUser expectations, customer requirements, and compliance standards introduce significant technical challenges. With multiple user sources, authentication factors, and open industry standards, the amount of knowledge and work required to build a typical IAM system can be enormous. A strong IAM platform has built-in support for all identity providers and authentication factors, offers APIs for easy integration with your software, and relies on the most secure industry standards for authentication and authorization.\n\nFor those who haven’t yet decided whether to build or buy an IAM solution, [Build vs. Buy: Guide to Evaluating Identity Management](https://auth0.com/resources/whitepapers/build-vs-buy-evaluating-identity-management) is a useful resource.",
  "title": "Introduction to Identity and Access Management (IAM)",
  "description": "Basic overview of the computer software field of identity and access management, written for those new to the space",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/identity-fundamentals/introduction-to-auth0",
  "markdown": "# Introduction to Auth0\n\nAuth0 is an identity access management (IAM) provider. But what does this mean? If you've read [Introduction to Identity and Access Management (IAM)](https://auth0.com/docs/get-started/identity-fundamentals/identity-and-access-management), you know an IAM solution is a gatekeeper to the resources you provide to customers as web applications, APIs, etc. The gatekeeper initiates authorization as outlined in OAuth 2.0. The addition of the OpenID Connect layer adds authentication to secure your users’ digital identities and your product.\n\nThe Auth0 identity platform supports different application types and frameworks. Whether your application is a regular web app, a mobile app, or a machine-to-machine app, Auth0 provides configurations for the most secure authorization grant, or workflow, for each. You can read more about authorization grants and choose the one for your application in our article [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)\n\nAside from supporting secure protocols, the Auth0 identity platform allows you to customize login services to fit your business, your technology, and your customer base. Using the Auth0 Dashboard and Management API, you can create your own Auth0 instance to authenticate and authorize your customers. You can configure login behaviors, connect your user data store, manage those users, choose an authorization grant, and establish authentication factors for a seamless, scalable product with an impactful user experience.\n\n## Get Started\n\n### Identity fundamentals\n\nYou don’t have to be an expert on IAM to integrate Auth0 into your application or API, but you can choose the right configuration for your use case if you know some key concepts. To learn more, read our [Introduction to Identity and Access Management (IAM)](https://auth0.com/docs/get-started/identity-fundamentals/identity-and-access-management) article. If you still have questions about planning your implementation, review our [Architecture Scenarios](https://auth0.com/docs/get-started/architecture-scenarios) section for walk-throughs of real world scenarios.\n\n### Integrate with Auth0\n\nTo start integrating with Auth0, you can either start with our interactive [Quickstart guides](https://auth0.com/docs/quickstarts) for initial set-up and quick configurations, or you can register your application manually in the Auth0 Dashboard. In Dashboard, you can create a tenant, or your Auth0 instance, from the ground up. If you prefer to use SDKs, Auth0 offers multiple options for each application type. To see the full offering, navigate to [Auth0 Libraries](https://auth0.com/docs/libraries).\n\nYou can begin your configuration with general details in the Dashboard tenant settings, such as the name displayed to your users, your company logo, your callback URLs, or where Auth0 redirects your users after authentication. You can review our recommendations by reading [Tenant Settings](https://auth0.com/docs/get-started/tenant-settings).\n\nOnce you’ve set up the tenant, then you can create and configure your application or API. You can use the instructions in our articles [Create Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications) or [Register APIs](https://auth0.com/docs/get-started/auth0-overview/set-up-apis) as a starting point.\n\n### Authenticate\n\nThe vehicle of authentication is the login form, or the intermediary to allow your users access to your application. Users provide pre-determined credentials, such as username or password, in the login form to verify their digital identities.\n\nAuth0’s Universal Login is a login form you can customize to accommodate your brand and configure to provide secure access. Some benefits of using Universal Login are:\n\n*   Passwordless login with biometrics\n    \n*   Choice of multi-factor authentication methods from email, voice, or Duo\n    \n*   Single Sign-on (SSO) capabilities\n    \n*   Localization support\n    \n\nTo learn more, read [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). To find out more about available features, read [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login).\n\nOnce you have a login form, you can connect your user store to Auth0. You can connect an existing database, or use a social, legal, or enterprise identity provider such as X or Azure Active Directory. New users can sign up with the connection you have configured.\n\nOnce you have a login form and user store connection, you can set protocols that work behind the scenes when users log in to your application. The most common protocols are associated with the OAuth 2.0 and OpenID Connect (OIDC) specs you may have reviewed in our [Identity Fundamentals](https://auth0.com/docs/get-started/identity-fundamentals) article.\n\nAnother protocol to securely transmit information during log in comes in the form of tokens. Tokens from the Authorization Server, Auth0’s Authentication API, transmit information between entities.  When a user logs in and access is approved, the Authentication API sends an access token, an ID token, or both depending on the authentication grant you are using to create a session. Access tokens contain information about what scopes, or permissions, the requestor has in your application while ID tokens have requestor information, such as user metadata to better the user experience.\n\nTokens from the Authentication API are JSON Web Tokens (JWTs) structured with:\n\n*   a header that includes the signature\n    \n*   the payload that contains statements and attributes about the requestor\n    \n*   the signature that verifies the token is valid\n    \n\nTo learn more about tokens, read [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens), [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens), or [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens).\n\nOther protocols, like SAML (Security Assertion Markup Language) and WS-Fed (Web Service Federation) are used with more specific systems. SAML works with some identity providers while WS-Fed is used with Microsoft products. You can learn more by exploring the [Protocols](https://auth0.com/docs/authenticate/protocols) section of our documentation.\n\n### Manage users\n\nManaging user profiles and access can be time-consuming. If you choose to manage users with your Auth0 instance, you can remove some of the pain points.\n\nYou can easily automate CRUD operations and query user profiles using Auth0 Dashboard or the Management API. You can categorize your users into categories with Auth0 Organizations to arrange your customer-base to fit your management style. To learn more, navigate to the [Manage Users](https://auth0.com/docs/manage-users) section of our documentation.\n\nYour business model may include levels of access for your users. You may want a subsection of users to have read-only permissions and another subsection with the ability to edit. Auth0’s Authorization Core allows you to implement role-based access control. You can create roles, assign roles to users, and define permissions.\n\nIf you want to manage access based on browser behaviors, you can limit the lifetime of a session. A session, or the interaction between the requesting entity and your application or resource, has a lifetime limit. A session can end when the user closes the browser or navigates away from your webpage. You can extend sessions with refresh tokens that renew access tokens. Configure refresh tokens in the Dashboard.  To learn more, read [Session Lifetime Limits](https://auth0.com/docs/manage-users/sessions/session-lifetime-limits) and [Get Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens/get-refresh-tokens).\n\nCookies, or strings of data, tie into the session and represent an authenticated user. Cookies allow your authenticated users to maintain a session and move between web pages without being forced to re-authenticate.  Once the browser closes, the cookie is cleared by the browser.\n\n### Customize\n\nYour brand is important, and Auth0 offers customization to make the login experience more personalized to your business. You can add your logo and color scheme to your login form as well as use a custom domain to give you ownership of the login URL. To learn more about configuration, read [Custom Domains](https://auth0.com/docs/customize/custom-domains).\n\nUniversal Login offers numerous features to configure authentication to fit your needs, like Multi-factor authentication, passwordless authentication with device biometrics, and localization. On a more granular level, you can adjust the text of prompts your user receives when an action needs to be completed. You can configure prompts for your users to signup, to enroll a device for authentication, or to send a code to an email/SMS for users to enter for verification. You can also customize email communications to welcome new users, verify enrollment, or reset passwords with email templates. To learn more, read [Customize Universal Login Text Elements](https://auth0.com/docs/customize/login-pages/universal-login/customize-text-elements) and [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\nYou can also configure certain events with Auth0 Actions. Actions are secure functions that execute during runtime. Actions trigger at different points in the pipeline and have a variety of uses. You could add metadata before the user signs up or redirect users to an external site. To learn more about what Actions can do for you, read [Understand How Auth0 Actions Work](https://auth0.com/docs/customize/actions/actions-overview).\n\n### Secure\n\nMalicious attacks can happen anytime. Auth0 offers several attack protection options, such as Bot Detection in combination with Google reCAPTCHA Enterprise to prevent cyber attacks. To learn more about Bot Detection configuration, read [Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection). \n\nEven if you are using your own login page, Auth0 offers other security options you can enable in the Auth0 Dashboard: \n\n*   Breached Password Detection \n    \n*   Brute-Force Protection \n    \n*   Suspicious IP Throttling \n    \n\nBreached password detection is a security measure against malicious agents with stolen credentials. Brute-force protection safeguards a targeted user account by limiting the amount of login attempts that automatically block the malicious IP and send a notification to the flagged user account. Suspicious IP throttling works where brute force protection leaves off to block traffic from any IP address that attempts rapid signups or logins.\n\nOther security measures depend on how you want your users to authenticate. Enabling multi-factor authentication (MFA) in Universal Login requires users to provide two or more authentication factors. With Auth0, you can customize MFA to trigger under certain circumstances, such as a user logging in from an unknown device or from a questionable IP address. To learn more about configuring MFA, read [Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa).\n\n### Deploy and monitor\n\nWhen you’ve finished testing your Auth0 instance and are ready to deploy, you can use our public or private cloud offerings. To learn more about available offerings, read [Deployment Options](https://auth0.com/docs/deploy-monitor/deployment-options). If you need a multi-tenant capable environment, you can read more about [Private Cloud on AWS](https://auth0.com/docs/deploy-monitor/deploy-private-cloud/private-cloud-on-aws).\n\nTo keep your deployment on track, we provide guidance in the form of pre-deployment recommendations, a deployment checklist, best practices, common fixes, and other tips to help make deployment as seamless as possible.\n\nOnce you’ve established your production environment ready for users, you can be on the lookout with error tracking and alerts. The System Center Operations Manager allows you to monitor, while event logs can be exported to an analytical tool and allow you insight on trends, user behavior, or issues.",
  "title": "Introduction to Auth0",
  "description": "Describes Auth0 services and features.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/identity-fundamentals/authentication-and-authorization",
  "markdown": "# Authentication vs. Authorization\n\nWhile often used interchangeably, [authentication](https://auth0.com/docs/authenticate) and authorization represent fundamentally different functions. In this article, we compare and contrast the two to show how they protect applications in complementary ways.\n\nIn simple terms, authentication is the process of verifying who a user is, while authorization is the process of verifying what they have access to.\n\nComparing these processes to a real-world example, when you go through security in an airport, you show your ID to authenticate your identity. Then, when you arrive at the gate, you present your boarding pass to the flight attendant, so they can authorize you to board your flight and allow access to the plane.\n\n## Authentication vs. authorization\n\nHere's a quick overview of the differences between authentication and authorization:\n\n| **Authentication** | **Authorization** |\n| --- | --- |\n| Determines whether users are who they claim to be | Determines what users can and cannot access |\n| Challenges the user to validate credentials (for example, through passwords, answers to security questions, or facial recognition) | Verifies whether access is allowed through policies and rules |\n| Usually done before authorization | Usually done after successful authentication |\n| Generally, transmits info through an ID Token | Generally, transmits info through an Access Token |\n| Generally governed by the OpenID Connect (OIDC) protocol | Generally governed by the OAuth 2.0 framework |\n| Example: Employees in a company are required to authenticate through the network before accessing their company email | Example: After an employee successfully authenticates, the system determines what information the employees are allowed to access |\n\nIn short, access to a resource is protected by both authentication and authorization. If you can't prove your identity, you won't be allowed into a resource. And even if you can prove your identity, if you are not authorized for that resource, you will still be denied access.\n\nAuth0 has products and services for authentication, like [passwordless](https://auth0.com/docs/authenticate/passwordless/passwordless-with-universal-login), [multi-factor authentication](https://auth0.com/docs/secure/multi-factor-authentication) (MFA), and [Single-Sign On (SSO)](https://auth0.com/docs/authenticate/single-sign-on) you can configure using Auth0 Dashboard or Management API. For authorization, Auth0 offers [role-based access control](https://auth0.com/docs/manage-users/access-control/rbac) (RBAC) or [fine grained authorization](https://docs.fga.dev/fga) FGA).",
  "title": "Authentication vs. Authorization",
  "description": "Explore the differences between authentication and authorization.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/glossary",
  "markdown": "# Identity Glossary\n\nWe've put together a glossary of identity terms for newcomers and seasoned developers, alike. Hopefully this helps put any identity terminology confusion to rest.\n\n## A\n\n*   ##### Access Token\n    \n    Credential that can be used by an application to access an API. It informs the API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that has been granted. An Access Token can be in any format, but two popular options include opaque strings and JSON Web Tokens (JWT). They should be transmitted to the API as a Bearer credential in an HTTP Authorization header.\n    \n    To learn more, see [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens).\n    \n*   ##### Account Linking\n    \n    Connecting user accounts across multiple platforms to allow users access to more than one resource or application by providing credentials one time.\n    \n*   ##### Actions\n    \n    Secure, tenant-specific, versioned functions written in Node.js that execute at certain points during the Auth0 runtime. Actions are used to customize and extend Auth0's capabilities with custom logic.\n    \n    To learn more, see [Actions](https://auth0.com/docs/customize/actions).\n    \n*   ##### Adaptive Multi-factor Authentication\n    \n    Multi-factor authentication (MFA) that is only triggered for users when an attempted login is determined to be a low confidence login. With Adaptive MFA, Auth0 triggers MFA only when needed to add friction for bad actors while keeping the login experience unchanged for good actors.\n    \n*   ##### Application\n    \n    Your software that relies on Auth0 for authentication and identity management. Auth0 supports single-page, regular web, native, and machine-to-machine applications.\n    \n    To learn more, see [Applications in Auth0](https://auth0.com/docs/get-started/applications).\n    \n*   ##### Attack Protection\n    \n    Features that Auth0 provides to detect and mitigate attacks, including brute-force protection, suspicious IP throttling, breached password detection, bot detection, and adaptive multi-factor authentication.\n    \n    To learn more, see [Attack Protection](https://auth0.com/docs/secure/attack-protection).\n    \n*   ##### Audience\n    \n    Unique identifier of the audience for an issued token, identified within a JSON Web Token as the **aud** claim. The audience value is either the application (`Client ID`) for an ID Token or the API that is being called (`API Identifier`) for an Access Token. At Auth0, the Audience value sent in a request for an Access Token dictates whether that token is returned in an opaque or JWT format.\n    \n*   ##### Auth0 Dashboard\n    \n    Auth0’s primary administrator interface in which you can register your application or API, connect to a user store or another identity provider, and configure your Auth0 services.\n    \n*   ##### Authentication Server\n    \n    Server that confirms or denies a user’s identity. An authentication server does not limit the actions or resources available to the user (although it can provide context for this purpose).\n    \n*   Random string generated by the authorization server and returned to the application as part of the authorization response. The authorization code is relatively short-lived and is exchanged for an Access Token at the token endpoint when using the Authorization Code Flow (either with or without Proof Key for Code Exchange (PKCE)).\n    \n*   ##### Authorization Flow\n    \n    Another name for Authorization Grants outlined in OAuth 2.0. Authorization flows are the workflows a resource (an application or an AIP) uses to grant requestors access. Based on the type of technology (for example, if an application can store a Client Secret) and the type of requestor, resource owners can use Authorization Code Flow, Proof of Key Code Exchange (PKCE), Resource Owner Password Credential (ROPG), Implicit, or Client Credential.\n    \n*   ##### Authorization Server\n    \n    Centralized server that contributes to defining the boundaries of a user’s access. For example, your authorization server can control the data, tasks, and features available to a user. An authorization server does not authenticate users. It’s the role of the authentication server to verify a user’s identity.\n    \n\n## B\n\n*   ##### Bad Actors\n    \n    Also known as threat actors. Entity (a person or group) that poses a threat to the business or environment with the intention to cause harm. Harm can constitute physical or cyber damages, from breaking into a data center to hacking into systems with stolen credentials.\n    \n*   ##### Beta\n    \n    Product release stage during which the referenced feature or behavior is provided to subscribers to give them time to explore and adopt new product capabilities while providing final feedback prior to a General Availability (GA) release. Functionality is code-complete, stable, useful in a variety of scenarios, and believed to meet or almost meet quality expectations for a GA release. Beta releases may be restricted to a select number of subscribers (private) or open to all subscribers (public).\n    \n    To learn more, see [Product Release Stages](https://auth0.com/docs/troubleshoot/product-lifecycle/product-release-stages).\n    \n*   ##### Block/Unblock Users\n    \n    Removing or restoring a requestor's access to a resource. Refers to the features from Auth0's Attack Protection suite: Breached Password Detection, Brute-Force Protection, and Suspicious IP Throttling. Each service assesses login/sign-up trends and blocks IP addresses associated with suspicious activity.\n    \n*   ##### Bot Detection\n    \n    Form of attack protection in which Auth0 blocks suspected bot traffic by enabling a CAPTCHA during the login process.\n    \n    To learn more, see [Bot Detection](https://auth0.com/docs/secure/attack-protection/bot-detection).\n    \n*   ##### Breached Password Detection\n    \n    Form of attack protection in which Auth0 notifies your users if they use a username/password combination that has been compromised in a data leak on a third-party website or app.\n    \n    To learn more, see [Breached Password Detection](https://auth0.com/docs/secure/attack-protection/breached-password-detection).\n    \n*   ##### Breaking Change\n    \n    Change to the Auth0 platform that, to Auth0's knowledge, will cause failures in the interoperation of the Auth0 platform and customer applications.\n    \n*   ##### Brute-force Protection\n    \n    Form of attack protection that safeguards against brute-force attacks that occur from a single IP address and target a single user account.\n    \n    To learn more, see [Brute-Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection).\n    \n\n## C\n\n*   ##### Callback\n    \n    URL to which Auth0 sends its response after authentication. It is often the same URL to which a user is redirected after authentication.\n    \n*   ##### Claim\n    \n    Attribute packaged in a security token which represents a claim that the provider of the token is making about an entity.\n    \n*   ##### Client ID\n    \n    Identification value assigned to your application after registration. This value is used in conjunction with other third-party services and can be found in **Auth0 Dashboard** > **Application Settings**.\n    \n*   ##### Client Secret\n    \n    Secret used by a client (application) to authenticate with the Authorization Server; it should be known to only the client and the Authorization Server and must be sufficiently random to not be guessable.\n    \n*   ##### Confidential Client\n    \n    According to the OAuth 2.0 protocol, clients (applications) can be classified as either confidential or public depending on whether or not they are able to hold credentials (such as a client ID and secret) securely. Confidential clients can hold credentials in a secure way without exposing them to unauthorized parties and require a trusted backend server to do so. They can use grant types that require them to authenticate by specifying their client ID and secret when calling the token endpoint and can have tokens issued to them that have been signed either symmetrically or asymmetrically.\n    \n    To learn more, see [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n    \n*   ##### Confused Deputy\n    \n    Situation in which an attacker tricks a client or service into performing an action on their behalf.\n    \n*   ##### Connection\n    \n    Relationship between Auth0 and the sources of users for your applications. Examples include identity providers (such as Google or Active Directory), passwordless authentication methods, or user databases.\n    \n*   ##### Custom Domain\n    \n    Third-party domain with a specialized, or vanity, name. Also known as a CNAME.\n    \n\n## D\n\n*   ##### Deprecation\n    \n    Product release stage indicating that the referenced feature or behavior is not supported for use by new subscribers, is not actively being enhanced, and is being only minimally maintained. Tenants using the feature or behavior at the time of deprecation will continue to have access.\n    \n    To learn more, see [Product Release Stages](https://auth0.com/docs/troubleshoot/product-lifecycle/product-release-stages).\n    \n*   ##### Digital Identity\n    \n    Set of attributes that define a particular user in the context of a function which is delivered by a particular application.\n    \n*   ##### Digital Signature\n    \n    Encrypted string that protects bits in a token from tampering. If the bits are changed or tampered with, the signature will no longer be able to be verified and it will be rejected.\n    \n*   ##### Directory\n    \n    Centralized repository of users (the most well-known of which is Active Directory) which centralizes credentials and attributes and makes it unnecessary for each application to have their own local identity setup and pool of users. Allows single sign on to all applications that use the same directory of users.\n    \n\n## E\n\n*   ##### Early Access\n    \n    Product release stage during which the referenced feature or behavior is provided to a limited number of subscribers or customer development partners (CDPs) to give them the opportunity to test and provide feedback on future functionality. At this stage, functionality may not be complete, but is ready for validation.\n    \n    To learn more, see [Product Release Stages](https://auth0.com/docs/troubleshoot/product-lifecycle/product-release-stages).\n    \n*   ##### End of Life\n    \n    Product release stage indicating that the referenced feature or behavior is removed from the platform. Continued use of the feature or behavior will likely result in errors. The new behavior will automatically be enabled for Tenants that did not opt in during the migration window.\n    \n    To learn more, see [Product Release Stages](https://auth0.com/docs/troubleshoot/product-lifecycle/product-release-stages).\n    \n*   ##### End of Life Date\n    \n    Date when access to a feature or behavior is removed from the platform. End Of Life Dates can vary between different plan types.\n    \n    To learn more, see [Product Release Stages](https://auth0.com/docs/troubleshoot/product-lifecycle/product-release-stages).\n    \n\n## F\n\n*   ##### Fine-grained Authorization (FGA)\n    \n    Auth0’s SaaS product that gives individual users access to specific objects or resources within your application.\n    \n*   ##### Flow\n    \n    Processes that can be extended using Actions. Each Flow is made up of one or more Triggers and represents the logical pipeline through which information moves during a single point in the Auth0 journey.\n    \n\n## G\n\n*   ##### General Availability\n    \n    Product release stage during which the referenced feature or behavior is fully functional and available to all subscribers (limited by pricing tier) for production use. If a new release replaces an existing feature, Auth0 provides a period of backward compatibility in accordance with our deprecation policy and informs customers so they have time to adopt the new release.\n    \n    To learn more, see [Product Release Stages](https://auth0.com/docs/troubleshoot/product-lifecycle/product-release-stages).\n    \n*   ##### Group\n    \n    Set of one or more users. In the Auth0 Authorization Extension, use groups to grant access to many users at a time.\n    \n\n## I\n\n*   ##### ID Token\n    \n    Credential meant for the client itself, rather than for accessing a resource. It has a fixed format that clients can parse and validate.\n    \n    To learn more, see [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens).\n    \n*   ##### Identity Provider (IdP)\n    \n    Service that stores and manages digital identities. Auth0 supports trusted social, enterprise, and legal identity providers. Auth0 also can function as an identity provider for your applications.\n    \n\n## J\n\n*   ##### JSON Web Token (JWT)\n    \n    Open, industry standard [RFC 7519](https://tools.ietf.org/html/rfc7519) method for representing claims securely between two parties. At Auth0, ID Tokens are always returned in JWT format, and Access Tokens are often in JWT format. You may decode well-formed JWTs at [JWT.io](https://jwt.io/) to view their claims.\n    \n    To learn more, see [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens).\n    \n\n## L\n\n*   ##### Localization\n    \n    Ability to render the New Universal Login experience into a supported language.\n    \n*   ##### Lock\n    \n    Auth0's UI widget for authenticating users. It is ready to go as-is and is the default face of the Classic Universal Login experience. Lock allows you to customize minor behavioral and appearance options, but its primary goal is ease of use.\n    \n\n## M\n\n*   ##### Management API\n    \n    Auth0's API to manage Auth0 services and perform administrative tasks programatically.\n    \n*   ##### Metadata\n    \n    Information users can update, such as preferences or profile settings. Metadata is added to ID tokens and can be stored in user profiles.\n    \n*   ##### Migration\n    \n    Process by which a customer moves away from a particular feature or behavior. Migrations should occur during the Deprecation product release stage.\n    \n*   ##### Multi-factor authentication (MFA)\n    \n    Authentication process that considers multiple factors. Typically at Auth0, the first factor is the standard username/password exchange, and the second is a code or link via email or SMS, a one-time-password via an app such as Authy or Google Authenticator, or a push notification via a phone app such as Guardian or Duo. Using multiple factors allows your account to remain secure if someone captures one or the other factor--acquires your password or steals your phone, for example.\n    \n    To learn more, see [Multi-factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication).\n    \n\n## N\n\n*   ##### Nonce\n    \n    Arbitrary (often random or pseudo-random) number issued in an authentication protocol that can be used to help detect and mitigate replay attacks using old communications. In other words, the nonce is only issued once, so if an attacker attempts to replay a transaction with a different nonce, its false transaction can be detected more easily.\n    \n    To learn more, see [Mitigate Replay Attacks When Using the Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow).\n    \n\n## O\n\n*   ##### OAuth 2.0\n    \n    Authorization framework that defines authorization protocols and workflows. OAuth 2.0 defines roles, authorization grants (or workflows), authorization requests and responses, and token handling. OpenID Connect (OIDC) protocols to verify user identity extends OAuth 2.0.\n    \n    To learn more, see [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth).\n    \n*   ##### OpenID\n    \n    Open standard for authentication that allows applications to verify users are who they say they are without needing to collect, store, and therefore become liable for a user’s login information.\n    \n    To learn more, see [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol).\n    \n*   ##### Organizations\n    \n    Auth0 product that allows B2B customers to categorize end-users and define specific roles, login experience, and access to resources.\n    \n    To learn more, see [Organizations](https://auth0.com/docs/manage-users/organizations).\n    \n\n## P\n\n*   ##### Passwordless\n    \n    Form of authentication where the first factor is not a password. Instead, it could be a one-time password received by email or SMS, a push notification, or a biometric sensor. Passwordless uses one-time passwords, so users are less susceptible to the typical password-based attacks (e.g., dictionary or credential stuffing) than with traditional username/password logins.\n    \n    To learn more, see [Passwordless](https://auth0.com/docs/authenticate/passwordless).\n    \n*   ##### Perimeter\n    \n    Set of boundaries that encompass a directory, all of its users, and all of the applications which use the directory. In some implementations, this perimeter is a physical location; in others, it is a set of networks or devices connected via VPN.\n    \n*   ##### Product Release Stages\n    \n    Phases that describe how Auth0 stages, releases, and retires product functionality. Product features may not progress through all release stages, and the time in each stage will vary depending on the scope and impact of the feature.\n    \n*   ##### Public Client\n    \n    According to the OAuth 2.0 protocol, clients (applications) can be classified as either confidential or public depending on whether or not they are able to hold credentials (such as a client ID and secret) securely. Public clients cannot hold credentials securely, so should only use grant types that do not require the use of their client secret. ID Tokens issued to them must be signed asymmetrically using a private key (RS256) and verified using the public key corresponding to the private key used to sign the token.\n    \n    To learn more, see [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications).\n    \n\n## R\n\n*   ##### Raw Credential\n    \n    Shared secret or set of information that is agreed upon between the user and the resource that allow the resource to verify the identity of a user.\n    \n*   ##### Refresh Token\n    \n    Special kind of token that can be used to obtain a renewed Access Token. It is useful for renewing expiring Access Tokens without forcing the user to log in again. Using the Refresh Token, you can request a new Access Token at any time until the Refresh Token is blocklisted.\n    \n    To learn more, see [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n    \n*   ##### Refresh Token Rotation\n    \n    Strategy of frequently replacing refresh tokens to minimize vulnerability. With refresh token rotation, every time your application exchanges a refresh token to get a new access token, Auth0 also returns a new refresh token.\n    \n*   ##### Relying Party\n    \n    Entity (such as a service or application) that depends on a third-party identity provider to authenticate a user.\n    \n*   ##### Resource Owner\n    \n    Entity (such as a user or application) capable of granting access to a protected resource.\n    \n*   ##### Resource Server\n    \n    Server hosting protected resources. Resource servers accept and respond to protected resource requests.\n    \n*   ##### Role\n    \n    Aspect of a user’s identity assigned to the user to indicate the level of access they should have to the system. Roles are essentially collections of permissions.\n    \n    To learn more, see [Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/rbac).\n    \n\n## S\n\n*   ##### Scope\n    \n    Mechanism that defines the specific actions applications can be allowed to do or information that they can request on a user’s behalf. Often, applications will want to make use of the information that has already been created in an online resource. To do so, the application must ask for authorization to access this information on a user’s behalf. When an app requests permission to access a resource through an authorization server, it uses the Scope parameter to specify what access it needs, and the authorization server uses the Scope parameter to respond with the access that was actually granted.\n    \n    To learn more, see [Scopes](https://auth0.com/docs/get-started/apis/scopes).\n    \n*   ##### Security Assertion Markup Language (SAML)\n    \n    XML-based standardized protocol by which two parties can exchange authentication information without the use of a password.\n    \n    To learn more, see [SAML](https://auth0.com/docs/authenticate/protocols/saml).\n    \n*   ##### Security Token\n    \n    Digitally-signed artifact used to prove that the user was successfully authenticated.\n    \n*   ##### Session Cookie\n    \n    Entity emitted by middleware after it establishes that the token it is receiving is signed, valid, and comes from a trusted source (the identity provider). This entity represents the fact that successful authentication occurred with the identity provider. This cookie prevents this process with tokens from needing to be continually repeated, by allowing the user to be considered authenticated as long as the cookie is present.\n    \n*   ##### Shadow Account\n    \n    Difficult-to-sustain practice of manually provisioning a user from a local directory separately in a remote directory (essentially creating a copy, or shadow, of the original account) when they need access to remote applications.\n    \n*   ##### Signing Algorithm\n    \n    Hashing algorithm used to digitally sign tokens to ensure the token has not been tampered with by bad actors.\n    \n*   ##### Single Sign-On (SSO)\n    \n    Service that, after a user logs into one application, automatically logs that user in to other applications, regardless of the platform, technology, or domain the user is using. The user signs in only one time (hence the name of the feature). Similarly, Single Logout (SLO) occurs when, after a user logs out from one application, they are logged out of each application or service where they were logged in. SSO and SLO are possible through the use of sessions.\n    \n    To learn more, see [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on).\n    \n*   ##### Subscription\n    \n    Agreement that defines the features and quotas available for each of your tenants. Auth0 has multiple subscription levels to meet the needs of different developers and organizations.\n    \n*   ##### Suspicious IP Throttling\n    \n    Form of attack protection that protects your tenant against suspicious logins targeting too many accounts from a single IP address.\n    \n\n## T\n\n*   ##### Tenant\n    \n    At Auth0, a logically-isolated group of users who share common access with specific privileges to a single software instance. No tenant can access the data of another tenant, even though multiple tenants might be running on the same machine. Tenant, in general, is a term borrowed from software multitenant architecture.\n    \n*   ##### Token Endpoint\n    \n    Endpoint on the Authorization Server that is used to programmatically request tokens.\n    \n*   ##### Trigger\n    \n    Event that automatically invokes an Action when a specific operation, such as a user logging in, occurs at runtime. Some Triggers are executed synchronously, blocking the Flow in which they are involved, and some are executed asynchronously.\n    \n*   ##### Trust\n    \n    Resource trusts an identity provider or authority when that resource is willing to believe what the authority says about its users.\n    \n\n## U\n\n*   ##### Universal Login\n    \n    Auth0’s implementation of the authentication flow, which is the key feature of an Authorization Server. Each time a user needs to prove their identity, your [applications](https://auth0.com/docs/get-started/applications) redirect to Universal Login, and Auth0 will do what’s needed to guarantee the user’s identity.\n    \n    To learn more, see [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login).\n    \n\n## W\n\n*   ##### Web Service Federation (WS-Fed)\n    \n    Protocol for managing user identities between systems, domains, and identity providers with established trust using WS-Trust. This protocol is mainly used for Microsoft products and defines policies on how to share federation metadata.",
  "title": "Identity Glossary",
  "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps",
  "markdown": "# Register Machine-to-Machine Applications\n\nTo integrate Auth0 with a machine-to-machine (M2M) application, you must first register your app with Auth0 using the Auth0 Dashboard. These apps may include non-interactive apps, such as command-line tools, daemons, IoT devices, or services running on your back-end.\n\nM2M apps are linked to an API and its permissions or [scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes), which are selected from pre-defined values. Make sure you have already [registered the associated API](https://auth0.com/docs/get-started/auth0-overview/set-up-apis) with Auth0 and defined scopes for the API before beginning this registration.\n\nIf you want to authorize your application to access only the Auth0 Management API, you do not need to do anything; the Management API is pre-populated for you.\n\nTo integrate Auth0 with a machine-to-machine (M2M) application, you must first register your app with Auth0 using the Auth0 Dashboard.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click **Create Application**.\n    \n2.  Enter a descriptive name for your application, select **Machine to Machine Applications**, and click **Create**.\n    \n    ![Auth0 Create Application](https://images.ctfassets.net/cdy7uua7fh8z/128mqeFl3vNb1lcyU38pnc/3e9ca9cc08aae6b9ff504b537a350cfb/Screen_Shot_2021-06-03_at_4.15.16_PM.png)\n3.  Select the API you want to be able to call from your application.\n    \n    ![Dashboard Applications Applications Create Application Machine to Machine Application Authorized API Selection](https://images.ctfassets.net/cdy7uua7fh8z/17luDFRWRVXeNiE0BTt2X2/09132c2ee66480b3b8481679db90b1b4/dashboard-applications-applications-create-m2m-authorize-api.png)\n4.  Each M2M app that accesses an API must be granted a set of permissions (or scopes) that should be granted by the authenticated user. To learn how to add permissions, see [Add API Permissions](https://auth0.com/docs/get-started/apis/add-api-permissions). Select the **Permissions** that you want to be issued as part of your application's access token, and click **Authorize**.\n    \n    ![Dashboard Applications Applications Create Machine to Machine Application Select Permissions](https://images.ctfassets.net/cdy7uua7fh8z/26HappX2cn7qKf3WePPJFt/0c4d3fbe253f83a764fdaafc935cd680/dashboard-applications-applications-create-m2m-permissions.png)\n    \n    Once the new application is created, you will be directed to **Application** **Settings** which includes the following tabs:\n    \n    | **Settings Tab** | **Description** |\n    | --- | --- |\n    | **Quick Start** | Shows all the available examples for ${application\\_type} applications. It also shows you how you can call your API using various technologies. To learn how to accept and validate Access Tokens in your API, see our [Backend/API Quickstarts](https://auth0.com/docs/quickstart/backend). |\n    | **Settings** | Shows all available settings for your application. By default, most of the settings will be created for you. |\n    | **Credentials** | Shows the application’s authentication method and configured credentials. To learn more, read [Application Credentials](https://auth0.com/docs/secure/application-credentials) |\n    | **APIs** | Allows you to authorize additional APIs for use with your Application. |\n    \n    To learn more, read [Application Settings](https://auth0.com/docs/get-started/applications/application-settings).\n\n## Next steps\n\nOnce you have registered and configured your application, some common next steps are:\n\n*   Configure a connection and enable it for your application.\n    \n*   Modify your app code to use your Auth0-registered application. See our [Auth0 Quickstarts](https://auth0.com/docs/quickstarts), where you'll find detailed instructions and samples for a variety of technologies. You'll also learn how to implement login and logout, handle your user sessions, retrieve and display user profile information, and more.\n    \n*   Use [Auth0 APIs](https://auth0.com/docs/api).\n    \n    *   The [Authentication API](https://auth0.com/docs/api/authentication) handles all primary identity-related functions (for example, login, logout, and get user profile). Most users consume this API through our Quickstarts, the [Auth0.js library](https://auth0.com/docs/libraries/auth0js), or the [Lock widget](https://auth0.com/docs/libraries/lock). However, if you are building all of your authentication UI manually, you will have to interact with this API directly.\n        \n    *   The [Management API](https://auth0.com/docs/api/management/v2) allows you to automate various tasks that can also be accessed via the Dashboard in Auth0 (for example: creating users, setting application grant types).\n        \n\n## Learn more\n\n*   [Register APIs](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)\n*   [Create Machine-to-Machine Applications for Testing](https://auth0.com/docs/get-started/apis/create-m2m-app-test)\n*   [Application Settings](https://auth0.com/docs/get-started/applications/application-settings)\n*   [Add API Permissions](https://auth0.com/docs/get-started/apis/add-api-permissions)\n*   [Delete API Permissions](https://auth0.com/docs/get-started/apis/delete-api-permissions)",
  "title": "Register Machine-to-Machine Applications",
  "description": "Learn how to register and configure a machine-to-machine (M2M) application using the Auth0 Dashboard and authorize it using the Management API test feature. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps",
  "markdown": "# Register Regular Web Applications\n\nTo integrate Auth0 with a regular web app, you must first register your app with Auth0 using the Auth0 Dashboard. These apps may include traditional web apps that perform most of their application logic on the server (for example, Express.js, ASP.NET).\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click **Create Application**.\n    \n2.  Enter a descriptive name for your application, select **Regular Web Applications**, and click **Create**.\n    \n    ![Auth0 Create Application](https://images.ctfassets.net/cdy7uua7fh8z/128mqeFl3vNb1lcyU38pnc/3e9ca9cc08aae6b9ff504b537a350cfb/Screen_Shot_2021-06-03_at_4.15.16_PM.png)\n    \n    Once the new application is created, you will be directed to **Application** **Settings** which includes the following tabs:\n    \n    | **Settings Tab** | **Description** |\n    | --- | --- |\n    | **Quick Start** | Shows all the available documentation for your application type. |\n    | **Settings** | Shows all available settings for your application. By default, most of the settings will be created for you. To learn more, read [Application Settings](https://auth0.com/docs/get-started/dashboard/application-settings). |\n    | **Credentials** | Shows the application’s authentication method and configured credentials. To learn more, read [Application Credentials](https://auth0.com/docs/secure/application-credentials) |\n    | **Add-ons** | Allows you to enable plugins associated with an application. These are SAML or WS-Fed web apps for which Auth0 generates access tokens. To learn more, read [Enable SAML2 Web App Addon](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon) and [Configure WS-Fed Applications](https://auth0.com/docs/protocols/configure-ws-fed-applications). |\n    | **Connections** | Allows you to enable connections for your application. Connections are sources of users; they can be enabled and shared between multiple applications. To learn more, read [Connections](https://auth0.com/docs/connections). |\n    | **Organizations** | Allows you to authenticate users into organizations to which they belong. To learn more, read [Organizations](https://auth0.com/docs/organizations). |\n    \n    To learn more, read [Application Settings](https://auth0.com/docs/get-started/applications/application-settings).\n3.  Scroll down and locate the **Trust Token Endpoint IP Header** setting, enable it, and click **Save Changes**. When enabled, this protects against brute-force attacks.\n    \n\n## Next steps\n\nOnce you have registered and configured your application, some common next steps are:\n\n*   Configure a connection and enable it for your application.\n    \n*   Modify your app code to use your Auth0-registered application. See our [Auth0 Quickstarts](https://auth0.com/docs/quickstarts), where you'll find detailed instructions and samples for a variety of technologies. You'll also learn how to implement login and logout, handle your user sessions, retrieve and display user profile information, and more.\n    \n*   Use [Auth0 APIs](https://auth0.com/docs/api).\n    \n    *   The [Authentication API](https://auth0.com/docs/api/authentication) handles all primary identity-related functions (for example, login, logout, and get user profile). Most users consume this API through our Quickstarts, the [Auth0.js library](https://auth0.com/docs/libraries/auth0js), or the [Lock widget](https://auth0.com/docs/libraries/lock). However, if you are building all of your authentication UI manually, you will have to interact with this API directly.\n        \n    *   The [Management API](https://auth0.com/docs/api/management/v2) allows you to automate various tasks that can also be accessed via the Dashboard in Auth0 (for example: creating users, setting application grant types).\n        \n\n## Learn more\n\n*   [Application Settings](https://auth0.com/docs/get-started/applications/application-settings)\n*   [Regular Web Applications with Single Sign-On](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps)",
  "title": "Register Regular Web Applications",
  "description": "Learn how to register and configure a regular web application using the Auth Dashboard. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications",
  "markdown": "# First-Party and Third-Party Applications\n\nApplications can be classified as either first-party or third-party, which refers to the ownership of the application. The main difference relates to who has administrative access to your Auth0 domain.\n\n## First-party applications\n\nFirst-party applications are those controlled by the same organization or person who owns the Auth0 domain. For example, let's say you created both a Contoso API and an application that logs into `contoso.com` and consumes the Contoso API. You would register both the API and application under the same Auth0 domain, and the application would be a first-party application. By default, all applications created via the [Auth0 Dashboard](https://manage.auth0.com/#/applications) are first-party applications.\n\n## Third-party applications\n\nThird-party applications are controlled by someone who most likely should not have administrative access to your Auth0 domain. Third-party applications enable external parties or partners to securely access protected resources behind your API. An example of this is with Facebook, let's say you created an application to get a client ID and secret to integrate with your service. That application is considered third-party because it is not owned by Facebook but a third-party that wants to integrate with Facebook APIs and services.\n\nAll applications created through [Dynamic Client Registration](https://auth0.com/docs/get-started/applications/dynamic-client-registration) will be third-party. Third-party applications cannot be created using the Dashboard, but must be created through the Auth0 Management API by setting `is_first_party` to `false`.\n\nThird-party applications have the following unique characteristics:\n\n*   **User Consent**: You must require user consent when consuming APIs because anyone can create an application. Requiring the user to provide consent improves security.\n    \n*   **ID Tokens**: [ID tokens](https://auth0.com/docs/secure/tokens/id-tokens) generated for third-party applications hold only minimum user profile information.\n    \n*   **Connections**: You can only use tenant-level connections or domain connections. For more information, see [Enable Third-party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications).\n    \n\n## Learn more\n\n*   [Update Application Ownership](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/update-application-ownership)\n*   [Check if Application is Confidential or Public](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/view-application-type)\n*   [User Consent and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications)",
  "title": "First-Party and Third-Party Applications",
  "description": "Describes the difference between confidential and public application types.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/create-applications/single-page-web-apps",
  "markdown": "# Register Single-Page Web Applications\n\nTo integrate Auth0 with a single-page web app, you must first register your app with Auth0 using the Dashboard.\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click **Create Application**.\n    \n2.  Enter a descriptive name for your application, select **Single-Page Web Applications**, and click **Create**.\n    \n    ![Auth0 Create Application](https://images.ctfassets.net/cdy7uua7fh8z/128mqeFl3vNb1lcyU38pnc/3e9ca9cc08aae6b9ff504b537a350cfb/Screen_Shot_2021-06-03_at_4.15.16_PM.png)\n    \n    Once the new application is created, you will be directed to **Application** **Settings** which includes the following tabs:\n    \n    | **Settings Tab** | **Description** |\n    | --- | --- |\n    | **Quick Start** | Shows all the available documentation for your application type. |\n    | **Settings** | Shows all available settings for your application. By default, most of the settings will be created for you. To learn more, read [Application Settings](https://auth0.com/docs/get-started/dashboard/application-settings). |\n    | **Credentials** | Shows the application’s authentication method and configured credentials. To learn more, read [Application Credentials](https://auth0.com/docs/secure/application-credentials) |\n    | **Add-ons** | Allows you to enable plugins associated with an application. These are SAML or WS-Fed web apps for which Auth0 generates access tokens. To learn more, read [Enable SAML2 Web App Addon](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon) and [Configure WS-Fed Applications](https://auth0.com/docs/protocols/configure-ws-fed-applications). |\n    | **Connections** | Allows you to enable connections for your application. Connections are sources of users; they can be enabled and shared between multiple applications. To learn more, read [Connections](https://auth0.com/docs/connections). |\n    | **Organizations** | Allows you to authenticate users into organizations to which they belong. To learn more, read [Organizations](https://auth0.com/docs/organizations). |\n    \n    To learn more, read [Application Settings](https://auth0.com/docs/get-started/applications/application-settings).\n\n## Next steps\n\nOnce you have registered and configured your application, some common next steps are:\n\n*   Configure a connection and enable it for your application.\n    \n*   Modify your app code to use your Auth0-registered application. See our [Auth0 Quickstarts](https://auth0.com/docs/quickstarts), where you'll find detailed instructions and samples for a variety of technologies. You'll also learn how to implement login and logout, handle your user sessions, retrieve and display user profile information, and more.\n    \n*   Use [Auth0 APIs](https://auth0.com/docs/api).\n    \n    *   The [Authentication API](https://auth0.com/docs/api/authentication) handles all primary identity-related functions (for example, login, logout, and get user profile). Most users consume this API through our Quickstarts, the [Auth0.js library](https://auth0.com/docs/libraries/auth0js), or the [Lock widget](https://auth0.com/docs/libraries/lock). However, if you are building all of your authentication UI manually, you will have to interact with this API directly.\n        \n    *   The [Management API](https://auth0.com/docs/api/management/v2) allows you to automate various tasks that can also be accessed via the Dashboard in Auth0 (for example: creating users, setting application grant types).\n        \n\n## Learn more\n\n*   [Application Settings](https://auth0.com/docs/get-started/applications/application-settings)\n*   [Authenticate Single-Page Apps With Cookies](https://auth0.com/docs/manage-users/cookies/spa-authenticate-with-cookies)\n*   [Get Management API Access Tokens for Single-Page Applications](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-tokens-for-single-page-applications)",
  "title": "Register Single-Page Web Applications",
  "description": "Learn how to register a single-page web application (SPA) using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/create-tenants/create-multiple-tenants",
  "markdown": "# Create Multiple Tenants\n\nYou can configure multiple tenants to create [different environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments) in the Auth0 Dashboard to allow for complex configurations. For example, you could have two separate domains (one internal and one public-facing), or you may want users to log in differently for different applications. The way to accomplish this is to create more than one Auth0 tenant to allow you to have separate sets of applications, connections, and users for the applications and groups of users that you need to support.\n\n1.  Go to the [Auth0 Dashboard](https://manage.auth0.com/#/), select your tenant name, and select **Create Tenant**.\n    \n    ![Dashboard Tenant Drop-Down Menu Create Tenant](https://images.ctfassets.net/cdy7uua7fh8z/53KetqhNIGDs6N5cqJdQtz/a8ab19657d5070e1d3c121c3ad8d18d4/dashboard-tenant-drop-down-menu.png)\n2.  Enter your desired **Tenant Domain**, select a **Region**, and select **Create**.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3aqUs6NTb69YhxZt0lpL4f/4c143e071a08cd7a8052b5e4db46e7da/image-20240621-221859.png)\n\n## Learn more\n\n*   [Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture)\n*   [Set Up Multiple Environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments)\n*   [Delete or Reset Tenants](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/delete-or-reset-tenant)\n*   [Multi-Tenant Applications Best Practices](https://auth0.com/docs/get-started/auth0-overview/create-tenants/multi-tenant-apps-best-practices)\n*   [Tenant Settings](https://auth0.com/docs/get-started/tenant-settings)",
  "title": "Create Multiple Tenants",
  "description": "Describes how to create an additional tenant using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/credentials",
  "markdown": "# Credential Settings\n\nOn the [Applications](http://manage.auth0.com/#/applications) page of the Dashboard, locate your application in the list, and click its name to view the available settings. Switch to the **Credentials** tab.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/lKxreQAhE83LAheDkKrxA/1ea8c9fe5b758035d8f25b67c0f22a0a/defaultapp.png)\n\n## Authentication Methods\n\nAuth0 offers the following ways your application can authenticate with the authorization server: \n\n*   **Private Key JWT**: An asymmetric authentication method for confidential applications. In Private Key JWT, you generate a pair of keys, public and private, to use as credentials. You provide the public key and securely store the private key in your own system without sharing it with Auth0. You use the private key to sign the request sent to the authorization server. You can manage the public keys below in the **Available Credentials** section.\n    \n*   **Client Secret:** A symmetrical authentication method. In Client Secret authentication, you provide the Client Secret Auth0 assigned when you created the application. You can view and copy the `client_secret` directly from this section.\n    \n    *   **Client Secret (Basic)**: Use Basic for a confidential application using the `HTTP BASIC` authentication scheme to send a Client Secret.\n        \n    *   **Client Secret (Post)**: Use Post for a confidential application using request body parameters to send a Client Secret.\n        \n\nTo learn more about authentication methods and associated credentials, read [Application Credentials](https://auth0.com/docs/secure/application-credentials).\n\n## Available Credentials\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7vzjXXZ0A9pDj5qsXmOTwh/92145467ac0bb5285177383dde8bb017/availablecredentials.png)\n\n**Add New Credential**: Adds a new entry to the list if you have not reached the max number of credentials (2) for the application.\n\n*   **Name**: Name of the credential. For example: 4096.\n    \n*   **Key ID**: Unique Auth0-generated credential identifier. The same credential can’t be uploaded more than once.\n    \n*   **Algorithm**: Algorithm you select for each credential. We support RS256, PS256, and RS384.\n    \n*   **Expires At**: `datetime` when the credential is invalid for the declared use. The credential will not be deleted, but will be inoperable. This can be configured in the UI by enabling the **Set an explicit expiry date for this credential** checkbox.\n    \n\nChoose the side menu to enable, disable, or delete credentials.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/4f2Q0fWWidhm8rKr75Ue2G/b8e27f34a5e3557550b8fa642948f606/availablecredentials2.png)![](https://images.ctfassets.net/cdy7uua7fh8z/5AHW1oTLRMKwgv4mHjp3OY/c0d0688c0c40f66c51569baf2e0ddb00/availablecredentials3.png)\n\n## Rotate client secret\n\nYou may need to occasionally rotate your application’s client secret. To learn more, read [Rotate Client Secrets](https://auth0.com/docs/get-started/applications/rotate-client-secret).\n\n## Learn more\n\n*   [Application Credentials](https://auth0.com/docs/secure/application-credentials)\n*   [Authenticate with Private Key JWT](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt)\n*   [Rotate Credentials](https://auth0.com/docs/get-started/applications/rotate-credentials)\n*   [Configure Private Key JWT Authentication](https://auth0.com/docs/get-started/applications/configure-private-key-jwt)",
  "title": "Credential Settings",
  "description": "Describes the settings related to credentials tab available in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/create-tenants/multi-tenant-apps-best-practices",
  "markdown": "# Multi-Tenant Applications Best Practices\n\nMulti-tenancy is an architectural approach featuring a single instance of software that runs on a server and is accessible by multiple groups of users. With multi-tenancy, you can segment users with shared characteristics into groups and grant them separate permissions and levels of access to your application. This allows you to create and maintain tailored experiences for different customers, business units, or other defined groups of users.\n\nIn Auth0, the best method for implementing multi-tenancy is [Auth0 Organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview). If necessary, other legacy solutions can be used to accommodate distinct business use cases. If you offer a [business-to-business (B2B)](https://auth0.com/docs/get-started/architecture-scenarios/business-to-business) product or service, setting up multi-tenancy for your business users may be beneficial for your use case.\n\nThe sections below outline the options available for implementing multi-tenancy in Auth0.\n\n## Auth0 Organizations\n\nFor most multi-tenant use cases, Auth0 Organizations is the ideal solution for you and your users. Auth0 Organizations supports business-to-business (B2B) implementations that have one or more applications that end-users can access.\n\nCommon features of B2B implementations include:\n\n*   A product that is licensed to another business for use by their employees.\n    \n*   Multiple organizations that require their own federation and lightweight branding of the authentication experience.\n    \n*   Separate levels of application access for different groups of users.\n    \n\nWith Auth0 Organizations, you can create unique groups of users and tailor their experiences with [role-based access control](https://auth0.com/docs/manage-users/access-control/rbac), [customized login pages and email templates](https://auth0.com/docs/manage-users/organizations/create-first-organization#customize-prompts-and-email-templates), and more.\n\nTo learn more about using Auth0 Organizations to implement multi-tenancy, review [Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture).\n\n## Legacy solutions\n\nIf Auth0 Organizations does not satisfy the requirements of your use case, please reach out to our [Professional Services](https://auth0.com/docs/get-started/professional-services) team to develop a solution that ensures your success.\n\nSome legacy solutions include:\n\n*   Using an Auth0 connection to represent each tenant.\n    \n*   Using an Auth0 application to represent each tenant.\n    \n*   Using an Auth0 tenant to represent each tenant.\n    \n*   Storing tenant details in the user's profile.\n    \n\n### Use Auth0 connections\n\nYou can represent each of your tenants with a separate Auth0 connection.\n\nThis approach allows you to support scenarios where:\n\n*   You have different connection-level requirements, such as varying password policies, for each of your tenants.\n    \n*   You have user pools from different connections. For example, one tenant could require users to provide username/password credentials, while another tenant could require users to log in through an enterprise IdP.\n    \n\nTo prompt a user to log in through a specific connection, call the [Auth0 Authentication API Login endpoint](https://auth0.com/docs/api/authentication#login), and include the `connection` parameter.\n\n### Use Auth0 applications\n\nYou can represent each of your tenants with a separate Auth0 application.\n\nThis approach allows you to uniquely configure each Auth0 application based on varying tenant requirements, such as available connections.\n\nYou'll need to track the tenants to which your users belong within your application. When a logs into your application, you'll need to read that information, and direct the user to the appropriate Auth0 application to complete authentication.\n\nTo enable a connection for multiple applications with the Auth0 Management API, call the [Update a Connection endpoint](https://auth0.com/docs/api/management/v2/#!/Connections/patch_connections_by_id), and pass the relevant Client IDs to the `enabled_clients` parameter.\n\n### Use Auth0 tenants\n\nYou can represent each of your tenants with a separate Auth0 tenant.\n\nThis approach allows you to share access to the Auth0 Dashboard with users, restricted by tenant, but requires you to configure Auth0 individually for each tenant.\n\nThis means that, in addition to managing the features of each Auth0 tenant individually (such as Branding, Actions, and Attack Protection), your application will have to support multiple Auth0 configurations.\n\n### Store tenant details in the user's profile\n\nYou can store tenant details in the user's profile and have your application read that information after the user logs in.\n\nThis approach allows all of your users, regardless of which tenant to which they belong to, to log in using in a uniform configuration (such as available connections).\n\nTo implement this, you could store tenant details in the user's Auth0 profile in the `app_metadata` object, using an identifier of your choice (for example, `\"tenant\": \"customer-group-12345\"`). After the user logs in, your application retrieves the `tenant` variable, and then displays a version appropriate to the returned value.",
  "title": "Multi-Tenant Applications Best Practices",
  "description": "Describes best practices for how to use Auth0 to secure your multi-tenant applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/confidential-and-public-applications",
  "markdown": "# Confidential and Public Applications\n\nAccording to the [OAuth 2.0 specification](https://tools.ietf.org/html/rfc6749#section-2.1), applications can be classified as either confidential or public. The main difference relates to whether or not the application is able to hold credentials (such as a client ID and secret) securely. This affects the type of authentication the applications can use.\n\nWhen you create an application using the Dashboard, Auth0 will ask you what Auth0 application type you want to assign to the new application and use that information to determine whether the application is confidential or public.\n\nTo learn more, read [Check if Application is Confidential or Public](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/view-application-type).\n\n## Confidential applications\n\nConfidential applications can hold credentials in a secure way without exposing them to unauthorized parties. They require a trusted backend server to store the secret(s).\n\n### Grant types\n\nConfidential applications use a trusted backend server and can use grant types that require specifying their Client ID and Client Secret (or alternative registered credentials) for authentication when calling the Auth0 Authentication API [Get Token](https://auth0.com/docs/api/authentication#get-token) endpoint. Confidential applications can use Client Secret Post, Client Secret Basic, or [Private Key JWT](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt) authentication methods.\n\nThese are considered confidential applications:\n\n*   A web application with a secure backend that uses the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow), [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow), or Resource Owner Password Flow with realm support\n    \n*   A machine-to-machine (M2M) application that uses the [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow)\n    \n\n### ID tokens\n\nBecause confidential applications are capable of holding secrets, you can have ID tokens issued to them that have signed in one of two ways:\n\n*   Symmetrically, using their client secret (`HS256`)\n    \n*   Asymmetrically, using a private key (`RS256`)\n    \n\n## Public applications\n\nPublic applications **cannot** hold credentials securely.\n\n### Grant types\n\nPublic applications can only use grant types that do not require the use of their client secret. They can't send a client secret because they can't maintain the confidentiality of the credentials required.\n\nThese are public applications:\n\n*   A native desktop or mobile application that uses the [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)\n    \n*   A JavaScript-based client-side web application (such as a single-page app) that uses the [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post) grant\n    \n\n### ID tokens\n\nBecause public applications are unable to hold secrets, [ID tokens](https://auth0.com/docs/secure/tokens/id-tokens) issued to them must be:\n\n*   Signed asymmetrically using a private key (`RS256`)\n    \n*   Verified using the public key corresponding to the private key used to sign the token\n    \n\n## Learn more\n\n*   [Check if Application is Confidential or Public](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/view-application-type)\n*   [First-Party and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications)\n*   [User Consent and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications)",
  "title": "Confidential and Public Applications",
  "description": "Describes the difference between confidential and public application types.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/deploy-monitor/monitor/monitor-applications",
  "markdown": "# Monitor Applications\n\nYour applications and services depend on Auth0. Monitoring Auth0's health lets you report specific errors to customers or reduce user impact in case there's an issue with Auth0.\n\nThere's many ways to monitor Auth0 and each approach complements the others. You should pick based on your needs and investment possibilities.\n\n## Synthetic transactions\n\nThe simplest approach to monitor Auth0:\n\n*   Set up a periodic request to perform an authentication transaction.\n    \n*   If the request succeeds, Auth0 is working fine.\n    \n*   If the request fails, this may indicate:\n    \n    *   an issue with Auth0\n        \n    *   an issue specific to the tenant used for the synthetic transaction\n        \n    *   or just a single failed request.\n        \n\nFor synthetic transactions, use an environment as close to your production tenant configuration as possible. You may potentially even use the same production tenant. Since setting up synthetic transactions with redirect flows and third party providers can be tricky, using the [Resource Owner Password Grant](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/call-your-api-using-resource-owner-password-flow) is recommended. This flow doesn't involve browser redirects or require a UI.\n\nIf you are using [rules](https://auth0.com/docs/customize/rules) or [custom database connection(s)](https://auth0.com/docs/connections/database/custom-db) or other extensibility points, the synthetic transaction(s) should be configured to utilize the rules and/or custom DB scripts to ensure that aspect of the system is working.\n\nTools like [Pingdom](http://pingdom.com/) make setting up synthetic transactions a simple thing.\n\n### Check period\n\nWe recommend running synthetic transactions on one minute intervals. With this simple approach, that frequency won't consume a lot of your Auth0 rate limit quota, while also providing timely responses.\n\n### Limitations of synthetic transactions\n\nSynthetic transactions are a simple and inexpensive way monitoring an Auth0 tenant's health. However, they do have some limitations:\n\n*   Synthetic transactions do not represent your end user's experience. Instead they give you a proxy metric for them.\n    \n*   Synthetic transactions might not use the same flows as your users.\n    \n*   They lack atomicity (typically run once a minute) and do not report on errors your end users might have seen.\n    \n\nIf you are interested in getting more granular data read about [Error Tracking](#error-tracking) and [Metrics and Logs](#metrics-and-logs).\n\n## Error tracking\n\nThis approach is useful to track errors in existing calls to Auth0. It involves reporting errors whenever a call to Auth0 fails. [Sentry](https://sentry.io/) is a tool commonly used for these cases, which works both on frontend and backend scenarios.\n\nThis approach is useful because it allows you to know about real errors that your end users are experiencing. However, because you are only tracking errors (and not all requests) it is not possible to get an accurate perception of \"how many\" end users are affected: is it 1% or 5%? It also doesn't require you to set up a separate \"synthetic call\", which might consume part of your rate limit quota, especially if misconfigured.\n\n## Metrics and logs\n\nThis approach is useful if calls to Auth0 are performed from a backend you control. This is the case for:\n\n*   Most calls to [Auth0's Management API](https://auth0.com/docs/api/management/v2)\n    \n*   Calls to the [Authentication API](https://auth0.com/docs/api/authentication) from Regular Web Applications and Machine-to-machine applications ([learn more about client types](https://auth0.com/docs/get-started/applications)).\n    \n\nThe approach consists of using metrics and/or logs to track error rates on calls to Auth0. Metrics/logs report error rates that accurately describe what end users are experiencing, without requiring you to set up a separate \"synthetic call\", which might consume part of your rate limit quota, especially if misconfigured.\n\n## Alerting\n\nRegardless of the monitoring approaches you use, it's common to get an alert or page when errors happen at a particular rate. That rate depends on your application.\n\nWhen your team gets an alert from Auth0, we recommend adding a link to [Check Auth0 Status](https://auth0.com/docs/deploy-monitor/monitor/check-auth0-status) to the alert payload/playbook. This will allow them to quickly check Auth0's official status reporting channel to see if the issue is coming from Auth0 or your application/service.\n\n## Learn more\n\n*   [Check Auth0 Status](https://auth0.com/docs/deploy-monitor/monitor/check-auth0-status)\n*   [Check External Services Status](https://auth0.com/docs/deploy-monitor/monitor/check-external-services-status)\n*   [Monitor Auth0 Using System Center Operations Manager](https://auth0.com/docs/deploy-monitor/monitor/monitor-using-scom)",
  "title": "Monitor Applications",
  "description": "Your applications depend on Auth0. Monitoring Auth0's health lets you report errors or reduce user impact in case there's an issue with Auth0. Learn more.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/wildcards-for-subdomains",
  "markdown": "# Subdomain URL Placeholders\n\nYou can use various placeholders to act as dynamic text entries in your URLs.\n\n## How URL evaluation works\n\nA URL containing an `{organization_name}` placeholder will only be evaluated when all the following the conditions are met:\n\n*   The application has the `organization_usage` set to `allow` or `require`\n    \n*   A transaction was performed in the context of an organization (for example, initiating an authorization transaction with the organization parameter: `/authorize?organization=org_bVss9Do3994SIbiH&…`)\n    \n\nURLs with the `{organization_name}` placeholder will be evaluated in addition to exact match URLs (`https://app.exampleco.com`) and URLs with wildcards (`https://*.exampleco.com`). You must not rely on any specific order of evaluation of the URLs.\n\nAvoid registering URLs with wildcard and Organization placeholders in the same configuration field for an application as it may lead to undesirable behavior and make troubleshooting difficult. As an example, consider an application with two **Allowed Callback URLs**: `https://*.exampleco.com` and `https://{organization_name}.exampleco.com`. A `redirect_uri` with the value of `https://company-a.exampleco.com` would be considered valid even if there were no Organizations with the name `company-a` registered in your tenant; this is due to the evaluation of the wildcard placeholder.\n\n## Wildcard URL placeholders\n\nWildcard placeholders in subdomains **should not** be used in production applications. Auth0 recommends URLs with the `{organization_name}` placeholder where relevant.\n\nManage these settings in [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) in the following fields:\n\n*   **Allowed Callback URLs**: List of URLs to which Auth0 is allowed to redirect users after they authenticate.\n    \n*   **Allowed Logout URLs**: List of URLs to which you can redirect users after they log out from Auth0.\n    \n*   **Allows Web Origins**: List of URLs from where an authorization request using [Cross-Origin Authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication), [Device Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow), and [web\\_message as the response mode](https://auth0.com/docs/authenticate/protocols/oauth) can originate.\n    \n*   **Allowed Origins (CORS)**: List of URLs that will be allowed to make requests from JavaScript to Auth0 API (typically used with CORS).\n    \n\nAvoid using wildcard placeholders for subdomains in production application callbacks and allowed origins as it can make your application vulnerable to attacks.\n\nYou can use the star symbol (`*`) as a wildcard for subdomains, but it must be used in accordance with the following rules in order to properly function:\n\n*   The protocol of the URL **must** be `http` or `https`. Protocols such as `com.example.app` and `service:jmx:rmi` will not work.\n    \n*   The wildcard **must** be located in a subdomain within the hostname component. `https://*.com` will not work.\n    \n*   The wildcard **must** be located in the subdomain furthest from the root domain. `https://sub.*.example.com` will not work.\n    \n*   The URL **must not** contain more than one wildcard. `https://*.*.example.com` will not work.\n    \n*   A wildcard **may** be prefixed and/or suffixed with additional valid hostname characters. `https://prefix-*-suffix.example.com` will work.\n    \n*   A URL with a valid wildcard **will not** match a URL more than one subdomain level in place of the wildcard. `https://*.example.com` will not work with `https://sub1.sub2.example.com`.\n    \n\n## Organization URL placeholders\n\nYou can use `{organization_name}` as a placeholder to dynamically specify a registered organization’s name in a URL (`https://{organization_name}.exampleco.com`). URLs with the `{organization_name}` placeholder should only be used on domains that you fully control (for example, `https://{organization_name}.exampleco.com` where you control the `exampleco.com` domain).\n\nManage these settings in [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) in the following fields:\n\n*   **Allowed Callback URLs**: List of URLs to which Auth0 is allowed to redirect users after they authenticate.\n    \n*   **Allowed Origins (CORS)**: List of URLs that will be allowed to make requests from JavaScript to Auth0 API (typically used with CORS).\n    \n\nThe following restrictions apply when using the `{organization_name}` placeholder:\n\n*   The protocol of the URL must be `http:` or `https:`. `com.example.app://{organization_name}.exampleco.com` will not work.\n    \n*   The placeholder must be located in a subdomain within the hostname component. `https://{organization_name}` or `https://exampleco.com/{organization_name}` will both not work.\n    \n*   The placeholder must be located in the subdomain furthest from the root domain. `https://sub.{organization_name}.exampleco.com` will not work.\n    \n*   The URL must not contain more than one placeholder. `https://{organization_name}.{organization_name}.exampleco.com` will not work.\n    \n*   A placeholder must not be prefixed nor suffixed with additional valid hostname characters. `https://prefix-{organization_name}-suffix.exampleco.com` will not work.\n    \n*   A placeholder **must not** be used in conjunction with a wildcard in the URL. `https://{organization_name}.*.exampleco.com` will not work.\n    \n\n## Learn more\n\n*   [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications)\n*   [First-Party and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/first-party-and-third-party-applications)\n*   [Enable Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications)",
  "title": "Subdomain URL Placeholders",
  "description": "Describes placeholders, including wildcard and organization placeholders, for subdomains function in application configuration.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/test-database-connections",
  "markdown": "# Test Database Connections\n\nYou can test database connections for applications using the Auth0 Dashboard. The configured database connections can be used to log in to your application.\n\nTo properly test, you should have already [set up your database connection](https://auth0.com/docs/get-started/applications/set-up-database-connections) and [created a user](https://auth0.com/docs/manage-users/user-accounts/create-users) for your database connection.\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database), and select the **Try** arrow next to the connection you want to test.\n    \n    ![Dashboard - Authentication - Database - Database Connections List](https://images.ctfassets.net/cdy7uua7fh8z/1Hf6ctA9xhsLOQO9IyG0VU/027f0e08606445e019731afc22c43d31/Dashboard_-_Authentication_-_Database_-_Database_Connections_List.png)\n2.  Enter your test user's username and password. If you have configured everything correctly, you will see the **It Works!** page:\n    \n    ![Dashboard - Connections - Database - Try - Success](https://images.ctfassets.net/cdy7uua7fh8z/5DWJWLf8zvZJH0rSlhK0cr/f33377edf6f82f17e11e08ec30d8d75a/connection-social-try-success.png)\n\n## Learn more\n\n*   [Set Up Database Connections](https://auth0.com/docs/get-started/applications/set-up-database-connections)",
  "title": "Test Database Connections",
  "description": "Describes how to test database connections for applications using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/enable-sso-for-applications",
  "markdown": "# Enable Single Sign-On Integrations for Applications\n\nBy default, seamless single sign-on (SSO) is enabled for all new Auth0 tenants; however, **legacy tenants** may [choose whether to enable this feature at the tenant level](https://auth0.com/docs/get-started/tenant-settings/enable-sso-for-legacy-tenants). If you have not enabled tenant-level SSO, you may enable it per application.\n\nYou can enable an SSO for your application using the Auth0 Dashboard.\n\n## Prerequisite\n\nBefore enabling SSO for an application, you must first create and configure a connection for each identity provider you want to use. For social identity providers, make sure the connection is not using developer keys if you use the [Universal Login experience](https://auth0.com/docs/authenticate/login/auth0-universal-login).\n\n## Enable SSO\n\n1.  Go to [Auth0 Dashboard > Applications > SSO Integrations](https://manage.auth0.com/#/externalapps), and select the name of the integration to view.\n    \n2.  Scroll to the bottom of the **Settings** page, locate **Use Auth0 instead of the IdP to do Single Sign-on**, enable the toggle, and select **Save Changes**.\n    \n\n## Learn more\n\n*   [Single Sign-On Integrations](https://auth0.com/docs/customize/integrations/sso-integrations)",
  "title": "Enable Single Sign-On Integrations for Applications",
  "description": "Describes how to create a single sign-on (SSO) integration for an application. Only for use with legacy tenants.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-application-metadata",
  "markdown": "# Configure Application Metadata\n\nApplication metadata is optional and consists of customizable keys and values (max 255 characters each), that you can set for each application. Metadata is exposed in the `Client` object as `client_metadata`, and in Rules as `context.clientMetadata`. You might store, for example, the URL for the application’s home page (a field that Auth0 doesn’t provide by default in the application settings).\n\nClient metadata is stored as part of the application (client) properties. To learn more about data types, field names, and storage limitations, read [Metadata Field Names and Data Types](https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data).\n\n#### Where to store client secrets\n\nWhere to store the secret depends on the scope of the secret:\n\n*   Is it just one secret per application? Then `client_metadata` would be a good place.\n    \n*   Is it the same secret for the whole system (i.e., for all applications or many)? Then the rule’s configuration values might be a better choice\n    \n*   Is it a different secret for each user? Then storing in `app_metadata` might be better.\n    \n\nExisting applications will have no value for this property.\n\nYou can access application metadata in [Actions](https://auth0.com/docs/customize/actions):\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.client.metadata.SKIP_VERIFICATION === \"yes\"){\n    return;\n  }\n  // ... continue this Action\n}\n```\n\n... or in [Rules](https://auth0.com/docs/customize/rules):\n\n```\nfunction applicationMetadataExample (user, context, callback){\n  context.clientMetadata = context.clientMetadata || {};\n  if (context.clientMetadata.SKIP_VERIFICATION === \"yes\"){\n    return callback();\n  }\n  // ... continue this Rule\n}\n```\n\nYou can read and add to the application metadata using either the Dashboard or the Management API. To learn how to manage client metadata with the Management API, read [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api).\n\n## Add application metadata key/value pairs\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the application.\n    \n2.  Scroll down and click **Advanced Settings**.\n    \n3.  On the **Application Metadata** tab, enter the key's name and value, then click **Add**.\n    \n    ![Dashboard Applications Applications Settings Tab Advanced Settings Application Metadata Tab](https://images.ctfassets.net/cdy7uua7fh8z/7GWHyQloNihda3fuYiVEWQ/d32531dbb111dc90f491985970da76fe/dashboard-applications-applications-settings-advanced-app-metadata.png)\n4.  Click **Save Changes**.\n    \n\n## Update application metadata value\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the application.\n    \n2.  Scroll down and click **Advanced Settings**.\n    \n3.  On the **Application Metadata** tab, enter the key's name that you want to change and enter a new value, then click **Add**.\n    \n4.  Click **Save Changes**\n    \n\n## Delete application metadata\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select the application.\n    \n2.  Scroll down and click **Advanced Settings**.\n    \n3.  On the **Application Metadata** tab locate the key/value pair you want to delete and click the trash can icon.\n    \n4.  Confirm the deletion.\n    \n5.  Click **Save Changes**.\n    \n\n## Learn more\n\n*   [Metadata Field Names and Data Types](https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data)\n*   [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api)\n*   [Manage Metadata with Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules)\n*   [Rotate Client Secrets](https://auth0.com/docs/get-started/applications/rotate-client-secret)",
  "title": "Configure Application Metadata",
  "description": "Learn how to configure, update, and delete application metadata (client_metadata and clientMetadata)  in the Auth0 Dashboard Applications Advanced Settings.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/revoke-api-access",
  "markdown": "# Revoke Access to APIs Using Application Grants\n\nConfiguring your application grant so that the tokens you issue last for only a short period means that when it comes time for you to revoke access to a protected resource, you can simply delete the grant. At this point, the party with the access token only has a limited period between when you delete the grant and the token's expiration to make additional API requests. Because this is an easy (and safe) option to implement, we recommend you deny access to your APIs and other protected resources by revoking application grants.\n\nIf, for example, you are using a Machine-to-Machine [application](https://auth0.com/docs/get-started/applications) to access your [API](https://auth0.com/docs/get-started/apis) and you have a partner that calls your API, and at the end of your existing contract, you and your partner decide not to renew your partnership. You now want to remove your partner's access to your API. The issue, however, is that you've given your partner an access token that lasts for a month.\n\n*   What can you do in this situation?\n    \n*   How might you configure your Auth0 environment to make such situations easier to handle in the future?\n    \n\n## Application grants\n\nThe main issue in this scenario is the length of time for which the API access token is valid: one month.\n\nBy default, Auth0 issues access tokens that last for 24 hours. Setting the token's lifetime to 24 hours means that your partner must repeat the client credentials exchange (or whichever grant you've implemented) to obtain a new access token every 24 hours. To deny access to your partner due to the expiration of your contract, you can simply delete the application grant so that when their existing token expires, they cannot request a new one.\n\nYou can change the lifetime of a token by setting the `token_lifetime` option. The specific lifetime appropriate to your use case will vary, but we recommend setting this value to be as short as possible. A good starting point for determining this value would be the window you consider allowable for the delay between deleting the grant and final use of the API.\n\n### Delete an application grant\n\nTo delete an application grant, make the appropriate `DELETE` call to the Management API's [Delete an Application Grant endpoint](https://auth0.com/docs/api/management/v2#!/Client_Grants/delete_client_grants_by_id). As part of the call, you'll need to specify the ID of the application grant you want to delete, which you can obtain via the Management API's [Get all Application Grants endpoint](https://auth0.com/docs/api/management/v2#!/Client_Grants/get_client_grants).\n\nYou can also [update an Application's grant types](https://auth0.com/docs/get-started/applications/update-grant-types) through the Auth0 Dashboard.\n\n## Learn more\n\n*   [Data Security](https://auth0.com/docs/secure/security-guidance/data-security)",
  "title": "Revoke Access to APIs Using Application Grants",
  "description": "Understand application grants when it comes to revoking access and handling tokens.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/change-application-signing-algorithms",
  "markdown": "# Change Application Signing Algorithms\n\n##### Change Application Signing Algorithms\n\nStart Building\n\n*   [Quickstarts](https://auth0.com/docs/quickstarts \"Quickstarts\")\n\nLearn the Basics\n\n*   [Identity Fundamentals](https://auth0.com/docs/get-started/identity-fundamentals \"Identity Fundamentals\")\n*   [Auth0 Overview](https://auth0.com/docs/get-started/auth0-overview \"Auth0 Overview\")\n\nConfigure Auth0\n\n*   [Auth0 Teams](https://auth0.com/docs/get-started/auth0-teams \"Auth0 Teams\")\n*   [Tenant Settings](https://auth0.com/docs/get-started/tenant-settings \"Tenant Settings\")\n*   [Applications in Auth0](https://auth0.com/docs/get-started/applications \"Applications in Auth0\")\n*   [Application Settings](https://auth0.com/docs/get-started/applications/application-settings \"Application Settings\")\n*   [Credential Settings](https://auth0.com/docs/get-started/applications/credentials \"Credential Settings\")\n*   [Subdomain URL Placeholders](https://auth0.com/docs/get-started/applications/wildcards-for-subdomains \"Subdomain URL Placeholders\")\n*   [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications \"Confidential and Public Applications\")\n*   [Dynamic Application Registration](https://auth0.com/docs/get-started/applications/dynamic-client-registration \"Dynamic Application Registration\")\n*   [Set Up Database Connections](https://auth0.com/docs/get-started/applications/set-up-database-connections \"Set Up Database Connections\")\n*   [Test Database Connections](https://auth0.com/docs/get-started/applications/test-database-connections \"Test Database Connections\")\n*   [Application Grant Types](https://auth0.com/docs/get-started/applications/application-grant-types \"Application Grant Types\")\n*   [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types \"Update Grant Types\")\n*   [Revoke Access to APIs Using Application Grants](https://auth0.com/docs/get-started/applications/revoke-api-access \"Revoke Access to APIs Using Application Grants\")\n*   [Signing Algorithms](https://auth0.com/docs/get-started/applications/signing-algorithms \"Signing Algorithms\")\n*   [Change Application Signing Algorithms](https://auth0.com/docs/get-started/applications/change-application-signing-algorithms \"Change Application Signing Algorithms\")\n*   [Configure Application Metadata](https://auth0.com/docs/get-started/applications/configure-application-metadata \"Configure Application Metadata\")\n*   [Update Application Connections](https://auth0.com/docs/get-started/applications/update-application-connections \"Update Application Connections\")\n*   [Rotate Credentials](https://auth0.com/docs/get-started/applications/rotate-credentials \"Rotate Credentials\")\n*   [Rotate Client Secrets](https://auth0.com/docs/get-started/applications/rotate-client-secret \"Rotate Client Secrets\")\n*   [Enable Android App Links Support](https://auth0.com/docs/get-started/applications/enable-android-app-links-support \"Enable Android App Links Support\")\n*   [Enable Universal Links Support in Apple Xcode](https://auth0.com/docs/get-started/applications/enable-universal-links-support-in-apple-xcode \"Enable Universal Links Support in Apple Xcode\")\n*   [Configure Cross-Origin Resource Sharing](https://auth0.com/docs/get-started/applications/set-up-cors \"Configure Cross-Origin Resource Sharing\")\n*   [Configure Applications with OIDC Discovery](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery \"Configure Applications with OIDC Discovery\")\n*   [Configure WS-Fed Applications](https://auth0.com/docs/get-started/applications/configure-ws-fed-applications \"Configure WS-Fed Applications\")\n*   [Configure FAPI Compliance](https://auth0.com/docs/get-started/applications/configure-fapi-compliance \"Configure FAPI Compliance\")\n*   [Configure Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/applications/configure-par \"Configure Pushed Authorization Requests (PAR)\")\n*   [Configure JWT-secured Authorization Requests (JAR)](https://auth0.com/docs/get-started/applications/configure-jar \"Configure JWT-secured Authorization Requests (JAR)\")\n*   [Configure mTLS Authentication](https://auth0.com/docs/get-started/applications/configure-mtls \"Configure mTLS Authentication\")\n*   [Configure Private Key JWT Authentication](https://auth0.com/docs/get-started/applications/configure-private-key-jwt \"Configure Private Key JWT Authentication\")\n*   [Remove Applications](https://auth0.com/docs/get-started/applications/remove-applications \"Remove Applications\")\n*   [Test Applications Locally](https://auth0.com/docs/get-started/applications/work-with-auth0-locally \"Test Applications Locally\")\n*   [Enable Single Sign-On Integrations for Applications](https://auth0.com/docs/get-started/applications/enable-sso-for-applications \"Enable Single Sign-On Integrations for Applications\")\n*   [APIs](https://auth0.com/docs/get-started/apis \"APIs\")\n*   [Manage Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access \"Manage Dashboard Access\")\n\nPlan and Design\n\n*   [Authentication and Authorization Flows](https://auth0.com/docs/get-started/authentication-and-authorization-flow \"Authentication and Authorization Flows\")\n*   [Architecture Scenarios](https://auth0.com/docs/get-started/architecture-scenarios \"Architecture Scenarios\")\n*   [Professional Services](https://auth0.com/docs/get-started/professional-services \"Professional Services\")\n\nWas this article helpful?",
  "title": "Change Application Signing Algorithms",
  "description": "Describes how to change an application's signing algorithm using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/update-application-connections",
  "markdown": "# Update Application Connections\n\nYou can change your application's enabled connections using the Auth0 Dashboard.\n\n1.  Go to [Dashboard > Applications](https://manage.auth0.com/#/applications) and click the name of the application to view.\n    \n    ![Dashboard Applications List](https://images.ctfassets.net/cdy7uua7fh8z/1ecNwGgFQZxdP57p0tp3jT/d6796b8b909d0db1d4dd7d5e0487776a/dashboard-applications-applications-list.png)\n2.  Click the **Connections** tab, and enable or disable the appropriate connections for the application.\n    \n\n## Learn more\n\n*   [View Connections](https://auth0.com/docs/authenticate/identity-providers/view-connections)\n*   [Verify Connections](https://auth0.com/docs/troubleshoot/basic-issues/verify-connections)",
  "title": "Update Application Connections",
  "description": "Describes how to update an application's enabled connections using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/enable-universal-links-support-in-apple-xcode",
  "markdown": "# Enable Universal Links Support in Apple Xcode\n\nUniversal links establish a verified relationship between domains and applications, so both your Auth0 Application settings and your iOS application need to be in sync. To do this, you need to provide Auth0 with Apple Team ID and Bundle Identifier. You can enable universal links support for your Auth0-registered application using the Auth0 Dashboard.\n\n## Obtain Apple Team ID and Bundle Identifier\n\n1.  To find your Apple **Team ID**, go to your [Apple developer account summary page](https://developer.apple.com/membercenter/index.action#accountSummary).\n    \n2.  To find your iOS application's **Bundle identifier**, go to its [Xcode project settings](https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/ConfiguringYourApp/ConfiguringYourApp.html) page.\n    \n\n## Provide Apple Team ID and Bundle Identifier to Auth0\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/clients) and select the name of the application to view.\n    \n    ![Dashboard Applications List](https://images.ctfassets.net/cdy7uua7fh8z/1ecNwGgFQZxdP57p0tp3jT/d6796b8b909d0db1d4dd7d5e0487776a/dashboard-applications-applications-list.png)\n2.  Scroll to the bottom of the **Settings** page, and select **Show Advanced Settings**.\n    \n3.  Select **Device Settings**, provide the **Team ID** and the **App bundler identifier** values for your iOS application and select **Save Changes**.\n    \n    ![Dashboard Applications Application Settings Tab Advanced Settings Device Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/YKKPtWtswHn2FZGFSVWNw/3af8af94d510abe6db83ac36c5407402/dashboard-applications-applications-settings-advanced-device-settings.png)\n\n## Test link\n\nCheck whether the universal links `apple-app-site-association` file is available for your application by navigating to the following URL in your browser: `{yourDomain}/apple-app-site-association`\n\nIf the link is successful, you will see the following JSON (formatted for readability):\n\n```\n{\n  \"applinks\": {\n    \"apps\": [],\n    \"details\": [{\n      \"appID\": \"86WQXF56BC.com.auth0.Passwordless-Email\",\n      \"paths\": [\"/ios/com.auth0.Passwordless-Email/*\"]\n    }]\n  }\n}\n```",
  "title": "Enable Universal Links Support in Apple Xcode",
  "description": "Learn how to enable universal links support for your Auth0 app in Apple Xcode using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/rotate-credentials",
  "markdown": "# Rotate Credentials\n\nAuth0 recommends you rotate key material regularly to meet your compliance needs and ensure security is not compromised by leaked private keys. You can use the Auth0 Dashboard or Management API to rotate new keys into use. You need to create a new credential, associate it with the `private_key_jwt` authentication method, and remove old or unused credentials.\n\nTo rotate your application credentials with Auth0 Dashboard:\n\n1.  Navigate to [**Auth0 Dashboard > Applications > Application**](https://manage.auth0.com/#/applications) and select the application you want to update.\n    \n2.  Switch to the **Credentials** tab.\n    \n3.  In the **Available Credentials** section, select **Add New Key**.\n    \n    ![Auth0 Dashboard - Applications - Settings - Credentials tab](https://images.ctfassets.net/cdy7uua7fh8z/2r7AsCgGPUeX7WltJKDcCM/75f3df3b379d54ce584c15e14d39aee8/2023-04-25_13-16-52.png)\n4.  Set a name for your new credential, the public key in PEM format, and the algorithm for the new credential.\n    \n5.  Select **Add Credential**.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/22iFg3xbJDmH4hlg45q2u7/a9bcb4dce744b30304ac4a303c293e85/2023-05-03_10-58-45.png)\n6.  To activate your new credential, navigate to the menu for the credential and choose **Enable for Private Key JWT use**.\n    \n    ![Auth0 Dashboard - Applications - Application Settings - Credential tab - enable or delete credential](https://images.ctfassets.net/cdy7uua7fh8z/4mLWXAcWk0gYDVdngrmuLJ/cedfa1d80e8987763dba8ee290c11756/2023-03-28_15-45-22.png)\n7.  Once you have updated your applications to use the new credential, deactivate your original credential:\n    \n    1.  Select **Disable for Private Key JWT Use**.\n        \n    2.  Once disabled, return to the credential menu and select **Delete Credential**.\n        \n        ![Auth0 Dashboard - Applications - Application Settings - Credential tab - disable credential](https://images.ctfassets.net/cdy7uua7fh8z/3Y9enp5EfK274V2qyYaM9s/7cd9cc48f2f0b05d48588057b8b00cc2/2023-03-28_16-05-34.png)\n\n### Active credentials\n\nTo assure zero downtime, you can leave multiple credentials active during rotation. Applications can function normally using older keys until keys are updated. Applications can send signed assertions with any set of active credentials.\n\nAuth0 recommends you minimize the time that multiple credentials are in use. The example below uses multiple associated credentials:\n\n```\ncurl --location --request PATCH 'https://$tenant/api/v2/clients/$client_id' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n          \"client_authentication_methods\": {\n             \"private_key_jwt\": {\n                \"credentials\": [{ \"id\": $credential1.id }, { \"id\": $credential2.id }]\n             }\n          }\n }'\n```\n\n## Learn more\n\n*   [Configure Private Key JWT Authentication](https://auth0.com/docs/get-started/applications/configure-private-key-jwt)\n*   [Application Credentials](https://auth0.com/docs/secure/application-credentials)\n*   [Credential Settings](https://auth0.com/docs/get-started/applications/credentials)",
  "title": "Rotate Credentials",
  "description": "Describes how to rotate existing credentials in the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/rotate-client-secret",
  "markdown": "# Rotate Client Secrets\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret\"\n\n\treq, _ := http.NewRequest(\"POST\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D/rotate-secret\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Rotate Client Secrets",
  "description": "Learn how to rotate an application's client secret using the Auth Dashboard or the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery",
  "markdown": "# Configure Applications with OIDC Discovery\n\n```\n{\n  \"issuer\": \"https://{yourDomain}.us.auth0.com/\",\n  \"authorization_endpoint\": \"https://{yourDomain}.us.auth0.com/authorize\",\n  \"token_endpoint\": \"https://{yourDomain}.us.auth0.com/oauth/token\",\n  \"device_authorization_endpoint\": \"https://{yourDomain}.us.auth0.com/oauth/device/code\",\n  \"userinfo_endpoint\": \"https://{yourDomain}.us.auth0.com/userinfo\",\n  \"mfa_challenge_endpoint\": \"https://{yourDomain}.us.auth0.com/mfa/challenge\",\n  \"jwks_uri\": \"https://{yourDomain}.us.auth0.com/.well-known/jwks.json\",\n  \"registration_endpoint\": \"https://{yourDomain}.us.auth0.com/oidc/register\",\n  \"revocation_endpoint\": \"https://{yourDomain}.us.auth0.com/oauth/revoke\",\n  \"scopes_supported\": [\n    \"openid\",\n    \"profile\",\n    \"offline_access\",\n    \"name\",\n    \"given_name\",\n    \"family_name\",\n    \"nickname\",\n    \"email\",\n    \"email_verified\",\n    \"picture\",\n    \"created_at\",\n    \"identities\",\n    \"phone\",\n    \"address\"\n  ],\n  \"response_types_supported\": [\n    \"code\",\n    \"token\",\n    \"id_token\",\n    \"code token\",\n    \"code id_token\",\n    \"token id_token\",\n    \"code token id_token\"\n  ],\n  \"code_challenge_methods_supported\": [\n    \"S256\",\n    \"plain\"\n  ],\n  \"response_modes_supported\": [\n    \"query\",\n    \"fragment\",\n    \"form_post\"\n  ],\n  \"subject_types_supported\": [\n    \"public\"\n  ],\n  \"id_token_signing_alg_values_supported\": [\n    \"HS256\",\n    \"RS256\",\n    \"PS256\"\n  ],\n  \"token_endpoint_auth_methods_supported\": [\n    \"client_secret_basic\",\n    \"client_secret_post\",\n    \"private_key_jwt\"\n  ],\n  \"claims_supported\": [\n    \"aud\",\n    \"auth_time\",\n    \"created_at\",\n    \"email\",\n    \"email_verified\",\n    \"exp\",\n    \"family_name\",\n    \"given_name\",\n    \"iat\",\n    \"identities\",\n    \"iss\",\n    \"name\",\n    \"nickname\",\n    \"phone_number\",\n    \"picture\",\n    \"sub\"\n  ],\n  \"request_uri_parameter_supported\": false,\n  \"request_parameter_supported\": false,\n  \"token_endpoint_auth_signing_alg_values_supported\": [\n    \"RS256\",\n    \"RS384\",\n    \"PS256\"\n  ]\n}\n```",
  "title": "Configure Applications with OIDC Discovery",
  "description": "Describes how to use OpenID Connect (OIDC) discovery to configure applications with Auth0 using SDKs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/set-up-cors",
  "markdown": "# Configure Cross-Origin Resource Sharing\n\nAuth0 strongly recommends that authentication transactions be handled via [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). Doing so offers the easiest and most secure way to authenticate users. However, some situations may require that login be directly embedded in an application. When embedded login is required, an application must be set up for cross-origin resource sharing (CORS).\n\nYou can configure CORS for an application using the Auth0 Dashboard.\n\n## Configure cross-origin authentication\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click the name of the application to view.\n    \n2.  Under **Cross-Origin Authentication**, toggle on **Allow Cross-Origin Authentication**.\n    \n    ![Dashboard - Applications - Application - Settings - Cross-Origin Authentication](https://images.ctfassets.net/cdy7uua7fh8z/6251mtL32aGJElM8TjJKx7/39ed973f9b47678c1fd5faf601d75693/Cross-Origin_Authentication.png)\n3.  Locate **Allowed Origins (CORS)**, and enter your application's origin URL. To learn more about Origins, read [Origin on Mozilla MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin).\n    \n4.  Click **Save Changes**.\n    \n\n## Create cross-origin verification page\n\nThere are some cases when third-party cookies will not be available. Certain browser versions do not support third-party cookies and, if they do, they may be disabled in a user's settings.\n\nFor [browsers that are supported](#browser-testing-support), you can use the `crossOriginVerification` method from the [Auth0.js SDK](https://auth0.com/docs/libraries/auth0js) in your application on a dedicated page to handle cases when third-party cookies are disabled.\n\nFor browsers that are not supported, such as Chrome, Opera, and Safari, cross-origin authentication will not work when third-party cookies are disabled unless you enable [Custom Domains](https://auth0.com/docs/customize/custom-domains).\n\n1.  Create a page in your application that instantiates `WebAuth` from [Auth0.js](https://auth0.com/docs/libraries/auth0js). Call `crossOriginVerification` immediately. The name of the page is up to you.\n    \n    to configure this snippet with your account\n    \n    ```\n    <!-- callback-cross-auth.html -->\n    \n    <head>\n      <script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n      <script type=\"text/javascript\">\n        var auth0Client = new auth0.WebAuth({\n          clientID: '{yourClientId}',\n          domain: '{yourDomain}'\n        });\n        auth0Client.crossOriginVerification();\n      </script>\n    </head>\n    ```\n    \n    When third party cookies are not available, Auth0.js renders an iframe to call a different cross-origin verification flow.\n2.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select the application to view.\n    \n3.  Under **Cross-Origin Authentication**, add the URL of the callback page you created to the **Cross-Origin Verification Fallback URL** field.\n    \n4.  Click **Save Changes**.\n    \n\nFor more details, view the [cross-origin authentication sample on GitHub](https://github.com/auth0/lock/blob/master/support/callback-cross-auth.html).\n\n## Error codes and descriptions\n\nWhen Auth0.js v9 (and Lock) is used for embedded login, it calls the `/co/authenticate` endpoint, which has the following errors:\n\n| **Status** | **Code** | **Description** |\n| --- | --- | --- |\n| `400` | `invalid_request` | Invalid request body. All and only of client\\_id, credential\\_type, username, otp, realm are required. |\n| `400` | `unsupported_credential_type` | Unknown credential type parameter. |\n| `400` | `invalid_request` | Unknown realm non-existent-connection. |\n| `401` | `unauthorized_client` | Cross origin login not allowed. |\n| `401` | `password_leaked` | This login attempt has been blocked because the password you're using was previously disclosed through a data breach (not in this application). |\n| `403` | `access_denied` | Wrong email or password. |\n| `403` | `access_denied` | Authentication error |\n| `403` | `blocked_user` | Blocked user |\n| `429` | `too_many_attempts` | Your account has been blocked after multiple consecutive login attempts. We've sent you a notification via your preferred contact method with instructions on how to unblock it. |\n| `429` | `too_many_attempts` | We have detected suspicious login behavior and further attempts will be blocked. Please contact the administrator. |\n\nIn addition, you can also get a generic `403` error without an `error` or `error_description` property. The response body would just include something similar to the following:\n\n`Origin https://test.app is not allowed.`\n\n## Browser testing support\n\nThe following browsers can use cross-origin authentication when third-party cookies are disabled:\n\n*   Microsoft Internet Explorer\n    \n\n#### Samesite cookie attributes\n\nPreviously, the [`samesite` cookie attribute](https://auth0.com/docs/sessions/concepts/cookie-attributes) options were `true`, `false`, `strict` or `lax`. If you didn't set the attribute manually, Auth0 would use the default value of `false`.\n\nEffective February 2020, Google Chrome v80 changed the way it handles cookies, and Auth0 implemented the following changes accordingly:\n\n*   Cookies without the `samesite` attribute set will be set to `lax`.\n    \n*   Cookies with `sameSite=none` must be secured, otherwise they cannot be saved in the browser's cookie jar.\n    \n\nThe goal of these changes are to improve security and help mitigate cross-site resource forgery (CSRF) attacks.\n\n## Learn more\n\n*   [Embedded Login](https://auth0.com/docs/authenticate/login/embedded-login)\n*   [Cross-Origin Authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication)\n*   [Application Settings](https://auth0.com/docs/get-started/applications/application-settings)\n*   [SameSite Cookie Attribute Changes](https://auth0.com/docs/manage-users/cookies/samesite-cookie-attribute-changes)",
  "title": "Configure Cross-Origin Resource Sharing",
  "description": "Describes how to configure Cross-Origin Resource Sharing (CORS) for an Auth0-registered application using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-fapi-compliance",
  "markdown": "# Configure FAPI Compliance\n\nTo help customers configure their Auth0 tenant to adhere to one of the Financial-grade API (FAPI) profiles, the Application model includes a `compliance_level` property that can be set to one of three values:\n\n*   `null` or undefined: No compliance level is required. This is the default.\n    \n*   `fapi1_adv_mtls_par`: The customer would like this client to behave in accordance with the FAPI1 Advanced profile using [mTLS](https://auth0.com/docs/get-started/applications/configure-mtls) and [PAR](https://auth0.com/docs/get-started/applications/configure-par).\n    \n*   `fapi1_adv_pkj_par`: The customer would like this client to behave in accordance with the FAPI1 Advanced profile using [Private Key JWT](https://auth0.com/docs/get-started/applications/configure-private-key-jwt) and [PAR](https://auth0.com/docs/get-started/applications/configure-par).\n    \n\nUse [Management API](https://auth0.com/docs/api/management/v2) to set the `compliance_level` property with a POST or PATCH request:\n\n```\ncurl --location --request PATCH 'https://$tenant/api/v2/clients/$client_id' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data '{\n    \"compliance_level\": \"fapi1_adv_mtls_par\"\n}'\n```\n\nTo return the `compliance_level` property, use a GET request:\n\n```\ncurl --location 'https://$tenant/api/v2/clients/$client_id \\\n  --header 'Authorization: Bearer $management_access_token'\n```\n\nComplying with a FAPI profile requires a number of configuration changes. Setting the `compliance_level` ensures that no authorization request can succeed unless the request and the configuration is compliant with the selected standard.\n\nFor example, both the `fapi1_adv_pkj_par` and `fapi1_adv_mtls_par` compliance levels require PAR. If either of these compliance levels are selected, PAR is required regardless of the value of the `require_pushed_authorization_requests` setting. Attempting an authorization without using PAR results in the following error response:\n\n```\n{\n  “error”: “invalid_request”,\n  “error_description”: “Pushed Authorization Requests are required by the configured compliance level” \n}\n```\n\nIn some cases, setting a compliance level also changes Auth0’s behavior. For example, both the `fapi1_adv_pkj_par` and `fapi1_adv_mtls_par` compliance levels cause Auth0 to include a `s_hash` claim in the returned ID token containing a SHA256 hash of the state value. This allows the ID tokens to act as a detached signature.\n\nThe following tables summarize the additional validation rules and changes to Auth0’s behavior that each compliance level enables:\n\n| **Validation** | `fapi1_adv_pkj_par` | `fapi1_adv_mtls_par` |\n| --- | --- | --- |\n| Prevents the use of access tokens in the URL query when calling `/userinfo`. Access tokens must be placed in the Authorization header instead. | Y   | Y   |\n| Requires PAR. | Y   | Y   |\n| Requires PKCE with the S256 challenge method. | Y   | Y   |\n| Prevents the use of wildcards in the allowed callbacks on a client. | Y   | Y   |\n| Enforces the use of JAR. | Y   | Y   |\n| Ensures the JAR payload is signed using the PS256 algorithm. | Y   | Y   |\n| Ensures the JAR payload contains the nbf claim and it is no longer than 60 minutes in the past. | Y   | Y   |\n| Ensures the JAR payload contains the exp claim and that it is no more than 60 minutes after the nbf claim. | Y   | Y   |\n| Ensures the client has set the `oidc_conformant` property to true. | Y   | Y   |\n| Requires the use of Private Key JWT for client authentication. | Y   | N   |\n| Requires the use of mTLS for client authentication. | N   | Y   |\n\n| **Auth0 updated behavior** | `fapi1_adv_pkj_par` | `fapi1_adv_mtls_par` |\n| --- | --- | --- |\n| Adds s\\_hash claim to ID tokens. | Y   | Y   |\n| When the profile scope is requested, the `update_at` claim contains an OIDC Conformant unix timestamp rather than a string. | Y   | Y   |\n| Returns only OIDC conformant error codes. In some cases, Auth0 may return additional error codes, but enabling this compliance level ensures that Auth0 only uses error codes defined in the OpenID standards. | Y   | Y   |\n\n## Learn more\n\n*   [Configure Private Key JWT Authentication](https://auth0.com/docs/get-started/applications/configure-private-key-jwt)\n*   [Configure Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/applications/configure-par)\n*   [Configure mTLS Authentication](https://auth0.com/docs/get-started/applications/configure-mtls)",
  "title": "Configure FAPI Compliance",
  "description": "Learn how to configure FAPI compliance for an Auth0 tenant.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-mtls",
  "markdown": "# Configure mTLS Authentication\n\nWas this article helpful?",
  "title": "Configure mTLS Authentication",
  "description": "Learn how to configure mTLS authentication. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-jar",
  "markdown": "# Configure JWT-secured Authorization Requests (JAR)\n\nJWT\\-Secured Authorization Requests (JAR) allow OAuth2 authorization request parameters to be packaged into a single JWT request parameter which is then signed for integrity protection.\n\n## Prerequisites\n\nBefore configuring your application for using JAR, you must [generate an RSA key pair](https://auth0.com/docs/secure/application-credentials/generate-rsa-key-pair).\n\n## Configure JAR for your application\n\n### Use Management API\n\nYou can configure JAR for your application using the `signed_request_object` client configuration property. This object property contains the following fields:\n\n*   `required`: forces all authorization requests to the `/authorize` and `/oauth/par` to use JAR. To learn more, read [Authorization Code Flow with JWT-Secured Authorization Requests](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-jar) and [Authorization Code Flow with PAR and JAR](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par-and-jar).\n    \n*   `credentials`: an array of credential IDs used to verify signatures.\n    \n\nYou can configure JAR for a new application or for an existing application via the Management API.\n\n### Configure JAR for a new application\n\nWhen you create a new application, configure JAR by sending a POST request with the `signed_request_object`. In that POST request, you can also register the corresponding client credential (i.e. the key PEM):\n\n```\nPOST https://{yourTenant}.auth0.com/api/v2/clients\nAuthorization: Bearer [YOUR ACCESS TOKEN]\nContent-Type: application/json\n{\n  \"name\": \"My App using JAR\",\n  \"signed_request_object\": {\n      \"required\": true,\n\"credentials\": [{\n        \"name\": \"My credential for JAR\",\n        \"credential_type\": \"public_key\",\n        \"pem\": \"[YOUR PEM FILE CONTENT]\",\n        \"alg\": \"RS256\"\n}]\n  },\n  \"jwt_configuration\": {\n    \"alg\": \"RS256\"\n  }\n}\n```\n\n### Configure JAR for an existing application\n\nWhen updating an existing application, you need to explicitly create a client credential first. The following POST request uses your PEM file content to create your client credentials for JAR:\n\nto configure this snippet with your account\n\n```\nPOST https://{yourTenant}.auth0.com/api/v2/clients/{yourClientId}/credentials\nAuthorization: Bearer [YOUR ACCESS TOKEN]\nContent-Type: application/json\n{\n  \"name\": \"My credentials for JAR\",\n  \"credential_type\": \"public_key\",\n  \"pem\": \"[YOUR PEM FILE CONTENT]\",\n  \"alg\": \"RS256\"\n}\n```\n\nThen, assign the client credential to the `signed_request_object` client configuration. The following PATCH request associates your client credentials with the `signed_request_object`:\n\nto configure this snippet with your account\n\n```\nPATCH https://{yourTenant}.auth0.com/api/v2/clients/{yourClientId}\nAuthorization: Bearer [YOUR ACCESS TOKEN]\nContent-Type: application/json\n{\n  \"signed_request_object\": {\n    \"credentials\": [{\"id\": \"[YOUR CREDENTIAL ID]\"}]\n  }\n}\n```\n\n### Use Auth0 Dashboard\n\nYou can use the Auth0 Dashboard to configure your application to use JAR with previously generated RSA keys.\n\n1.  Navigate to [Auth0 Dashboard > Applications](https://manage.auth0.com/#/applications).\n    \n2.  Select the application you want to use with JAR.\n    \n3.  Select the **Application Settings** tab.\n    \n4.  In the **Authorization Requests** section, enable **Require JWT-Secured Authorization Requests**.\n    \n    ![Dashboard > Applications > Settings](https://images.ctfassets.net/cdy7uua7fh8z/3QMyrHCk2nd5zydapDH1JH/cd89c385c907e0ea2cb3f5db36ec022b/2024-05-24_14-18-32.png)\n5.  If no credential is assigned and there are credentials available, you will be prompted to assign an existing credential.\n    \n    ![Dashboard > Application > Settings > Assign Existing Credentials](https://images.ctfassets.net/cdy7uua7fh8z/HQHhFWTtdfNa5TnZ1dwx6/73ba434f7e21ae66c41b5bb46531d5ca/2024-05-24_14-27-44.png)\n6.  You will also have the option to assign a new credential.\n    \n    ![Auth0 Dashboard > Applications > Settings > Assign New Credentials](https://images.ctfassets.net/cdy7uua7fh8z/7JfsCBwytWO6Q7hUvdtSwJ/7067dd207f0a2f16d772d47fff243e73/2024-05-24_14-39-43.png)\n7.  Add and assign a new credential by uploading a previously generated RSA key pair. When prompted, enter the following:\n    \n    *   **Name**: a name to identify the credential\n        \n    *   **Public Key**: public key of the X.509 certificate in PEM format\n        \n    *   **Algorithm**: select the JAR signature algorithm\n        \n    *   **Expiration Date**: set the expiration date of the credential\n        \n\n![Dashboard > Applications > APIs](https://images.ctfassets.net/cdy7uua7fh8z/2bX2BT4snNZGmGR97ethxi/31511b33ec027648865eaec48e306fb1/2024-05-27_10-46-17.png)\n\n## Learn more\n\n*   [Authorization Code Flow with JWT-Secured Authorization Requests (JAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-jar)\n*   [Authorization Code Flow with PAR and JAR](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par-and-jar)",
  "title": "Configure JWT-secured Authorization Requests (JAR)",
  "description": "Learn how to configure JWT-secured Authorization Requests (JAR) for an application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-ws-fed-applications",
  "markdown": "# Configure WS-Fed Applications\n\nYou can configure a WS-Fed application (service provider) to use Auth0 as an identity provider. Some commonly used WS-Fed applications are pre-configured in Auth0 and available via [Single Sign-On Integrations](https://auth0.com/docs/customize/integrations/sso-integrations). If a WS-Fed application is not listed in Single Sign-On Integrations, the WS-Fed application configuration can be accessed using the following steps.\n\n1.  Go to **Dashboard >** **Applications > Applications**.\n    \n2.  Click **Create App**.\n    \n3.  Enter a name, and click **Save**.\n    \n4.  Go to the **Addons** tab.\n    \n5.  Scroll to **WS-Fed Web App**, and enter the **Application Callback URL**. This is your callback URL in the WS-Fed application to which the WS-Fed response will be posted. It may also be called the **ACS** or **Assertion Consumer Service URL** in some applications.\n    \n6.  Enter the **Realm**. This is an identifier sent by the WS-Fed application and is used to identify the application in the response.\n    \n\n## Configure claims included in the WS-Fed token response\n\nUnlike the SAML Web App addon, the WS-Fed Web App addon does not include configuration settings that allow you to configure the token generated by Auth0. If you need to change the default settings, you can create a rule similar to:\n\n```\nfunction (user, context, callback) {\n\n  // only apply changes for the WS-Fed application\n  if (context.clientName !== 'Your ws-fed application name') {\n    return callback(null, user, context);\n  }\n\n  // exclude the upn claim creation (defaults to true)\n  context.samlConfiguration.createUpnClaim = false;\n\n  // exclude the identities array (defaults to true)\n  context.samlConfiguration.mapIdentities = false;\n\n  // exclude claims that were not explicitly mapped (defaults to true)\n  context.samlConfiguration.passthroughClaimsWithNoMapping = false;\n\n  // this is the default mapping. Remove or change as you like.\n  // Note that the key (left side) is the attribute name (namespace-qualified)\n  // and the value (right side) is the property name from the user object.\n  // you can also use transient values from the user object. For example, for:\n  //    user.calculated_field = <some expression>;\n  // then add this mapping:\n  //    'some_claim': 'calculated_field', \n  context.samlConfiguration.mappings = {\n    'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier': 'user_id',\n    'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress': 'email',\n    'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name': 'name',\n    'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname': 'given_name',\n    'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname': 'family_name',\n    'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn': 'upn',\n    'http://schemas.xmlsoap.org/claims/Group': 'groups'\n  };\n\n  callback(null, user, context);\n}\n```\n\n## Custom domains\n\nTo use your WS-Fed apps with a custom domain and with Auth0 as the IdP, update your service provider with new identity provider metadata from Auth0. You can obtain the metadata from:\n\n`https://<YOUR CUSTOM DOMAIN>/wsfed/FederationMetadata/2007-06/FederationMetadata.xml`.\n\n## Encrypted responses\n\nIf you require encrypted responses, you should use SAML to connect to ADFS. To learn more, read [Configure ADFS as SAML Identity Provider](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-adfs-saml-connections) and [Sign and Encrypt SAML Requests](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/sign-and-encrypt-saml-requests).\n\n## Learn more\n\n*   [Custom Domains](https://auth0.com/docs/customize/custom-domains)\n*   [Auth0 Integrations](https://auth0.com/docs/customize/integrations)",
  "title": "Configure WS-Fed Applications",
  "description": "Describes how to configure a WS-Fed application to use Auth0 as an identity provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/configure-private-key-jwt",
  "markdown": "# Configure Private Key JWT Authentication\n\nYou can use the Auth0 Dashboard to create a new application and configure the credentials or update an existing application.\n\nWe recommend you securely store the current `client_secret` parameter before you set your application credential method to Private Key JWT. The `client_secret` parameter will be hidden once the Private Key JWT configuration is complete.\n\n#### Configure a new application for `private_key_jwt`\n\n1.  Navigate to [**Auth0 Dashboard > Applications > Application**](https://manage.auth0.com/#/applications).\n    \n2.  Select **Create Application**.\n    \n3.  Choose your application type.\n    \n4.  Under the application settings, select the **Credentials** tab.\n    \n5.  Under **Authentication Methods**, select **Private Key JWT**.\n    \n    ![Configure Private Key JWT Authentication - Auth0 Dashboard instructions](https://images.ctfassets.net/cdy7uua7fh8z/33kfi48tkbMIOQJ8PBxj76/45004e5e46516daa3fa66408c5601487/2023-04-10_15-11-53.png)\n6.  Configure credential details: \n    \n    1.  Enter a name for the credential.\n        \n    2.  Upload your PEM format or X.509 certificate.\n        \n    3.  Select the algorithm to sign the assertions.\n        \n    4.  Optional: Enable custom expiration. Select **Set an explicit expiry date for this Credential** and set a future date.\n        \n        ![Dashboard - applications - application settings - credentials](https://images.ctfassets.net/cdy7uua7fh8z/2PWYMJkNnuOumKqrDztLeU/40b1db27563d6f7811bc711d1e635d76/2023-04-10_15-20-10.png)\n7.  Select **Add Credential**.\n    \n\n#### Configure an existing application\n\n1.  Navigate to [Auth0 Dashboard > Applications](http://manage.auth0.com/#/applications).\n    \n2.  Select the application you want to update.\n    \n3.  Select the **Credentials** tab.\n    \n4.  Choose **Private Key JWT**.\n    \n5.  Configure credential details: \n    \n    1.  Enter a name for the credential.\n        \n    2.  Upload your PEM format or X.509 certificate.\n        \n    3.  Select the algorithm to sign the assertions.\n        \n    4.  Optional: Enable custom expiration. Select **Set an explicit expiry date for this Credential** and set a future date.\n        \n6.  Select **Add Credential**.\n    \n\n#### Configure an application to use Client Secret authentication\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/dashboard/#/applications/) and select the application you want to update.\n    \n2.  Select the **Credentials** tab.\n    \n3.  Choose **Client Secret (Post)** or **Client Secret (Basic)**.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/7lLtxWyMqQWtyyvrAtia0A/b474a05fe53c9c6c4248a36a96c05fad/2023-05-03_12-13-47.png)\n4.  Select **Save**.\n    \n\n#### Update credential expiration\n\nYou can update an existing credential with an expiration date with Auth0 Dashboard.\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/dashboard/#/applications/) and select the application you want to update.\n    \n2.  Select the **Credentials** tab.\n    \n3.  Choose the credential you want to update and select **Edit Credential**.\n    \n    ![Dashboard - Applications - Application Settings - Credentials - update expiry date](https://images.ctfassets.net/cdy7uua7fh8z/6858PTDkNCRZiIqtBVmciZ/ddf0ec8a4c81cc21e4c7bbd61fcefe0f/2023-05-03_12-13-30.png)\n4.  Select **Set an explicit expiry date for this Credential** and set a future date.\n    \n5.  Select **Update Credential**.",
  "title": "Configure Private Key JWT Authentication",
  "description": "Describes how to configure new and existing applications to use Private Key JWT Authentication.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/remove-applications",
  "markdown": "# Remove Applications\n\n```\ncurl --request DELETE \\\n  --url 'https://{yourDomain}/api/v2/clients/%7ByourClientId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\");\nvar request = new RestRequest(Method.DELETE);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\"\n\n\treq, _ := http.NewRequest(\"DELETE\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.delete(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'DELETE',\n  url: 'https://{yourDomain}/api/v2/clients/%7ByourClientId%7D',\n  headers: {authorization: 'Bearer {yourMgmtApiToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"DELETE\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"DELETE\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiToken}\" }\n\nconn.request(\"DELETE\", \"/{yourDomain}/api/v2/clients/%7ByourClientId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Delete.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/clients/%7ByourClientId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"DELETE\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Remove Applications",
  "description": "Learn how to remove an Auth0-registered application using the Auth0 Dashboard or the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/tenant-settings/find-your-tenant-name-or-tenant-id",
  "markdown": "# Find Your Tenant Name or Tenant ID\n\nEvery Auth0 tenant has a name. You use this name frequently in your code to identify the tenant. When you see the `{yourTenantId}`, `{yourTenantName}`, `{yourTenant}`, or similar variable in the Auth0 documentation, substitute the variable with the tenant name.\n\n1.  Go to the [Auth0 Dashboard](https://manage.auth0.com/#).\n    \n2.  In the top-left corner, find the tenant name beside the Auth0 logo.\n    \n\n![Find the name or ID of your Auth0 tenant](https://images.ctfassets.net/cdy7uua7fh8z/6frjVl9cPpJDIjxNF5YtoT/d0da27e927048e455f3254b878e59638/Dashboard-Find-Tenant-Name.png)\n\n## Learn more\n\n*   [Tenant Settings](https://auth0.com/docs/get-started/tenant-settings)\n*   [Multi-Tenant Applications Best Practices](https://auth0.com/docs/get-started/auth0-overview/create-tenants/multi-tenant-apps-best-practices)",
  "title": "Find Your Tenant Name or Tenant ID",
  "description": "How to find the name of your Auth0 tenant ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/tenant-settings/signing-keys",
  "markdown": "# Signing Keys\n\nWhen you select our recommended signing algorithm (RS256), Auth0 uses public-key cryptography to establish trust with your applications. In more general terms, we use a signing key that consists of a public and private key pair.\n\nSigning keys are used to sign ID tokens, access tokens, SAML assertions, and WS-Fed assertions sent to your application or API. The signing key is a JSON web key (JWK) that contains a well-known public key used to validate the signature of a signed JSON web token (JWT). A JSON web key set (JWKS) is a set of keys containing the public keys used to verify any JWT issued by the authorization server and signed using the RS256 signing algorithm. The service may only use one JWK for validating web tokens, however, the JWKS may contain multiple keys if the service rotated signing certificates.\n\n## How it works\n\nWhen a user signs in to your application, we create a token that contains information about the user and sign the token using its private key before we send it back to your application. Auth0 secures the private key, which is unique per tenant.\n\nTo verify that the token is valid and originated from Auth0, your application validates the token’s signature using the public key. We provide other application security key management capabilities through both our Dashboard and Management API.\n\nAuth0 recommends that you rotate keys regularly to ensure you will be ready for action in case of a security breach.\n\nAdditional application signing certificates are listed below.\n\n*   [CER](https://{yourdomain}/cer)\n    \n*   [PEM](https://{yourdomain}/pem)\n    \n*   [raw PEM](https://{yourdomain}/rawpem)\n    \n*   [PB7](https://{yourdomain}/pb7)\n    \n*   [Fingerprint](https://{yourdomain}/fingerprint)\n    \n\nYou can also retrieve this information for individual applications through the Auth0 Dashboard. To do so, navigate to the **Settings** page for a specific application. Then, expand the **Advanced Settings** and choose the **Certificates** tab.\n\nThe rotation and revocation process supports your personal preferences and promotes a graceful transition for your application. If you prefer to update your application first, then rotate and revoke your key, you may do that. Alternatively, if you prefer to rotate your key, and then update your application and revoke your old key, you may also do that.\n\nAvailable keys include:\n\n*   **Currently used**: Key that is currently being used to sign all new assertions.\n    \n*   **Previously used**: Key that was previously used, but has been rotated out. Assertions that were generated with this key will still work.\n    \n*   **Next in queue**: Key that is queued and will replace the current key when the application signing key is next rotated.\n    \n\n## Limitations\n\nRotating your signing key will be subject to a smaller rate limit than other API endpoints. To learn more, read [Management API Rate Limits](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits).\n\n## Learn more\n\n*   [Rotate Signing Keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys/rotate-signing-keys)\n*   [Revoke Signing Keys](https://auth0.com/docs/get-started/tenant-settings/signing-keys/revoke-signing-keys)\n*   [View Signing Certificates](https://auth0.com/docs/get-started/tenant-settings/signing-keys/view-signing-certificates)\n*   [Change Application Signing Algorithms](https://auth0.com/docs/get-started/applications/change-application-signing-algorithms)",
  "title": "Signing Keys",
  "description": "Describes how your tenant's application signing keys work.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/tenant-settings/enable-sso-for-legacy-tenants",
  "markdown": "# Enable Single Sign-On for Tenants\n\nYou can enable SSO for your tenant using the Auth0 Dashboard. If you do not choose to enable tenant-level SSO, you may [enable it per application](https://auth0.com/docs/get-started/applications/enable-sso-for-applications). If you do not see this setting available in the Dashboard, you already have Seamless SSO enabled; this toggle is strictly for legacy tenants.\n\n1.  Go to [Dashboard > Tenant Settings](https://manage.auth0.com/#/tenant).\n    \n    ![Dashboard Tenant Settings General Settings tab](https://images.ctfassets.net/cdy7uua7fh8z/4okToiwlkNQBxwr8QGE3Rs/3f39b3a057b55d06bff3511f255849ce/dashboard-tenant-settings-general-settings.png)\n2.  Go to the **Advanced** tab.\n    \n3.  Scroll to the **Log In Session Management** section. Locate **Enable Seamless SSO**.\n    \n4.  Enter the **Inactivity timeout** (default 4320 minutes) and **Require log in after** (default 10080 minutes) fields.\n    \n\nOnce finished, you should also [configure your session lifetime settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings).\n\n## Learn more\n\n*   [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on)",
  "title": "Enable Single Sign-On for Tenants",
  "description": "Describes how to enable Single Sign-on (SSO) for a tenant using the Auth0 Dashboard. Only for use with legacy tenants.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/applications/work-with-auth0-locally",
  "markdown": "# Test Applications Locally\n\nIn most cases, authenticating users through Auth0 requires an internet connection. However, you can still develop and test apps that use Auth0 locally. In some cases, you might not need access to an internet connection.\n\nTo learn how to structure your development, test, and production environments when using Auth0, see [Set Up Multiple Environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments).\n\n## Use JSON Web Tokens with client-side applications\n\nBecause [JSON Web Tokens (JWTs)](https://auth0.com/docs/secure/tokens/json-web-tokens) are stateless (that is, the app that consumes them cares only about its contents, not any of its previous states), this is one of the easiest scenarios to test locally.\n\nYou can obtain JWTs for testing using any of the following methods:\n\n1.  Create a test user for a [database connection](https://auth0.com/docs/connections/database), and programmatically log the user in. Essentially, you are using the [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow). For detailed implementation instructions, read [Call Your API Using the Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/call-your-api-using-resource-owner-password-flow).\n    \n2.  Use a browser bot to play the role of a user, log in and retrieve a JWT.\n    \n\n## Use sessions with server-side applications\n\nUnless your server-side application allows the generation of artificial sessions for testing, you'll need a way to perform a login through Auth0 manually.\n\nFor a high-level overview of how to do this, see [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow). For detailed implementation instructions, see our tutorial, [Add Login Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow).\n\n## Use local domains with Auth0\n\nIf you're developing your application locally, you can use `localhost` and other domains inaccessible by Auth0 (such as those on an intranet) as [callback URLs](https://auth0.com/docs/authenticate/login/redirect-users-after-login). For example, during development, you could use `http://localhost:3000/callback` as the callback URL.\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications/{yourClientId}/settings) and click the application.\n    \n2.  Add the URL to the **Allowed Callback URLs** list.\n    \n\nBecause Auth0's main identity protocol is [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol), Auth0 never needs to directly call your application's server. Instead, Auth0 redirects users to your application's endpoint(s) with required information contained in a query string or hash fragment.\n\n## Divert emails for testing\n\nIf you want to test your local application and do not want the emails (creation, validation, etc.) to be delivered to the actual email address of the users your application creates or validates, Auth0 recommends using a custom email provider. For example, a service like [Mailtrap](https://mailtrap.io/signin) or your own custom SMTP server implementation can apply whatever logic you require to trap the emails. This ensures that users do not receive emails but you can access them for validation and troubleshooting. To learn more, read [Configure Test SMTP Email Server](https://auth0.com/docs/customize/email/configure-test-smtp-email-servers).\n\nAuth0 does not allow certain \"false\" domains commonly used during testing. Use real email addresses to avoid disruption or errors.\n\n## Learn more\n\n*   [Verify Domain](https://auth0.com/docs/troubleshoot/basic-issues/verify-domain)\n*   [Verify Platform](https://auth0.com/docs/troubleshoot/basic-issues/verify-platform)",
  "title": "Test Applications Locally",
  "description": "Learn how to develop and test Auth0 applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments",
  "markdown": "# Set Up Multiple Environments\n\nDevelopment, staging, and production environments are easy to set up in Auth0. Simply create a new tenant for each environment to guarantee isolation between them. You can easily switch between tenants using the tenant chooser from the top left menu on the Dashboard. You can also configure different administrators for each.\n\nProduction [rate limits](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy) only apply to tenants tagged as `Production`. Ensure your tenant's environment tag is set to `Production` before going live, and note the differences between rate limits for different tenants, environments, and fee structures.\n\nYou can name your multiple environments any way you prefer. For production environments, we strongly recommend using [custom domains](https://auth0.com/docs/customize/custom-domains).\n\nIf you have an Enterprise subscription plan you can [link tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants/child-tenants) that which become identical to your Production account in terms of paid/upgraded features for use in a development/staging/testing environment.\n\n## Tag the environment\n\nFor each new tenant created, you should specify its environment. You can assign Environment Tags to your tenants to differentiate between development, staging, and production environments.\n\nIf your tenant is mixed use, choose the higher environment. For example, a tenant used for both development and production should be set to **Production**.\n\n1.  To assign an Environment Tag to a tenant, go to the [Dashboard > Settings > General](https://manage.auth0.com/#/tenant/general).\n    \n    ![Dashboard Tenant Settings General Settings tab](https://images.ctfassets.net/cdy7uua7fh8z/4okToiwlkNQBxwr8QGE3Rs/3f39b3a057b55d06bff3511f255849ce/dashboard-tenant-settings-general-settings.png)\n2.  Under **Assign Environment Tag**, identify your tenant's environment as **Development**, **Staging**, or **Production**.\n    \n    ![undefined](https://images.ctfassets.net/cdy7uua7fh8z/27OH1jFXce97CSjk7TPeD7/1d858adea38c0b2bc9ff359240edcadf/Dashboard-Tenant_Settings-General-Environmental_Tag0.png)\n3.  After selecting the environment, click **Save**.\n    \n\n## Migration\n\nThrough the [Management API v2](https://auth0.com/docs/api/management/v2), you can automate the migration of assets ([rules](https://auth0.com/docs/customize/rules), database [connections](https://auth0.com/docs/connections), and so forth) between tenants.\n\nFor easier configuration management, save your configuration values in the [Dashboard](https://manage.auth0.com/#/rules), instead of hardcoding them into your **rules** or **db connections** scripts.\n\nFor example, let's say you want to set a URL for logs. One way to do it is to hardcode it in the rule:\n\n```\nfunction(user, context, callback){\n      var log_url = 'https://someurl/log';\n      ...\n    }\n```\n\nThis code, however, is not portable since this URL will likely change from development to production.\n\nThe recommended way of working with code that you need to use/move from development to product is via [Rules](https://manage.auth0.com/#/rules) section. If you have not yet created a rule, you'll need to do so. (Otherwise, jump to step 4.)\n\n1.  Click **Create Your First Rule**.\n    \n2.  Choose the **empty rule** template.\n    \n3.  Enter a name for your new rule, and click **Save**.\n    \n4.  Go to [Dashboard > Rules](https://manage.auth0.com/#/rules), and scroll to the bottom of the page to set your configuration values (we will use `log_url` for the key name, and `https://someurl/log` for value), then click **Create**.\n    \n5.  Now, you can write your rule. Edit the rule you created, enter the following code in the code area, and click **Save**.\n    \n    ```\n    function(user, context, callback){\n          var log_url = configuration.log_url;\n          ...\n        }\n    ```\n    \n\nThis code is portable, and when you migrate to production, you only need to change this setting instead of searching your scripts.\n\n## AD/LDAP Connectors\n\nIf you use multiple Auth0 tenants with AD/LDAP, you will need to create an AD/LDAP Connection and set up an AD/LDAP Connector for each tenant. This is because each AD/LDAP Connector is tied to a specific Connection within an Auth0 tenant.\n\nMultiple AD/LDAP Connectors can point to the same AD or LDAP directory, but each AD/LDAP Connector can only be used by one Connection within one Auth0 tenant.\n\nIf you have multiple AD/LDAP directories against which users will authenticate (for example, to support different departments or customers, each with their own directory), you can set up multiple AD/LDAP Connectors within each Auth0 tenant.\n\n## Learn more\n\n*   [Create Multiple Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants/create-multiple-tenants)\n*   [Delete or Reset Tenants](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/delete-or-reset-tenant)\n*   [Link Multiple Tenants to a Single Subscription](https://auth0.com/docs/get-started/auth0-overview/create-tenants/child-tenants)",
  "title": "Set Up Multiple Environments",
  "description": "Describes how to use multiple Auth0 tenants to manage various environments.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa",
  "markdown": "# Multi-Factor Authentication for Dashboard Users\n\nMulti-factor authentication (MFA) adds an additional level of security to an Auth0 account. When users with MFA enabled log into the Auth0 Dashboard, Auth0 prompts for their credentials plus an additional piece of identifying information. This ensures that only valid users can access their accounts, even if a bad actor has compromised a username and password.\n\nAny Dashboard user can self-enroll in MFA in [Your Profile](https://manage.auth0.com/#/profile). The MFA indicator in the [Auth0 Dashboard > Settings > Tenant Members](https://manage.auth0.com/#/tenant/admins) list identifies whether a user has enabled MFA for their account.\n\nAuth0 supports these authentication factors for Dashboard users:\n\n*   **WebAuthn with FIDO security keys**: WebAuthn roaming authenticators are removable and cross-platform, like a Yubikey, and can be used on multiple devices. To authenticate with a roaming authenticator, users must connect the authenticator to their device (through USB, NFC, or Bluetooth) and provide proof of presence (by touching it, for example).\n    \n*   **WebAuthn with device biometrics**: WebAuthn platform authenticators are attached to a device and work on that device only. Examples are the MacBook Touch Bar, Windows Hello, iOS Touch ID or Face ID, and Android fingerprint or face recognition. Because they work on the attached device only, a user must have at least one other factor enrolled in their profile before enrolling device biometrics.\n    \n*   **Push notification via Guardian**: Sends push notifications to a user's pre-registered device, typically a mobile phone or tablet. The user can immediately allow or deny account access with a button press. The push factor is available with the Guardian mobile app for iOS and Android.\n    \n*   **One-time passwords (OTP)**: Allows a user to use an authenticator app (such as Google Authenticator) on their personal device. The app generates an OTP that changes over time and can be entered as a second factor to validate the account.\n    \n*   **SMS notification**: Sends a one-time code over SMS. Auth0 then prompts the user to enter this code before they can complete authentication. SMS as an MFA is available only on tenants attached to a subscription plan.\n    \n\nTo learn how to enroll in Dashboard MFA, read [Add Multi-Factor Authentication for Auth0 Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa/add-mfa).\n\n## Learn more\n\n*   [Add Multi-Factor Authentication for Auth0 Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa/add-mfa)\n*   [Remove or Change Dashboard Multi-Factor Authentication](https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa/remove-or-change-dashboard-multi-factor-authentication)\n*   [Update Dashboard User Email Addresses](https://auth0.com/docs/get-started/manage-dashboard-access/update-dashboard-user-email)\n*   [Reset Account Passwords](https://auth0.com/docs/troubleshoot/customer-support/reset-account-passwords)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
  "title": "Multi-Factor Authentication for Dashboard Users",
  "description": "Learn how Auth0 Dashboard users can implement multi-factor authentication (MFA).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets",
  "markdown": "# Open and Manage Support Tickets\n\nUse [Auth0 Support Center](https://support.auth0.com/) to create tickets for questions or issues you are experiencing. You can access Support Center if you are a full administrator of an Auth0 account or have received an invitation to Support Center from an administrator.\n\nIf you are an existing Private Cloud customer, you will need to create an Auth0 cloud-based account to log in to the Support Center. This account can also be used for development and test purposes at no additional cost. Please contact your Technical Account Manager or Sales Executive to associate your cloud-based account to your existing Private Cloud subscription.\n\n## Open new tickets\n\n1\\. Go to [Support Center](https://support.auth0.com/) and click **Open Ticket**.\n\nIf you don't see this button, then you do not have access to support (only paying and trial customers have access to support). In this case click **Ask our Community** to use our [Community](https://community.auth0.com/) resources.\n\n![Open and Manage Tickets Open Ticket Screen](https://images.ctfassets.net/cdy7uua7fh8z/1cqZ8DSdSYMuEV7putldj8/262c9a35becc43335bcc32c167ca56df/openticket1.png)\n\n2\\. Choose **Affected Tenant** from the dropdown menu.\n\n3\\. Under **Issue Type**, select the type of issue that best fits your case.\n\n4\\. If you are not a trial tenant customer, you will be asked to select a severity level.\n\n##### Severity levels\n\n| Severity Level | Description |\n| --- | --- |\n| 1 (Urgent) | **Emergency Issue**: Defect resulting in full or partial system outage or a condition that makes the Auth0 Platform unusable or unavailable in production for all of your Users. |\n| 2 (High) | **Significant Business Impact**: Defect resulting in a condition where major functionality is impacted or significant performance degradation is experienced; issue is persistent and affects many Users and/or major functionality. |\n| 3 (Normal) | **Minor Feature/Function Issues/General Question**: Defect results in a component of the Auth0 Platform not performing as expected or documented **or** an inquiry by your representatives regarding general technical issues/questions. |\n| 4 (Low) | **Minor Problem/Enhancement Request**: Information requested on Auth0 Platform capabilities, navigation, installation, or configuration; enhancement request. |\n\n5\\. Depending on the issue type you chose, after you select the severity, you may be asked to answer: **What can we help you with?** Choose the answer that best matches your issue.\n\n6\\. You can choose to answer follow-up questions to further refine your request. You can also choose to skip this step by clicking the toggle.\n\n![Support Ticket Follow Up Screen](https://images.ctfassets.net/cdy7uua7fh8z/32UuivlZb6mTke1Tg5rGYn/b33589693e023952f9bb361795e13050/Screenshot_2023-09-18_at_12.09.42_PM.png)\n\n7\\. Provide a clear summary of the request or issue in the **Request Summary** field.\n\n8\\. Provide as much detail as possible about the issue or request in the **Description** box.\n\nWhen writing in this box, you can style your text with [Markdown](https://guides.github.com/features/mastering-markdown) and preview what you have written by clicking **Preview**. When writing your description, please try to include the following information when it applies:\n\n1.  What were you trying to do?\n    \n2.  What did you expect to happen?\n    \n3.  Where did things go wrong?\n    \n4.  Were there any error messages or screenshots showing the problem? If so, please include them.\n    \n5.  Has this worked before, or are you trying a new configuration?\n    \n6.  Does the problem occur for all users or just a few?\n    \n7.  What troubleshooting steps have you tried?\n    \n8.  When you have completed all the fields, click **SUBMIT**.\n    \n\n## Update existing tickets\n\n1\\. Go to the [Support Center](https://support.auth0.com/) page and click **Home**.\n\n2\\. Select the ticket that you want to update by clicking its **Request Summary**.\n\n3\\. Enter any additional details into the text box and then click **REPLY**.\n\nIf you are the ticket requester and the ticket is assigned to an agent but is not solved or closed, you have the option to change the status of your ticket to **Solved** by checking the **Submit as solved** box next to the **REPLY** button.\n\n## Closed tickets\n\nIf your ticket has been closed but you'd like to continue working with Auth0 on the issue, create a new Support Center ticket. Be sure to include the reference number for the original ticket(s).\n\n## Manage 'Subscription Tickets'\n\nIf you have the [Elevated Support Access role](https://auth0.com/docs/get-started/manage-dashboard-access/feature-access-by-role) assigned to you, you can view Subscription Tickets by navigating to [Auth0 Support Center Tickets page](https://support.auth0.com/tickets) and selecting \"Subscription Tickets\".\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7c1LfHJ0NUZK9a8GcjhUpo/7e1ca2895dfe6276691e0251df3a10cc/2024-06-04_13-08-54.png)\n\nIf you have proper access, you can see and manage all tickets opened by all users per tenant.\n\nIf you do not have proper access, you will receive an error instructing you how to gain access.\n\n## Learn more\n\n*   [Manage Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access)\n*   [Service Levels](https://auth0.com/docs/troubleshoot/customer-support/services-level-descriptions)\n*   [Update Dashboard User Email Addresses](https://auth0.com/docs/get-started/manage-dashboard-access/update-dashboard-user-email)\n*   [Troubleshoot Auth0](https://auth0.com/docs/troubleshoot)\n*   [Product Support Matrix](https://auth0.com/docs/troubleshoot/customer-support/product-support-matrix)",
  "title": "Open and Manage Support Tickets",
  "description": "Describes how to open and manage tickets with Support Center.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/login-pages/custom-error-pages",
  "markdown": "# Customize Error Pages\n\nWhen an authorization error occurs, and your callback URL is valid, the Authorization Server returns the appropriate error and state parameters to your callback URL. If your callback URL is invalid, your application will display the [default Auth0 error page](https://auth0.com/docs/authenticate/login/auth0-universal-login/error-pages).\n\nYour application may also display the default Auth0 error page for reasons other than an invalid callback URL, such as:\n\n*   Required parameters are missing when calling the Auth0 Authentication API [Login endpoint](https://auth0.com/docs/api/authentication#login).\n    \n*   User opens an expired password reset link (when using the Classic Login experience).\n    \n*   User navigates to a bookmarked login page and a [Default Login Route](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes) is not specified.\n    \n\n## Parameters\n\nIf you choose to configure a custom error page, the Authorization Server will return parameters appended to the URL as a query string.\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `client_id` | Identifier of the Auth0 application. |\n| `connection` | Connection used at the time of error. |\n| `lang` | Language set for use at the time of error. |\n| `error` | Error code of the error. |\n| `error_description` | Description of the error. |\n| `tracking` | Identifier used by Auth0 to find errors in internal logs. |\n\nParameters presented vary depending on the error type and are specific to the request. For example, if the request which resulted in an error did not contain a `client_id`, the Authorization Server will not return the `client_id` parameter.\n\n## Display a custom error page\n\nIf you want to display a custom error page, you have two options:\n\n1.  Redirect users to a custom error page using either the Auth0 Dashboard or the Auth0 Management API.\n    \n2.  Configure Auth0 to render a custom error page on your behalf via the Management API.\n    \n\n### Redirect users to a custom error page using the Dashboard\n\nUse the Dashboard to configure Auth0 to redirect users to a custom error page:\n\n1.  Navigate to [Auth0 Dashboard > Tenant Settings](https://manage.auth0.com/#/tenant/).\n    \n2.  Locate the **Error Pages** section.\n    \n3.  Select the **Redirect users to your own error page** option.\n    \n4.  Enter the URL of the error page you would like your users to see, and select **Save**.\n    \n\n### Redirect users to a custom error page using the Management API\n\nUse the Management API [Update Tenant Settings](https://auth0.com/docs/api/management/v2/#!/Tenants/patch_settings) endpoint. Replace the `{mgmtApiAccessToken}` placeholder value with your Management API Access Token, and update the value of the `url` field in the JSON body to point to the location of the error page.\n\n*   [cURL](#36308a408045434d8d59041687b8b880_shell)\n*   [C#](#36308a408045434d8d59041687b8b880_csharp)\n*   [Go](#36308a408045434d8d59041687b8b880_go)\n*   [Java](#36308a408045434d8d59041687b8b880_java)\n*   [Node.JS](#36308a408045434d8d59041687b8b880_node)\n*   [Obj-C](#36308a408045434d8d59041687b8b880_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/tenants/settings' \\\n  --header 'authorization: Bearer {mgmtApiAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"error_page\": {\"html\": \"\", \"show_log_link\":false, \"url\": \"http://www.example.com\"}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/tenants/settings\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer {mgmtApiAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"error_page\\\": {\\\"html\\\": \\\"\\\", \\\"show_log_link\\\":false, \\\"url\\\": \\\"http://www.example.com\\\"}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/tenants/settings\"\n\n\tpayload := strings.NewReader(\"{\\\"error_page\\\": {\\\"html\\\": \\\"\\\", \\\"show_log_link\\\":false, \\\"url\\\": \\\"http://www.example.com\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {mgmtApiAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/tenants/settings\")\n  .header(\"authorization\", \"Bearer {mgmtApiAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"error_page\\\": {\\\"html\\\": \\\"\\\", \\\"show_log_link\\\":false, \\\"url\\\": \\\"http://www.example.com\\\"}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/tenants/settings',\n  headers: {\n    authorization: 'Bearer {mgmtApiAccessToken}',\n    'content-type': 'application/json'\n  },\n  data: {error_page: {html: '', show_log_link: false, url: 'http://www.example.com'}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {mgmtApiAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"error_page\": @{ @\"html\": @\"\", @\"show_log_link\": @NO, @\"url\": @\"http://www.example.com\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/tenants/settings\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/tenants/settings\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"error_page\\\": {\\\"html\\\": \\\"\\\", \\\"show_log_link\\\":false, \\\"url\\\": \\\"http://www.example.com\\\"}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {mgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"error_page\\\": {\\\"html\\\": \\\"\\\", \\\"show_log_link\\\":false, \\\"url\\\": \\\"http://www.example.com\\\"}}\"\n\nheaders = {\n    'authorization': \"Bearer {mgmtApiAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/tenants/settings\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/tenants/settings\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer {mgmtApiAccessToken}'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"error_page\\\": {\\\"html\\\": \\\"\\\", \\\"show_log_link\\\":false, \\\"url\\\": \\\"http://www.example.com\\\"}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {mgmtApiAccessToken}\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"error_page\": [\n    \"html\": \"\",\n    \"show_log_link\": false,\n    \"url\": \"http://www.example.com\"\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/tenants/settings\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Value | Description |\n| --- | --- |\n| `MGMT_API_ACCESS_TOKEN` | [Access Token for the Management API](https://auth0.com/docs/api/management/v2/tokens) with the scope `update:tenant_settings`. |\n| `show_log_link` | Indicates whether to show a link to the error in your tenant logs. Valid values are `true` and `false`. |\n| `url` | Location of the custom error page to which you want to redirect. |\n\n### Render a custom error page\n\nUse the Management API [Update Tenant Settings](https://auth0.com/docs/api/management/v2/#!/Tenants/patch_settings) endpoint. Replace the `{mgmtApiAccessToken}` placeholder value with your Management API Access Token, and update the value of the `html` field in the JSON body to a string containing the HTML of your page.\n\nYou can use Liquid syntax to include the following variables:\n\n*   `{client_id}`\n    \n*   `{connection}`\n    \n*   `{lang}`\n    \n*   `{error}`\n    \n*   `{error_description}`\n    \n*   `{tracking}`\n    \n\n*   [cURL](#000d7970b9c94b6fa732eb83749cdd8a_shell)\n*   [C#](#000d7970b9c94b6fa732eb83749cdd8a_csharp)\n*   [Go](#000d7970b9c94b6fa732eb83749cdd8a_go)\n*   [Java](#000d7970b9c94b6fa732eb83749cdd8a_java)\n*   [Node.JS](#000d7970b9c94b6fa732eb83749cdd8a_node)\n*   [Obj-C](#000d7970b9c94b6fa732eb83749cdd8a_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url https://login.auth0.com/api/v2/tenants/settings \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"error_page\": {\"html\": \"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'\\''now'\\'' | date: '\\''%Y %h'\\''}}.</h1>\", \"show_log_link\": false, \"url\": \"\"}}'\n```\n\n```\nvar client = new RestClient(\"https://login.auth0.com/api/v2/tenants/settings\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"error_page\\\": {\\\"html\\\": \\\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\\\", \\\"show_log_link\\\": false, \\\"url\\\": \\\"\\\"}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://login.auth0.com/api/v2/tenants/settings\"\n\n\tpayload := strings.NewReader(\"{\\\"error_page\\\": {\\\"html\\\": \\\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\\\", \\\"show_log_link\\\": false, \\\"url\\\": \\\"\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://login.auth0.com/api/v2/tenants/settings\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"error_page\\\": {\\\"html\\\": \\\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\\\", \\\"show_log_link\\\": false, \\\"url\\\": \\\"\\\"}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://login.auth0.com/api/v2/tenants/settings',\n  headers: {\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {\n    error_page: {\n      html: '<h1>{{error | escape }} {{error_description | escape }} This error was generated {{\\'now\\' | date: \\'%Y %h\\'}}.</h1>',\n      show_log_link: false,\n      url: ''\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"error_page\": @{ @\"html\": @\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\", @\"show_log_link\": @NO, @\"url\": @\"\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://login.auth0.com/api/v2/tenants/settings\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://login.auth0.com/api/v2/tenants/settings\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"error_page\\\": {\\\"html\\\": \\\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\\\", \\\"show_log_link\\\": false, \\\"url\\\": \\\"\\\"}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"login.auth0.com\")\n\npayload = \"{\\\"error_page\\\": {\\\"html\\\": \\\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\\\", \\\"show_log_link\\\": false, \\\"url\\\": \\\"\\\"}}\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/api/v2/tenants/settings\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://login.auth0.com/api/v2/tenants/settings\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"error_page\\\": {\\\"html\\\": \\\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\\\", \\\"show_log_link\\\": false, \\\"url\\\": \\\"\\\"}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"error_page\": [\n    \"html\": \"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\",\n    \"show_log_link\": false,\n    \"url\": \"\"\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://login.auth0.com/api/v2/tenants/settings\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Value | Description |\n| --- | --- |\n| `MGMT_API_ACCESS_TOKEN` | [Access Token for the Management API](https://auth0.com/docs/api/management/v2/tokens) with the scope `update:tenant_settings`. |\n| `show_log_link` | Indicates whether to show a link to the error in your tenant logs. Valid values are `true` and `false`. |\n| `html` | HTML of the custom error page you want to render. |\n\nTo prevent XSS vulnerabilities, sanitize your custom template using Liquid's [escape](https://shopify.github.io/liquid/filters/escape/) and [strip\\_html](https://shopify.github.io/liquid/filters/strip_html/) filters.\n\n## Learn more\n\n*   [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login)",
  "title": "Customize Error Pages",
  "description": "Learn how to create a custom error page for authorization error events.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first",
  "markdown": "# Configure Identifier First Authentication\n\nIdentifier First login flows prompt users for their identifier and authentication method in two separate steps. For example, when you authenticate to Google websites, you enter your email first, click next, and then enter your password.\n\n## How it works\n\nThis two-step approach lets you customize a user's experience depending on the identifier they entered:\n\n*   When a user enters a corporate email (for example, `user@acme.com`), you can redirect them to acme.com’s corporate login page.\n    \n*   If a user enters an email for a personal account, you can prompt them for their password.\n    \n*   If the user's device is enrolled with WebAuthn w/Device Biometrics, they can use their device's biometric authenticators instead of a password.\n    \n\n![Auth0 Universal Login Identifier First authentication flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/31S2oC0o2NRiV2RsVE3yIw/5bac735d6a53792875d4793a26ae8931/HRD_Docs.png)\n\n## Configure Identifier First\n\n1.  Go to [Dashboard > Authentication > Authentication Profile](https://manage.auth0.com/#/authentication-profiles).\n    \n2.  Pick the flow you want to use:\n    \n    *   Identifier + Password: Users will enter their identifier and password on the same screen.\n        \n    *   Identifier First: Users will enter their identifier on the first screen. If the identifier matches the Identity Provider domain of the enterprise connection, users will be redirected to the enterprise connection's login page. If not, they will enter their password.\n        \n    *   Identifier First + Biometrics: The same as above, but if users are logging in from a device that supports WebAuthn w/Device Biometrics, they will be prompted to enroll that device, and they can use it in subsequent logins. You can learn more about this feature [here](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics)\n        \n\n## Define Home Realm Discovery identity providers\n\nWhen a user enters their email, Auth0 will check if the domain matches one from a registered Enterprise connection. If there's a match, Auth0 redirects the user to the enterprise identity provider’s login page. If the domain doesn't match, the user is prompted to enter their password. This is also known as Home Realm Discovery (HRD).\n\n1.  Go to [Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise).\n    \n2.  Select a connection.\n    \n3.  In the **Login Experience** tab set a maximum of 1000 domains. If you need more, please [contact support](https://support.auth0.com/).\n    \n4.  (Optional) Choose to display a button in the login page in addition to, or instead, of using the Identity Provider domains.\n    \n\n![Auth0 Authentication Enterprise Google Workspace Login Experience Tab Home Realm Discovery and Buttons](https://images.ctfassets.net/cdy7uua7fh8z/2urIgscBUaaMYHYFH1JJhX/cabd57d792abf01cb86df9cf509dd6a4/image.png)",
  "title": "Configure Identifier First Authentication",
  "description": "Learn how to configure Identifier First authentication with Universal Login.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/quickstart/backend/nodejs/03-troubleshooting",
  "markdown": "# Auth0 Node (Express) API SDK Quickstarts: Troubleshooting\n\nThis document will help you troubleshoot your configuration if you get unexpected responses from your API. We recommend that you log in to follow this quickstart with examples configured for your account.\n\nIf you configured JWT validation correctly, you will be able to get proper responses from your API when you make requests. However, in the case where you get a 401 (Unauthorized) response from your API, it is because the configuration of your JWT middleware does not match with the JWT which was passed.\n\nThis document will help you troubleshoot your JWT middleware configuration.\n\n## How Does a Token Get Validated?\n\nIn terms of validating a JWT, there are various things to consider:\n\n1.  **Is the token well-formed?** In other words, is this token conforming to the structure of a JSON Web Token (JWT)? To get more information on the structure of a JWT, please refer to [this section on the structure of a JWT](https://auth0.com/docs/jwt#what-is-the-json-web-token-structure-)\n    \n2.  **Has the token been tampered with?** The last part of a JWT is the signature. The signature is used to verify that the token was in fact signed by the sender and not altered in any way.\n    \n3.  **Has the token been received in its validity period?** JWTs are only valid for a specified time period (as expressed in the `exp` claim).\n    \n4.  **Is the token coming from the intended Authority?** This consists of 2 parts\n    \n    *   **Signature Verification**: Can we confirm that the JWT is correctly signed using the key issued by the issuing authority?\n        \n    *   **Issuer Value**: The Issuer is defined in the `iss` claim. Once again does this claim match up with what your application expects?\n        \n5.  **Is the token intended for the current application?** So does the `aud` claim of the JWT match with what your application is expecting?\n    \n\n## Inspecting a Token\n\nA quick way to inspect a JWT is by using the [JWT.io](https://jwt.io/) website. It has a handy debugger which allows you to quickly check that a JWT is well-formed, and also inspect the values of the various claims.\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-rs256.png)\n\nIn the screenshot above you can see that the token was signed using the **RS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://rs256.test.api**.\n\nSo, in other words, these values in your JWT validation configuration registration must match **exactly** - including the trailing slash for the Issuer, such as\n\n```\naudience = \"https://rs256.test.api\",\ndomain = \"https://jerrie.auth0.com/\"\n};\n```\n\nFor a token signed using HS256, the debugger view will look a little different:\n\n![Debugging a JWT on JWT.io](https://auth0.com/docs/media/articles/server-apis/aspnet-core-webapi/jwt-io-debugger-hs256.png)\n\nIn the screenshot above you can see that the token was signed using the **HS256** algorithm. The **Issuer** of the token is **https://jerrie.auth0.com/**, and the **Audience** is **https://hs256.test.api**.",
  "title": "Auth0 Node (Express) API SDK Quickstarts: Troubleshooting",
  "description": "This document will help you troubleshoot your configuration if you get unexpected responses from your API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions",
  "markdown": "# Manage Subscriptions\n\nIf you have an Enterprise subscription plan, please refer to your Auth0 agreement for details.\n\nIf you have a Self-Service subscription plan, you can manage your subscription plan from the Auth0 Dashboard:\n\n1.  Go to [Teams > Settings](https://accounts.auth0.com/) for Team-based subscriptions OR [Dashboard > Settings](https://manage.auth0.com/#/tenant/general) for Tenant-based subscriptions.\n    \n2.  Select the **Subscription** tab. You can customize your plan options like monthly or yearly billing, the maximum number of supported monthly Active Users, and more.\n    \n\n![Auth0 Tenant Settings Subscription tab](https://images.ctfassets.net/cdy7uua7fh8z/3yISRVTJOwP4Yo2uG0iZdO/540ac52cb14f13899e2c55f549f9c11e/Screenshot_2023-12-05_at_3.50.08_PM.png)\n\nStarting 1 December 2023, any Tenant-based subscription updates (except downgrades to Free) automatically converts to a Team-based subscription, allowing you benefits such as the ability to [link multiple tenants](https://auth0.com/docs/get-started/auth0-teams/tenant-management) within a single Self-Service subscription.\n\nIf you already have a Team-based subscription, instead of upgrading another tenant, you will have to instead link your tenant to the existing Team subscription.\n\n## Upgrade subscriptions\n\nYou can upgrade your subscription from a Free plan to an Essentials or a Professional plan or from an Essentials to a Professional. To upgrade to an Enterprise plan, [contact Auth0 Sales](https://auth0.com/get-started?place=header&type=button&text=talk%20to%20sales).\n\n1.  On the **Subscription** tab, scroll to the panels describing the plan options.\n    \n2.  Select a new plan and click **Checkout** to upgrade. If you do not have your billing information stored with Auth0, you'll need to provide it.\n    \n3.  Click **Subscribe Now** to confirm your information and activate your new subscription.\n    \n\n## Downgrade to a Free subscription\n\n1.  On the **Subscription** tab, scroll to the box associated with the Free plan and click **Checkout**.\n    \n2.  To confirm your subscription change, click **Subscribe Now**.\n    \n\n## Learn more\n\n*   [Downgrade or Cancel Auth0 Subscriptions](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/downgrade-or-cancel-subscriptions)\n*   [Delete or Reset Tenants](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/delete-or-reset-tenant)\n*   [Link Multiple Tenants to a Single Subscription](https://auth0.com/docs/get-started/auth0-overview/create-tenants/child-tenants)\n*   [Remove Tenant Members](https://auth0.com/docs/get-started/manage-dashboard-access/remove-dashboard-users)\n*   [Tenant Settings](https://auth0.com/docs/get-started/tenant-settings)\n*   [Reset Account Passwords](https://auth0.com/docs/troubleshoot/customer-support/reset-account-passwords)",
  "title": "Manage Subscriptions",
  "description": "Describes how to upgrade or change your Auth0 subscription.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/use-org-name-authentication-api",
  "markdown": "# Use Organization Names in Authentication API\n\nBy default, the [Authentication API](https://auth0.com/docs/api/authentication) uses organization IDs to identify specific organizations. If needed, you can configure your tenant to also use organization names as an identifier. However, there are usability and security implications to consider before enabling this feature. To better understand the potential impact, review the [Considerations and recommendations](#considerations-and-recommendations) section.\n\n## How it works\n\nConfiguring your tenant to support organization names in the Authentication API results in the following:\n\n*   The `organization` parameter in the [/authorize](https://auth0.com/docs/api/authentication#authorize-application) and [SAML](https://auth0.com/docs/api/authentication#saml) endpoints can accept both organization names and IDs.\n    \n*   Access and ID tokens automatically include both `org_name` and `org_id` claims.\n    \n\nYou can enable this feature through your Auth0 Dashboard or the Management API:\n\n*   **Auth0 Dashboard**: Select [Settings](https://auth0.com/docs/get-started/tenant-settings) from the left-side menu and choose the **Advanced** tab. In the **Settings** section, enable the **Allow Organization Names in Authentication API** toggle.\n    \n*   **Management API**: Use the `PATCH /api/v2/tenants/settings` endpoint to set `allow_organization_name_in_authentication_api` to `true`. For more information, review the [Management API](https://auth0.com/docs/api/management/v2) documentation.\n    \n\n### Example flow\n\nThe following example demonstrates an authorization code flow that uses organization names.\n\n1\\. Call the `/authorize` endpoint passing your organization name for the `organization` parameter:\n\nto configure this snippet with your account\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=code&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    scope={scope}&\n    state={state}&\n    organization={yourOrganizationName}\n```\n\n2\\. After obtaining the authorization code, call the `POST /oauth/token` endpoint to retrieve access and ID tokens:\n\nto configure this snippet with your account\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'code=yourAuthorizationCode}' \\\n  --data 'redirect_uri={https://yourApp/callback}'\n```\n\n3\\. The decoded tokens returned contain both the `org_id` and `org_name` claims:\n\n```\n{\n    \"sub\": \"google-oauth2|10...17\",\n    \"aud\": [\n        \"https://yourApp\"\n    ],\n    \"iat\": 1686840988,\n    \"exp\": 1686927388,\n    \"azp\": \"Suo...qTd\",\n    \"scope\": \"openid profile\",\n    \"org_id\": \"{yourOrganizationId}\",\n    \"org_name\": \"{yourOrganizationName}\"\n}\n```\n\n## Considerations and recommendations\n\nBefore using organization names in the Authentication API, it is important to understand the primary differences between organization names and IDs.\n\nUnlike organization IDs (which remain static), you can change the name of an organization at any time after initial creation. Additionally, you can reuse organization names within a single tenant as long as it's only assigned to **exactly one** organization at a time. In practice, this means you can change the name of one of your organizations and reuse its original name for another organization in your tenant. Organization names are only unique within a single tenant; the same name may be used for two or more organizations across multiple tenants.\n\nIn general, using organization IDs is recommended when validating tokens. However, if using organization names is more appropriate for your use case, consider the implications below when implementing the feature.\n\n### Usability and security considerations\n\nConsider the potential impacts below when using organization names to request and validate tokens:\n\n*   **Organization names can be reused**: Long-lived tokens do not expire when an organization changes its name, and the org\\_name claims in those tokens retain their original value. If the original name is later reused by a different organization, such tokens may grant users unauthorized access to data and resources managed by the new organization.\n    \n*   **Organization names are only unique within a single tenant**: If your API does not verify `iss` (issuer) claims in tokens, an organization with the same name in a different tenant could generate tokens that are incorrectly accepted by your API.\n    \n*   **Organization names can be changed**: If you change the name of an organization, your applications must provide the new organization name in Authentication API requests. As tokens can be long-lived, the `org_name` claim in a token may no longer match the current organization name, which could prevent applications from granting access to the appropriate organization.\n    \n\n### Recommended best practices\n\nDue to the possible security and usability impacts, using IDs instead of names to validate tokens is recommended when working with organizations. If you choose to use organization names, follow the best practices below for an optimal experience:\n\n*   Always validate the `iss` claim to ensure a token was issued by your Auth0 tenant.\n    \n*   Avoid reusing organization names that previously existed in your tenant. To prevent reuse and ensure previously issued tokens cannot be used to access different organizations, maintain an accurate and up-to-date record of historic organization names.\n    \n*   Avoid renaming organizations once they are in use unless absolutely necessary. If you choose to rename an organization, be aware that existing access and ID tokens do not automatically contain the new organization name. After renaming an organization, ensure you prompt users to log in again.",
  "title": "Use Organization Names in Authentication API",
  "description": "Setup, security considerations, and best practices for using organization names in the Authentication API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/manage-dashboard-access/feature-access-by-role",
  "markdown": "# Dashboard Access by Role\n\nAs a tenant administrator, you can assign roles to your colleagues that grant them limited access to the Auth0 Dashboard. This allows tenant members to complete their jobs without putting production applications at risk, while also complying with the principle of least privilege.\n\n## Dashboard roles\n\nYou can assign the following roles for Auth0 Dashboard access:\n\n| **Role** | **Permissions** |\n| --- | --- |\n| **Admin** | Read and write access to all resources in the Auth0 Dashboard. |\n| **Editor - Specific Apps** | Read and write access to specific applications only. |\n| **Editor - Connections** | Read, write, and create access to all types of connections. |\n| **Editor - Users** | User management operations (create, delete, block, unblock, reset MFA, reset password, update metadata, assign roles, etc.) and access to logs. |\n| **Editor - Organizations** | Read, write, and create access to Organization configuration. Read-only access to Users, Roles, and Connections. |\n| **Viewer - Users** | Read-only access to users and logs. |\n| **Viewer - Config Settings** | Read-only access to all configuration settings (applications, APIs, rules, security settings, etc.) except for sensitive information such as secrets, billing, users, and logs. |\n| **Support Access - Deprecated** | Access to tickets (submit, view, and update) and aggregated metrics. |\n| **Elevated Support Access** | Read, write, and create access to **all** support tickets created by **all users** on a tenant (Subscripton Tickets in Auth0 Support Center). Access to aggregated metrics. |\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects the availability of this feature. To learn more, read [Auth0's Pricing Page](https://auth0.com/pricing).\n\nLimited-access roles restrict a tenant member's Dashboard experience to only the sections and actions necessary for their job.\n\nThe feature permissions associated with each role are outlined below. If a specific permission is not listed for a role, tenant members given that role will not have access to that area of the Auth0 Dashboard.\n\n## Log events available to user roles\n\nLogs can contain sensitive data, such as secrets, PII, etc. It is important not to disclose sensitive data to users whose role does not require that information. However, the **Editor - Users** or **Viewer - Users** roles need to have some access to logs to identity user issues. For example, finding out if the user signed up correctly, if the user was blocked, etc.\n\nWe allow the **Editor - Users** and **Viewer - Users** with access to a limited set of log types, that are connected to user events. The log events in the list provide the necessary information about user actions but do not disclose sensitive information about other parts of the tenant configuration. To learn more, read [Log Event Type Codes](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes).\n\n```\ncls\ncs\nf\nfce\nfcoa\nfcp\nfcpn\nfcpr\nfcu\nfdeac\nfdeaz\nfdecc\nfdu\nfeacft\nfeccft\nfede\nfens\nfeoobft\nfeotpft\nfepft\nfepotpft\nfercft\nfi\nflo\nfn\nfp\nfs\nfsa\nfu\nfui\nfv\nfvr\ngd_auth_failed\ngd_auth_rejected\ngd_auth_succeed\ngd_enrollment_complete\ngd_otp_rate_limit_exceed\ngd_recovery_failed\ngd_recovery_rate_limit_exceed\ngd_recovery_succeed\ngd_send_email\ngd_send_email_failure\ngd_send_pn\ngd_send_pn_failure\ngd_send_sms\ngd_send_sms_failure\ngd_send_voice\ngd_send_voice_failure\ngd_start_auth\ngd_start_enroll\ngd_tenant_update\ngd_unenroll\ngd_update_device_account\nlimit_mu\nlimit_wc\nmfar\npwd_leak\ns\nsce\nscoa\nscp\nscpn\nscpr\nscu\nsdu\nseacft\nsede\nsens\nseoobft\nseotpft\nsepft\nsercft\nsi\nslo\nss\nssa\nsv\nsvr\nublkdu\nw\n```\n\n## Limitations\n\n*   Users with **Admin** role can invite **Editor - Specific Apps** users to one application at a time. To work around this, the **Admin** user can [edit their role](https://auth0.com/docs/get-started/manage-dashboard-access/edit-dashboard-users) to assign multiple applications after the user accepts the invitation.\n    \n*   The **Viewer - Users** and **Editor - Users** roles don't have access to the Users' **Devices** and **Authorized Apps** sections.\n    \n*   The [New Activity Page](https://auth0.com/docs/get-started/dashboard/activity) is visible to **Admins** and **Elevated Support Access** users only. **Editor - Users** and **Viewer - Users** can access daily activity (such as logins or signups) through the [Auth0 Management API](https://auth0.com/docs/api/management/v2#!/Stats/get_daily).\n    \n\n## Private Cloud requirements\n\nThe **Editor - Users** and the **Viewer - Users** roles require that User Search v3 and Logs Search v3 are enabled in your environment. If your environments don’t support these versions, these two roles are unavailable.\n\n## Learn more\n\n*   [Add Tenant Members](https://auth0.com/docs/get-started/manage-dashboard-access/add-dashboard-users)\n*   [Edit Tenant Members](https://auth0.com/docs/get-started/manage-dashboard-access/edit-dashboard-users)\n*   [Remove Tenant Members](https://auth0.com/docs/get-started/manage-dashboard-access/remove-dashboard-users)\n*   [Troubleshoot Role-Based Access Control and Authorization](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-rbac-authorization)\n*   [Check Error Messages](https://auth0.com/docs/troubleshoot/basic-issues/check-error-messages)",
  "title": "Dashboard Access by Role",
  "description": "Describes each tenant member role and provides details about what Auth0 Dashboard features they have access to.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/manage-dashboard-access/edit-dashboard-users",
  "markdown": "# Edit Tenant Members\n\nIf you are a tenant administrator, you can change a user's assigned role(s). The changes take effect after users refresh their Dashboard.\n\nYou can assign a user more than one role and the permissions will be combined. You must have already added the tenant member.\n\n1.  Go to [Dashboard > Settings > Tenant Members](https://manage.auth0.com/#/tenant/admins).\n    \n    ![Auth0 Tenant Settings Tenant Members Tab](https://images.ctfassets.net/cdy7uua7fh8z/31k0wWw5X3JTGV47Q5PHyq/a1c64c6a655e419fac7bd2c5511a360e/Dashboard_-_Tenant_Settings_-_Tenant_Members.png)\n2.  Click **...** to the right of a user name or email and click **Edit Roles**. If you don't see that option, it means that the user has not yet accepted their invitation.\n    \n3.  Select additional roles or remove roles.\n    \n4.  Click **Save**.\n    \n\n**Password resets**: To learn more, read [Reset Auth0 Account Password](https://auth0.com/docs/troubleshoot/customer-support/reset-account-passwords) if you or one of your Dashboard users is having issues logging in.\n\n**Email address invalid**: To learn more, read [Update Dashboard User Email Addresses](https://auth0.com/docs/get-started/manage-dashboard-access/update-dashboard-user-email) to view email addresses for your tenant members and update if necessary.\n\n## Learn more\n\n*   [Dashboard Access by Role](https://auth0.com/docs/get-started/manage-dashboard-access/feature-access-by-role)\n*   [Add Tenant Members](https://auth0.com/docs/get-started/manage-dashboard-access/add-dashboard-users)\n*   [Remove Tenant Members](https://auth0.com/docs/get-started/manage-dashboard-access/remove-dashboard-users)\n*   [Troubleshoot Role-Based Access Control and Authorization](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-rbac-authorization)",
  "title": "Edit Tenant Members",
  "description": "Learn how to edit Auth0 Dashboard user roles for your Auth0 tenant.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/delete-or-reset-tenant",
  "markdown": "# Delete or Reset Tenants\n\nYou can delete your Auth0 tenant or reset it to the default configuration in the Auth0 Dashboard. You can delete your Auth0 account data with assistance from Auth0 Support.\n\n## Delete tenant\n\nBefore you delete a tenant, consider the following options:\n\n*   [Change tenant ownership](https://auth0.com/docs/get-started/manage-dashboard-access).\n    \n*   [Reset tenant configuration](#reset-tenant-configuration).\n    \n\n### Remove custom domain\n\nIf you configured a custom domain for a tenant you'd like to delete, you need to remove the custom domain first. If you do not, you cannot configure the custom domain for another tenant.\n\n### Determine deletion process\n\nThe process for deleting a tenant depends on the [subscription plan](https://www.auth0.com/pricing) it's associated with and the [type of tenant](https://auth0.com/docs/get-started/auth0-overview/create-tenants/child-tenants) it is (main or child). You may be able to delete the tenant in the [Auth0 Dashboard](#delete-tenant-in-auth0-dashboard), or you may need to [contact Auth0 Support or Community](#contact-auth0-support-or-community).\n\n|     | **Free Plan** | **Self-service plan** | **Enterprise plan** |\n| --- | --- | --- | --- |\n| **Main tenant** | Auth0 Dashboard | Auth0 Dashboard | Contact Auth0 Support |\n| **Main tenant with child tenants** | Contact Auth0 Community | Contact Auth0 Support | Contact Auth0 Support |\n| **Child tenant** | Auth0 Dashboard | Auth0 Dashboard | Auth0 Dashboard |\n\n### Downgrade tenant\n\nBefore you can delete a tenant in the Dashboard, you must downgrade it to the Free plan. To learn more, read [Downgrade or Cancel Auth0 Subscriptions](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/downgrade-or-cancel-subscriptions).\n\n### Delete tenant in Dashboard\n\nYou can delete a tenant in the Dashboard if you have the [appropriate level of access](https://auth0.com/docs/get-started/manage-dashboard-access/feature-access-by-role).\n\n1.  Go to [Dashboard > Settings](https://manage.auth0.com/#/tenant/advanced), and then switch to the **Advanced** view.\n    \n2.  Locate **Danger Zone** at the bottom of the page, and then select **Delete**.\n    \n3.  Review the confirmation prompt and confirm that you want to permanently delete your tenant.\n    \n4.  Select **Yes, Delete Tenant**.\n    \n\nIf your tenant is on a Trial, Essential, Professional, or Enterprise plan and you cannot delete your tenant in the Auth0 Dashboard, [open a ticket with Auth0 Support](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets) for assistance.\n\nIf your tenant is on a Free plan and you cannot delete it in the Auth0 Dashboard, [post in Auth0 Community](https://community.auth0.com/) and ask for assistance.\n\n## Reset tenant configuration\n\nYou can reset your tenant to its default configuration with the [Auth0 Deploy CLI](https://github.com/auth0/auth0-deploy-cli).\n\nThe Deploy CLI is a tool that helps you manage your Auth0 tenant configuration. It integrates into your development workflows as a standalone CLI or as a node module. To learn more about the Deploy CLI tool and how to get started, read [Deploy CLI Tool](https://auth0.com/docs/deploy-monitor/deploy-cli-tool).\n\n## Delete Auth0 account data\n\nIf you want to delete your Auth0 account data (including email address, billing information, and so on), follow the steps to delete your tenant, and then [post in Auth0 Community](https://community.auth0.com/) and ask for assistance.\n\nTo learn more about Auth0's responsibilities as a data controller, read the [Okta Privacy Policy](https://www.okta.com/privacy-policy/).\n\n## Learn more\n\n*   [Downgrade or Cancel Auth0 Subscriptions](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/downgrade-or-cancel-subscriptions)\n*   [Export Data](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data)",
  "title": "Delete or Reset Tenants",
  "description": "Learn how to delete your tenant or reset it to the default configuration.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/manage-dashboard-access/update-dashboard-user-email",
  "markdown": "# Update Dashboard User Email Addresses\n\nAs a tenant administrator, you can update the email address associated with an existing Auth0 Dashboard member by adding a new user with the new email address and removing the user associated with the old email address.\n\n1.  Go to [Dashboard > Settings > Tenant Members](https://manage.auth0.com/#/tenants/admins).\n    \n2.  Click **Add Member**.\n    \n3.  Enter the new email address and select the access permissions.\n    \n4.  Click **Invite** to send the email invitation to the user.\n    \n5.  Once the user accepts the invitation, remove the user associated with the old email address.\n    \n\n## Learn more\n\n*   [Reset Account Passwords](https://auth0.com/docs/troubleshoot/customer-support/reset-account-passwords)",
  "title": "Update Dashboard User Email Addresses",
  "description": "Learn how to update Auth0 Dashboard tenant member email addresses.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/manage-dashboard-access/add-dashboard-users",
  "markdown": "# Add Tenant Members\n\nIf you are a tenant administrator, you can add colleagues to the tenant and assign them a specific role to allow them access to the Auth0 Dashboard features they need.\n\nWhen you add new tenant members, you can assign roles that allow them access without putting production applications and sensitive information at risk. You can assign a user more than one role and the permissions will be combined. For further protection, users can turn on [multi-factor authentication](https://auth0.com/docs/get-started/manage-dashboard-access/add-change-remove-mfa) (MFA). To learn more about which Dashboard features are accessible with each role, read [Dashboard Access by Role](https://auth0.com/docs/get-started/manage-dashboard-access/feature-access-by-role).\n\n| **Role** | **Permissions** |\n| --- | --- |\n| **Admin** | Read and write access to all resources in the Auth0 Dashboard. |\n| **Editor - Specific Apps** | Read and write access to specific applications only. |\n| **Editor - Connections** | Read, write, and create access to all types of connections. |\n| **Editor - Users** | User management operations (create, delete, block, unblock, reset MFA, reset password, update metadata, assign roles, etc.) and access to logs. |\n| **Editor - Organizations** | Read, write, and create access to Organization configuration. Read-only access to Users, Roles, and Connections. |\n| **Viewer - Users** | Read-only access to users and logs. |\n| **Viewer - Config Settings** | Read-only access to all configuration settings (applications, APIs, rules, security settings, etc.) except for sensitive information such as secrets, billing, users, and logs. |\n| **Support Access - Deprecated** | Access to tickets (submit, view, and update) and aggregated metrics. |\n| **Elevated Support Access** | Read, write, and create access to **all** support tickets created by **all users** on a tenant (Subscripton Tickets in Auth0 Support Center). Access to aggregated metrics. |\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n1.  Go to [Dashboard > Settings > Tenant Members](https://manage.auth0.com/#/tenant/admins).\n    \n    ![Auth0 Tenant Settings Tenant Members Tab](https://images.ctfassets.net/cdy7uua7fh8z/31k0wWw5X3JTGV47Q5PHyq/a1c64c6a655e419fac7bd2c5511a360e/Dashboard_-_Tenant_Settings_-_Tenant_Members.png)\n2.  Click **Add Member**.\n    \n3.  On the **Add New Tenant Member** screen, enter the user's email address and select the roles you would like to assign to them.\n    \n    ![Dashboard Tenant Settings Tenant Members Tab Add Member](https://images.ctfassets.net/cdy7uua7fh8z/2OBx7T6HCvlXZJunHHjuKa/aab976286d7425761ceda23b540675d6/Team_Name_-_Dashboard_Setting_-_Border.png)\n4.  Click **Invite**. Auth0 will send an email to the user with a link for them to click to accept the invitation. Before the user accepts the invitation, they will appear in the Invitations list as pending. If you click the `**...**` you will see **Remove invitation** or **Copy invitation link**.\n    \n\n#### Missing tenants\n\nUsers can create Auth0 accounts in different ways. For example, they can sign up with a social provider (e.g., Google, GitHub), then sign up again using their email address. If your tenant members cannot see all of their tenants after logging in, check to see if they have multiple Auth0 accounts. You can view the signup method used by the Dashboard tenant member by going to [Dashboard > Tenant Settings > Tenant Members](https://manage.auth0.com/#/tenant/admins).\n\nWhen the invited user clicks the link to accept the invitation, they will be asked to log in with the invited email address. They can then choose whether to log in with a social provider or to log in with their email address and password. If they choose to log in with their email address and password, they must have already created an account with Auth0, or they will need to sign up first and then accept the invitation again.\n\n## Learn more\n\n*   [Dashboard Access by Role](https://auth0.com/docs/get-started/manage-dashboard-access/feature-access-by-role)\n*   [Edit Tenant Members](https://auth0.com/docs/get-started/manage-dashboard-access/edit-dashboard-users)\n*   [Remove Tenant Members](https://auth0.com/docs/get-started/manage-dashboard-access/remove-dashboard-users)\n*   [Troubleshoot Role-Based Access Control and Authorization](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-rbac-authorization)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)\n*   [Troubleshoot Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues)",
  "title": "Add Tenant Members",
  "description": "Learn how to add tenant members to access the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/manage-dashboard-access/remove-dashboard-users",
  "markdown": "# Remove Tenant Members\n\nWas this article helpful?",
  "title": "Remove Tenant Members",
  "description": "Learn how to remove tenant members from access to the Auth0 Dashboard for your Auth0 tenant.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/manage-dashboard-access/configure-single-sign-on-for-auth0-dashboard",
  "markdown": "# Configure Single Sign-on for Auth0 Dashboard\n\nYou can configure Auth0 to allow [Tenant Members](https://auth0.com/docs/get-started/manage-dashboard-access) to use your own [Enterprise identity provider](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers) (IdP) to authenticate to the Auth0 Dashboard through single sign-on (SSO).\n\n## How it works\n\nConfiguring SSO for the Dashboard requires you to work with Auth0 Support to add an Enterprise connection to the root tenant authority (RTA), which manages the available authentication methods a Tenant Member can use to log in to the Dashboard.\n\nAdding this SSO connection does not restrict Tenant Members from logging in using the existing authentication methods (such as email/password, [LinkedIn](https://marketplace.auth0.com/integrations/linkedin-social-connection), [Microsoft](https://marketplace.auth0.com/integrations/microsoft-account-social-connection), [GitHub](https://marketplace.auth0.com/integrations/github-social-connection), or [Google](https://marketplace.auth0.com/integrations/google-social-connection)).\n\nConfiguring SSO for the Dashboard also enables SSO for all public Auth0 sites, such as:\n\n*   Auth0 website ([https://auth0.com](https://auth0.com/))\n    \n*   Auth0 Community ([https://community.auth0.com](https://community.auth0.com/))\n    \n*   Auth0 Docs ([https://www.auth0.com/docs](https://www.auth0.com/docs))\n    \n*   Auth0 Support Center ([https://support.auth0.com](https://support.auth0.com/))\n    \n\n### User experience\n\nWhen an authorized user goes to log in to the Dashboard, they enter their email address for a registered domain (for example, `user@example.com`) into the Auth0 Universal Login page, and then are redirected to your IdP to complete authentication.\n\n### Limitations\n\nBefore you decide to configure SSO for the Dashboard, please consider the restrictions:\n\n*   SSO cannot be limited to specific tenants.\n    \n*   SSO does not support IdP-initiated authentication flows.\n    \n*   Tenant Member invitations cannot be automated or sent in bulk with the Auth0 Management API.\n    \n*   Tenant Member access cannot be managed by your IdP’s group memberships.\n    \n*   MFA cannot be enforced for all members of a tenant.\n    \n\n### Considerations\n\n#### Full directory access to Dashboard\n\nWhen you add your IdP as an available connection for Tenant Members to log in on, all of the users in your IdP’s directory are able to access the Dashboard, but only the Tenant Members who have been invited to a given tenant are able to access that tenant.\n\nIf a user attempts to access a tenant in the Dashboard that they have not been invited to, they are prompted to [complete user profiling](#complete-user-profiling) and create a new trial tenant. If they create a new trial tenant, it will not be associated with your Enterprise plan.\n\n#### Residual Tenant Member identities\n\nIf a Tenant Member was invited (and had access) to a tenant in the Dashboard using a different identity than the one created on the new connection, they will still—technically—be able to use that identity to access the tenant.\n\nYou’ll have to decide if you want to remove their old identity, or keep it as a potential alternative authentication method.\n\n## Configure SSO for the Dashboard\n\nConfiguring SSO for the Dashboard requires a series of steps shared between you and Auth0 Support.\n\n[Open a ticket with Auth0 Support](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets) to share your IdP’s configuration data so they can set up the SSO configuration. Include the following information when you submit your ticket:\n\n*   Email domain(s) you’d like to associate with the SSO configuration\n    \n*   Name of the IdP\n    \n*   Authentication protocol\n    \n*   Additional IdP-specific information\n    \n\nThere are additional configuration steps required depending on the IdP and authentication protocol you’d like to use:\n\n#### ADFS (SAML)\n\n1.  [Create a Relying Party Trust](https://learn.microsoft.com/en-us/windows-server/identity/ad-fs/operations/create-a-relying-party-trust#to-create-a-claims-aware-relying-party-trust-manually) with the following properties:\n    \n    | **Property** | **Values** |\n    | --- | --- |\n    | Entity ID | `urn:auth0:auth0:{assignedConnectionName}` |\n    | Callback endpoint | `https://auth0.auth0.com/login/callback` |\n    \n2.  [Add a claim description](https://learn.microsoft.com/en-us/windows-server/identity/ad-fs/operations/add-a-claim-description) for each of the following claims:\n    \n    | **Claim** | **Claim identifier** | **Value** |\n    | --- | --- | --- |\n    | Name Identifier | `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier` | `E-Mail-Addresses` or `User-Principal-Name` |\n    | Email Address | `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress` | N/A |\n    | Name | `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name` | N/A |\n    \n3.  Enable the SAML 2.0 endpoint.\n    \n4.  Provide Auth0 Support with the following information:\n    \n    *   Login endpoint (for example, `https://{yourServer}/adfs/ls`)\n        \n    *   Signing certificate, or the SAML metadata XML file\n        \n\n1.  [Create a new App registration](https://learn.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app).\n    \n2.  Set the **Redirect URI** type to Web, and the value to `https://auth0.auth0.com/login/callback`.\n    \n3.  Select **Register**.\n    \n4.  [Enable the Implicit Grant](https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-implicit-grant-flow#send-the-sign-in-request) for the ID Token.\n    \n5.  [Add the email claim](https://learn.microsoft.com/en-us/azure/active-directory/develop/active-directory-optional-claims) to the ID Token.\n    \n6.  Provide Auth0 Support with the following information: \n    \n    *   The application (client) ID\n        \n    *   The OIDC metadata endpoint (for example, `https://login. microsoftonline.com/{yourAzureAdTenantId}/v2.0/.well-known/openid-configuration`)\n        \n\n1.  [Create a new Enterprise Application](https://learn.microsoft.com/en-us/azure/active-directory/manage-apps/add-application-portal).\n    \n2.  Set up [single sign-on for SAML](https://learn.microsoft.com/en-us/azure/active-directory/develop/single-sign-on-saml-protocol) with the following properties (you may need to use placeholder values until Auth0 Support can provide you with the SSO connection’s name):\n    \n    | **Property** | **Value** |\n    | --- | --- |\n    | Identifier (Entity ID) | `urn:auth0:auth0:{assignedConnectionName}` |\n    | Reply (ACS) URL | `https://auth0.auth0.com/login/callback` |\n    | Sign-on URL | `https://manage.auth0.com/login?connection={assignedConnectionName}` |\n    \n3.  Leave the **Attributes & Claims** section - including `email`, `Unique User Identifier`, and optionally `name -` unchanged from Azure's suggestions.\n    \n4.  Provide Auth0 Support with the SAML metadata XML data. You can either:\n    \n    *   Share the App Federation Metadata URL (for example, `https://login.microsoftonline.com/{azureAdTenantId}/federationmetadata /2007-06/federationmetadata.xml?appid={appId}`).\n        \n    *   Download the Federation Metadata XML document and attach it to the ticket.\n        \n\n#### Google (SAML)\n\nAuth0 supports configuring SSO for the Dashboard with a Google SAML IdP, but it’s recommended that you direct users to log in with the existing Google authentication method.\n\nWhen a user logs in to the Google SAML IdP, Auth0 creates a new user identity for them (separate from their existing Google user identity), which may be confusing.\n\nIf you’d like to set up SSO for the Dashboard with a Google SAML IdP, read [Generic IdP (SAML)](#generic-idp-saml) for instructions.\n\n#### Okta (SAML)\n\n1.  Create a SAML application with the following properties (you may need to use placeholder values until Auth0 Support can provide you with the SSO connection’s name):\n    \n    | **Property** | **Value** |\n    | --- | --- |\n    | Entity ID | `urn:auth0:auth0:{assignedConnectionName}` |\n    | Callback endpoint (ACS URL) | `https://auth0.auth0.com/login/callback` |\n    \n2.  Set the **Name Identifier** to send the email address of the user.\n    \n3.  Provide Auth0 Support with the SAML metadata XML data. You can either:\n    \n    *   Share the SAML metadata XML URL:\n        \n        1.  Locate the **SAML Signing Certificates** section.\n            \n        2.  Select the **Actions** menu.\n            \n        3.  Select **View IdP metadata**, and then select **Copy Link Address**. It will have this format: `https://{org}.okta.com/app/{appId}/sso/saml/metadata`.\n            \n    *   Download the SAML metadata XML file and attach it to the ticket.\n        \n\n##### IdP-initiated authentication flows\n\nSSO for the Dashboard does not support IdP-initiated authentication flows. If you want users to be able to select a chiclet to log in to the Dashboard you need to: \n\n1.  Hide the SAML app from users.\n    \n2.  [Create a Bookmark App](https://help.okta.com/en/prod/Content/Topics/Apps/Apps_Bookmark_App.htm) that points to `https://manage.auth0.com/login?connection={assignedConnectionName}`. This is the application that users will be able to select to log in.\n    \n\nMake sure you enable both the SAML application and the Bookmark App for the same set of users that can use the application.\n\n#### OneLogin (SAML)\n\n1.  Create a SAML Test Connector (SP) with the following properties (you may need to use placeholder values until Auth0 Support can provide you with the SSO connection’s name):\n    \n    | **Property** | **Value** |\n    | --- | --- |\n    | Entity ID | `urn:auth0:auth0:{assignedConnectionName}` |\n    | Callback endpoint (ACS URL) | `https://auth0.auth0.com/login/callback` |\n    | Login URL | `https://manage.auth0.com/login?connection={assignedConnectionName}` |\n    \n2.  Provide Auth0 Support with the SAML metadata XML file.\n    \n\n#### Generic IdP (OIDC)\n\n1.  Register an application (client) with the IdP with the following properties:\n    \n    | **Property** | **Value** |\n    | --- | --- |\n    | Callback URL | `https://auth0.auth0.com/login/callback` |\n    \n2.  Provide Auth0 Support with the:\n    \n    *   Application (client) ID\n        \n    *   Issuer URL or OIDC metadata endpoint (for example, `https://{idpDomain}/[...]/.well-known/openid-configuration`)\n        \n\n#### Generic IdP (SAML)\n\n1.  Auth0 Support will provide you with the SSO connection's name.\n    \n2.  Create a SAML application with the following properties:\n    \n    | **Property** | **Value** |\n    | --- | --- |\n    | Entity ID | `urn:auth0:auth0:{assignedConnectionName}` |\n    | Callback endpoint | `https://auth0.auth0.com/login/callback` |\n    \n3.  Ensure that the SAML assertions contain the following claims:\n    \n    | **Claim** | **Claim identifier** | **Value** |\n    | --- | --- | --- |\n    | Name Identifier | `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier` | `upn` or `emailaddress` |\n    | Email Address | `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress` | N/A |\n    | Name | `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name` | N/AA |\n    \n4.  Provide Auth0 Support with either the:\n    \n    *   Sign-in URL and signing certificate\n        \n    *   SAML metadata XML file\n        \n\n### Set up SSO connection\n\nThe Auth0 Support team uses the configuration data you provide to complete initial setup of the SSO connection.\n\nHome Realm Discovery (HRD) is not configured during initial setup.\n\n### Test SSO connection\n\nWhen initial setup of the SSO connection is complete, the Auth0 Support team has you test the SSO connection to ensure the configuration data was correct, and that Tenant Members can authenticate on the SSO connection in the manner you’re looking for.\n\nThe Auth0 Support team provides you with a direct login URL you can use to prompt authentication for the new SSO connection. For example:\n\n`https://manage.auth0.com/login?connection={assignedConnectionName}`\n\n## Enforce SSO with Auth0 Teams\n\nIf you use Auth0 Teams with your Enterprise tenant, you can enforce SSO authentication for the tenants that belong to the Teams account. To learn more about tenant administration and management, read [Auth0 Teams](https://auth0.com/docs/get-started/auth0-teams).\n\n1.  Open a new browser and enter your Teams account and identifier: `https://accounts.auth0.com/teams/{team-identifier}.`\n    \n2.  Navigate to the **Security** page.\n    \n3.  [Configure the Security Policies](https://auth0.com/docs/get-started/auth0-teams/configure-security-policies) by selecting **Enforce Single Sign On**.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3LFdDLZALsxV9k7cI8qplK/f2810fe059e98010126d34300a0f5afb/Auth0_Teams_-_Configure_Security_Policies_-_2-3.png)\n\n### Enable Home Realm Discovery (optional)\n\nIf you’re using Universal Login or Classic Login, you can request to enable HRD, so the login page recognizes the domain of the email address the Tenant Member enters, and then directs them to the new SSO connection.\n\n#### When to enable HRD\n\nIf HRD is enabled, Tenant Members that previously used an email/password identity (with an email matching the configured HRD domain) won’t be able to log in through the login page.\n\nDue to this change in behavior, request to enable HRD only after at least some of the current Tenant Members are aware of the change, and that they know that they’ll either:\n\n*   Receive an invitation to join the tenants under the new identity\n    \n*   Need to re-invite themselves with the new identity\n    \n\n#### How to bypass HRD\n\nIf a Tenant Member needs to log in with their email/password identity, you can provide them with a direct login URL:\n\n`https://manage.auth0.com/login?connection=auth0`\n\nThis URL bypasses HRD, and allows them to log in with their email/password identity.\n\n#### Example of HRD login behavior\n\nHere’s an example of a list of Tenant Members:\n\n| **Tenant** | **Tenant Member** | **Connection** | **Affected?** |\n| --- | --- | --- | --- |\n| `fabrikam@us` | `user1@example.com` | email/password | Yes |\n| `fabrikam@us` | `user1@gmail.com` | google-oauth2 | No  |\n| `fabrikam@us` | `user2@example.com` | github | No  |\n| `fabrikam@us` | `user3@acme.com` | email/password | No  |\n| `fabrikam@us` | `user4@example.com` | email/password | Yes |\n| `fabrikam-dev@us` | `user5@example.com` | email/password | Yes |\n| `fabrikam-dev@us` | `user1@example.com` | email/password | Yes |\n\nIf we associate the example.com domain to the new connection, the Tenant Members `user1@gmail.com`, `user2@example.com`, and `user3@acme.com` are able to log in as they have previously, because they use either a social provider, or an email with a unassociated domain.\n\nAlternatively, the Tenant Members `user1@example.com`, `user4@example.com`, and `user5@example.com` are not able to log in as they have previously, because their emails are associated with the domain configured for HRD.\n\n## Migrate existing Tenant Members\n\nThe process to migrate existing Tenant Members depends on whether you have enabled HRD.\n\n### How to migrate with HRD disabled\n\nTo migrate Tenant Members with HRD disabled, you need to share the direct login URL for the new SSO connection:\n\n`https://manage.auth0.com/login?connection={assignedConnectionName}` \n\n1.  [Create a new Tenant Member invitation](https://auth0.com/docs/get-started/manage-dashboard-access/add-dashboard-users) for the Tenant Member.\n    \n2.  Instruct the Tenant Member to:\n    \n    1.  Log in on the new SSO connection by using the direct login URL before accepting the invitation. If this is the first time they are logging in on the new SSO connection, they may need to [complete user profiling](#complete-user-profiling).\n        \n    2.  Copy and paste the invitation URL they received in the invitation email into the same browser where they logged in on the new SSO connection. Users should not select **Create Account**.\n        \n    3.  Accept the invitation.\n        \n\n### How to migrate with HRD enabled\n\nTo migrate Tenant members with HRD enabled, you need to follow steps similar to [adding Tenant Members](https://auth0.com/docs/get-started/manage-dashboard-access/add-dashboard-users):\n\n1.  [Create a new Tenant Member invitation](https://auth0.com/docs/get-started/manage-dashboard-access/add-dashboard-users) for the Tenant Member.\n    \n2.  Instruct the Tenant Member to:\n    \n    1.  Log out of the Dashboard (if they had previously logged in with an old identity).\n        \n    2.  Open the invitation link in the invitation email they received.\n        \n    3.  Log in on the new connection.\n        \n    4.  Accept the invitation.\n        \n\n### Complete user profiling\n\nWhen a Tenant Member logs in to the new SSO connection for the first time, they'll see a form where they need to specify their type of responsibilities.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/1KRnEYyDA12TgSc4x5cAv2/65d4060341be29b46cf1d7f3b2d9e84c/Complete_User_Profiling_-_Role.png)\n\nInstruct the Tenant Member to:\n\n1.  Select **Yes, Coding**.\n    \n2.  Select **I need advanced settings**.\n    \n3.  Select **Next**, and then continue to the next screen.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/3BAi4zQ7X6zijvbdHXTG0S/5bbe3a87be81377b15ab57338f795565/Complete_User_Profiling_-_Tenant.png)\n4.  Do not select Create Account. Instead paste the invitation link they received in the invitation email.\n    \n5.  Accept the invitation.",
  "title": "Configure Single Sign-on for Auth0 Dashboard",
  "description": "Learn how to configure single sign-on (SSO) for the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/apis/delete-api-permissions",
  "markdown": "# Delete API Permissions\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/resource-servers/API_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"scopes\": [ { \"value\": \"PERMISSION_NAME\", \"description\": \"PERMISSION_DESC\" }, { \"value\": \"PERMISSION_NAME\", \"description\": \"PERMISSION_DESC\" } ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/resource-servers/API_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"scopes\\\": [ { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" }, { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" } ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/resource-servers/API_ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"scopes\\\": [ { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" }, { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" } ] }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/resource-servers/API_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"scopes\\\": [ { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" }, { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" } ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/resource-servers/API_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    scopes: [\n      {value: 'PERMISSION_NAME', description: 'PERMISSION_DESC'},\n      {value: 'PERMISSION_NAME', description: 'PERMISSION_DESC'}\n    ]\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"scopes\": @[ @{ @\"value\": @\"PERMISSION_NAME\", @\"description\": @\"PERMISSION_DESC\" }, @{ @\"value\": @\"PERMISSION_NAME\", @\"description\": @\"PERMISSION_DESC\" } ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/resource-servers/API_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/resource-servers/API_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"scopes\\\": [ { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" }, { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" } ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"scopes\\\": [ { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" }, { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" } ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/resource-servers/API_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/resource-servers/API_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"scopes\\\": [ { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" }, { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" } ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"scopes\": [\n    [\n      \"value\": \"PERMISSION_NAME\",\n      \"description\": \"PERMISSION_DESC\"\n    ],\n    [\n      \"value\": \"PERMISSION_NAME\",\n      \"description\": \"PERMISSION_DESC\"\n    ]\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/resource-servers/API_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Delete API Permissions",
  "description": "Learn how to delete permissions from APIs using the Auth0 Dashboard or the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/apis/add-api-permissions",
  "markdown": "# Add API Permissions\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/resource-servers/API_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"scopes\": [ { \"value\": \"PERMISSION_NAME\", \"description\": \"PERMISSION_DESC\" }, { \"value\": \"PERMISSION_NAME\", \"description\": \"PERMISSION_DESC\" } ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/resource-servers/API_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"scopes\\\": [ { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" }, { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" } ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/resource-servers/API_ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"scopes\\\": [ { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" }, { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" } ] }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/resource-servers/API_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"scopes\\\": [ { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" }, { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" } ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/resource-servers/API_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    scopes: [\n      {value: 'PERMISSION_NAME', description: 'PERMISSION_DESC'},\n      {value: 'PERMISSION_NAME', description: 'PERMISSION_DESC'}\n    ]\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"scopes\": @[ @{ @\"value\": @\"PERMISSION_NAME\", @\"description\": @\"PERMISSION_DESC\" }, @{ @\"value\": @\"PERMISSION_NAME\", @\"description\": @\"PERMISSION_DESC\" } ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/resource-servers/API_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/resource-servers/API_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"scopes\\\": [ { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" }, { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" } ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"scopes\\\": [ { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" }, { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" } ] }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/resource-servers/API_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/resource-servers/API_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"scopes\\\": [ { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" }, { \\\"value\\\": \\\"PERMISSION_NAME\\\", \\\"description\\\": \\\"PERMISSION_DESC\\\" } ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"scopes\": [\n    [\n      \"value\": \"PERMISSION_NAME\",\n      \"description\": \"PERMISSION_DESC\"\n    ],\n    [\n      \"value\": \"PERMISSION_NAME\",\n      \"description\": \"PERMISSION_DESC\"\n    ]\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/resource-servers/API_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Add API Permissions",
  "description": "Learn how to add permissions to APIs using the Auth Dashboard or the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates",
  "markdown": "# Custom Database Action Script Templates\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nIf you have your own database (known as a legacy data store in Auth0) containing user identity data, you can use it as an identity provider to authenticate users. You create and configure the connection to your legacy data store as a custom database in Auth0. You can choose to migrate data to Auth0's data store from your legacy database incrementally over time, or you can continue to use it without migrating data. We provide script templates to perform functions on the custom database that you can use and customize.\n\nThere are two different types of custom database scripts:\n\n*   **Automatic Migration**: Whenever a user logs into Auth0, if the user is not yet in Auth0, the script will check the legacy database to see if the user exists there. If found and the **Import users to Auth0** flag is turned on, the user data migrates the user to Auth0 data store. This capability is sometimes called **trickle migration** or **lazy migration**.\n    \n*   **Legacy Database**: Auth0 will always query the underlying database when a user tries to log in, is created, changes their password, verifies their email, or is deleted. If found and the **Import users to Auth0** flag is **not** turned on, user data stays in the legacy database and does **not** migrate to Auth0.\n    \n\nAuth0 provides the following custom database action scripts:\n\n*   [Change Password](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n    \n*   [Create User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n    \n*   [Delete User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n    \n*   [Get User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n    \n*   [Login](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n    \n*   [Verify User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)\n    \n*   [Change Email](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)\n    \n\n#### Network firewall\n\nIf you are behind a firewall, this feature may require that you add the appropriate Auth0 IP addresses to the Allow List to work properly.\n\n## Script execution\n\nAs described in [Custom Database Connections](https://auth0.com/docs/authenticate/database-connections/custom-db), a custom database connection type allows you to configure action scripts: custom code that is used when interfacing with your legacy identity store. Each action script is essentially a named JavaScript function that is passed a number of parameters, with the name of the function and the parameters passed depending on the script.\n\n### Limits\n\nAction script execution supports the asynchronous nature of JavaScript, and constructs such as [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) objects can be used. Asynchronous processing effectively results in suspension pending completion of an operation, and an Auth0 serverless Webtask container typically has a 20-second execution limit, after which the container may be recycled. Recycling a container due to this limit will prematurely terminate operation, ultimately resulting in an error condition being returned (as well as resulting in a potential reset of the `global` object).\n\n### Completion and the callback function\n\nThe `callback` function supplied to each action script effectively acts as a signal to indicate completion of operation. An action script should complete immediately following a call to the `callback` function (either implicitly or by explicitly executing a JavaScript return statement) and should refrain from any other operation.\n\nIf an action script uses asynchronous processing, then a call to the `callback` function must be deferred to the point where asynchronous processing completes, and must be the final thing called. Asynchronous execution will result in a JavaScript `callback` being executed after the asynchronous operation is complete; this callback is typically fired at some point after the main (synchronous) body of a JavaScript function completes.\n\n## Learn more\n\n*   [Custom Database Action Script Execution Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution)\n*   [Troubleshoot Custom Databases](https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling)",
  "title": "Custom Database Action Script Templates",
  "description": "Learn about custom database action script templates.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/apis/configure-access-token-profile",
  "markdown": "# Configure Access Token Profile\n\nYou can choose which access token profile to use for your APIs: the Auth0 token profile or the RFC 9068 token profile. The access token profile you configure determines the format of the access tokens issued for the API.\n\nBy default, Auth0 issues access tokens using the Auth0 token profile. The Auth0 token profile issues access tokens that are formatted as [JSON Web Tokens (JWTs)](https://auth0.com/docs/secure/tokens/json-web-tokens), which contain information about an entity in the form of claims.\n\nAuth0 also supports the RFC 9068 token profile. The RFC 9068 token profile issues access tokens formatted as JWTs following the [IETF JWT Profile for OAuth 2.0 Access Tokens (RFC 9068)](https://datatracker.ietf.org/doc/html/rfc9068). To learn more about the differences between these token profiles, read [Access Token Profiles](https://auth0.com/docs/secure/tokens/access-tokens/access-token-profiles).\n\nWhen you [register an API](https://auth0.com/docs/get-started/auth0-overview/set-up-apis), you can select the access token profile in the Auth0 Dashboard. After you’ve registered the API, you can configure the access token profile anytime using the [Management API](https://auth0.com/docs/api/management/v2) and the [Auth0 Dashboard](https://manage.auth0.com/).\n\n## Configure access token profile for an API\n\n1\\. Go to [Dashboard > Applications > APIs](https://manage.auth0.com/#/apis) and click the name of the API to view.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/4biSz1LEV96fhFyJJPB6Ws/6386dfba492141f5797367329abb0205/image3.png)\n\n2\\. Scroll to **Access Token Settings** and select the access token profile under **JSON Web Token (JWT) Profile**. The selected profile determines the format and claims of access tokens issued for the API. The supported values are `Auth0` and `RFC 9068`. To read more about the difference between the two profiles, read [Access Token Profiles](https://auth0.com/docs/secure/tokens/access-tokens/access-token-profiles).\n\n3\\. Click **Save**.",
  "title": "Configure Access Token Profile",
  "description": "Learn how to configure an access token profile for your API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/authorization-policies",
  "markdown": "# Authorization Policies\n\nBehind the scenes, role-based authorization uses a pre-configured authorization policy, which contains conditions that allow code to evaluate whether a user should be permitted to access a protected API.\n\nThe authorization policy determines:\n\n*   how to define and organize the users or roles that are affected by the policy\n    \n*   what logic and conditions apply to the policy and whether their outcome permits or denies access\n    \n\nWhen using Auth0's core authorization and [role-based access control (RBAC)](https://auth0.com/docs/manage-users/access-control/rbac), the policy includes evaluating the roles and permissions assigned to users. To use these features, you must [enable role-based access control for APIs](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis).\n\nYou can further customize the authorization policy by using [rules](https://auth0.com/docs/customize/rules). To learn more, read [Rules for Authorization Policies](https://auth0.com/docs/manage-users/access-control/rules-for-authorization-policies).",
  "title": "Authorization Policies",
  "description": "Understand the concept of authorization policies and how they apply in Auth0.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/rules-for-authorization-policies",
  "markdown": "# Rules for Authorization Policies\n\nYou can append [Rules](https://auth0.com/docs/customize/rules) to the pre-configured authorization policy to exercise additional control over permitting or denying user access. A rule contains custom code that makes an authorization decision based on appropriate logic. When combined with other rules, it helps define what happens in different contexts.\n\nRules can restrict access based on any combination of attributes you store for users, such as user department, time of day, location, or any other user or API attribute (like username, security clearance, or API name).\n\nFor example, if you were using rules to provide finely-grained access control at a non-profit organization, you could give only W2 employees working in the Research and Development department in the New Delhi office access to an application.\n\nFor samples of rule implementations with authorization policies, read [Sample Use Cases: Rules with Authorization](https://auth0.com/docs/manage-users/access-control/sample-use-cases-rules-with-authorization).\n\nBased on the order in which they run, rules can change the outcome of the authorization decision prior to the permissions being added to the Access Token. The basic process with rules injected is as follows:\n\n1.  The user tries to authenticate with the application.\n    \n2.  Auth0 brings the request to the selected identity provider.\n    \n3.  Once the identity provider confirms that user credentials are valid, all created rules run in the order in which they are configured in the Dashboard.\n    \n4.  Assuming no rule has restricted the user's access, the user is authorized to access the application.\n    \n\n## Learn more\n\n*   [Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/rbac)\n*   [Configure Core Authorization Features for Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/configure-core-rbac)",
  "title": "Rules for Authorization Policies",
  "description": "Understand how rules apply to authorization policies and Auth0's role-based access system (RBAC).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis",
  "markdown": "# Enable Role-Based Access Control for APIs\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/resource-servers/API_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"enforce_policies\": \"true\", \"token_dialect\": \"TOKEN_DIALECT\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/resource-servers/API_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"enforce_policies\\\": \\\"true\\\", \\\"token_dialect\\\": \\\"TOKEN_DIALECT\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/resource-servers/API_ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"enforce_policies\\\": \\\"true\\\", \\\"token_dialect\\\": \\\"TOKEN_DIALECT\\\" }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/resource-servers/API_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"enforce_policies\\\": \\\"true\\\", \\\"token_dialect\\\": \\\"TOKEN_DIALECT\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/resource-servers/API_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {enforce_policies: 'true', token_dialect: 'TOKEN_DIALECT'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"enforce_policies\": @\"true\",\n                              @\"token_dialect\": @\"TOKEN_DIALECT\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/resource-servers/API_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/resource-servers/API_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"enforce_policies\\\": \\\"true\\\", \\\"token_dialect\\\": \\\"TOKEN_DIALECT\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"enforce_policies\\\": \\\"true\\\", \\\"token_dialect\\\": \\\"TOKEN_DIALECT\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/resource-servers/API_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/resource-servers/API_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"enforce_policies\\\": \\\"true\\\", \\\"token_dialect\\\": \\\"TOKEN_DIALECT\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"enforce_policies\": \"true\",\n  \"token_dialect\": \"TOKEN_DIALECT\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/resource-servers/API_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Enable Role-Based Access Control for APIs",
  "description": "Learn how to enable role-based access control (RBAC) for an API using the Auth0 Dashboard or the Management API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests",
  "markdown": "# Configure Rich Authorization Requests (RAR)\n\n## Prerequisites\n\nBefore configuring Rich Authorization Requests (RAR) for an API, first set up: \n\n*   A [custom domain](https://auth0.com/docs/customize/custom-domains).\n    \n*   A [custom Universal Login Pages](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates) template. Read the [Page templates API](https://auth0.com/docs/customize/universal-login-pages/universal-login-page-templates#page-templates-api) to learn how to customize a Universal Login Page template using the Management API.\n    \n\n## Configure the resource server\n\n### Set the consent policy\n\nThe consent policy determines when and how Auth0 shows the consent prompt to the end user.\n\nThe resource server (i.e. the API) registered in an Auth0 tenant needs to define in advance which consent policy to apply to authorize the Rich Authorization Request (RAR). \n\nThe default consent policy is `null` or undefined. Auth0 also supports the consent policy, `transactional-authorization-with-mfa,` which covers the transactional authorization use case that always requires the explicit consent of the resource owner (i.e the end user). The table below summarizes Auth0's consent policy behavior:\n\n| **Is it a Rich Authorization Request?** | **MFA Required?** | **`null` or undefined (default)** | `transactional-authorization-with-mfa` |\n| --- | --- | --- | --- |\n| No  | No  | Standard consent is shown unless there is a grant that includes the requested access. | Customized consent is shown regardless of previously granted accesses. |\n| Yes | No  | Authorization request is rejected with `invalid_request`. | Customized consent is shown regardless of previously granted accesses. |\n| Yes | Yes, with an authentication factor that is not a push notification | Authorization request is rejected with `invalid_request`. | Customized consent is shown after the user fulfills MFA challenges. |\n| Yes | Yes, with a push notification factor | Authorization request is rejected with `invalid_request`. | No consent is shown. The consent is handled in the mobile application that received the push notification challenge. |\n\nSet the consent policy in your API settings using the Auth0 Dashboard.\n\n1.  Navigate to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis).\n    \n2.  Select the **Settings** tab.\n    \n3.  Under **Access Settings**, choose **Transactional Authorization with MFA**.\n    \n4.  Save your changes.\n    \n\n![Dashboard > Applications > APIs > Settings > Access Settings](https://images.ctfassets.net/cdy7uua7fh8z/3gr8Sf98gh8CUkjnlodNk/f3de54fb02969833b950aa39e38060ae/2024-05-24_11-14-49.png)\n\nThe resource server must register the `authorization_details` types that are accepted, similar to registering which scopes are allowed.\n\nYou can add `authorization_details` in the Auth0 Dashboard.\n\n1.  Navigate to [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis).\n    \n2.  Select the **Permissions** tab.\n    \n3.  Under **Add an Authorization Details type**, add `payment_initiation`. Select the **+Add** option. Add `money_transfer` and select the **+Add** option.\n    \n\n![Dashboard > Applications > APIs > Permissions](https://images.ctfassets.net/cdy7uua7fh8z/4zNaT0T7lXnrU65eAUCddw/e3eeba14ab633c1bcd78e73fee97b872/2024-05-24_11-32-05.png)\n\n### Create a resource server for Rich Authorization Requests\n\nThe following POST request creates and configures a resource server to receive Rich Authorization Requests:\n\n```\ncurl --location --request POST 'https://$tenant/api/v2/resource-servers/' \\\n  --header 'Authorization: Bearer $management_access_token' \\\n  --header 'Content-Type: application/json' \\\n  --data-raw '{\n  \"name\": \"Payments API\",\n  \"identifier\": \"https://payments.api/\",\n  \"consent_policy\": \"transactional-authorization-with-mfa\",\n  \"authorization_details\": [{\"type\": \"payment_initiation\"}]\n  }'\n```\n\n## Set customized consent prompt to render the authorization details\n\nTo render the authorization details of a Rich Authorization Request in the consent screen, you need to configure the `customized-consent` prompt with the appropriate template partials.\n\nThe following PUT request configures the customized consent partials:\n\n```\ncurl --location --request PUT \"https://$tenant/api/v2/prompts/customized-consent/partials\" \\\n    --header \"Authorization: Bearer $management_access_token\" \\\n    --header \"Content-Type: application/json\" \\\n    --data '{\n          \"customized-consent\": {\n            \"form-content\": \"<div style=\\\"font-size: 1.3em; font-weight: bold;\\\">Operation Details</div><hr style=\\\"margin: 10px 0;\\\"><div style=\\\"margin-bottom: 20px;\\\"></div><div style=\\\"font-weight: bold;\\\">Transaction Type</div><div>{{ transaction.params.authorization_details[0].type }}</div><div style=\\\"margin-bottom: 20px;\\\"></div><div style=\\\"font-weight: bold;\\\">Amount</div><div>{{ transaction.params.authorization_details[0].instructedAmount.amount }} {{ transaction.params.authorization_details[0].instructedAmount.currency }}</div><div style=\\\"margin-bottom: 20px;\\\"></div><div style=\\\"font-weight: bold;\\\">Recipient</div><div>{{ transaction.params.authorization_details[0].beneficiary }}</div><div style=\\\"margin-bottom: 20px;\\\"></div><div style=\\\"font-weight: bold;\\\">Destination Account</div><div>{{ transaction.params.authorization_details[0].destinationAccount }}</div><div style=\\\"margin-bottom: 20px;\\\"></div>\"\n          }\n        }'\n```\n\nThe customized consent template renders the authorization details in the following consent prompt that Auth0 shows to the end user:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/uqpeFxfS09a90Fpdt33Ud/36fb00a6e3daf0e8ed2552fc30538944/image16.png)\n\nTo learn more about how to customize the consent prompt, read [Customize New Universal Login Pages](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates) and [Customize New Universal Login with the No-Code Editor](https://auth0.com/docs/customize/login-pages/universal-login/customize-themes).",
  "title": "Configure Rich Authorization Requests (RAR)",
  "description": "Learn how to configure Rich Authorization Requests (RAR) for an API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/apis/create-m2m-app-test",
  "markdown": "# Create Machine-to-Machine Applications for Testing\n\nWhen you create an account, a default Management API instance is created in the API section of the Auth0 Dashboard. A sample machine-to-machine test application is automatically created. The following instructions allow you to create another test application to use with this Management API instance and use the generated test token before building your own Production setup.\n\nYou should note, the test token located under API Explorer is for testing access to the Management API only. To learn more about Management API tokens, review [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production). If you are interested in using the test token, visit [Get Management API Access Tokens for Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)\n\n1.  Go to [Dashboard > Applications > APIs](https://manage.auth0.com/#/apis) and select **Auth0 Management API**.\n    \n2.  Select the **API Explorer** tab.\n    \n3.  Click **Create & Authorize a Test Application**. A new application has been created and is authorized to access the Management API.\n    \n\n![Dashboard Applications APIs Auth0 Management API Explorer Tab Authorize and Test](https://images.ctfassets.net/cdy7uua7fh8z/6G5M1JY9iYnkYXfDHwTvR/d09119af4f7d6d45c9b39001fd189d2f/dashboard-applications-apis-mgmt-api-authorize-and-test.png)\n\nThe application created in the steps above has been granted all the Management API scopes. This means that it can access all endpoints for testing purposes. However, applications do not generally allow access to all scopes but only authorizes scopes that are required.\n\n#### How can I find out which scopes/permissions are required for the Management API?\n\nEach machine-to-machine application that accesses an API must be granted a set of [Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes). Scopes are permissions that should be granted by the owner. Each [Auth0 Management API v2](https://auth0.com/docs/api/management/v2) endpoint requires specific scopes. To see the required scopes/permissions for each endpoint, go to the [Management API Explorer](https://auth0.com/docs/api/management/v2#!) and find the endpoint you want to call. Each endpoint has a section called **Scopes** listing all the scopes that the endpoint accepts.\n\n## Example: Get All Connections endpoint\n\nThe [Get All Connections](https://auth0.com/docs/api/management/v2#!/Clients/get_connections) endpoint accepts the `read:connections` scope while the [Create a Connection](https://auth0.com/docs/api/management/v2#!/Clients/post_connections) endpoint accepts the `write:connections` scope. Our machine-to-machine token should only need the `read:connections` scope in order to access data from that endpoint.\n\nIf you have multiple applications that should access the Management API, then you should create separate machine-to-machine applications for each application in Auth0 instead of just a single machine-to-machine application.\n\n## Learn more\n\n*   [Get Management API Access Tokens for Testing](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)\n*   [Get Management API Access Tokens for Production](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-production)\n*   [Get Management API Access Tokens for Single-Page Applications](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-tokens-for-single-page-applications)\n*   [Applications in Auth0](https://auth0.com/docs/get-started/applications)",
  "title": "Create Machine-to-Machine Applications for Testing",
  "description": "Learn how to register and authorize a test machine-to-machine application for calling Management API endpoints using Access Tokens.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/apis/configure-json-web-encryption",
  "markdown": "# Configure JSON Web Encryption (JWE)\n\nBy default, Auth0 issues access tokens that are formatted as a signed [JSON Web Token (JWT)](https://auth0.com/docs/secure/tokens/json-web-tokens), meaning that while they are integrity protected, clients and other intermediaries can still inspect them. This can lead to a loss of information privacy on data intended only to be exposed to a resource server.  \n\nTo prevent unauthorized inspection of access tokens, Auth0 supports the use of nested JWT access tokens, where access information is signed in a JWT and then encrypted and represented with JSON Web Encryption (JWE). Resource servers are expected to both decrypt these access tokens and verify the signature of the JWT payload while the information is opaque to any other parties.\n\n## Generate RSA key pair\n\nBefore configuring an API to use JWE, you must [generate an RSA key pair](https://auth0.com/docs/secure/application-credentials/generate-rsa-key-pair).\n\nThe private key must be kept secret. Upload the public key to Auth0 encoded in PEM format as described in [Generate RSA Key Pair](https://auth0.com/docs/secure/application-credentials/generate-rsa-key-pair). Only the resource server or API server can securely access the private key to decrypt the access token.\n\n## Management API\n\nUse the [Auth0 Management API](https://auth0.com/docs/api/management/v2) to configure JWE for a resource server or API server. You must configure JWE for each API, so each API has its own public encryption key.\n\nThe following POST request configures a new API to receive encrypted access tokens:\n\n```\ncurl -X POST --location \"https://{domain}/api/v2/resource-servers\" \\\n    -H \"Authorization: Bearer {managementAccessToken}\" \\\n    -H \"Content-Type: application/json\" \\\n    --data-raw '{\n  \"name\": \"{apiName}\",\n  \"identifier\": \"{apiIdentifier}\",\n  \"token_encryption\": {\n    \"format\": \"compact-nested-jwe\",\n    \"encryption_key\":\n    {\n      \"name\": \"{credentialName}\",\n      \"pem\": \"{pem}\",\n      \"alg\": \"{alg}\",\n      \"kid\": \"{kid}\"\n    }\n  }\n}'\n```\n\nThe following table explains what the different parameters mean:\n\n| **Parameter** | **Required?** | **Description** |\n| --- | --- | --- |\n| `apiName` | Required | The name of your new API. |\n| `apiIdentifier` | Required | The unique identifier for your API. This will be used as your token audience. |\n| `credentialName` | Optional | The name for your public key. |\n| `pem` | Required | Public key encoded in PEM format. |\n| `alg` | Required | The encryption algorithm must be either `RSA-OAEP-256`, `RSA-OAEP-384`, or `RSA-OAEP-512`. |\n| `kid` | Optional | The identifier used to write to the `kid` header in your JWE token. This can be used to identify the key used for encryption during key rotation. |\n\nThe response contains the `id` property which uniquely identifies the resource server. The response also contains a generated `thumbprint_sha256` field that can be used to identify the credential. Auth0 will not return key material after initial creation (in this case, your PEM).\n\nThere are many ways to generate the `thumbprint_sha256`. For more information, see the [RFC 8705 OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens](https://datatracker.ietf.org/doc/html/rfc8705#name-jwt-certificate-thumbprint-).\n\nTo ensure that you generated the correct `thumbprint_sha256`, you can use the following Node.js code sample to extract the thumbprint:\n\n```\nconst fs = require('fs');\nconst crypto = require('crypto');\n\nconst { calculateJwkThumbprint, exportJWK } = require('jose');\n\nconst publicKeyObject = crypto.createPublicKey(fs.readFileSync('./my_cert.pem'));\nexportJWK(publicKeyObject).then((jwk) => {\n  calculateJwkThumbprint(jwk, 'sha256').then((thumbprint) => {\n    console.log(thumbprint);\n  });\n});\n```\n\n## Dashboard\n\nUse the [Auth0 Dashboard](https://manage.auth0.com/) to configure JWE for your API. To begin, enable the **JSON Web Encryption (JWE)** toggle under **Token Settings** for your API.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/5xHKQ3rKN7DZogzD5qFDLp/1499dc4963ddb53fceee1ef432f894bc/Screenshot_2024-05-28_at_1.22.44_PM.png)\n\nWhen prompted, add a JSON Web Encryption (JWE) key:\n\n*   Enter a friendly name for easy identification.\n    \n*   Upload a certificate with the public key encoded in PEM format.\n    \n*   Select the encryption algorithm.\n    \n*   (Optional) Enter a key identifier.\n    \n\nClick **Add** to save the JWE key, which will generate a thumbprint of the certificate.\n\n## Learn more\n\n*   [JSON Web Encryption](https://auth0.com/docs/secure/tokens/access-tokens/json-web-encryption)",
  "title": "Configure JSON Web Encryption (JWE)",
  "description": "Learn how to configure JSON Web Encryption (JWE) for an API. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/apis/set-logical-api",
  "markdown": "# Configure Logical API for Multiple APIs\n\nIf you have multiple distinct API implementations that are all logically a part of the same API, you can simplify your authorization process by representing them with a single logical API in the Auth0 Dashboard. Doing this allows you to implement just one authorization flow, while still controlling access to the individual APIs by assigning the appropriate scopes.\n\nThe following sections describe how to use and represent multiple APIs as a single Resource Server in Auth0. We will use the following sample application in the examples. The sample application uses a microservices architecture and contains:\n\n*   2 Node.js APIs: `contacts` and `calendar` (you can think of them as microservices)\n    \n*   1 Resource Server representing the 2 APIs\n    \n*   2 Namespaced scopes: `read:contacts` and `read:calendar`\n    \n*   The Implicit Grant flow to obtain an `access_token` that works for both APIs\n    \n\nWe will represent the two APIs using just one Auth0 API called `Organizer Service`. We will then create two scopes to demonstrate how you can use the [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) to access the `calendar` and `contacts` APIs from the SPA.\n\nYou need to complete the following steps:\n\n1.  Enable a connection for your application\n    \n2.  Create a test user\n    \n3.  Register a logical API in Auth0\n    \n4.  Configure scopes for the logical API\n    \n5.  Grant access to the logical API\n    \n6.  (Optional) Implement single logout (SLO) or single sign-on (SSO)\n    \n\n## Prerequisites\n\n*   [Register your application](https://auth0.com/docs/get-started/auth0-overview/create-applications/single-page-web-apps).\n    \n    *   Select an **Application Type** of **Single-Page App**.\n        \n    *   Add **Allowed Callback URLs** of `http://localhost:3000` and `http://localhost:3000/callback.html`.\n        \n*   Download the [sample application](https://github.com/auth0-samples/auth0-api-auth-implicit-sample). To learn how to set up the sample app, read the [README](https://github.com/auth0-samples/auth0-api-auth-implicit-sample#readme).\n    \n\n## Enable a connection for your application\n\nYou will need a source of users for your newly-registered application, so you will need to configure a [connection](https://auth0.com/docs/connections). For the purpose of this sample, we'll create a simple [Database Connection](https://auth0.com/docs/connections/database) that asks only for the user's email address and a password. To learn more, read [Set Up Database Connections](https://auth0.com/docs/get-started/applications/set-up-database-connections).\n\n## Create a test user\n\nSince you're working with a newly-created connection, there won't be any users associated with it. Before we can test the sample application's login process, we'll need to create and associate a user with the connection, so make sure you choose your newly-created Connection when you create your user. To learn more, read [Create Users](https://auth0.com/docs/manage-users/user-accounts/create-users).\n\n## Register a logical API in Auth0\n\nRegister a single logical API that you will use to represent the multiple APIs contained within the sample application. For the purpose of this sample, call your API `Organizer Service` and set its unique identifier to `organize`. By default, the signing algorithm for the tokens obtained for this API is **RS256**, which you should leave as is. To learn more, read [Register APIs](https://auth0.com/docs/get-started/auth0-overview/set-up-apis).\n\n## Configure permissions for the logical API\n\nTo allow the logical API to represent the APIs included within the sample application, you will need to create the proper permissions ([](https://auth0.com/docs/get-started/apis/scopes/api-scopes)scopes).\n\nScopes allow you to define which API actions will be accessible to calling applications. One scope will represent one API/action combination. For the purpose of this sample, you want calling applications to be able to `read` from one API called `calendar` and another one called `contacts`, so you will need to create the following permissions:\n\n*   `read:calendar`\n    \n*   `read:contacts`\n    \n\nYou can think of each one as a microservice. To learn more, read [Add API Permissions](https://auth0.com/docs/get-started/apis/add-api-permissions) and [API Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes).\n\n## Grant access to the logical API\n\nYou are now ready to provide access to your APIs by allowing the logical API to obtain Access Tokens. By including the necessary scopes, you can control an application's access to the APIs represented by the logical API. The following steps use the [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post) to reflect the sample. However, you can use whichever flow best suits your needs. For example:\n\n*   If you have a **Machine-to-Machine Application**, you can authorize it to request Access Tokens for your API by executing a [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow).\n    \n*   If you are building a **Native App**, you can implement the [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).\n    \n\nTo learn about Authorization flows, read [Authentication and Authorization Flows](https://auth0.com/docs/get-started/authentication-and-authorization-flow).\n\n1.  The user clicks Login within the SPA, and the app redirects the user to the Auth0 Authorization Server (`/authorize` endpoint). To learn more about the call's parameters, see our tutorial: [Call Your API Using the Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce).\n    \n    to configure this snippet with your account\n    \n    ```\n    https://{yourDomain}/authorize?\n    scope=read:contacts%20read:calendar&\n    audience=organize&\n    response_type=id_token%20token&\n    client_id={yourClientId}&\n    redirect_uri=http://localhost:3000&\n    nonce={nonce}\n    ```\n    \n    ![Example application sign in page](https://images.ctfassets.net/cdy7uua7fh8z/1ogYIaeDdyGL3Qo511m6Sh/5ab97c1535b2b62523a367594d44d66f/home.png)\n2.  Your Auth0 Authorization Server redirects the user to the login page, where the user authenticates using one of the configured login options.\n    \n    ![Lock login page](https://images.ctfassets.net/cdy7uua7fh8z/6z6aA5nfA1uwOyx8srhvvI/2435a0909cfe44a57bef3ff27ef24e5b/lock.png)\n3.  If this is the first time the user has been through this flow, they see a consent prompt listing the permissions Auth0 will give to the SPA. In this case, the user is asked to consent to the app reading their contacts and calendar.\n    \n    ![Example application Lock Consent screen](https://images.ctfassets.net/cdy7uua7fh8z/1te4FYRbu0aFcdohdXY2Rv/116bed5515eb2114c39374fb0a258912/consent-screen.png)\n4.  If the user consents, Auth0 redirects the user back to the SPA with tokens in the hash fragment of the URI. The SPA can now extract the tokens from the hash fragment using JavaScript and use the Access Token to call your APIs on behalf of the user.\n    \n    ```\n    function getParameterByName(name) {\n      var match = RegExp('[#&]' + name + '=([^&]*)').exec(window.location.hash);\n      return match && decodeURIComponent(match[1].replace(/\\+/g, ' '));\n    }\n    \n    function getAccessToken() {\n      return getParameterByName('access_token');\n    }\n    ```\n    \n\nIn our sample, after you successfully log in, you will see buttons that allow you to call either of your APIs using the Access Token obtained from the logical API.\n\n![Example application user authorized screen](https://images.ctfassets.net/cdy7uua7fh8z/2pGWG5Wa7U1tBPhAJZ7Bat/7e194066560605cc842f20624b80d958/apis.png)\n\n### Implement single logout (SLO) or single sign-on (SSO)\n\nIn some multi-application scenarios, where Single Logout is desired (a user logging out of one application needs to be logged out of other applications), an application can be set up to periodically poll Auth0 using `checkSession()` to see if a session exists. If the session does not exist, you can then log the user out of the application. The same polling method can be used to implement silent authentication for a Single Sign-on (SSO) scenario.\n\nThe poll interval between checks to `checkSession()` should be at least 15 minutes between calls to avoid any issues in the future with rate limiting of this call.\n\n## Learn more\n\n*   [Register APIs](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)\n*   [Add API Permissions](https://auth0.com/docs/get-started/apis/add-api-permissions)\n*   [API Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)",
  "title": "Configure Logical API for Multiple APIs",
  "description": "Learn how to use a single logical API in Auth0 to represent and control access to multiple APIs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/hybrid-flow",
  "markdown": "# Hybrid Flow\n\nApplications that are able to securely store [Client Credentials](https://auth0.com/docs/secure/application-credentials) may benefit from the use of the Hybrid Flow (defined in the [OpenID Connect specification, section 3.3](https://openid.net/specs/openid-connect-core-1_0.html#HybridFlowAuth)). The Hybrid flow allows your application to have immediate access to an ID token while ensuring secure and safe retrieval of access tokens and refresh tokens. This can be useful in situations where your application needs to immediately access information about the user, but must perform some processing before gaining access to protected resources for an extended period of time.\n\n## How it works\n\nThe Hybrid Flow combines steps from the [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post) and [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow):\n\n1.  User selects **Login** within application.\n    \n2.  Application redirects user to Auth0 Authorization Server ([`/authorize` endpoint](https://auth0.com/docs/api/authentication#authorization-code-flow)), passing along `response_type` parameter indicating type of requested credential (ID token and authorization code), and `response_mode` parameter of `form_post` to ensure security.\n    \n3.  Auth0 Authorization Server redirects user to login and authorization prompt.\n    \n4.  User authenticates using one of the configured login options, and may see a consent prompt listing the permissions Auth0 will give to the application.\n    \n5.  Auth0 Authorization Server redirects user back to application with single-use authorization code, and ID token, access token, or both, depending on provided `response_type`.\n    \n6.  Application sends authorization code, application's client ID, and application's credentials, such as Client Secret or Private Key JWT, to Auth0 Authorization Server ([`**/oauth/token**` endpoint](https://auth0.com/docs/api/authentication?http#authorization-code-flow43)).\n    \n7.  Auth0 Authorization Server verifies authorization code, application's client ID, and application's credentials.\n    \n8.  Auth0 Authorization Server responds with second ID token and access token (and optionally, a refresh token).\n    \n9.  Application can use second access token to call an API to access information about user.\n    \n10.  API responds with requested data.\n    \n\n## How to implement it\n\nYou can follow our tutorial to use the Authentication API to [Call Your API Using the Hybrid Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/hybrid-flow/call-api-hybrid-flow).\n\n## Learn more\n\n*   [Auth0 Rules](https://auth0.com/docs/customize/rules)\n*   [Auth0 Hooks](https://auth0.com/docs/customize/hooks)\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Token Best Practices](https://auth0.com/docs/secure/tokens/token-best-practices)\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)\n*   [Application Credentials](https://auth0.com/docs/secure/application-credentials)",
  "title": "Hybrid Flow",
  "description": "Learn how the Hybrid Flow works to provide optimum access to the ID Token while still leveraging the Authorization Code Flow for the secure and safe retrieval of Access and Refresh Tokens.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-jar",
  "markdown": "# Authorization Code Flow with JWT-Secured Authorization Requests (JAR)\n\n[JWT-Secured Authorization Request (JAR)](https://datatracker.ietf.org/doc/html/rfc9101) is an extension of the OAuth2 protocol and adds a layer of security to protect the integrity of authorization request parameters.\n\n## Prerequisites\n\nTo use JAR, you must first [generate an RSA key pair](https://auth0.com/docs/secure/application-credentials/generate-rsa-key-pair). Then, register the public key with Auth0 as explained in [Configure JWT-Secured Authorization Requests](https://auth0.com/docs/get-started/applications/configure-jar).\n\nDuring the authorization code flow, the client application takes the parameters they would like to send to the `/authorize` or `/oauth/par` endpoints and wraps them in a [JSON Web Token (JWT)](https://auth0.com/docs/secure/tokens/json-web-tokens), which they then sign using the private key.\n\nThe authorization server verifies the signature with your application's public key. If the signature is valid, the authorization server extracts the request parameters from JAR and processes the request as usual. As a result, the parameter values are guaranteed to come from a known source, and cannot be tampered with or accessed by intermediaries.\n\n## Generate the JAR request\n\nTo generate a JAR request, you need to first create a [JSON Web Token (JWT)](https://auth0.com/docs/secure/tokens/json-web-tokens). Use the [Auth0 JWT library](https://jwt.io/libraries) to help you generate a JWT in your preferred language.\n\nFor a JAR request, the JWT header must contain the following fields:\n\n*   `alg`: The algorithm used to sign the JWT. Must be either RS256, RS384, or PS256.\n    \n*   `typ`: The type of JWT. Must be either `jwt` or `oauth-authz-req+jwt`.\n    \n\nThe header may also contain a `kid` field that identifies the key used to sign the JWT. If a `kid` is present, Auth0 will look for a public key registered during [JAR configuration](https://auth0.com/docs/get-started/applications/configure-jar) that has a matching key ID and use that key to verify the JWT’s signature.\n\n### Payload\n\nThe JWT payload must contain the following claims:\n\n*   `iss`: This must contain your app’s `client_id`\n    \n*   `aud`: This must be your tenant’s domain, with the protocol and a trailing forward slash. For example, `https://your_domain.auth0.com/`\n    \n\nThe JWT must also contain any mandatory parameters for the call to `/authorize`. For example:\n\n*   `client_id`: This must also contain your app’s `client_id`\n    \n*   `response_type`: Indicates to Auth0 which OAuth 2.0 flow you want to perform. Use `code` for Authorization Code Grant Flow.\n    \n\nThe JWT may contain any of the optional parameters for the authorization flow that is being requested, such as `audience`, `scope`, `state`, `redirect_uri`, among others.\n\nIn addition, the JWT may contain the following optional claims:\n\n*   `iat`: Must be a numeric date.\n    \n*   `nbf`: Must be a numeric date, representing a time in the past.\n    \n*   `exp`: Must be a numeric date, representing a time in the future.\n    \n*   `jti`: Must be a string no longer than 64 bytes.\n    \n\n### Generate JWT example\n\nThe following JavaScript code sample demonstrates how to build and sign a JWT using JavaScript and the [jsonwebtoken library](https://www.npmjs.com/package/jsonwebtoken?activeTab=readme). It outputs the generated JWT to the console:\n\n```\nconst jwt = require('jsonwebtoken');\nconst crypto = require(\"crypto\");\nconst fs = require('fs');\n\nconst privateKey = fs.readFileSync('[PATH TO YOUR PEM FILE]');\nconst client_id = '[YOUR CLIENT ID]';\nconst nonce = crypto.randomBytes(16).toString('hex');\n\nconst requestObject = jwt.sign(\n{\n  iss: client_id,    \n  aud: 'https://your_tenant.auth0.com/', // your tenant's domain\n  client_id,\n  response_type: \"code\",\n  scope: \"openid profile\",\n  redirect_uri : \"https://myapp.com/callback\" // your app's callback URL\n  nonce\n},\nprivateKey,\n{\n  keyid: '[YOUR KID]', // optional key id (kid) value from your public key\n  algorithm: 'RS256',\n  header: {\n    typ: 'oauth-authz-req+jwt',\n  },\n});\n\nconsole.log(requestObject);\n```\n\nTo call the `/authorize` endpoint using your signed JWT, open a new browser window. Pass your Client ID as the `client_id` parameter and the signed and URL-encoded JWT as the `request` parameter.\n\n```\n# MacOS\nopen \"https://your_tenant.auth0.com/authorize?client_id=[YOUR CLIENT ID]&request=[URL ENCODED JWT]\"\n\n# Windows\nexplorer \"https://your_tenant.auth0.com/authorize?client_id=[YOUR CLIENT ID]&request=[URL ENCODED JWT]\"\n```\n\n## Learn more\n\n*   [Configure JWT-secured Authorization Requests (JAR)](https://auth0.com/docs/get-started/applications/configure-jar)",
  "title": "Authorization Code Flow with JWT-Secured Authorization Requests (JAR)",
  "description": "Learn how to use JWT-Secured Authorization Requests (JAR) with the Authorization Code Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow",
  "markdown": "# Add Login Using the Authorization Code Flow\n\nYou can add login to your regular web application using the Authorization Code Flow. To learn how the flow works and why you should use it, read [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow). To call your API from a regular web app, read [Call Your API Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/call-your-api-using-the-authorization-code-flow).\n\nTo implement the Authorization Code Flow, Auth0 provides the following resources:\n\n*   [Regular Web App Quickstarts](https://auth0.com/docs/quickstart/webapp): The easiest way to implement the flow.\n    \n*   [Authentication API](https://auth0.com/docs/api/authentication): If you prefer to build your own solution, keep reading to learn how to call our API directly.\n    \n\nFollowing a successful login, your application will have access to the user's ID token and access token. The ID token contains basic user profile information, and the access token can be used to call the Auth0 `/userinfo` endpoint or your own protected APIs. To learn more about ID tokens, read [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens). To learn more about access tokens, read [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens).\n\nYou will request the user's authorization and redirect back to your app with an `authorization_code`. Then you will exchange the code for tokens.\n\n## Prerequisites\n\nRegister your app with Auth0. To learn more, read [Register Regular Web Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps).\n\n*   Select **Regular Web App** as the **Application Type**.\n    \n*   Add an **Allowed Callback URL** of `**{https://yourApp/callback}**`.\n    \n*   Make sure your application's **Grant Types** include **Authorization Code**. To learn more, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types).\n    \n\nTo begin the flow, you'll need to get the user's authorization. This step may include one or more of the following processes:\n\n*   Authenticating the user;\n    \n*   Redirecting the user to an Identity Provider to handle authentication;\n    \n*   Obtaining user consent for the requested permission level, unless consent has been previously given.\n    \n\nTo authorize the user, your app must send the user to the [authorization URL](https://auth0.com/docs/api/authentication#authorization-code-flow).\n\n### Authorization URL example\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=code&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    scope={scope}&\n    state={state}\n```\n\n### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `response_type` | Denotes the kind of credential that Auth0 will return (`code` or `token`). For this flow, the value must be `code`. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `redirect_uri` | The URL to which Auth0 will redirect the browser after authorization has been granted by the user. The Authorization Code will be available in the `code` URL parameter. You must specify this URL as a valid callback URL in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings).<br><br>**Warning:** Per the [OAuth 2.0 Specification](https://tools.ietf.org/html/rfc6749#section-3.1.2), Auth0 removes everything after the hash and does _not_ honor any fragments. |\n| `scope` | Specifies the [scopes](https://auth0.com/docs/scopes) for which you want to request authorization, which dictate which claims (or user attributes) you want returned. These must be separated by a space. To get an ID Token in the response, you need to specify a scope of at least `openid`. If you want to return the user's full profile, you can request `openid profile`. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `email`, or [custom claims](https://auth0.com/docs/tokens/concepts/jwt-claims#custom-claims) conforming to a [namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims). Include `offline_access` to get a Refresh Token (make sure that the **Allow Offline Access** field is enabled in the [Application Settings](https://manage.auth0.com/#/applications)). |\n| `state` | (recommended) An opaque arbitrary alphanumeric string your app adds to the initial request that Auth0 includes when redirecting back to your application. To see how to use this value to prevent cross-site request forgery (CSRF) attacks, see [Mitigate CSRF Attacks With State Parameters](https://auth0.com/docs/protocols/oauth2/mitigate-csrf-attacks). |\n| `connection` | (optional) Forces the user to sign in with a specific connection. For example, you can pass a value of `github` to send the user directly to GitHub to log in with their GitHub account. When not specified, the user sees the Auth0 Lock screen with all configured connections. You can see a list of your configured connections on the **Connections** tab of your application. |\n| `organization` | (optional) ID of the organization to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating. |\n| `invitation` | (optional) Ticket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the `invitation` and `organization` key-value pairs when the user accepts the invitation. |\n| `login_hint` | (optional) Populates the username/email field for the login or signup page when redirecting to Auth0. Supported by the Universal Login experience. |\n\nAs an example, your HTML snippet for your authorization URL when adding login to your app might look like:\n\n```\n<a href=\"https://{yourDomain}/authorize?\n  response_type=code&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  scope=openid%20profile&\n  state=xyzABC123\">\n  Sign In\n</a>\n```\n\n### Response\n\nIf all goes well, you'll receive an `HTTP 302` response. The authorization code is included at the end of the URL:\n\n```\nHTTP/1.1 302 Found\nLocation: {https://yourApp/callback}?code={authorizationCode}&state=xyzABC123\n```\n\n## Request tokens\n\nNow that you have an Authorization Code, you must exchange it for tokens. Using the extracted Authorization Code (`code`) from the previous step, you will need to `POST` to the [token URL](https://auth0.com/docs/api/authentication#authorization-code).\n\n### POST to token URL example\n\n*   [cURL](#f46589a28f9e46e0be6d2ba675dea193_shell)\n*   [C#](#f46589a28f9e46e0be6d2ba675dea193_csharp)\n*   [Go](#f46589a28f9e46e0be6d2ba675dea193_go)\n*   [Java](#f46589a28f9e46e0be6d2ba675dea193_java)\n*   [Node.JS](#f46589a28f9e46e0be6d2ba675dea193_node)\n*   [Obj-C](#f46589a28f9e46e0be6d2ba675dea193_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'code=yourAuthorizationCode}' \\\n  --data 'redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    code: 'yourAuthorizationCode}',\n    redirect_uri: '{https://yourApp/callback}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=authorization_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code=yourAuthorizationCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&redirect_uri={https://yourApp/callback}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=authorization_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code=yourAuthorizationCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&redirect_uri={https://yourApp/callback}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to `authorization_code`. |\n| `code` | The `authorization_code` retrieved in the previous step of this tutorial. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `client_secret` | Your application's Client Secret. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). To learn more about available application authentication methods, read [Application Credentials](https://auth0.com/docs/secure/application-credentials). |\n| `redirect_uri` | The valid callback URL set in your Application settings. This must exactly match the `redirect_uri` passed to the authorization URL in the previous step of this tutorial. Note that this must be URL encoded. |\n\n### Response\n\nIf all goes well, you'll receive an HTTP 200 response with a payload containing `access_token`, `refresh_token`, `id_token`, and `token_type` values:\n\n```\n{\n  \"access_token\": \"eyJz93a...k4laUWw\",\n  \"refresh_token\": \"GEbRxBN...edjnXbL\",\n  \"id_token\": \"eyJ0XAi...4faeEoQ\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n[ID tokens](https://auth0.com/docs/secure/tokens/id-tokens) contain user information that must be decoded and extracted.\n\n[Access tokens](https://auth0.com/docs/secure/tokens/access-tokens) are used to call the [Auth0 Authentication API's /userinfo endpoint](https://auth0.com/docs/api/authentication#get-user-info) or another API. If you are calling your own API, the first thing your API will need to do is [verify the Access token](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens).\n\n[Refresh tokens](https://auth0.com/docs/secure/tokens/refresh-tokens) are used to obtain a new access token or ID token after the previous one has expired. The `refresh_token` will only be present in the response if you included the `offline_access` scope and enabled **Allow Offline Access** for your API in the Dashboard.\n\n## Use cases\n\n### Basic authentication request\n\nThis example shows the most basic request you can make when authorizing the user in step 1. It displays the Auth0 login screen and allows the user to sign in with any of your configured connections:\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=code&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    scope=openid\n```\n\nNow, when you request tokens, your ID Token will contain the most basic claims. When you decode the ID Token, it will look similar to:\n\n```\n{\n  \"iss\": \"https://auth0pnp.auth0.com/\",\n  \"sub\": \"auth0|581...\",\n  \"aud\": \"xvt9...\",\n  \"exp\": 1478112929,\n  \"iat\": 1478076929\n}\n```\n\n### Request user's name and profile picture\n\nIn addition to the usual user authentication, this example shows how to request additional user details, such as name and picture.\n\nTo request the user's name and picture, you need to add the appropriate scopes when authorizing the user:\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=code&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    scope=openid%20name%20picture&\n    state={state}\n```\n\nNow, when you request tokens, your ID token will contain the requested name and picture claims. When you decode the ID token, it will look similar to:\n\n```\n{\n  \"name\": \"jerrie@...\",\n  \"picture\": \"https://s.gravatar.com/avatar/6222081fd7dcea7dfb193788d138c457?s=480&r=pg&d=https%3A%2F%2Fcdn.auth0.com%2Favatars%2Fje.png\",\n  \"iss\": \"https://auth0pnp.auth0.com/\",\n  \"sub\": \"auth0|581...\",\n  \"aud\": \"xvt...\",\n  \"exp\": 1478113129,\n  \"iat\": 1478077129\n}\n```\n\n### Request user log in with GitHub\n\nIn addition to the usual user authentication, this example shows how to send users directly to a social identity provider, such as GitHub. You will first need to configure the appropriate connection in [Auth0 Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social) and get the connection name from the **Settings** tab.\n\nTo send users directly to the GitHub login screen, you need to pass the `connection` parameter and set its value to the connection name (in this case, `github`) when authorizing the user in step 1:\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=code&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    scope=openid%20name%20picture&\n    state={state}&\n    connection=github\n```\n\nNow, when you request tokens, your ID Token will contain a `sub` claim with the user's unique ID returned from GitHub. When you decode the ID token, it will look similar to:\n\n```\n{\n  \"name\": \"Jerrie Pelser\",\n  \"nickname\": \"jerriep\",\n  \"picture\": \"https://avatars.githubusercontent.com/u/1006420?v=3\",\n  \"iss\": \"https://auth0pnp.auth0.com/\",\n  \"sub\": \"github|100...\",\n  \"aud\": \"xvt...\",\n  \"exp\": 1478114742,\n  \"iat\": 1478078742\n}\n```\n\n## Learn more\n\n*   [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth)\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Register Regular Web Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps)\n*   [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types)",
  "title": "Add Login Using the Authorization Code Flow",
  "description": "Learn how to add login to your regular web application using the Authorization Code Flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par-and-jar",
  "markdown": "# Authorization Code Flow with PAR and JAR\n\nUse Push Authorization Requests (PAR) and JWT\\-Secured Authorization Requests (JAR) together to provide a higher security level in the authorization flow. Whereas PAR provides clients with confidentiality and integrity protection for authorization requests, JAR provides non-repudiation protection.\n\n### How to use PAR and JAR together\n\nTo use PAR and JAR together, [generate the JAR request](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-jar) and, instead of calling the `/authorize` endpoint, post the request to the PAR endpoint. Then, the PAR endpoint returns a `request_uri` that you can use to call the `/authorize` endpoint as in a [regular PAR flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-par).\n\nThe following cURL request uses PAR and JAR together:\n\n```\ncurl --location 'https://your_tenant.auth0.com/oauth/par' \\\n--header 'Content-Type: application/x-www-form-urlencoded' \\\n--data-urlencode 'client_id=[YOUR CLIENT ID]' \\\n--data-urlencode 'client_secret=[YOUR CLIENT SECRET]' \\\n--data-urlencode 'request=[JWT]'\n```\n\n## Learn more\n\n*   [Configure Pushed Authorization Requests (PAR)](https://auth0.com/docs/get-started/applications/configure-par)\n*   [Authorization Code Flow with JWT-Secured Authorization Requests (JAR)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-jar)",
  "title": "Authorization Code Flow with PAR and JAR",
  "description": "Learn how to use PAR and JAR with the Authorization Code Flow. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/secure/highly-regulated-identity/transactional-authorization-with-contextual-sca",
  "markdown": "# Transactional Authorization with Contextual Strong Customer Authentication\n\nHighly Regulated Identity enables Transactional Authorization with Contextual Strong Customer Authentication (SCA) by applying SCA step-up authentication and [Dynamic Linking](https://auth0.com/docs/secure/highly-regulated-identity#dynamic-linking) to authorize a specific transaction. It challenges the user with a second authentication factor to explicitly authorize the transaction details of a one-time operation. This is useful for the following use cases that require financial-grade security:\n\n*   Securing sensitive operations executed from your own services, such as approving bank transfers, access to operations history, and changes in access credentials. \n    \n*   Securing sensitive operations requested from third-party services, such as approving digital payments and allowing one-time access for account verification.\n    \n\nThis article walks you through the end-to-end journey of approving a bank transfer. The same transactional authorization flow can be applied to other use cases.\n\n## Prerequisites\n\nFollow the instructions in [Configure Rich Authorization Requests](https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests) for the API or resource server you want to configure:\n\n*   Set `transactional-authorization-with-mfa` as the `consent_policy`.\n    \n*   Register the `authorization_details.types` that you want to use.\n    \n\n## End-to-end flow\n\nThe following diagram shows the end-to-end flow for Transactional Authorization with Contextual SCA. There are four main phases:\n\n1.  Securely redirect the user to Auth0 with the transaction details. In this step, avoid revealing sensitive information on the front channel (e.g. the browser).\n    \n2.  Apply dynamic policy after the user authenticates. Using [Actions](https://auth0.com/docs/customize/actions), you can dynamically decide on the next steps based on the transaction details and other information you may get from sources such as external APIs. To learn more, read [Apply dynamic policy](#apply-dynamic-policy).\n    \n3.  Challenge the user with a second authentication factor and show transaction details for the user to explicitly approve. This step depends on the authentication factor you chose to apply using Actions.\n    \n4.  Get the access token and proceed with the sensitive operation. Your API validates the approved transaction details associated with the access token.\n    \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/6VYcY5YJRT9Ngaomj5f9yi/d150a6cb293539974047b07c960b15c8/HRI_diagrams_-_transactional_authorization_sca_end_to_end_flow_digram.png)\n\nWe will go through each phase in detail in the following sections.\n\n### Communicate transaction details and redirect to Auth0\n\nThe user first accesses your web application after authenticating with Auth0. Following our example use case, the user then requests a money transfer to one of their contacts.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/6loGZG5Llvz4QhyuWBJ2uI/70261b41e6e1afc06e4987d5644899dc/image8.png)\n\nTo meet financial-grade security standards, Highly Regulated Identity uses Pushed Authorization Requests (PAR) to hide transaction details from the browser. Instead of sending query parameters through the browser to the `/authorize` endpoint, PAR directly sends parameters from your backend to a special `/par` endpoint using a POST request. To learn how to set it up, read [Configure Pushed Authorization Requests](https://auth0.com/docs/get-started/applications/configure-par).\n\nIn the PAR request body, transaction details are sent as part of the `authorization_details` JSON object:\n\n```\n\"authorization_details\": [\n {\n   \"type\": \"money_transfer\",\n   \"instructedAmount\": {\n     \"amount\": 150,\n     \"currency\": \"USD\"\n   },\n   \"sourceAccount\": \"xxxxxxxxxxx1234\",\n   \"destinationAccount\": \"xxxxxxxxxxx9876\",\n   \"beneficiary\": \"Hanna Herwitz\",\n   \"subject\": \"A Lannister Always Pays His Debts\"\n }\n]\n```\n\nUse Actions to inspect the `authorization_details` to determine which authentication factors to use based on the transaction. To learn more about `authorization_details` and how to use it along PAR, read [Authorization Code Flow with Rich Authorization Requests](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/authorization-code-flow-with-rar).\n\nIf you want to meet FAPI 1 Advanced Security compliance requirements, you must also use public key cryptography to authenticate the backend against the `/par` or the `/token` endpoint. This is more secure than sending a Client Secret. Auth0 offers the following public key cryptography authentication methods:\n\n*   [Private Key JWT](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-private-key-jwt)\n    \n*   [mutual-TLS (mTLS) for OAuth](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authenticate-with-mtls)\n    \n\nAfter receiving a successful response to your PAR request, redirect the user to your Auth0 tenant’s `/authorize` endpoint. Add the `request_uri` parameter received in the PAR response and the `client_id` as the only query parameters, thus effectively hiding any sensitive information from the browser.\n\n### Apply dynamic policy\n\nWhen the user logs in without using SSO and the browser hits your Auth0 tenant’s `/authorize` endpoint, Auth0 will attempt to authenticate the user. In our example of approving a bank transfer, Auth0 has already authenticated the user to access your web application. However, when a third party redirects the user, such as for a digital payment, Auth0 presents a login screen to the user. To learn more about the authentication flow, read the [Authenticate](https://auth0.com/docs/authenticate) documentation.\n\nOnce Auth0 has successfully authenticated the user, Auth0 triggers post-login [Actions](https://auth0.com/docs/customize/actions), which expose transaction details about the user, app, authentication factor(s) used, and more in the [post-login event object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object). Within the post-login event object, the `event.transaction.requested_authorization_details` property contains details about the authorization request that were received in the previous step.\n\nUse the [post-login event object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object) to decide how you want to proceed with the transaction. For example, you can send transaction details to an external risk engine, and after evaluating the risk level, determine whether to request step-up authentication using sms, as illustrated in the following code sample.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.transaction?.requested_authorization_details.some(e => e.type === 'money_transfer')) {\n      const axios = require('axios');\n\n      //details to contact risk evaluation engine\n      const risk_url = 'https://risk.example.org/score';\n      const risk_options = {\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      };\n\n      const tx_data = {\n        email: event.user.email,\n        authorization_details: event.transaction?.requested_authorization_details,\n        linking_id: event.transaction.linking_id\n      };\n\n      //send operation details to risk evaluation engine\n      var risk = await axios.post(risk_url, tx_data, risk_options);\n\n      //if it is a risky operation use sms to authorize\n      if (risk.data.score >= 2) {\n        api.authentication.challengeWith({ type: 'phone' });\n      }\n\n     //add unique transaction_id to access token for traceablity\n      api.accessToken.setCustomClaim('transaction_id', event.transaction.linking_id);\n    }\n};\n```\n\nThe post-login Action also exposes `event.transaction.linking_id`, which holds a universally unique identifier (UUID) of the transaction. Later, when Auth0 prompts the user to approve the transaction, the `linking_id` provides a reference for [Dynamic Linking](https://auth0.com/docs/secure/highly-regulated-identity#dynamic-linking). You can also add the `linking_id` to the access token as a [custom claim](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims) to associate the authorization details of a specific transaction with the API calls on your end. This helps with traceability, as Auth0 includes the `linking_id` in tenant logs.\n\n### Challenge the user to get transaction details approval\n\nYou can customize what authentication factor to use depending on factors enrolled by the user, factors already satisfied by the session, and/or your own preferences. You can also provide alternatives for the user to choose from. To learn more, read [Customize MFA Selection in New Universal Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-selection-universal-login).\n\nAdditionally, for SMS, email, and WebAuthn, you can customize the consent screen that Auth0 presents to the user with the information you want to show from authorization\\_details and other transaction details. To learn more, read [Configure Rich Authorization Requests](https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests). For push notifications, this does not apply as the mobile application is the one showing the transaction details to the end user.\n\nThe following sections explain the different authentication factors that you can configure for transactional authorization.\n\n#### Push notifications\n\nSend a push notification to a user’s enrolled mobile device while Auth0 prompts the user with the Multi-Factor Authentication (MFA) waiting screen on the consumption device (e.g. the laptop where the transaction originated).\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/4mEJTT4VsAAAb6I0HhJI6r/b1e3852e0e63630a51f36160e90b2bc3/image11.png)\n\nFor push notifications, the mobile application is responsible for showing the transaction details to the user for explicit approval. To do that, using Actions, store the transaction details you want to show to the user along with the `linking_id` on an external server or endpoint and make them available only for a few minutes. After that, challenge the user with a push notification as illustrated in the following code sample. Remember to forbid the option to fallback to manually entering an OTP by adding the option `otpFallback: false`.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.transaction?.requested_authorization_details.some(e => e.type === 'money_transfer')) {\n      const axios = require('axios');\n\n      //details to store tx_details in external server\n      const tx_server_url = 'https://consent.example.org/transactions';\n      const tx_server_options = {\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      };\n      const tx_data = {\n        email: event.user.email,\n        authorization_details: event.transaction?.requested_authorization_details,\n        linking_id: event.transaction.linking_id\n      };\n\n      //store the transaction details in an external endpoint\n      var response = await axios.post(tx_server_url, tx_data, tx_server_options);\n\n      //event.transaction.linking_id is automatically added to the push challenge\n      api.authentication.challengeWith({ type: 'push-notification', options: {otpFallback: false}});\n\n     //add unique transaction_id to access token for traceablity\n      api.accessToken.setCustomClaim('transaction_id', event.transaction.linking_id);\n    }\n};\n```\n\nThe push notification includes the `event.transaction.linking_id`, which [Auth0 Guardian SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian) passes to the mobile application. Over the wire, the property name is shortened to `txlnkid`. With the `linking_id`, the mobile application can now fetch transaction details and show them to the user. Once the user approves or declines the operation, the mobile application can allow or reject the MFA challenge respectively! The transaction progresses to the [Complete the operation](#complete-the-operation) phase.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/2sy04NuQrzQ3OTiMbXNI9v/8d09efc3531723f456abafcf48f07f23/image5.png)![](https://images.ctfassets.net/cdy7uua7fh8z/29ugIpjRjoMWQkCcSDGRrk/777a32dd86f8877407cb758853af5a19/image7.png)\n\n**Note:** To verify the identity of the user opening the push notification, you can add biometric authentication to the mobile application. To learn more, read [Configure WebAuthn with Device Biometrics for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa).\n\n#### SMS, Email, or WebAuthn\n\nYou can also set up phone, email, or Webauthn as authentication factors to challenge the user. For these authentication factors, Auth0 prompts the user with the corresponding MFA waiting screen. After the user validates the challenge on the MFA waiting screen, Auth0 shows the transaction details to the user for explicit approval. Remember you have to [Configure Rich Authorization Requests](https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests) for the approval step to work properly.\n\nFor the phone authentication factor, Auth0 sends a verification code to the user through SMS or voice. The following screenshot shows the MFA waiting screen after Auth0 sent the code through SMS:\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/kYn2A0p2jTY5CUn1FsjVf/f23649485b9ae835672edd7c01c2327f/image10.png)\n\nThe user then receives the SMS with the verification code.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7dkldrgsng6FfnGerJk57N/8b37709be8725b526e51000a5a0f49d8/image13.png)\n\nAfter the user inputs the verification code in the MFA waiting screen, Auth0 prompts the user with the transaction details on a consent screen. Once the user approves or declines the transaction details, the transaction progresses to the [Complete the operation](#complete-the-operation) phase.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/1KXXiizJYA2Ooo6no7D2aE/3a2face26a1484c7927ef38f49ed078c/image2.png)\n\nEmail and Webauthn use the same transactional approval flow and similar MFA waiting and explicit approval screens.\n\n#### No Challenge\n\nIf you don’t challenge the user with a second authentication factor, Auth0 prompts the user with the consent screen to get explicit approval for the transaction details.\n\n### Complete the operation\n\nTo complete the operation, Auth0 follows the standard [Authorization Code Flow](https://auth0.com/docs/login/flows/authorization-code-flow). If the transaction is approved, the user browser is redirected to your application with an authorization code, which is then exchanged for an access token encrypted using [JSON Web Encryption](https://auth0.com/docs/secure/tokens/access-tokens/json-web-encryption). The access token contains the `authorization_details` that you originally passed. The following code sample shows the contents of a decrypted access token:\n\n```\n{\n \"iss\": \"https://my_tenant.auth0.com/\",\n \"sub\": \"auth0|me\",\n \"aud\": \"https://myapi.zewobnak.com\",\n \"iat\": 1683661385,\n \"exp\": 1683747785,\n \"azp\": \"my_client\",\n \"transaction_linking_id\": \"ce4842e8-2894-418a-b1f9-39a330cd4911\",\n \"authorization_details\": [\n   {\n     \"type\": \"money_transfer\",\n     \"instructedAmount\": {\n       \"amount\": 150,\n       \"currency\": \"USD\"\n     },\n     \"sourceAccount\": \"xxxxxxxxxxx1234\",\n     \"destinationAccount\": \"xxxxxxxxxxx9876\",\n     \"beneficiary\": \"Hanna Herwitz\",\n     \"subject\": \"A Lannister Always Pays His Debts\",\n   }\n ]\n}\n```\n\nPass the access token to the API that facilitates the money transfer. The API then checks the access token’s `authorization_details` to verify the transaction details, such as the amount, sender, destination, and more. Once verified, the money transfer successfully executes, and you should see the approval screen.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/dXeBbLxt1w1fqGt67ALCG/a4e9ce5feb4375f0a2c123a6bb85227b/image9.png)\n\nIf the transaction is rejected at any step, the user browser displays an `access_denied` error code.",
  "title": "Transactional Authorization with Contextual Strong Customer Authentication",
  "description": "Learn about how Highly Regulated Identity enables transactional authorization with Contextual Strong Customer Authentication. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/add-login-using-the-implicit-flow-with-form-post",
  "markdown": "# Add Login Using the Implicit Flow with Form Post\n\nYou can add login to your single-page application (SPA) using the Implicit Flow with Form Post. To learn how the flow works and why you should use it, read [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post).\n\nUse the Implicit Flow with Form Post for login-only use cases; if you need to request access tokens while logging the user in so you can call your API, use the Authorization Code Flow with PKCE. To learn more, read [Authorization Code Flow with Proof Key for Code Exchange (PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce)).\n\nTo implement the Implicit Flow with Form Post, you can use the following resources:\n\n*   [Express OpenID Connect SDK](https://www.npmjs.com/package/express-openid-connect): The easiest way to implement the flow, which will do most of the heavy-lifting for you. If you use our Javascript SDK, please ensure you are implementing mitigations that are appropriate for your architecture. To learn more, read [Auth0.js v9 Reference](https://auth0.com/docs/libraries/auth0js).\n    \n*   [Authentication API](https://auth0.com/docs/api/authentication): If you prefer to build your own solution, keep reading to learn how to call our API directly.\n    \n\nFollowing a successful login, your application will have access to the user's [ID token](https://auth0.com/docs/secure/tokens/id-tokens). The ID token will contain basic user profile information.\n\n## Prerequisites\n\nRegister your app with Auth0. To learn more, read [Register Single Page Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/single-page-web-apps).\n\n*   Select **Single-Page App** as the **Application Type**.\n    \n*   Add an **Allowed Callback URL** of `**{https://yourApp/callback}**`.\n    \n*   Make sure your application's **Grant Types** include **Implicit**. To learn more, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types).\n    \n\nRequest the user's authorization and redirect back to your app. To begin the flow, you'll need to get the user's authorization. This step may include one or more of the following processes:\n\n*   Authenticating the user;\n    \n*   Redirecting the user to an Identity Provider to handle authentication;\n    \n*   Checking for active Single Sign-on (SSO) sessions;\n    \n*   Obtaining user consent for the requested permission level, unless consent has been previously given.\n    \n\nTo authorize the user, your app must send the user to the authorization URL.\n\n### Authorization URL example\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=YOUR_RESPONSE_TYPE&\n    response_mode=form_post&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    scope=SCOPE&\n    state=STATE&\n    nonce=NONCE\n```\n\n### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `response_type` | Denotes the kind of credential that Auth0 will return (code or token). For the Implicit Flow, the value can be `id_token`, `token`, or `id_token token`. Specifically, `id_token` returns an ID Token, and `token` returns an Access Token. |\n| `response_mode` | Specifies the method with which response parameters should be returned. For security purposes, the value should be `form_post`. In this mode, response parameters will be encoded as HTML form values that are transmitted via the HTTP POST method and encoded in the body using the `application/x-www-form-urlencoded` format. |\n| `client_id` | Your application's Client ID. You can find this value at your [Application's Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings). |\n| `redirect_uri` | The URL to which Auth0 will redirect the browser after authorization has been granted by the user. You must specify this URL as a valid callback URL in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings).<br><br>**Warning:** Per the [OAuth 2.0 Specification](https://tools.ietf.org/html/rfc6749#section-3.1.2), Auth0 removes everything after the hash and does _not_ honor any fragments. |\n| `scope` | Specifies the [scopes](https://auth0.com/docs/scopes) for which you want to request authorization, which dictate which claims (or user attributes) you want returned. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, [custom claims](https://auth0.com/docs/tokens/concepts/jwt-claims#custom-claims) conforming to a [namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (for example, `read:contacts`). |\n| `state` | (recommended) An opaque arbitrary alphanumeric string that your app adds to the initial request and Auth0 includes when redirecting back to your application. To see how to use this value to prevent cross-site request forgery (CSRF) attacks, see [Mitigate CSRF Attacks With State Parameters](https://auth0.com/docs/protocols/oauth2/mitigate-csrf-attacks). |\n| `nonce` | (required for `response_type` containing `id_token token`, otherwise recommended) A cryptographically random string that your app adds to the initial request and Auth0 includes inside the ID Token, [used to prevent token replay attacks](https://auth0.com/docs/api-auth/tutorials/nonce). |\n| `connection` | (optional) Forces the user to sign in with a specific connection. For example, you can pass a value of `github` to send the user directly to GitHub to log in with their GitHub account. When not specified, the user sees the Auth0 Lock screen with all configured connections. You can see a list of your configured connections on the **Connections** tab of your application. |\n| `organization` | (optional) ID of the organization to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating. |\n| `invitation` | (optional) Ticket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the `invitation` and `organization` key-value pairs when the user accepts the invitation. |\n\nAs an example, your HTML snippet for your authorization URL when adding login to your app might look like:\n\n```\n<a href=\"https://{yourDomain}/authorize?\n  response_type=id_token token&\n  response_mode=form_post&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&\n  scope=read:tests&\n  state=xyzABC123&\n  nonce=eq...hPmz\">\n  Sign In\n</a>\n```\n\n### Response\n\nIf all goes well, you'll receive an `HTTP 302` response. The requested credentials are encoded in the body:\n\n```\nHTTP/1.1 302 Found\nContent-Type: application/x-www-form-urlencoded\nid_token=eyJ...acA&\nstate=xyzABC123\n```\n\nNote that the returned values depend on what you requested as a `response_type`.\n\n| Response Type | Components |\n| --- | --- |\n| id\\_token | ID Token |\n| token | Access Token (plus `expires_in` and `token_type` values) |\n| id\\_token token | ID Token, Access Token (plus `expires_in` and `token_type` values) |\n\nAuth0 will also return any state value you included in your call to the authorization URL.\n\n[](https://auth0.com/docs/secure/tokens/id-tokens)ID tokens contain user information that must be decoded and extracted.\n\n## Use cases\n\n### Basic authentication request\n\nThis example shows the most basic request you can make when authorizing the user in step 1. It displays the Auth0 login screen and allows the user to sign in with any of your configured connections:\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=id_token&\n    response_mode=form_post&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    nonce=NONCE\n```\n\nThis will return an ID token, which you can parse from your redirect URL.\n\n### Request user's name and profile picture\n\nIn addition to the usual user authentication, this example shows how to request additional user details, such as name and picture.\n\nTo request the user's name and picture, you need to add the appropriate scopes when authorizing the user:\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=id_token token&\n    response_mode=form_post&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    scope=openid%20name%20picture&\n    state=STATE&\n    nonce=NONCE\n```\n\nNow, your ID token will contain the requested name and picture claims. When you decode the ID token, it will look similar to:\n\n```\n{\n  \"name\": \"jerrie@...\",\n  \"picture\": \"https://s.gravatar.com/avatar/6222081fd7dcea7dfb193788d138c457?s=480&r=pg&d=https%3A%2F%2Fcdn.auth0.com%2Favatars%2Fje.png\",\n  \"iss\": \"https://auth0pnp.auth0.com/\",\n  \"sub\": \"auth0|581...\",\n  \"aud\": \"xvt...\",\n  \"exp\": 1478113129,\n  \"iat\": 1478077129\n}\n```\n\n### Request user log in with GitHub\n\nIn addition to the usual user authentication, this example shows how to send users directly to a social identity provider, such as GitHub. For this example to work, you need to go to [Auth0 Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social) and configure the appropriate connection. Get the connection name from the **Settings** tab.\n\nTo send users directly to the GitHub login screen, you need to pass the `connection` parameter and set its value to the connection name (in this case, `github`) when authorizing the user:\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=id_token token&\n    response_mode=form_post&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    scope=openid%20name%20picture&\n    state=STATE&\n    nonce=NONCE&\n    connection=github\n```\n\nNow, your ID Token will contain a `sub` claim with the user's unique ID returned from GitHub. When you decode the ID Token, it will look similar to:\n\n```\n{\n  \"name\": \"Jerrie Pelser\",\n  \"nickname\": \"jerriep\",\n  \"picture\": \"https://avatars.githubusercontent.com/u/1006420?v=3\",\n  \"iss\": \"https://auth0pnp.auth0.com/\",\n  \"sub\": \"github|100...\",\n  \"aud\": \"xvt...\",\n  \"exp\": 1478114742,\n  \"iat\": 1478078742\n}\n```\n\n## Learn more\n\n*   [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth)\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Mitigate Replay Attacks When Using the Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow)\n*   [Register Single-Page Web Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/single-page-web-apps)\n*   [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types)",
  "title": "Add Login Using the Implicit Flow with Form Post",
  "description": "Learn how to add login to your single-page application (SPA) using the Implicit Flow with Form Post.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/add-login-using-the-authorization-code-flow-with-pkce",
  "markdown": "# Add Login Using the Authorization Code Flow with PKCE\n\nYou can add login to your native, mobile, or single-page app using the Authorization Code Flow with PKCE. To learn how the flow works and why you should use it, read [Authorization Code Flow with Proof Key for Code Exchange (PKCE)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce). To learn how to call your API from a native, mobile, or single-page app, read [Call Your API Using Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce).\n\nTo implement the Authorization Code Flow with Proof Key for Code Exchange (PKCE), you can use the following resources:\n\n*   [Auth0 Mobile SDKs](https://auth0.com/docs/libraries) and [Auth0 Single-Page App SDK](https://auth0.com/docs/libraries/auth0-single-page-app-sdk): The easiest way to implement the flow, which will do most of the heavy lifting for you. Our [Mobile Quickstarts](https://auth0.com/docs/quickstart/native) and [Single-Page App Quickstarts](https://auth0.com/docs/quickstart/spa) will walk you through the process.\n    \n*   [Authentication API](https://auth0.com/docs/api/authentication): If you prefer to build your own solution, keep reading to learn how to call our API directly.\n    \n\nFollowing successful login, your application will have access to the user's ID token and access token. The ID token will contain basic user profile information, and the access token can be used to call the Auth0 `/userinfo` endpoint or your own protected APIs. To learn more about ID tokens, read [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens). To learn more about access tokens, read [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens).\n\n## Prerequisites\n\nRegister your app with Auth0. To learn more, read [Register Native Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/native-apps) or [Register Single-Page Web Applications](https://auth0.com/docs/get-started/auth0-overview/create-applications/single-page-web-apps).\n\n*   Select an **Application Type** of **Native** or **Single-Page App**, depending on your application type.\n    \n*   Add an **Allowed Callback URL** of `**YOUR_CALLBACK_URL**`. Your callback URL format will vary depending on your application type and platform. For details about the format for your application type and platform, see our [Native/Mobile Quickstarts](https://auth0.com/docs/quickstart/native) and [Single-Page App Quickstarts](https://auth0.com/docs/quickstart/spa).\n    \n*   Make sure your application's **Grant Types** include **Authorization Code**. To learn more, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types).\n    \n\n## Create code verifier\n\nCreate a `code_verifier`, which is a cryptographically-random, Base64-encoded key that will eventually be sent to Auth0 to request tokens.\n\nTo learn more about the algorithm to create the `code_verifier`, read section [4.1 Client Creates a Code Verifier](https://datatracker.ietf.org/doc/html/rfc7636#section-4.1) of the OAuth Proof Key for Code Exchange spec.\n\n### Javascript sample\n\n```\n// Dependency: Node.js crypto module\n// https://nodejs.org/api/crypto.html#crypto_crypto\nfunction base64URLEncode(str) {\n    return str.toString('base64')\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_')\n        .replace(/=/g, '');\n}\nvar verifier = base64URLEncode(crypto.randomBytes(32));\n```\n\n### Java sample\n\n```\n// Dependency: Apache Commons Codec\n// https://commons.apache.org/proper/commons-codec/\n// Import the Base64 class.\n// import org.apache.commons.codec.binary.Base64;\nSecureRandom sr = new SecureRandom();\nbyte[] code = new byte[32];\nsr.nextBytes(code);\nString verifier = Base64.getUrlEncoder().withoutPadding().encodeToString(code);\n```\n\n### Android sample\n\n```\n// Dependency: Apache Commons Codec\n// https://commons.apache.org/proper/commons-codec/\n// Import the Base64 class.\n// import org.apache.commons.codec.binary.Base64;\nSecureRandom sr = new SecureRandom();\nbyte[] code = new byte[32];\nsr.nextBytes(code);\nString verifier = Base64.encodeToString(code, Base64.URL_SAFE | Base64.NO_WRAP | Base64.NO_PADDING);\n```\n\n### Swift 5 sample\n\n```\nvar buffer = [UInt8](repeating: 0, count: 32)\n_ = SecRandomCopyBytes(kSecRandomDefault, buffer.count, &buffer)\nlet verifier = Data(buffer).base64EncodedString()\n    .replacingOccurrences(of: \"+\", with: \"-\")\n    .replacingOccurrences(of: \"/\", with: \"_\")\n    .replacingOccurrences(of: \"=\", with: \"\")\n```\n\n### Objective-C sample\n\n```\nNSMutableData *data = [NSMutableData dataWithLength:32];\nint result __attribute__((unused)) = SecRandomCopyBytes(kSecRandomDefault, 32, data.mutableBytes);\nNSString *verifier = [[[[data base64EncodedStringWithOptions:0]\n                        stringByReplacingOccurrencesOfString:@\"+\" withString:@\"-\"]\n                        stringByReplacingOccurrencesOfString:@\"/\" withString:@\"_\"]\n                        stringByTrimmingCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@\"=\"]];\n```\n\n## Create code challenge\n\nGenerate a `code_challenge` from the `code_verifier` that will be sent to Auth0 to request an `authorization_code`.\n\nTo learn more about how the `code_challenge` is derived from the `code_verifier`, read section [4.2 Client Creates the Code Challenge](https://datatracker.ietf.org/doc/html/rfc7636#section-4.) of the OAuth Proof Key for Code Exchange spec.\n\n### Javascript sample\n\n```\n// Dependency: Node.js crypto module\n// https://nodejs.org/api/crypto.html#crypto_crypto\nfunction sha256(buffer) {\n    return crypto.createHash('sha256').update(buffer).digest();\n}\nvar challenge = base64URLEncode(sha256(verifier));\n```\n\n### Java sample\n\n```\n// Dependency: Apache Commons Codec\n// https://commons.apache.org/proper/commons-codec/\n// Import the Base64 class.\n// import org.apache.commons.codec.binary.Base64;\nbyte[] bytes = verifier.getBytes(\"US-ASCII\");\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nmd.update(bytes, 0, bytes.length);\nbyte[] digest = md.digest();\nString challenge = Base64.encodeBase64URLSafeString(digest);\n```\n\n### Swift 5 sample\n\n```\nimport CommonCrypto\n\n// ...\n\nguard let data = verifier.data(using: .utf8) else { return nil }\nvar buffer = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))\n_ = data.withUnsafeBytes {\n    CC_SHA256($0.baseAddress, CC_LONG(data.count), &buffer)\n}\nlet hash = Data(buffer)\nlet challenge = hash.base64EncodedString()\n    .replacingOccurrences(of: \"+\", with: \"-\")\n    .replacingOccurrences(of: \"/\", with: \"_\")\n    .replacingOccurrences(of: \"=\", with: \"\")\n```\n\n### Objective-C sample\n\n```\n// Dependency: Apple Common Crypto library\n// http://opensource.apple.com//source/CommonCrypto\nu_int8_t buffer[CC_SHA256_DIGEST_LENGTH * sizeof(u_int8_t)];\nmemset(buffer, 0x0, CC_SHA256_DIGEST_LENGTH);\nNSData *data = [verifier dataUsingEncoding:NSUTF8StringEncoding];\nCC_SHA256([data bytes], (CC_LONG)[data length], buffer);\nNSData *hash = [NSData dataWithBytes:buffer length:CC_SHA256_DIGEST_LENGTH];\nNSString *challenge = [[[[hash base64EncodedStringWithOptions:0]\n                         stringByReplacingOccurrencesOfString:@\"+\" withString:@\"-\"]\n                         stringByReplacingOccurrencesOfString:@\"/\" withString:@\"_\"]\n                         stringByTrimmingCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@\"=\"]];\n```\n\nRequest the user's authorization and redirect back to your app with an `authorization_code`.\n\nOnce you've created the `code_verifier` and the `code_challenge`, you must get the user's authorization. This is technically the beginning of the authorization flow, and this step may include one or more of the following processes:\n\n\\* Authenticating the user; \\* Redirecting the user to an Identity Provider to handle authentication; \\* Checking for active [Single Sign-on (SSO)](https://auth0.com/docs/authenticate/single-sign-on) sessions; \\* Obtaining user consent for the requested permission level, unless consent has been previously given.\n\nTo authorize the user, your app must send the user to the [authorization URL](https://auth0.com/docs/api/authentication#authorization-code-grant-pkce-), including the `code_challenge` you generated in the previous step and the method you used to generate the `code_challenge`.\n\n### Authorization URL example\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=code&\n    code_challenge={codeChallenge}&\n    code_challenge_method=S256&\n    client_id={yourClientId}&\n    redirect_uri={yourCallbackUrl}&\n    scope={scope}&\n    state={state}\n```\n\n### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `response_type` | Denotes the kind of credential that Auth0 will return (`code` or `token`). For this flow, the value must be `code`. |\n| `code_challenge` | Generated challenge from the `code_verifier`. |\n| `code_challenge_method` | Method used to generate the challenge (e.g., S256). The PKCE spec defines two methods, `S256` and `plain`, the former is used in this example and is the **only** one supported by Auth0 since the latter is discouraged. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `redirect_uri` | The URL to which Auth0 will redirect the browser after authorization has been granted by the user. The Authorization Code will be available in the `code` URL parameter. You must specify this URL as a valid callback URL in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings).<br><br>**Warning:** Per the [OAuth 2.0 Specification](https://tools.ietf.org/html/rfc6749#section-3.1.2), Auth0 removes everything after the hash and does _not_ honor any fragments. |\n| `scope` | Specifies the [scopes](https://auth0.com/docs/scopes) for which you want to request authorization, which dictate which claims (or user attributes) you want returned. These must be separated by a space. To get an ID Token in the response, you need to specify a scope of at least `openid`. If you want to return the user's full profile, you can request `openid profile`. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `email`, or [custom claims](https://auth0.com/docs/tokens/concepts/jwt-claims#custom-claims) conforming to a [namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims). Include `offline_access` to get a Refresh Token (make sure that the **Allow Offline Access** field is enabled in the [Application Settings](https://manage.auth0.com/#/applications)). |\n| `state` | (recommended) An opaque arbitrary alphanumeric string your app adds to the initial request that Auth0 includes when redirecting back to your application. To see how to use this value to prevent cross-site request forgery (CSRF) attacks, see [Mitigate CSRF Attacks With State Parameters](https://auth0.com/docs/protocols/oauth2/mitigate-csrf-attacks). |\n| `connection` | (optional) Forces the user to sign in with a specific connection. For example, you can pass a value of `github` to send the user directly to GitHub to log in with their GitHub account. When not specified, the user sees the Auth0 Lock screen with all configured connections. You can see a list of your configured connections on the **Connections** tab of your application. |\n| `organization` | (optional) ID of the organization to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating. |\n| `invitation` | (optional) Ticket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the `invitation` and `organization` key-value pairs when the user accepts the invitation. |\n\nAs an example, your HTML snippet for your authorization URL when adding login to your app might look like:\n\n```\n<a href=\"https://{yourDomain}/authorize?\n  response_type=code&\n  code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM&\n  code_challenge_method=S256&\n  client_id={yourClientId}&\n  redirect_uri={yourCallbackUrl}&\n  scope=openid%20profile&\n  state=xyzABC123\">\n  Sign In\n</a>\n```\n\n### Response\n\nIf all goes well, you'll receive an `HTTP 302` response. The authorization code is included at the end of the URL:\n\n```\nHTTP/1.1 302 Found\nLocation: {yourCallbackUrl}?code={authorizationCode}&state=xyzABC123\n```\n\n## Request tokens\n\nExchange your `authorization_code` and `code_verifier` for tokens.\n\nNow that you have an Authorization Code, you must exchange it for tokens. Using the extracted Authorization Code (`code`) from the previous step, you will need to `POST` to the [token URL](https://auth0.com/docs/api/authentication#authorization-code-pkce-) sending along the `code_verifier`.\n\n### POST to token URL example\n\n*   [cURL](#932c0fcce1314fd08c57b18f84ba38be_shell)\n*   [C#](#932c0fcce1314fd08c57b18f84ba38be_csharp)\n*   [Go](#932c0fcce1314fd08c57b18f84ba38be_go)\n*   [Java](#932c0fcce1314fd08c57b18f84ba38be_java)\n*   [Node.JS](#932c0fcce1314fd08c57b18f84ba38be_node)\n*   [Obj-C](#932c0fcce1314fd08c57b18f84ba38be_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data 'code_verifier={yourGeneratedCodeVerifier}' \\\n  --data 'code={yourAuthorizationCode}' \\\n  --data 'redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    code_verifier: '{yourGeneratedCodeVerifier}',\n    code: '{yourAuthorizationCode}',\n    redirect_uri: '{https://yourApp/callback}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=authorization_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code_verifier={yourGeneratedCodeVerifier}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code={yourAuthorizationCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&redirect_uri={https://yourApp/callback}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=authorization_code&client_id={yourClientId}&code_verifier=%7ByourGeneratedCodeVerifier%7D&code=%7ByourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=authorization_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code_verifier={yourGeneratedCodeVerifier}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code={yourAuthorizationCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&redirect_uri={https://yourApp/callback}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to \"authorization\\_code\". |\n| `code_verifier` | The cryptographically-random key that was generated in the first step of this tutorial. |\n| `code` | The `authorization_code` retrieved in the previous step of this tutorial. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `redirect_uri` | The valid callback URL set in your Application settings. This must exactly match the `redirect_uri` passed to the authorization URL in the previous step of this tutorial. Note that this must be URL encoded. |\n\n### Response\n\nIf all goes well, you'll receive an HTTP 200 response with a payload containing `access_token`, `refresh_token`, `id_token`, and `token_type` values:\n\n```\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"refresh_token\":\"GEbRxBN...edjnXbL\",\n  \"id_token\":\"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\n[ID tokens](https://auth0.com/docs/secure/tokens/id-tokens) contain user information that must be decoded and extracted.\n\n[Access tokens](https://auth0.com/docs/secure/tokens/access-tokens) are used to call the [Auth0 Authentication API's /userinfo endpoint](https://auth0.com/docs/api/authentication#get-user-info) or another API. If you are calling your own API, the first thing your API will need to do is [verify the Access token](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens).\n\n[Refresh tokens](https://auth0.com/docs/secure/tokens/refresh-tokens) are used to obtain a new access token or ID token after the previous one has expired. The `refresh_token` will only be present in the response if you included the `offline_access` scope and enabled **Allow Offline Access** for your API in the Dashboard.\n\n## Use cases\n\n### Basic authentication request\n\nThis example shows the most basic request you can make when authorizing the user in step 1. It displays the Auth0 login screen and allows the user to sign in with any of your configured connections:\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=code&\n    code_challenge={codeChallenge}&\n    code_challenge_method=S256&\n    client_id={yourClientId}&\n    redirect_uri={yourCallbackUrl}&\n    scope=openid\n```\n\nNow, when you request tokens, your ID Token will contain the most basic claims. When you decode the ID Token, it will look similar to:\n\n```\n{\n  \"iss\": \"https://auth0pnp.auth0.com/\",\n  \"sub\": \"auth0|581...\",\n  \"aud\": \"xvt9...\",\n  \"exp\": 1478112929,\n  \"iat\": 1478076929\n}\n```\n\n### Request user's name and profile picture\n\nIn addition to the usual user authentication, this example shows how to request additional user details, such as name and picture.\n\nTo request the user's name and picture, you need to add the appropriate scopes when authorizing the user:\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=code&\n    code_challenge={codeChallenge}&\n    code_challenge_method=S256&\n    client_id={yourClientId}&\n    redirect_uri={yourCallbackUrl}&\n    scope=openid%20name%20picture&\n    state={state}\n```\n\nNow, when you request tokens, your ID token will contain the requested name and picture claims. When you decode the ID token, it will look similar to:\n\n```\n{\n  \"name\": \"auth0user@...\",\n  \"picture\": \"https://example.com/profile-pic.png\",\n  \"iss\": \"https://auth0user.auth0.com/\",\n  \"sub\": \"auth0|581...\",\n  \"aud\": \"xvt...\",\n  \"exp\": 1478113129,\n  \"iat\": 1478077129\n}\n```\n\n### Request user log in with GitHub\n\nIn addition to the usual user authentication, this example shows how to send users directly to a social identity provider, such as GitHub. For this example to work, you need to go to [Auth0 Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social) and configure the appropriate connection. Get the connection name from the **Settings** tab.\n\nTo send users directly to the GitHub login screen, you need to pass the `connection` parameter and set its value to the connection name (in this case, `github`) when authorizing the user:\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=code&\n    code_challenge={codeChallenge}&\n    code_challenge_method=S256&\n    client_id={yourClientId}&\n    redirect_uri={yourCallbackUrl}&\n    scope=openid%20name%20picture&\n    state={state}&\n    connection=github\n```\n\nNow, when you request tokens, your ID token will contain a `sub` claim with the user's unique ID returned from GitHub. When you decode the ID token, it will look similar to:\n\n```\n{\n  \"name\": \"John Smith\",\n  \"picture\": \"https://avatars.example.com\",\n  \"email\": \"jsmith@...\",\n  \"email_verified\": true,\n  \"iss\": \"https://auth0user.auth0.com/\",\n  \"sub\": \"github|100...\",\n  \"aud\": \"xvt...\",\n  \"exp\": 1478114742,\n  \"iat\": 1478078742\n}\n```\n\n## Learn more\n\n*   [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth)\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)\n*   [Tokens](https://auth0.com/docs/secure/tokens)",
  "title": "Add Login Using the Authorization Code Flow with PKCE",
  "description": "Learn how to add login to your native, mobile, or single-page application using the Authorization Code Flow with Proof Key for Code Exchange (PKCE).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-exchange",
  "markdown": "# Client Credentials Exchange\n\nAt the Client Credentials Exchange extensibility point, Hooks let you execute custom actions when an Access Token is issued through the Authentication API [`POST /oauth/token` endpoint](https://auth0.com/docs/api/authentication#client-credentials-flow) using the Client Credentials Flow. For example, you may deny the token from being issued, add custom claims to the access token, or modify its scopes. To learn more, read [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow).\n\nHooks at this extensibility point are blocking (synchronous), which means they execute as part of the trigger's process and prevent the rest of the Auth0 pipeline from running until the Hook is complete.\n\nTo learn about other extensibility points, read Extensibility Points.\n\n## Starter code and parameters\n\nWhen creating a Hook executed at the Client Credentials Exchange extensibility point, you may find the following starter code helpful. Parameters that can be passed into and used by the Hook function are listed at the top of the code sample.\n\n```\n/**\n@param {object} client - client information\n@param {string} client.name - client name\n@param {string} client.id - client ID\n@param {string} client.tenant - Auth0 tenant name\n@param {object} client.metadata - client metadata\n@param {array|undefined} scope - either an array of strings representing the token's scope claim, or undefined\n@param {string} audience - token's audience claim\n@param {object} context - Auth0 context info\n@param {object} context.webtask - Hook (webtask) context\n@param {function} cb - function (error, accessTokenClaims)\n*/\n\nmodule.exports = function(client, scope, audience, context, cb) {\n  var access_token = {};\n  access_token.scope = scope; // do not remove this line\n\n  // Modify scopes or add extra claims\n  // access_token['https://example.com/claim'] = 'bar';\n  // access_token.scope.push('extra');\n\n  // Deny the token and respond with an OAuth2 error response\n  // if (denyExchange) {\n  //   // To return an HTTP 400 with { \"error\": \"invalid_scope\", \"error_description\": \"Not authorized for this scope.\" }\n  //   return cb(new InvalidScopeError('Not authorized for this scope.'));\n  //\n  //   // To return an HTTP 400 with { \"error\": \"invalid_request\", \"error_description\": \"Not a valid request.\" }\n  //   return cb(new InvalidRequestError('Not a valid request.'));\n  //\n  //   // To return an HTTP 500 with { \"error\": \"server_error\", \"error_description\": \"A server error occurred.\" }\n  //   return cb(new ServerError('A server error occurred.'));\n  // }\n\n  cb(null, access_token);\n};\n```\n\nPlease note:\n\n*   The callback function (`cb`) at the end of the sample code signals completion and must be included.\n    \n\n*   The line `access_token.scope = scope` ensures that all granted scopes will be present in the access token. Removing it will reset all scopes, and the token will include only scopes you add with the script.\n    \n\n### Default response\n\nWhen you run a Hook executed at the Client Credentials Exchange extensibility point, the default response object is:\n\n```\n{\n  \"scope\": \"array of strings\"\n}\n```\n\n### Starter code response\n\nOnce you've customized the starter code with your scopes and additional claims, you can test the Hook using the runner embedded in the Hook Editor. The runner simulates a call to the Hook with the same body and response that you would get with a Client Credentials Exchange.\n\nWhen you run a Hook based on the starter code, the response object is:\n\n```\n{\n  \"audience\": \"https://my-tenant.auth0.com/api/v2/\",\n  \"client\": {\n    \"id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",\n    \"name\": \"client-name\",\n    \"tenant\": \"my-tenant\",\n    \"metadata\": {\n      \"plan\": \"full\"\n    }\n  },\n  \"scope\": [\n    \"read:connections\"\n  ]\n}\n```\n\n## Sample script: Add an additional scope to the access token\n\nIn this example, we use a Hook to add an additional scope to those already existing for the access token.\n\n```\nmodule.exports = function(client, scope, audience, context, cb) {\n    // Scopes to be added\n    var access_token = {};\n\n    // Get the scope that's currently on the Access Token\n    // and add it to the object we're working with\n    // Do not remove this line!\n    access_token.scope = scope;\n\n    // Append the `read:resource` scope\n    access_token.scope.push('read:resource');\n\n    // Callback to indicate completion and to return new\n    // array of scopes\n    cb(null, access_token);\n};\n```\n\nTo learn more, read [Scopes](https://auth0.com/docs/get-started/apis/scopes).\n\n### Response\n\nWhen we run this Hook, the response object is:\n\n```\n{\n  \"scope\": [\n    \"read:connections\",\n    \"read:resource\"\n  ]\n}\n```\n\n## Sample script: Add a claim to the access token\n\nIn this example, we add a namespaced custom claim and its value to the access token. To learn more, read [Create Namespaced Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\nYou can add the following as claims to the issued token:\n\n*   The `scope` property of the response object\n    \n*   Any properties with namespaced property names\n    \n\nThe extensibility point ignores all other response object properties.\n\n```\nmodule.exports = function(client, scope, audience, context, cb) {\n    // Claims to be added\n    var access_token = {};\n\n    // New claim to add to the token\n    access_token['https://example.com/foo'] = 'bar';\n\n    // Callback to indicate completion and to return new claim\n    cb(null, access_token);\n  };\n```\n\n### Response\n\nWhen we run this Hook, the response object is:\n\n```\n{\n  \"https://example.com/foo\": \"bar\"\n}\n```\n\n## Sample script: Raise an error or deny an access token\n\nIn this example, we use custom Error objects to generate OAuth2 Error Responses. (To learn more, see [OAuth2 RFC - Section 5.2 in the IETF Datatracker](https://tools.ietf.org/html/rfc6749#section-5.2).)\n\nIf a plain JavaScript error is returned in the callback, such as:\n\n```\nmodule.exports = function(client, scope, audience, context, cb) {\n    // Callback to indicate completion and to return new claim\n    cb(new Error(\"Unknown error occurred.\");\n  };\n```\n\nThen when you request a `client_credentials` grant from the `/oauth/token` endpoint, Auth0 will respond with:\n\n```\nHTTP 500\n{ \"error\": \"server_error\", \"error_description\": \"Unknown error occurred.\" }\n```\n\nHowever, if you like additional control over the OAuth2 Error Response, three custom Error objects are available to use instead.\n\n### InvalidScopeError\n\n```\nmodule.exports = function(client, scope, audience, context, cb) {\n    const invalidScope = ...; // determine if scope is valid\n\n    if(invalidScope) {\n      cb(new InvalidScopeError(\"Scope is not permitted.\"));\n    }\n  };\n```\n\nThen when you request a `client_credentials` grant is from the `/oauth/token` endpoint, Auth0 responds with:\n\n```\nHTTP 400\n{ \"error\": \"invalid_scope\", \"error_description\": \"Scope is not permitted.\" }\n```\n\n### InvalidRequestError\n\n```\nmodule.exports = function(client, scope, audience, context, cb) {\n    const invalidRequest = ...; // determine if request is valid\n\n    if(invalidRequest) {\n      cb(new InvalidRequestError(\"Bad request.\"));\n    }\n  };\n```\n\nThen when you request a `client_credentials` grant from the `/oauth/token` endpoint, Auth0 will respond with:\n\n```\nHTTP 400\n{ \"error\": \"invalid_request\", \"error_description\": \"Bad request.\" }\n```\n\n### ServerError\n\n```\nmodule.exports = function(client, scope, audience, context, cb) {\n    callOtherService(function(err, response) {\n      if(err) {\n        return cb(new ServerError(\"Error calling remote system: \" + err.message));\n      }\n    });\n  };\n```\n\nThen when you request a `client_credentials` grant from the `/oauth/token` endpoint, Auth0 responds with:\n\n```\nHTTP 400\n{ \"error\": \"server_error\", \"error_description\": \"Error calling remote system: ...\" }\n```\n\n## Learn more",
  "title": "Client Credentials Exchange",
  "description": "Learn how Hooks can be used with the Client Credentials Exchange extensibility point, which is available for database connections and passwordless connections.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/cookies/spa-authenticate-with-cookies",
  "markdown": "# Authenticate Single-Page Apps With Cookies\n\nSecuring a single-page app (SPA) can be a challenge. However, if your SPA meets the following criteria, then you can simplify your implementation by using cookies to authenticate.\n\n*   Served to the client using your own backend.\n    \n*   Has the same domain as your backend.\n    \n*   Makes API calls that require authentication to your backend.\n    \n\nHere is a description of this approach as well as a sample implementation using [Node.js](https://nodejs.org/en/).\n\n## How it works\n\nThe steps below show how tokens are retrieved and used. In this approach, the [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post) is used instead of a traditional [Authorization Code Flow with Proof Key for Code Exchange](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce). This is because Form Post Response Mode is a simpler way to implement login when it’s your own resource you are requesting to access.\n\n![Authenticate Single-Page Apps Using Cookies How it Works part 1 diagram](https://images.ctfassets.net/cdy7uua7fh8z/7suPpG6SuHuCOFHeFmE21T/1bf0a56fd21f65460cff7fd01b4c93f4/2023-09-22_13-21-34.png)\n\n1.  The user accesses a protected route using the browser, or performs some action that requires an authentication step to be initiated (such as clicking on a Login button)\n    \n2.  The browser client redirects to a `/login` route on the backend, or to the protected route depending on what the user did\n    \n3.  The backend constructs a request to the authorization server’s `/authorize` endpoint and redirects the browser client there\n    \n4.  The user is prompted to authenticate themselves using whatever method the authorization server presents\n    \n5.  The authorization server POSTs the tokens to the redirect URI as a URL-encoded form post. The backend is able to retrieve those tokens by parsing the body data.\n    \n\nAt this point, the user is authenticated and the backend has the required tokens. A cookie can now be created to represent this state on the client. The client browser is then redirected to a route that serves the SPA and also receives the authentication cookie.\n\nFrom now on, this cookie is traded between the client and backend when API calls are made using an AJAX call. On each request, the backend verifies if the cookie is still valid and if so, allows the request to continue.\n\n![Authenticate Single-Page Apps Using Cookies How it Works part 2 diagram](https://images.ctfassets.net/cdy7uua7fh8z/6SCp9KwQkwJV7L26TOuxIO/d625575a43d00a00fcf17c7310ac2bc8/2023-09-22_13-21-50.png)\n\n### Invalid or missing cookies\n\nWhen implementing this approach you'll need to handle cases where the authentication cookie is invalid or missing. The API call to the backend from the client happens in the background, so the client has to deal with any response from the server indicating the user should reauthenticate.\n\nIn the following sample application, this case is handled in a naive way by prompting the user to re-authenticate if the API call results in a 302 Redirect result. The 302 occurs because, upon unsuccessful validation of the cookie, the server tries to redirect to the Authorization endpoint of the authorization server and sends this response to the client.\n\n## Example\n\nThe example application uses Node.js and Express to demonstrate the concepts covered above.\n\n### Prerequisites\n\n*   To follow along, make sure you have the [latest version of Node](https://nodejs.org/en/download/) installed.\n    \n*   Once Node is installed, [download or clone the source code](https://github.com/auth0-blog/spa-cookie-demo/) and open the project folder inside a terminal window.\n    \n    ```\n    // Clone the tutorial respository using SSH\n    git clone git@github.com:auth0-blog/spa-cookie-demo\n    // ... or if you use HTTPS:\n    git clone https://github.com/auth0-blog/spa-cookie-demo.git\n    // Move into the project directory\n    cd spa-cookie-demo\n    ```\n    \n*   The `master` branch represents the state of the application before any authentication is added. If you would like to refer to the final version of the application, check out the `with-oidc` branch: `git checkout with-oidc`\n    \n\n### Initialize the Node.js app\n\nInstall the application dependencies by running `npm install` from your terminal window. To run the application, use `npm run dev`. This starts the Express server. Go to [http://localhost:3000](http://localhost:3000/) in your browser to view the application.\n\nThe development servers uses `nodemon`, which automatically restarts whenever it detects any file changes.\n\n### Explore the application\n\nWith the application open at [http://localhost:3000](http://localhost:3000/), click the **Call API** button. You should see a message displayed on the screen.\n\n![SPA Authentication with Cookies Explore the Application screen](https://images.ctfassets.net/cdy7uua7fh8z/7JhdgzFLig2xcDle7ziiGp/c1db6272d20d4a291ba90a6968460109/image3.png)\n\nNote that you were able to make the API call without being logged in. Let's fix that by adding some middleware that requires the user to authenticate before the API call can be made.\n\n### Set up environment\n\nFor the application to work with authentication, `express-openid-connect` requires some environment variables to be present. For this application, these variables can be specified in a `.env` file. Create a `.env` file in the root of the project directory and populate it with the following:\n\n```\nISSUER_BASE_URL=<YOUR OIDC URL>\nCLIENT_ID=<YOUR OIDC CLIENT ID>\nBASE_URL=http://localhost:3000\nAPP_SESSION_SECRET=<YOUR SECRET VALUE>\n```\n\n### Set up app in Auth0\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and click **Create Application**.\n    \n2.  Name your new application, select **Regular Web Applications**, and click **Create**\n    \n3.  In the **Settings** for your new app, add `http:/localhost:3000/callback` to **Allowed Callback URLs**.\n    \n4.  Add `http:/localhost:3000` to **Allowed Logout URLs**.\n    \n5.  Click **Save Changes**.\n    \n6.  Go to [Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social) and set up some social connections. Enable them for your app in the **Application** options in the **Connections** tab. The example uses username/password database, Facebook, Google, and X.\n    \n7.  On the **Settings** screen, note the domain and client ID settings at the top.\n    \n8.  There are two values that need to be configured as part of the application. Reopen the `.env` file and set these values:\n    \n    ```\n    ISSUER_BASE_URL={yourDomain}\n    CLIENT_ID={yourClientId}\n    BASE_URL=http://localhost:3000\n    APP_SESSION_SECRET=<YOUR SECRET VALUE>\n    ```\n    \n\n### Run the app\n\n1.  With the server and environment configuration done, find your browser window that has the application open. If you've closed the browser and stopped the server, run the following from the terminal to restart the application: `npm run dev`\n    \n2.  Open [http://localhost:3000](http://localhost:3000/) in the browser. From a user interface perspective, the app should look the same, however this time when the **Call API** button is clicked, you should receive a warning that the user is not logged in. Also note that you do not see the \"Hello, World\" message as before since the call to the API has been rejected.\n    \n3.  Click **Log in now** to log in. Once you have been authenticated, you'll return to the app and see an updated UI that reflects your new logged-in state. You should be able to press the **Call API** button once more to invoke an API call to the server, and it now works.\n    \n4.  Click the **Profile** link at the top of the page to show user information retrieved from the ID token.\n    \n    ![SPA Authentication Using Cookies User Profile](https://images.ctfassets.net/cdy7uua7fh8z/3f9uRrBolvtguRJDiHUpkn/061b7c4b76e6c342190ed4606e72f36f/image8.png)\n\n## Learn more\n\n*   [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post)\n*   [Authenticate: SPA Example](https://auth0.com/docs/videos/get-started-series/authenticate-spa-example)\n*   [Secure](https://auth0.com/docs/secure)\n*   [SameSite Cookie Attribute Changes](https://auth0.com/docs/manage-users/cookies/samesite-cookie-attribute-changes)",
  "title": "Authenticate Single-Page Apps With Cookies",
  "description": "Describes how to use your backend server to authenticate a single-page app (SPA) with cookies.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/universal-vs-embedded-login",
  "markdown": "# Centralized Universal Login vs. Embedded Login\n\nWhen you design the authentication experience for your application, you have to choose whether the login flow will use **universal** or **embedded** login.\n\n*   With **Universal Login**, when the users try to log in they are redirected to a central domain, through which authentication is performed, and then they are redirected back to the app. An example is G Suite. No matter which service you are trying to access (Gmail, Google calendar, Google docs, etc) if you are not logged in you are redirected to `https://accounts.google.com` and once you successfully log in you are redirected back to the calling app.\n    \n\n*   On the other hand, an **embedded login** flow does not redirect the user somewhere central. The login widget is served from the same page without redirecting the user to another domain. The credentials are then sent to the authentication provider for authentication. In a web app, this is a cross-origin request.\n    \n\n## Pros and cons\n\n| **Feature** | **Centralized** | **Embedded** |\n| --- | --- | --- |\n| **Single Sign-On** | If you are working with mobile apps, you cannot have SSO unless you use Universal Login. With web apps you can, although the most secure way is to use a central service so the cookies are from the same origin. | With embedded login, you'd have to collect the user credentials in an application served from one origin and then send them to another origin, which can present certain security vulnerabilities, including the possibility of a phishing attack. |\n| **Consistency and Maintenance** | Your Authorization Server (the domain that logs the users in) owns all the login pages which makes the management easier and the pages more consistent and secure. You could also use a single login page among your apps, a process that creates an impression that users are logging into a centralized system, rather than an individual app. | If you have more than one app, you must implement more than one login page. You will also have to maintain and manage these pages. Besides the extra effort it can also introduce inconsistencies which results in bad UX. Furthermore, with embedded login you would have to manage the dangers of cross-origin attack vectors. |\n| **Feature Management** | You can turn on and off features such as MFA, across all your apps, using the Dashboard. | Must be done for each application individually. |\n| **User Experience** | Redirected to another subdomain to log in. | Not redirected to another subdomain to login. |\n| **Mobile Apps and Security** | According to the [Best Current Practice for OAuth 2.0 for Native Apps Request For Comments](https://www.rfc-editor.org/rfc/rfc8252.txt), only external user agents (such as the browser) should be used by native applications for authentication flows. Using the browser to make native app authorization requests results in better security and it gives users the confidence that they are entering credentials in the right domain. It also enables use of the user's current authentication state, making Single Sign-on (SSO) possible. | Embedded user agents are deemed unsafe for third parties and should not be implemented. With native login a malicious app could try and phish users for username/password or tokens. Also, if your mobile apps use native login, then your users have to enter their credentials for each of your apps, hence SSO is not possible. |\n\n## Security risks\n\n*   Universal Login is more secure than embedded login. Authentication takes place over the same domain, eliminating cross-origin requests. Cross-origin authentication is inherently more dangerous. Collecting user credentials in an application served from one origin and then sending them to another origin can present certain security vulnerabilities. [](https://auth0.com/blog/all-you-need-to-know-about-the-google-docs-phishing-attack/)Phishing attacks are more likely, as are bucket brigade attacks. Universal Login does not send information between origins, thereby negating cross-origin concerns. To learn more, read [Prevent Common Cybersecurity Attacks](https://auth0.com/docs/secure/security-guidance/prevent-threats).\n    \n\n*   Embedded user agents are unsafe for third parties, including the authorization server itself. If an embedded login is used, the app has access to both the authorization grant and the user's authentication credentials. As a consequence, this data is left vulnerable to recording or malicious use. Even if the app is trusted, allowing it to access the authorization grant as well as the user's full credentials is unnecessary. This violates the principle of least privilege and increases the potential for attack.\n    \n\nGoogle no longer supports an embedded approach when implementing OAuth. Furthermore, according to the [Internet Engineering Task Force (IETF)](https://www.ietf.org/), authorization requests from native apps should only be made through external user agents, primarily the user's browser. Using the browser to make native app authorization requests results in better security. When embedded agents are used, the app has access to the OAuth authorization grant as well as the user's credentials, leaving this data vulnerable to recording or malicious use.\n\nAnother helpful resource is [Modernizing OAuth interactions in Native Apps for Better Usability and Security](https://developers.googleblog.com/2016/08/modernizing-oauth-interactions-in-native-apps.html) at [https://developers.googleblog.com](https://developers.googleblog.com/).\n\n## Universal Login with Auth0\n\nFor most situations, we recommend using a Universal Login strategy, where Auth0 will show a login page if authentication is required. You can customize your login page using the Dashboard.\n\nYou can use Auth0's Custom Domains to persist the same domain across the login page and the app. The redirect to the login page will be transparent to your users because the domain will not change. To learn more, read [Custom Domains](https://auth0.com/docs/customize/custom-domains).\n\nWhenever your app triggers an authentication request, the user will be redirected to the login page in order to authenticate. This will create a cookie. In future authentication requests, Auth0 will check for this cookie, and if it is present the user will not be redirected to the login page. They will see the page only when they need to actually log in. This is the easiest way to implement SSO.\n\nNote that if the incoming authentication request uses an external identity provider (for example, Facebook), the login page will not be displayed. Instead, Auth0 will direct the user to the identity provider's login page.\n\nYou can deploy your custom login page from an external repository, like [GitHub](https://marketplace.auth0.com/integrations/github-actions), [Bitbucket](https://marketplace.auth0.com/integrations/bitbucket-pipeline), [GitLab](https://marketplace.auth0.com/integrations/gitlab-pipeline), or [Microsoft Azure](https://marketplace.auth0.com/integrations/azure-pipeline).\n\nOur recommendation is to use Universal Login when you use Auth0. The first and foremost reason is security. Using Auth0 Universal Login instead of embedding login in your application provides seamless CSRF protection. This helps prevent third-party impersonation or the hijacking of sessions.\n\n## Embedded login with Auth0\n\nEmbedded logins in web apps with Auth0 use cross-origin authentication. (To learn more, read [Cross-Origin Authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication)). This uses third-party cookies to allow for secure authentication transactions across different origins. This does not apply to native applications since they use the standard OAuth 2.0 `/token` endpoint. To learn more about third-party cookies, read [Tracking and privacy: Third-party cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Third-party_cookies) at [https://developer.mozilla.org](https://developer.mozilla.org/).\n\nAuth0 does not recommend using cross-origin authentication, however, if you do, only when authenticating against a directory using a username and password. Social IdPs and enterprise federation use a different mechanism, redirecting via standard protocols like OpenID Connect (OIDC) and SAML. Additionally, cross-origin authentication is only applicable to embedded login on the web (using Lock or auth0.js). Native applications using embedded login make use of the standard OAuth 2.0 Token endpoint.\n\nIn addition, if you have not enabled custom domains, the end-user must have a browser that supports third-party cookies. Otherwise, in some browsers, cross-origin authentication will fail. This limitation applies to both traditional username/password database connections as well as passwordless database connections.\n\n## Learn more\n\n*   [Migrate from Embedded Login to Universal Login](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-embedded-login-to-universal-login)\n*   [Mobile Device Login Flow Best Practices](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow/mobile-device-login-flow-best-practices)\n*   [Prevent Common Cybersecurity Threats](https://auth0.com/docs/secure/security-guidance/prevent-threats)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)",
  "title": "Centralized Universal Login vs. Embedded Login",
  "description": "Describes the differences between centralized Universal Login and Embedded login.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/embedded-login",
  "markdown": "# Embedded Login\n\nEmbedded Login allows your users to log directly into your application and transmit their credentials to the Auth0 server for authentication. We do not recommend using Embedded Login. To learn more, read [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login).\n\nIf you decide to use Embedded Login, you must [configure your application for Cross-Origin Resource Sharing](https://auth0.com/docs/get-started/applications/set-up-cors) and should [configure a custom domain](https://auth0.com/docs/customize/custom-domains). You can then implement the [Lock SDK](https://auth0.com/docs/libraries/lock) or [Auth0.js SDK](https://auth0.com/docs/libraries/auth0js) within your application, or call the [Auth0 Authentication API](https://auth0.com/docs/api/authentication) directly.\n\nAuth0 supports Embedded Login with Passwordless connections for multiple application types:\n\n*   [Embedded Passwordless Login in Native Applications](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/native)\n    \n*   [Embedded Passwordless Login in Regular Web Applications](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/webapps)\n    \n*   [Embedded Passwordless Authentication for Single-Page Apps](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/spa)\n    \n\n## Learn more\n\n*   [Lock for Web](https://auth0.com/docs/libraries/lock)\n*   [Auth0.js v9 Reference](https://auth0.com/docs/libraries/auth0js)\n*   [Cross-Origin Authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication)",
  "title": "Embedded Login",
  "description": "Describes Auth0 Embedded Login used to log users directly into your application, transmitting credentials to the Auth0 server.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/native-login",
  "markdown": "# Native Login\n\nNative mobile applications can use native or browser-based login flows.\n\nIn a **browser-based** login flow, the user is shown a web browser and redirected to the Auth0 login page for sign up or log in. For example: an iOS application opens a SafariViewController or an Android application opens a Custom Chrome Tab.\n\nWith a **native** login flow, the user signs up or enters their credentials directly into the app.\n\nRegardless of which option you choose, Auth0 supports either.\n\n## Browser-based login\n\n*   [Android Quickstart](https://auth0.com/docs/quickstart/native/android)\n    \n*   [iOS Swift Quickstart](https://auth0.com/docs/quickstart/native/ios-swift)\n    \n\n## Native embedded login\n\nIf you prefer to embed your own login pages within your native/mobile app, you can implement our login widget, Lock, directly into your app with:\n\n*   [Lock.swift](https://auth0.com/docs/libraries/lock-swift)\n    \n*   [Lock.Android](https://auth0.com/docs/libraries/lock-android)\n    \n\nExamples of native apps with embedded login:\n\n*   [Android](https://github.com/auth0-samples/auth0-android-sample/tree/embedded-login)\n    \n*   [iOS](https://github.com/auth0-samples/auth0-ios-swift-sample/tree/embedded-login/01-Embedded-Login)\n    \n\n### Passwordless\n\n[Embedded Passwordless Login in Native Applications](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/native)\n\n### Considerations\n\n*   Phishing/security concerns: an unauthorized party could decompile or intercept traffic to/from your application to get the Client ID and authentication URL. With this information the unauthorized party could create a rogue application, upload it to an application store, and use it to phish for usernames, passwords, and Access Tokens.\n    \n*   SSO: users have to enter their credentials for each application.\n    \n    *   Can implement SSO with native apps by storing refresh tokens on a shared keychain, but this is not compliant with the OAuth 2.0 specifications.\n        \n*   Takes more time to implement\n    \n*   No automatic improvements when Auth0 adds new features, have to update app code to take advantage of new features vs UL\n    \n*   Not compliant with OAuth 2.0 best practices\n    \n    *   [RFC 8252 OAuth 2.0 for Native Apps](https://tools.ietf.org/html/rfc8252): authorization requests from native apps should only be made through external user-agents, primarily the user's browser\n        \n\nYou can add functionality to your native app letting users authenticate with social identity providers natively, within the application:\n\nFacebook Login:\n\n*   [Add Facebook Login to Native Apps](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/facebook-native)\n    \n*   [Android - Facebook Login](https://auth0.com/docs/quickstart/native/android-facebook-login)\n    \n*   [iOS Swift - Facebook Login](https://auth0.com/docs/quickstart/native/ios-swift-facebook-login)\n    \n\nSign In with Apple:\n\n*   [iOS Swift - Sign In With Apple](https://auth0.com/docs/quickstart/native/ios-swift-siwa)\n    \n*   [Add Sign In with Apple to Native iOS Apps](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/apple-native)\n    \n\n### Rate limits\n\nLimits are only applied to requests related to the Native Social Login flows, which are identified based on the body of the requests with the following initial criteria:\n\n| Request Type | Body |\n| --- | --- |\n| `grant_type` | `urn:ietf:params:oauth:grant-type:token-exchange` |\n| `subject_token_type` | `http://auth0.com/oauth/token-type/apple-authz-code` |\n\n#### Limits for production tenants of paying customers\n\n| Endpoint | Path | Limited By | Rate Limit |\n| --- | --- | --- | --- |\n| Get Token | `/oauth/token` | Any native social login request | 50 per minute with bursts up to 500 requests |\n\n#### Limits for non-production tenants of paying customers and all tenants of free customers\n\n| Endpoint | Path | Limited By | Rate Limit |\n| --- | --- | --- | --- |\n| Get Token | `/oauth/token` | Native social login requests and IP | 30 per minute |",
  "title": "Native Login",
  "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow/call-your-api-using-the-device-authorization-flow",
  "markdown": "# Call Your API Using the Device Authorization Flow\n\nAuth0 makes it easy for your app to implement the Device Authorization flow using:\n\n*   [Authentication API](https://auth0.com/docs/api/authentication): Keep reading to learn how to call our API directly. For an interactive experience, read [Device Flow Playground](https://auth0.github.io/device-flow-playground/).\n    \n\n## Prerequisites\n\nBefore beginning this tutorial:\n\n*   Check limitations (below) to be sure the Device Authorization flow is suitable for your implementation.\n    \n*   [Register the Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications/native-apps).\n    \n    *   Select an **Application Type** of **Native**.\n        \n    *   If necessary, set **Allowed Web Origins**. You can use this to allow localhost as an origin for local development, or to set an allowed origin for specific TV software with architecture subject to CORS (e.g., HTML5 + JS). Most applications will not use this setting.\n        \n    *   Ensure that the **OIDC Conformant** toggle is enabled. This setting is in the [Dashboard](https://manage.auth0.com/#) under **Applications > Application > Advanced Settings > OAuth**.\n        \n    *   Make sure the Application's **Grant Types** include **Device Code**. To learn how, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types).\n        \n    *   If you want your Application to be able to use Refresh Tokens, make sure the Application's **Grant Types** include **Refresh Token**. To learn how, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types). To learn more about Refresh Tokens, read [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n        \n*   Set up and enable at least one connection for the Application: [Database connections](https://auth0.com/docs/get-started/applications/set-up-database-connections), [Social connections](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers)\n    \n*   [Register your API with Auth0](https://auth0.com/docs/architecture-scenarios/mobile-api/part-2#create-the-api)\n    \n    *   If you want your API to receive Refresh Tokens to allow it to obtain new tokens when the previous ones expire, enable **Allow Offline Access**. To learn more about Refresh Tokens, read [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n        \n*   [Configure Device User Code Settings](https://auth0.com/docs/get-started/tenant-settings/configure-device-user-code-settings) to define the character set, format, and length of your randomly-generated user code.\n    \n\n## Steps\n\n1.  [Request device code](#request-device-code) (Device Flow): Request a device code that the user can use to authorize the device.\n    \n2.  [Request device activation](#request-device-activation) (Device Flow): Request that the user authorize the device using their laptop or smartphone.\n    \n3.  [Request tokens](#request-tokens) (Device Flow): Poll the token endpoint to request a token.\n    \n4.  [Authorize user](#authorize-user) (Browser Flow): The user authorizes the device, so the device can receive tokens.\n    \n5.  [Receive tokens](#receive-tokens) (Device Flow): After the user successfully authorizes the device, receive tokens.\n    \n6.  [Call API](#call-api) (Device Flow): Use the retrieved Access Token to call your API.\n    \n7.  [Refresh tokens](#refresh-tokens) (Device Flow): Use a Refresh Token to request new tokens when the existing ones expire.\n    \n\nOptional: [Explore sample use cases](#sample-use-cases).\n\nOptional: [Troubleshoot](#troubleshoot).\n\n### Request device code\n\nOnce the user has started their device app and wants to authorize the device, you'll need to get a device code. When the user begins their session in their browser-based device, this code will be bound to that session.\n\nTo get the device code, your app must request a code from the [device code URL](https://auth0.com/docs/api/authentication#get-device-code), including the Client ID.\n\n#### Example POST to device code URL\n\n*   [cURL](#0e7cd98654c748a8aa9ba7a9247f7836_shell)\n*   [C#](#0e7cd98654c748a8aa9ba7a9247f7836_csharp)\n*   [Go](#0e7cd98654c748a8aa9ba7a9247f7836_go)\n*   [Java](#0e7cd98654c748a8aa9ba7a9247f7836_java)\n*   [Node.JS](#0e7cd98654c748a8aa9ba7a9247f7836_node)\n*   [Obj-C](#0e7cd98654c748a8aa9ba7a9247f7836_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/device/code' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data 'client_id={yourClientId}' \\\n  --data 'scope={scope}' \\\n  --data 'audience={audience}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/device/code\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"client_id={yourClientId}&scope=%7Bscope%7D&audience=%7Baudience%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/device/code\"\n\n\tpayload := strings.NewReader(\"client_id={yourClientId}&scope=%7Bscope%7D&audience=%7Baudience%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/device/code\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"client_id={yourClientId}&scope=%7Bscope%7D&audience=%7Baudience%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/device/code',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: {client_id: '{yourClientId}', scope: '{scope}', audience: '{audience}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&scope={scope}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience={audience}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/device/code\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/device/code\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"client_id={yourClientId}&scope=%7Bscope%7D&audience=%7Baudience%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"client_id={yourClientId}&scope=%7Bscope%7D&audience=%7Baudience%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/device/code\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/device/code\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"client_id={yourClientId}&scope=%7Bscope%7D&audience=%7Baudience%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&scope={scope}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience={audience}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/device/code\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Device code parameters\n\nNote that when requesting a device code to call a custom API, you:\n\n*   must include an audience parameter\n    \n*   can include additional scopes supported by the target API\n    \n\n| Parameter Name | Description |\n| --- | --- |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `scope` | The [scopes](https://auth0.com/docs/scopes) for which you want to request authorization. These must be separated by a space. You can request any of the [standard OIDC scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` and `email`, [custom claims](https://auth0.com/docs/tokens/concepts/jwt-claims#custom-claims) conforming to a [namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any [scopes supported by the target API](https://auth0.com/docs/scopes/current/api-scopes) (e.g., `read:contacts`). Include `openid` to get an ID Token or to be able to use the [/userinfo endpoint](https://auth0.com/docs/api/authentication#user-profile) to retrieve profile information for the user. Include `offline_access` to get a Refresh Token (make sure that the **Allow Offline Access** field is enabled in the [API Settings](https://manage.auth0.com/#/apis)). Note that this must be URL encoded. |\n| `audience` | The unique identifier of the API your app wants to access. Use the **Identifier** value on the [Settings](https://manage.auth0.com/#/apis) tab for the API you created as part of the prerequisites for this tutorial. Note that this must be URL encoded. |\n\n#### Device code response\n\nIf all goes well, you'll receive an `HTTP 200` response with a payload containing `device_code`, `user_code`, `verification_uri`, and `expires_in`, `interval`, and `verification_uri_complete` values:\n\n```\n{\n  \"device_code\": \"Ag_EE...ko1p\",\n  \"user_code\": \"QTZL-MCBW\",\n  \"verification_uri\": \"https://accounts.acmetest.org/activate\",\n  \"verification_uri_complete\": \"https://accounts.acmetest.org/activate?user_code=QTZL-MCBW\",\n  \"expires_in\": 900,\n  \"interval\": 5\n}\n```\n\n*   `device_code` is the unique code for the device. When the user goes to the `verification_uri` in their browser-based device, this code will be bound to their session.\n    \n*   `user_code` contains the code that should be input at the `verification_uri` to authorize the device.\n    \n*   `verification_uri` contains the URL the user should visit to authorize the device.\n    \n*   `verification_uri_complete` contains the complete URL the user should visit to authorize the device. This allows your app to embed the `user_code` in the URL, if you so choose.\n    \n*   `expires_in` indicates the lifetime (in seconds) of the `device_code` and `user_code`.\n    \n*   `interval` indicates the interval (in seconds) at which the app should poll the token URL to request a token.\n    \n\n### Request device activation\n\nOnce you have received a `device_code` and `user_code`, you must ask the user to go to the `verification_uri` on their laptop or smartphone and enter the `user_code`:\n\n![Auth0 Flows Device Authorization Request, sample page showing two activation methods, user_code and QR code](https://images.ctfassets.net/cdy7uua7fh8z/2WzaeNXIYCVduRuzyRd0Sb/cdb4d59b657166d0a9a555a662b9ed63/request-device-activation.png)\n\nThe `device_code` is not intended for the user directly and should not be displayed during the interaction to avoid confusing the user.\n\n### Request tokens\n\nWhile you are waiting for the user to activate the device, begin polling the token URL to request an Access Token. Using the extracted polling interval (`interval`) from the previous step, you will need to `POST` to the [token URL](https://auth0.com/docs/api/authentication#device-auth) sending along the `device_code`.\n\nTo avoid errors due to network latency, you should start counting each interval after receipt of the last polling request's response.\n\n#### Example request token POST to token URL\n\n*   [cURL](#c126a24d106d4c4fb339751b21ea626e_shell)\n*   [C#](#c126a24d106d4c4fb339751b21ea626e_csharp)\n*   [Go](#c126a24d106d4c4fb339751b21ea626e_go)\n*   [Java](#c126a24d106d4c4fb339751b21ea626e_java)\n*   [Node.JS](#c126a24d106d4c4fb339751b21ea626e_node)\n*   [Obj-C](#c126a24d106d4c4fb339751b21ea626e_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=urn:ietf:params:oauth:grant-type:device_code \\\n  --data 'device_code={yourDeviceCode}' \\\n  --data 'client_id={yourClientId}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=%7ByourDeviceCode%7D&client_id={yourClientId}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=%7ByourDeviceCode%7D&client_id={yourClientId}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=%7ByourDeviceCode%7D&client_id={yourClientId}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n    device_code: '{yourDeviceCode}',\n    client_id: '{yourClientId}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=urn:ietf:params:oauth:grant-type:device_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&device_code={yourDeviceCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=%7ByourDeviceCode%7D&client_id={yourClientId}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=%7ByourDeviceCode%7D&client_id={yourClientId}\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code&device_code=%7ByourDeviceCode%7D&client_id={yourClientId}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=urn:ietf:params:oauth:grant-type:device_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&device_code={yourDeviceCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Token request parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to \"urn:ietf:params:oauth:grant-type:device\\_code\". This is an extension grant type (as defined by Section 4.5 of [RFC6749](https://tools.ietf.org/html/rfc6749#section-4.5)). Note that this must be URL encoded. |\n| `device_code` | The `device_code` retrieved in the previous step of this tutorial. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n\n#### Token responses\n\nWhile you wait for the user to authorize the device, you may receive a few different `HTTP 4xx` responses:\n\nYou will see this error while waiting for the user to take action. Continue polling using the suggested interval retrieved in the previous step of this tutorial.\n\n```\nHTTP/1.1 403 Forbidden\n{\n  \"error\": \"authorization_pending\",\n  \"error_description\": \"...\"\n}\n```\n\n##### Slow down\n\nYou are polling too fast. Slow down and use the suggested interval retrieved in the previous step of this tutorial. To avoid receiving this error due to network latency, you should start counting each interval after receipt of the last polling request's response.\n\n```\nHTTP/1.1 429 Too Many Requests\n{\n  \"error\": \"slow_down\",\n  \"error_description\": \"...\"\n}\n```\n\n##### Expired token\n\nThe user has not authorized the device quickly enough, so the \\`device\\_code\\` has expired. Your application should notify the user that the flow has expired and prompt them to reinitiate the flow.\n\n```\nHTTP/1.1 403 Bad Request\n{ \n  \"error\": \"expired_token\",\n  \"error_description\": \"...\"\n}\n```\n\n##### Access denied\n\nFinally, if access is denied, you will receive:\n\n```\nHTTP/1.1 403 Forbidden\n{\n  \"error\": \"access_denied\",\n  \"error_description\": \"...\"\n}\n```\n\nThis can occur for a variety of reasons, including:\n\n*   the user refused to authorize the device\n    \n*   the authorization server denied the transaction\n    \n*   a configured rule denied access (To learn more, read [Auth0 Rules](https://auth0.com/docs/customize/rules).)\n    \n\n### Authorize user\n\nThe user will either scan the QR code, or else will open the activation page and enter the user code:\n\n![Auth0 Flows Device Authorization prompt directing the user to enter the code displayed on their device](https://images.ctfassets.net/cdy7uua7fh8z/7KRZGb2QcksaEVewXK5bc2/b688b813428f0750ea76b7bcac418bba/enter-user-code__1_.png)\n\nA confirmation page will be shown to have the user confirm that this is the right device:\n\n![Auth0 Flows Device Authorization sample confirmation prompt directing the user to confirm the code](https://images.ctfassets.net/cdy7uua7fh8z/4udH69PJSo20QyK8cwhhtc/193488ee0f689f0724345a40dcdb6478/confirm-device__1_.png)\n\nThe user will complete the transaction by signing in. This step may include one or more of the following processes:\n\n*   Authenticating the user;\n    \n*   Redirecting the user to an Identity Provider to handle authentication;\n    \n*   Checking for active SSO sessions;\n    \n*   Obtaining user consent for the device, unless consent has been previously given.\n    \n\n![Auth0 Flows Device Authorization User authorization prompt directing the user to log in with email and password or with Google or another identity](https://images.ctfassets.net/cdy7uua7fh8z/4UbIdGQMucMhoaXxvFLcki/8c1616d7f28bbd37c253a0145a93a17d/user-auth__1_.png)\n\nUpon successful authentication and consent, the confirmation prompt will be shown:\n\n![Flows - Device Authorization - Congratulations notification for user](https://images.ctfassets.net/cdy7uua7fh8z/7ze8nZU4b0q3YOzLQSJ6nJ/48ef5170035a200cebb821c581cec9bb/user-confirmation__1_.png)\n\nAt this point, the user has authenticated, and the device has been authorized.\n\n### Receive tokens\n\nWhile the user has been authenticating and authorizing the device, the device app has continued to poll the token URL to request an Access Token.\n\nOnce the user has successfully authorized the device, you'll receive an `HTTP 200` response with a payload containing `access_token`, `refresh_token` (optionally), `id_token` (optionally), `token_type`, and `expires_in` values:\n\n```\n{\n  \"access_token\":\"eyJz93a...k4laUWw\",\n  \"refresh_token\":\"GEbRxBN...edjnXbL\",\n  \"id_token\": \"eyJ0XAi...4faeEoQ\",\n  \"token_type\":\"Bearer\",\n  \"expires_in\":86400\n}\n```\n\nAccess Tokens are used to call the Auth0 Authentication API's [`/userinfo` endpoint](https://auth0.com/docs/api/authentication#get-user-info) or another API. (To learn more about Access Tokens, read [Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens).) You will be able to use the Access Token to call `/userinfo` only if you included the `openid` scope. If you are calling your own API, the first thing your API will need to do is [verify the Access Token](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens).\n\nID Tokens contain user information that must be decoded and extracted. (To learn more about ID Tokens, read [ID Tokens](https://auth0.com/docs/secure/tokens/id-tokens).) The `id_token` will only be present in the response if you included the `openid` scope.\n\nRefresh Tokens are used to obtain a new Access Token or ID Token after the previous one has expired. (To learn more about Refresh Tokens, read [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).) The `refresh_token` will only be present in the response if you included the `offline_access` scope and enabled **Allow Offline Access** for your API in the Dashboard.\n\n### Call your API\n\nTo call your API, the application must pass the retrieved Access Token as a Bearer token in the Authorization header of your HTTP request.\n\n*   [cURL](#8962ae4bb088440bb1a3437fa9ad5336_shell)\n*   [C#](#8962ae4bb088440bb1a3437fa9ad5336_csharp)\n*   [Go](#8962ae4bb088440bb1a3437fa9ad5336_go)\n*   [Java](#8962ae4bb088440bb1a3437fa9ad5336_java)\n*   [Node.JS](#8962ae4bb088440bb1a3437fa9ad5336_node)\n*   [Obj-C](#8962ae4bb088440bb1a3437fa9ad5336_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://myapi.com/api \\\n  --header 'authorization: Bearer ACCESS_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://myapi.com/api\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://myapi.com/api\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://myapi.com/api\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://myapi.com/api',\n  headers: {'content-type': 'application/json', authorization: 'Bearer ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://myapi.com/api\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://myapi.com/api\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"myapi.com\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer ACCESS_TOKEN\"\n    }\n\nconn.request(\"GET\", \"/api\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://myapi.com/api\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer ACCESS_TOKEN\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://myapi.com/api\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Refresh tokens\n\nYou have already received a Refresh Token if you've been following this tutorial and completed the following:\n\n*   configured your API to allow offline access\n    \n*   included the `offline_access` scope when you initiated the authentication request through the [authorize endpoint](https://auth0.com/docs/api/authentication/reference#authorize-application)\n    \n\nYou can use the Refresh Token to get a new Access Token. Usually, a user will need a new Access Token only after the previous one expires or when gaining access to a new resource for the first time. It's bad practice to call the endpoint to get a new Access Token every time you call an API, and Auth0 maintains rate limits that will throttle the amount of requests to the endpoint that can be executed using the same token from the same IP.\n\nTo refresh your token, make a `POST` request to the `/oauth/token` endpoint in the Authentication API, using `grant_type=refresh_token`.\n\n#### Example refresh token POST to token URL\n\n*   [cURL](#6f35983f74e84de7ae47fe80d9c24bd6_shell)\n*   [C#](#6f35983f74e84de7ae47fe80d9c24bd6_csharp)\n*   [Go](#6f35983f74e84de7ae47fe80d9c24bd6_go)\n*   [Java](#6f35983f74e84de7ae47fe80d9c24bd6_java)\n*   [Node.JS](#6f35983f74e84de7ae47fe80d9c24bd6_node)\n*   [Obj-C](#6f35983f74e84de7ae47fe80d9c24bd6_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=refresh_token \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'refresh_token={yourRefreshToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=refresh_token&client_id={yourClientId}&client_secret={yourClientSecret}&refresh_token=%7ByourRefreshToken%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=refresh_token&client_id={yourClientId}&client_secret={yourClientSecret}&refresh_token=%7ByourRefreshToken%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=refresh_token&client_id={yourClientId}&client_secret={yourClientSecret}&refresh_token=%7ByourRefreshToken%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'refresh_token',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    refresh_token: '{yourRefreshToken}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=refresh_token\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&refresh_token={yourRefreshToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=refresh_token&client_id={yourClientId}&client_secret={yourClientSecret}&refresh_token=%7ByourRefreshToken%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=refresh_token&client_id={yourClientId}&client_secret={yourClientSecret}&refresh_token=%7ByourRefreshToken%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=refresh_token&client_id={yourClientId}&client_secret={yourClientSecret}&refresh_token=%7ByourRefreshToken%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=refresh_token\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&refresh_token={yourRefreshToken}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Refresh token request parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to \"refresh\\_token\". |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `client_secret` | Your application's Client Secret. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientSecret}/settings). |\n| `refresh_token` | The Refresh Token to use. |\n| `scope` | (Optional) A space-delimited list of requested scope permissions. If not sent, the original scopes will be used; otherwise you can request a reduced set of scopes. Note that this must be URL encoded. |\n\n#### Refresh token response\n\nIf all goes well, you'll receive an `HTTP 200` response with a payload containing a new `access_token`, `id_token` (optionally), token lifetime in seconds (`expires_in`), granted `scope` values, and `token_type`:\n\n```\n{\n  \"access_token\": \"eyJ...MoQ\",\n  \"expires_in\": 86400,\n  \"scope\": \"openid offline_access\",\n  \"id_token\": \"eyJ...0NE\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n## Sample use cases\n\n### Detect device authorization flow use\n\nYou can use Rules to detect whether the current transaction is using the Device Authorization Flow. (To learn more about rules, read [Auth0 Rules](https://auth0.com/docs/customize/rules).) To do so, check the `context` object's `protocol` property:\n\n```\nfunction (user, context, callback) {\n   if (context.protocol === 'oauth2-device-code') {\n      ...\n   }\n \n   callback(null, user, context);\n}\n```\n\n### Sample implementations\n\n*   [Device Authorization Playground](https://auth0.github.io/device-flow-playground/)\n    \n*   [AppleTV (Swift)](https://github.com/pushpabrol/auth0-device-flow-appletv): Simple application that shows how Auth0 can be used with the Device Authorization Flow from an AppleTV.\n    \n*   [CLI (Node.js)](https://gist.github.com/panva/ebaacfe433a8677bdbf458f6e1132045): Sample implementation of a CLI that uses the Device Authorization Flow instead of the Authorization Code Flow. The major difference is that your CLI does not need to host a web server and listen on a port.\n    \n\n## Troubleshoot\n\nTenant logs are created for any interaction that takes place and can be used to troubleshoot issues. To learn more, read [Logs](https://auth0.com/docs/deploy-monitor/logs).\n\n### Error codes\n\n| Code | Name | Description |\n| --- | --- | --- |\n| `fdeaz` | Failed device authorization request |     |\n| `fdeac` | Failed device activation |     |\n| `fdecc` | User canceled the device confirmation |     |\n| `fede` | Failed Exchange | Device Code for Access Token |\n| `sede` | Success Exchange | Device Code for Access Token |\n\n### Limitations\n\nTo use the Device Authorization Flow, devices must:\n\n*   Support Server Name Indication (SNI) when [Custom Domains](https://auth0.com/docs/customize/custom-domains) are used\n    \n*   Have an [Auth0 application type](https://auth0.com/docs/get-started/applications) of **Native**\n    \n*   Have the [Token Endpoint Authentication Method](https://auth0.com/docs/get-started/applications/application-settings) set to **None**\n    \n*   Be [OIDC-conformant](https://auth0.com/docs/get-started/applications/application-settings)\n    \n*   Not be created through [Dynamic Client Registration](https://auth0.com/docs/get-started/applications/dynamic-client-registration)\n    \n\nIn addition, the Device Authorization Flow does not allow:\n\n*   [Social Connections](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers) using [Auth0 developer keys](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/devkeys) unless you are using the [Universal Login experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience).\n    \n*   Query string parameters to be accessed from hosted login page or rules\n    \n\nWe support the full Draft 15, except for confidential Clients. To learn more, read [OAuth 2.0 Device Authorization Grant Draft 15 on ietf.org](https://tools.ietf.org/html/draft-ietf-oauth-device-flow-15).\n\n## Learn more\n\n*   [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth)\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)\n*   [Tokens](https://auth0.com/docs/secure/tokens)\n*   [Logs](https://auth0.com/docs/deploy-monitor/logs)",
  "title": "Call Your API Using the Device Authorization Flow",
  "description": "Learn how to call your API from an input-constrained device using the Device Authorization flow.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/redirect-users-after-login",
  "markdown": "# Redirect Users\n\nYou can return users to specific pages (URLs) within your application after validating their ID Tokens (authentication). To see an example of how this works, try the [React: Login Quickstart](https://auth0.com/docs/quickstart/spa/react).\n\n## Redirect users to callback URLs on the AllowList\n\nBecause callback URLs can be manipulated by unauthorized parties, Auth0 recognizes only URLs on the AllowList set in the **Allowed Callback URLs** field of an [Application's Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings) as valid. To return users to callback URLs on the AllowList, it is necessary for your application to know how to continue the user on their journey.\n\nThere are two methods for doing this:\n\n*   Using cookies and browser sessions\n    \n*   Using `state` parameters\n    \n\nDuring a user's authentication, the `redirect_uri` request parameter is used as a callback URL. This is where your application receives and processes the response from Auth0, and is often the URL to which users are redirected once the authentication is complete. To learn more about how the `redirect_uri` works, see [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth).\n\nYou can use a cookie or the browser session to store a return URL value. This is a simple solution to implement, however, it can cause issues in cases where a cookie does not persist. There are two separate user sessions initiated in this situation. Each serves a separate purpose and requires some consideration to achieve the desired user experience.\n\n*   **Auth0-provided SSO Session**: Auth0 provides a session for enabling [Single Sign On (SSO)](https://auth0.com/docs/authenticate/single-sign-on) to allow your user to maintain an authentication session without being prompted for credentials more than once. This session is maintained by Auth0 and referenced as a cookie bound to your tenant domain (or `CNAME`). There are two [tenant settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings) that determine the length of the Auth0 Session:\n    \n    *   The `idle_session_lifetime` is how long the session will remain alive without interaction.\n        \n    *   The `session_lifetime` is the maximum duration that the session is allowed to remain alive.\n        \n    \n    These settings apply to all applications within your tenant and should be configured to align with the security model that matches your use case.\n    \n*   **Application Session**: Your application must also maintain a concept of a session. Throughout the user session, your application may need to request additional tokens or renew expired ones. You should store these tokens in your application and reference them using an identifier passed back to the browser using a secure cookie.\n    \n\nOnce your user has authenticated with Auth0 it is up to your application to determine how long it persists this session.\n\n## Redirect users to other URLs\n\nSometimes, the callback URL is not necessarily where you want users redirected after authentication. For example, if a user intends to access a protected page in your application, and that action triggers the request to authenticate, you can store that URL to redirect the user back to their intended page after the authentication finishes. Store the desired URL using the following methods:\n\n*   [Redirect users with state parameters](https://auth0.com/docs/secure/attack-protection/state-parameters)\n    \n*   [Redirect users from within rules](https://auth0.com/docs/customize/rules/redirect-users)\n    \n\nChoose the option that works best for your application type and the type of [flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use) that you are using. Create the necessary logic in your application to retrieve the stored URL and redirect your users where you want them to go. The [Auth0 SDKs](https://auth0.com/docs/libraries) also include support for redirect URLs.\n\n## Learn more\n\n*   [Redirect Users with Alternative Logout](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout)\n*   [Understand How Progressive Profiling Works](https://auth0.com/docs/manage-users/user-accounts/user-profiles/progressive-profiling)",
  "title": "Redirect Users",
  "description": "Describes how to redirect users to URLs that have not been added to the AllowList.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/max-age-reauthentication",
  "markdown": "# Force Reauthentication in OIDC\n\nThe `prompt=login` mechanism can be subverted by simply stripping the parameter as it passes through the user agent (browser) and is only good for providing a UX hint to the OpenID provider (OP) in cases when the relying party (RP) wants to display a link like:\n\n**“Hi Josh. Not you? Click here.”**\n\nHowever, you should not rely on it to validate that a fresh authentication took place. To mitigate this, the client must validate that re-authentication has taken place using the `auth_time` claim if re-authentication is why `max_age` was requested. This claim will be included automatically in the ID token when `prompt-login` or `max_age=0` parameters are given in the authentication request.\n\nYou need to pass the `max_age` parameter to the Authorization API [`/authorize` endpoint](https://auth0.com/docs/api/authentication). If you use [Auth0.js](https://auth0.com/docs/libraries/auth0js) or [Lock](https://auth0.com/docs/libraries/lock/lock-authentication-parameters), you can set the parameter in the appropriate options of the library.\n\nHow you implement re-authentication depends on your specific use-case. Make a distinction between simple re-authentication for sensitive operations vs. [step-up](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication) (i.e. multi-factor authentication) for sensitive operations. Both are valid security measures. The former requires the end user to re-enter their password, whereas the latter requires them to use a pre-configured means of multifactor authentication as well.\n\n## Limitations of prompt=login parameters\n\nThe [OIDC spec](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) defines the `prompt=login` parameter that can be used to trigger re-authentication UI (usually a login prompt):\n\nHowever, there is an issue with using this parameter to ensure re-authentication: **the RP has no way to validate that a re-authentication action has taken place**. Let's inspect the traffic to understand why. The flow for an authentication request from the RP is as follows:\n\n```\nhttps://mydomain.auth0.com/authorize?\nclient_id=abcd1234\n&redirect_uri= https://mydomain.com/callback \n&scope=openid profile\n&response_type=id_token\n&prompt=login\n```\n\nUpon successful authentication by the AS, the RP will have an ID token delivered:\n\n```\n{\n  \"nickname\": \"user\",\n  \"name\": \"user@mydomain.auth0.com\",\n  \"updated_at\": \"2019-04-01T14:43:03.445Z\",\n  \"iss\": \"https://jcain0.auth0.com/\",\n  \"sub\": \"auth0|l33t\",\n  \"aud\": \"abcd1234\",\n  \"iat\": 1554129793,\n  \"exp\": 1554165793\n}\n```\n\nThe trusted identity document returned by the AS **has no claims that validate when the last login occurred**. This becomes a problem when the initial authorization request comes in the form of a 302 redirect through the end user’s browser. If a malicious actor wants to skip the re-authentication step requested by the RP, they simply have to remove the `prompt=login` parameter and the RP doesn't know the difference in the fields contained in the ID token.\n\nHere’s a diagram of a simplified implicit flow using the `prompt=login` parameter:\n\n![Force Re-Authentication OIDC Implicit Flow](https://images.ctfassets.net/cdy7uua7fh8z/7lhntbIKJ25JqQ1M9uB6rJ/26163ab92ac6e289e1185bcb50db2a72/simplified-implicit-flow-with-prompt-login.png)\n\nNote that all the end-user has to do is remove the `prompt=login` parameter and the re-authentication step can be skipped:\n\n![Simplified Implicit Flow Remove prompt=login](https://images.ctfassets.net/cdy7uua7fh8z/3hye4mnbcsny7oT0L2kxeq/029a66b8f4f98ee56c5d45a2da617e88/simplified-implicit-flow-remove-prompt.png)\n\nThe token(s) returned from the first flow above will be identical to the token(s) returned from the second flow. The RP has no specification-defined way of verifying that re-authentication has taken place, and therefore cannot trust that a `prompt=login` has actually yielded a re-authentication.\n\n## max\\_age authentication request parameter\n\nUnlike `prompt=login`, the `max_age` authentication request parameter provides a mechanism whereby RPs can positively confirm that re-authentication has taken place within a given time interval. The [OIDC spec](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) states:\n\nThe last sentence in the definition is the most important part. When `max_age` is requested by the RP, an `auth_time` claim must be present in the RP. This means that `max_age` can be used in one of two ways:\n\n*   **To enforce a minimum session freshness**: If an app has a requirement that users must re-authenticate once per day, this can be enforced in the context of a much longer SSO session by providing `max_age` with a value. These are defined in seconds.\n    \n*   **To force an immediate re-authentication**: If an app requires that a user re-authenticate prior to access, provide a value of 0 for the `max_age` parameter and the AS will force a fresh login.\n    \n\nThis requirement is described as follows:\n\n![OIDC re-authentication max_age flow](https://images.ctfassets.net/cdy7uua7fh8z/2IHX6TjuCEcMrPZxoHkC41/11a32321789feee0eac6e71e9c64b307/max-age-flow.png)\n\nNote that the RP receives a token with the proper amount of information to validate whether or not re-authentication has taken place. The RP can now consult the `auth_time` claim in the ID token to determine whether or not the `max_age` parameter it requested was fulfilled. In this way, the `max_age=0` parameter is impervious to the same kind of client tampering that could subvert the `prompt=login` parameter.\n\n## Use auth\\_time claims\n\nWe've established that the OIDC spec provides the `max_age` parameter as a way to positively confirm a re-authentication has taken place, but `prompt=login` does not. This does not present very secure options if you want to force a re-authentication:\n\n*   **prompt=login**: Only include the `prompt` parameter and not validate that the AS actually re-authenticated.\n    \n*   **prompt=login & max\\_age=999999**: Include an arbitrary `max_age` such that an `auth_time` claim is present. You can validate a re-authentication took place, but the parameters get messy.\n    \n*   **max\\_age=0**: Effectively force a login prompt using only the `max_age` parameter. Note that a recent spec update further clarified this parameter, stating it is effectively the same as `prompt=login`. This one is not feasible since it blends what should be a UX parameter with a session maintenance parameter.\n    \n\nInstead, Auth0 has made a choice to send the `auth_time` claim in the ID token when responding to a `prompt=login` request parameter. This means that you have the option use `prompt=login` AND validate that a re-authentication took place.\n\n### auth\\_time validation example\n\nThe following example uses the [passport-auth0-openidconnect](https://github.com/auth0/passport-auth0-openidconnect) module to demonstrate how to validate re-authentication. The first (and simplest) way is to add the `max_age=0` option to the `Auth0OidcStrategy`:\n\n```\nvar strategy = new Auth0OidcStrategy(\n  {\n    domain: process.env.AUTH0_DOMAIN,\n    clientID: process.env.AUTH0_CLIENT_ID,\n    clientSecret: process.env.AUTH0_CLIENT_SECRET,\n    callbackURL: process.env.AUTH0_CALLBACK_URL || 'http://localhost:5000/callback',\n    max_age: 0\n  },\n  function(req, issuer, audience, profile, accessToken, refreshToken, params, cb) {\n    // No extra validation required!\n    return cb(null, profile);\n  });\n```\n\nNotice that no further validation steps are required as the strategy already handles validation of the `max_age` parameter:\n\n```\n// https://openid.net/specs/openid-connect-basic-1_0.html#IDTokenValidation - check 8.\nif (meta.params.max_age && (!jwtClaims.auth_time || ((meta.timestamp - meta.params.max_age) > jwtClaims.auth_time))) {\n  return self.error(new Error('auth_time in id_token not included or too old'));\n}\n```\n\nYou can also use `prompt=login` in the same context, but since the standard does not require an `auth_time` to accompany the ID token response, you must handle the validation manually. So, the strategy constructor would be:\n\n```\nvar strategy = new Auth0OidcStrategy(\n  {\n    domain: process.env.AUTH0_DOMAIN,\n    clientID: process.env.AUTH0_CLIENT_ID,\n    clientSecret: process.env.AUTH0_CLIENT_SECRET,\n    callbackURL: process.env.AUTH0_CALLBACK_URL || 'http://localhost:5000/callback',\n    prompt: 'login'\n  },\n  function(req, issuer, audience, profile, accessToken, refreshToken, params, cb) {\n    const tenSecondsAgo = (Date.now() / 1000) - 10;\n    if (isNaN(profile.auth_time) || profile.auth_time < tenSecondsAgo) {\n      return cb('prompt=login requested, but auth_time is greater than 10 seconds old', null);\n    }\n\n    return cb(null, profile);\n  });\n```\n\nUnlike `max_age=0`, the client must manually perform validation on the `auth_time` parameter. To learn more, read [Use auth\\_time claims](https://auth0.com/docs/authenticate/login/max-age-reauthentication#use-auth_time-claims).\n\n## Known issues\n\nAuth0 can only guarantee that an exchange took place with the upstream identity provider. This may be through the user actually signing in to a third-party identity provider or perhaps the user already had a session and didn't have to sign in again. Either way, Auth0’s exchange with the upstream identity provider will result in an updated `auth_time`.\n\nForcing re-authentication within the upstream identity provider is not something Auth0 supports because not all providers support this.\n\nThe diagram below presents an example flow for a user who chooses to reauthenticate with a federated connection:\n\n![Federated connections do not force re-authentication diagram](https://images.ctfassets.net/cdy7uua7fh8z/8o7GZWQo6LKRTwuYC6dDS/119eeb33dcafcdc5e8d992f284fd5134/federated-connection-flow.png)\n\nThis method assumes you use [database connections](https://auth0.com/docs/authenticate/database-connections). External identity providers may or may not support forcing re-authentication. Using `prompt=login` or `prompt=consent` is generally a way to indicate an external (social) identity provider to reauthenticate a user, but Auth0 cannot enforce this.\n\n## Learn more\n\n*   [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post)\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)",
  "title": "Force Reauthentication in OIDC",
  "description": "Describes how to use the max_age authentication request parameter as a mechanism whereby relying parties can positively confirm that re-authentication has taken place within a given time interval.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication",
  "markdown": "# Adopt OIDC-Conformant Authentication\n\nAuth0 is a [certified OpenID Connect (OIDC) provider](http://openid.net/certification/). As part of Auth0’s efforts to improve security and standards-based interoperability, we roll out new features exclusively on authentication flows that strictly conform to [OIDC specifications](http://openid.net/specs/openid-connect-core-1_0.html).\n\nWe will explain the differences between the OIDC-conformant and legacy pipelines and provide suggestions on how to adapt your existing applications. If you are a developer and/or IT administrator who manages Auth0 integrations in your applications using the [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth). This information is not applicable if you are using SAML or WS-Federation. All authentication flows are described through HTTP requests rather than in the context of any particular language or library implementation.\n\nAll new features target only the OIDC-conformant pipeline, and all legacy Auth0 SDK versions are deprecated, do not receive updates for new features or non-critical security issues, and will eventually be discontinued. In addition, all documentation, libraries, and examples outside of this guide apply to only the OIDC-conformant pipeline. Because of this, we strongly recommend adopting the OIDC-conformant pipeline even if you do not need to leverage any new features or functionality in the immediate future.\n\n## Apply the OIDC-conformant pipeline\n\nDepending on the age of your tenant, you may have different options for applying the OIDC-conformant pipeline.\n\n### New tenants\n\nIf you create a new tenant using the Auth0 Dashboard, the OIDC-conformant pipeline is used by default. This has been a default setting for the Dashboard since early 2019.\n\n### Older tenants\n\nIf you want to force all changes outlined in this guide at the same time for a given application so you can encounter all breaking changes during configuration rather than run time, you must:\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select the desired application.\n    \n2.  Scroll to **Advanced Settings** and go to the **OAuth** tab.\n    \n3.  Enable the **OIDC Conformant** toggle switch and click **Save Changes**.\n    \n\n![Auth0 Dashboard Applications Advanced Settings OAuth Tab](https://images.ctfassets.net/cdy7uua7fh8z/4fD4877KHKW8HWRVwb0YX1/185ebefd15573660ade0c0cce65438a9/dashboard-applications-edit_view-settings_advanced_oauth.png)\n\nIf you want to use the OIDC-conformant pipeline on a per-authentication-request basis and your application needs to call an API with a JWT access token, initiate the request to the [`/social`](https://auth0.com/docs/api/authentication#social) endpoint with an `audience` parameter.\n\nIf you want to use the OIDC-conformant pipeline on a per-authentication-request basis and your application doesn't need to call an API, use the following `audience` parameter:\n\n```\nhttps://{yourDomain}/userinfo\n```\n\n## Differences\n\nEnabling the OIDC-conformant pipeline results in the following changes to the legacy pipeline.\n\n### APIs\n\nApplications and APIs (resources) should be defined as separate Auth0 entities. To learn more, read [OIDC-Conformant Adoption: APIs](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis).\n\n### Access tokens\n\n*   APIs should be secured with access tokens instead of ID tokens. To learn more about the differences, read [Tokens](https://auth0.com/docs/secure/tokens).\n    \n*   A defined set of standard claims about users can be returned in ID Tokens or in the response from `/userinfo`.\n    \n*   Custom claims must conform to a named format. To learn more, read [Create Namespaced Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n    \n*   Responses from `/userinfo` will conform to the OIDC specification, similar to the contents of ID tokens\n    \n*   Scopes can be used to request either standard claims or custom API permissions.\n    \n\nTo learn more, read [OIDC-Conformant Adoptions: Access Tokens](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens).\n\n*   [Authorization Code Flow](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow): Structural differences exist in the authentication request, authentication response, code exchange request, code exchange response, ID token structure, and access token structure.\n    \n*   [Client Credentials Flow](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow): New flow enabled, which allows applications to authenticate as themselves (rather than on behalf of a user) to programmatically and securely obtain access to an API.\n    \n*   [Implicit Flow](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow): Structural differences exist in the authentication request, authentication response, ID token structure, and access token structure. Specifically:\n    \n    *   `response_type=token` only returns an access token. To get an ID token, use `response_type=id_token` or `response_type=token id_token`.\n        \n    *   ID tokens will be signed asymmetrically using RS256.\n        \n    *   Authentication requests made without a nonce parameter will be rejected. To learn more, read [Mitigate Replay Attacks When Using Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow).\n        \n    *   Refresh tokens will no longer be returned when using the Implicit Flow for authentication.\n        \n*   [Resource Owner Password Flow](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-rop-flow): Structural differences exist in the authentication request, authentication response, ID token structure, and access token structure. Specifically:\n    \n    *   the legacy [resource owner endpoint](https://auth0.com/docs/api/authentication#database-ad-ldap-active-) is disabled, which also disables passwordless authentication for embedded login from that endpoint. To [implement Passwordless with embedded login](https://auth0.com/docs/connections/passwordless/guides/embedded-login), you must use the Embedded Passwordless API or our SDKs, depending on your application type.\n        \n    *   the `device` parameter is now considered invalid when requesting a refresh token using the `offline_access` scope.\n        \n\n### Delegation\n\n*   **Deprecated**: [`/delegation`](https://auth0.com/docs/api/authentication#delegation) endpoint, except when used to get third-party API tokens.\n    \n*   OIDC-conformant applications cannot be the source or target of delegation requests.\n    \n\nTo learn more, read [OIDC-Conformant Adoption: Delegation](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation).\n\n### Endpoints\n\n*   **Deprecated**: `/tokeninfo` endpoint\n    \n*   **Disabled**: the [`/oauth/access_token`](https://auth0.com/docs/api/authentication#post-oauth-access_token) endpoint (used for social authentication from native mobile applications).\n    \n*   **Deprecated**: `/ssodata` endpoint\n    \n*   **Deprecated**: [`/delegation`](https://auth0.com/docs/api/authentication#delegation) endpoint except when used to get third-party API tokens.\n    \n\n### Refresh tokens\n\n*   Refresh tokens will no longer be returned when using the Implicit Flow for authentication.\n    \n*   Refresh tokens can be used for confidential applications, but refresh token rotation can increase security for most flows and should always be used for public applications when using the Authorization Code Flow with PKCE. To learn about confidential applications, read [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications). To learn more about refresh token rotation, read, [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation).\n    \n*   When getting new tokens, you should use the `/oauth/token` endpoint.\n    \n*   The `device` parameter is no longer needed when requesting a refresh token using the `offline_access` scope in authentication requests.\n    \n\nTo learn more, read [OIDC-Conformation Adoption: Refresh Tokens](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens).\n\n### Single Sign-on (SSO)\n\n*   SSO can be performed only from Auth0 login pages, which means that you must employ Universal Login.\n    \n*   To determine whether users are logged in via SSO, you must use silent authentication. To learn more, read [Configure Silent Authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication).\n    \n*   **Deprecated**: `/ssodata` endpoint and `getSSOData()` method from `Lock/auth0.js`.\n    \n\nTo learn more, read [OIDC-Conformant Adoption: Single Sign-On](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-sso).\n\n### Additional features\n\n*   Create third-party applications for your APIs and display consent dialogs for authorization. To learn more, read [User Consent and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications).\n    \n*   Restrict user profile information provided to applications upon authentication. To learn more, read [User Profiles](https://auth0.com/docs/videos/get-started-series/learn-user-profiles).\n    \n*   Dynamically register applications. To learn more, read [Dynamic Client Registration](https://auth0.com/docs/get-started/applications/dynamic-client-registration).\n    \n*   [Organizations](https://auth0.com/docs/manage-users/organizations) and their related features become available.",
  "title": "Adopt OIDC-Conformant Authentication",
  "description": "Learn about the effect of the OIDC-conformant application setting on the authentication pipeline.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/professional-services/discover-design",
  "markdown": "# Professional Services: Discover and Design\n\nThe first stage in a successful implementation involves discovering, designing, and architecting your Identity and Access Management solution, and our Discover and Design services are here to help. We work together with your product and engineering teams to **architect an identity solution** for your environment and build an **incremental Go-Live plan** that solves the most-pressing identity problems early. Auth0 Professional Services help your projects quickly reach success by addressing your business objectives in a pragmatic, step-by-step manner.\n\n## Architectural discovery\n\nFocused on discovering the optimum design based on your requirements, Architectural Discovery services provide best practice guidance on topics such as requirements determination, Auth0 Tenant deployment strategies, your use cases, and integration with the software development process in your organization. Engaging with Auth0 Professional Services will help to provide you with a clear understanding of what you need to tackle, and when, in order to fulfill your particular needs. Delivered as part of our Discover, Design, & Implement packages.\n\n## Scenario guidance\n\nGuiding you through your use case scenarios, our Scenario Guidance services help you navigate the possible paths through your discovered use cases in a best practice manner. Covering topics such as OpenID Connect (OIDC) flows, Authorization server capabilities, session management, and Single Sign-On (SSO), engagement with the Auth0 Professional Services team provides visibility into the things you need to prepare you to address what's required. Delivered as part of our Discover, Design, & Implement packages.\n\nIf you have specific support requirements or need more information about the Professional Services we offer, please [contact Auth0 Sales](https://auth0.com/contact-us).\n\n## Learn more\n\n*   [Professional Services: Implement](https://auth0.com/docs/get-started/professional-services/implement)\n*   [Professional Services: Maintain and Improve](https://auth0.com/docs/get-started/professional-services/maintain-improve)",
  "title": "Professional Services: Discover and Design",
  "description": "Describes services to create a foundational set up of your Auth0 platform architecture.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/professional-services/implement",
  "markdown": "# Professional Services: Implement\n\nTo help you accelerate your integration with Auth0, we provide a wide range of implementation services that you can leverage to achieve the product functionality, service connectivity, operational readiness, and/or quality assurance required to get you into production. Auth0 is a unique service that offers developers unrivaled flexibility and extensibility, and our expert Professional Services team knows how to integrate with Auth0 in ways that are the most optimal for the platform and for your environment.\n\n## Programming advisory\n\nFocused on accelerating your development team’s understanding of Auth0 SDKs, APIs, extensibility and integration points, our Programming Advisory services give you the opportunity to engage with our team to get best practice guidance on a wide range of topics. We can provide your development teams with code samples and programming guidance that will help you integrate with Auth0 faster and more effectively, whatever your chosen language or technology stack. Delivered through a number of our Discover, Design, & Implement packages.\n\n## Deployment preparation\n\nProvides for validation on an implemented solution, typically prior to go-live. Our Deployment Preparation services primarily focus on review of integration, including usage of the Auth0 SDKs, APIs, and extensibility as well as setup configuration of Auth0 and Auth0 Tenant. We can provide you with the peace of mind that the systems you deploy will be safe and secure. Delivered via a number of our Discover, Design, & Implement packages.\n\n## Custom implementation\n\nIn addition, our Custom Implementation services -- delivered as part of a number of our Discover, Design, & Implement packages -- provide a wide range of customized implementations to help you accelerate your integration with Auth0. Custom Implementation gives you the opportunity to leverage our implementation services in cases where you need more than the standard out-of-box functionality:\n\n*   **Custom Actions, Rules, Hooks, database scripts, login pages and email templates**: Solve user experience, third-party service integration, or other logical problem within a customer’s Auth0 authentication and authorization workflow. These customizations happen in-product and do not require additional infrastructure to deploy.\n    \n*   **Custom APIs and libraries**: Solve service communication, user experience, or tenant management problem through the use of a custom web services endpoint or code library. Typically deployed on customer or third-party infrastructure.\n    \n*   **Custom utilities**: Solve quality assurance or operations problems that are out-of-band from extending core product functionality, such as performance testing or deployment scripts.\n    \n\n## Learn more\n\n*   [Professional Services: Discover and Design](https://auth0.com/docs/get-started/professional-services/discover-design)\n*   [Professional Services: Maintain and Improve](https://auth0.com/docs/get-started/professional-services/maintain-improve)",
  "title": "Professional Services: Implement",
  "description": "Learn how Auth0 Professional Services can help you implement your Auth0 solution.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/professional-services/maintain-improve",
  "markdown": "# Professional Services: Maintain and Improve\n\nOnce complete, we can work with your teams to review your identity environment, optimize and improve your solution, advise on new features, and answer any questions; all of these services are designed to help you maintain and improve on your Auth0 investment. To support this we recommend scheduling an annual HealthCheck engagement with Professional Services via one of our Maintain and Improve packages.\n\nFor larger customers, we also provide our \"Premier Success\" post-implementation consulting service via our Maintain and Improve packages. This assigns a dedicated Solutions Architect to meet with your team on a weekly, bi-weekly, or monthly basis to provide you with the ongoing assistance a demanding environment can often require.\n\n## Learn more\n\n*   [Professional Services: Discover and Design](https://auth0.com/docs/get-started/professional-services/discover-design)\n*   [Professional Services: Implement](https://auth0.com/docs/get-started/professional-services/implement)",
  "title": "Professional Services: Maintain and Improve",
  "description": "Describes services to help you maintain and improve on your Auth0 investment.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/authentication-methods",
  "markdown": "# Passwordless Authentication Methods\n\nWith Passwordless connections, users can log in without a password. Instead, they can use a variety of other authentication methods. Auth0 Passwordless connections support the following authentication methods:\n\n| Factor | Description |\n| --- | --- |\n| [Email](https://auth0.com/docs/connections/passwordless/authentication-methods/email-otp) | The user is asked to enter their email address, to which Auth0 sends a one-time-use code. The user enters the code into your application. |\n| [Magic Link](https://auth0.com/docs/connections/passwordless/authentication-methods/email-magic-link) | The user is asked to enter their email address, to which Auth0 sends an email with a link in it. The user clicks the link and is directly logged in to your application. |\n| [SMS](https://auth0.com/docs/connections/passwordless/authentication-methods/sms-otp) | The user is asked to enter their phone number, to which Auth0 sends a one-time-use code. By default, Auth0 uses Twilio to send the code, but if you have a custom SMS gateway, you can modify your connection to use that instead. |",
  "title": "Passwordless Authentication Methods",
  "description": "Describes the various authentication methods supported by Auth0 passwordless connections, including email, magic link, and SMS.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/implement-login",
  "markdown": "# Implement Login with Passwordless\n\nAuth0 supports two way of implementing authentication: Embedded Login and Universal Login.\n\nThe industry is aligned in that redirecting to the [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) page is the proper way to implement authentication in all apps, but in the case of Native Applications, sometimes customers prefer to implement Embedded Login for UX reasons.\n\nYou can review the article [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login) for more information to help you decide which solution is best option for your product and customers.\n\n## Learn more\n\n*   [Migrate from Embedded Login to Universal Login](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-embedded-login-to-universal-login)",
  "title": "Implement Login with Passwordless",
  "description": "Describes available login flows to implement via connections ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/passwordless-connection-limitations",
  "markdown": "# Passwordless Connection Limitations\n\nThe type of authentication you want to use depends on which version of Universal Login you configured with your application. If you are using the Universal Login experience, you can set up [passwordless authentication using WebAuthN with Device Biometrics](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics) or use passwordless connections as described below.\n\nYou can set up email or SMS passwordless authentication using the following methods:\n\n1.  Universal Login + passwordless connection parameters\n    \n2.  Classic Login + Lock\n    \n3.  Classic Login + custom UI + Auth0.js\n    \n\nTo learn more about these implementations, read [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms).\n\n### Errors\n\nIf you are using an embedded login, we recommend using custom domains. To learn more, read [Custom Domains](https://auth0.com/docs/customize/custom-domains).\n\n## Considerations\n\n*   You cannot create passwordless users from the Auth0 Dashboard. Create them directly from the [Management API](https://auth0.com/docs/api/management/v2#!/Users/post_users).\n    \n*   Refresh tokens cannot be retrieved when using a passwordless magic link via email, only an OTP.\n    \n\n## Learn more\n\n*   [Passwordless Connections](https://auth0.com/docs/authenticate/passwordless)",
  "title": "Passwordless Connection Limitations",
  "description": "Describes some limitations to using passwordless connections.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics",
  "markdown": "# Configure WebAuthn with Device Biometrics for Passwordless Authentication\n\nYou can configure Universal Login to let users authenticate using [WebAuthn](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn) with Device Biometrics instead of a password.\n\nWebAuthn with Device Biometrics is the most secure and usable authentication factor that's available today, greatly reducing login friction without sacrificing security.\n\n## Prerequisite\n\nTo enable Passwordless with WebAuthn Device Biometrics, you need to:\n\n1.  Make sure the Universal Login experience is enabled and that the HTML for the login page is not customized in [Dashboard > Universal Login](https://manage.auth0.com/#/login_settings).\n    \n2.  Select **Identifier First + Biometrics** in the [Dashboard > Authentication Profile](https://manage.auth0.com/#/authentication-profiles). This will automatically [enable WebAuthn with Device Biometrics](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa) in the Multi-Factor authentication section if it is not enabled yet.\n    \n3.  If you use a [custom database connection](https://auth0.com/docs/authenticate/database-connections/custom-db), ensure **Import Mode** is set to **On.** If it's not, you can run the [getUser script](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user) to the same effect.\n    \n\n## How does it work\n\nUsers that authenticate with username/email and password and have a device that [is capable of using WebAuthn with Device Biometrics](https://webauthn.me/browser-support), are given the option of enrolling their device:\n\n![Example of setting up a Face ID login for specific domain using WebAuthn](https://images.ctfassets.net/cdy7uua7fh8z/1JfsIYEo3O7xmTAxLRwNSs/2f2ba478ff32b0aa86f4f01cd6c0cf3b/2023-01-31_16-34-09.png)\n\nAfter you enable the feature, we provide a few options for users on the Login Faster on This Device dialog box. Users can choose to enroll their device or skip enrollment to reduce the number of times they are prompted:\n\n| Option | Description |\n| --- | --- |\n| `Continue` | Prompts the user for Biometric Factor Enrollment |\n| `Remind me later` | Skips enrollment and prompts for enrollment again in two weeks |\n| `Not on this device` | Does not prompt enrollment for 1 year or as long as the Auth0 cookies are stored in the users' browser |\n\n![Login - webauthn biometrics - log in faster on this device](https://images.ctfassets.net/cdy7uua7fh8z/1w3jwsf0ihbTD0BNudRXN9/6ee65674ffa41e5e9537129bb3f98e79/2023-01-31_16-34-09.png)\n\nIf customers decide to enroll their device, the next time they authenticate from that device they'll be given the option of using their device biometrics or a password:\n\n![Example of using Fingerprint or Face Recognition to login to a domain](https://images.ctfassets.net/cdy7uua7fh8z/4DkewyodXBQ3gncybz7KPI/873d6a3eafb644ee605daa209006d1b3/Docs_Login.png)\n\nWe call this feature 'progressive enrollment', and it's designed to make the transition to WebAuthn-based authentication easy as possible for both developers and users.\n\n## Multi-Factor Authentication\n\nWebAuthn with Device Biometrics allows avoiding requiring another authentication method for performing multi-factor authentication. **WebAuthn with Device Biometrics combines two factors in one**: something you have (the device), and something you are (biometrics) or something you know (the passcode).\n\nThis has several consequences:\n\n*   When you enable MFA in the dashboard, Auth0 will not prompt for MFA if users authenticated with WebAuthn w/Biometrics as first factor.\n    \n*   When MFA is enabled and users create a new account, they will:\n    \n    *   Create a user with a username/password.\n        \n    *   Enroll in MFA, with a non-biometrics authentication method, so they can complete MFA on any device.\n        \n    *   Optionally enroll with Device Biometrics.\n        \n\nThe next time they log in, they can log in with password + another authentication method or with device biometrics.\n\n*   When users authenticate using WebAuthn Biometrics as their only authentication method, the `amr` value in the ID Token will be set to `mfa`.\n    \n*   If you want to enable MFA from our extensibility platform, you’ll be able to consider how users authenticated to decide if they should be prompted for MFA or not. The rule below will only perform MFA if the user did not authenticate with the `webauthn-platform` authentication method:\n    \n\n```\nfunction (user, context, callback) {\n  let authMethods = context.authentication.methods;\n\n  const amr = authMethods.find((method) => method.name === 'webauthn-platform');\n\n  if (!amr) {\n    context.multifactor = {\n      provider: 'any',\n      allowRememberBrowser: false\n    };\n  }\n  return callback(null, user, context);\n}\n```\n\nThis post-login action will have the same effect:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  let authMethods = event.authentication.methods;\n\n  let amr = authMethods.find((method) => method.name === 'webauthn-platform');\n\n   if (!amr) {\n     api.multifactor.enable('any');\n  }\n};\n```\n\n## Device Recognition\n\nAuth0 will use the rules to determine if the device is already enrolled or not, and prompt the user for enrollment. To learn more, read [Device recognition](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa#device-recognition) in the article [Configure WebAuthn with Device Biometrics for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa).\n\nTo avoid user enumeration attacks, Auth0 will only prompt users for biometrics as the first factor if users are logging in from a known device. If not, they'll need to login with the password.\n\nFor example:\n\n*   A user logs-in from Chrome in Windows, and is enrolled with Windows Hello. As part of the enrollment information, Auth0 knows that the user enrolled from a Windows device, and stores a 'known device' to recognize the user agent.\n    \n*   The next time the user logs in from Chrome, they will be prompted to use Windows Hello instead of a password.\n    \n*   If the user later logs in from Firefox in Windows, given the 'known device' cookie is not present, users will need to login with their password. As they are already enrolled with Windows Hello, they won't be prompted to enroll again.\n    \n*   The next time the user logs in from Firefox, they will be prompted to use Windows Hello.\n    \n\nThis will not let attackers know if users have an account or not, or if they used WebAuthn device biometrics to authenticate to the site.\n\n## Webauthn.me\n\nAuth0 maintains [webauthn.me](https://a0.to/webauthme-auth0-docs), which has [detailed information](https://webauthn.me/introduction) about WebAuthn and an up-to-date list of browsers supporting WebAuthn.\n\n## Learn more\n\n*   [Configure Universal Login with Passwordless](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login)\n*   [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms)\n*   [Configure WebAuthn with Device Biometrics for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa)\n*   [FIDO Authentication with WebAuthn](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn)",
  "title": "Configure WebAuthn with Device Biometrics for Passwordless Authentication",
  "description": "Learn how to configure WebAuthn with device biometrics for passwordless authentication.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/sample-use-cases-rules",
  "markdown": "# Sample Use Cases - Rules with Passwordless Authentication\n\nWith [rules](https://auth0.com/docs/customize/rules), you can handle more complicated cases than is possible with [passwordless connections](https://auth0.com/docs/authenticate/passwordless) alone. For instance, you can add extra precautions to further ensure possession of an email address or device.\n\n## Require Multi-factor Authentication for users who are outside the corporate network\n\nLet's say you want to require [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) for any users who are accessing the application using a passwordless connection from outside your corporate network.\n\nUsing a rule, you can check whether a user is authenticating using a passwordless method (`sms`, `email`) and if their session IP falls outside of the designated corporate network, prompt them for a second authentication factor.\n\nTo do this, you would [create the following rule](https://auth0.com/docs/customize/rules/create-rules):\n\n```\nfunction(user, context, callback) {\n  const ipaddr = require('ipaddr.js');\n  const corp_network = \"192.168.1.134/26\";\n  const current_ip = ipaddr.parse(context.request.ip);\n  // is auth method passwordless and IP outside corp network?\n  const passwordlessOutside = context.authentication.methods.find(\n    (method) => (\n      ((method.name === 'sms') || (method.name === 'email')) && \n      (!current_ip.match(ipaddr.parseCIDR(corp_network)))\n    )\n  );\n\n  // if yes, then require MFA\n  if (passwordlessOutside) {\n    context.multifactor = {\n      provider: 'any',\n      allowRememberBrowser: false\n    };\n  }\n  callback(null, user, context);\n}\n```",
  "title": "Sample Use Cases - Rules with Passwordless Authentication",
  "description": "Explore examples using rules with passwordless connections.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/authentication-methods/email-otp",
  "markdown": "# Passwordless Authentication with Email\n\nYou can configure a Passwordless connection to send a one-time password (OTP) to a user through email to complete authentication.\n\nTo learn more, read [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms).\n\n## How it works\n\nWhen a new user receives an OTP and enters it for the first time on your website, their user profile is created on the `email` connection before being authenticated by Auth0.\n\nIf the email address that the OTP was sent to matches an existing user, Auth0 authenticates the user:\n\n### Embedded Login\n\n![Passwordless email workflow diagram with embedded login](https://images.ctfassets.net/cdy7uua7fh8z/3HMLxPTq9eCsq1eR21s0bL/52eaf41d7cf14539ec476b7ee17d64e3/SMS_Email_Flow.png)\n\n### Universal Login\n\n![Passwordless email workflow diagram with universal login](https://images.ctfassets.net/cdy7uua7fh8z/5p3cKrJwmc7MxpQ7pbXsjC/b180e3be9469e634264d2d7f32e32651/Universal_Login.png)\n\n## Configure the connection\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Passwordless](https://manage.auth0.com/#/connections/passwordless), and enable the **Email** toggle.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/6ghwbvjgEt0pyqyJmt871T/12f0110b0f20148eb68a7b267175eb11/connections-passwordless-list.png)\n2.  Select **Email** to open the configuration window, switch to the **Settings** view, and then enter your email's **From**, **Subject**, and **Message** text.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/1seXVjFNAcvKL9KX6fPppQ/0ff58acc4cde37af61b27756d62443fb/dashboard-passwordless-email.png)\n3.  Configure **OTP Expiry** and **OTP Length.**\n    \n    *   Only the last OTP (or link) issued will be accepted. Once the latest one is issued, any others are invalidated. Once used, the latest one is also invalidated.\n        \n    *   Only three failed attempts to input the OTP are allowed. After this, a new code will need to be requested.\n        \n    *   The OTP issued will be valid (by default) for three minutes before it expires.\n        \n    *   If you choose to extend the amount of time it takes for your OTP to expire, you should also extend the length of the OTP. Otherwise, an attacker has a larger window of time to attempt to guess a short code.\n        \n4.  Decide if you want to **Disable Sign Ups**. If you enable this setting, you can allow passwordless access for only existing users, but may expose your application to the threat of user enumeration attacks. To learn more, read [Passwordless Connections Best Practices](https://auth0.com/docs/authenticate/passwordless/best-practices).\n    \n5.  Select **Save**.\n    \n\n### Multi-language support\n\nThe **Message** area supports multiple languages.\n\nTo specify a language, call the [Auth0 Authentication API Get Code or Link endpoint](https://auth0.com/docs/api/authentication#get-code-or-link) and set the value of the `x-request-language` header. When this header is not set, the language is extracted from the `accept-language` header, which is automatically set by the browser.\n\n### Message syntax\n\nThe **Message** area accepts Liquid syntax. You can use this syntax, combined with parameter values, to programmatically construct elements of the message.\n\nFor example, you can reference the `request_language` parameter to change the language of the message:\n\n```\n{% if request_language contains 'dutch' %}\n   Hier is uw verificatie code: {{ code }}\n{% endif %}\n{% if request_language contains 'fr-FR' %}\n   Ceci est votre code: {{ code }}\n{% endif %}\n```\n\nThe following parameters are available when defining the message template:\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `code` | The password to use. |\n| `link` | The generated sign-in link. |\n| `application.name` | The name of the application with which the user is signing up. |\n| `request_language` | The requested language for message content. |\n| `operation` | Indicates when the template has been triggered by an update to a user's email through the API. When triggered, the value is `change_email`, otherwise it is `null`. |\n\nIf the user is logged in through an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview), the following parameters are also available:\n\n*   `organization.id`\n    \n*   `organization.display_name`\n    \n*   `organization.name`\n    \n*   `organization.metadata`\n    \n*   `organization.branding.logo_url`\n    \n*   `organization.branding.colors.primary`\n    \n*   `organization.branding.colors.page_background`\n    \n\nFor more information on these parameters and their values, read the Auth0 Management API [Get organization](https://auth0.com/docs/api/management/v2#!/Organizations/get_organizations_by_id) endpoint.\n\n## Enable applications\n\nSwitch to the **Applications** view, and enable the applications for which you would like to use Passwordless Email.\n\n## Email providers\n\nAuth0 sends emails from its own SMTP provider by default. Auth0's built-in email provider is designed solely for testing purposes and does not support customization of email templates.\n\n[Configure your own SMTP email provider](https://auth0.com/docs/customize/email/smtp-email-providers) to manage, monitor, and troubleshoot your email communications, and customize email templates.\n\nAuth0 supports the following email providers:\n\n*   [Mandrill](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mandrill-as-external-smtp-email-provider)\n    \n*   [Amazon SES](https://auth0.com/docs/customize/email/smtp-email-providers/configure-amazon-ses-as-external-smtp-email-provider)\n    \n*   [Azure Communication Services](https://auth0.com/docs/customize/email/smtp-email-providers/configure-azure-comm-service-as-smtp-email-provider)\n    \n*   [SendGrid](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sendgrid-as-external-smtp-email-provider)\n    \n*   [SparkPost](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sparkpost-as-external-smtp-email-provider)\n    \n*   [Mailgun](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mailgun-as-external-smtp-email-provider)\n    \n*   [Custom SMTP external email provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider)",
  "title": "Passwordless Authentication with Email",
  "description": "Learn how how to use Passwordless connections with the email authentication factor.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/authentication-methods/email-magic-link",
  "markdown": "# Passwordless Authentication with Magic Links\n\nYou can configure a Passwordless connection to send a Magic Link to a user through email to complete authentication.\n\nTo learn more, read [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms).\n\n## How it works\n\nWhen a user opens a Magic Link, Auth0 logs them in directly. It is similar in function to them receiving an email with a one-time password (OTP), returning to your application, and entering the OTP, but without having to actually perform those steps.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/5VsqHQRwtHwT7rx0aiUCP6/5f3a728423cd1114c1c72f1041e969b6/passwordless-email-receive-link.png)\n\n### Limitations\n\nMagic Links are not supported for Universal Login.\n\nWhen using Magic Links with Classic Login, both the initial request and its response must take place in the same browser or the transaction will fail. This is particularly relevant for iOS users, who cannot change their default web browser.\n\nFor example, the user might make the initial request using the Chrome browser, but when the user opens the Magic Link in their email, iOS automatically opens it in Safari (the default browser). If this happens, the transaction will fail.\n\n### Classic Login flow with Magic Links\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/yYsZhaG5uzmVg1MwVCRix/0b735f499987539856fa9a251e2b09d1/Magic_Link_Flow.png)\n\nThe user then clicks the button or link in the email and is automatically signed in to your application.\n\n## Configure the connection\n\n1.  In the Auth0 Dashboard, go to [Authentication > Passwordless](https://manage.auth0.com/#/connections/passwordless), and then enable the **Email** toggle.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/6ghwbvjgEt0pyqyJmt871T/12f0110b0f20148eb68a7b267175eb11/connections-passwordless-list.png)\n2.  Select **Email** to open the configuration window, switch to the **Settings** view, and enter your email's **From**, **Subject**, and **Message** text.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/1seXVjFNAcvKL9KX6fPppQ/0ff58acc4cde37af61b27756d62443fb/dashboard-passwordless-email.png)\n3.  Enter any **Authentication Parameters** you would like to include in the generated sign-in link.\n    \n4.  Decide if you want to **Disable Sign Ups**. If you enable this setting, you can allow passwordless access for only existing users, but may expose your application to the threat of user enumeration attacks. To learn more, read [Passwordless Connections Best Practices](https://auth0.com/docs/authenticate/passwordless/best-practices).\n    \n5.  Select **Save**.\n    \n\n### Multi-language support\n\nThe **Message** area supports multiple languages.\n\nTo specify a language, call the [Auth0 Authentication API Get Code or Link endpoint](https://auth0.com/docs/api/authentication#get-code-or-link) and set the value of the `x-request-language` header. When this header is not set, the language is extracted from the `accept-language` header, which is automatically set by the browser.\n\n### Message syntax\n\nThe **Message** area accepts Liquid syntax. You can use this syntax, combined with parameter values, to programmatically construct elements of the message.\n\nFor example, you can reference the `request_language` parameter to change the language of the message:\n\n```\n{% if request_language contains 'dutch' %}\n   Hier is uw verificatie code: {{ code }}\n{% endif %}\n{% if request_language contains 'fr-FR' %}\n   Ceci est votre code: {{ code }}\n{% endif %}\n```\n\nThe following parameters are available when defining the message template:\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `code` | The password to use. |\n| `link` | The generated sign-in link. |\n| `application.name` | The name of the application with which the user is signing up. |\n| `request_language` | The requested language for message content. |\n| `operation` | Indicates when the template has been triggered by an update to a user's email through the API. When triggered, the value is `change_email`, otherwise it is `null`. |\n\n## Update Classic Login settings\n\nIf you are using Classic Login for your application, you must update the page template to implement Magic Links.\n\n1.  In the Auth0 Dashboard, go to [**Branding > Universal Login > Advanced Options**](https://manage.auth0.com/#/login_settings).\n    \n2.  Switch to the **Login** view, locate the **Default Templates** dropdown, and select **Lock (passwordless).**\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/3PvZFpAUrtaMaq5A2Xi22c/c09dd8a9e34a26a95c574f76128279b5/2022-09-22_14-51-38.png)\n3.  Next, update the `Auth0LockPasswordless` section of code with a new parameter. Add the `passwordlessMethod` to your template.\n    \n    ```\n    passwordlessMethod: 'link',\n    ```\n    \n4.  Select **Save**.\n    \n\nTo learn more about embedded login configuration options, read [Passwordless Authentication with Embedded Login](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login).\n\n## Enable applications\n\nSwitch to the **Applications** view, and enable the applications for which you would like to use Passwordless Email.\n\n## Email providers\n\nAuth0 sends emails from its own SMTP provider by default. Auth0's built-in email provider is designed solely for testing purposes and does not support customization of email templates.\n\n[Configure your own SMTP email provider](https://auth0.com/docs/customize/email/smtp-email-providers) to manage, monitor, and troubleshoot your email communications, and customize email templates.\n\nAuth0 supports the following email providers:\n\n*   [Mandrill](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mandrill-as-external-smtp-email-provider)\n    \n*   [Amazon SES](https://auth0.com/docs/customize/email/smtp-email-providers/configure-amazon-ses-as-external-smtp-email-provider)\n    \n*   [SendGrid](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sendgrid-as-external-smtp-email-provider)\n    \n*   [SparkPost](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sparkpost-as-external-smtp-email-provider)\n    \n*   [Mailgun](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mailgun-as-external-smtp-email-provider)\n    \n*   [Custom SMTP external email provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider)",
  "title": "Passwordless Authentication with Magic Links",
  "description": "Learn how to use Passwordless connections with the magic link authentication factor.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/authentication-methods/sms-otp",
  "markdown": "# Passwordless Authentication with SMS\n\nYou can configure a Passwordless connection to send a one-time password (OTP) to a user through SMS to complete authentication.\n\nTo learn more, read [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms).\n\nAuth0 supports using [Twilio](https://www.twilio.com/) and custom SMS gateways to send OTPs. If you would like to use a custom SMS gateway, read [Set Up Custom SMS Gateway for Passwordless Connections](https://auth0.com/docs/authenticate/passwordless/authentication-methods/use-sms-gateway-passwordless).\n\n## How it works\n\nWhen a new user receives a code and enters it for the first time in your application, their user profile is created on the `sms` connection before being authenticated by Auth0.\n\nIf the phone number that the OTP was sent to matches an existing user, Auth0 authenticates the user:\n\n### Embedded Login\n\n![SMS workflow for passwordless authentication](https://images.ctfassets.net/cdy7uua7fh8z/7A1AOmvvAQXheVt9swOtqM/43742694a9005b99e84975633d481e14/SMS_Email_Flow.png)\n\n### Universal Login\n\n![Passwordless email workflow diagram with universal login](https://images.ctfassets.net/cdy7uua7fh8z/5p3cKrJwmc7MxpQ7pbXsjC/b180e3be9469e634264d2d7f32e32651/Universal_Login.png)\n\n## Configure the connection\n\n1.  In the Auth0 Dashboard, go to [Authentication > Passwordless](https://manage.auth0.com/#/connections/passwordless), and then enable the **SMS** toggle.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/6ghwbvjgEt0pyqyJmt871T/12f0110b0f20148eb68a7b267175eb11/connections-passwordless-list.png)\n2.  Select **SMS** to open the configuration window.\n    \n\n### Configure Twilio settings\n\nYou will need a [Twilio Account SID](https://www.twilio.com/docs/glossary/what-is-a-sid) and a [Twilio Auth Token](https://www.twilio.com/help/faq/twilio-basics/what-is-the-auth-token-and-how-can-i-change-it). These are the Twilio API credentials that Auth0 will use to send an SMS to the user.\n\n1.  Enter your **Twilio Account SID** and **Twilio Auth Token.**\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/7fBmOsNz47vBq8LO8mXxZn/662926055e5c381164c74376a8c96cbc/connections-passwordless-sms_2.png)\n2.  Select the **SMS Source,** and then enter either your **Twilio Messaging Service SID** or a **From** phone number. Users will see what you enter as the sender of the SMS.\n    \n\n### Configure a custom SMS gateway\n\nIf you would like to use your own SMS gateway, you will need to create the passwordless connection and then modify it using the Auth0 Management API. To learn more, read [Set Up Custom SMS Gateway for Passwordless Connections](https://auth0.com/docs/authenticate/passwordless/authentication-methods/use-sms-gateway-passwordless).\n\n### Configure Passwordless SMS settings\n\n1.  In **Message**, enter the body text of the SMS.\n    \n2.  Adjust settings for your **OTP Expiry** and **OTP Length**.\n    \n    *   Only the last one-time password (or link) issued will be accepted. Once the latest one is issued, any others are invalidated. Once used, the latest one is also invalidated.\n        \n    *   Only three failed attempts to input the one-time password are allowed. After this, a new code will need to be requested.\n        \n    *   The one-time password issued will be valid (by default) for three minutes before it expires.\n        \n    *   If you choose to extend the amount of time it takes for your one-time password to expire, you should also extend the length of the one-time password code. Otherwise, an attacker has a larger window of time to attempt to guess a short code.\n        \n3.  Decide if you want to **Disable Sign Ups**. If you enable this setting, you can allow passwordless access for only existing users, but may expose your application to the threat of user enumeration attacks. To learn more, read [Passwordless Connections Best Practices](https://auth0.com/docs/authenticate/passwordless/best-practices).\n    \n4.  Select **Save**.\n    \n\n#### Multi-language support\n\nThe **Message** area supports multiple languages.\n\nTo specify a language, call the [Auth0 Authentication API Get Code or Link endpoint](https://auth0.com/docs/api/authentication#get-code-or-link) and set the value of the `x-request-language` header. When this header is not set, the language is extracted from the `accept-language` header, which is automatically set by the browser.\n\n#### Message syntax\n\nThe **Message** area accepts Liquid syntax. You can use this syntax, combined with parameter values, to programmatically construct elements of the message.\n\nFor example, you can reference the `request_language` parameter to change the language of the message:\n\n```\n{% if request_language contains 'dutch' %}\n   Hier is uw verificatie code: {{ password }}\n{% endif %}\n{% if request_language contains 'fr-FR' %}\n   Ceci est votre code: {{ password }}\n{% endif %}\n```\n\nThe following parameters are available when defining the message template:\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `password` or `code` | The password to use. |\n| `phone_number` | The user's phone number. |\n| `application.name` | The name of the application with which the user is signing up. |\n| `request_language` | The requested language for message content. |\n\nTo learn more about using Liquid, read [Liquid for Designers on GitHub](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).\n\n### Enable applications\n\nSwitch to the **Applications** view, and enable the applications for which you would like to use Passwordless SMS.",
  "title": "Passwordless Authentication with SMS",
  "description": "Learn how to use Passwordless connections with the SMS authentication method.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/implement-login/universal-login",
  "markdown": "# Passwordless Authentication with Universal Login\n\n[Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) is Auth0's implementation of the login flow. Each time a user needs to prove their identity, your applications redirect to Universal Login and Auth0 will do what is needed to guarantee the user's identity. It's the preferred way to implement Passwordless Authentication.\n\nTo implement Passwordless Authentication in Universal Login you need to customize the login page's HTML.\n\n1.  Go to [Dashboard > Branding > Universal Login](https://manage.auth0.com/#/login_settings) and click **Advanced Options**.\n    \n\n![Screenshot: Passwordless Authentication with Universal Login](https://images.ctfassets.net/cdy7uua7fh8z/3KLxperY1ZgUkkD2FMQ6Yw/cb5c9a709bb6ace14669c1fabee1b8f7/manage.auth0.com_dashboard_us_pavo_universal-login_customizations-new.png)\n\n2\\. Click the **Login** tab, then enable the **Customize Login Page** toggle.\n\n![Custom Login](https://images.ctfassets.net/cdy7uua7fh8z/5iwLcz2O100hLuxlKN4rSs/e4f35f8c44516b98b3584d56bcaac12d/manage.auth0.com_dashboard_us_pavo_login_page__2_.png)\n\n3\\. From the Default Template drop-down menu, choose the **Custom Login Form** template. The HTML template will update with code using CSS and the Auth0.js SDK.\n\n4\\. Use HTML and CSS to customize the template to your specifications, and click **Save Changes**. To learn more about how to use the Auth0.js SDK with the **Custom Login Form** template, see [Auth0.js SDK](https://auth0.com/docs/libraries/auth0js).\n\n5\\. Select the **Preview** tab to review your changes. Make sure to select the correct application for which you want to preview the login page.\n\nTo integrate Universal Login in your application, please refer to our [Quickstarts](https://auth0.com/docs/quickstarts), where you'll find complete examples for all application types and popular platforms.\n\n## Learn more\n\n*   [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login)\n*   [Customize](https://auth0.com/docs/customize)",
  "title": "Passwordless Authentication with Universal Login",
  "description": "Describes how to implement Passwordless authentication with Universal Login.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login",
  "markdown": "# Passwordless Authentication with Embedded Login\n\nIf you need to embed the login user interface in your application, you can do it by using our [Embedded Passwordless API](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/relevant-api-endpoints) or our SDKs.\n\nDepending on the kind of application you want to build, you'll need to implement it differently:\n\n*   For Single Page Applications (SPAs) (for example, Angular or React), read [Embedded Passwordless Authentication for Single-page Applications (SPA)](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/spa).\n    \n*   For Native applications (for example, iOS, Android, or desktop applications), read [Embedded Passwordless Login in Native Applications](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/native).\n    \n*   For Regular Web Applications (for example, NodeJS, Java, Rails, or .NET), read [Embedded Passwordless Login in Regular Web Applications](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/webapps).\n    \n\nHowever, embedded logins in web apps with Auth0 use cross-origin authentication, which is not our recommendation. To learn more, read [Cross-Origin Authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication).\n\n## Learn more\n\n*   [Passwordless Connections](https://auth0.com/docs/authenticate/passwordless)\n*   [Passwordless Connections Best Practices](https://auth0.com/docs/authenticate/passwordless/best-practices)\n*   [Using Passwordless APIs](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/relevant-api-endpoints)",
  "title": "Passwordless Authentication with Embedded Login",
  "description": "Describes how to implement Passwordless authentication with Universal Login.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/relevant-api-endpoints",
  "markdown": "# Using Passwordless APIs\n\nPasswordless APIs can be used in two scenarios:\n\n*   When implementing Universal Login and you want to customize the login page using auth0.js to interact with Auth0.\n    \n*   When you want to embed the login flow in your application.\n    \n\nIf you decide to embed login, please make sure you [understand the security implications](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login).\n\nTo learn more about how to implement Passwordless for Universal Login and Embedded login for different scenarios, read [Passwordless Authentication with Universal Login](https://auth0.com/docs/authenticate/passwordless/implement-login/universal-login) or [Passwordless Authentication with Embedded Login](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login).\n\n## Passwordless endpoints\n\n### POST /passwordless/start\n\nThe [POST /passwordless/start](https://auth0.com/docs/api/authentication#get-code-or-link) endpoint can be called to begin the Passwordless authentication process for both Classic Login and Embedded Login.\n\nDepending on the parameters provided to the endpoint, Auth0 begins the user verification process by sending one of the following:\n\n*   A single-use code via email or SMS message\n    \n*   A single-use link via email\n    \n\nThe API call must have the following structure:\n\n```\nPOST https://{yourDomain}/passwordless/start\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientID}\",\n  \"client_secret\": \"{yourClientSecret}\", // For Regular Web Applications\n  \"connection\": \"email|sms\",\n  \"email\": \"{email}\", //set for connection=email\n  \"phone_number\": \"{phoneNumber}\", //set for connection=sms\n  \"send\": \"link|code\", //if left null defaults to link\n  \"authParams\": { // any authentication parameters that you would like to add\n    \"scope\": \"openid\",     // used when asking for a magic link\n    \"state\": \"{yourState}\"  // used when asking for a magic link, or from the custom login page\n  }\n}\n```\n\nIf you use a magic link, users will receive a link generated by the Authentication API. Users will select the link and trigger a call to {`yourAuth0Tenant}.auth0.com/passwordless/verify-redirect`. Auth0 will redirect the user to the application, and the user will be logged in.\n\nIf you use a code, your application will need to prompt for that code, and then you should use the `/oauth/token` endpoint, or the `passwordlessLogin` method in the Auth0.js SDK to exchange that code for authentication tokens.\n\n### POST /oauth/token\n\nIf you are implementing passwordless for Native Applications or Regular Web Applications, you need to use `/oauth/token` to exchange the OTP code for authentication tokens. You cannot use this endpoint from Single Page Applications.\n\nTo achieve this you first need to enable the **Passwordless OTP** grant for your application at [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) in your application's settings under **Advanced Settings** > **Grant Types**.\n\nThe user will receive the OTP code and your Native or Web application will prompt the user for it. When the user enters the code, you can complete the authentication flow by calling the `/oauth/token` endpoint with the following parameters:\n\n```\nPOST https://{yourAuth0Domain}/oauth/token\nContent-Type: application/json\n{\n  \"grant_type\" : \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourAuth0ClientID}\",\n  \"client_secret\": \"{yourClientSecret}\", // only for web apps, native apps don’t have a client secret\n  \"username\":\"<email address>\", // or \"<phone number>\"\n  \"otp\": \"CODE\",\n  \"realm\": \"email\", // or \"sms\" \n  \"audience\" : \"your-api-audience\", // in case you need an access token for a specific API\n  \"scope\": \"openid profile email\" // whatever scopes you need\n}\n```\n\nIf all goes well, Auth0 will return a response similar to the following:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n\"access_token\":\"eyJz93a...k4laUWw\",\n\"refresh_token\":\"GEbRxBN...edjnXbL\",\n\"id_token\":\"eyJ0XAi...4faeEoQ\",\n\"token_type\":\"Bearer\",\n\"expires_in\":86400\n}\n```\n\nYou can then decode the ID Token to get information about the user, or use the Access Token to call your API as normal.\n\n## Using Auth0.js\n\nWhen implementing Passwordless Authentication in Single Page Applications or in a customized Universal Login page, you should [use Auth0.js and the included passwordlessLogin method](https://auth0.com/docs/libraries/auth0js). The implementation is complex, so we recommend that you use the library instead of calling the APIs directly.\n\n## Rate limiting in passwordless endpoints\n\nAuth0 rate limits and attack protection features only consider the IP from the machine that is making the API call. When the API call is made from a backend server, you usually want Auth0 to consider the IP from the end user, not the one from the server.\n\nAuth0 supports specifying an `auth0-forwarded-for` header in API calls, but it is only considered when:\n\n*   the API call is made for a confidential application.\n    \n*   the API call includes the client secret.\n    \n*   the **Trust Token Endpoint IP Header** toggle is on.\n    \n\nFor a complete explanation, read [Avoid Common Issues with Resource Owner Password Flow and Attack Protection](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection).",
  "title": "Using Passwordless APIs",
  "description": "Describes how to implement Passwordless authentication using Auth0 APIs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-business",
  "markdown": "# Business to Business\n\nThis guidance is relevant to **all** project stakeholders. We recommend reading it in its entirety at least once, even if you've already started your journey with Auth0. We provide a Project Planning Guide in PDF format, details about how to get started with each phase of the implementation process, and checklists to help you manage the tasks in each phase.\n\nThere are many different ways Auth0 can be integrated into the B2B IAM project architecture. Auth0's flexibility comprehensively supports many different use cases however your project may not require all of the capabilities provided by Auth0. Knowing what, when, and how best to implement something will help you focus on completing the necessary tasks at the right time.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2B IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/63F0WOPJdVzsPMxV1Xvp8x/7a329487c5e890d8e820f6a48983b46a/B2B_Project_Planning.pdf)\n\n## Multiple Organization Architecture (Multitenancy)\n\nMany B2B platforms implement some form of isolation and/or branding for their customers' organization, and this can add complexity to any Identity and Access Management (IAM) system. If this applies to you, then we recommend you take some time to read through our guidance and best practice advice for this type of environment.\n\n[Multiple Organization Architecture](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture)\n\n## Get started\n\nCustomers using Auth0 for Business-to-Business (B2B) projects typically share a common set of goals and objectives, and in the sections that follow we'll focus on our real-world customer implementation experiences to help you deliver your solution efficiently.\n\n#### Best practice\n\nAuth0 provides recommendations and best practice suggestions in an ad hoc way throughout this guide in panels like this one. You can also obtain detailed guidance regarding specific functionality by speaking with your account representative or a member of our Auth0 [Professional Services](https://auth0.com/docs/services) team.\n\n| **Read** | **To learn...** |\n| --- | --- |\n| [Architecture](https://auth0.com/docs/architecture-scenarios/b2b/architecture) | How to configure your Auth0 tenant architecture affects your B2B IAM implementation. |\n| [Provisioning](https://auth0.com/docs/architecture-scenarios/b2b/provisioning) | About user provisioning functionality and considerations for your B2B IAM implementation. |\n| [Authentication](https://auth0.com/docs/architecture-scenarios/b2b/authentication) | How authentication works in your B2B IAM implementation. |\n| [Branding](https://auth0.com/docs/architecture-scenarios/b2b/branding) | How to configure Auth0 items to reflect your brand and desired user experience. |\n| [Deployment Automation](https://auth0.com/docs/architecture-scenarios/b2b/deployment) | How Auth0 tooling helps to automate tenant deployment. |\n| [Quality Assurance](https://auth0.com/docs/architecture-scenarios/b2b/quality-assurance) | About quality assurance considerations for your B2B IAM implementations. |\n| [Profile Management](https://auth0.com/docs/architecture-scenarios/b2b/profile-management) | About user profile management planning considerations for your B2B IAM implementation. |\n| [Authorization](https://auth0.com/docs/architecture-scenarios/b2b/authorization) | About user authorization and related planning considerations for your B2B IAM implementation. |\n| [Logout](https://auth0.com/docs/architecture-scenarios/b2b/logout) | About user logout planning considerations for your B2B IAM implementation. |\n| [Operations](https://auth0.com/docs/architecture-scenarios/b2b/operations) | How to operationalize your Auth0 tenant environments. |\n| [Launch Preparation](https://auth0.com/docs/architecture-scenarios/b2b/launch) | About launch preparation considerations for your B2B IAM implementation. |\n\n## Implementation planning checklists\n\nUse the links below to download a spreadsheet that includes tasks for each phase of a Software Development Lifecycle (SDLC) project.\n\n[Analyze Checklist](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Analyze-Checklist.xlsx)\n\n[Design Checklist](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Design-Checklist.xlsx)\n\n[Build Checklist](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Build-Checklist.xlsx)\n\n[Test Checklist](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Test-Checklist.xlsx)\n\n[Deploy Checklist](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Deploy-Checklist.xlsx)\n\n[Monitor Checklist](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Monitor-Checklist.xlsx)",
  "title": "Business to Business",
  "description": "Explains the architecture scenario B2B IAM with a SAAS application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/business-to-consumer",
  "markdown": "# Business to Consumer\n\nThis guidance is relevant to **all** project stakeholders. We recommend reading it in its entirety at least once, even if you've already started your journey with Auth0. We provide a Project Planning Guide in PDF format, details about how to get started with each phase of the implementation process, and checklists to help you manage the tasks in each phase.\n\nThere are many different ways Auth0 can be integrated into the CIAM project architecture. Auth0's flexibility comprehensively supports many different use cases however your project may not require all of the capabilities provided by Auth0. Knowing what, when, and how best to implement something will help you focus on completing the necessary tasks at the right time.\n\n## Project Planning Guide\n\nWe provide planning guidance in PDF format that you can download and refer to for details about our recommended strategies.\n\n[B2C IAM Project Planning Guide](https://assets.ctfassets.net/cdy7uua7fh8z/3er1aEQ7Ul0q3c9leJWczR/b1f18b4c16abb7e78b01e4eb2b52bb8e/B2C_Project_Planning.pdf)\n\n## Get started\n\nCustomers using Auth0 for Business-to-Consumer (B2C) projects typically share a common set of goals and objectives, and in the sections that follow we'll focus on our real-world customer implementation experiences to help you deliver your solution efficiently.\n\n### Best Practice\n\nAuth0 provides recommendations and best practice suggestions in an _ad hoc_ way throughout this guide in panels like this one. You can also obtain detailed guidance regarding specific functionality by speaking with your account representative or a member of our Auth0 [Professional Services](https://auth0.com/docs/professional-services) team.\n\n| **Read** | **To learn...** |\n| --- | --- |\n| [Architecture](https://auth0.com/docs/architecture-scenarios/b2c/architecture) | How to configure your Auth0 tenant architecture affects your B2C IAM implementation. |\n| [Provisioning](https://auth0.com/docs/architecture-scenarios/b2c/provisioning) | About user provisioning functionality and considerations for your B2C IAM implementation. |\n| [Authentication](https://auth0.com/docs/architecture-scenarios/b2c/authentication) | How authentication works in your B2C IAM implementation. |\n| [Branding](https://auth0.com/docs/architecture-scenarios/b2c/branding) | How to configure Auth0 items to reflect your brand and desired user experience. |\n| [Deployment Automation](https://auth0.com/docs/architecture-scenarios/b2c/deployment) | How Auth0 tooling helps to automate tenant deployment. |\n| [Quality Assurance](https://auth0.com/docs/architecture-scenarios/b2c/quality-assurance) | About quality assurance considerations for your B2C IAM implementations. |\n| [Profile Management](https://auth0.com/docs/architecture-scenarios/b2c/profile-management) | About user profile management planning considerations for your B2C IAM implementation. |\n| [Authorization](https://auth0.com/docs/architecture-scenarios/b2c/authorization) | About user authorization and related planning considerations for your B2C IAM implementation. |\n| [Logout](https://auth0.com/docs/architecture-scenarios/b2c/logout) | About user logout planning considerations for your B2C IAM implementation. |\n| [Operations](https://auth0.com/docs/architecture-scenarios/b2c/operations) | How to operationalize your Auth0 tenant environments. |\n| [Launch Preparation](https://auth0.com/docs/architecture-scenarios/b2c/launch) | About launch preparation considerations for your B2C IAM implementation. |\n\n## Implementation planning checklists\n\nUse the links below to download a spreadsheet that includes tasks for each phase of a Software Development Lifecycle (SDLC) project.\n\n[Analyze Checklist](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Analyze-Checklist.xlsx)\n\n[Design Checklist](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Design-Checklist.xlsx)\n\n[Build Checklist](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Build-Checklist.xlsx)\n\n[Test Checklist](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Test-Checklist.xlsx)\n\n[Deploy Checklist](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Deploy-Checklist.xlsx)\n\n[Monitor Checklist](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Monitor-Checklist.xlsx)",
  "title": "Business to Consumer",
  "description": "Explains the architecture scenario B2C IAM with an eCommerce or SAAS application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/b2e",
  "markdown": "# Business to Employees\n\nThe B2E (Business to Employees) scenario involves applications that are used by employee users. These are applications that are targeted toward users who are typically acting on behalf of an organization such as an employer, a university, or a group in which they are a member, as opposed to acting on their own behalf.\n\nSuch applications that are custom written by the organization may use the OIDC/OAuth protocol to externalize authentication whereas those that have been purchased will often use the SAML protocol. In either case, the enterprise will typically want to use some form of Enterprise connection, such as a SAML Identity Provider, ADFS, Google Workspace, Azure AD or a directory service such as AD or OpenLDAP, and less frequently, a custom DB, for authentication of enterprise users.\n\nFor a business that is creating or integrating applications with Auth0 for a B2E environment, there are several requirements that are common for this scenario. This guide will summarize the most common requirements for B2E applications and explain the Auth0 features which help meet each need.\n\n## Enterprise providers\n\nMost businesses already have a corporate identity repository which has information on all the employee users and user profile information. It may also contain information on partners and contractors. A common requirement for the B2E scenario therefore, is to allow such users to log in via [Auth0 Enterprise connections](https://auth0.com/docs/connections/identity-providers-enterprise) such as SAML2 providers, ADFS, Google Workspace, Azure AD or an on-premise corporate directory service. This is attractive to users because it allows them to avoid creating yet another username and password for each application and instead leverage the same login credential across all their enterprise applications.\n\nThis is especially attractive to security interests within the company because user credentials are only exposed to the identity stack instead of to each application. Furthermore, this architecture allows the business to retain control over access to applications because the enterprise identity provider provides a single shutoff point. If a user leaves the organization, administrators can simply disable the user’s account in the corporate identity provider and the user can no longer log in to any of the applications using that identity provider.\n\nAuth0 makes it easy to enable login via a wide variety of enterprise providers with just a few simple configuration steps.\n\n## Groups and roles\n\nWith a lot of users, you may set up groups and roles to manage access and privileges. Often, these are stored and administered in a directory service.\n\nAuth0 can get user attributes, like groups and roles, from a directory service or enterprise identity provider during authentication. You can then make the attributes available through tokens returned to the application or with the Auth0 Management API.\n\n## Profile translation\n\nSometimes a directory or identity provider returns attributes in one format, but your application uses another format. Using Auth0's [Rules](https://auth0.com/docs/rules/current/metadata-in-rules), you can [map and translate user profile attributes](https://auth0.com/rules/saml-attribute-mapping). You can even translate between OIDC/OAuth, SAML, WS-Fed, and LDAP.\n\nFor example, you retrieve attributes in SAML assertion format from a SAML Identity Provider. With a rule you can then translate the attributes to custom claims in an ID Token for an OIDC/OAuth application.\n\nYou can also map SAML attributes to the Auth0 user profile from the dashboard. To do this, go to [Connections > Enterprise > SAMLP Identity Provider](https://manage.auth0.com/#/connections/enterprise), select your SAML connection, and set your attribute mappings in the **Mappings** tab.\n\n## Extensibility with augmented user profiles\n\nYou may want to enrich user profiles with attributes or data retrieved from other services. For example, you might receive an address or phone number and wish to translate that into a geographic region. [Auth0 Rules](https://auth0.com/docs/rules) enable you to write small snippets of code that execute during the authentication transaction. This lets you execute logic or call other services for user information, then add [user metadata](https://auth0.com/docs/users/concepts/overview-user-metadata) to the Auth0 user profile and optionally the resulting tokens sent to your applications.\n\n## Single Sign-on\n\nIf you have several internal applications, you can set up [Single Sign-on (SSO)](https://auth0.com/docs/sso) across them so users only have to log in once.\n\nAuth0 supports integration with applications that externalize authentication using industry standard identity protocols:\n\n*   OIDC/OAuth\n    \n*   SAML2\n    \n*   WS-Fed\n    \n\nAfter some configuration, all your applications can leverage your enterprise identity provider. In this setup, Auth0 is the broker between your applications and enterprise identity providers.\n\nNow when a user signs in to one application, they can access other applications integrated with Auth0 without having to log in again. This will be true until their SSO session expires. You should configure the SSO session length within Auth0 to meet security policies.\n\n## Single Sign-on integrations\n\nYou can also integrate purchased applications with Auth0 for Single Sign-on (SSO). Auth0 provides [pre-built integrations](https://auth0.com/docs/integrations/sso) for applications such as:\n\n*   Salesforce\n    \n*   Zendesk\n    \n*   Slack\n    \n*   New Relic\n    \n\n## Branding\n\nBranding is an important part of any application. Your logo, colors and styles should be consistent in all parts of the application. You can [customize](https://auth0.com/docs/libraries/custom-signup) the login, signup, and error pages displayed by Auth0 so it matches your application. Add your own logo, text, and colors. There's also I18N/L10N support for global rollouts. [Emails for verification or password resets](https://auth0.com/docs/email/templates) are customizable too.\n\n[Login screens](https://auth0.com/docs/libraries/lock/v11/ui-customization) should appear to come from your application’s branded domain name. To maintain consistency, you can define a [custom domain name](https://auth0.com/docs/custom-domains) for the login screen displayed by Auth0.\n\n## Multi-factor authentication\n\nInternal or employee applications often deal with sensitive content. [Multi-factor authentication (MFA)](https://auth0.com/docs/mfa) helps protect your data and applications. Auth0 provides a variety of ways to implement MFA. And for more flexibility, you can use Rules to turn it on only for the applications or user groups that need it.\n\n## Logs export\n\nNeed to analyze logs or store them long-term? Auth0 provides extensions to [export logs to external tools](https://auth0.com/docs/logs) for analysis and retention. You can also retrieve log data with the Management API.\n\n## Audit\n\nCompanies have many uses for logs data, one of which is audit reports. Auth0 captures a variety of data in log files, which may be useful for your audit reporting. The logs have information on authenticated users, the identity provider used, and when significant administrative changes are made in the Auth0 dashboard.\n\nLog events each have an event type. You can use event types as filters when querying log data with the Management API, or when exporting logs to log analysis tools.\n\n## Monitoring\n\nMonitoring the infrastructure and services that your applications depend on is critical. Auth0 provides an [Auth0 Status](https://status.auth0.com/) page you can subscribe to.\n\nAuth0 makes every effort to minimize outages, but if there is any disruption to service, it will appear on the status page. To support requirements for root cause analysis documentation after a disruption, Auth0 conducts internal analysis and publishes the results on the disruption notice when the analysis is completed.\n\n## Attack Protection\n\nAn unfortunate part of modern life on the internet is hackers. Hackers are constantly trying to find a way into applications. For example, they may try to log in using common passwords. Or they may use credentials stolen from elsewhere, hoping that users re-used the same passwords at other sites.\n\nAuth0's [Attack Protection](https://auth0.com/docs/anomaly-detection) detects these situations for Auth0 Database connections and provides options for how to respond. Turn on Attack Protection and configure the response options so you can respond appropriately if such an event occurs.\n\n## Github Deployment\n\nDo you manage a lot of your application code in Github? You can deploy code for Actions, Rules, Hooks, or custom database access from there with Auth0's [Github Deployment extension](https://auth0.com/docs/extensions/github-deploy).\n\nIf you have a full continuous integration/continuous deployment pipeline, use the [Auth0 Deploy CLI tool](https://github.com/auth0/auth0-deploy-cli) for greater flexibility.",
  "title": "Business to Employees",
  "description": "Explains the architecture scenario of B2E with a large organization that wants to extend their existing enterprise directory service.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture",
  "markdown": "# Multiple Organization Architecture\n\nThere are multiple use case scenarios where users end up belonging to third-party organizations that have signed up for the services you provide. Such users can be employees of some third-party organization, customers, or a combination of both. Whatever the situation, guidance has been created to help you design your integration with Auth0; it should provide you with a high-level overview of the common use cases experienced with respect to multi-tenant applications.\n\nFor example, B2B applications strive to create a pleasant user experience for the employees/customers of the businesses they serve. To accomplish this, service providers in B2B environments often allow some branding to be added to their service for each of the organizations that use it. For example, let’s say you work for AwesomeSaaS (an SaaS software company) and your company uses Human0, an HR application for managing benefits and other HR functions. You would access your HR app at [`https://awesomesaas.human0.com`](https://travel0.human0.com/), and when you log in, the login experience would be customized to display the AwesomeSaaS logo and use AwesomeSaaS colors.\n\nAs a B2B service provider designing an integration with Auth0, you will need to consider whether or not your customers (i.e., third-party organizations) will allow users from other organizations to log in to their instance of the application, and whether those users should be shared between organizations or isolated to one organization in particular.\n\nLet’s start by introducing a couple of examples of applications that will help highlight the various use case scenarios. Travel0 is a fictitious company that offers online travel agency services. Travel0 has several applications, but for the purpose of this exercise, we’ll focus on the two applications that are marketed directly to organizations:\n\n*   **Travel0 Corporate Booking**: Provides organizations with an online application where their employees can log in to and book work-related travel. Organizations that are customers of this application include:\n    \n    *   **Hoekstra & Associates**: A small law office with just a few employees. They do not have an IT department and don’t have the time or capacity to learn how to set up a corporate Identity Provider (IdP).\n        \n    *   **Gupta & Smith Law**: A larger law office, but they also do not have an IT department and don’t have the time or capacity to learn how to set up a corporate IdP.\n        \n    *   **MetaHexa Bank**: A large finance organization. They provide banking and insurance services and have their own IdP.\n        \n    *   **Many Student University (MSU)**: A large university with several campuses, where each campus has its own IdP.\n        \n*   **Travel0 Adventure Management**: Allows organizations to create and market adventures (e.g., whitewater rafting, horseback riding, zip line). It allows guides (who are freelance, or employees of some third-party travel/event organization) to sign up for and be scheduled to lead adventures. Organizations that are customers of this application include:\n    \n    *   **AdventureZ**: A large tour/event organizer. They have their own IdP that they use for their employees. They rarely need freelancers because they have enough guides on staff, some of which only work during busy times. They also facilitate their guides’ ability to do freelance work for other companies.\n        \n    *   **Rocky Mountain High Adventures**: A new group entering the market for the first time. The cofounders run tours; they reach out to freelancers for help mostly during busy times.\n        \n    *   **Suzie’s Rafting and Ziplines**: This company has been around for a long time. They have a staff of guides that handles most of their events, but they also reach out to freelancers when busy.\n        \n\n## Terminology\n\nLet’s take a step back for a moment and clarify some terminology. This is important because many of the words used in the provided guidance can be overloaded to mean a number of different things. We’ll be diligent in our use of terms in an attempt to avoid confusion, and we recommend that you take a moment to read through each definition so that it’s clear when reading through the examples who is fulfilling what role:\n\n*   **Auth0 Tenant** (otherwise known as **Authorization Server**)**:** Tenant that you create in Auth0. It is an instance of an Authorization Server and represents one or more user domains.\n    \n*   **Auth0 Organizations:** Refers to the Auth0 Tenant feature designed to support organizations. An instance of an [Auth0 Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview) will typically refer to a specific customer of yours.\n    \n*   **Employee**: Person who is part of your company. They will typically have an account in your Identity Provider (IdP) and may need admin access to one or more Organization Tenant instances. Your customers may have users who are in turn employees of their organizations, but we will refer to those individuals using the more general term of Organization Users. We will only use the term Employee to refer to Employees of your company.\n    \n*   **Identity Provider (IdP)**: Service, such as Auth0, that manages authentication of users, and optionally, provides user profile information and/or credentials management. The service may also provide delegation of credential validation and profile management via the use of a third-party IdP (such as Azure AD, Google, Facebook, etc.)\n    \n*   **Organization: T**hird-party company that is a customer of yours. You may refer to an organization instance that is created for your application as a tenant; we will refer to it as an Organization Tenant to avoid confusing it with an Auth0 Tenant. \n    \n*   **Organization Tenant:** Refers to a tenant that may be created for your customer as part of your application subscription/provision. This is different from an Auth0 Tenant. \n    \n*   **Organization User**: Person who is logging in to the application as a member of an Organization. This may be an employee (of the Organization) or a customer. Any user referenced in an organization context can be considered an Organization User.\n    \n\n## User Isolation\n\nNow that we’ve covered some terminology, let’s get back to discussing how we might determine the type of application we’re providing when it comes to organizational user isolation. There are essentially two fundamental approaches regarding how/where each of these users can be stored: [users isolated by organization](#users-isolated-by-organization) and [users shared between organizations](#users-shared-between-organizations).\n\n![Architecture Scenarios - Multitenancy - Diagram - Multiple organizations shared decision](https://images.ctfassets.net/cdy7uua7fh8z/5PIUlQgG5PmnzaWjtD6J5t/9956e135a587611c234ece90ab7e3af4/multiple-org-shared-decision.png)\n\nThe flow diagram above outlines the decision-making process. You should also consider whether [administrative-type access](#administrative-access-to-organizations) is required for an organization instance. This may be for an employee of your organization who, say, acts as an administrator for one or more organizations, or for some other third party that’s providing help desk services or the like.\n\nIn the following sections, we’ll dive into the detail associated with each approach to organizational user isolation. We recommend that you pay close attention to the atypical scenarios associated with each (i.e., where users need access to more than one organization) because these types of use cases will often help determine which approach more closely maps to your requirements.\n\n### Users isolated by Organization\n\nEach organization has its own set of users, and users cannot and should not be able to access other organizations. If they attempt to do so, they should be rejected as unauthorized. Keep in mind that you can force your users to create a separate account for each organization, even if they belong to more than one. As a person, they would be considered to be two different users.\n\nIn this scenario, a user is tied directly to the organization to which they belong or have access. Users have two options for how they log in: a) they create credentials in identity storage provisioned for the appropriate organization (i.e., UserID/Password Database Connection in your Auth0 Tenant), or b) they log in using their own organization’s IdP. In this use case, it would not make sense for a user to be part of multiple organizations, and even if they were, we would rather they create a separate identity for each. Using Travel0 Corporate Booking as an example, the diagram below shows how this would look:\n\n![Architecture Scenarios - Multitenancy - Diagram - Isolated users](https://images.ctfassets.net/cdy7uua7fh8z/42jUyjrrYapzZaxEsCTvw6/3722ece70744d0853a39e0c51fe6c380/isolated-users.png)\n\nSally is a typical user: she is an employee of MetaHexa Bank, and she can only access MetaHexa Bank’s instance of Travel0 Corporate Booking.\n\nPat, on the other hand, is an atypical user. Pat is a freelance paralegal, so she works for both Hoekstra & Associates and Gupta & Smith Law; she will access the Travel0 Corporate Booking instance for each using a separate user identity. There are many reasons this makes sense, not least for reducing accidental error situations by forcing Pat to create two separate personas--one for each law firm. When Pat books travel, she must log in separately to the specific organization instance in order to make the booking.\n\nPat either doesn’t exist for your company or is an example of a rare use case scenario. However, she illustrates the kind of thing that needs to be considered when determining user isolating requirements: if you want users to be isolated to the organization with which they’re associated then you’re making a decision that necessitates the creation of separate user identities. In this case, there is one identity for Pat when accessing the Hoekstra & Associates instance of Travel0 Corporate Booking, and a separate one for accessing Gupta & Smith Law’s instance of Travel0 Corporate Booking. \n\n### Users shared between Organizations\n\nA user may belong to more than one organization, and it would be convenient if that user did not have to have a separate identity/account as they navigate from one organization to another. Organizations can still use their own IdP in such cases. \n\n![Architecture Scenarios - Multitenancy - Diagram - Shared users](https://images.ctfassets.net/cdy7uua7fh8z/3z920KV1sDj6v0xUM1PLy4/fb82e123670dd1f0abd789f5b0d59ca1/shared-users.png)\n\nIn this scenario, a user is no longer tied directly to the organization to which they belong or have access. Users now have two options for how they log in: a) they create credentials in identity storage provisioned generally (i.e., in a single UserID/Password Database Connection in your Auth0 Tenant), rather than in any identity store specifically allocated in your Auth0 Tenant for the organization, or b) they log in using their own organization’s IdP. Once a user has an identity, they are then given permission to access each of the organizations to which they should have access. This could mean access to just one organization, or it may mean they have access to more than one organization. Users will need to understand that when prompted to log in, they can use the same credentials to access each organization’s instance. Using Travel0 Adventure Management as an example, the diagram above shows how this would look.\n\nJonno is a typical user. Jonno is an employee of Suzie’s Rafting and Ziplines. Jonno is only able to log in to the instance of Travel0 Adventure Management provisioned to create and guide adventures for Suzie’s Rafting and Ziplines. Jonno’s credentials are either stored in a Database Connection associated with Travel0’s Auth0 Tenant or in Suzie’s Zipline and Rafting’s IdP (depending on whether they want to manage their user identities or not).\n\nSumana is an atypical user. Sumana is an employee of AdventureZ, but as AdventureZ also coordinates freelance opportunities for the smaller guide companies during high peak times, Sumana has been invited to join Rocky Mountain High Adventures as a  freelancer. Sumana is authorized to log in to both AdventureZ and Rocky Mountain’s instances of Travel0 Adventure Management. However, because she has never been invited as a guide to Suzie’s Rafting and Ziplines, she is not authorized to access that instance.\n\nSumana needs to have the same identity for both organizations because guiding involves the use of a rating system, and Sumana’s ratings need to carry over and be combined between the organizations with which she works. Sumana’s credentials, like Jonno’s, are either stored in a Database Connection associated with Travel0’s Auth0 Tenant, or in AdventureZ’s IdP (depending on whether AdventureZ wants to manage user identities or not). Where her credentials are stored has no bearing on the organization instances to which she has access.\n\n### Administrative access to Organizations\n\nThere are occasions when you will need to provide administrative access across your organizations. Typically, this will be for administrative tasks outside of user Profile/Account management (as described in [Profile Management](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations/profile-management)), and you may need to provide access to your employees as well as to third parties.\n\nFrom an employee perspective, the Auth0 Dashboard can be configured via [role-based access control](https://auth0.com/docs/get-started/manage-dashboard-access/feature-access-by-role), which will allow you to define specific roles across your Auth0 Tenant deployment as a whole. You can even leverage your own corporate IdP to provide Auth0 Tenant Administrator authentication for your employees, as well as extended Tenant Administrator access to trusted third-parties.\n\nFor other administrative access you will typically want to build your own API and or application, which you will use in conjunction with the Auth0 Management API. Providing administrative access to your Auth0 Tenant via the Auth0 Dashboard for a wide range of users is not recommended. While building such an application/API is beyond the scope of this document, it’s recommended that you seek help from [Auth0 Professional Services](https://auth0.com/docs/get-started/professional-services) before embarking on such an endeavor.\n\n## Users isolated by Organization\n\nApplications that have users isolated per organization typically support three different use cases. For the examples in this section, we'll use the Travel0 Corporate Booking application scenarios described in our introduction. Travel0 is the Auth0 customer.\n\n*   **Organizations that either don’t have their own IdP or don’t know how to use it**. These tend to be smaller organizations that don’t have an IT department available to configure Single Sign-On (SSO) with the organization’s Identity Provider (IdP) or else don’t have an organization IdP fit for the task. In our [Travel0 Corporate Booking](https://docs.google.com/document/d/1uAWY658kvUj3jwqkWEbPv9zNmCeH4-navbkYB-P_eGw/edit?pli=1#bookmark=id.6bbihuutc8mr) example, Hoekstra & Associates is such an organization.\n    \n*   **Organizations that prefer to configure their own IdP** so that their employees don’t have to create a new set of credentials for your application. Most organizations fall into this category. In our [Travel0 Corporate Booking](https://docs.google.com/document/d/1uAWY658kvUj3jwqkWEbPv9zNmCeH4-navbkYB-P_eGw/edit?pli=1#bookmark=id.6bbihuutc8mr) example, MetaHexa Bank is such an organization.\n    \n*   **Organizations that require multiple authentication options**. Examples of this type of organization include those that frequently acquire new companies, organizations like schools that allow staff and parents to log in to the same application, and organizations that invite partners or customers to log in to their application instance (i.e., B2B2C organizations). In our examples, Many Student University (MSU) would be such an organization.\n    \n\nFor the first two types of organizations, the solution tends to be fairly straightforward. These organizations are considered Single IdP organizations, and the approach is almost always the same. To learn more, read [Single Identity Provider Organizations](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations).\n\nOrganizations that have more than one IdP for the organization trend toward a higher order of intricacy, but there are a few approaches that can minimize complexity. To learn more, read [Multiple Identity Provider Organizations](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/multiple-idp-orgs).\n\n## Learn more\n\n*   [Single Identity Provider Organizations](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/single-identity-provider-organizations)\n*   [Multiple Identity Provider Organizations](https://auth0.com/docs/get-started/architecture-scenarios/multiple-organization-architecture/multiple-idp-orgs)",
  "title": "Multiple Organization Architecture",
  "description": "An integration guide to multi-tenant architectures that must accommodate application instances for multiple Auth0 Organizations.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/server-application-api",
  "markdown": "# Server Applications with API\n\nIn this scenario we will build a Timesheet API for a fictitious company named ExampleCo. The API will allow to add timesheet entries for an employee or a contractor.\n\nWe will also be building a cron job which will process timesheet entries from an external system to the centralized timesheet database using the API.\n\n### TL;DR\n\n*   Auth0 provides API Authentication and Authorization as a means to secure access to API endpoints (see [API Authentication and Authorization](https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/part-1#api-authentication-and-authorization))\n*   For authorizing a Machine to Machine Application (a CLI, service or daemon where no user interaction is involved) Auth0 supports the Client Credentials grant (see [Client Credentials Grant](https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/part-1#client-credentials-grant))\n*   Both the Machine to Machine Application and the API must be configured in the Auth0 Dashboard (see [Auth0 Configuration](https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/part-2))\n*   The API will be secured by ensuring that a valid Access Token (which is implemented as a JSON Web Token) is passed in the HTTP Authorization header when calls are made to the API (see [Implement the API](https://auth0.com/docs/architecture-scenarios/server-api/part-3))\n*   Upon successful authorization an Access Token is issued to the Machine to Machine Application (see [Get an Access Token](https://auth0.com/docs/architecture-scenarios/server-api/part-3#get-an-access-token))\n*   The Machine to Machine Application can in turn use this Access Token to pass along as an HTTP Authorization header to authenticate calls to API endpoints (see [Invoke the API](https://auth0.com/docs/architecture-scenarios/server-api/part-3#invoke-the-api))\n\n## The Premise\n\nExampleCo is a consulting startup company. Currently they have approximately 100 employees and they also outsource several activities to external contractors. All employees and external contractors are required to fill in their timesheets every week. For this purpose, they built a timesheets application, a scenario we covered in [Single Sign-On for Regular Web Apps](https://auth0.com/docs/get-started/architecture-scenarios/sso-for-regular-web-apps). The internal employees use this web app to fill in their timesheets but some of the external contractors already use another tool to track their timesheets. Hence a solution to avoid the double work is required. It was decided to build a cron job which will read the timesheet entries from this external system, and automatically upload those to ExampleCo's backend using an API.\n\n### Goals & Requirements\n\nExampleCo wants to build a flexible solution. At the moment only an automated process needs to push timesheet entries but in the future the company plans on launching more applications, like a mobile app to accommodate their sales teams. Hence the company has decided to develop a single Timesheets API which will be used to log time not only by this server process, but by all future applications as well. They want to put in place a security architecture that is flexible enough to accommodate this. ExampleCo wants to ensure that a large part of the code and business logic for the application can be shared across the different applications.\n\nIt is required that only authorized users and applications are allowed access to the Timesheets API.\n\n## Learn more\n\n*   [Solution Overview (Server Apps + API)](https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/part-1)\n*   [Auth0 Configuration (Server Apps + API)](https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/part-2)\n*   [Application Implementation (Server Apps + API)](https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/part-3)\n*   [Conclusion (Server Apps + API)](https://auth0.com/docs/get-started/architecture-scenarios/server-application-api/part-4)",
  "title": "Server Applications with API",
  "description": "Explains the architecture scenario with server to server communication with secure calls to an API (resource server) on behalf of the application.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/checklists",
  "markdown": "# Implementation Planning Checklists\n\nClick the links below to download a checklist that corresponds to a phase in the SDLC (Software Development Lifecycle). You can open the checklist in any spreadsheet application and customize them to suit your needs.\n\n## Analyze Checklist\n\n[Analyze Checklist Download](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Analyze-Checklist.xlsx)\n\nIn the Analyze phase, analyze end-user business requirements and determine project goals as part of the high-level plan for the project. Convert the requirements and goals into system functions that the organization intends to develop. Activities include:\n\n*   Gathering business requirements\n    \n*   Creating process diagrams\n    \n*   Performing detailed analysis\n    \n*   Alignment to project plan\n    \n\n## Design Checklist\n\n[Design Checklist Download](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Design-Checklist.xlsx)\n\nIn the Design phase, describe the desired features and operations of the system, including business rules, pseudo-code, screen layouts, and other necessary documentation. Activities include:\n\n*   Infrastructure design\n    \n*   System model design\n    \n\n## Build Checklist\n\n[Build Checklist Download](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Build-Checklist.xlsx)\n\nIn the Build phase, develop the actual system through implementation of infrastructure and code. Activities include:\n\n*   Infrastructure implementation\n    \n*   Code implementation\n    \n\n## Test Checklist\n\n[Test Checklist Download](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Test-Checklist.xlsx)\n\nIn the Test phase, integrate and deploy all implemented code in the testing environment infrastructure. Testing then follows Software Testing Life Cycle activities to check the system for errors, bugs, and defects to verify that system features work as expected (or not). Activities include:\n\n*   Write test cases\n    \n*   Execute test cases\n    \n\n## Deploy Checklist\n\n[Deploy Checklist Download](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Deploy-Checklist.xlsx)\n\nIn the Deploy phase, deploy the system to either a staging or production environment, where actual users begin to operate and interact with it.\n\nEventually, you deploy all components of the system to the production environment when you make a live release.\n\n## Monitor Checklist\n\n[Monitor Checklist Download](https://cdn2.auth0.com/docs/media/articles/architecture-scenarios/checklists/Monitor-Checklist.xlsx)\n\nIn the Monitor phase, make enhancements, corrections, and changes to ensure the system continues to work and stays updated to meet the business objectives and support the needs of the users. Activities include:\n\n*   Monitoring\n    \n*   Maintenance\n    \n*   Changes and adjustments\n    \n*   Upgrade and adapt to future needs",
  "title": "Implementation Planning Checklists",
  "description": "Links to checklists for your implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/architecture-scenarios/implementation-resources",
  "markdown": "# Implementation Resources\n\nAuth0 provides a wealth of resources to help you effectively engage with our product and community. This list provides links to the resources available, by category.\n\n## Get started\n\nResources designed to help you learn the basics of Auth0 include:\n\n*   [**Getting Started documentation**](https://auth0.com/docs/get-started): Explore the Auth0 Dashboard and common terms used for components of the Auth0 service. Gain a broad understanding of Auth0 and learn the terminology you might hear when working with Auth0 staff or reading our docs.\n    \n*   [**Get Started with Auth0 Video Series**](https://auth0.com/docs/videos/get-started-series): In these short videos, we cover how easy it is to complete the basic steps to use Auth0 with your applications. Watch the series before you start your project so you can get the benefit of our knowledge and experience with other customers. We cover tenant configuration, provisioning user stores and importing users, authentication, authorization, and branding and customization of everything shown to your users.\n    \n*   [**Architecture scenarios**](https://auth0.com/docs/get-started/architecture-scenarios): Review common architecture scenarios and learn how to implement them with Auth0. Scenarios include tutorials for common architecture patterns, such as a Single-Page Application (SPA) calling an API. High-level descriptions are useful for architects, while tutorials will help development teams.\n    \n*   [**Implementation guides**](https://auth0.com/docs/topics/guides): Learn how to implement commonly-used features, such as user management and multi-factor authentication (MFA). This information is useful for both architects and developers\n    \n\n## Learn\n\nAuth0 provides numerous tutorials, guides, white papers, and blog posts that focus on both learning and providing quick reference checks.\n\n*   [**Docs site**](https://auth0.com/docs/): Browse through our docs to explore a wealth of available topics, or use our search to quickly find content related to a topic or term.\n    \n*   [**Feature descriptions and white papers**](https://auth0.com/learn/): Investigate short descriptions of features, industry case studies, and reference white papers. The Auth0 Learn site provides a quick overview of Auth0 features and their business value; it is helpful for project owners as well as architects and developers.\n    \n*   [**Blog posts**](https://auth0.com/blog/): Read blog posts written by experts on a variety of topics--from time-honored advice to breaking news in the identity space. Many blog posts are oriented toward architects and developers.\n    \n\n## Run sample code\n\nOnce your development team is ready to build, Auth0 provides sample programs, SDKs, and libraries to speed your project along.\n\n*   [**Quickstarts**](https://auth0.com/docs/quickstarts): Investigate a rich array of small sample programs that demonstrate how to implement the key features you’ll want to include in your program, such as authentication, session management, profile updates, and logout. Quickstarts will give developers a head start on understanding how to integrate applications with Auth0.\n    \n*   [Libraries and SDKs](https://auth0.com/docs/libraries): Simplify your custom application development by using our extensive set of libraries and SDKs, which abstract many of the details of identity protocols for you. Auth0 SDKs support numerous languages and frameworks to simplify your integration with Auth0. We also provide a library for Lock, a login widget, that you can use across several platforms, including iOS and Android.\n    \n*   [**Management API**](https://auth0.com/docs/api/management/v2): Explore and manipulate objects, configurations, and settings within Auth0. The Management API Explorer allows you to quickly manipulate individual objects and settings on an ad-hoc basis and test API calls before coding them into your applications.\n    \n*   [**Authentication API**](https://auth0.com/docs/api/authentication): Authenticate and authorize users via the OIDC, OAuth, and SAML protocols. The Authentication API Explorer allows you to experiment with authentication and authorization flows, and test API calls before coding them into your applications.\n    \n\n## Try out features and API calls\n\nWhile building, Auth0 allows you to experiment with and test out various product features.\n\n*   **TRY buttons/links**: Quickly try out Auth0 product features. **TRY** buttons are located throughout Auth0 and allow you to experiment with connections, rules, hooks, and email templates.\n    \n*   [**Authentication API Explorer**](https://auth0.com/docs/api/authentication#introduction): Experiment with authentication and authorization flows, and test API calls before coding them into your applications.\n    \n*   [**Management API Explorer**](https://auth0.com/docs/api/management/v2): Quickly manipulate individual objects and settings on an ad-hoc basis and test API calls before coding them into your applications.\n    \n\n## Get help\n\nAuth0 resources that help you troubleshoot your implementation include:\n\n*   [**Auth0 Community forum**](https://community.auth0.com/): Connect with the world of Auth0 via Auth0 posts, FAQs, and community Q&As. Architects and developers find this a valuable source of information for learning and connecting with others as well as getting help on issues.\n    \n*   [**Support Center**](https://support.auth0.com/): View and manage your subscription and tenants, file and view support requests, run automated production checks on a tenant, and view compliance information. Paid subscribers will find the support center a valuable resource if an issue or question cannot be solved by documentation or by searching the forum.\n    \n    *   [**Create support cases**](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets): Create and file a support case if you need help.\n        \n    *   [**Support Plans and Service Level Agreements**](https://auth0.com/docs/support#defect-responses): Learn about multiple levels of support available for purchase.\n        \n    *   [**Troubleshooting tips**](https://auth0.com/docs/onboarding/enterprise-support#what-to-check-before-logging-an-issue) and [**Information to include in your support case**](https://auth0.com/docs/onboarding/enterprise-support#information-to-provide-when-logging-an-issue): Get advice to help your development and support teams analyze issues.\n        \n*   [**Supported versions**](https://auth0.com/docs/troubleshoot/customer-support/product-support-matrix): Understand which versions of SDKs, browsers, and languages are supported. Architects and developers should review this to ensure your project employs languages, libraries, and SDKs that will allow your implementation to work with Auth0.\n    \n*   [**Feedback Portal**](https://auth0.com/feedback): Make product suggestions. (You can also do this via the Support Center if you want better visibility into what you’ve filed over time.) Architects and developers can use this site to provide feedback on the Auth0 product for consideration as enhancements in the future.\n    \n*   [**Professional Services**](https://auth0.com/docs/get-started/professional-services): Engage our world-wide professional services team to help speed your project to success. Project owners will find this useful for learning how Auth0 identity experts can help accelerate your project or fill in any temporary skill gaps.\n    \n\n## Set up and monitor operations\n\nWhen you're ready to plan your launch, Auth0 provides the following resources:\n\n*   [**Pre-launch advice**](https://auth0.com/docs/deploy-monitor/pre-deployment-checks) and [**Production check**](https://auth0.com/docs/deploy-monitor/pre-deployment-checks/how-to-run-production-checks): Get tips and tools to help you plan your launch. Project managers and development and operations teams should explore these tips to leverage advice for a smooth launch.\n    \n*   [**Operational policies**](https://auth0.com/docs/troubleshoot/customer-support/operational-policies): Familiarize yourself with Auth0's policies, so you know lead times for operational requests. Policies are useful for an entire team, but project owners and operations teams in particular should be aware of Auth0's operational policies.\n    \n*   [**Status Dashboard**](https://status.auth0.com/): Quickly determine the availability of Auth0 services and subscribe to status updates. Although service interruptions are rare, when one occurs Auth0 conducts a root cause analysis and publishes the results on this site. Operations and support teams should be familiar with how to check Auth0 status.\n    \n*   [**Monitor endpoints**](https://auth0.com/docs/deploy-monitor): Learn how to integrate our monitoring endpoints into your monitoring infrastructure. This information is of particular use to operations teams and project owners.\n    \n*   [**Log data**](https://auth0.com/docs/deploy-monitor/logs): Learn about the types of logs Auth0 provides, log data retention, and tools you can use to export log data to external analytical tools for analysis and long-term data storage. This information is useful for developers and operations teams, as well as compliance teams interested in data retention.\n    \n*   [**Dashboard notices**](https://auth0.com/docs/architecture-scenarios/implementation/b2c/b2c-operations#notifications): Stay informed about important announcements from Auth0. From time to time, Auth0 notifies you of important information via your Auth0 Dashboard and (depending on the severity of the information) via email to your registered Auth0 Dashboard Admins. You should regularly log in to the Dashboard and check the bell icon at the top for any important notices.\n    \n\n## Satisfy privacy, security, and compliance needs\n\nView info on Auth0’s privacy policy, security policy, compliance certifications, and how Auth0 can help you with your compliance needs. This information is useful for project owners as well as security, privacy teams, and procurement teams.\n\n*   [Privacy and Cookie Policy](https://auth0.com/privacy)\n    \n*   [Security, Privacy and Compliance](https://auth0.com/security/)\n    \n*   [Compliance Frameworks and Certifications](https://auth0.com/docs/secure/data-privacy-and-compliance)",
  "title": "Implementation Resources",
  "description": "Learn about all the resources Auth0 provides to help you with your Auth0 implementation.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/inbound-single-sign-on",
  "markdown": "# Service-Provider-Initiated Single Sign-On\n\nFor Service-Provider-initiated Single Sign-On (SSO) implementations, Auth0 is the SSO Service Provider (SP). When a user logs in to an application:\n\n1.  The application presents the user with one or more external Identity Providers (IdPs).\n    \n2.  The user selects an IdP to authenticate with and logs in.\n    \n3.  Upon successful authentication, the user is returned to the application with an active session.\n    \n\nSP-initiated SSO in Auth0 is handled by connections.\n\n## Auth0 SSO sessions vs. application sessions\n\nWhen users log in, various [session layers](https://auth0.com/docs/manage-users/sessions/session-layers) can be created. For SP-initiated SSO implementations, it's important to understand that the SSO experience is made possible by the Auth0 Session Layer, which is stored centrally on the Authorization Server. Leveraging this session layer, users can easily authenticate to different applications, each of which may have its own application session to track whether the user is logged in to it specifically.\n\n## Build your own implementations\n\n### OIDC/OAuth\n\n*   Social Identity Providers\n    \n*   Add a generic OAuth2 Authorization Server to Auth0\n    \n*   [Auth0 Marketplace](https://marketplace.auth0.com/)\n    \n\n### SAML\n\n*   Auth0 provides instructions to configure the following SAML IdPs with Auth0:\n    \n    *   [Okta](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-okta-as-saml-identity-provider)\n        \n    *   [OneLogin](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-onelogin-as-saml-identity-provider)\n        \n    *   [PingFederate 7](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-pingfederate-as-saml-identity-provider)\n        \n    *   [Salesforce](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-salesforce-as-saml-identity-provider)\n        \n    *   [SiteMinder](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-siteminder-as-saml-identity-provider)\n        \n    *   [SSOCircle](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-ssocircle-as-saml-identity-provider)\n        \n*   We also provide generic instructions to [configure Auth0 as a SAML service provider](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider).\n    \n*   [Configure Identity-Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on)\n    \n\n## Limitations\n\n*   Native applications can only use [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login).\n    \n*   OpenID Connect (OIDC) does not support IdP-initiated SSO.\n    \n\n## Learn more\n\n*   [Identity-Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on)\n*   [API Endpoints for Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on/api-endpoints-for-single-sign-on)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)\n*   [Troubleshoot SAML Errors](https://auth0.com/docs/troubleshoot/authentication-issues/saml-errors)",
  "title": "Service-Provider-Initiated Single Sign-On",
  "description": "Overview of Single Sign-on (SSO) initiated by a Service Provider (SP).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on",
  "markdown": "# Identity-Provider-Initiated Single Sign-On\n\nFor Identity-Provider-Initiated Single Sign-On (SSO), a third-party Identity Provider (IdP) is the SSO provider. When a user logs in to an application:\n\n1.  The application redirects the user to an identity provider.\n    \n2.  The third-party identity provider performs authentication and authorization.\n    \n3.  Upon successful authentication, the user is returned to the application.\n    \n\n## Pre-defined integrations\n\nAuth0 provides IdP-initiated [SSO Integrations](https://auth0.com/docs/customize/integrations/sso-integrations) for various services, like [Dropbox](https://marketplace.auth0.com/integrations/dropbox-sso), [Slack](https://marketplace.auth0.com/integrations/slack-sso), or [Zoom](https://marketplace.auth0.com/integrations/zoom-sso). To see the full list, explore [Auth0 Marketplace: SSO Integrations](https://marketplace.auth0.com/features/sso-integrations).\n\n## Build your own implementations\n\n## SAML\n\n*   [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings)\n    \n\n## OIDC\n\n*   [Configure Applications with OIDC Discovery](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery)",
  "title": "Identity-Provider-Initiated Single Sign-On",
  "description": "Overview of Single Sign-on (SSO) initiated by Identity Providers (IdPs).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/get-started/authentication-and-authorization-flow/hybrid-flow/call-api-hybrid-flow",
  "markdown": "# Call Your API Using the Hybrid Flow\n\nAuth0 makes it easy for your app to implement the Authorization Code Flow using:\n\n*   [Authentication API](https://auth0.com/docs/api/authentication): If you prefer to build your own solution, keep reading to learn how to call our API directly.\n    \n\n## Prerequisites\n\n**Before beginning this tutorial:**\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications/regular-web-apps).\n    \n    *   Select the appropriate **Application Type**.\n        \n    *   Add an **Allowed Callback URL** of `**{https://yourApp/callback}**`.\n        \n    *   Make sure your Application's **Grant Types** include **Implicit** and **Authorization Code**. To learn how, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types).\n        \n    *   If you want your Application to be able to use Refresh Tokens, make sure the Application's **Grant Types** include **Refresh Token**. To learn how, read [Update Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types). To learn more about Refresh Tokens, read [Refresh Tokens](https://auth0.com/docs/secure/tokens/refresh-tokens).\n        \n*   [Register your API with Auth0](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)\n    \n    *   If you want your API to receive Refresh Tokens to allow it to obtain new tokens when the previous ones expire, enable **Allow Offline Access**.\n        \n\n## Steps\n\n1.  [Authorize user](#authorize-user): Request the user's authorization and redirect back to your app with an authorization code.\n    \n2.  [Request tokens](#request-tokens): Exchange your authorization code for tokens.\n    \n3.  [Call API](#call-api): Use the retrieved Access Token to call your API.\n    \n4.  [Refresh tokens](#refresh-tokens): Use a Refresh Token to request new tokens when the existing ones expire.\n    \n\nOptional: [Explore sample use cases](#sample-use-cases)\n\nThis step may include one or more of the following processes:\n\n*   Authenticating the user\n    \n*   Redirecting the user to an Identity Provider to handle authentication\n    \n*   Checking for active Single Sign-on (SSO) sessions\n    \n*   Obtaining user consent for the requested permission level, unless consent has been previously given.\n    \n\nTo authorize the user, your app must send the user to the [authorization URL](https://auth0.com/docs/api/authentication#authorization-code-grant).\n\n#### Example authorization URL\n\n```\nhttps://{yourDomain}/authorize?\n    response_type=YOUR_RESPONSE_TYPE&\n    response_mode=form_post&\n    client_id={yourClientId}&\n    redirect_uri={https://yourApp/callback}&\n    scope=SCOPE&\n    audience=API_AUDIENCE&\n    state=STATE&\n    nonce=NONCE\n```\n\n##### Parameters\n\nNote that for authorizing a user when calling a custom API, you:\n\n\\- must include an audience parameter - can include additional scopes supported by the target API\n\n| Parameter Name | Description |\n| --- | --- |\n| `response_type` | Denotes the kind of credential that Auth0 will return (code or token). For this flow, the value must include `code`, but may also include `id_token`, `token`, or `id_token token`. Specifically, `id_token` returns an ID Token, and `token` returns an Access Token. |\n| `response_mode` | Specifies the method with which response parameters should be returned. For security purposes, the value should be `form_post`. In this mode, response parameters will be encoded as HTML form values that are transmitted via the HTTP POST method and encoded in the body using the `application/x-www-form-urlencoded` format. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `redirect_uri` | The URL to which Auth0 will redirect the browser after authorization has been granted by the user. The Authorization Code will be available in the `code` URL parameter. You must specify this URL as a valid callback URL in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings).<br><br>**Warning:** Per the [OAuth 2.0 Specification](https://tools.ietf.org/html/rfc6749#section-3.1.2), Auth0 removes everything after the hash and does _not_ honor any fragments. |\n| `scope` | Specifies the [scopes](https://auth0.com/docs/scopes) for which you want to request authorization, which dictate which claims (or user attributes) you want returned. These must be separated by a space. You can request any of the [standard OpenID Connect (OIDC) scopes](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) about users, such as `profile` or `email`, [custom claims](https://auth0.com/docs/tokens/concepts/jwt-claims#custom-claims) conforming to a [namespaced format](https://auth0.com/docs/tokens/guides/create-namespaced-custom-claims), or any scopes supported by the target API (e.g., `read:contacts`). Include `offline_access` to get a Refresh Token (make sure that the **Allow Offline Access** field is enabled in the [Application Settings](https://manage.auth0.com/#/applications)). |\n| `audience` | The unique identifier of the API your application wants to access. Use the **Identifier** value on the [Settings](https://manage.auth0.com/#/apis) tab for the API you created as part of the prerequisites for this tutorial. |\n| `state` | (recommended) An opaque arbitrary alphanumeric string your app adds to the initial request that Auth0 includes when redirecting back to your application. To see how to use this value to prevent cross-site request forgery (CSRF) attacks, see [Mitigate CSRF Attacks With State Parameters](https://auth0.com/docs/protocols/oauth2/mitigate-csrf-attacks). |\n| `nonce` | A cryptographically random string that your app adds to the initial request and Auth0 includes inside the ID Token, [used to prevent token replay attacks](https://auth0.com/docs/api-auth/tutorials/nonce). |\n| `organization` | (optional) ID of the organization to use when authenticating a user. When not provided, if your application is configured to **Display Organization Prompt**, the user will be able to enter the organization name when authenticating. |\n| `invitation` | (optional) Ticket ID of the organization invitation. When [inviting a member to an Organization](https://auth0.com/docs/organizations/invite-members), your application should handle invitation acceptance by forwarding the `invitation` and `organization` key-value pairs when the user accepts the invitation. |\n\nAs an example, your HTML snippet for your authorization URL when adding login to your app might look like:\n\n```\n<a href=\"https://{yourDomain}/authorize?\n  response_type=code id_token token&\n  client_id={yourClientId}&\n  redirect_uri={https://yourApp/callback}&  \n  scope=appointments%20contacts&\n  audience=appointments:api&\n  state=xyzABC123&\n  nonce=eq...hPmz\">\n  Sign In\n</a>\n```\n\n#### Response\n\nIf all goes well, you'll receive an `HTTP 302` response. The requested credentials are encoded in the body:\n\n```\nHTTP/1.1 302 Found\nContent-Type: application/x-www-form-urlencoded\ncode=AUTHORIZATION_CODE&\naccess_token=ey...MhPw\n&expires_in=7200\n&token_type=Bearer\nid_token=eyJ...acA&\nstate=xyzABC123\n```\n\nNote that the returned values depend on what you requested as a `response_type`.\n\n| Response Type | Components |\n| --- | --- |\n| `code` | Authorization code |\n| `id_token` | ID Token |\n| `token` | Access Token (plus `expires_in` and `token_type` values) |\n| `id_token token` | ID Token, Access Token (plus `expires_in` and `token_type` values) |\n\nAuth0 will also return any state value you included in your call to the authorization URL.\n\nWhen you decode and parse your ID token, you will notice an additional claim, `c_hash`, which contains a hash of the `code`. This claim is mandatory when an ID token is issued at the same time as a `code`, and you should validate it:\n\n1.  Using the hash algorithm specified in the `alg` claim in the ID Token header, hash the octets of the ASCII representation of the `code`.\n    \n2.  Base64url-encode the left-most half of the hash.\n    \n3.  Check that the result matches the `c_hash` value.\n    \n\n### Request tokens\n\nNow that you have an Authorization Code, you must exchange it for tokens. Using the extracted Authorization Code (`code`) from the previous step, you will need to `POST` to the [token URL](https://auth0.com/docs/api/authentication#authorization-code).\n\nThe Access Token you receive in this step is the one you should use to call your API. Make sure you keep it separate from the Access Token you received in the previous step of this tutorial.\n\n#### Example POST to token URL\n\n*   [cURL](#c04cbbf104c64a8f87da1b8905594e91_shell)\n*   [C#](#c04cbbf104c64a8f87da1b8905594e91_csharp)\n*   [Go](#c04cbbf104c64a8f87da1b8905594e91_go)\n*   [Java](#c04cbbf104c64a8f87da1b8905594e91_java)\n*   [Node.JS](#c04cbbf104c64a8f87da1b8905594e91_node)\n*   [Obj-C](#c04cbbf104c64a8f87da1b8905594e91_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=authorization_code \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data 'code=yourAuthorizationCode}' \\\n  --data 'redirect_uri={https://yourApp/callback}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'authorization_code',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    code: 'yourAuthorizationCode}',\n    redirect_uri: '{https://yourApp/callback}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=authorization_code\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&code=yourAuthorizationCode}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&redirect_uri={https://yourApp/callback}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=authorization_code&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&code=yourAuthorizationCode%7D&redirect_uri={https://yourApp/callback}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=authorization_code\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&code=yourAuthorizationCode}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&redirect_uri={https://yourApp/callback}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to `authorization_code`. |\n| `code` | The `authorization_code` retrieved in the previous step of this tutorial. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `client_secret` | Your application's Client Secret. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). To learn more about available application authentication methods, read [Application Credentials](https://auth0.com/docs/secure/application-credentials). |\n| `redirect_uri` | The valid callback URL set in your Application settings. This must exactly match the `redirect_uri` passed to the authorization URL in the previous step of this tutorial. Note that this must be URL encoded. |\n\n#### Response\n\nIf all goes well, you'll receive an `HTTP 200` response with a payload containing `access_token`, `refresh_token`, `id_token`, and `token_type` values:\n\n```\n{\n  \"access_token\": \"eyJz93a...k4laUWw\",\n  \"refresh_token\": \"GEbRxBN...edjnXbL\",\n  \"id_token\": \"eyJ0XAi...4faeEoQ\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n[ID tokens](https://auth0.com/docs/secure/tokens/id-tokens) contain user information that must be decoded and extracted.\n\n[Access tokens](https://auth0.com/docs/secure/tokens/access-tokens) are used to call the [Auth0 Authentication API's /userinfo endpoint](https://auth0.com/docs/api/authentication#get-user-info) or another API. If you are calling your own API, the first thing your API will need to do is [verify the Access token](https://auth0.com/docs/secure/tokens/access-tokens/validate-access-tokens).\n\n[Refresh tokens](https://auth0.com/docs/secure/tokens/refresh-tokens) are used to obtain a new access token or ID token after the previous one has expired. The `refresh_token` will only be present in the response if you included the `offline_access` scope and enabled **Allow Offline Access** for your API in the Dashboard.\n\n### Call API\n\nTo call your API from a regular web application (or similar cases in which the application credentials can be safely stored), the application must pass the retrieved Access Token as a Bearer token in the Authorization header of your HTTP request.\n\n*   [cURL](#2a1793b84286470292f752bc32826265_shell)\n*   [C#](#2a1793b84286470292f752bc32826265_csharp)\n*   [Go](#2a1793b84286470292f752bc32826265_go)\n*   [Java](#2a1793b84286470292f752bc32826265_java)\n*   [Node.JS](#2a1793b84286470292f752bc32826265_node)\n*   [Obj-C](#2a1793b84286470292f752bc32826265_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url https://myapi.com/api \\\n  --header 'authorization: Bearer {accessToken}' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://myapi.com/api\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {accessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://myapi.com/api\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {accessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://myapi.com/api\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {accessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://myapi.com/api',\n  headers: {'content-type': 'application/json', authorization: 'Bearer {accessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {accessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://myapi.com/api\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://myapi.com/api\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {accessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"myapi.com\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {accessToken}\"\n    }\n\nconn.request(\"GET\", \"/api\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://myapi.com/api\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {accessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {accessToken}\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://myapi.com/api\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Refresh tokens\n\nYou have already received a [refresh token](https://auth0.com/docs/secure/tokens/refresh-tokens) if you've been following this tutorial and completed the following:\n\n*   configured your API to allow offline access\n    \n*   included the `offline_access` scope when you initiated the authentication request through the [authorize endpoint](https://auth0.com/docs/api/authentication/reference#authorize-application).\n    \n\nYou can use the Refresh Token to get a new access token. Usually, a user will need a new access token only after the previous one expires or when gaining access to a new resource for the first time. It's bad practice to call the endpoint to get a new access token every time you call an API, and Auth0 maintains rate limits that will throttle the amount of requests to the endpoint that can be executed using the same token from the same IP.\n\nTo refresh your token, make a `POST` request to the `/oauth/token` endpoint in the Authentication API, using `grant_type=refresh_token`.\n\n#### Example POST to token URL\n\n*   [cURL](#68712eaf7c234281a2c373d28e934c9c_shell)\n*   [C#](#68712eaf7c234281a2c373d28e934c9c_csharp)\n*   [Go](#68712eaf7c234281a2c373d28e934c9c_go)\n*   [Java](#68712eaf7c234281a2c373d28e934c9c_java)\n*   [Node.JS](#68712eaf7c234281a2c373d28e934c9c_node)\n*   [Obj-C](#68712eaf7c234281a2c373d28e934c9c_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=refresh_token \\\n  --data 'client_id={yourClientId}' \\\n  --data 'refresh_token={yourRefreshToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'refresh_token',\n    client_id: '{yourClientId}',\n    refresh_token: '{yourRefreshToken}'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=refresh_token\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&refresh_token={yourRefreshToken}\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=refresh_token&client_id={yourClientId}&refresh_token=%7ByourRefreshToken%7D\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=refresh_token\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&refresh_token={yourRefreshToken}\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Parameters\n\n| Parameter Name | Description |\n| --- | --- |\n| `grant_type` | Set this to `refresh_token`. |\n| `client_id` | Your application's Client ID. You can find this value in your [Application Settings](https://manage.auth0.com/#/Applications/{yourClientId}/settings). |\n| `refresh_token` | The refresh token to use. |\n| `scope` | (optional) A space-delimited list of requested scope permissions. If not sent, the original scopes will be used; otherwise you can request a reduced set of scopes. Note that this must be URL encoded. |\n\n#### Response\n\nIf all goes well, you'll receive an `HTTP 200` response with a payload containing a new `access_token`, its lifetime in seconds (`expires_in`), granted `scope` values, and `token_type`. If the scope of the initial token included `openid`, then the response will also include a new `id_token`:\n\n```\n{\n  \"access_token\": \"eyJ...MoQ\",\n  \"expires_in\": 86400,\n  \"scope\": \"openid offline_access\",\n  \"id_token\": \"eyJ...0NE\",\n  \"token_type\": \"Bearer\"\n}\n```\n\n### Sample use cases\n\n#### Customize tokens\n\nYou can use rules to change the returned scopes of Access Tokens and/or add claims to Access and ID Tokens. (To learn more about rules, read [Auth0 Rules](https://auth0.com/docs/customize/rules).) To do so, add the following rule, which will run after the user authenticates:\n\n```\nfunction(user, context, callback) {\n  // add custom claims to Access Token and ID Token\n  context.accessToken['http://foo/bar'] = 'value';\n  context.idToken['http://fiz/baz'] = 'some other value';\n  // change scope\n  context.accessToken.scope = ['array', 'of', 'strings'];\n  callback(null, user, context);\n}\n```\n\nScopes will be available in the token after all rules have run.\n\n## Learn more\n\n*   [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth)\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)\n*   [Tokens](https://auth0.com/docs/secure/tokens)",
  "title": "Call Your API Using the Hybrid Flow",
  "description": "Learn how to execute the Hybrid Flow so your app can use an ID token to access information about the user while obtaining an authorization code that can be exchanged for an Access Token.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/okta-access-gateway",
  "markdown": "# Okta Access Gateway\n\n**Okta Access Gateway (OAG)** is a solution designed to extend modern identity to legacy on-prem applications to protect your hybrid cloud. Now, you can easily set up Okta Access Gateway to use Auth0 as the identity provider to authenticate users and have Single Sign-On (SSO) when accessing on-prem applications. To learn more about setup, see the [Okta Access Gateway website](https://help.okta.com/oag/en-us/content/topics/access-gateway/ag-main.htm). \n\nAfter correctly setting up, you can view your OAG Applications as **SSO Integrations** on the Auth0 Dashboard.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7fB4rjisMdL7nNcMrh1b0J/c250ef129d72952b71c2a0c17a2aa1a7/image1.png)",
  "title": "Okta Access Gateway",
  "description": "Overview of Okta Access Gateway (OAG). ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/single-sign-on/api-endpoints-for-single-sign-on",
  "markdown": "# API Endpoints for Single Sign-On\n\nWhen implementing Single Sign-on (SS0) and configuring its settings, the following API endpoints will be helpful to you.\n\n## Authentication API endpoints\n\n### POST /login/callback\n\nFor SSO flows initiated by an Identity Provider (IdP), the [POST /login/callback](https://auth0.com/docs/api/authentication#idp-initiated-single-sign-on-sso-flow) endpoint can accept a sign-on SAML request from the identity provider.\n\n## Management API\n\nThe Management API features several endpoints designed to help you manage SSO.\n\nTo call any of the Management API endpoints, you will need to [obtain an Access Token](https://auth0.com/docs/api/management/v2/tokens).\n\n### Clients\n\nAll of your client applications/SSO integrations feature information relevant to your SSO implementation. You can retrieve or change this information by calling one of the Clients endpoints.\n\nOf-interest parameters for each client include:\n\n*   `sso`: Flag applicable only for clients created via SSO integrations. If `true`, Auth0 handles SSO; if `false`, the IdP handles SSO.\n    \n*   `sso_disabled`: Flag used to enable/disable SSO. If `true`, then SSO is disabled; if `false`, SSO is enabled. This option can only be set via the Management API.\n    \n*   `app_type`: Application type. If the client was created using one of Auth0's built-in SSO integrations, the name of the SSO integration would be listed (e.g., `box` or `concur` instead of `native` or `spa`)\n    \n\n#### Get all clients\n\nThe [GET /api/v2/clients](https://auth0.com/docs/api/management/v2#!/Clients/get_clients) endpoint can be used to return information about the client applications you have configured for your tenant.\n\n#### Create a client\n\nThe [POST /api/v2/clients](https://auth0.com/docs/api/management/v2#!/Clients/post_clients) endpoint can be used to create a new client application.\n\n#### Get a client\n\nThe [GET /api/v2/clients/{id}](https://auth0.com/docs/api/management/v2#!/Clients/get_clients_by_id) endpoint can be used to return information about a specific client you have configured for your tenant.\n\n#### Update a client\n\nThe [PATCH /api/v2/clients/{id}](https://auth0.com/docs/api/management/v2#!/Clients/patch_clients_by_id) endpoint can be used to update a specific client, including its SSO-related parameters.\n\n### Tenants\n\nAuth0 allows you to control the following tenant-level parameters that may affect your SSO implementation:\n\n*   `session_lifetime`: Length of time for which the user's Auth0 session will stay valid.\n    \n*   `idle_session_lifetime`: Amount of time that may elapse before the user must sign in again due to inactivity.\n    \n\n### Get tenant settings\n\nThe [GET /api/v2/tenants/settings](https://auth0.com/docs/api/management/v2#!/Tenants/get_settings) endpoint retrieves the settings for your tenant.\n\n### Update tenant settings\n\nThe [POST /api/v2/connections](https://auth0.com/docs/api/management/v2#!/Tenants/patch_settings) endpoint allows you to update your tenant settings.\n\n## Learn more\n\n*   [Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)",
  "title": "API Endpoints for Single Sign-On",
  "description": "Describes Auth0 Authentication API and Management API endpoints relevant when implementing Single Sign-on (SSO).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/passwordless/passwordless-with-universal-login",
  "markdown": "# Passwordless with Universal Login\n\nThe Universal Login Experience supports [Passwordless connections](https://auth0.com/docs/authenticate/passwordless), which allow users to provide a phone number or email address, and then receive a one-time password (OTP) to complete authentication.\n\n## Enable Passwordless for Universal Login\n\nTo configure Universal Login to support Passwordless connections, you'll need to set the Authentication Profile to use a supported login flow, and update your application to specify the connection during authentication.\n\n### Enable Identifier First\n\nIn the Auth0 Dashboard, go to [Authentication > Authentication Profile.](https://manage.auth0.com/?/authentication-profiles)\n\nSelect either **Identifier First** or **Identifier First + Biometrics**.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/55saPRLPRJqFMxSjYo9Lvn/d85d8c11ac783efba56c2bd1cf8f377a/image-20221202-233952.png)\n\n### Update your application\n\nDepending on the type of connections you have enabled for your application, you may need to update your application to specify a Passwordless connection during login:\n\n| **Database connection** | **Passwordless connection** | **Need to specify?** | **User experience** |\n| --- | --- | --- | --- |\n| Yes | SMS and/or Email | Yes | Specified Passwordless connection is presented during login. |\n| No  | SMS and Email | No  | Passwordless connection that was created first is presented. |\n| No  | SMS or Email | No  | Passwordless connection is presented (along with any enabled Social connections) during login. |\n\nTo specify a Passwordless connection during login, you must pass the `connection` parameter and its value (either `sms` or `email`) to the [Auth0 Authentication API Login endpoint](https://auth0.com/docs/api/authentication#login):\n\n`https://mytenant.us.auth0.com/authorize?client_id={id}&``**connection={sms|email}**``&scope=…&response_type=code&response_mode=query&state=…&redirect_uri=http%3A%2F%2Flocalhost%3A3000&code_challenge=…`\n\nIf you are using one of our SDKs, you can specify a Passwordless connection during initialization. For example:\n\n```\nauth0 = await createAuth0Client({\n     domain: config.domain,\n     client_id: config.clientId,\n     connection: \"email\"\n  });\n\nauth0 = await createAuth0Client({\n     domain: config.domain,\n     client_id: config.clientId,\n     connection: \"sms\"\n  });\n```\n\n### Test the connection\n\nWhen the user is prompted to enter their OTP, they'll see one of the following screens:\n\n### Signup\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/6ABY0ul7dceiGcdRH7glm6/38dacdca6fe6b277cb4d3b3e14f38b09/Passwordless_SMS_Signup_Prompt.png)\n\n### Login\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/5xHAEaXgnS43Jpnju9FCzZ/79ac7d36abdb06d4ed7f636684a414eb/Passwordless_SMS_Login_Prompt.png)",
  "title": "Passwordless with Universal Login",
  "description": "The document announces support for Universal Login and Passwordless connections.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/create-sso-dashboard-application",
  "markdown": "# Create Single Sign-on (SSO) Dashboard Application\n\nUse the Single Sign-On (SSO) Dashboard extension to manage SSO login for your users on multiple enterprise applications. To learn more, [view this extension on GitHub](https://github.com/auth0-extensions/auth0-sso-dashboard-extension).\n\n## Create Auth0 application\n\nBefore you [add the SSO Dashboard extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/install-sso-dashboard-extension), you need to create an application in Auth0:\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select **+Create Application**.\n    \n2.  Enter a descriptive name for your Application (for example, SSO Dashboard), select **Single-Page Web Application** for the **Application Type**, and then select **Create**.\n    \n3.  On the **Settings** tab, set the **Allowed Callback URLs** based on your tenant's region:\n    \n    1.  For **Admins**: `https://{yourTenant}.YOUR_REGION_KEY.webtask.io/auth0-sso-dashboard/admins/login`\n        \n    2.  For **Users**: `https://{yourTenant}.YOUR_REGION_KEY.webtask.io/auth0-sso-dashboard/login`\n        \n        | **Region** | **Region Key** |\n        | --- | --- |\n        | US-1 | `us12` |\n        | US-3 | `us` |\n        | EU  | `eu12` |\n        | AU  | `au12` |\n        | JP-1 | `jp` |\n        \n4.  Select and copy the **Client ID** value.\n    \n5.  Navigate to the bottom of the page, and then select **Advanced Settings**.\n    \n6.  Select the **OAuth** tab, and then paste the **Client ID** value into the **Allowed APPs / APIs** field.\n    \n7.  Set **JsonWebToken Signature Algorithm** to **RS256**.\n    \n8.  Select **Save Changes**.\n    \n\nBy default, all the connection types are enabled for users to be able to log into the SSO Dashboard. If you would like to change this, navigate to the **Connections** tab for the Application.\n\n## Install SSO Dashboard extension\n\nNext, you will need to [install the SSO Dashboard Extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/install-sso-dashboard-extension) and [add applications](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/add-applications-to-the-sso-dashboard) to the dashboard.\n\n## Learn more\n\n*   [Install Single Sign-On Dashboard Extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/install-sso-dashboard-extension)\n*   [Add Applications to Single Sign-On Dashboard](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/add-applications-to-the-sso-dashboard)\n*   [Troubleshoot Extensions](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-extensions)\n*   [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on)\n*   [Sessions](https://auth0.com/docs/manage-users/sessions)\n*   [Logout](https://auth0.com/docs/authenticate/login/logout)",
  "title": "Create Single Sign-on (SSO) Dashboard Application",
  "description": "Describes how to create an application to use with the SSO Dashboard Extension to enable SSO login for your applications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/auth0-user-store",
  "markdown": "# Auth0 User Store\n\nAuth0 provides the database infrastructure to store your users by default. This scenario provides the best performance for the authentication process since all data is stored in Auth0.\n\nThe Auth0-hosted database is highly secure. Passwords are never stored or logged in plain text but are hashed with **bcrypt**. Varying levels of password security requirements can also be enforced. To learn more, read [Password Strength in Auth0 Database Connections](https://auth0.com/docs/authenticate/database-connections/password-strength).\n\n## Migrating to Auth0 from a custom user store\n\nIn this scenario, you have a legacy user store and wish to switch to the Auth0 store. Auth0 provides an automatic migration feature that adds your users to the Auth0 database one-at-a-time as each logs in and avoids asking your users to reset their passwords all at the same time. To learn more, read [Configure Automatic Migration from Your Database](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database).\n\n## Learn more\n\n*   [Manage Users](https://auth0.com/docs/manage-users)",
  "title": "Auth0 User Store",
  "description": "Describes creating and using a database connection with the Auth0 user store.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/basic-issues/verify-connections",
  "markdown": "# Verify Connections\n\nAn authentication transaction often has several parts. Auth0 provides methods so you can try individual parts of the transaction to help you find the possible source of the problem.\n\nMost identity provider connections have a **TRY** button to see if the connection is working. If that fails, you can debug the connection without involving the rest of the application. If the connection works, then you can start debugging the application.\n\n1.  Use the **TRY** button on a connection to test just the connection.\n    \n2.  If the test with the **TRY** button fails, you know it is not an issue with your application but rather something with the connection configuration or the connection provider.\n    \n3.  Check the response from the test with the **TRY** button to see if the response contains a useful error message or other information.\n    \n4.  Try logging into the same service through a different path.\n    \n5.  If the same issue occurs you’ll know it’s some sort of issue with the account\n    \n6.  If a test with the **TRY** button fails for a custom DB connection, it is frequently caused by an issue in the custom DB scripts. Putting console.log statements into them and viewing output in the Console Log can help debug them.\n    \n\n## Verify external service dependencies\n\n1.  If your authentication uses external services, like social identity providers, and it suddenly stops working, [check external services status](https://auth0.com/docs/deploy-monitor/monitor/check-external-services-status).\n    \n2.  If a connection is not working, even with the **TRY** button, check the connection.\n    \n\n## Learn more\n\n*   [Verify Platform](https://auth0.com/docs/troubleshoot/basic-issues/verify-platform)\n*   [Verify Domain](https://auth0.com/docs/troubleshoot/basic-issues/verify-domain)\n*   [Verify Rules](https://auth0.com/docs/troubleshoot/basic-issues/verify-rules)\n*   [Check Auth0 Status](https://auth0.com/docs/deploy-monitor/monitor/check-auth0-status)\n*   [Monitor Applications](https://auth0.com/docs/deploy-monitor/monitor/monitor-applications)",
  "title": "Verify Connections",
  "description": "Learn how to verify connection transactions and external service dependencies to troubleshoot issues",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/custom-db",
  "markdown": "# Custom Database Connections\n\nUse a custom database connection when you want to provide Auth0 with access to your own independent (legacy) identity data store primarily for authentication (filling the role of an identity provider) and for migrating user data to Auth0's data store.\n\nAuth0 [Extensibility](https://auth0.com/docs/customize/extensions) allows you to add custom logic to build out last-mile solutions for Identity and Access Management (IdAM). Auth0 extensibility comes in several forms: [Actions](https://auth0.com/docs/customize/actions), [Rules](https://auth0.com/docs/customize/rules), [Hooks](https://auth0.com/docs/customize/hooks), and [scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/templates) for both custom database connections and custom database migration. Each is implemented using [Node.js](https://nodejs.org/en/) running on the Auth0 platform in an Auth0 tenant.\n\nAuth0 extensibility executes at different points in the IdAM pipeline:\n\n*   **Actions** extend processes called flows, which are made up of one or more triggers, and which represent the logical pipeline through which information moves during a single point in the Auth0 journey. To learn more about available flows and triggers, read [Explore Flows and Triggers](https://auth0.com/docs/customize/actions/flows-and-triggers).\n    \n*   **Rules** run when artifacts for user authenticity are generated (i.e., an ID Token in OpenID Connect (OIDC)), an Access Token in OAuth 2.0, or an assertion in Security Assertion Markup Language (SAML).\n    \n*   **Hooks** provide additional extensibility for when there is an exchange of non-user related artifacts, and for when user identities are created.\n    \n*   **Custom database action scripts** can be used to integrate with an existing user identity store, or can be used where [automatic user migration](https://auth0.com/docs/manage-users/user-migration) from a legacy identity store is required. Various [templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates) are provided.\n    \n\nWhatever the use case, Auth0 extensibility allows you to tailor IdAM operations to your exact requirements. However, if not used in the right way, this can open up the potential for improper or unintended use which can lead to problematic situations down the line. In an attempt to address matters ahead of time, Auth0 provides [best practice guidance](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts) to both designers and implementers, and we recommend reading it in its entirety at least once, even if you've already started your journey with Auth0.\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Learn more\n\n*   [Authenticate with Your Own User Store](https://auth0.com/docs/authenticate/database-connections/custom-db/overview-custom-db-connections)\n*   [Create Custom Database Connections](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection)\n*   [Custom Database Action Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates)\n*   [Troubleshoot Custom Databases](https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling)",
  "title": "Custom Database Connections",
  "description": "Learn about authenticating users using your database as an identity provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/passkeys",
  "markdown": "# Passkeys\n\nPasskeys are a phishing-resistant alternative to traditional authentication factors (such as username/password) that offer an easier and more secure login experience to users. Passkeys are modeled from FIDO® W3C Web Authentication (WebAuthn) and Client to Authenticator Protocol (CTAP) [specifications](https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-errata-20220621.html#intro)).\n\nPasskeys reduce the friction experienced with single-device authentication methods by allowing credentials to sync across devices. Cross-device authentication eliminates the need for users to re-enroll on each of their devices. It also supports a more reliable recovery method as the stored credentials can survive the loss of an originating device. To learn more about passkeys, review the FIDO® Alliance [Passkey FAQs](https://fidoalliance.org/passkeys/#faq).\n\nAuth0 supports passkeys as an authentication method for [database connections](https://auth0.com/docs/authenticate/database-connections).\n\n## User experience flows\n\nSimilar to traditional authentication factors, passkeys can support several user experience flows such as signup, login, and account recovery.\n\n### Signup flow\n\nThe signup flow requires the user to provide an email address, and then create a passkey on either their current device or another device through cross-device authentication.\n\n1.  Prompts the user to enter their email address.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/5SlpzscSseNOuJlvhOgBqr/318d95254ef48197a32e58c92be00d2b/signup-passkey_default.png)\n2.  User enters their email address.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/3r5pFsWx6SkYOHSHglRwzG/337e3569359c3431c82e80adfeceb470/signup-passkey_filled.png)\n3.  Prompts the user to create a passkey.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/7vZK4q4iUtxyld1Os6og4s/49c22a4c2c06f31256e5a0d4df6daca2/signup-passkey_enrol.png)\n4.  If the user selects **Create a passkey**, it triggers the browser (or operating system) flow to create a passkey.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/IsWmSXNHc2fvRuEgn5DpK/52b2464e21c8dc68bb06869126043ba9/Signup_-_Passkey_-_Browser_OS_Create_a_Passkey.png)\n    *   If the user selects **Continue**, it prompts them to authenticate with their device’s credentials.\n        \n        ![](https://images.ctfassets.net/cdy7uua7fh8z/6OJlPQrWBhgO8izXXoKbOw/a3c1af9a94aaeffc50793e3e9b88db8f/Signup_-_Passkeys_-_Chrome_Prompt_for_Device_Credentials.png)\n    *   If the user selects **Try another way**, it prompts them to create a passkey on another device.\n        \n        ![](https://images.ctfassets.net/cdy7uua7fh8z/2yXrkVbYLxxp6MXnrZLqVN/5f67ddf9b8003729a11604a3af3e553d/passkey-browser-cross-device.png)\n\n### Login flow\n\nThe login flow detects if the user has a passkey registered to the current device and then automatically selects it using autofill. If the user has multiple passkeys registered to the device, they can manually select one with a button.\n\n1.  Prompts the user for an email address or a passkey.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/3qqI3Uo1z1yQhvb7boQ0cx/820f38ffdec77388331ef238ff80de88/login-passkey_default.png)\n2.  User can use autofill or select **Continue with a passkey**.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/3zvWl2rpxzJ5klloIihRYB/a311cc3cc54075b7b92aca677ced29ba/login-passkey_filled.png)![](https://images.ctfassets.net/cdy7uua7fh8z/tC4UZmYFgo7Zjt9kviP9j/690b87af58068c18a4609c8e9431e5b7/Login_-_Passkeys_-_Choose_a_passkey.png)\n3.  Prompts the user to authenticate with the device’s credentials.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/6OJlPQrWBhgO8izXXoKbOw/a3c1af9a94aaeffc50793e3e9b88db8f/Signup_-_Passkeys_-_Chrome_Prompt_for_Device_Credentials.png)\n\n## Passkeys with MFA enabled\n\nIf MFA is enabled, the user may be prompted to complete an MFA challenge after authenticating with a passkey based on settings and risk assessment.\n\nThe default behavior is to require the completion of an MFA challenge regardless if the authentication method used was a password or a passkey. Given the high level of security passkeys provide, you may skip MFA for users that have authenticated with a passkey in order to reduce friction. This can be achieved by using a post-login Action.\n\nTo learn more, read [Reduce friction with passkeys](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow#reduce-friction-with-passkeys) and [Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication).",
  "title": "Passkeys",
  "description": "Learn about implementing passkeys as an authentication method ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations",
  "markdown": "# Troubleshoot SAML Configurations\n\nWhen troubleshooting, it's important to understand your configuration.\n\n*   **Is Auth0 serving as the SAML Service Provider (SP), the SAML Identity Provider (IdP), or both?**\n    \n    The SP redirects users elsewhere for authentication. The IdP authenticates the user by prompting them to log in and validating the information provided. If your application redirects the user to Auth0 for authentication via SAML, then Auth0 is the IdP. If Auth0 redirects users via a Connection to a remote IdP via SAML, then Auth0 is the SP to the remote IdP. Auth0 can act as the SP, IdP, or both.\n    \n*   **Does your authentication flow use an SP-initiated model, an IdP-initiated model, or both?**\n    \n    SP-initiated authentication flows begin with the user navigating to the SP application and getting redirected to the IdP for login. An IdP-initiated flow means the user navigates to the IdP, logs in, and then gets redirected to the SP application.\n    \n    Within enterprise settings, the IdP-initiated flow is most common.\n    \n*   **Which user profile attribute identifies the user at the IdP (during login) and within each application?**\n    \n    If the naming attribute differs between the IdP and the application(s), you'll need to configure the appropriate mappings within Auth0 so that it sends the correct user profile attributes to the application(s).\n    \n    *   From our experience, using the email address as the unique identifier is the easiest option, though there are privacy concerns with this option.\n        \n    *   Enterprise organizations often use an internal ID of some type with the IdP, which needs to be mapped to another attribute meaningful to outsourced SaaS applications.\n        \n*   **Are your authentication requests signed?**\n    \n*   **Are your authentication assertions encrypted?**\n    \n\nWhen troubleshooting, we recommend beginning by gathering information that helps answer the following questions:\n\n1.  How many users experience the issue? Just one user? All users?\n    \n2.  Is this an issue with a new setup, or is this an existing integration that's stopped working?\n    \n3.  How many applications does the issue affect?\n    \n4.  What is the expected behavior? What is the behavior you're seeing?\n    \n5.  How far through the login sequence does the user get?\n    \n\n## Check affected users\n\n*   Check the user's profile, browser, or device for any issues.\n    \n*   Check to see if it happens in all browsers for the affected users (indicating a data issue) or just certain types of browsers (indicating a browser-specific issue).\n    \n*   Check to see if the browser has enabled JavaScript and cookies.\n    \n*   Check that the caps lock key is disabled.\n    \n*   If the user is using a mobile device, check to see if there's any software that might impact authentication and/or authorization (such as not running some type of required software).\n    \n*   Check to see if the user can access some of the app's key URLs, such as the IdP's Single Sign-on (SSO) URL (indicating a network connectivity issue).\n    \n\n## Troubleshoot Auth0 as a service provider\n\n### Common errors\n\nHere are some common errors you might encounter when Auth0 acts as the service provider and the steps you should take to resolve them.\n\n#### Error: Connection disabled\n\nThis message indicates that the Application doesn't have an active Connection associated:\n\n`\"error\": \"invalid_request\", \"error_description\": \"the connection was disabled\"`\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select a connection type.\n    \n2.  Select the name of your Connection.\n    \n3.  Select the **Applications** view.\n    \n4.  Enable at least one Application (if you don't see any in the list, you will need to create an application before proceeding).\n    \n\n#### Error: IdP-Initiated login not enabled\n\nThis error typically occurs because the ACS URL configured in the IdP used the default Auth0 tenant domain, whereas the authentication transaction was started by calling the Custom Domain `/authorize` endpoint.\n\n`\"invalid_request\": \"IdP-Initiated login is not enabled for connection 'CONNECTION_NAME'.\"`\n\nIf you see this error when using an SP-initiated flow, one of the following is missing or empty:\n\n*   `RelayState` parameter\n    \n*   `InResponseTo` attribute in the SAML response\n    \n\nIf these are missing or empty, Auth0 treats the login as IdP-initiated. You can fix this error by checking your configuration to ensure that both fields are populated and returned appropriately.\n\nTo fix this:\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select a connection type.\n    \n2.  Select the name of your Connection.\n    \n3.  Select the **IdP-Initiated SSO** view.\n    \n4.  Locate **IdP-Initiated SSO Behavior**, and select **Accept Requests** to enable IdP-initiated logins.\n    \n5.  Select the **Default Application** and the **Response Protocol** used by that application, and (optionally) specify any additional parameters you want to be passed to the application.\n    \n\n#### Error: InResponseTo attribute does not match the ID in AuthNRequest\n\nThis error occurs when the `InResponseTo` attribute in the SAML response is not recognized by the Auth0 tenant. This error could be caused by:\n\n*   blocked cookies\n    \n*   mismatched IDs from the most recent SAML request\n    \n*   inconsistent use of domains\n    \n\nIf your tenant uses a custom domain, you could have a mismatch if the login flow begins on the custom domain and finishes on the canonical domain. For example, the user starts at the custom domain:\n\n```\nhttps://auth.{yourDomain}.com/authorize?client_id=abc123&redirect_uri=https://jwt.io&response_type=code&scope=openid&audience=https://example.com&connection=mysamlconnection\n```\n\nBut the identity provider is configured to return the SAML response to the ACS URL at the canonical domain:\n\n```\nhttps://{yourTenant}.auth0.com/login/callback\n```\n\nIf the ID is returned to another domain in the `InResponseTo` attribute of a SAML response, your Auth0 tenant doesn’t have a record of it and returns the above error.\n\nTo fix this:\n\nUse the same domain throughout the login flow. Change either the domain in the initial `/authorize` request or the ACS URL with your identity provider.\n\n#### Error: IdP-Initiated Default App Not Configured\n\nThis error typically occurs have enabled IdP-Initiated flows but you haven't provided the necessary information to execute the flow.\n\n`\"invalid_request\": \"Default App for IdP-Initiated is not configured. Make sure to configure that from connection settings or include client_id in RelayState parameter.\"`\n\nThe ACS URL should use the same domain as the initial authentication request. If using custom domains, this should use the custom domain callback URL.\n\nIf you see this error when using an SP-initiated flow, one of the following is missing or empty:\n\n*   `RelayState` parameter\n    \n*   `InResponseTo` attribute in the SAML response\n    \n\nIf these are missing or empty, Auth0 treats the login as IdP-initiated. You can fix this error by checking your configuration to ensure that both fields are populated and returned appropriately.\n\nTo fix this:\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select a connection type.\n    \n2.  Select the name of your Connection.\n    \n3.  Select the **IdP-Initiated SSO** view.\n    \n4.  Select the **Default Application** and the **Response Protocol** used by that application, and (optionally) specify any additional parameters you want to be passed to the application.\n    \n\n#### Error: Missing RelayState\n\nThis error occurs when the identity provider doesn't return the `RelayState` parameter along with its response.\n\nWork with the identity provider to ensure that it returns the `RelayState` parameter.\n\n#### Error: Audience invalid\n\nThis error occurs if the value of the `audience` element from the identity provider's SAML response doesn't match the value expected by Auth0. Auth0 expects the value to be the Entity ID for the Connection.\n\nFind your connection's entity ID:\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select a connection type.\n    \n2.  Select the name of your Connection.\n    \n3.  Select the **Setup** view, and locate the **Common Settings** section; your **Entity ID** is the second parameter provided.\n    \n\nMake sure that the identity provider sends the correct `audience` value in the SAML response.\n\n#### Incorrect protocol specified\n\nOne common error is specifying the incorrect response protocol on the IdP-Initiated tab. The response protocol is the one used between Auth0 and the Application (not the remote identity provider). For example, if you set this value to **SAML** when your Application expects **OpenID Connect** or **WS-Fed** results in errors due to the incorrect configuration.\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select a connection type.\n    \n2.  Select the name of your Connection.\n    \n3.  Select the **IdP-Initiated SSO** view, locate **Response Protocol**, and check its value.\n    \n\n#### User isn't logged out of the IdP\n\nWhen ADFS is configured as SAML IdP, if the ADFS is relaying party trust `Name ID` attribute isn't mapped the logout flow fails. For example, with the federated parameter `v2/logout?federated&...` user isn't redirected to the ADFS SAML logout endpoint but redirects back to application callback URL directly. As a consequence, the user isn't logged out from the IdP in that case.\n\nAdd the `Name ID` attribute as a rule on the SAML Relaying Party Trust.\n\n### SAML login issues\n\nWhen troubleshooting a SAML login, there are four primary stages to check:\n\n*   Stage 1: The user is successfully redirected to an identity provider (IdP) and is able to login.\n    \n*   Stage 2: After login with the IdP, the user returns to Auth0 with a successful login event recorded.\n    \n*   Stage 3: After a successful login event in Auth0, the user profile in Auth0 is correct.\n    \n*   Stage 4: The user successfully redirects back to application and is able to access application.\n    \n\nThe following sections describe how to check each stage and how to identify if there are any issues with a given stage.\n\n#### IdP login page doesn't display\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select **SAML**.\n    \n2.  Locate your connection, and select its **Try** (triangle/play) icon to test the interaction between Auth0 and the remote IdP. If the Connection does **not** work, continue with the steps detailed in this section. If it does, proceed to the next section.\n    \n    ![Troubleshoot SAML Connections Test Connection Screen](https://images.ctfassets.net/cdy7uua7fh8z/1AmNnVUgQXXvPBkfZBfAAK/60a86221d4bee328d04bdaae0876c9e8/test-connection.png)\n3.  Next to the SAML connection, click **Settings** (represented by the gear icon).\n    \n    ![Dashboard Authentication Enterprise SAML Connection Settings](https://images.ctfassets.net/cdy7uua7fh8z/6s8p4aMck06YnPStr493sA/3e10e74fd75b504a04b0e3bb3dfb82f2/dashboard-authentication-enterprise-saml-connection-settings.png)\n4.  Check and confirm the following with the IdP administrator:\n    \n    1.  That the Sign In URL is the correct Single Sign-on (SSO) URL. This is the URL that Auth0 will redirect the user to for authentication.\n        \n    2.  If the IdP expects HTTP-POST binding or HTTP-Redirect binding. You can switch the default binding in the **Settings** tab.\n        \n    3.  If your authentication requests should be signed. If so, which signing algorithm does the IdP expect you to use? (Note that authentication requests are not commonly signed.) If you're sending signed requests, enable the Connection Settings **Sign Request** toggle and make sure the **Signing Algorithm** value matches what the IdP expects.\n        \n    4.  Ask the IdP administrator to check for log entries that might provide information on the problem.\n        \n\n#### Logs don't show successful login event\n\nIn this case, the user successfully logs in with the identity provider, but the Auth0 logs do not show a successful login event.\n\n1.  Check the [Logs](https://manage.auth0.com/#/logs) and [Users](https://manage.auth0.com/#/users) pages in the Auth0 Dashboard to see if Auth0 shows a successful login event. If Auth0's logs don't show a successful login event, there is probably an issue with the SAML Authentication Assertion returned by the IdP or Auth0 is unable to consume the assertion.\n    \n2.  Check the information that Auth0 sends to the application by [capturing an HTTP trace of the login sequence](https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files) and analyzing the HTTP trace.\n    \n3.  You can view the HTTP trace in a HAR file analyzer, such as [Google's HAR Analyzer](https://toolbox.googleapps.com/apps/har_analyzer/).\n    \n    1.  Scan through the sequence of URLs invoked in the HTTP trace.\n        \n        1.  The first few will be URLs for your application.\n            \n        2.  There will then be a redirect to an Auth0 URL (such as `{yourDomain}`).\n            \n    2.  After one or more intervening URLs, there will be a POST back to Auth0 containing the SAML assertion with user information. The URL should be for the Assertion Consumer Service (ACS) of Auth0, which consumes the assertion and extracts the needed information.\n        \n    3.  Click on the row for the POST call in the HAR analyzer.\n        \n    4.  Switch to the POST Data tab, and look for the SAML response.\n        \n    5.  Copy and paste the SAML response into a [SAML debugger](https://samltool.io/).\n        \n    6.  Remove the \"SAML response\" at the beginning, as well as anything beginning with `&RelayState=` at the end.\n        \n4.  After retrieving and decoding the SAML message, check the following fields:\n    \n    | Field | Description |\n    | --- | --- |\n    | Destination | Check that the destination for the SAML response is the correct Auth0 Tenant and Connection (`https://{TENANT}.auth0.com/login/callback?connection={CONNECTION}`). |\n    | Status Field | This field should indicate success. (`<samlp:StatusCode Value=\"urn:oasis:names:tc:SAML:2.0:status:Success\"/>`). |\n    | Recipient | Check that the `<saml:SubjectConfirmation` Method element contains correct tenant and connection in the “Recipient” field (`https://{TENANT}.auth0.com/login/callback?connection={CONNECTION}`). |\n    | Audience | Check that the SAML Audience restriction field contains the correct tenant and connection information (`<saml:AudienceRestriction><saml:Audience>urn:auth0:{TENANT}:{CONNECTION}</saml:Audience>`). |\n    | Naming | The attribute identified by the `NameIdentifier` field should be known to the application. If it's not, the identifier should be some other attribute within the assertion (such as an internal IdP identifier for the user or an email address). |\n    | Signature Key | Check that the value indicated by the `X509Certificate` element matches the value provided to your connection. |\n    | Certificate | Compare the certificate sent to the one that you provided to the application |\n    \n\n#### User profile attributes are incorrect\n\nIn this case, the user successfully logs in with the IdP, the Auth0 logs show a successful login event, but the user's profile attributes are **not** correct.\n\nCheck to see if the user's Auth0 profile populated correctly:\n\n1.  Go to the [Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n    \n2.  Find and click on the specific user to open up their profile. If there are multiple rows for a given user, be sure to open up the record associated with the SAML Connection.\n    \n3.  On the user's profile, you can view their details in one of two ways. You can use the **Details** tab or the **Raw JSON** tab. This shows you what attributes Auth0 has received from the identity provider.\n    \n4.  If the attribute is missing, check to see if the attribute was included in the assertion. You can do this by decoding the SAML assertion, or you can enable debugging for the connection.\n    \n    1.  To enable debugging for the connection, navigate to [Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise).\n        \n    2.  Open the list of **SAML** IdP connections, click **Settings**, and enable **Debug Mode**.\n        \n        ![Troubleshoot SAML Connections Enable Debug Mode screen](https://images.ctfassets.net/cdy7uua7fh8z/1F6npTHy1P0c0ygXfbndBD/21719cf36172e6b3f8e26b1fe0e8e4fe/debug-connection.png)\n    3.  With **Debug Mode** enabled, **Success Login** log entries [in the Dashboard](https://manage.auth0.com/#/logs) will have an `original_profile` property listing every attribute included in the SAML assertion by the Identity Provider. You can use this list to see the information that the IdP is sending and to help you create the mappings. If the missing attribute is not in the assertion at all, please work with the IdP to make sure it is included.\n        \n5.  If an attribute value exists in the Auth0 user profile, but is not mapped to the right attribute, you can correct this via the Connection Mapping capability.\n    \n    1.  You can do this by navigating to [Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise).\n        \n    2.  Open the list of **SAML** IdP connections, click on **Settings**, and go to the **Mappings** tab.\n        \n        ![Troubleshoot SAML Connections Mappings Tab Screen](https://images.ctfassets.net/cdy7uua7fh8z/BPMjuhqE17E5vWcHukcKf/925d0a5150ae2f8214aefdf00f326be8/mappings.png)\n    3.  Within the provided editor, there is a JSON snippet you can edit to configure your mappings. The name on the left is the Auth0 user profile attribute to which the assertion value will be mapped. The value on the right is the identifier in the SAML assertion from which the attribute comes. When Auth0 incorporates unmapped SAML attributes into the user profile, attribute identifiers containing dots `.` are replaced with semicolons `:`. While configuring your mappings, ensure the identifiers you provide match those in the SAML assertion.\n        \n\n#### User cannot access the application\n\nIn this case, the user successfully logs in with the IdP, Auth0 logs show a successful login event, and the user's profile attributes are correct; but the user **cannot** access the application.\n\n1.  Check your application's log files to see if there are any error messages indicating why the user is unable to access the application. The two most common causes for this issue are:\n    \n    1.  Missing user profile information.\n        \n    2.  Incorrect or missing authorization information.\n        \n2.  Check the information that Auth0 sends to the application by [capturing an HTTP trace of the login sequence](https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files) and analyzing the HTTP trace. You can view the HTTP trace in a HAR file analyzer, such as [Google's HAR Analyzer](https://toolbox.googleapps.com/apps/har_analyzer/).\n    \n    1.  Scan through the sequence of URLs invoked in the HTTP trace.\n        \n        1.  The first few will be URLs for your application.\n            \n        2.  There will then be a redirect to an Auth0 URL (such as `{yourDomain}`).\n            \n    2.  After one or more intervening URLs, there will be a POST back to Auth0 containing the SAML assertion with user information. The URL should be for the Assertion Consumer Service (ACS) of Auth0, which consumes the assertion and extracts the needed information.\n        \n    3.  Click on the row for the POST call in the HAR analyzer.\n        \n    4.  Switch to the POST Data tab, and look for the SAML response.\n        \n    5.  Copy and paste the SAML response into a [SAML debugger](https://samltool.io/).\n        \n    6.  Remove the SAML response at the beginning, as well as anything beginning with `&RelayState=` at the end.\n        \n3.  After retrieving and decoding the SAML message, check the following fields:\n    \n    | Field | Description |\n    | --- | --- |\n    | Destination | Check that the destination for the SAML response is the correct Auth0 Tenant and Connection (`https://{TENANT}.auth0.com/login/callback?connection={CONNECTION}`). |\n    | Status Field | This field should indicate success. (`<samlp:StatusCode Value=\"urn:oasis:names:tc:SAML:2.0:status:Success\"/>`). |\n    | Recipient | Check that the `<saml:SubjectConfirmation` Method element contains correct tenant and connection in the “Recipient” field (`https://{TENANT}.auth0.com/login/callback?connection={CONNECTION}`). |\n    | Audience | Check that the SAML Audience restriction field contains the correct tenant and connection information (`<saml:AudienceRestriction><saml:Audience>urn:auth0:{TENANT}:{CONNECTION}</saml:Audience>`). |\n    | Naming | The attribute identified by the `NameIdentifier` field should be known to the application. If it's not, the identifier should be some other attribute within the assertion (such as an internal IdP identifier for the user or an email address). |\n    | Signature Key | Check that the value indicated by the `X509Certificate` element matches the value provided to your connection. |\n    | Certificate | Compare the certificate sent to the one that you provided to the application |\n    \n4.  If your authorization flow uses an OIDC-conformant protocol, you can capture a HAR trace and view it using [Google's HAR Analyzer](https://toolbox.googleapps.com/apps/har_analyzer/).\n    \n    1.  Scan through the sequence of URLs in the trace, and look for the following:\n        \n        1.  The first few will be URLs for your application.\n            \n        2.  There will then be a redirect to an Auth0 URL (such as `{yourDomain}`).\n            \n    2.  Further down is your application's callback URL. Make sure that it's correct.\n        \n    3.  Retrieve the ID Token from this call, and paste it into [a JWT decoder](https://jwt.io/). Check that the claims in the token contain the information needed by the application.\n        \n5.  If you're using an IdP-initiated flow (for example, the user starts at the identity provider in a portal application), be sure that:\n    \n    1.  The Assertion Consumer Service (ACS) URL at the identity provider includes the connection name (for example `https://{yourDomain}/login/callback?connection=CONNECTION_NAME`)\n        \n    2.  The IdP-initiated configuration tab for the Connection is properly filled in, including:\n        \n        1.  The IdP-initiated SSO behavior is set to **Accept Requests**;\n            \n        2.  The application to which the user should be sent;\n            \n        3.  The protocol between the application and Auth0 (which is not necessarily **SAML** like the connection, and most likely is **OpenID Connect**);\n            \n        4.  Any protocol-specific values to include in the query string, such as `scope`, `response_type`, `redirect_uri`, and `audience`. These values should match the ones expected by the application when using an SP-initiated flow.\n            \n    3.  Disable your rules temporarily to make sure that nothing is interfering with the login process.\n        \n    4.  If you've enabled multi-factor authentication (MFA), disable it temporarily to make sure that it is not interfering with the login process.\n        \n    5.  Check that the SAML Connection works in an SP-Initiated flow by using **Try** to run a Connection test.\n        \n\nThe error may appear as follows:\n\n`<samlp:Status> <samlp:StatusCodeValue=\"urn:oasis:names:tc:SAML:2.0:status:Responder\" /> </samlp:Status>`\n\n1.  Make sure that the signature algorithm on your Auth0 connection is the same as the configuration on the ADFS side: either `rsa-sha256` or `rsa-sha1`.\n    \n2.  Alternatively, you can contact your ADFS administrator to learn the expected signing method or to see if their logs contain further information about the reason for the error.\n    \n\n## Troubleshoot Auth0 as identity provider\n\nWhen troubleshooting a SAML login, there are four primary stages to check:\n\n*   Stage 1: The user is successfully redirected to IDP and is able to login.\n    \n*   Stage 2: After login with the IDP, the user returns to Auth0 with a successful login event recorded.\n    \n*   Stage 3: After a successful login event in Auth0, the user profile in Auth0 is correct.\n    \n*   Stage 4: The user successfully redirects back to the application and is able to access the application.\n    \n\n### Successful login event does not show up in logs\n\nIn this case, the user successfully logs in with the idp, but a successful login event does not show up in Auth0 logs.\n\n1.  If you're using an Auth0 Database Connection:\n    \n    1.  Check that the user exists and the entered password is correct.\n        \n    2.  Disable your rules temporarily to make sure that nothing is interfering with the login process.\n        \n    3.  If you've enabled multi-factor authentication (MFA), disable it temporarily to make sure that it is not interfering with the login process.\n        \n2.  If you're using an Auth0 Database Connection or a remote SAML connection, check that the SAML Connection works by using **Try** to run a Connection test.\n    \n\n### User profile attributes are incorrect\n\nIn this case, the user successfully logs in with the IdP, a successful login event shows up in Auth0 logs, but the user's profile attributes are incorrect. If the user:\n\n*   Appears to log in successfully.\n    \n*   The Logs and Users pages in the Auth0 Dashboard should successful login events\n    \n\nThe next step is to check that the user's profile contains the necessary user profile attributes.\n\n1.  Go to the [Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n    \n2.  Find and click on the specific user to open up their profile. If there are multiple rows for a given user, be sure to open up the record associated with the SAML Connection.\n    \n3.  On the user's profile, you can view their details in one of two ways. You can use the **Details** tab or the **Raw JSON** tab. This shows you what attributes Auth0 has received from the identity provider. If an attribute is missing, check with the identity provider to confirm that it has the attribute and that it is returning that attribute to Auth0.\n    \n\n### User cannot access the application\n\nIn this case, the user successfully logs in with the IdP, a successful login event shows up in Auth0 logs, and the user's profile attributes are correct, but the user cannot access the application.\n\n1.  Check to see if the user's Auth0 profile populated correctly:\n    \n    1.  Go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n        \n    2.  Find and click on the specific user to open up their profile. If there are multiple rows for a given user, be sure to open up the record associated with the SAML Connection.\n        \n    3.  On the user's profile, view their details in one of two ways. You can use the **Details** tab or the **Raw JSON** tab. This shows you what attributes Auth0 has received from the identity provider. Ensure that the profile includes all of the details required by the application. If a user attribute is missing, check with the identity provider to confirm that it has the attribute and that it is returning that attribute to Auth0.\n        \n2.  Check the application's log files to see if there are any error messages indicating why the user is unable to access the application. The two most common causes for this issue are missing user profile information or incorrect/missing authorization information.\n    \n3.  Check the information that Auth0 sends to the application by [capturing an HTTP trace of the login sequence](https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files) and analyzing the HTTP trace. You can view the HTTP trace in a HAR file analyzer, such as [Google's HAR Analyzer](https://toolbox.googleapps.com/apps/har_analyzer/).\n    \n    1.  Scan through the sequence of URLs invoked in the HTTP trace.\n        \n        1.  The first few will be URLs for your application.\n            \n        2.  There will then be a redirect to an Auth0 URL (such as `{yourDomain}`).\n            \n    2.  After one or more intervening URLs, there will be a POST back to Auth0 containing the SAML assertion with user information. The URL should be for the Assertion Consumer Service (ACS) of Auth0, which consumes the assertion and extracts the needed information.\n        \n    3.  Click on the row for the POST call in the HAR analyzer.\n        \n    4.  Switch to the POST Data tab, and look for the SAML response.\n        \n    5.  Copy and paste the SAML response into a [SAML debugger](https://samltool.io/).\n        \n    6.  Remove the SAML response at the beginning, as well as anything beginning with `&RelayState=` at the end.\n        \n4.  After retrieving and decoding the SAML message, check the following fields:\n    \n    | Field | Description |\n    | --- | --- |\n    | Destination | Check that the destination for the SAML response is the correct Auth0 Tenant and Connection (`https://{TENANT}.auth0.com/login/callback?connection={CONNECTION}`). |\n    | Status Field | This field should indicate success. (`<samlp:StatusCode Value=\"urn:oasis:names:tc:SAML:2.0:status:Success\"/>`). |\n    | Recipient | Check that the `<saml:SubjectConfirmation` Method element contains correct tenant and connection in the “Recipient” field (`https://{TENANT}.auth0.com/login/callback?connection={CONNECTION}`). |\n    | Audience | Check that the SAML Audience restriction field contains the correct tenant and connection information (`<saml:AudienceRestriction><saml:Audience>urn:auth0:{TENANT}:{CONNECTION}</saml:Audience>`). |\n    | Naming | The attribute identified by the `NameIdentifier` field should be known to the application. If it's not, the identifier should be some other attribute within the assertion (such as an internal IdP identifier for the user or an email address). |\n    | Signature Key | Check that the value indicated by the `X509Certificate` element matches the value provided to your connection. |\n    | Certificate | Compare the certificate sent to the one that you provided to the application |\n    \n5.  Ensure that the SAML assertion contains any additional information required by the application and that the information is present in the attributes expected by the application.\n    \n    1.  If you need to alter the assertion sent from Auth0 to your application, you can add or map attributes using rules.\n        \n        1.  Log into Auth0 and navigate to **Rules**.\n            \n        2.  Click **Create Rule** and, on the next page, choose the **Change your SAML configuration** template.\n            \n        3.  In the rules editor, uncomment the lines you want to use. Use lines 9-17 in the template to map attributes as needed. You can also add lines to implement mappings. The left side of each line specifies the identifier for the attribute in the assertion. The right side of each line references the Auth0 user profile attribute whose value will be used to populate the outgoing assertion sent to the application.\n            \n            ```\n            //context.samlConfiguration.mappings = {    \n                // \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\":      \"user_id\",    \n                // \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\":        \"email\",    \n                // \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\":                \"name\",    \n                // \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\":           \"given_name\",    \n                // \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\":             \"family_name\",    \n                // \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn\":                 \"upn\",    \n                // \"http://schemas.xmlsoap.org/claims/Group\":                                   \"groups\"    \n                // };\n            ```\n            \n\n### No active session(s) found matching LogoutRequest error\n\nThe `SessionIndex` and `NameID` values in the SAML Logout request need to match the ones received by the service provider in the original SAML assertion.\n\n## Contact support\n\nIf the troubleshooting steps listed above don't solve the issues, please request assistance from Auth0 by opening up a ticket in the Support Center. Be sure to include the following information:\n\n1.  The number of users experiencing this issue. One? All?\n    \n2.  Whether this issue involves a new setup or if it involves an existing integration that suddenly stopped working\n    \n3.  The number of applications affected\n    \n4.  What the expected behavior is, as well as what the current behavior is\n    \n5.  How far through the login sequence the user gets\n    \n6.  The name of the application registered in Auth0 and the identity protocol it uses\n    \n7.  The name of the Connection involved\n    \n8.  Whether or not you're using the Auth0 Lock widget (if so, what version?)\n    \n9.  Is a customized version of Lock used?\n    \n10.  An HTTP trace of the SSO interaction in [a .har file](https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files)\n    \n11.  An Auth0 log entry for the failed authentication\n    \n12.  An authentication log file from any third-party applications (such as Sharepoint) involved\n    \n\n## Learn more\n\n*   [SAML Single Sign-On Integrations](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations)\n*   [Test SAML SSO with Auth0 as Service Provider and Identity Provider](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/configure-auth0-as-service-and-identity-provider)",
  "title": "Troubleshoot SAML Configurations",
  "description": "Describes troubleshooting for SAML configuration issues.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/db2-script",
  "markdown": "# Login Script for IBM DB2\n\nIf you are integrating Auth0 with [IBM DB2](https://www.ibm.com/analytics/us/en/technology/db2), you can use the following script for your login process.\n\n```\nfunction login (email, password, callback) {\n  var ibmdb = require(\"ibm_db\");\n  var bcrypt = require('bcrypt');\n  var credentials = \"\";\n  credentials += \"DRIVER={DB2};\";\n  credentials += \"DATABASE=SAMPLE;\";\n  credentials += \"HOSTNAME=<db2host_url>;\";\n  credentials += \"UID=<user_name>;\";\n  credentials += \"PWD=<password>;\";\n  credentials += \"PORT=50001;\";\n  credentials += \"PROTOCOL=TCPIP\";\n  ibmdb.open(credentials, function(err, conn) {\n    if (err) callback(new Error(\"Error while trying to connect to auth source\"));\n    conn.query(\"select * from =<user_name>.USERS where email='\" + email + \"'\", function(err, data) {\n      if (err) callback(new Error(err));\n      else {\n      if (!bcrypt.compareSync(password, data[0].PASSWORDHASH)) return;\n      //map attributes to profile – sample below\n      var profile = {\n        user_id: data[0].ID,\n        nickname: data[0].EMAIL,\n        email: data[0].EMAIL,\n        given_name : data[0].FIRSTNAME,\n        family_name : data[0].LASTNAME\n      };\n      callback(null,profile);\n      }\n      conn.close(function() {\n      });\n    });\n  });\n}\n```",
  "title": "Login Script for IBM DB2",
  "description": "Provides a custom callback script for those integrating with IBM DB2.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/flexible-identifiers-and-attributes",
  "markdown": "# Flexible Identifiers and Attributes\n\nA **Flexible Identifier** is the attribute a user inputs on a login screen to authenticate themselves. You can choose from one or more types of identifiers: email and username are generally available, while the phone identifier is in our early access program. To learn more about Auth0 releases, review [Product Release Stages](https://auth0.com/docs/troubleshoot/product-lifecycle/product-release-stages).\n\n### Attribute and Identifier definitions\n\nFor this product, an **Attribute** is a piece of user data that can be stored, such as email, phone number, and username. All Identifiers are Attributes, but only specific attributes are Identifiers.\n\nAn **Identifier** is a unique Attribute that recognizes a distinct user in a given connection. Email, phone, and username can uniquely identify an individual and serve as Identifiers, while other attributes contribute to the user's profile without uniquely identifying a user.\n\n### Early Access changes and limitations\n\nFlexible Identifiers is available for early access with some limitations to the early access service:\n\n*   Flexible Identifiers including the phone attribute are only available with [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience) and you must [configure a phone provider](https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers).\n    \n*   You must configure [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) to use phone verification on signup.\n    \n*   The email address attribute must be enabled to use [Adaptive MFA](https://auth0.com/docs/secure/multi-factor-authentication/adaptive-mfa).\n    \n*   You must have email on the User Profile to use Signup invites for [Organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview).\n    \n*   End users blocked under Brute Force Protection cannot unblock themselves via an email link. Other methods are available. To learn more, [read Brute Force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection).\n    \n*   Flexible Identifiers moves the identifier field to the first login screen and changes the reset password prompt from email to username.\n    \n\n### Issues using Flexible Identifiers\n\nThe following is a list of potential issues you may encounter while configuring and managing Flexible Identifiers:\n\n*   If the scope `phone` is not specified in the authorization request by your application, you will not receive the `phone_number` claim. To learn more about scopes, [read Scopes](https://auth0.com/docs/get-started/apis/scopes).\n    \n*   Your Get User custom database action script must be valid when **Import Users to Auth0** is set to **on.** To learn more, [read Configure Automatic Migration from Your Database](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database).\n    \n*   Each user must be assigned a unique username and email address if **Custom Database with Import Mode** is set to **on**.\n    \n*   If you use the custom database action script Change Password and want to set `email` and `email_verified` to `True`, you must return the preferred `email_verified` state on the object. To learn more, [read Change Password](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password).\n    \n*   If you use a custom database connection with Import Users to Auth0 toggled off, you must align your user profile properties with the Auth0 normalized user profile. To learn more, [read Normalized User Profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles).\n    \n*   If you use a custom database connection with Import Users to Auth0 toggled on, Auth0 will check for uniqueness of `phone_number` and `phone_verified.`\n    \n*   Once you participate in the early access program, Identifier First prompts will change to display all identifiers on the first screen and remove your previous settings, and the Reset Password prompt will display the input field to Username instead of Email.\n    \n*   Familiarize yourself with best practices to avoid SMS Pumping attacks. To learn more, read our [whitepaper on SMS Pumping](https://www.okta.com/resources/whitepaper-handling-toll-fraud-and-sms-pumping-with-twilio-in-the-okta-customer-identity/).",
  "title": "Flexible Identifiers and Attributes",
  "description": "Describes limitations of Identifiers and Attributes. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/database-connections/activate-and-configure-attributes-for-flexible-identifiers",
  "markdown": "# Activate and Configure Attributes for Flexible Identifiers\n\n## Activate attributes configuration\n\n1.  Navigate to [**Auth0 Dashboard > Authentication > Database**](https://manage.auth0.com/#/connections/database), then select the Database Connection you’d like to activate from the list of **Database Connections**.\n    \n2.  Go to the **Attributes** tab and choose **Activate** on the **New Attributes Configuration** screen, then confirm you’ve tested your configuration in a Development environment. \n    \n3.  Select **Proceed**. The new configuration options become available.\n    \n\n![New EA feature, Attributes, needs to be activated by end users. ](https://images.ctfassets.net/cdy7uua7fh8z/3Ko21nSZQqR6MQHnsD0iMn/37a9b5e2818f893bf0e6283ad8e5bf49/2024-05-21_15-35-26.png)\n\n### Choose Attributes on a new connection\n\nAttributes are added to connections by navigating to [**Auth0 Dashboard > Authentication > Database**](https://auth0.com/docs/$manage_url/database).\n\nTo create a new connection, choose **\\+ Create DB Connection** and pick which Attributes to add. To add, configure, or remove Attributes in use by an existing connection, configure an existing connection, choose the **Attributes** tab and follow the instructions below.   \n\nDefault values are assigned to a new connection and can be edited after the connection has been created.\n\n| Setting | Value |\n| --- | --- |\n| Use `{attribute}` as Identifier | `True` |\n| Allow Signup with `{attribute}` | Required |\n| Require `{attribute}` on user profile | `True` |\n| Username Length | Min: 1 Max: 15 |\n| Allow usernames in email format | `False` |\n| Allow usernames in phone number format | `False` |\n\n### Add Attributes to an existing connection\n\nNavigate to the **Attributes** tab and choose **Activate**, then choose from the available Attributes and select the **Create** option.\n\n### Configure or remove existing Attributes on a connection\n\nAll Attributes can be changed or deleted from your Auth0 Dashboard. Users cannot log in, sign up or reset passwords using the removed Attribute, and a minimum of one Attribute must remain active on every connection.\n\nTo change or remove an Attribute, navigate to the Attributes tab, then choose the **...** menu button next to an Attribute and select **Configure** or **Remove** from the dropdown menu.\n\n### Revert a connection\n\nIf your tenant has `username` enabled as an Attribute, performing the following action requires you to modify your `username` settings. You'll need to reconfigure your username settings if you choose this path.\n\nTo revert a connection back to its original state, use the Management API to [PATCH the connection](https://auth0.com/docs/api/management/v2/connections/patch-connections-by-id) endpoint `/api/v2/connections/:id` with an empty `options` object like the example below.",
  "title": "Activate and Configure Attributes for Flexible Identifiers",
  "description": "Describes how identifiers like email and phone must be configured in a user tenant.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database",
  "markdown": "# Configure Automatic Migration from Your Database\n\nConfigure your Database connection to automatically migrate your users from an external user store to Auth0 with [custom database action scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/templates).\n\n## Configure Database connection as custom\n\nCreate a Database connection, and then set it to custom.\n\n1.  Go to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database) and select the database to view.\n    \n2.  Select the **Custom Database** view, and toggle on **Use my own database**.\n    \n    ![Auth0 Dashboard Authentication Database Connection Custom Database Settings Use Own Database Enabled](https://images.ctfassets.net/cdy7uua7fh8z/11HPAdVwJMmnWbzMVjHCJ8/c6583a1d8e3c02771fb81f2515f6e813/dashboard-connections-database-edit_view-custom-database_use-my-own-database.png)\n3.  Select the **Settings** view, toggle on **Import Users to Auth0**, and select **Save**.\n    \n    ![Dashboard Authentication Database Settings Import User to Auth0](https://images.ctfassets.net/cdy7uua7fh8z/1OqPgVsKGjRSRMNewmbU2y/4130babd9f0e6f1a38ecf565dd97e242/Screen_Shot_2021-05-18_at_8.33.49_PM.png)\n\n## Configure Database Action Scripts\n\nSelect the **Custom Database** view, and then locate **Database Action Scripts**.\n\n![Dashboard Authentication Database Connection Custom Database tab Database Action Scripts](https://images.ctfassets.net/cdy7uua7fh8z/4LBIvvjaABo51It4eVCmX3/4ef14765c79cc5b7ecfa3f3155caa9eb/Screen_Shot_2021-05-18_at_8.54.55_PM.png)\n\n### Login\n\nThe [Login](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login) script executes each time a user who is not found in the Auth0 attempts to log in. It verifies that the user exists in the external user store without reprompting the user for their password.\n\n### Get User\n\nThe [Get User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user) script executes after any of the following scenarios:\n\n*   A user initiates signup attempt.\n    \n*   A user initiates a change password flow.\n    \n*   A user enters their login identifier when using Identifier First + Biometrics.\n    \n*   The Management API [Update a User's Email or Username](https://auth0.com/docs/api/v2#!/Users/patch_users_by_id) or [Create User](https://auth0.com/docs/api/management/v2#!/Users/post_users) endpoint is called.\n    \n\nIf a user who has not been migrated confirms a password change and logs in successfully, their user profile will be created in the Auth0 with the new password. This user profile contains all the data returned in the Get User script. All subsequent logins for this user will be performed directly in Auth0.\n\n## Verify user migration is complete\n\nVerify that all users have been migrated to the Auth0 user store using the Auth0 Dashboard or the Auth0 Management API.\n\n1.  Go to [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users), and review the list of users.\n    \n2.  Use the Management API [List or Search Users](https://auth0.com/docs/api/v2#!/Users/get_users) endpoint.\n    \n\n## Disconnect external user store\n\nReconfigure the Database Action Scripts as no operation functions. This will prevent Auth0 from reaching out to your external user store to authenticate users.\n\n1.  Go to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database), and then select your Database connection.\n    \n2.  Switch to the **Custom Database** view, and then locate **Database Action Scripts.**\n    \n3.  Update the **Login** script.\n    \n    ```\n    function login (email, password, callback) {\n      return callback(null, null);\n    }\n    ```\n    \n4.  Update the **Get User** script.\n    \n    ```\n    function getByEmail (email, callback) {\n      return callback(null, null);\n    }\n    ```\n    \n\n## Troubleshoot user migration issues\n\nIf you encounter any issues with automatic migration, first read [Custom Database Connection and Action Script Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts).\n\n### User already exists\n\nThe most common scenarios when you may encounter this issue:\n\n*   You delete a user from your Database connection and then try to recreate the user.\n    \n*   You attempt to create a new user on your Database connection when the user already exists in your external user store.\n    \n*   A user's migration process was interrupted.\n    \n\nDuring the user migration process, Auth0 first creates a partial user profile in an internal user store, and then creates a full user profile on your Database connection. If an issue occurs that prevents this full user profile from being created, you may encounter the `The user already exists` error.\n\nYou can usually resolve this issue by deleting the user from the Database connection, deleting the user from the internal user store, and then reattempting the migration process.\n\n1.  Check the `console.log()` statements with the [Real-time Webtask Logs extension](https://auth0.com/docs/customize/extensions/real-time-webtask-logs).\n    \n2.  Delete the user with the Management API [Delete a User](https://auth0.com/docs/api/management/v2#!/Users/delete_users_by_id) endpoint.\n    \n3.  Delete the user with the Management API [Delete a Connection User](https://auth0.com/docs/api/management/v2#!/Connections/delete_users_by_email) endpoint.\n    \n4.  Instruct the user to log in or change their password to reattempt migration.\n    \n\n### Missing metadata\n\nIf a user is interrupted during the login or change password flow that initiates the migration process, Auth0 may not be able to transfer their metadata (`user_metadata` or `app_metadata`) along with their other profile data.\n\nYou can mitigate this scenario by creating an [Action](https://auth0.com/docs/customize/actions) that verifies the user's profile is missing metadata, retrieves it from the external use store, and then stores it in Auth0.\n\n## Learn more\n\n*   [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports)\n*   [User Import / Export Extension](https://auth0.com/docs/manage-users/user-migration/user-import-export-extension)",
  "title": "Configure Automatic Migration from Your Database",
  "description": "Learn how to enable automatic user migration with your custom database.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/okta",
  "markdown": "# Connect Your Auth0 Application with Okta Workforce Enterprise Connection\n\nIf your Auth0 domain name is not shown above and you are not using our [custom domains](https://auth0.com/docs/customize/custom-domains) feature, your domain name is a concatenation of your tenant name, your regional subdomain, and `auth0.com`, separated by the dot (`.`) symbol.\n\nFor example, if your tenant name is `exampleco-enterprises`, and your tenant is in the US region, your Auth0 domain name would be `exampleco-enterprises.us.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.us.auth0.com/login/callback`.\n\nHowever, if your tenant is in the US region and was created before June 2020, then your Auth0 domain name would be `exampleco-enterprises.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.auth0.com/login/callback`.\n\nIf you are using [custom domains](https://auth0.com/docs/customize/custom-domains), your **Redirect URI** would be `https://<YOUR CUSTOM DOMAIN>/login/callback`.",
  "title": "Connect Your Auth0 Application with Okta Workforce Enterprise Connection",
  "description": "Learn how to connect to Okta Workforce Identity Cloud as an OpenID Connect (OIDC) Identity Provider using an enterprise connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections",
  "markdown": "# Enable Enterprise Connections\n\nYou can enable enterprise connections for applications using the Auth0 Dashboard. To enable your enterprise connection, you should have already set it up.\n\n1.  Go to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select the connection type to view.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Select the name of the connection to view.\n    \n    ![Dashboard - Connections - Enterprise - AD/LDAP - List](https://images.ctfassets.net/cdy7uua7fh8z/1sxfMEARFGmA6cPMlWkx3c/24224f426feac774b7278a2a8bbdf162/dashboard-connections-enterprise-adldap-list_ssl.png)\n3.  Select the **Applications** view, and enable or disable the connection for the appropriate application(s).\n    \n    ![Dashboard - Connections - Enterprise - Applications](https://images.ctfassets.net/cdy7uua7fh8z/2Jwoyem76rmja1sveD88It/d66bca3bcd05d50f7cd85f772bf18a53/dashboard-connections-enterprise-adldap-edit_view-connections_ssl.png)\n\nWhen you set up your enterprise IdP connection, remember that the `connection` parameter passed to Auth0's `/authorize,` `/whr,` or `/wsfed` endpoint will redirect to the upstream IdP **unless** it's connected via database or Active Directory.\n\n## Learn more\n\n*   [Test Enterprise Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections)",
  "title": "Enable Enterprise Connections",
  "description": "Describes how to enable enterprise connections for applications using the Auth0 Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc",
  "markdown": "# Configure PKCE and Claim Mapping for OIDC Connections\n\nEnterprise connections using [OpenID Connect](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/oidc) or O[kta Workforce](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/okta) as the identity provider can support Proof Key for Code Exchange (PKCE), as well as attribute and token mapping. \n\n## Configure PKCE for OIDC connections\n\nOpenID Connect and Okta Workforce connections are automatically configured to support Proof Key for Code Exchange (PKCE).\n\nIf your OIDC identity provider (IdP) supports PKCE through OIDC Discovery metadata, Auth0 will use the strongest algorithm available by default. For more information on OIDC Discovery metadata, review [OpenID’s documentation](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata). \n\n### View PKCE configuration for a connection\n\nYou can view the PKCE configuration for a specific connection through the Auth0 Dashboard:\n\n1.  Navigate to **Authentication > Enterprise** and choose your OIDC provider (either OpenID Connect or Okta Workforce).\n    \n2.  Select the **Settings** tab.\n    \n3.  In the **General** section, locate the **Connection Profile** field.\n    \n\n![The Connection Profile field available under Settings for Enterprise connections](https://images.ctfassets.net/cdy7uua7fh8z/3kickfUGNFHHjwIu2AWzVf/c7db941828eb458ba8668a75fd11a5a5/Connection_Profile_screenshot.png)\n\nYou can manage the PKCE configuration for a connection through the Auth0 Dashboard:\n\n1.  Navigate to [**Dashboard > Authenticate >Enterprise**](https://manage.auth0.com/#/connections/enterprise) and choose your OIDC provider (either OpenID Connect or Okta Workforce).\n    \n2.  Select the **Settings** tab and locate the **Connection Profile** field.\n    \n3.  Set the `pkce` property to one of the [supported values](#supported-pkce-configuration-values) listed below.\n    \n4.  Select **Save**.\n    \n\n### Supported PKCE configuration values\n\nAuth0 supports the following values for PKCE configuration:\n\n| Value | Description |\n| --- | --- |\n| `auto` | Default value. Uses the strongest algorithm available. |\n| `s256` | Uses the SHA-256 algorithm. Auth0 does not currently support RS512 tokens. |\n| `plain` | Uses plaintext as described in the [PKCE specification](https://www.rfc-editor.org/rfc/rfc7636#section-4.2 \"Proof Key for Code Exchange by OAuth Public Clients - Code Challenge\"). |\n| `disabled` | Disables support for PKCE. |\n\n## Map Claims for OIDC connections\n\nOpenID Connect and Okta Workforce connections can automatically map claims received from the identity provider (IdP). You can configure this mapping through a library template provided by Auth0 or by entering your own template directly.\n\n### Mapping template properties\n\nMapping templates support the `options.attribute_map` object properties listed below. Templates must be in JSON format with valid key/value pairs.\n\n| **Property** | **Required?** | **Description** |\n| --- | --- | --- |\n| `mapping_mode` | Required | Method used to map incoming claims. |\n| `userinfo_scope` | Optional | Scopes to send to the IdP's Userinfo endpoint. |\n| `attributes` | Required | Object containing mapping details for incoming claims. |\n\n### Mapping mode\n\nThe `mapping_mode` property defines the method used to map incoming claims from the IdP to the Auth0 user profile. `mapping_mode` supports the following values:\n\n| **Value** | **Description** |\n| --- | --- |\n| `use_map` | Uses the provided template to map the data. |\n| `bind_all` | Copies all data elements provided by the IdP. |\n\n#### Restricted claims\n\nSome claims are reserved for use by Auth0; such claims cannot be used as attribute keys for user profiles.\n\nIf you set the `mapping_mode` property to `bind_all`, your IdP may attempt to map values to one or more of these restricted claims. While this does not prevent users from authenticating on your connection, values associated with restricted claims are **not** mapped to the Auth0 user profile.\n\nIf you set `mapping_mode` to `use_map`, you can map the incoming restricted claim to a valid one:\n\n```\n\"attribute_map\": {\n        \"mapping_mode\": \"use_map\",\n        \"attributes\": {\n            \"amr\": \"{context.tokenset.amr}\" // `amr` is a restricted claim and will not be mapped\n            \"federated_amr\": \"{context.tokenset.amr}\" // `federated_amr` is not a restricted claim and will be mapped\n        }\n    }\n```\n\nFor a complete list of restricted claims, review [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\n### UserInfo scope\n\nThe `userinfo_scope` property defines the scopes that Auth0 sends to the IdP’s UserInfo endpoint when requested.\n\nFor example, if you want to send the standard OIDC scopes and the `groups` scope when requesting the UserInfo endpoint, you can do so as follows:\n\n```\n\"attribute_map\": {\n    . . .\n    \"userinfo_scope\": \"openid email profile groups\",\n    . . .\n}\n```\n\n### Attributes\n\nThe `attributes` property is an object containing mapping information that allows Auth0 to interpret incoming claims from the IdP. Mapping information must be provided as key/value pairs.\n\nThe key to the left corresponds to an Auth0 user profile attribute. The value to the right represents the incoming claim from the IdP, which can be expressed as a literal value, a dynamic context object, or a combination of both. Dynamic context objects are template expressions written in the familiar `${variable}` format.\n\n```\n\"attribute_map\": {\n    . . .\n    \"attributes\": {\n        \"name\": \"${context.tokenset.name}\",\n        \"email\": \"${context.tokenset.email}\",\n        \"username\": \"${context.tokenset.preferred_username}\"\n    }\n}\n```\n\n#### Literal values\n\nA literal value is a static value mapped to a specific profile attribute for all users on your connection.\n\nFor example, if you are configuring a SalesForce OIDC connection and want to assign the same SFDC Community ID to all user profiles, you can do so as follows:\n\n```\n\"attribute_map\": {\n    . . .\n    \"attributes\": {\n        …\n        \"sf_community_id\": \"3423409219032-32\"\n    }\n}\n```\n\n#### Context object\n\nYou can map dynamic values to user profile attributes by using the `context` object. This allows you to store unique values for individual profiles, as opposed to literal values that are static across all profiles.\n\nThe `context` object supports the following properties:\n\n| Property | Description |\n| --- | --- |\n| `context.connection` | Contains the following properties:*   `id`: The connection’s unique identifier (for example, `con_4423423423432423`).<br>  <br>*   `strategy`: The connection’s strategy (for example, `oidc`). |\n| `context.tokenset` | Contains the following properties:*   `access_token`: The entire validated access token sent by the IdP.<br>  <br>*   `<claim name>`: Any ID token claim sent by the IdP. |\n| `context.userinfo` | Contains the following properties:*   `<claim name>`: Any available claim provided by the IdP’s UserInfo endpoint. |\n\n### Examples\n\n#### Simple user claim mapping\n\nThis example demonstrates how to map common user claims to the Auth0 user profile with data from the ID token:\n\n```\n\"attribute_map\": {\n    . . .\n    \"attributes\": {\n        \"name\": \"${context.tokenset.name}\",\n        \"email\": \"${context.tokenset.email}\",\n        \"username\": \"${context.tokenset.preferred_username}\"\n    }\n}\n```\n\n#### Group claim mapping\n\nThis example shows how to map groups to the Auth0 user profile from the incoming IdP:\n\n```\n\"attribute_map\": {\n    . . .\n    \"attributes\": {\n        \"federated_groups\": \"${context.userinfo.groups}\",\n        \"federated_locale\": \"${context.userinfo.locale}\",\n        \"federated_zoneinfo\": \"${context.userinfo.zoneinfo}\"\n    }\n}\n```\n\n#### Combining literal values and context objects\n\nThis example demonstrates how to combine literal values and dynamic template expressions to map a complex value to an attribute on the Auth0 user profile:\n\n```\n\"attribute_map\":{\n    . . .\n    \"attributes\": {\n        \"alt_id\": \"user_email|${context.tokenset.email}\",\n        . . .\n    }\n}\n```",
  "title": "Configure PKCE and Claim Mapping for OIDC Connections",
  "description": "Configure Proof Key for Code Exchange (PKCE) and mapping templates for OpenID Connect and Okta Workforce connections.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections",
  "markdown": "# Test Enterprise Connections\n\nYou can test enterprise connections for applications using Auth0's Dashboard.\n\nTo properly test, you should have already [set up your enterprise connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections).\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select the connection type to view.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Select the **Try** arrow next to the connection you want to test.\n    \n    ![Dashboard - Connections - Enterprise - AD/LDAP - List](https://images.ctfassets.net/cdy7uua7fh8z/1sxfMEARFGmA6cPMlWkx3c/24224f426feac774b7278a2a8bbdf162/dashboard-connections-enterprise-adldap-list_ssl.png)\n3.  Log in and consent to allow access to your app. If you have configured everything correctly, you will see the **It Works!** page.\n    \n    ![Dashboard - Connections - Database - Try - Success](https://images.ctfassets.net/cdy7uua7fh8z/5DWJWLf8zvZJH0rSlhK0cr/f33377edf6f82f17e11e08ec30d8d75a/connection-social-try-success.png)",
  "title": "Test Enterprise Connections",
  "description": "Learn how to test enterprise connections for applications using the Auth Dashboard.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/troubleshoot/customer-support/operational-policies/entity-limit-policy",
  "markdown": "# Entity Limit Policy\n\nEntities in Auth0 are tenant configuration elements such as applications, connections, rules, and API resource servers.\n\n## Notifications\n\nAuth0 provides notifications to you when you are approaching (80%) and when you have reached your respective entity limits (100% or higher). We will also provide messages to prevent you from attempting to configure entities that would be rejected because they would put you over the platform limit. Here is an example of a message you would see if you reached your connection limit for the platform:\n\n![Entity Limit Policy Entity Limit Reached Screen](https://images.ctfassets.net/cdy7uua7fh8z/6wMoudiAXBtu7EXMXzCAlb/0cc3a52f8a0f58c1a8fb8eac9fd5cca2/entity-limit-reached.png)\n\nEntity counts may take a few seconds to update. If you see a warning that you believe is in error, try again after a few seconds, or contact support if the issue persists.\n\n## Global subscription plan limits\n\nThis section lists limits that apply to all subscription plans.\n\nThe Organizations feature is subject to the following limits:\n\n| **Entity** | **Maximum** |\n| --- | --- |\n| Organizations per tenant | 100,000 |\n| Members per organization | 100,000 |\n| Connections per organization | 10  |\n| Role assignments per organization member | 50  |\n\nCustomers on Enterprise plans can request increased entity limits for Organizations per tenant and Organization members per Organization by [contacting support](https://support.auth0.com/).\n\nThese limits can be increased to 2,000,000 Organizations per tenant and 2,000,000 Organization members per Organization on public cloud. On private cloud instances, these entities are unlimited.\n\nThe Authorization Core Role-Based Access Control (RBAC) feature set is subject to the following limits:\n\n| **Feature** | **Limit** |\n| --- | --- |\n| Roles per tenant | 1000 |\n| Scopes per API | 1000 |\n| Roles per user | 50  |\n| Permissions per user | 1000 |\n| Permissions per role | 1000 |\n\nNote that limitations on permissions per user affect those assigned directly. Technically, a user could have more permissions than noted if the permissions were assigned to different roles and then the roles were assigned to the user.\n\nRefresh tokens are also subject to limitation. Refresh tokens have a limit of 200 valid tokens per user per application. If the limit is reached and a new refresh token is created, the system revokes or deletes the oldest token for that user in the application. Revoked tokens and expired tokens do not count against the limit.\n\n| **Token type** | **Per user / application** |\n| --- | --- |\n| Refresh | 200 |\n\n## Enterprise subscription limits\n\n| **Entity** | **Maximum** |\n| --- | --- |\n| API Resource Servers | 100,000 |\n| Application credentials | 2,000 |\n\n## Self-service paid subscription limits\n\n| **Entity** | **Maximum** |\n| --- | --- |\n| Applications | 100 |\n| Connections | 100 |\n| Rules | 10  |\n| API Resource Servers | 100 |\n\n## Free subscription limits\n\n| **Entity** | **Maximum** |\n| --- | --- |\n| Applications | 10  |\n| Connections | 10  |\n| Rules | 3   |\n| API Resource Servers | 10  |\n| Admins (including on Teams) | 3   |",
  "title": "Entity Limit Policy",
  "description": "Describes Auth0's tenant entity limit policy for subscribers.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/oidc",
  "markdown": "# Connect to OpenID Connect Identity Provider\n\n## Prerequisites\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n    *   Select an appropriate **Application Type**.\n        \n    *   Add an **Allowed Callback URL** of **`{https://yourApp/callback}`**.\n        \n    *   Make sure your Application's [Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n        \n\n## Steps\n\nTo connect your application to an OIDC Identity Provider, you must:\n\n1.  [Set up your app in the OpenID Connect Identity Provider](#set-up-your-app-in-the-openid-connect-identity-provider)\n    \n2.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0)\n    \n3.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application)\n    \n4.  [Test the connection](#test-the-connection)\n    \n\n## Set up your app in the OpenID Connect Identity Provider\n\nTo allow users to log in using an OIDC Identity Provider, you must register your application with the IdP. The process of doing this varies depending on the OIDC Identity Provider, so you will need to follow your IdP's documentation to complete this task.\n\nGenerally, you will want to make sure that at some point you enter your callback URL: `https://{yourDomain}/login/callback`.\n\n#### Find your Auth0 domain name for redirects\n\nIf your Auth0 domain name is not shown above and you are not using our [custom domains](https://auth0.com/docs/customize/custom-domains) feature, your domain name is a concatenation of your tenant name, your regional subdomain, and `auth0.com`, separated by the dot (`.`) symbol.\n\nFor example, if your tenant name is `exampleco-enterprises`, and your tenant is in the US region, your Auth0 domain name would be `exampleco-enterprises.us.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.us.auth0.com/login/callback`.\n\nHowever, if your tenant is in the US region and was created before June 2020, then your Auth0 domain name would be `exampleco-enterprises.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.auth0.com/login/callback`.\n\nIf you are using [custom domains](https://auth0.com/docs/customize/custom-domains), your **Redirect URI** would be `https://<YOUR CUSTOM DOMAIN>/login/callback`.\n\nDuring this process, your OIDC Identity Provider will generate a unique identifier for the registered API, usually called a **Client ID** or an **Application ID**. Make note of this value; you will need it later.\n\n## Create an enterprise connection in Auth0\n\nNext, you will need to create and configure a OIDC Enterprise Connection in Auth0. Make sure you have the **Application (client) ID** and the **Client secret** generated when you set up your app in the OIDC provider.\n\n### Create an enterprise connection using the Dashboard\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **Open ID Connect**, and click its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create:**\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant. Once set, this name can't be changed. |\n    | **Issuer URL** | URL where Auth0 can find the **OpenID Provider Configuration Document**, which should be available in the `/.well-known/openid-configuration` endpoint. You can enter the base URL or the full URL. You will see a green checkmark if it can be found at that location, a red mark if it cannot be found, or an error message if the file is found but the required information is not present in the configuration file. |\n    | **Client ID** | Unique identifier for your registered application. Enter the saved value of the **Client ID** for the app you registered with the OIDC Identity Provider. |\n    | **Callback URL** | URL to which Auth0 redirects users after they authenticate. Ensure that this value is configured for the app you registered with the OIDC Identity Provider. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    \n    #### Find your Auth0 domain name for redirects\n    \n    If your Auth0 domain name is not shown above and you are not using our [custom domains](https://auth0.com/docs/customize/custom-domains) feature, your domain name is a concatenation of your tenant name, your regional subdomain, and `auth0.com`, separated by the dot (`.`) symbol.\n    \n    For example, if your tenant name is `exampleco-enterprises`, and your tenant is in the US region, your Auth0 domain name would be `exampleco-enterprises.us.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.us.auth0.com/login/callback`.\n    \n    However, if your tenant is in the US region and was created before June 2020, then your Auth0 domain name would be `exampleco-enterprises.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.auth0.com/login/callback`.\n    \n    If you are using [custom domains](https://auth0.com/docs/customize/custom-domains), your **Redirect URI** would be `https://<YOUR CUSTOM DOMAIN>/login/callback`.\n    \n    ![Enter OIDC Connection Details](https://images.ctfassets.net/cdy7uua7fh8z/4PO4eBhEM3R0ZMhaTlDVfB/4e1c4cebafd9c8159a4c4913c12b9baf/OpenID_Connect.png)\n3.  In the **Settings** view, make additional configuration adjustments, if necessary.\n    \n    | Field | Description |\n    | --- | --- |\n    | **Issuer URL** | Click **Show Issuer Details** to view the Issuer URL **Advanced Settings** and make adjustments. |\n    | **Type** | Set to **Front Channel** or **Back Channel**. Front Channel uses the OIDC protocol with `response_mode=form_post` and `response_type=id_token`. Back Channel uses `response_type=code`. |\n    | **Scopes** | A comma-separated list of Auth0 scopes to request when connecting to the Identify Provider. This will affect the data stored in the user profile. You are required to include at least the `openid` scope. Note that the connection does not call `/userinfo` endpoint and expects the user claims to be present in the `id_token`. |\n    \n4.  In the **Login Experience** view, configure how users log in with this connection.\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Identity Provider domains** | A comma-separated list of the domains that can be authenticated in the Identify Provider. This is only applicable when using [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication with Universal Login. |\n    | **Add button** (Optional) | Display a button for this connection in the login page. |\n    | **Button display name** (Optional) | Text used to customize the login button for Universal Login. When set the button reads: \"Continue with {Button display name}\". |\n    | **Button logo URL** (Optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    \n5.  Select **Save Changes**.\n    \n\n### Create an enterprise connection using the Management API\n\nThese examples will show you the variety of ways you can create the \\[connection\\](/connections) using Auth0's Management API. You ca configure the connection by either providing a metadata URI or by setting the OIDC URLs explicitly.\n\n#### Use front-channel with discovery endpoint\n\n*   [cURL](#7f7b717752fe46e88d88b77f2f5f0e22_shell)\n*   [C#](#7f7b717752fe46e88d88b77f2f5f0e22_csharp)\n*   [Go](#7f7b717752fe46e88d88b77f2f5f0e22_go)\n*   [Java](#7f7b717752fe46e88d88b77f2f5f0e22_java)\n*   [Node.JS](#7f7b717752fe46e88d88b77f2f5f0e22_node)\n*   [Obj-C](#7f7b717752fe46e88d88b77f2f5f0e22_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --data '{ \"strategy\": \"oidc\", \"name\": \"CONNECTION_NAME\", \"options\": { \"type\": \"front_channel\", \"discovery_url\": \"https://IDP_DOMAIN/.well-known/openid-configuration\", \"client_id\" : \"IDP_CLIENT_ID\",  \"scopes\": \"openid profile\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"undefined\", \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'},\n  data: {\n    strategy: 'oidc',\n    name: 'CONNECTION_NAME',\n    options: {\n      type: 'front_channel',\n      discovery_url: 'https://IDP_DOMAIN/.well-known/openid-configuration',\n      client_id: 'IDP_CLIENT_ID',\n      scopes: 'openid profile'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"oidc\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"type\": @\"front_channel\", @\"discovery_url\": @\"https://IDP_DOMAIN/.well-known/openid-configuration\", @\"client_id\": @\"IDP_CLIENT_ID\", @\"scopes\": @\"openid profile\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\nlet parameters = [\n  \"strategy\": \"oidc\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\n    \"type\": \"front_channel\",\n    \"discovery_url\": \"https://IDP_DOMAIN/.well-known/openid-configuration\",\n    \"client_id\": \"IDP_CLIENT_ID\",\n    \"scopes\": \"openid profile\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Use back-channel with discovery endpoint\n\n*   [cURL](#d537210b80504cae8cfdab7d0a1b3305_shell)\n*   [C#](#d537210b80504cae8cfdab7d0a1b3305_csharp)\n*   [Go](#d537210b80504cae8cfdab7d0a1b3305_go)\n*   [Java](#d537210b80504cae8cfdab7d0a1b3305_java)\n*   [Node.JS](#d537210b80504cae8cfdab7d0a1b3305_node)\n*   [Obj-C](#d537210b80504cae8cfdab7d0a1b3305_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --data '{ \"strategy\": \"oidc\", \"name\": \"CONNECTION_NAME\", \"options\": { \"type\": \"back_channel\", \"discovery_url\": \"https://IDP_DOMAIN/.well-known/openid-configuration\", \"client_id\" : \"IDP_CLIENT_ID\", \"client_secret\" : \"IDP_CLIENT_SECRET\", \"scopes\": \"openid profile\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"undefined\", \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"scopes\\\": \\\"openid profile\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"scopes\\\": \\\"openid profile\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"scopes\\\": \\\"openid profile\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'},\n  data: {\n    strategy: 'oidc',\n    name: 'CONNECTION_NAME',\n    options: {\n      type: 'back_channel',\n      discovery_url: 'https://IDP_DOMAIN/.well-known/openid-configuration',\n      client_id: 'IDP_CLIENT_ID',\n      client_secret: 'IDP_CLIENT_SECRET',\n      scopes: 'openid profile'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"oidc\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"type\": @\"back_channel\", @\"discovery_url\": @\"https://IDP_DOMAIN/.well-known/openid-configuration\", @\"client_id\": @\"IDP_CLIENT_ID\", @\"client_secret\": @\"IDP_CLIENT_SECRET\", @\"scopes\": @\"openid profile\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"scopes\\\": \\\"openid profile\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\nlet parameters = [\n  \"strategy\": \"oidc\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\n    \"type\": \"back_channel\",\n    \"discovery_url\": \"https://IDP_DOMAIN/.well-known/openid-configuration\",\n    \"client_id\": \"IDP_CLIENT_ID\",\n    \"client_secret\": \"IDP_CLIENT_SECRET\",\n    \"scopes\": \"openid profile\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Use back-channel specifying issuer settings\n\n*   [cURL](#da15fa3d6cd3453f96ffc0b91876b73d_shell)\n*   [C#](#da15fa3d6cd3453f96ffc0b91876b73d_csharp)\n*   [Go](#da15fa3d6cd3453f96ffc0b91876b73d_go)\n*   [Java](#da15fa3d6cd3453f96ffc0b91876b73d_java)\n*   [Node.JS](#da15fa3d6cd3453f96ffc0b91876b73d_node)\n*   [Obj-C](#da15fa3d6cd3453f96ffc0b91876b73d_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --data '{ \"strategy\": \"oidc\", \"name\": \"CONNECTION_NAME\", \"options\": { \"type\": \"back_channel\", \"issuer\": \"https://IDP_DOMAIN\", \"authorization_endpoint\": \"https://IDP_DOMAIN/authorize\", \"client_secret\" : \"IDP_CLIENT_SECRET\", \"client_id\" : \"IDP_CLIENT_ID\",  \"scopes\": \"openid profile\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"undefined\", \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'},\n  data: {\n    strategy: 'oidc',\n    name: 'CONNECTION_NAME',\n    options: {\n      type: 'back_channel',\n      issuer: 'https://IDP_DOMAIN',\n      authorization_endpoint: 'https://IDP_DOMAIN/authorize',\n      client_secret: 'IDP_CLIENT_SECRET',\n      client_id: 'IDP_CLIENT_ID',\n      scopes: 'openid profile'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"oidc\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"type\": @\"back_channel\", @\"issuer\": @\"https://IDP_DOMAIN\", @\"authorization_endpoint\": @\"https://IDP_DOMAIN/authorize\", @\"client_secret\": @\"IDP_CLIENT_SECRET\", @\"client_id\": @\"IDP_CLIENT_ID\", @\"scopes\": @\"openid profile\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\nlet parameters = [\n  \"strategy\": \"oidc\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\n    \"type\": \"back_channel\",\n    \"issuer\": \"https://IDP_DOMAIN\",\n    \"authorization_endpoint\": \"https://IDP_DOMAIN/authorize\",\n    \"client_secret\": \"IDP_CLIENT_SECRET\",\n    \"client_id\": \"IDP_CLIENT_ID\",\n    \"scopes\": \"openid profile\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Use front-channel specifying issuer settings\n\n*   [cURL](#57b6ee6341ae4f398e9c3b0cf71df0e6_shell)\n*   [C#](#57b6ee6341ae4f398e9c3b0cf71df0e6_csharp)\n*   [Go](#57b6ee6341ae4f398e9c3b0cf71df0e6_go)\n*   [Java](#57b6ee6341ae4f398e9c3b0cf71df0e6_java)\n*   [Node.JS](#57b6ee6341ae4f398e9c3b0cf71df0e6_node)\n*   [Obj-C](#57b6ee6341ae4f398e9c3b0cf71df0e6_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --data '{ \"strategy\": \"oidc\", \"name\": \"CONNECTION_NAME\", \"options\": { \"type\": \"front_channel\", \"issuer\": \"https://IDP_DOMAIN\", \"authorization_endpoint\": \"https://IDP_DOMAIN/authorize\", \"token_endpoint\": \"https://IDP_DOMAIN/oauth/token\", \"client_id\" : \"IDP_CLIENT_ID\",  \"scopes\": \"openid profile\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"undefined\", \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"token_endpoint\\\": \\\"https://IDP_DOMAIN/oauth/token\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"token_endpoint\\\": \\\"https://IDP_DOMAIN/oauth/token\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"token_endpoint\\\": \\\"https://IDP_DOMAIN/oauth/token\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'},\n  data: {\n    strategy: 'oidc',\n    name: 'CONNECTION_NAME',\n    options: {\n      type: 'front_channel',\n      issuer: 'https://IDP_DOMAIN',\n      authorization_endpoint: 'https://IDP_DOMAIN/authorize',\n      token_endpoint: 'https://IDP_DOMAIN/oauth/token',\n      client_id: 'IDP_CLIENT_ID',\n      scopes: 'openid profile'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"oidc\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"type\": @\"front_channel\", @\"issuer\": @\"https://IDP_DOMAIN\", @\"authorization_endpoint\": @\"https://IDP_DOMAIN/authorize\", @\"token_endpoint\": @\"https://IDP_DOMAIN/oauth/token\", @\"client_id\": @\"IDP_CLIENT_ID\", @\"scopes\": @\"openid profile\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"token_endpoint\\\": \\\"https://IDP_DOMAIN/oauth/token\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"token_endpoint\\\": \\\"https://IDP_DOMAIN/oauth/token\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"token_endpoint\\\": \\\"https://IDP_DOMAIN/oauth/token\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\nlet parameters = [\n  \"strategy\": \"oidc\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\n    \"type\": \"front_channel\",\n    \"issuer\": \"https://IDP_DOMAIN\",\n    \"authorization_endpoint\": \"https://IDP_DOMAIN/authorize\",\n    \"token_endpoint\": \"https://IDP_DOMAIN/oauth/token\",\n    \"client_id\": \"IDP_CLIENT_ID\",\n    \"scopes\": \"openid profile\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Configure PKCE and claims mapping\n\nThis Enterprise connection can support Proof Key for Code Exchange (PKCE), as well as attribute and token mapping. To learn more, review [Configure PKCE and Claim Mapping for OIDC Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc).\n\n## Enable the enterprise connection for your Auth0 application\n\nTo use your new enterprise connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n## Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).\n\n## Manually configure Issuer metadata\n\nIf you click **Show Issuer Details** on the Issuer URL endpoint, you can see the data and adjust it if you need to.\n\n## Federate with Auth0\n\nThe OpenID Connect enterprise connection is extremely useful when federating to another Auth0 tenant. Just enter your Auth0 tenant URL (for example, `https://<tenant>.us.auth0.com`) in the **Issuer** field, and enter the Client ID for any application in the tenant to which you want to federate in the **Client ID** field.",
  "title": "Connect to OpenID Connect Identity Provider",
  "description": "Learn how to connect to OpenID Connect (OIDC) Identity Providers using an enterprise connection.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/saml",
  "markdown": "# SAML\n\nThe Security Assertion Markup Language (SAML) protocol is an open-standard, XML-based framework for authentication and authorization between two entities without a password:\n\n*   **Service provider** (SP) agrees to trust the identity provider to authenticate users.\n    \n*   **Identity provider** (IdP) authenticates users and provides to service providers an authentication assertion that indicates a user has been authenticated.\n    \n\nAuth0 supports the SAML protocol and can serve as the IdP, the SP, or both including:\n\n*   SAML2 web applications\n    \n*   SAML SSO integrations\n    \n*   IdP-initiated SSO\n    \n*   Microsoft Active Directory Federation Services (ADFS)\n    \n*   SAML request signing and encrypting\n    \n\n## Supported SAML bindings and options\n\nAuth0 supports the following SAML bindings:\n\n*   HTTP Redirect\n    \n*   HTTP POST\n    \n\nAuth0 supports the following SAML options:\n\n*   Web Browser SSO Profile\n    \n*   Single Logout Profile\n    \n*   Name Identifier Management Profile\n    \n*   Name Identifier Mapping Profile",
  "title": "SAML",
  "description": "Learn about the Security Assertion Markup Language (SAML) protocol, which is an open-standard, XML-based framework for authentication and authorization between two entities without a password.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/ldap-protocol",
  "markdown": "# Lightweight Directory Access Protocol\n\n##### Lightweight Directory Access Protocol\n\n[Contact sales](https://auth0.com/get-started?place=header&type=button&text=talk%20to%20sales) Log in\n\n[\n\n###### Authenticate\n\n](https://auth0.com/docs/authenticate)\n\nAdd Login\n\n*   [Login](https://auth0.com/docs/authenticate/login \"Login\")\n*   [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on \"Single Sign-On\")\n*   [Passwordless](https://auth0.com/docs/authenticate/passwordless \"Passwordless\")\n\nProvision Users\n\n*   [Identity Providers](https://auth0.com/docs/authenticate/identity-providers \"Identity Providers\")\n*   [Database Connections](https://auth0.com/docs/authenticate/database-connections \"Database Connections\")\n*   [Enterprise Connections](https://auth0.com/docs/authenticate/enterprise-connections \"Enterprise Connections\")\n*   [Protocols](https://auth0.com/docs/authenticate/protocols \"Protocols\")\n*   [SAML](https://auth0.com/docs/authenticate/protocols/saml \"SAML\")\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol \"OpenID Connect Protocol\")\n*   [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth \"OAuth 2.0 Authorization Framework\")\n*   [Web Services Federation Protocol](https://auth0.com/docs/authenticate/protocols/ws-fed-protocol \"Web Services Federation Protocol\")\n*   [Lightweight Directory Access Protocol](https://auth0.com/docs/authenticate/protocols/ldap-protocol \"Lightweight Directory Access Protocol\")\n*   [System for Cross-domain Identity Management (SCIM)](https://auth0.com/docs/authenticate/protocols/scim \"System for Cross-domain Identity Management (SCIM)\")\n*   [Connection Settings Best Practices](https://auth0.com/docs/authenticate/connection-settings-best-practices \"Connection Settings Best Practices\")\n\nThe Lightweight Directory Access Protocol (LDAP) is an application protocol, used for accessing and maintaining distributed directory information services over an Internet Protocol (IP) network. The function of LDAP is to enable access to an existing directory like Active Directory (AD). Auth0 uses an [Active Directory/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector) that you install on your network to integrate with AD/LDAP.\n\n## Learn more\n\n*   [AD/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector)\n*   [Auth0 AD/LDAP Connector Health Monitor Extension](https://auth0.com/docs/customize/extensions/ad-ldap-connector-health-monitor)\n*   [Configure AD/LDAP Connector Authentication with Kerberos](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos)\n*   [Deploy AD/LDAP Connectors for High Availability Environments](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-high-availability)\n*   [Point AD/LDAP Connector to Auth0 Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-to-auth0)\n\nWas this article helpful?",
  "title": "Lightweight Directory Access Protocol",
  "description": "Describes how Auth0 supports the Lightweight Directory Access Protocol (LDAP).",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/protocols/scim",
  "markdown": "# System for Cross-domain Identity Management (SCIM)\n\nSCIM (System for Cross-domain Identity Management) is a set of application-level protocols to securely manage and communicate user data across multiple domains. SCIM clients can be integrated to manage CRUD (create, replace, update, delete) operations, apply queries and filters, and create user groups within your organization. SCIM allows you to automate user lifecycles and maintain user accounts across platforms.\n\nTo read the SCIM specification, read [System for Cross-domain Identity Management: Core Schema](https://datatracker.ietf.org/doc/rfc7643/).\n\n### SCIM with Auth0\n\nAuth0 supplies an extensible, flexible directory that is designed to support CIAM use cases and focuses on simplifying identity for direct-to-consumer and software-as-a-service applications.\n\nIn an Auth0 tenant, you can use isolated directories via Social, Enterprise, or Database identity provider connections. To learn more about available connections, read [Identity Providers](https://auth0.com/docs/authenticate/identity-providers) or [Database Connections](https://auth0.com/docs/authenticate/database-connections).\n\nWith connections, you can model internal users and external users within Auth0 or connect external directories and choose to update the records in the Auth0 tenant during authentication or on-demand with the Management API.\n\nAuth0 synchronizes user data from federated directories at authentication (just-in-time). Inbound and outbound SCIM synchronization is provided via middleware that interfaces with Auth0’s Management API for supported lifecycle events such as user creation, update, and delete.\n\nTo learn more about using SCIM with Auth0, contact [Professional Services](https://auth0.com/docs/get-started/professional-services).",
  "title": "System for Cross-domain Identity Management (SCIM)",
  "description": "Describes using System for Cross-domain Identity Management (SCIM) schema in identity management",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/enable-connections",
  "markdown": "# Enable Organization Connections\n\nYou can enable specific connections for each [organization](https://auth0.com/docs/manage-users/organizations/organizations-overview) to provide users with different login options. After you enable a connection, it is added to the organization login prompt, and users can authenticate through that connection to access your applications.\n\nTo enable a connection for an organization, the connection **must** already exist in your tenant. Supported connections include [database connections](https://auth0.com/docs/connections/database), [social connections](https://auth0.com/docs/connections/identity-providers-social), and [enterprise connections](https://auth0.com/docs/connections/identity-providers-enterprise).\n\n## Organization Properties\n\nWhen using organizations, some connections have additional properties that you can configure:\n\n| **Property** | **Connection Types** | **Description** |\n| --- | --- | --- |\n| Membership On Authentication | All connection types | When enabled, this property automatically assigns organization membership to end-users the first time they authenticate with the connection.<br><br>Membership on Authentication is useful in scenarios where all users with the ability to authenticate with a specific connection can be assumed to be members of an organization. |\n| Organization Signup | Database connections only | This property determines whether or not end-users can access a signup link on the login prompt that allows them to gain membership to an Organization. To use Organization Signup, you must also enable Membership On Authentication.<br><br>Organization Signup is useful is scenarios where users need self-service access to join Organizations, such as:<br><br>*   When Organizations are used to model open-membership user populations such as workspaces.<br>*   In business-to-business-to-consumer (B2B2C) use cases where users can freely sign up for accounts. |\n| Display connection as a button | Enterprise connections only | This optional property determines whether or not a specific connection displays as an option on the organization login prompt.<br><br>**Note**: If this option is disabled for a connection, end-users can still authenticate via the connection and log in to applications in the context of the organization by sending the connection parameter directly in the authorization request. They can also authenticate with this connection if you are using the [Identifier First with Home Realm Discovery](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication profile in combination with the [Prompt for Credentials](https://auth0.com/docs/manage-users/organizations/login-flows-for-organizations#configure-the-login-flow-for-your-application) organization login flow. |\n\n## Configure Organization Connections\n\nYou can configure connections for organizations using either the Auth0 Dashboard or the Management API.\n\n#### Auth0 Dashboard\n\nTo enable a connection via the Auth0 Dashboard:\n\n1.  Navigate to [Auth0 Dashboard > Organizations](https://manage.auth0.com/#/organizations), and select the organization for which you want to configure connections.\n    \n2.  Select the **Connections** view, then select **Enable Connections**.\n    \n3.  Choose the connection you want to enable, and select **Enable Connection**.\n    \n4.  In the Authentication section, locate **Membership On Authentication** and choose whether to enable or disable auto-membership. When enabled, auto-membership automatically adds all users logging in with the connection as members of the organization.\n    \n5.  **For Database connections only**: In the Organization Signup section, choose whether to enable or disable self-service signups. When enabled, users can access a signup link on the login prompt to create their account and automatically gain membership to the organization.\n    \n    *   **Note**: To enable this property, you must first enable **Membership on Authentication**.\n        \n6.  **For Enterprise connections only**: In the Connection button section, optionally enable the **Display connection as a button** property to display the connection as an option on the organization login prompt.\n    \n7.  Select **Save**.",
  "title": "Enable Organization Connections",
  "description": "Learn to enable Organization connections using the Auth0 Dashboard and Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-migration/bulk-user-import-database-schema-and-examples",
  "markdown": "# Bulk User Import Database Schema and Examples\n\n```\n{\n  \"type\": \"object\",\n\t\"properties\": {\n\t\t\"email\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"The user's email address.\",\n\t\t\t\"format\": \"email\"\n\t\t},\n\t\t\"email_verified\": {\n\t\t\t\"type\": \"boolean\",\n\t\t\t\"default\": false,\n\t\t\t\"description\": \"Indicates whether the user has verified their email address.\"\n\t\t},\n\t\t\"user_id\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"The user's unique identifier. This will be prepended by the connection strategy.\"\n\t\t},\n\t\t\"username\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"The user's username.\"\n\t\t},\n\t\t\"given_name\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"The user's given name.\"\n\t\t},\n\t\t\"family_name\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"The user's family name.\"\n\t\t},\n\t\t\"name\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"The user's full name.\"\n\t\t},\n\t\t\"nickname\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"The user's nickname.\"\n\t\t},\n\t\t\"picture\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"URL pointing to the user's profile picture.\"\n\t\t},\n\t\t\"blocked\": {\n\t\t\t\"type\": \"boolean\",\n\t\t\t\"description\": \"Indicates whether the user has been blocked.\"\n\t\t},\n\t\t\"password_hash\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"Hashed password for the user. Passwords should be hashed using bcrypt $2a$ or $2b$ and have 10 saltRounds.\"\n\t\t},\n\t\t\"custom_password_hash\": {\n\t\t\t\"type\": \"object\",\n\t\t\t\"description\": \"A more generic way to provide the users password hash. This can be used in lieu of the password_hash field when the users password hash was created with an alternate algorithm. Note that this field and password_hash are mutually exclusive.\",\n\t\t\t\"properties\": {\n\t\t\t\t\"algorithm\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"enum\": [\n\t\t\t\t\t\t\"argon2\",\n\t\t\t\t\t\t\"bcrypt\",\n\t\t\t\t\t\t\"hmac\",\n\t\t\t\t\t\t\"ldap\",\n\t\t\t\t\t\t\"md4\",\n\t\t\t\t\t\t\"md5\",\n\t\t\t\t\t\t\"sha1\",\n\t\t\t\t\t\t\"sha256\",\n\t\t\t\t\t\t\"sha512\",\n\t\t\t\t\t\t\"pbkdf2\",\n\t\t\t\t\t\t\"scrypt\"\n\t\t\t\t\t],\n\t\t\t\t\t\"description\": \"The algorithm that was used to hash the password.\"\n\t\t\t\t},\n\t\t\t\t\"hash\": {\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\"description\": \"The password hash.\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"encoding\": {\n\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\"enum\": [\n\t\t\t\t\t\t\t\t\"base64\",\n\t\t\t\t\t\t\t\t\"hex\",\n\t\t\t\t\t\t\t\t\"utf8\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"description\": \"The encoding of the provided hash. Note that both upper and lower case hex variants are supported, as well as url-encoded base64.\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"digest\": {\n\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\"description\": \"The algorithm that was used to generate the HMAC hash\",\n\t\t\t\t\t\t\t\"enum\": [\n\t\t\t\t\t\t\t\t\"md4\",\n\t\t\t\t\t\t\t\t\"md5\",\n\t\t\t\t\t\t\t\t\"ripemd160\",\n\t\t\t\t\t\t\t\t\"sha1\",\n\t\t\t\t\t\t\t\t\"sha224\",\n\t\t\t\t\t\t\t\t\"sha256\",\n\t\t\t\t\t\t\t\t\"sha384\",\n\t\t\t\t\t\t\t\t\"sha512\",\n\t\t\t\t\t\t\t\t\"whirlpool\"\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"key\": {\n\t\t\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\t\t\"description\": \"The key that was used to generate the HMAC hash\",\n\t\t\t\t\t\t\t\"required\": [\n\t\t\t\t\t\t\t\t\"value\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\t\t\"description\": \"The key value\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"encoding\": {\n\t\t\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\t\t\"enum\": [\n\t\t\t\t\t\t\t\t\t\t\"base64\",\n\t\t\t\t\t\t\t\t\t\t\"hex\",\n\t\t\t\t\t\t\t\t\t\t\"utf8\"\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\"default\": \"utf8\",\n\t\t\t\t\t\t\t\t\t\"description\": \"The key encoding\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"salt\": {\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\"description\": \"The salt value used to generate the hash.\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"encoding\": {\n\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\"enum\": [\n\t\t\t\t\t\t\t\t\"base64\",\n\t\t\t\t\t\t\t\t\"hex\",\n\t\t\t\t\t\t\t\t\"utf8\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"default\": \"utf8\",\n\t\t\t\t\t\t\t\"description\": \"The encoding of the provided salt. Note that both upper and lower case hex variants are supported, as well as url-encoded base64.\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"position\": {\n\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\"enum\": [\n\t\t\t\t\t\t\t\t\"prefix\",\n\t\t\t\t\t\t\t\t\"suffix\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"default\": \"prefix\",\n\t\t\t\t\t\t\t\"description\": \"The position of the salt when the hash was calculated. For example; MD5('salt' + 'password') = '67A1E09BB1F83F5007DC119C14D663AA' would have \\\"position\\\":\\\"prefix\\\".\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"required\": [\n\t\t\t\t\t\t\"value\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"password\": {\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\"encoding\": {\n\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\"enum\": [\n\t\t\t\t\t\t\t\t\"ascii\",\n\t\t\t\t\t\t\t\t\"utf8\",\n\t\t\t\t\t\t\t\t\"utf16le\",\n\t\t\t\t\t\t\t\t\"ucs2\",\n\t\t\t\t\t\t\t\t\"latin1\",\n\t\t\t\t\t\t\t\t\"binary\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"default\": \"utf8\",\n\t\t\t\t\t\t\t\"description\": \"The encoding of the password used to generate the hash. On login, the user-provided password will be transcoded from utf8 before being checked against the provided hash. For example; if your hash was generated from a ucs2 encoded string, then you would supply \\\"encoding\\\":\\\"ucs2\\\".\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"keylen\" : {\n\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\"description\": \"Desired key length in bytes for the scrypt hash. Must be an integer greater than zero. Required when algorithm is set to scrypt.\"\n\t\t\t\t},\n\t\t\t\t\"cost\" : {\n\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\"default\": 16384,\n\t\t\t\t\t\"description\": \"CPU/memory cost parameter used for the scrypt hash. Must be a power of two greater than one. Only used when algorithm is set to scrypt.\"\n\t\t\t\t},\n\t\t\t\t\"blockSize\" : {\n\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\"default\": 8,\n\t\t\t\t\t\"description\": \"Block size parameter used for the scrypt hash. Must be a positive integer. Only used when algorithm is set to scrypt.\"\n\t\t\t\t},\n\t\t\t\t\"parallelization\" : {\n\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\"default\": 1,\n\t\t\t\t\t\"description\": \"Parallelization parameter used for the scrypt hash. Must be a positive integer. Only used when algorithm is set to scrypt.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\n\t\t\t\t\"algorithm\",\n\t\t\t\t\"hash\"\n\t\t\t],\n\t\t\t\"additionalProperties\": false\n\t\t},\n\t\t\"app_metadata\": {\n\t\t\t\"type\": \"object\",\n\t\t\t\"description\": \"Data related to the user that does affect the application's core functionality.\"\n\t\t},\n\t\t\"user_metadata\": {\n\t\t\t\"type\": \"object\",\n\t\t\t\"description\": \"Data related to the user that does not affect the application's core functionality.\"\n\t\t},\n\t\t\"mfa_factors\": {\n\t\t\t\"type\": \"array\",\n\t\t\t\"items\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"totp\": {\n\t\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\t\"secret\": {\n\t\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\t\"pattern\": \"^[A-Z2-7]+$\",\n\t\t\t\t\t\t\t\t\"description\": \"The OTP secret is used with authenticator apps (Google Authenticator, Microsoft Authenticator, Authy, 1Password, LastPass). It must be supplied in un-padded Base32 encoding, such as: JBTWY3DPEHPK3PNP\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\t\t\"required\": [\n\t\t\t\t\t\t\t\"secret\"\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t\"phone\": {\n\t\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\t\"pattern\": \"^\\\\+[0-9]{1,15}$\",\n\t\t\t\t\t\t\t\t\"description\": \"The phone number for SMS MFA. The phone number should include a country code and begin with +, such as: +12125550001\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\t\t\"required\": [\n\t\t\t\t\t\t\t\"value\"\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t\"email\": {\n\t\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\t\"format\": \"email\",\n\t\t\t\t\t\t\t\t\"description\": \"The email address for MFA\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\t\t\"required\": [\n\t\t\t\t\t\t\t\"value\"\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"maxProperties\": 1,\n\t\t\t\t\"additionalProperties\": false\n\t\t\t},\n\t\t\t\"minItems\": 1,\n\t\t\t\"maxItems\": 10\n\t\t}\n\t},\n\t\"required\": [\n\t\t\"email\"\n\t],\n\t\"additionalProperties\": false\n}\n```",
  "title": "Bulk User Import Database Schema and Examples",
  "description": "Learn how to perform bulk user imports with the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-migration/user-migration-scenarios",
  "markdown": "# User Migration Scenarios\n\n```\nfunction login(username, password, callback) {\n  // Replace the {yourStormpathClientId} attribute with your Stormpath ID\n  var url = 'https://api.stormpath.com/v1/applications/{yourStormpathClientId}/loginAttempts';\n\n  // Stormpath requires the user credentials be passed in as a base64 encoded message\n  var message = username + ':' + password;\n  var pass = new Buffer(message).toString('base64');\n\n  // Here we are making the POST request to authenticate a user\n  request({\n    url: url,\n    method: 'POST',\n    auth: {\n      // Your API Client ID\n      user: '{yourStormpathClientId}',\n      // Your API Client Secret\n      password: '{yourStormpathClientSecret}'\n    },\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    json: {\n      type: 'basic',\n      // Passing in the base64 encoded credentials\n      value: pass\n    }\n  }, function (error, response, body) {\n    // If response is successful we'll continue\n    if (response.statusCode !== 200) return callback();\n    // A successful response will return a URL to get the user information\n    var accountUrl = body.account.href;\n\n    // We'll make a second request to get the user info. This time it will be a GET request\n    request({\n      url: accountUrl,\n      method: 'GET',\n      auth: {\n        // Your API Client ID\n        user: '{yourStormpathClientId}',\n        // YOUR API Client Secret\n        password: '{yourStormpathClientSecret}'\n      }\n    }, function (errorUserInfo, responseUserInfo, bodyUserInfo) {\n      // If we get a successful response, we'll process it\n      if (responseUserInfo.statusCode !== 200) return callback();\n\n      var parsedBody = JSON.parse(bodyUserInfo);\n      // To get the user identifier, we'll strip out the Stormpath API\n      var id = parsedBody.href.replace('https://api.stormpath.com/v1/accounts/', '');\n\n      // Finally, we'll set the data we want to store in Auth0 and migrate the user\n      return callback(null, {\n        user_id : id,\n        username: parsedBody.username,\n        email: parsedBody.email,\n        // We set the users email_verified to true as we assume if they were a valid\n        // user in Stormpath, they have already verified their email\n        // If this field is not set, the user will get an email asking them to verify\n        // their account\n        email_verified: true,\n        // Add any additional fields you would like to carry over from Stormpath\n      });\n    });\n  });\n}\n```",
  "title": "User Migration Scenarios",
  "description": "User migrations scenarios from various platforms using multiple methods.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint",
  "markdown": "# Retrieve Users with the Get Users Endpoint\n\nThe [`GET /api/v2/users` endpoint](https://auth0.com/docs/api/management/v2#!/Users/get_users) allows you to retrieve a list of users. Using this endpoint, you can:\n\n*   Search based on a variety of criteria\n    \n*   Select the fields to be returned\n    \n*   Sort the returned results\n    \n\nThis endpoint is **eventually consistent**, and as such, we recommend that you use this endpoint for back office processes such as changing the display name of an existing user.\n\n## Request example\n\nTo search for users, make a `GET` request to the [`/api/v2/users` endpoint](https://auth0.com/docs/api/management/v2#!/Users/get_users). The request must include a [Management API access token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens). Pass your search query to the `q` parameter and set the `search_engine` parameter to `v3`.\n\nFor example, to search for a user whose email is exactly `jane@exampleco.com`, use `q=email:\"jane@exampleco.com\"`:\n\n*   [cURL](#9e36007721d54403a8e41967bdc1273c_shell)\n*   [C#](#9e36007721d54403a8e41967bdc1273c_csharp)\n*   [Go](#9e36007721d54403a8e41967bdc1273c_go)\n*   [Java](#9e36007721d54403a8e41967bdc1273c_java)\n*   [Node.JS](#9e36007721d54403a8e41967bdc1273c_node)\n*   [Obj-C](#9e36007721d54403a8e41967bdc1273c_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users?q=email%3A%22jane%40exampleco.com%22&search_engine=v3' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users?q=email%3A%22jane%40exampleco.com%22&search_engine=v3\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users?q=email%3A%22jane%40exampleco.com%22&search_engine=v3\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users?q=email%3A%22jane%40exampleco.com%22&search_engine=v3\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users',\n  params: {q: 'email:\"jane@exampleco.com\"', search_engine: 'v3'},\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users?q=email%3A%22jane%40exampleco.com%22&search_engine=v3\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users?q=email%3A%22jane%40exampleco.com%22&search_engine=v3\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users?q=email%3A%22jane%40exampleco.com%22&search_engine=v3\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users?q=email%3A%22jane%40exampleco.com%22&search_engine=v3\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users?q=email%3A%22jane%40exampleco.com%22&search_engine=v3\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf successful, you'll receive a response like this:\n\n```\n[\n  {\n    \"email\": \"jane@exampleco.com\",\n    \"email_verified\": false,\n    \"username\": \"janedoe\",\n    \"phone_number\": \"+199999999999999\",\n    \"phone_verified\": false,\n    \"user_id\": \"auth0|5457edea1b8f22891a000004\",\n    \"created_at\": \"\",\n    \"updated_at\": \"\",\n    \"identities\": [\n      {\n        \"connection\": \"Initial-Connection\",\n        \"user_id\": \"5457edea1b8f22891a000004\",\n        \"provider\": \"auth0\",\n        \"isSocial\": false\n      }\n    ],\n    \"app_metadata\": {},\n    \"user_metadata\": {},\n    \"picture\": \"\",\n    \"name\": \"\",\n    \"nickname\": \"\",\n    \"multifactor\": [\n      \"\"\n    ],\n    \"last_ip\": \"\",\n    \"last_login\": \"\",\n    \"logins_count\": 0,\n    \"blocked\": false,\n    \"given_name\": \"\",\n    \"family_name\": \"\"\n  }\n]\n```\n\n## Query examples\n\nBelow are some examples of the kinds of queries you can make with the Management API.\n\n| Use case | Query |\n| --- | --- |\n| Search for all users whose name contains \"john\" | `name:*john*` |\n| Search all users whose name is exactly \"jane\" | `name:\"jane\"` |\n| Search for all user names starting with \"john\" | `name:john*` |\n| Search for user names that start with \"jane\" and end with \"smith\" | `name:jane*smith` |\n| Search for all users whose email is exactly \"john@exampleco.com\" | `email:\"john@exampleco.com\"` |\n| Search for all users whose email is exactly \"john@exampleco.com\" or \"jane@exampleco.com\" using `OR` | `email:(\"john@exampleco.com\" OR \"jane@exampleco.com\")` |\n| Search for users without verified email | `email_verified:false OR NOT _exists_:email_verified` |\n| Search for users who have the `user_metadata` field named `full_name` with the value of \"John Smith\" | `user_metadata.full_name:\"John Smith\"` |\n| Search for users from a specific connection | `identities.connection:\"google-oauth2\"` |\n| Search for all users that have never logged in | `(NOT _exists_:logins_count OR logins_count:0)` |\n| Search for all users who logged in before 2018 | `last_login:[* TO 2017-12-31]` |\n| Search for all users whose last login was in December 2017 | `last_login:{2017-11 TO 2017-12]`, `last_login:[2017-12-01 TO 2017-12-31]` |\n| Search for all users with logins count >= 100 and <= 200 | `logins_count:[100 TO 200]` |\n| Search for all users with logins count >= 100 | `logins_count:[100 TO *]` |\n| Search for all users with logins count > 100 and < 200 | `logins_count:{100 TO 200}` |\n| Search for all users whose email domain is \"exampleco.com\" | `email.domain:\"exampleco.com\"` |\n\n## Limitations\n\nThe endpoint returns a maximum of 50 users, even if more users match your query.\n\nIf you need to return more than 50 users, use the `page` parameter to show more pages of results. Each page contains 50 users. For example, you can specify `&page=2` to show results 51-100, specify `&page=3` to show results 101-150, and so on. However, this endpoint never returns a total of more than 1000 users with the same search criteria, even with paging.\n\nThere is a 1 MB per-user limit on user data that can be indexed, queried, and returned by the [user search endpoint](https://auth0.com/docs/api/management/v2/users/get-users). For more information on how this affects custom metadata larger than 1MB, see [Metadata Field Names and Data Types](https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data#size-limits-and-storage). The [get user endpoint](https://auth0.com/docs/api/management/v2/users/get-users-by-id) must be used to retrieve all user attributes for oversized user profiles.\n\nIf you need a complete export of all of your users, use the [export job](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports) or the [User Import / Export](https://auth0.com/docs/extensions/user-import-export) extension.\n\nIf you get the error `414 Request-URI Too Large` this means that your query string is larger than the supported length. In this case, refine your search.\n\nWe do **not** recommend that you use this endpoint for:\n\n*   Operations that require immediate consistency. Instead, use the [Get Users by Email endpoint](https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-by-email-endpoint) or the [Get Users by ID endpoint](https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-by-id-endpoint).\n    \n*   User exports. Instead, use the [User Export endpoint](https://auth0.com/docs/manage-users/user-migration/bulk-user-exports).\n    \n*   Operations that require user search as part of authentication processes. Instead, use the Get Users by Email endpoint or the Get Users by ID endpoint.\n    \n*   Searching for Users for [Account Linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking) by Email. Instead, use the Get Users by Email endpoint.\n    \n\n## Learn more\n\n*   [User Search Query Syntax](https://auth0.com/docs/manage-users/user-search/user-search-query-syntax)\n*   [Sort Search Results](https://auth0.com/docs/manage-users/user-search/sort-search-results)\n*   [View Search Results by Page](https://auth0.com/docs/manage-users/user-search/view-search-results-by-page)\n*   [Bulk User Exports](https://auth0.com/docs/manage-users/user-migration/bulk-user-exports)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)",
  "title": "Retrieve Users with the Get Users Endpoint",
  "description": "Learn how to retrieve lists of users using the get_users endpoint.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-migration/bulk-user-imports",
  "markdown": "# Bulk User Imports\n\nYou can bulk import user data into Auth0 using the [Create Import Users Job](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_imports) endpoint. Bulk imports are useful for migrating users from an existing database or service to Auth0.\n\n## Prerequisites\n\nBefore you launch the import users job:\n\n*   Configure a database connection to import the users into and enable it for at least one application.\n    \n*   If you are importing passwords, make sure the passwords are hashed using one of the supported algorithms. Users with passwords hashed by unsupported algorithms will need to reset their password when they log in for the first time after the bulk import.\n    \n*   If you are importing MFA enrollments, make sure they are a supported type: `email`, `phone`, or `totp`.\n    \n*   [Get a Management API token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) for job endpoint requests.\n    \n\n## Create users JSON file\n\nCreate a JSON file with the user data you want to import into Auth0. How you export user data to a JSON file will vary depending on your existing user database. The Management API endpoint expects sections of the JSON file. So instead of using `fs.readFileSync`, it requires `fs.createReadStream`. The endpoint expects a piped read stream instead of the whole JSON file.\n\nTo learn more about the JSON file schema and see examples, read [Bulk Import Database Schema and Examples](https://auth0.com/docs/manage-users/user-migration/bulk-user-import-database-schema-and-examples).\n\n## Request bulk user import\n\nTo start a bulk user import job, make a `POST` request to the [Create Import Users Job](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_imports) endpoint. Be sure to replace the `MGMT_API_ACCESS_TOKEN`, `USERS_IMPORT_FILE.json`, `CONNECTION_ID`, and `EXTERNAL_ID` placeholder values with your Management API Access Token, users JSON file, database [connection ID](https://auth0.com/docs/authenticate/identity-providers/locate-the-connection-id), and external ID, respectively.\n\n*   [cURL](#57462b311a8b48cd8d02657268819268_shell)\n*   [C#](#57462b311a8b48cd8d02657268819268_csharp)\n*   [Go](#57462b311a8b48cd8d02657268819268_go)\n*   [Java](#57462b311a8b48cd8d02657268819268_java)\n*   [Node.JS](#57462b311a8b48cd8d02657268819268_node)\n*   [Obj-C](#57462b311a8b48cd8d02657268819268_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/jobs/users-imports' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --form users=@USERS_IMPORT_FILE.json \\\n  --form connection_id=CONNECTION_ID \\\n  --form external_id=EXTERNAL_ID\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/jobs/users-imports\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"multipart/form-data; boundary=---011000010111000001101001\");\nrequest.AddParameter(\"multipart/form-data; boundary=---011000010111000001101001\", \"-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"users\\\"; filename=\\\"USERS_IMPORT_FILE.json\\\"\\r\\nContent-Type: text/json\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"connection_id\\\"\\r\\n\\r\\nCONNECTION_ID\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"external_id\\\"\\r\\n\\r\\nEXTERNAL_ID\\r\\n-----011000010111000001101001--\\r\\n\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/jobs/users-imports\"\n\n\tpayload := strings.NewReader(\"-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"users\\\"; filename=\\\"USERS_IMPORT_FILE.json\\\"\\r\\nContent-Type: text/json\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"connection_id\\\"\\r\\n\\r\\nCONNECTION_ID\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"external_id\\\"\\r\\n\\r\\nEXTERNAL_ID\\r\\n-----011000010111000001101001--\\r\\n\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"multipart/form-data; boundary=---011000010111000001101001\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/jobs/users-imports\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"multipart/form-data; boundary=---011000010111000001101001\")\n  .body(\"-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"users\\\"; filename=\\\"USERS_IMPORT_FILE.json\\\"\\r\\nContent-Type: text/json\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"connection_id\\\"\\r\\n\\r\\nCONNECTION_ID\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"external_id\\\"\\r\\n\\r\\nEXTERNAL_ID\\r\\n-----011000010111000001101001--\\r\\n\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/jobs/users-imports',\n  headers: {\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'content-type': 'multipart/form-data; boundary=---011000010111000001101001'\n  },\n  data: '-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\"users\"; filename=\"USERS_IMPORT_FILE.json\"\\r\\nContent-Type: text/json\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\"connection_id\"\\r\\n\\r\\nCONNECTION_ID\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\"external_id\"\\r\\n\\r\\nEXTERNAL_ID\\r\\n-----011000010111000001101001--\\r\\n'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"multipart/form-data; boundary=---011000010111000001101001\" };\nNSArray *parameters = @[ @{ @\"name\": @\"users\", @\"fileName\": @\"USERS_IMPORT_FILE.json\", @\"contentType\": @\"text/json\" },\n                         @{ @\"name\": @\"connection_id\", @\"value\": @\"CONNECTION_ID\" },\n                         @{ @\"name\": @\"external_id\", @\"value\": @\"EXTERNAL_ID\" } ];\nNSString *boundary = @\"---011000010111000001101001\";\n\nNSError *error;\nNSMutableString *body = [NSMutableString string];\nfor (NSDictionary *param in parameters) {\n    [body appendFormat:@\"--%@\\r\\n\", boundary];\n    if (param[@\"fileName\"]) {\n        [body appendFormat:@\"Content-Disposition:form-data; name=\\\"%@\\\"; filename=\\\"%@\\\"\\r\\n\", param[@\"name\"], param[@\"fileName\"]];\n        [body appendFormat:@\"Content-Type: %@\\r\\n\\r\\n\", param[@\"contentType\"]];\n        [body appendFormat:@\"%@\", [NSString stringWithContentsOfFile:param[@\"fileName\"] encoding:NSUTF8StringEncoding error:&error]];\n        if (error) {\n            NSLog(@\"%@\", error);\n        }\n    } else {\n        [body appendFormat:@\"Content-Disposition:form-data; name=\\\"%@\\\"\\r\\n\\r\\n\", param[@\"name\"]];\n        [body appendFormat:@\"%@\", param[@\"value\"]];\n    }\n}\n[body appendFormat:@\"\\r\\n--%@--\\r\\n\", boundary];\nNSData *postData = [body dataUsingEncoding:NSUTF8StringEncoding];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/jobs/users-imports\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/jobs/users-imports\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"users\\\"; filename=\\\"USERS_IMPORT_FILE.json\\\"\\r\\nContent-Type: text/json\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"connection_id\\\"\\r\\n\\r\\nCONNECTION_ID\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"external_id\\\"\\r\\n\\r\\nEXTERNAL_ID\\r\\n-----011000010111000001101001--\\r\\n\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: multipart/form-data; boundary=---011000010111000001101001\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"users\\\"; filename=\\\"USERS_IMPORT_FILE.json\\\"\\r\\nContent-Type: text/json\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"connection_id\\\"\\r\\n\\r\\nCONNECTION_ID\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"external_id\\\"\\r\\n\\r\\nEXTERNAL_ID\\r\\n-----011000010111000001101001--\\r\\n\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"multipart/form-data; boundary=---011000010111000001101001\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/jobs/users-imports\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/jobs/users-imports\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'multipart/form-data; boundary=---011000010111000001101001'\nrequest.body = \"-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"users\\\"; filename=\\\"USERS_IMPORT_FILE.json\\\"\\r\\nContent-Type: text/json\\r\\n\\r\\n\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"connection_id\\\"\\r\\n\\r\\nCONNECTION_ID\\r\\n-----011000010111000001101001\\r\\nContent-Disposition: form-data; name=\\\"external_id\\\"\\r\\n\\r\\nEXTERNAL_ID\\r\\n-----011000010111000001101001--\\r\\n\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"multipart/form-data; boundary=---011000010111000001101001\"\n]\nlet parameters = [\n  [\n    \"name\": \"users\",\n    \"fileName\": \"USERS_IMPORT_FILE.json\",\n    \"contentType\": \"text/json\"\n  ],\n  [\n    \"name\": \"connection_id\",\n    \"value\": \"CONNECTION_ID\"\n  ],\n  [\n    \"name\": \"external_id\",\n    \"value\": \"EXTERNAL_ID\"\n  ]\n]\n\nlet boundary = \"---011000010111000001101001\"\n\nvar body = \"\"\nvar error: NSError? = nil\nfor param in parameters {\n  let paramName = param[\"name\"]!\n  body += \"--\\(boundary)\\r\\n\"\n  body += \"Content-Disposition:form-data; name=\\\"\\(paramName)\\\"\"\n  if let filename = param[\"fileName\"] {\n    let contentType = param[\"content-type\"]!\n    let fileContent = String(contentsOfFile: filename, encoding: String.Encoding.utf8)\n    if (error != nil) {\n      print(error)\n    }\n    body += \"; filename=\\\"\\(filename)\\\"\\r\\n\"\n    body += \"Content-Type: \\(contentType)\\r\\n\\r\\n\"\n    body += fileContent\n  } else if let paramValue = param[\"value\"] {\n    body += \"\\r\\n\\r\\n\\(paramValue)\"\n  }\n}\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/jobs/users-imports\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Parameter | Description |\n| --- | --- |\n| `users` | File in JSON format that contains the users to import. |\n| `connection_id` | ID of the connection to which users will be inserted. You can retrieve the ID using the [GET /api/v2/connections](https://auth0.com/docs/api/management/v2#!/Connections/get_connections) endpoint. |\n| `upsert` | Boolean value; `false` by default. When set to `false`, pre-existing users that match on email address, user ID, or username will fail. When set to true, pre-existing users that match on email address will be updated, but only with upsertable attributes. For a list of user profile fields that can be upserted during import, see [User Profile Structure: User profile attributes](https://auth0.com/docs/users/user-profile-structure#user-profile-attributes). Note: Providing a duplicated user entry in the import file will cause an error. In this case, Auth0 will not do an insert followed by an update. |\n| `external_id` | Optional user-defined string that can be used to correlate multiple jobs. Returned as part of the job status response. |\n| `send_completion_email` | Boolean value; `true` by default. When set to `true`, sends a completion email to all tenant owners when the import job is finished. If you do _not_ want emails sent, you must explicitly set this parameter to `false`. |\n\nIf the request is successful, you'll receive a response similar to the following:\n\n```\n{\n  \"status\": \"pending\",\n  \"type\": \"users_import\",\n  \"created_at\": \"\",\n  \"id\": \"job_abc123\",\n  \"connection_id\": \"CONNECTION_ID\",\n  \"upsert\": false,\n  \"external_id\": \"EXTERNAL_ID\",\n  \"send_completion_email\": true\n}\n```\n\nThe returned entity represents the import job.\n\nWhen the user import job finishes and if `send_completion_email` was set to `true`, the tenant administrator(s) will get an email notifying them that job either failed or succeeded. An email for a job that failed might notify the administrator(s) that it failed to parse the users JSON file when importing users.\n\n### Concurrent import jobs\n\nThe [Create Import Users Job](https://auth0.com/docs/api/management/v2#!/Jobs/post_users_imports) endpoint has a limit of two concurrent import jobs. Requesting additional jobs while there are two pending returns a `429 Too Many Requests` response:\n\n```\n{\n  \"statusCode\": 429,\n  \"error\": \"Too Many Requests\",\n  \"message\": \"There are 2 active import users jobs, please wait until some of them are finished and try again\n}\n```\n\n## Check job status\n\nTo check a job's status, make a `GET` request to the [Get a Job](https://auth0.com/docs/api/management/v2#!/Jobs/get_jobs_by_id) endpoint. Be sure to replace the `MGMT_API_ACCESS_TOKEN` and `JOB_ID` placeholder values with your Management API Access Token and user import job ID.\n\n*   [cURL](#869b9726e73c47a09733ccf24abc1f1f_shell)\n*   [C#](#869b9726e73c47a09733ccf24abc1f1f_csharp)\n*   [Go](#869b9726e73c47a09733ccf24abc1f1f_go)\n*   [Java](#869b9726e73c47a09733ccf24abc1f1f_java)\n*   [Node.JS](#869b9726e73c47a09733ccf24abc1f1f_node)\n*   [Obj-C](#869b9726e73c47a09733ccf24abc1f1f_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/jobs/JOB_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/jobs/JOB_ID\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/jobs/JOB_ID\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/jobs/JOB_ID\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/jobs/JOB_ID',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/jobs/JOB_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/jobs/JOB_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/jobs/JOB_ID\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/jobs/JOB_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/jobs/JOB_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nDepending on the status of the user import job, you'll receive a response similar to one of the following:\n\n**Pending**\n\n```\n{\n  \"status\": \"pending\",\n  \"type\": \"users_import\",\n  \"created_at\": \"\",\n  \"id\": \"job_abc123\",\n  \"connection_id\": \"CONNECTION_ID\",\n  \"external_id\": \"EXTERNAL_ID\"\n}\n```\n\n**Completed**\n\nIf a job is completed, the job status response will include totals of successful, failed, inserted, and updated records.\n\n```\n{\n  \"status\": \"completed\",\n  \"type\": \"users_import\",\n  \"created_at\": \"\",\n  \"id\": \"job_abc123\",\n  \"connection_id\": \"CONNECTION_ID\",\n  \"external_id\": \"EXTERNAL_ID\",\n  \"summary\": {\n    \"failed\": 0,\n    \"updated\": 0,\n    \"inserted\": 1,\n    \"total\": 1\n  }\n}\n```\n\n**Failed**\n\nIf there is an error in the job, it will return as failed. However, note that invalid user information, such as an invalid email, will not make the entire job fail.\n\n```\n{\n  \"status\": \"failed\",\n  \"type\": \"users_import\",\n  \"created_at\": \"\",\n  \"id\": \"job_abc123\",\n  \"connection_id\": \"CONNECTION_ID\",\n  \"external_id\": \"EXTERNAL_ID\",\n}\n```\n\nTo learn details for failed entries see **Retrieve failed entries** below.\n\n## Job timeouts\n\nAll user import jobs timeout after **two (2) hours**. If your job does not complete within this time frame, it is marked as failed.\n\nFurthermore, all of your job-related data is automatically deleted after 24 hours and cannot be accessed afterward. As such, **we strongly recommend storing job results using the storage mechanism of your choice**.\n\n## Retrieve failed entries\n\nIf there were errors in the user import job, you can get the error details by making a `GET` request to the [Get Job Error Details](https://auth0.com/docs/api/management/v2#!/Jobs/get_errors) endpoint. Be sure to replace the `MGMT_API_ACCESS_TOKEN` and `JOB_ID` placeholder values with your Management API Access Token and user import job ID.\n\n*   [cURL](#3bb17233d0734b56b8dd8809783684aa_shell)\n*   [C#](#3bb17233d0734b56b8dd8809783684aa_csharp)\n*   [Go](#3bb17233d0734b56b8dd8809783684aa_go)\n*   [Java](#3bb17233d0734b56b8dd8809783684aa_java)\n*   [Node.JS](#3bb17233d0734b56b8dd8809783684aa_node)\n*   [Obj-C](#3bb17233d0734b56b8dd8809783684aa_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/jobs/JOB_ID/errors' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/jobs/JOB_ID/errors\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/jobs/JOB_ID/errors\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/jobs/JOB_ID/errors\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/jobs/JOB_ID/errors',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/jobs/JOB_ID/errors\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/jobs/JOB_ID/errors\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/jobs/JOB_ID/errors\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/jobs/JOB_ID/errors\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/jobs/JOB_ID/errors\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nIf the request is successful, you'll receive a response similar to the following. Sensitive fields such as `hash.value` will be redacted in the response.\n\n```\n[\n    {\n        \"user\": {\n            \"email\": \"test@test.io\",\n            \"user_id\": \"7af4c65cb0ac6e162f081822422a9dde\",\n            \"custom_password_hash\": {\n                \"algorithm\": \"ldap\",\n                \"hash\": {\n                    \"value\": \"*****\"\n                }\n            }\n        },\n        \"errors\": [\n            {\n                \"code\": \"...\",\n                \"message\": \"...\",\n                \"path\": \"...\"\n            }\n        ]\n    }\n]\n```\n\nEach error object will include an error code and a message explaining the error in more detail. The possible error codes are:\n\n*   ANY\\_OF\\_MISSING\n    \n*   ARRAY\\_LENGTH\\_LONG\n    \n*   ARRAY\\_LENGTH\\_SHORT\n    \n*   CONFLICT\n    \n*   CONFLICT\\_EMAIL\n    \n*   CONFLICT\\_USERNAME\n    \n*   CONNECTION\\_NOT\\_FOUND\n    \n*   DUPLICATED\\_USER\n    \n*   ENUM\\_MISMATCH\n    \n*   FORMAT\n    \n*   INVALID\\_TYPE\n    \n*   MAX\\_LENGTH\n    \n*   MAXIMUM\n    \n*   MFA\\_FACTORS\\_FAILED\n    \n*   MIN\\_LENGTH\n    \n*   MINIMUM\n    \n*   NOT\\_PASSED\n    \n*   OBJECT\\_REQUIRED\n    \n*   PATTERN\n    \n\n## Learn more\n\n*   [Configure Automatic Migration from Your Database](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database)\n*   [User Import / Export Extension](https://auth0.com/docs/manage-users/user-migration/user-import-export-extension)\n*   [Bulk User Import Database Schema and Examples](https://auth0.com/docs/manage-users/user-migration/bulk-user-import-database-schema-and-examples)\n*   [User Migration Scenarios](https://auth0.com/docs/manage-users/user-migration/user-migration-scenarios)",
  "title": "Bulk User Imports",
  "description": "Learn how to perform bulk user imports with the Management API.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-by-email-endpoint",
  "markdown": "# Retrieve Users with Get Users by Email Endpoint\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users-by-email?email=%7BuserEmailAddress%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users-by-email?email=%7BuserEmailAddress%7D\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users-by-email?email=%7BuserEmailAddress%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users-by-email?email=%7BuserEmailAddress%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users-by-email',\n  params: {email: '{userEmailAddress}'},\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users-by-email?email=%7BuserEmailAddress%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users-by-email?email=%7BuserEmailAddress%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users-by-email?email=%7BuserEmailAddress%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users-by-email?email=%7BuserEmailAddress%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users-by-email?email=%7BuserEmailAddress%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Retrieve Users with Get Users by Email Endpoint",
  "description": "Learn how to retrieve lists of users using the get-users-by-email endpoint.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-search/sort-search-results",
  "markdown": "# Sort Search Results\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&sort=created_at%3A1&search_engine=v3' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&sort=created_at%3A1&search_engine=v3\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&sort=created_at%3A1&search_engine=v3\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&sort=created_at%3A1&search_engine=v3\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users',\n  params: {q: 'logins_count:[100 TO 200]', sort: 'created_at:1', search_engine: 'v3'},\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&sort=created_at%3A1&search_engine=v3\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&sort=created_at%3A1&search_engine=v3\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&sort=created_at%3A1&search_engine=v3\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&sort=created_at%3A1&search_engine=v3\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&sort=created_at%3A1&search_engine=v3\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Sort Search Results",
  "description": "Learn how to sort search results by passing a field:order value to the sort parameter.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-by-id-endpoint",
  "markdown": "# Retrieve Users with the Get Users by ID Endpoint\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users/%7BuserId%7D' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/%7BuserId%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users/%7BuserId%7D',\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/%7BuserId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/%7BuserId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users/%7BuserId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/%7BuserId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/%7BuserId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "Retrieve Users with the Get Users by ID Endpoint",
  "description": "Learn how to retrieve lists of users using the get-users-by-id endpoint.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-search/view-search-results-by-page",
  "markdown": "# View Search Results by Page\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&page=2&per_page=10&include_totals=true&search_engine=v3' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&page=2&per_page=10&include_totals=true&search_engine=v3\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&page=2&per_page=10&include_totals=true&search_engine=v3\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&page=2&per_page=10&include_totals=true&search_engine=v3\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users',\n  params: {\n    q: 'logins_count:[100 TO 200]',\n    page: '2',\n    per_page: '10',\n    include_totals: 'true',\n    search_engine: 'v3'\n  },\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&page=2&per_page=10&include_totals=true&search_engine=v3\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&page=2&per_page=10&include_totals=true&search_engine=v3\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&page=2&per_page=10&include_totals=true&search_engine=v3\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&page=2&per_page=10&include_totals=true&search_engine=v3\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users?q=logins_count%3A%5B100%20TO%20200%5D&page=2&per_page=10&include_totals=true&search_engine=v3\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "View Search Results by Page",
  "description": "Learn how to view search results page by page and include totals.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-migration/bulk-user-exports",
  "markdown": "# Bulk User Exports\n\nYou can use the `POST /api/v2/jobs/users-exports` endpoint to create a job that exports all users associated with a [connection](https://auth0.com/docs/identityproviders), or all users in the tenant.\n\nFor a list of user profile fields that can be exported, read [User Profile Structure](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure).\n\nWhen you create your job, you'll need to provide:\n\n*   [ID for the connection](https://auth0.com/docs/authenticate/identity-providers/locate-the-connection-id) from which you want to export users (optional)\n    \n*   Format of the export file (CSV or JSON-compatible)\n    \n*   Maximum number of user records to be exported (optional, will export all records if omitted)\n    \n*   User-related fields (such as user ID or name) that you want included in the export\n    \n\nYou'll also need a valid [Management API Access Token](https://auth0.com/docs/api/management/v2/tokens).\n\n## Create a request body\n\nOptionally, find the `connection_id` and your Auth0 tenant domain name in the Auth0 Dashboard. Create a new text file with the request body below:\n\n```\n{\n   \"connection_id\":\"connection_id\",\n   \"format\":\"csv\",\n   \"limit\":20,\n   \"fields\":[\n      {\n         \"name\":\"user_id\"\n      },\n      {\n         \"name\":\"email\"\n      },\n      {\n         \"name\":\"user_metadata.country\"\n      }\n   ]\n}\n```\n\nUpdate the `connection_id` with your database connection ID, or remove it to export all users in the tenant.\n\n## Request example\n\nRequired Scopes: `read:users`\n\n*   [cURL](#9b7d99d7001449b5978d90cf7a63bed9_shell)\n*   [C#](#9b7d99d7001449b5978d90cf7a63bed9_csharp)\n*   [Go](#9b7d99d7001449b5978d90cf7a63bed9_go)\n*   [Java](#9b7d99d7001449b5978d90cf7a63bed9_java)\n*   [Node.JS](#9b7d99d7001449b5978d90cf7a63bed9_node)\n*   [Obj-C](#9b7d99d7001449b5978d90cf7a63bed9_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/jobs/users-exports' \\\n  --header 'authorization: Bearer {yourMgmtAPIAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"connection_id\": \"{yourConnectionId}\", \"format\": \"csv\", \"limit\": 5, \"fields\": [{\"name\": \"email\"}, { \"name\": \"identities[0].connection\", \"export_as\": \"provider\" }]}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/jobs/users-exports\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtAPIAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"csv\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, { \\\"name\\\": \\\"identities[0].connection\\\", \\\"export_as\\\": \\\"provider\\\" }]}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/jobs/users-exports\"\n\n\tpayload := strings.NewReader(\"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"csv\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, { \\\"name\\\": \\\"identities[0].connection\\\", \\\"export_as\\\": \\\"provider\\\" }]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtAPIAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/jobs/users-exports\")\n  .header(\"authorization\", \"Bearer {yourMgmtAPIAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"csv\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, { \\\"name\\\": \\\"identities[0].connection\\\", \\\"export_as\\\": \\\"provider\\\" }]}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/jobs/users-exports',\n  headers: {\n    authorization: 'Bearer {yourMgmtAPIAccessToken}',\n    'content-type': 'application/json'\n  },\n  data: {\n    connection_id: '{yourConnectionId}',\n    format: 'csv',\n    limit: 5,\n    fields: [{name: 'email'}, {name: 'identities[0].connection', export_as: 'provider'}]\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtAPIAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"connection_id\": @\"{yourConnectionId}\",\n                              @\"format\": @\"csv\",\n                              @\"limit\": @5,\n                              @\"fields\": @[ @{ @\"name\": @\"email\" }, @{ @\"name\": @\"identities[0].connection\", @\"export_as\": @\"provider\" } ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/jobs/users-exports\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/jobs/users-exports\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"csv\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, { \\\"name\\\": \\\"identities[0].connection\\\", \\\"export_as\\\": \\\"provider\\\" }]}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtAPIAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"csv\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, { \\\"name\\\": \\\"identities[0].connection\\\", \\\"export_as\\\": \\\"provider\\\" }]}\"\n\nheaders = {\n    'authorization': \"Bearer {yourMgmtAPIAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/jobs/users-exports\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/jobs/users-exports\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtAPIAccessToken}'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"csv\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, { \\\"name\\\": \\\"identities[0].connection\\\", \\\"export_as\\\": \\\"provider\\\" }]}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourMgmtAPIAccessToken}\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\n  \"connection_id\": \"{yourConnectionId}\",\n  \"format\": \"csv\",\n  \"limit\": 5,\n  \"fields\": [\n    [\"name\": \"email\"],\n    [\n      \"name\": \"identities[0].connection\",\n      \"export_as\": \"provider\"\n    ]\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/jobs/users-exports\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nThe response should look something like this:\n\n```\n{\n  \"type\": \"users_export\",\n  \"status\": \"pending\",\n  \"connection_id\": \"con_0000000000000001\",\n  \"format\": \"csv\",\n  \"limit\": 5,\n  \"fields\": [\n    {\n      \"name\": \"user_id\"\n    },\n    {\n      \"name\": \"name\"\n    },\n    {\n      \"name\": \"email\"\n    },\n    {\n      \"name\": \"identities[0].connection\",\n      \"export_as\": \"provider\"\n    }\n  ],\n  \"connection\": \"Username-Password-Authentication\",\n  \"created_at\": \"2017-11-02T23:34:03.803Z\",\n  \"id\": \"job_coRQCC3MHztpuTlo\"\n}\n```\n\n## Include user metadata in exported CSV\n\nIf you export user data in CSV format and want to include metadata information, specify each metadata field that you want to export. You can export up to 30 fields.\n\nFor example, for metadata structured like this:\n\n```\n{\n  \"consent\": {\n      \"given\": true,\n      \"date\": \"01/23/2019\",\n      \"text_details\": \"{yourURL}\"\n  }\n}\n```\n\nThe export request (for all three fields) would look like this:\n\n*   [cURL](#0262b9c83e5a4a9e93a46746aa046be1_shell)\n*   [C#](#0262b9c83e5a4a9e93a46746aa046be1_csharp)\n*   [Go](#0262b9c83e5a4a9e93a46746aa046be1_go)\n*   [Java](#0262b9c83e5a4a9e93a46746aa046be1_java)\n*   [Node.JS](#0262b9c83e5a4a9e93a46746aa046be1_node)\n*   [Obj-C](#0262b9c83e5a4a9e93a46746aa046be1_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/jobs/users-exports' \\\n  --header 'authorization: Bearer {yourMgmtAPIAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"connection_id\": \"{yourConnectionId}\", \"format\": \"csv\", \"limit\": 5, \"fields\": [{\"name\": \"email\"}, {\"name\": \"user_metadata.consent.given\"}, {\"name\": \"user_metadata.consent.date\"}, {\"name\": \"user_metadata.consent.text_details\"}]}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/jobs/users-exports\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtAPIAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"csv\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, {\\\"name\\\": \\\"user_metadata.consent.given\\\"}, {\\\"name\\\": \\\"user_metadata.consent.date\\\"}, {\\\"name\\\": \\\"user_metadata.consent.text_details\\\"}]}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/jobs/users-exports\"\n\n\tpayload := strings.NewReader(\"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"csv\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, {\\\"name\\\": \\\"user_metadata.consent.given\\\"}, {\\\"name\\\": \\\"user_metadata.consent.date\\\"}, {\\\"name\\\": \\\"user_metadata.consent.text_details\\\"}]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtAPIAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/jobs/users-exports\")\n  .header(\"authorization\", \"Bearer {yourMgmtAPIAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"csv\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, {\\\"name\\\": \\\"user_metadata.consent.given\\\"}, {\\\"name\\\": \\\"user_metadata.consent.date\\\"}, {\\\"name\\\": \\\"user_metadata.consent.text_details\\\"}]}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/jobs/users-exports',\n  headers: {\n    authorization: 'Bearer {yourMgmtAPIAccessToken}',\n    'content-type': 'application/json'\n  },\n  data: {\n    connection_id: '{yourConnectionId}',\n    format: 'csv',\n    limit: 5,\n    fields: [\n      {name: 'email'},\n      {name: 'user_metadata.consent.given'},\n      {name: 'user_metadata.consent.date'},\n      {name: 'user_metadata.consent.text_details'}\n    ]\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtAPIAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"connection_id\": @\"{yourConnectionId}\",\n                              @\"format\": @\"csv\",\n                              @\"limit\": @5,\n                              @\"fields\": @[ @{ @\"name\": @\"email\" }, @{ @\"name\": @\"user_metadata.consent.given\" }, @{ @\"name\": @\"user_metadata.consent.date\" }, @{ @\"name\": @\"user_metadata.consent.text_details\" } ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/jobs/users-exports\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/jobs/users-exports\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"csv\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, {\\\"name\\\": \\\"user_metadata.consent.given\\\"}, {\\\"name\\\": \\\"user_metadata.consent.date\\\"}, {\\\"name\\\": \\\"user_metadata.consent.text_details\\\"}]}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtAPIAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"csv\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, {\\\"name\\\": \\\"user_metadata.consent.given\\\"}, {\\\"name\\\": \\\"user_metadata.consent.date\\\"}, {\\\"name\\\": \\\"user_metadata.consent.text_details\\\"}]}\"\n\nheaders = {\n    'authorization': \"Bearer {yourMgmtAPIAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/jobs/users-exports\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/jobs/users-exports\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtAPIAccessToken}'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"csv\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, {\\\"name\\\": \\\"user_metadata.consent.given\\\"}, {\\\"name\\\": \\\"user_metadata.consent.date\\\"}, {\\\"name\\\": \\\"user_metadata.consent.text_details\\\"}]}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourMgmtAPIAccessToken}\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\n  \"connection_id\": \"{yourConnectionId}\",\n  \"format\": \"csv\",\n  \"limit\": 5,\n  \"fields\": [[\"name\": \"email\"], [\"name\": \"user_metadata.consent.given\"], [\"name\": \"user_metadata.consent.date\"], [\"name\": \"user_metadata.consent.text_details\"]]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/jobs/users-exports\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### JSON-compatible format\n\nIf you export the data in JSON-compatible format, you only need to provide the root property; you do not need to name each individual inner property since they will be included automatically.\n\nAuth0's export files use the [ndjson](https://github.com/ndjson/ndjson-spec) format due to the large size of the export files, while the import functionality expects a JSON file.\n\nBefore you can import users using an export generated by Auth0, you'll need to convert the file from **ndjson** to **json** using the library of your choice (such as [jq](https://stedolan.github.io/jq/)).\n\nIn this case, for the same example we used before, the request would look like this:\n\n*   [cURL](#dc0cdbe7f1b6425ba304a3b4ff7506e7_shell)\n*   [C#](#dc0cdbe7f1b6425ba304a3b4ff7506e7_csharp)\n*   [Go](#dc0cdbe7f1b6425ba304a3b4ff7506e7_go)\n*   [Java](#dc0cdbe7f1b6425ba304a3b4ff7506e7_java)\n*   [Node.JS](#dc0cdbe7f1b6425ba304a3b4ff7506e7_node)\n*   [Obj-C](#dc0cdbe7f1b6425ba304a3b4ff7506e7_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/jobs/users-exports' \\\n  --header 'authorization: Bearer {yourMgmtAPIAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"connection_id\": \"{yourConnectionId}\", \"format\": \"json\", \"limit\": 5, \"fields\": [{\"name\": \"email\"}, {\"name\": \"user_metadata.consent\"}]}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/jobs/users-exports\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtAPIAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"json\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, {\\\"name\\\": \\\"user_metadata.consent\\\"}]}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/jobs/users-exports\"\n\n\tpayload := strings.NewReader(\"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"json\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, {\\\"name\\\": \\\"user_metadata.consent\\\"}]}\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtAPIAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/jobs/users-exports\")\n  .header(\"authorization\", \"Bearer {yourMgmtAPIAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"json\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, {\\\"name\\\": \\\"user_metadata.consent\\\"}]}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/jobs/users-exports',\n  headers: {\n    authorization: 'Bearer {yourMgmtAPIAccessToken}',\n    'content-type': 'application/json'\n  },\n  data: {\n    connection_id: '{yourConnectionId}',\n    format: 'json',\n    limit: 5,\n    fields: [{name: 'email'}, {name: 'user_metadata.consent'}]\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtAPIAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"connection_id\": @\"{yourConnectionId}\",\n                              @\"format\": @\"json\",\n                              @\"limit\": @5,\n                              @\"fields\": @[ @{ @\"name\": @\"email\" }, @{ @\"name\": @\"user_metadata.consent\" } ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/jobs/users-exports\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/jobs/users-exports\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"json\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, {\\\"name\\\": \\\"user_metadata.consent\\\"}]}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtAPIAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"json\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, {\\\"name\\\": \\\"user_metadata.consent\\\"}]}\"\n\nheaders = {\n    'authorization': \"Bearer {yourMgmtAPIAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/jobs/users-exports\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/jobs/users-exports\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtAPIAccessToken}'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"connection_id\\\": \\\"{yourConnectionId}\\\", \\\"format\\\": \\\"json\\\", \\\"limit\\\": 5, \\\"fields\\\": [{\\\"name\\\": \\\"email\\\"}, {\\\"name\\\": \\\"user_metadata.consent\\\"}]}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {yourMgmtAPIAccessToken}\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\n  \"connection_id\": \"{yourConnectionId}\",\n  \"format\": \"json\",\n  \"limit\": 5,\n  \"fields\": [[\"name\": \"email\"], [\"name\": \"user_metadata.consent\"]]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/jobs/users-exports\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Check export status\n\nOnce you've created your job to export your users, you can check on its status using the [Get a Job endpoint](https://auth0.com/docs/api/management/v2#!/Jobs/get_jobs_by_id).\n\nProvide the ID of the job (which you received in the response when creating the job). If you're using the sample request below, replace the placeholder `{yourJobId}` with the value of the ID.\n\nRequire Scopes: `create:users`, `read:users`, `create:passwords_checking_job`\n\n*   [cURL](#53fcd33679784fcfaa96167063db4ebf_shell)\n*   [C#](#53fcd33679784fcfaa96167063db4ebf_csharp)\n*   [Go](#53fcd33679784fcfaa96167063db4ebf_go)\n*   [Java](#53fcd33679784fcfaa96167063db4ebf_java)\n*   [Node.JS](#53fcd33679784fcfaa96167063db4ebf_node)\n*   [Obj-C](#53fcd33679784fcfaa96167063db4ebf_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D' \\\n  --header 'authorization: Bearer {yourMgmtAPIAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtAPIAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtAPIAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D\")\n  .header(\"authorization\", \"Bearer {yourMgmtAPIAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D',\n  headers: {authorization: 'Bearer {yourMgmtAPIAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtAPIAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtAPIAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtAPIAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/jobs/%7ByourJobId%7D\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtAPIAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtAPIAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/jobs/%7ByourJobId%7D\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou should get a response like the following:\n\n```\n{\n  \"type\": \"users_export\",\n  \"status\": \"completed\",\n  \"connection_id\": \"con_lCvO...a\",\n  \"format\": \"csv\",\n  \"limit\": 5,\n  \"fields\": [\n    {\n      \"name\": \"user_id\"\n    },\n    {\n      \"name\": \"name\"\n    },\n    {\n      \"name\": \"email\"\n    },\n    {\n      \"name\": \"identities[0].connection\",\n      \"export_as\": \"provider\"\n    }\n  ],\n  \"location\": \"pus3-auth0-export-users-us-east-2.s3.us-east-2.amazonaws.com/job_coRQCC3MHztpuTlo/auth0docs2.csv.gz?Expires=1509725589&Key-Pair-Id=APKAJPL62IJALBDMSSCA&Signature=l2JaFXP~BATnfagb64PK-qbX9QaZREDYNW0q5QeHuV-MaDpZjpABDXfHHLh2SsCMQz~UO-QsCSfI81l0lvCKzZPZL6cZHK7f~ixlZOK~MHKJuvMqsUZMbNluNAwhFmgb2fZ86yrB1c-l2--H3lMELAk7hKUwwSrNBlsfbMgQ-i41nMNnsYdy3AVlNVQkwZyx~w-IEHfJDHsqyjia-jfDbIOLQvr8~D9PwZ-xOzROxDwgxrt3undtz80bkgP5hRKOAbHC7Y-iKWa2bzNZYHqzowTrlh7Ta60cblJR46NfF9cNqn9jqRGVv-lsvUD9FxnImCCk~DL6npJnzNLjHvn4-CaWq6KdQnwWgCnZ3LZkxXDVWLLIQQaoc6i~xbuGnnbtKRePFSnpqbt2mAUYasdxTOWuUVK8wHhtfZmRYtCpwZcElXFO9Qs~PTroYZEiS~UHH5byMLt2x4ChkHnTG7pIhLAHN~bCOLk8BN2lOkDBUASEVtuJ-1i6cKCDqI2Ro9YaKZcCYzeQvKwziX6cgnMchmaZW77~RMOGloi2EffYE31OJHKiSVRK7RGTykaYN5S2Sg7W0ZOlLPKBtCGRvGb8rJ6n3oPUiOC3lSp7v0~dkx1rm-jO8mKWZwVtC0~4DVaXsn8KXNbj0LB4mjKaDHwXs16uH1-aCfFnMK7sZC2VyCU_\",\n  \"connection\": \"Username-Password-Authentication\",\n  \"created_at\": \"2017-11-02T23:34:03.803Z\",\n  \"id\": \"job_coRQCC3MHztpuTlo\"\n}\n```\n\n## Find export data\n\nYou can access your export files using the URL provided as the value for the **location** parameter. The name of your tenant is also the name of your file. For example, if your tenant name is `auth0docs`, then your file will be `auth0docs.csv` or `auth0docs.json`. When you navigate to the URL, you will automatically begin downloading the file.\n\nThe download link is valid for 60 seconds. If this time period expires, you have 24 hours to call it again before the job expires.\n\n## Job Cleanup\n\nAll of your job-related data is automatically deleted after 24 hours and cannot be accessed afterward. As such, **we strongly recommend storing the job results using the storage mechanism of your choice**.",
  "title": "Bulk User Exports",
  "description": "Learn how to export lists of users and user metadata.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-search/user-search-best-practices",
  "markdown": "# User Search Best Practices\n\nHere are some best practices for user search:\n\n*   You need a token to make requests to the Management API. To learn more, read [Management API Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens).\n    \n*   To perform user search requests, the `read:users` scope is required.\n    \n*   To get the latest search results, use an **immediately consistent** endpoint during authentication processes, such as [Get Users by ID](https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-by-id-endpoint) and [Get Users by Email](https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-by-email-endpoint). Searches using these endpoints reflect the results of all successful write operations including those that occurred shortly prior to your request.\n    \n*   Use a well-known schema for metadata:\n    \n    *   Use consistent data types for properties.\n        \n    *   Avoid dynamic property names.\n        \n    *   Avoid large schema sizes and deep structures.\n        \n    *   Avoid storing data you do not need for authentication and authorization purposes.\n        \n*   Search queries time out (HTTP status code 503) if they're not completed in two seconds or less. Queries that take longer indicate that it's either an expensive query or that the query has an error resulting in it not completing quickly\n    \n*   Don't use a search criteria that returns a large data set (more than 1000 results).\n    \n*   Don't use existence queries (for example, \"give me all users with a property regardless of its value\").\n    \n*   Don't poll the search APIs.\n    \n*   Don't perform user search requests within login flow extension points, such as Rules or `post-login` Actions.\n    \n*   Don't use large metadata fields (try to keep metadata fields to 2 KB or less).\n    \n*   Using wildcard on searches can affect performance. In some cases, wildcard searches on large data sets can result in time out errors. We also recommend avoiding wildcards prefixed to the search term, while using them as suffixes yields better performance.\n    \n*   Escape the space character to improve performance (e.g., `q=name:John Doe` should be written as `q=name:John\\ Doe`).",
  "title": "User Search Best Practices",
  "description": "Learn about best practices when searching for users in Auth0",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/create-first-organization",
  "markdown": "# Create Your First Organization\n\nTo begin using the [Organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview) feature, you must create and configure your organizations.\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Create an organization\n\nWhen you [create an organization](https://auth0.com/docs/manage-users/organizations/configure-organizations/create-organizations), the settings you define are used to customize the login page and email templates that end-users see when they authenticate in the context of the organization.\n\nWhen using Organizations out-of-the-box, these settings will override the settings for Universal Login pages. To learn more about further customizing the login page or email templates, read [Customize prompts and email templates](#customize-prompts-and-email-templates).\n\n## Define organization behavior\n\nYou may be familiar with applications like Heroku that present different behaviors depending on whether a user logs in with a personal account or selects an organization associated with their business account. Auth0 allows you to define similar organization behavior at the application level.\n\nFor each application you create in Auth0, you can decide whether end-users should log in directly or be required to authenticate in the context of an organization. For applications that require users to log in via an organization, you can also specify what happens if one is not provided to the login flow.\n\nYou may also want to update your Application's **Allowed Callback URLs** and **Allowed Origins (CORs)** [application settings](https://auth0.com/docs/get-started/applications/application-settings) to include Organization [placeholders for subdomains](https://auth0.com/docs/get-started/applications/wildcards-for-subdomains).\n\n## Customize prompts and email templates\n\nWhen using Organizations with Universal Login out-of-the-box prompts, the branding settings you configure when you [create organizations](https://auth0.com/docs/manage-users/organizations/configure-organizations/create-organizations) override the branding for Universal Login pages and email templates. If you would like to further modify the Universal Login pages and emails that the end-user receives, you can customize page and email templates.\n\n### Page templates\n\nTo modify Universal Login page, customize a page template using the [Liquid template language](https://shopify.github.io/liquid/) and template variables, then apply the template using the Universal Login Page Templates API. To learn more, read [Universal Login Page Templates](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates).\n\nBecause the same template is used for all pages, you can implement consistent login pages with minimum effort.\n\nThe simplest template you can write is:\n\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    {%- auth0:head -%}\n  </head>\n  <body>\n    {%- auth0:widget -%}\n  </body>\n</html>\n```\n\nThe following tags must be present in the template:\n\n*   `**auth0:widget**`: Contains the HTML that structures the widget displayed on every page type (e.g., Login, Reset Password).\n    \n*   **`auth0:head`**: Contains tags required to render the widget.\n    \n\nTo center the widget in the page, replace the `<body>` tag with `<body class=\"_widget-auto-layout\">`.\n\n### Email templates\n\nTo modify emails the end-user receives, customize an email template using the [Liquid template language](https://shopify.github.io/liquid/) and template variables. To learn more, read [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\nThe following email templates can be further customized for organizations:\n\n*   **Welcome**: Received by the end-user once they verify their email address or, if email verification is disabled, when they sign up (or log in for the first time).\n    \n*   **Password Change**: Received by the end-user when they request a password change. Contains a link that redirects them to the Password Reset page.\n    \n*   **Invite User**: Received by the end-user when they are invited to an organization. Contains a link that redirects them to your configured default login route. To learn more, read [Invite Organization Members](https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members).\n    \n\n### Template variables\n\nPage and email templates may access a set of context variables that you can use to impact how the template is rendered.\n\nFor lists of available variables, read [Universal Login Page Templates](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates) for page template variables and [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates) for common email template variables.\n\nAdditional variables are available to the page template when a user logs in through an organization:\n\n*   `organization.id`\n    \n*   `organization.display_name`\n    \n*   `organization.name`\n    \n*   `organization.metadata`\n    \n*   `organization.branding.logo_url`\n    \n*   `organization.branding.colors.primary`\n    \n*   `organization.branding.colors.page_background`\n    \n\n## Configure organization membership\n\nEach organization has its own associated members, which represent the users who can access your applications by logging in through the organization’s configured login page.\n\nSaaS and B2B applications are usually provided to teams rather than to isolated individual users. In this context, a team could be an entire company, a small set of employees (for example, the marketing department), or even a transient group of users that are organized around a purpose (for example, a group of neighbors who have signed up to work with a charity and are competing as a team to raise the most money for a cause).\n\nOrganizations in Auth0 are flexible enough to support all of these use cases, but require some planning when building an application that supports teams. One of the first things to consider is how to manage team membership, which you can accomplish by:\n\n*   [Inviting users via email](https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members)\n    \n*   [Granting just-in-time membership](https://auth0.com/docs/manage-users/organizations/configure-organizations/grant-just-in-time-membership) to users that log in via an enabled connection\n    \n*   Directly managing membership via the Management API or Auth0 Dashboard by [assigning members](https://auth0.com/docs/manage-users/organizations/configure-organizations/assign-members) or [removing members](https://auth0.com/docs/manage-users/organizations/configure-organizations/remove-members)\n    \n\nOnce membership is defined, you can [retrieve members of organizations](https://auth0.com/docs/manage-users/organizations/configure-organizations/retrieve-members) or [retrieve a user's organization membership](https://auth0.com/docs/manage-users/organizations/configure-organizations/retrieve-user-membership).\n\n## Assign roles to members\n\nEach organization member can be assigned one or more roles, which are applied when users log in through the organization. Specifically, you can [add roles to organization members](https://auth0.com/docs/manage-users/organizations/configure-organizations/add-member-roles), [remove roles from organization members](https://auth0.com/docs/manage-users/organizations/configure-organizations/remove-member-roles), or [retrieve member roles for an organization](https://auth0.com/docs/manage-users/organizations/configure-organizations/retrieve-member-roles). You can use roles and their associated permissions to control access to [applications that you build](https://auth0.com/docs/manage-users/organizations/custom-development). To learn more about roles, read [Role-base Access Control](https://auth0.com/docs/manage-users/access-control/rbac).\n\n## Learn more\n\n*   [Understand How Auth0 Organizations Work](https://auth0.com/docs/manage-users/organizations/organizations-overview)\n*   [Custom Development with Organizations](https://auth0.com/docs/manage-users/organizations/custom-development)\n*   [Work with Tokens and Organizations](https://auth0.com/docs/manage-users/organizations/using-tokens)\n*   [Configure Organizations](https://auth0.com/docs/manage-users/organizations/configure-organizations)",
  "title": "Create Your First Organization",
  "description": "Learn how to create your first organization.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/login-flows-for-organizations",
  "markdown": "# Login Flows for Organizations\n\n[Auth0 Organizations](https://auth0.com/docs/manage-users/organizations) allows leaders of B2B products or SaaS applications to build multi-tenant architectures, store identification tokens appropriately, and minimize end user login friction.\n\n#### Configure Your Application to Use Organizations\n\nYour [Auth0 Application](https://auth0.com/docs/get-started/applications) can be configured in the [Organizations](https://auth0.com/docs/manage-users/organizations/configure-organizations/define-organization-behavior) tab to support three user types: Individuals, Business Users, or Both.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/Rz0i0zgIY7Yugx8M3D7pw/4cf50e68d32dc931ca18caae8cf48146/image3.png)\n\nApplications designed explicitly for consumers - for example, Netflix or Spotify - likely do **not** need Organization management. By choosing **Individuals**, users log in to the application directly and Organization context is not provided.\n\nB2B or SaaS applications - for example, Slack or Jira - are better-served by **Business Users,** so end users can only access your application in the context of an Auth0 Organization. Users in multiple Organizations are directed to the Organization Picker after the login flow, which displays the previous 20 organizations they joined. \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3b6s5amCEjFyRTKWkTrFZI/ae9cd3bcbd55d299d7bdddfb8747ea0b/image4.png)\n\nChoose **Both** if your end user may maintain both a personal and business account with your application. For example, Github often stores both personal and professional code repositories.\n\nYou can configure your application's user type through the Auth0 Dashboard (as described above) or the Management API. Specifically, use the `organization_usage` parameter of the [Update a client](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id) endpoint to set the appropriate type of user. For more information on both methods, review [Define Organization Behavior](https://auth0.com/docs/manage-users/organizations/configure-organizations/define-organization-behavior).\n\n#### Configure the Login Flow for your Application\n\nAfter selecting **Business Users** or **Both**, you can further customize the experience that your users have when logging into your application. \n\n![](https://images.ctfassets.net/cdy7uua7fh8z/3e18zLZ8dPeXBohvBLpKAU/a7097d34c7e2aeecdbcf80bb7bc6e960/image1.png)\n\nMost organizations should choose **Prompt for Credentials**, then enable [Identifier First Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first). If you already know the Organization with which a user is attempting to log in, the **No Prompt** option along with [Custom Development with Organizations](https://auth0.com/docs/manage-users/organizations/custom-development) allows your app to maintain a branded and customized login flow. Administrators can further curate the end user experience by enabling the **Prompt for Organization** toggle, which requires users to identify the Organization they’re logging into.\n\nYou can configure the login flow for your application through the Auth0 Dashboard (as described above) or the Management API. Specifically, use the `organization_require_behavior` parameter of the [Update a client](https://auth0.com/docs/api/management/v2/clients/patch-clients-by-id) endpoint to set the appropriate flow. For more information on both methods, review [Define Organization Behavior](https://auth0.com/docs/manage-users/organizations/configure-organizations/define-organization-behavior).\n\n##### Identifier First Authentication\n\nIf your enterprise application uses [Enterprise Federation](https://auth0.com/docs/authenticate/enterprise-connections), you can activate [Identifier First Authentication with Home Realm Discovery](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) in its Authentication Profile. Once enabled, Home Realm Discovery detects email addresses from a known domain and automatically sends them to the proper Workforce login.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/1vyoeNqhRmqP3iYP58X59Y/eaa1556a41b5f4d9a3211f877d284b36/image2.png)\n\nIn this flow, exactly one Auth0 [Database Connection](https://auth0.com/docs/authenticate/database-connections/custom-db) can be used as a fallback when a user’s email domain does not match the identity provider (IdP) domain of any enterprise connections. Users are shown your application’s login prompt instead of an organization’s login prompt, and [Connections that are enabled for the Application](https://auth0.com/docs/get-started/applications/update-application-connections) are visible to the user.\n\nAfter a user provides an email address, Auth0 matches it with Enterprise Connections enabled for this application **and** all Enterprise Connections enabled for Organizations. If a match is found, the user is directed to authenticate with the associated IdP. If no match is found, a password field is displayed.\n\nYou can use the Management API to configure Identifier First Authentication. Specifically, use the `identifier_first` parameter of the [Update prompts settings](https://auth0.com/docs/api/management/v2/prompts/patch-prompts) endpoint.\n\n##### Auto-Membership\n\nInstead of inviting or assigning users to an Organization directly, you may want to allow any user that is able to authenticate with a federated IdP to be granted access to an Organization. For these scenarios, Auth0 recommends the [Auto-Membership](https://auth0.com/docs/manage-users/organizations/configure-organizations/grant-just-in-time-membership) setting.\n\nAuto-membership is typically triggered by [directing a user to log in using the Organization’s login prompt](https://auth0.com/docs/manage-users/organizations/custom-development), which can pass the connection and organization parameters on the user’s behalf. If a user’s desired organization cannot be determined prior to login, the Prompt for Credentials flow grants membership to the sole organization with auto-membership configured.\n\nHowever, there may be scenarios in which you cannot determine a user’s desired organization prior to sending them to log in. In this case, you can use the aforementioned Prompt for Credentials flow but note that the user will only be granted membership in the organization if **one and only one organization** has this connection set as an enabled connection for the organization with auto-membership activated.\n\nYou can use the Management API to configure auto-membership. Specifically, use the `assign_membership_on_login` parameter of the [Modify an organization's connection](https://auth0.com/docs/api/management/v2/organizations/patch-enabled-connections-by-connection-id) endpoint.",
  "title": "Login Flows for Organizations",
  "description": "How to use Auth0 Login Flow with your Organization",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-search/v2",
  "markdown": "# User Search v2\n\nAuth0 allows you, as an administrator, to search for users using [Lucene Query Syntax](http://www.lucenetutorial.com/lucene-query-syntax.html).\n\nThis document provides sample queries and demonstrates how you can search for users. We also suggest that you refer to [Query Syntax](https://auth0.com/docs/manage-users/user-search/v2/query-syntax) for more examples of query string syntax.\n\n## Search for users using the Management API\n\nYou can also search for users using the [Management API](https://auth0.com/docs/api/management/v2). The easiest way to do this is by making use of the **API Explorer**. This technique is discussed briefly below, but please note that the Auth0 Management API is a REST API, so you can make API calls using anything that can make HTTP requests, or by using one of the [Auth0 SDKs](https://auth0.com/docs/libraries).\n\nIn order to make requests to the Management API, you will need a token. Please refer to [Access Tokens for the Management API](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) for more information.\n\n### Search using the API Explorer\n\nTo search users using the [Management API Explorer](https://auth0.com/docs/api/management/v2#!/Users/get_users), go to the **Users** section and then select **List or search users**. Scroll down to the `q` parameter. You can use any query string which uses the [query syntax](https://auth0.com/docs/manage-users/user-search/v2/query-syntax) in this field.\n\n![undefined](https://images.ctfassets.net/cdy7uua7fh8z/018m6DHJ8UzAfNaY0c1Ci5/4d317693627d03b830ca80b0ebe0a82e/search-users-api.png)\n\n## Sorting search results\n\nTo sort the list of users returned from the Management API, you can make use of the `sort` parameter. Use the format `field:order` for the value of the `sort` field, where `field` is the name of the field you want to sort by, and `order` can be `1` for ascending and `-1` for descending. For example, to sort users in ascending order by the `created_at` field you can pass the value of `created_at:1` for the `sort` parameter. Sorting by `app_metadata` or `user_metadata` is not supported.\n\nFor more information on the `sort` and other parameters, please refer to the [Management API Explorer documentation](https://auth0.com/docs/api/management/v2/#!/Users/get_users).\n\n## Exact matching and tokenization\n\nBecause of the manner in which ElasticSearch handles tokenization on `+` and `-`, unexpected results can occur when searching by some fields. For example, when searching for a user whose `name` is `jane` (`name:\"jane\"`), the results will be both for `jane` and `jane-doe`, because both of these contain the exact search term that you used. The difference may not affect some searches, but it will affect others, and provide unanticipated results.\n\nYou can solve this problem either by using structured JSON in your metadata, or by using the raw subfield.\n\n## Using the raw subfield\n\nIf you wish to avoid the potential pitfalls of analyzed data and search for an exact match to your term - an exact string comparison - then for some fields you can use the `raw` subfield, which will be `not_analyzed`.\n\nSo, in the example `name.raw:\"jane\"`, the user data for `jane` would match, but `jane-doe` would not.\n\nThe fields that support `raw` subfield queries are:\n\n*   `identities.connection⁠⁠⁠⁠`\n    \n*   ⁠⁠⁠⁠`identities.provider⁠⁠⁠⁠`\n    \n*   ⁠⁠⁠⁠`identities.user_id⁠⁠⁠⁠`\n    \n*   ⁠⁠⁠⁠`email⁠`\n    \n*   ⁠⁠⁠⁠`phone_number⁠⁠`\n    \n*   ⁠⁠⁠⁠`family_name⁠⁠⁠⁠`\n    \n*   ⁠⁠⁠⁠`given_name⁠⁠⁠⁠`\n    \n*   ⁠⁠⁠⁠`username⁠⁠⁠⁠`\n    \n*   ⁠⁠⁠⁠`name⁠⁠`\n    \n*   ⁠⁠⁠⁠`nickname`\n    \n\n## Example queries\n\nBelow are some example queries to illustrate the kinds of queries that are possible using the Management API V2.\n\n| Use Case | Query |\n| --- | --- |\n| Search for all users whose name _contains_ \"john\" | `name:\"john\"` |\n| Search all users whose name _is_ exactly \"john\" | `name.raw:\"john\"` |\n| Search for all user names starting with \"john\" | `name:john*` |\n| Search for user names that start with \"john\" and end with \"smith\" | `name:john*smith` |\n| Search for all users whose email _is_ exactly \"john@contoso.com\" | `email.raw:\"john@contoso.com\"` |\n| Search for all users whose email is exactly \"john@contoso.com\" or \"mary@contoso.com\" using `OR` | `email.raw:(\"john@contoso.com\" OR \"mary@contoso.com\")` |\n| Search for users without verified email | `email_verified:false OR NOT _exists_:email_verified` |\n| Search for users who have the `user_metadata` field named `name` with the value of \"John Doe\" | `user_metadata.name:\"John Doe\"` |\n| Search for users from a specific connection or provider | `identities.provider:\"google-oauth2\"` |\n| Search for all users that have never logged in | `(NOT _exists_:logins_count OR logins_count:0)` |\n| Search for all users who logged in before 2015 | `last_login:[* TO 2014-12-31]` |\n| Fuzziness: Search for terms that are similar to, but not exactly like, `jhn` | `name:jhn~` |\n| All users with more than 100 logins | `logins_count:>100` |\n| Logins count >= 100 and <= 200 | `logins_count:[100 TO 200]` |\n| Logins count >= 100 | `logins_count:[100 TO *]` |\n| Logins count > 100 and < 200 | `logins_count:{100 TO 200}` |\n\n### Example request\n\nBelow is an example request for searching all users whose email is exactly \"john@contoso.com\".\n\n*   [cURL](#5e39ab105c7e4d0398a0f2e44abd2d0d_shell)\n*   [C#](#5e39ab105c7e4d0398a0f2e44abd2d0d_csharp)\n*   [Go](#5e39ab105c7e4d0398a0f2e44abd2d0d_go)\n*   [Java](#5e39ab105c7e4d0398a0f2e44abd2d0d_java)\n*   [Node.JS](#5e39ab105c7e4d0398a0f2e44abd2d0d_node)\n*   [Obj-C](#5e39ab105c7e4d0398a0f2e44abd2d0d_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users?q=email.raw%3A%22john%40contoso.com%22&search_engine=v2' \\\n  --header 'authorization: Bearer ACCESS_TOKEN'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users?q=email.raw%3A%22john%40contoso.com%22&search_engine=v2\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer ACCESS_TOKEN\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users?q=email.raw%3A%22john%40contoso.com%22&search_engine=v2\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users?q=email.raw%3A%22john%40contoso.com%22&search_engine=v2\")\n  .header(\"authorization\", \"Bearer ACCESS_TOKEN\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users',\n  params: {q: 'email.raw:\"john@contoso.com\"', search_engine: 'v2'},\n  headers: {authorization: 'Bearer ACCESS_TOKEN'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer ACCESS_TOKEN\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users?q=email.raw%3A%22john%40contoso.com%22&search_engine=v2\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users?q=email.raw%3A%22john%40contoso.com%22&search_engine=v2\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer ACCESS_TOKEN\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users?q=email.raw%3A%22john%40contoso.com%22&search_engine=v2\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users?q=email.raw%3A%22john%40contoso.com%22&search_engine=v2\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer ACCESS_TOKEN'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer ACCESS_TOKEN\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users?q=email.raw%3A%22john%40contoso.com%22&search_engine=v2\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```",
  "title": "User Search v2",
  "description": "This page lists several examples of user search queries using query string syntax.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-search/user-search-query-syntax",
  "markdown": "# User Search Query Syntax\n\nWhen searching for users, you can create queries using [Lucene query syntax](http://www.lucenetutorial.com/lucene-query-syntax.html) to refine your search.\n\nThe query string is parsed into a series of terms and operators:\n\n*   A term can be a single word such as `jane` or `smith`.\n    \n*   A term can be a phrase surrounded by double quotes (`\"green apple\"`), which will match all words in the phrase in the same order.\n    \n*   A term without a field name will not match text in the [user metadata](https://auth0.com/docs/manage-users/user-accounts/metadata) fields.\n    \n*   Multiple terms can be grouped together with parentheses to form sub-queries.\n    \n*   Search values for the normalized user fields (`email`, `name`, `given_name`, `family_name`, and `nickname`) are case insensitive. All other fields (including all `app_metadata`/`user_metadata` fields) are case sensitive.\n    \n*   Operators (`AND`, `OR`, `NOT`) work on all normalized user fields and root metadata fields.\n    \n*   Operators should always be capitalized.\n    \n\n## Searchable fields\n\nYou can search for users using all the [normalized user profile fields](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profile-schema) and the fields below:\n\n| Search Field | Data Type | Description |\n| --- | --- | --- |\n| `phone_number` | text | The user's phone number. Only valid for users with SMS connections. |\n| `phone_verified` | boolean | The `true/false` value indicates whether the user's phone number has been verified. Only valid for users with SMS connections. |\n| `logins_count` | integer | The number of times the user has logged in. If a user is blocked and logs in, the blocked session is counted in `logins_count` and updates the `last_login` value. |\n| `created_at` | date time | The timestamp of when the user profile was first created. |\n| `updated_at` | date time | The timestamp of when the user's profile was last updated/modified. |\n| `last_login` | date time | The timestamp of when the user last logged in. In case this property executes from inside a [Rule](https://auth0.com/docs/rules) with the `user` object, the value will be associated with the login that triggered the rule (since rules execute after the actual login). |\n| `last_ip` | text (valid IP address) | The IP address associated with the user's last login. |\n| `blocked` | boolean | The `true` or `false` value indicates if the user has been blocked. Note: `true` _only_ brings back users blocked via the Admin Dashboard and Management API; it does not bring back users blocked by brute force anomaly detection. |\n| `email.domain` | text | The domain part of the user's email. |\n| `organization_id` | text (valid organization ID) | The organization that the user is a member of |\n\nMetadata fields may be used with:\n\n*   boolean\n    \n*   numeric: integer or double\n    \n*   text\n    \n*   objects: in order to search a scalar value nested in another object, use the path to the field. For example, `app_metadata.subscription.plan:\"gold\"`\n    \n*   arrays: in order to search fields in objects nested in arrays, use the path to the field and ignore the array level. For example, `user_metadata.addresses.city:\"Paris\"`\n    \n\nMetadata fields that contain an empty array, empty object, or `null` value are not indexed and cannot be searched for.\n\nRange and wildcard searches are not available on `user_metadata` fields.\n\n## Exact match\n\nTo find exact matches, use double quotes: `name:\"jane smith\"`.\n\nFor example, to find users with the name `jane smith`, use `q=name:\"jane smith\"`:\n\n*   [cURL](#05852b2d24db47e4b198946d08cf64b0_shell)\n*   [C#](#05852b2d24db47e4b198946d08cf64b0_csharp)\n*   [Go](#05852b2d24db47e4b198946d08cf64b0_go)\n*   [Java](#05852b2d24db47e4b198946d08cf64b0_java)\n*   [Node.JS](#05852b2d24db47e4b198946d08cf64b0_node)\n*   [Obj-C](#05852b2d24db47e4b198946d08cf64b0_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users?q=name%3A%22jane%20smith%22&search_engine=v3' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users?q=name%3A%22jane%20smith%22&search_engine=v3\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users?q=name%3A%22jane%20smith%22&search_engine=v3\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users?q=name%3A%22jane%20smith%22&search_engine=v3\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users',\n  params: {q: 'name:\"jane smith\"', search_engine: 'v3'},\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users?q=name%3A%22jane%20smith%22&search_engine=v3\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users?q=name%3A%22jane%20smith%22&search_engine=v3\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users?q=name%3A%22jane%20smith%22&search_engine=v3\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users?q=name%3A%22jane%20smith%22&search_engine=v3\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users?q=name%3A%22jane%20smith%22&search_engine=v3\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Wildcards\n\nWildcard searches can be run on terms using the asterisk character (`*`) to replace zero or more characters. Wildcard searches are not available on `user_metadata` fields.\n\n#### Examples\n\n*   `name:john*` returns all users with `john` at the beginning of their names.\n    \n*   `name:j*` returns all users with `j` at the beginning of their names.\n    \n*   `q=name:john*` returns all users whose names start with `john`.\n    \n*   For suffix matching, literals must have 3 characters or more. For example, `name:*usa` is allowed, but `name:*sa` is not.\n    \n\n*   [cURL](#eae0033ef5104cadb0cd5e480a0deb13_shell)\n*   [C#](#eae0033ef5104cadb0cd5e480a0deb13_csharp)\n*   [Go](#eae0033ef5104cadb0cd5e480a0deb13_go)\n*   [Java](#eae0033ef5104cadb0cd5e480a0deb13_java)\n*   [Node.JS](#eae0033ef5104cadb0cd5e480a0deb13_node)\n*   [Obj-C](#eae0033ef5104cadb0cd5e480a0deb13_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users?q=name%3Ajohn*&search_engine=v3' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users?q=name%3Ajohn*&search_engine=v3\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users?q=name%3Ajohn*&search_engine=v3\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users?q=name%3Ajohn*&search_engine=v3\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users',\n  params: {q: 'name:john*', search_engine: 'v3'},\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users?q=name%3Ajohn*&search_engine=v3\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users?q=name%3Ajohn*&search_engine=v3\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users?q=name%3Ajohn*&search_engine=v3\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users?q=name%3Ajohn*&search_engine=v3\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users?q=name%3Ajohn*&search_engine=v3\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Ranges\n\nYou can use ranges in your user search queries. Range searches are not available on user metadata fields.\n\n*   For inclusive ranges, use square brackets: `[min TO max]`.\n    \n*   For exclusive ranges, use curly brackets: `{min TO max}`.\n    \n*   Curly and square brackets can be combined in the same range expression: `logins_count:[100 TO 200}`.\n    \n*   Use ranges in combination with wildcards. For example, to find all users with more than 100 logins, use `q=logins_count:{100 TO *]`.\n    \n\n*   [cURL](#dbe3eea6a8a247e78127c919a4da25dd_shell)\n*   [C#](#dbe3eea6a8a247e78127c919a4da25dd_csharp)\n*   [Go](#dbe3eea6a8a247e78127c919a4da25dd_go)\n*   [Java](#dbe3eea6a8a247e78127c919a4da25dd_java)\n*   [Node.JS](#dbe3eea6a8a247e78127c919a4da25dd_node)\n*   [Obj-C](#dbe3eea6a8a247e78127c919a4da25dd_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/api/v2/users?q=logins_count%3A%7B100%20TO%20*%5D&search_engine=v3' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users?q=logins_count%3A%7B100%20TO%20*%5D&search_engine=v3\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users?q=logins_count%3A%7B100%20TO%20*%5D&search_engine=v3\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/api/v2/users?q=logins_count%3A%7B100%20TO%20*%5D&search_engine=v3\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/api/v2/users',\n  params: {q: 'logins_count:{100 TO *]', search_engine: 'v3'},\n  headers: {authorization: 'Bearer {yourMgmtApiAccessToken}'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users?q=logins_count%3A%7B100%20TO%20*%5D&search_engine=v3\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users?q=logins_count%3A%7B100%20TO%20*%5D&search_engine=v3\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = { 'authorization': \"Bearer {yourMgmtApiAccessToken}\" }\n\nconn.request(\"GET\", \"/{yourDomain}/api/v2/users?q=logins_count%3A%7B100%20TO%20*%5D&search_engine=v3\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users?q=logins_count%3A%7B100%20TO%20*%5D&search_engine=v3\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer {yourMgmtApiAccessToken}\"]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users?q=logins_count%3A%7B100%20TO%20*%5D&search_engine=v3\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Searchable Profile Attribute Examples\n\nWhen searching for users in the Auth0 Management API, you can filter users by `user_metadata` or `app_metadata`. To do so, you can use Lucene Search Syntax with the `q` parameter.\n\nBecause the Auth0 Management API [list or the search users](https://auth0.com/docs/api/management/v2#!/Users/get_users) endpoint is limited to 1000 results (10 pages of 100 records), filtering is a useful way of ensuring that the most relevant results are returned.\n\nBelow is a sample of a user profile `user_metadata`:\n\n```\n{\n  \"favorite_color\": \"blue\",\n  \"approved\": false,\n  \"preferredLanguage\": \"en\",\n  \"preferences\": {\n    \"fontSize\": 13\n  },\n  \"addresses\":{\n    \"city\":[\"Paris\",\"Seattle\"]\n  }\n}\n```\n\n### Filter metadata attributes\n\nTo return a `user_metadata` value, update the `q` query with a filter for the attribute.\n\nFor `user_metadata` values, you can query the profile directly:\n\n`q: _exists_:user_metadata.fav_color`\n\nThis query returns all user profiles with the `fav_color` attribute in the `user_metadata`.\n\n### Filter metadata nested object attributes and values\n\nYou can also search on nested objects in `user_metadata`:\n\n`q: _exists_:user_metadata.preferences.fontSize`\n\nThis queries all user profiles with `preferences.fontSize` configured in the `user_metadata`.\n\nTo search for the values of a nested object from another object, review the query below:\n\n`q: user_metadata.preferences.fontSize:13`\n\nThis query returns all user profiles that match the `fontSize` attribute with the value of `13`.\n\n### Filter metadata nested array values\n\nYou can use the query below to search fields in nested arrays:\n\n`q: user_metadata.addresses.city:\"Seattle\"`\n\nThis returns all user profiles that return the value of `Seattle` from the `address.city` attributes in the `user_metadata`.\n\n## Learn more\n\n*   [Sort Search Results](https://auth0.com/docs/manage-users/user-search/sort-search-results)\n*   [View Search Results by Page](https://auth0.com/docs/manage-users/user-search/view-search-results-by-page)\n*   [Retrieve Users with the Get Users Endpoint](https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint)",
  "title": "User Search Query Syntax",
  "description": "Describes Auth0's user search query string syntax.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/user-migration/user-import-export-extension",
  "markdown": "# User Import / Export Extension\n\nThe **User Import / Export Extension** allows you to:\n\n*   Bulk import your existing database users into Auth0\n    \n*   Search for and export some (or all) of your Auth0 database users\n    \n\nFor a list of user profile fields that can be imported and exported, see [User Profile Attributes](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure).\n\nYou must be a Dashboard Admin to use this extension.\n\n## Install the extension\n\nTo install this extension, go to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **User Import / Export**.\n\nThe extension does not require any additional configuration before it can be installed, so select **Install** in the informational pop-up window to proceed.\n\n![Dashboard Extensions Users Import/Export Install Extension](https://images.ctfassets.net/cdy7uua7fh8z/6D9Z4RigtgFBZcd861KVlK/6e42ed005ee62b13b44b0fc91d302f6f/Screen_Shot_2021-05-18_at_9.07.39_PM.png)\n\n## Use the extension\n\nAfter you've installed your extension, you'll see it listed in your list of installed extensions. Click on **Import / Export Extension** to launch.\n\n![Dashboard Extensions Installed Extensions tab](https://images.ctfassets.net/cdy7uua7fh8z/7unxnXFjDkSQUvnyvrOyDn/14c456335df4f9334c4fa0020dca8860/Screen_Shot_2021-05-18_at_9.09.04_PM.png)\n\nYou'll be asked to grant permission for the extension to access your Auth0 account for the listed activities the first time you launch the extension.\"\n\n![Dashboard Extensions Authorize the Users Import/Export Extension](https://images.ctfassets.net/cdy7uua7fh8z/5CCKmxUv1HN5nDj9jL8qel/d7f02ccf3f4be166b00bbf217e14144f/Screen_Shot_2021-05-18_at_9.11.01_PM.png)\n\nClick the **check mark** to proceed.\n\nThere are two ways of using this extension:\n\n*   Bulk import your existing database users into Auth0\n    \n*   Search for and export some (or all) of your Auth0 database users\n    \n\nBoth use cases are explained in further detail below.\n\n### Import users\n\nBy default, any time you open the extension, you'll see the **User Import** screen (if you're on the export screen, you can return to this screen by click **Import** in the left-hand navigation bar).\n\n![Dashboard Extensions Users Import Export Import users from file](https://images.ctfassets.net/cdy7uua7fh8z/5JC6p1ZDDCYm9cCEtq0D7N/511c1241b1835772e7121eb5845f179f/import.png)\n\nTo import your users, drag and drop a valid JSON file ([schema and examples here](https://auth0.com/docs/manage-users/user-migration/bulk-user-import-database-schema-and-examples)) onto the area that says **Drop your file here, or click to select**. Alternatively, you can click on this area to browse your files and select the appropriate JSON file. The JSON file should contain the list of users that you are planning to import.\n\nSelect the database connection for which your users will be imported. Please make sure that the connection you choose has been enabled for at least one application.\n\nClick **Start Importing Users** to begin the import process.\n\nWhen done, you'll see the following **Completed** message.\n\n![Dashboard Extensions Users Import Export Import Complete](https://images.ctfassets.net/cdy7uua7fh8z/7hyE3DWBJuFuAulAAnZlfN/23303644d4c706f4c0937bd363bf6699/import-complete.png)\n\nOnce you've imported your users, you can manage them individually using [Auth0 Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n\n### Export users\n\nTo export your existing Auth0 users associated with database connections, select **Export**.\n\n![Dashboard Extensions Users Import Export Export Users page](https://images.ctfassets.net/cdy7uua7fh8z/5wUhbGMjVQKIE9vx2SBIA3/a952aee6cc6027234631334c7174c4a8/export-users.png)\n\nUnder **User Fields**, you can decide which user attributes or expressions should be included in the export. The user attribute can be a static value like `user.user_metadata.name`, or it can be a JavaScript expression like `user.user_metadata.name || user.name`. Expressions will be evaluated during the export runtime. The **column name** value is how the value will be represented in the export.\n\nYou can click the **Add Default Fields** button to automatically select the default fields and populate their column names (this is also a good way for you to visualize how parameters/expressions will appear).\n\nYou can remove extraneous attributes/expressions by clicking on its associated **trash can** icon.\n\nUnder **Settings**, you can:\n\n*   Configure how your exported users are listed by providing a **User Attribute** by which users should be sorted (as well as whether the users should be sorted in ascending or descending order)\n    \n*   Choose your **Export Format**; you can choose between JSON and CSV files\n    \n    ![Dashboard Extensions Users Import Export Settings Export Format](https://images.ctfassets.net/cdy7uua7fh8z/1HVpo1IevSRJbFvwrEKkzf/761fa914f6c33cdee147e07b2c43f7c7/settings.png)\n\nWhen you're ready, click **Export X Users** (where `X` is the number of users you're exporting).\n\nYou can download the file containing your users when the export is complete.\n\n![Dashboard Extensions Users Import Export Progress Indicator Export Complete](https://images.ctfassets.net/cdy7uua7fh8z/2vtH1VMbGBZq1gxxJkM8K7/5086119751b1e38d686c9266fcf6f71e/export-complete.png)\n\n## Update Users\n\nThe Auth0 Management API allows bulk user profile updates to `user_metadata` and `app_metadata` with the User Import/Export Extension.\n\n### Export users\n\nUsing the [export process above](https://auth0.com/docs/customize/extensions/user-import-export-extension#export-users), create a complete export file including all your user attributes.\n\nChoose the JSON format for your export.\n\nDownload the file containing your users when the export is complete.\n\n### Update your configuration\n\nMake a **copy** of the JSON file you downloaded in the previous step.\n\nOpen the copy of the JSON file in a text editor. Your user schema should be similar to the one below:\n\n```\n[\n   {\n      \"Id\":\"auth0|626737a9813c000069daf462\",\n      \"Nickname\":\"testuser1\",\n      \"Name\":\"testuser1@auth0.com\",\n      \"email\":\"testuser1@auth0.com\",\n      \"Connection\":\"Username-Password-Authentication\",\n      \"Created At\":\"2022-04-26T00:07:05.098Z\",\n      \"Updated At\":\"2022-07-06T14:54:19.214Z\"\n   },\n   {\n      \"Id\":\"auth0|62d1a1853bdcf11ff5dca672\",\n      \"Nickname\":\"testuser2\",\n      \"Name\":\"testuser2@auth0.com\",\n      \"email\":\"testuser2@auth0.com\",\n      \"Connection\":\"Username-Password-Authentication\",\n      \"Created At\":\"2022-07-15T17:19:01.531Z\",\n      \"Updated At\":\"2022-07-15T17:19:01.532Z\"\n   },\n   {\n      \"Id\":\"auth0|62d1a1a524f32a4185c9ce23\",\n      \"Nickname\":\"testuser3\",\n      \"Name\":\"testuser3@auth0.com\",\n      \"email\":\"testuser3@auth0.com\",\n      \"Connection\":\"Username-Password-Authentication\",\n      \"Created At\":\"2022-07-15T17:19:33.484Z\",\n      \"Updated At\":\"2022-07-15T17:19:33.484Z\"\n   }\n]\n```\n\nDo not change the user email address because it is the lookup key for users in the database.\n\nTo add an attribute, create a new field in each user schema and update with a value. In the example below, the \"Family Name\" attribute has a value of \"Smith\" with a comma after the new attribute value.\n\nYou can also add the `email_verified` attribute to multiple users and set the value to `true`.\n\n```\n{\n   \"Id\":\"auth0|626737a9813c000069daf462\",\n   \"Nickname\":\"testuser1\",\n   \"Family Name\":\"Smith\",\n   \"Name\":\"testuser1@auth0.com\",\n   \"email\":\"testuser1@auth0.com\",\n   \"email_verified\":true,\n   \"Connection\":\"Username-Password-Authentication\",\n   \"Created At\":\"2022-04-26T00:07:05.098Z\",\n   \"Updated At\":\"2022-07-06T14:54:19.214Z\"\n}\n```\n\nSave the changes to your user file.\n\n### Import updated user profile data\n\nThe `users-import` endpoint allows you to upload your updated user profile file and update several users in one job. Navigate to the [Create import users job endpoint](https://auth0.com/docs/api/management/v2/#!/Jobs/post_users_imports).\n\nAdd your user file to the users parameter and add the database connection ID of the database you want to update.\n\nThe upsert value should be `true` to update the already existing user information. To add your updates, select **Try** or use Postman to import the users.\n\nUse the `job_id` to verify the status with the `jobs` [endpoint](https://auth0.com/docs/api/management/v2/#!/Jobs/get_jobs_by_id).",
  "title": "User Import / Export Extension",
  "description": "Learn about the User Import/Export extension, which allows you to import and export users from or to any database you have configured in your account.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/organizations-overview",
  "markdown": "# Understand How Auth0 Organizations Work\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Business cases\n\nThe Auth0 Organizations feature best supports business-to-business (B2B) implementations that have applications that end-users access.\n\n![B2B Organizations Business Case diagram](https://images.ctfassets.net/cdy7uua7fh8z/4l47Xknr2LpuMSOX0T3yCP/800877a39f474faa0c6d83551d56c337/b2b-business-case.png)\n\nCommon features of B2B implementations include:\n\n*   A product that is licensed to another business for use by their employees.\n    \n*   Each organization requires its own federation and lightweight branding of the authentication experience.\n    \n*   Access levels in the application can be represented by roles that are assigned to members of each organization.\n    \n\nLet’s explore some example business cases to highlight the ways in which Organizations can help.\n\n## Sample scenario\n\nTravel0 is a fictitious company that offers online travel services and has set up an Auth0 tenant. Travel0 has several applications, but we’ll focus on one application that could benefit from using Organizations.\n\n**Travel0 Adventure Management**: An online application that allows its customers to create and market adventures, such as whitewater rafting, horseback riding, and zip lining. Each adventure is led by a guide who can use the application to sign up and manage scheduling. Guides may be either employed by the customer directly or freelance.\n\nCustomers of the application include:\n\n*   **Granite Outpost Rafting and Ziplines**: An established company that directly employs their large staff of guides, but sometimes also reaches out to freelance guides. They have their own IdP that they use for their employees.\n    \n*   **AdventureZ**: A large event company that directly employs a large number of guides, but also uses freelancers, though rarely. They also facilitate their direct employees’ ability to freelance for other companies who are in need of guides. They have their own IdP that they use for their employees.\n    \n*   **Rocky Mountain High Adventures**: A new company just coming to market. The co-founders run most of their tours, and they reach out to freelancers for help during busy times. They don’t have an IT staff, and have neither the time nor inclination to set up their own identity provider (IdP). They have a contract with AdventureZ that allows any AdventureZ employees to freelance for them.\n    \n\n## Planning considerations\n\nWhen setting up organizations, consider the following:\n\n*   **Login experience**: Will users be required to select an organization when logging in? Will users see the application’s default login page or a customized login page for their organization?\n    \n*   **Connection model**: Will any users be shared between organizations? Do users need to be able to log in using an organization’s own internal identity provider?\n    \n*   **Roles**: Does the application need users to have specific roles assigned within their organizations? Do you intend to build a custom dashboard that allows administrators to self-manage their organizations using assigned roles?\n    \n\n### Login experience\n\nFirst, you must decide what the user should experience when they log in to an organization. You can choose to send the end-user directly to a specific Organization’s login prompt in Auth0, or you can send them to a prompt in which they can enter the name of the Organization with which they want to log in.\n\nAdditionally, you must choose whether to use the default Universal Login page that is configured for your application or to customize a login page specific to each organization using page templates. To learn more, see [Create Your First Organization](https://auth0.com/docs/manage-users/organizations/create-first-organization).\n\n### Connection model\n\nEach organization will usually map directly to one of your business customers or partners, but users can be members of multiple organizations. Understanding how users map to customer organizations will help you determine how to model your organizations and connections. There are two user scenarios:\n\n*   **Users are isolated to an organization**: Every user is a member of exactly one organization. Either users will never need to be part of multiple organizations, or it would make more sense for users to create a separate identity for each organization.\n    \n*   **Users are shared between organizations**: Any user may belong to multiple organizations and should be able to use the same identity to navigate between organizations.\n    \n\nUsing our Travel0 Adventure Management example, let’s assume the following users:\n\n*   **Jonno**: A guide who is directly employed by Rocky Mountain High Adventures and who should be able to log in to only Rocky Mountain’s organization. Because Rocky Mountain does not have its own IdP, Jonno’s credentials are stored in the Travel0 database connection and Jonno is assigned membership to the Rocky Mountain organization.\n    \n*   **Hiroko**: A guide who is directly employed by Granite Outpost Rafting and Ziplines and who should be able to log in to only Granite Outpost’s organization. Because Granite Outpost has its own IdP, Hiroko’s credentials may be stored in either the Travel0 database connection or an enterprise connection that Granite Outpost has set up to represent their IdP, and then Hiroko must also be assigned membership in Granite Outpost’s organization. If using Granite Outpost’s IdP, then the enterprise connection must also be enabled for the organization.\n    \n*   **Emilio**: A guide who freelances for both Rocky Mountain High Adventures and Granite Outpost Rafting and Ziplines and should be able to log in to both organizations. If we want Emilio to be able to use the same credentials for both organizations, then Emilio’s credentials should be stored in the Travel0 database connection, and Emilio should be assigned membership in both Rocky Mountain and Granite Outpost organizations. Otherwise, Emilio will need to set up one set of credentials in the Travel0 database connection for Rocky Mountain High Adventures and be assigned membership in the Rocky Mountain High organization, then set up another set of credentials in either the Travel0 database connection or Granite Outpost’s enterprise connection and be assigned membership in the Granite Outpost organization. Finally, if using Granite Outpost’s IdP, the configured enterprise connection must be enabled for the Granite Outpost organization.\n    \n*   **Sumana**: A guide who is directly employed by AdventureZ, but sometimes freelances for Rocky Mountain High Adventures under the contract Rocky Mountain has with AdventureZ. AdventureZ and Rocky Mountain have rating systems for their guides, and Sumana’s ratings need to carry over from AdventureZ to Rocky Mountain and be combined between organizations. Either Sumana’s credentials should be stored in the Travel0 database connection and membership should be assigned for both the Rocky Mountain and AdventureZ organizations, or if AdventureZ wants to share their IdP, then Sumana’s credentials should be stored in an enterprise connection that AdventureZ has set up to represent their IdP and the configured enterprise connection must be enabled for both the Rocky Mountain and AdventureZ organizations. If Sumana is also invited to freelance for Granite Outpost Rafting and Ziplines, then her credentials could be stored in the Travel0 database connection or she could be added to Granite Outpost’s IdP, and membership should be assigned to the Granite Outpost organization.\n    \n\nOnce you have determined how many organizations you will have and what your connection model should look like, you can set up [database](https://auth0.com/docs/connections/database), [social](https://auth0.com/docs/connections/identity-providers-social), or [enterprise](https://auth0.com/docs/connections/identity-providers-enterprise) connections; [create organizations](https://auth0.com/docs/manage-users/organizations/configure-organizations/create-organizations); and [configure organization membership](https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members) or [enable organization connections](https://auth0.com/docs/manage-users/organizations/configure-organizations/enable-connections).\n\n### Roles\n\nMembers of organizations can be [assigned roles](https://auth0.com/docs/manage-users/organizations/configure-organizations/add-member-roles). You can use these roles to define access control for your application. For example, if you built a dashboard for your users using our API and SDKs, you could assign an administrator role to certain members and allow them to self-manage their organizations through your dashboard.\n\n## Limitations\n\nThe Auth0 Organizations feature has the following limitations:\n\n*   Your Auth0 subscription plan affects the availability of this feature. To learn more, read [Auth0 Pricing](https://auth0.com/pricing/).\n    \n*   Supported only for Universal Login (not supported for Classic Login or Lock.js).\n    \n*   Organizations-enabled applications are not compatible with the following grants and protocols: Resource Owner Password, Client Credentials, Device Authorization Flow, WS-Fed (Auth0 as IdP).\n    \n*   Does not support:\n    \n    *   Custom domains per organization (For example, using the sample scenario, if Rocky Mountain High Adventures and Granite Outpost Rafting and Ziplining could both use `login.travel0.com` as login domains, then Organizations would be useful. Alternatively, if Rocky Mountain High Adventures wanted to use `login.rockymountain.com` and Granite Outpost wanted to use `login.graniteoutpost.com`, then you would need to use multiple Auth0 tenants.\n        \n    *   Integration with the Delegated Administration Extension.\n        \n    *   Integration with the Authorization Extension.\n        \n    *   Integration with third-party applications.\n        \n\n## Learn more\n\n*   [Create Your First Organization](https://auth0.com/docs/manage-users/organizations/create-first-organization)\n*   [Custom Development with Organizations](https://auth0.com/docs/manage-users/organizations/custom-development)\n*   [Work with Tokens and Organizations](https://auth0.com/docs/manage-users/organizations/using-tokens)\n*   [Configure Organizations](https://auth0.com/docs/manage-users/organizations/configure-organizations)\n*   [Entity Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/entity-limit-policy)",
  "title": "Understand How Auth0 Organizations Work",
  "description": "Describes how Auth0 Organizations work, use cases, a sample scenario, planning, and limitations.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/custom-development",
  "markdown": "# Custom Development with Organizations\n\nYou can extend Auth0 capabilities using [organization](https://auth0.com/docs/manage-users/organizations/organizations-overview) metadata and Actions, or use our APIs and SDKs to build organization administration dashboards for your users.\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Extensibility\n\nOrganizations support our extensibility points, so you can define properties within organization metadata and expose that data to [Actions](https://auth0.com/docs/customize/actions). This allows you to customize capabilities for individual customers; for example, you can execute custom logic in Actions for certain customers based on their subscription plan by storing that information in organization metadata.\n\n### Actions event object\n\nThe Action event object stores contextual information about the current authentication transaction, such as the user's IP address, application, or location.\n\nIf you change token content using the `event` object within an Action, your changes will be available in tokens after all Actions have finished running.\n\n## SDKs\n\nTo allow members to self-manage their organizations, you can assign roles to members, and use our API and SDKs to build dashboards in your products. Administrators can configure Single Sign-On (SSO), invite users to organizations, assign members to organizations, assign roles to members, and so on.\n\nExample tasks you may want to perform with organizations using the SDKs are outlined below.\n\n### I want users to log in to a specified organization\n\nWhen defining a new client, pass the organization ID into an organization parameter. Then on callback, ensure that the organization returned in the ID token is the same one that was sent in the `/authorize` request by validating the `org_id` claim in the same way that other claims like `exp` and `nonce` are validated.\n\nTo learn more, read:\n\n*   [Add Login Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/add-login-auth-code-flow)\n    \n*   [Call Your API Using the Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow/call-your-api-using-the-authorization-code-flow)\n    \n*   [Add Login Using the Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/add-login-using-the-authorization-code-flow-with-pkce)\n    \n*   [Call Your API Using the Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce/call-your-api-using-the-authorization-code-flow-with-pkce)\n    \n*   [Add Login Using the Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/add-login-using-the-implicit-flow-with-form-post)\n    \n*   [Call Your API Using the Hybrid Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/hybrid-flow/call-api-hybrid-flow)\n    \n\n### From my application, I want to get the organization to which the authenticated user logged in\n\nIf the user was authenticated using an organization, the organization ID will appear in the `org_id` claim in the ID token. Using the Auth0 SPA SDK, this can be retrieved as follows:\n\n`const { org_id } = await client.getIdTokenClaims();`\n\n### From my API, I want to get the organization with which the access token was issued\n\nIf the user was authenticated using an organization and an audience was specified, the access token will be a JWT and will contain the `org_id` claim with the ID of the organization to which the user logged in.\n\nThis can be validated along with the other claims on the backend, as in the following example for Ruby:\n\n```\nclass JsonWebToken\n  def self.verify(token)\n    decoded = JWT.decode(token, nil,\n               true, # Verify the signature of this token\n               algorithms: 'RS256',\n               iss: 'https://YOUR_DOMAIN/',\n               verify_iss: true,\n               aud: Rails.application.secrets.auth0_api_audience,\n               verify_aud: true) do |header|\n      jwks_hash[header['kid']]\n    end\n\n    // Retrieve the organization ID value from the decoded token\n    org = decoded[0]['org_id']\n  end\nend\n```\n\n## Learn more\n\n*   [Understand How Auth0 Organizations Work](https://auth0.com/docs/manage-users/organizations/organizations-overview)\n*   [Create Your First Organization](https://auth0.com/docs/manage-users/organizations/create-first-organization)\n*   [Work with Tokens and Organizations](https://auth0.com/docs/manage-users/organizations/using-tokens)\n*   [Configure Organizations](https://auth0.com/docs/manage-users/organizations/configure-organizations)\n*   [Auth0 Actions](https://auth0.com/docs/customize/actions)",
  "title": "Custom Development with Organizations",
  "description": "Learn to use Actions and SDKs with Auth0 organizations.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/using-tokens",
  "markdown": "# Work with Tokens and Organizations\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nMost identity (ID) tokens and access tokens returned by Auth0 are JSON Web Tokens (JWTs) containing a variety of claims, which are pieces of information asserted about a subject. For example, an [ID token](https://auth0.com/docs/secure/tokens/id-tokens) (which is always a JWT) can contain a claim called `name` that asserts that the name of the user authenticating is \"John Doe\".\n\nThere are two types of JWT claims:\n\n*   **Registered**: Claims defined by the [JWT specification](https://tools.ietf.org/html/rfc7519) to ensure interoperability with third-party, or external, applications. [OpenID Connect (OIDC)](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol) standard claims are reserved claims.\n    \n*   **Custom**: Claims that you define yourself. These claims can be non-registered, collision-resistant public claims or non-registered, non-public private claims subject to collision. Name these claims carefully, such as through [namespacing](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims), to avoid collision with reserved claims or other custom claims. It can be challenging to deal with two claims of the same name that contain differing information.\n    \n\nTo learn more about claims, read [JSON Web Token Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims).\n\n## Authenticate users through an organization\n\nTo authenticate a user through an organization, an `organization` parameter is added to a call to the `/authorize` endpoint. Examples of tokens returned when a user logs in through organizations are provided below.\n\n### ID token\n\nIn the following example, note that `https://marketplace/roles` and `https://namespace.exampleco.com/` are custom claims that have been added to the token, while the other included claims are standard.\n\n```\n{\n  \"https://marketplace/roles\": [\n    \"marketplace-administrator\"\n  ],\n  \"https://namespace.exampleco.com\": \"my custom claim\",\n  \"nickname\": \"firstName.lastName\",\n  \"name\": \"firstName.lastName@email.com\",\n  \"picture\": \"https://s.gravatar.com/avatar/638\",\n  \"updated_at\": \"2021-03-23T11:34:14.566z\",\n  \"email\": \"username@exampleco.com\",\n  \"email_verified\": true,\n  \"sub\": \"auth0|602c0dcab993d10073daf680\",\n  \"org_id\": \"org_9ybsU1dN2dKfDkBi\"\n}\n```\n\n### Access token\n\n```\n{\n  \"iss\": \"https://exampleco.auth0.com/\",\n  \"sub\": \"auth0|602c0dcab993d10073daf680\",\n  \"aud\": [\n    \"https://example-api/\",\n    \"https://exampleco.auth0.com/userinfo\"  \n  ],\n  \"iat\": 1616499255,\n  \"exp\": 1616585655,\n  \"azp\": \"ENDmmAJsbwI1hOG1KPJddQ8LHjV6kLkV\",\n  \"scope\": \"openid profile email\",\n  \"org_id\": \"org_9ybsU1dN2dKfDkBi\",\n  \"permissions\": [\n    \"delete:stuff\",\n    \"read:stuff\",\n    \"write:stuff\"  \n  ]\n}\n```\n\n## Validate tokens\n\nWhen the `organization` parameter is added to a call to the `/authorize` endpoint, Auth0 SDKs automatically validate the `org_id` claim, which is returned as part of any generated tokens. However, for security purposes, additional validation should be performed when tokens are received.\n\n**For web applications:**\n\nIf no `organization` parameter was passed to the `/authorize` endpoint, but an `org_id` claim is present in the ID token, then your application should validate the claim to ensure that the value received is expected or known and that it corresponds to an entity your application trusts, such as a paying customer. If the claim cannot be validated, then the application should deem the token invalid.\n\n**For APIs:**\n\nIf an `org_id` claim is present in the access token, then your API should validate the claim to ensure that the value received is expected or known and that it corresponds to an entity your application trusts, such as a paying customer. If the claim cannot be validated, then the API should deem the token invalid.\n\nIn particular:\n\n*   The `iss` (issuer) claim should be checked to ensure the token was issued by Auth0.\n    \n*   The `org_id` claim should be checked to ensure it is a value that is already known to the application. This could be validated against a known list of organization IDs, or perhaps checked in conjunction with the current request URL. For example, the subdomain may hint at which organization should be used when validating the ID Token.\n    \n\nNormally, validating only the issuer would be enough to ensure that the token was issued by Auth0. In the case of organizations, however, additional checks should be made to ensure that the organization within your Auth0 tenant is expected.\n\n## Learn more\n\n*   [Understand How Auth0 Organizations Work](https://auth0.com/docs/manage-users/organizations/organizations-overview)\n*   [Create Your First Organization](https://auth0.com/docs/manage-users/organizations/create-first-organization)\n*   [Custom Development with Organizations](https://auth0.com/docs/manage-users/organizations/custom-development)\n*   [Configure Organizations](https://auth0.com/docs/manage-users/organizations/configure-organizations)",
  "title": "Work with Tokens and Organizations",
  "description": "Learn how tokens work with Auth0's Organizations feature and how to authenticate users belonging to an organization.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations",
  "markdown": "# Configure Organizations\n\nYou can configure Organizations using the Auth0 Dashboard or Management API. To learn more about the steps involved in configuring your organization, read [Create Your First Organization](https://auth0.com/docs/manage-users/organizations/create-first-organization).\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).",
  "title": "Configure Organizations",
  "description": "Reference the various options you have to configure organizations.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/login-pages/universal-login",
  "markdown": "# Customize Universal Login\n\n[Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) provides the essential feature of an authorization server: the login flow. When a user needs to prove their identity to gain access to your application, you can redirect them to Universal Login and let Auth0 handle the authentication process.\n\nConfiguring Universal Login is dynamic and does not require any application-level changes, as web pages hosted on Auth0’s centralized authentication server completely drive the login flow. Additionally, you don’t need to manually update your code for your applications to benefit from improvements Auth0 makes to Universal Login.\n\nFrom the Auth0 Dashboard, you can customize the appearance and behavior of login pages to create a consistent, branded experience. For advanced use cases, you can also change the code of each page individually.",
  "title": "Customize Universal Login",
  "description": "An overview of Universal Login customization",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/sample-use-cases-role-based-access-control",
  "markdown": "# Sample Use Cases: Role-Based Access Control\n\nLet's take a look at an example of why you might need and how you could use [role-based access control (RBAC)](https://auth0.com/docs/manage-users/access-control/rbac) in your authorization flow.\n\nLet's say you are a business who provides business-to-business software-as-a-service to non-profit organizations. Your product allows non-profits to create, manage, and market products to potential donors. Your application contains several different modules, two of which are:\n\n*   a gift shop point of sale (POS) module that enables non-profits to effectively create pop-up t-shirt shops and manage their sales.\n    \n*   a marketing module that allows non-profits to create and distribute newsletters to their donors.\n    \n\nYou want to use Auth0 to control the access of your non-profit customers to different parts of your application. Without RBAC, all non-profit employees and volunteers will have access to all features of your application, which is not ideal, especially since one of them is an animal rescue who has a variety of volunteers with knowledge of only the area in which they volunteer.\n\nInstead, you implement RBAC, [creating some permissions](https://auth0.com/docs/get-started/apis/add-api-permissions) that users of your gift shop POS module would need:\n\n*   `read:catalog-item`\n    \n*   `read:customer-profile`\n    \n*   `create:invoice`\n    \n\nAnd to make these easier to manage, you [create a role](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/create-roles) called `Gift Shop Manager` and [add these permissions to that role](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/add-permissions-to-roles).\n\nSimilarly, you create permissions for users of your marketing module, which include:\n\n*   `create:newsletter`\n    \n*   `edit:newsletter`\n    \n*   `delete:newsletter`\n    \n*   `send:newsletter`\n    \n*   `edit:distribution-list`\n    \n\nAnd you create a role called `Newsletter Admin` and add these permissions to that role.\n\nNow, when your animal rescue brings in their volunteer, Astrid, to run their pop-up t-shirt shop, Astrid can be [assigned the role](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-roles-to-users) of `Gift Shop Manager`. When you assign this role to Astrid, she is granted all the permissions that you assigned to the role. Since Astrid knows nothing about publishing newsletters (and isn't the best with email), you never assigned her the `Newsletter Admin` role, so she never has access to the marketing module.\n\nFrom a more technical perspective, when Astrid logs into your product, Auth0 authenticates and authorizes her and includes the permissions in the returned Access Token. Then, your product inspects the token to learn which module to display to Astrid.\n\nBy using Auth0's RBAC, you avoid building and maintaining separate authorization systems; instead, you use the token you already receive during authorization. And when Astrid moves away or decides she is tired of running the gift shop and would rather coordinate the foster program, you can easily [](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/remove-roles-from-users)[remove the Gift Shop Manager role](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/remove-roles-from-users) from her and assign her a new role.\n\nAnd if maintaining the roles and permissions for all of your customers becomes too unwieldy, you can also use the Auth0 API to create a module within your product that allows customers to manage their own RBAC, thereby reducing liability and cutting staffing costs.",
  "title": "Sample Use Cases: Role-Based Access Control",
  "description": "Learn how to implement roles-based authorization (RBAC) in different scenarios and explore how to use rules with RBAC.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login",
  "markdown": "# Universal Login vs. Classic Login\n\n[Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) provides the essential feature of an authorization server: the login flow. When a user needs to prove their identity to gain access to your application, you can redirect them to Universal Login and let Auth0 handle the authentication process. \n\nUniversal Login is Auth0's primary hosted login solution. [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience) features easy-to-use customization tools and promotes a simpler, faster experience for end-users. Alternatively, Auth0 also supports [Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience), a hosted login experience that uses JavaScript controls for customization.\n\nTo help you choose the best solution for your needs, the table below compares the features of both login experiences.\n\n| **Feature** | **Universal Login** | **Classic Login** |\n| --- | --- | --- |\n| **Adopt new features without changing HTML** | Yes | No  |\n| **Ongoing development and new feature additions** | Yes | No  |\n| **Lightweight HTML** | Yes | No  |\n| **JavaScript required** | No  | Yes |\n| **Customization** | Yes, using [page templates](https://auth0.com/docs/customize/universal-login-pages/universal-login-page-templates \"Universal login page templates\") or the [no-code editor](https://auth0.com/docs/customize/universal-login-pages/customize-new-universal-login-with-the-no-code-editor) | Yes, using HTML, and only for login, multi-factor authentication (MFA), and password reset pages |\n| **No-Code solution** | Yes, using the [no-code editor](https://auth0.com/docs/customize/universal-login-pages/customize-new-universal-login-with-the-no-code-editor) | No  |\n| **Passwordless authentication** | Yes | Yes, with [SMS or Email](https://auth0.com/docs/connections/passwordless) |\n| **Email magic link** | No  | [Yes](https://auth0.com/docs/authenticate/passwordless/authentication-methods/email-magic-link) |\n| **Passkeys** | [Yes](https://auth0.com/docs/authenticate/database-connections/passkeys \"Passkeys\") | No  |\n| **WebAuthn and device biometrics** | [Yes](https://auth0.com/docs/mfa/fido-authentication-with-webauthn) | No  |\n| **Web Content Accessibility Guidelines (WCAG) Compliance** | Yes | No  |\n| **Organizations support** | [Yes](https://auth0.com/docs/organizations) | No  |\n| **Terms of service acceptance on signup** | Yes | [Yes](https://auth0.com/docs/libraries/lock/lock-configuration#showterms-boolean-) |\n| **Custom fields on signup** | Yes | [Yes](https://auth0.com/docs/libraries/lock/lock-configuration#additionalsignupfields-array-) |\n| **Full localization** | Yes, in [these](https://auth0.com/docs/universal-login/i18n) languages | Only for the login page |\n| **Customizable localized text on all pages** | [Yes](https://auth0.com/docs/universal-login/text-customization) | No  |\n| **Email MFA** | [Yes](https://auth0.com/docs/mfa/configure-email-notifications-for-mfa) | No  |\n| **Voice MFA** | [Yes](https://auth0.com/docs/mfa/configure-sms-voice-notifications-mfa) | No  |\n| **Duo MFA** | Yes, but Duo must be the only MFA factor enabled | Yes |\n| **MFA customization with Actions** | [Yes](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa-selection-nul) | No  |\n| **Buttons for enterprise connections** | [Yes](https://auth0.com/docs/universal-login/identifier-first#define-home-realm-discovery-identity-providers) | No  |\n| **Ability to disable self-service password recovery** | Yes | [Yes](https://auth0.com/docs/libraries/lock/lock-configuration#allowforgotpassword-boolean) |\n| **Custom URLs for password reset and user signup** | Yes, using page templates **and** a custom-built password reset or signup page | [Yes](https://auth0.com/docs/libraries/lock/lock-configuration#forgotpasswordlink-string-) |\n| **Kerberos support for AD/LDAP connections** | No  | [Yes](https://auth0.com/docs/extensions/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos#auto-login-with-lock) |\n| **Requires exposing identity provider domains in a public endpoint** | No  | [Yes](https://auth0.com/docs/config/tenant-settings#advanced) |\n\n## Learn more\n\n*   [Universal Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience)\n*   [Classic Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience)\n*   [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login)",
  "title": "Universal Login vs. Classic Login",
  "description": "Compares features available in the Universal Login and Classic Login experiences",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/login-pages/customize-consent-prompts",
  "markdown": "# Customize Consent Prompts\n\nWhen a third-party application requests scopes, users see a consent prompt. By default, this prompt uses the scope **name** to generate text and groups all scopes for a resource, displaying the resource's actions in a single line.\n\nIf you require a specialized consent prompt, for example, parental consent, you need to build your own custom consent form. Be aware that laws vary according to country.\n\nFor example, let's say you have an Auth0-registered API with the following defined scopes:\n\n*   `read:messages`: Be able to read your email messages\n    \n*   `write:messages`: Write messages\n    \n\nThe consent prompt will display **Messages: read and write your messages**.\n\nInstead, you can use your defined scope **description** to generate this text. In this case, the consent dialog would display: **Be able to read your email messages**, **Write messages**.\n\nThis change is made at the tenant level, so it will affect consent prompts for all APIs on the tenant.\n\n## Use scope descriptions to generate consent prompt text\n\nSet your tenant's **use\\_scope\\_descriptions\\_for\\_consent** flag to `true` by making the following API call:\n\n*   [cURL](#bf38a41d218945f0b5db9d679df700e0_shell)\n*   [C#](#bf38a41d218945f0b5db9d679df700e0_csharp)\n*   [Go](#bf38a41d218945f0b5db9d679df700e0_go)\n*   [Java](#bf38a41d218945f0b5db9d679df700e0_java)\n*   [Node.JS](#bf38a41d218945f0b5db9d679df700e0_node)\n*   [Obj-C](#bf38a41d218945f0b5db9d679df700e0_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/tenants/settings' \\\n  --header 'authorization: Bearer API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"flags\": { \"use_scope_descriptions_for_consent\": true } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/tenants/settings\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/tenants/settings\"\n\n\tpayload := strings.NewReader(\"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/tenants/settings\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/tenants/settings',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {flags: {use_scope_descriptions_for_consent: true}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"flags\": @{ @\"use_scope_descriptions_for_consent\": @YES } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/tenants/settings\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/tenants/settings\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/tenants/settings\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/tenants/settings\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"flags\": [\"use_scope_descriptions_for_consent\": true]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/tenants/settings\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Use scope names to generate consent prompt text\n\nSet your tenant's **use\\_scope\\_descriptions\\_for\\_consent** flag to `false` by making the following API call:\n\n*   [cURL](#bffd3be8551c43e1822b5baf98aaaf65_shell)\n*   [C#](#bffd3be8551c43e1822b5baf98aaaf65_csharp)\n*   [Go](#bffd3be8551c43e1822b5baf98aaaf65_go)\n*   [Java](#bffd3be8551c43e1822b5baf98aaaf65_java)\n*   [Node.JS](#bffd3be8551c43e1822b5baf98aaaf65_node)\n*   [Obj-C](#bffd3be8551c43e1822b5baf98aaaf65_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/tenants/settings' \\\n  --header 'authorization: Bearer API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"flags\": { \"use_scope_descriptions_for_consent\": false } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/tenants/settings\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": false } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/tenants/settings\"\n\n\tpayload := strings.NewReader(\"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": false } }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/tenants/settings\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": false } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/tenants/settings',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {flags: {use_scope_descriptions_for_consent: false}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"flags\": @{ @\"use_scope_descriptions_for_consent\": @NO } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/tenants/settings\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/tenants/settings\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": false } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": false } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/tenants/settings\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/tenants/settings\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": false } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"flags\": [\"use_scope_descriptions_for_consent\": false]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/tenants/settings\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Learn more\n\n*   [Scopes](https://auth0.com/docs/get-started/apis/scopes)\n*   [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims)\n*   [OpenID Connect Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes)\n*   [API Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes)\n*   [Auth0 Security Bulletin for Assigning Scopes Based on Email Address](https://auth0.com/docs/secure/security-guidance/security-bulletins/2019-09-05-scopes)",
  "title": "Customize Consent Prompts",
  "description": "Describes how to customize the consent prompt presented to users during authorization.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/login-pages/classic-login",
  "markdown": "# Customize Classic Login\n\nClassic Login is an Auth0-hosted login experience that relies on JavaScript for customization. Implementing Classic Login is less complex than embedding the authentication process directly in your app, and it can help prevent the dangers of cross-origin authentication.\n\nClassic Login serves as an alternative to [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience). For a feature comparison between the two login experiences, review [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login).",
  "title": "Customize Classic Login",
  "description": "Learn how to customize the Classic Login experience",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/sample-use-cases-rules-with-authorization",
  "markdown": "# Sample Use Cases: Rules with Authorization\n\nWith [rules](https://auth0.com/docs/customize/rules), you can modify or complement the outcome of the decision made by the pre-configured [authorization policy](https://auth0.com/docs/manage-users/access-control/authorization-policies) to handle more complicated cases than is possible with [role-based access control (RBAC)](https://auth0.com/docs/manage-users/access-control/rbac) alone. Based on the order in which they run, rules can change the outcome of the authorization decision prior to the permissions being added to the Access Token. They can also allow you to customize the content of your tokens.\n\n## Allow access only on weekdays for a specific application\n\nLet's say you have an application that you want to make sure is only accessible during weekdays. To do this, you would [create the following rule](https://auth0.com/docs/customize/rules/create-rules):\n\n```\nfunction (user, context, callback) {\n\n  if (context.clientName === 'APP_NAME') {\n    const d = Date.getDay();\n\n    if (d === 0 || d === 6) {\n      return callback(new UnauthorizedError('This app is only available during the week.'));\n    }\n  }\n\n  callback(null, user, context);\n}\n```\n\nIf a user attempts to access the application during the weekend, access will be denied, even if they authenticate and have the appropriate privileges.\n\n## Allow access only to users who are inside the corporate network\n\nLet's say you want to allow access to an application, but only for users who are accessing the application from inside your corporate network. To do this, you would create the following rule:\n\n```\nfunction (user, context, callback) {\n  const ipaddr = require('ipaddr.js@1.9.0');\n  const corp_network = \"192.168.1.134/26\";\n  const current_ip = ipaddr.parse(context.request.ip);\n\n  if (!current_ip.match(ipaddr.parseCIDR(corp_network))) {\n    return callback(new UnauthorizedError('This app is only available from inside the corporate network.'));\n  };\n\n  callback(null, user, context);\n}\n```\n\nIf the user is outside the corporate network, they will be denied access even if they successfully authenticate and have the appropriate privileges.\n\n## Deny access to anyone calling an API\n\nLet's say you want to deny access to all users who are calling an API. This means that you need to deny access depending on the `audience` value for your API, which you can find in the **API Audience** field of your API in [Dashboard > Applications > APIs](https://manage.auth0.com/#/apis). To do this, you would create the following rule:\n\n```\nfunction (user, context, callback) {\n  /*\n   *  Denies access to user-based flows based on audience\n   */\n  var audience = '';\n  audience = audience\n              || (context.request && context.request.query && context.request.query.audience)\n              || (context.request && context.request.body && context.request.body.audience);\n  if (audience === 'http://todoapi2.api' || !audience) {\n    return callback(new UnauthorizedError('end_users_not_allowed'));\n  }\n  return callback(null, user, context);\n}\n```\n\nIn this case, the `audience` value for the API is `http:://todoapi2.api`, so this is the audience we will refuse. If anyone tries to access the API with this `audience` value, they will be denied access and receive an `HTTP 401` response.\n\n## Add user roles to tokens\n\nIf you [enable RBAC for APIs](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis) along with \"Add Permissions in the Access Token\" (or enable RBAC via the Management API and set the **Token Dialect** to `access_token_authz`), you will receive user permissions in your Access Tokens. To add user roles to tokens, you would use the `context.authorization` object when you create the following rule:\n\n```\nfunction (user, context, callback) {\n  const namespace = 'http://demozero.net';\n  const assignedRoles = (context.authorization || {}).roles;\n\n  let idTokenClaims = context.idToken || {};\n  let accessTokenClaims = context.accessToken || {};\n\n  idTokenClaims[`${namespace}/roles`] = assignedRoles;\n  accessTokenClaims[`${namespace}/roles`] = assignedRoles;\n\n  context.idToken = idTokenClaims;\n  context.accessToken = accessTokenClaims;\n\n  callback(null, user, context);\n}\n```\n\nAlthough the [Delegated Administration Extension (DAE)](https://auth0.com/docs/customize/extensions/delegated-administration-extension) and the Authorization Core feature set are completely separate features, you can use the Authorization Core feature set to create and manage roles for the DAE if you use a rule.\n\n1.  [Create DAE roles](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/create-roles) using the Authorization Core feature set. The names of the roles you create must match the names of the [pre-defined DAE roles](https://auth0.com/docs/extensions/delegated-admin#assign-roles-to-users).\n    \n2.  [Assign the DAE roles you created to the appropriate users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-roles-to-users) using the Authorization core feature set.\n    \n3.  Add user roles to the DAE namespace in the ID Token. To do so, [create the following rule](https://auth0.com/docs/customize/rules/create-rules), remembering to replace the `CLIENT_ID` placeholder value with your application's Client ID:\n    \n    ```\n    function (user, context, callback) {\n        if (context.clientID === 'CLIENT_ID') {\n            const namespace = 'https://example.com/auth0-delegated-admin';\n            context.idToken[namespace] = {\n                roles: (context.authorization || {}).roles\n            };\n        }\n        callback(null, user, context);\n    }\n    ```",
  "title": "Sample Use Cases: Rules with Authorization",
  "description": "Learn how to use rules with roles-based access control (RBAC). For use with our Authorization Core feature set.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/sample-use-cases-actions-with-authorization",
  "markdown": "# Sample Use Cases: Actions with Authorization\n\nAuth0 [Actions](https://auth0.com/docs/customize/actions) allow you to modify or complement the outcome of the decision made by a pre-configured [authorization policy](https://auth0.com/docs/manage-users/access-control/authorization-policies) so that you can handle more complicated cases than is possible with [role-based access control (RBAC)](https://auth0.com/docs/manage-users/access-control/rbac) alone. Based on the order in which they run, Actions can change the outcome of an authorization decision prior to permissions being added to the Access Token. They can also allow you to customize the content of your tokens.\n\n## Allow access only on weekdays for a specific application\n\nLet's say you have an application that you want to make sure is only accessible during weekdays. [Create a new Action](https://auth0.com/docs/customize/actions/write-your-first-action), and select the `Login / Post Login` trigger because you’ll be adding the Action to the Login flow. Copy the following code to the Actions Code Editor:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.client.name === \"APP_NAME\") {\n    const d = new Date().getDay();\n\n    if (d === 0 || d === 6) {\n      api.access.deny(\"This app is only available during the week.\");\n    }\n  }\n}\n```\n\nFinally, add the Action you created to the [Login Flow](https://manage.auth0.com/#/actions/flows/login/). To learn how to attach Actions to Flows, read the \"Attach the Action to a flow\" section in [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\nIf a user attempts to access the application during the weekend, access will be denied, even if they authenticate and have the appropriate privileges.\n\n## Allow access only to users who are inside the corporate network\n\nLet's say you want to allow access to an application, but only for users who are accessing the application from inside your corporate network. [Create a new Action](https://auth0.com/docs/customize/actions/write-your-first-action), and select the `Login / Post Login` trigger because you’ll be adding the Action to the Login flow. Copy the following code to the Actions Code Editor:\n\n```\nconst ipaddr = require(\"ipaddr.js\");\n\nexports.onExecutePostLogin = async (event, api) => {\n  const corpNetwork = \"192.168.1.134/26\";\n  const currentIp = ipaddr.parse(event.request.ip);\n\n  if (!currentIp.match(ipaddr.parseCIDR(corpNetwork))) {\n    api.access.deny(\"This app is only available from inside the corporate network.\");\n  };\n};\n```\n\nFinally, add the Action you created to the [Login Flow](https://manage.auth0.com/#/actions/flows/login/). To learn how to attach Actions to Flows, read the \"Attach the Action to a flow\" section in [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\nIf the user is outside the corporate network, they will be denied access even if they successfully authenticate and have the appropriate privileges.\n\n## Deny access to anyone calling an API\n\nLet's say you want to deny access to all users who are calling an API. This means that you need to deny access depending on the `identifier` value for your API, which you can find in the **API Audience** field of your API at [Auth0 Dashboard > Applications > APIs](https://manage.auth0.com/#/apis). [Create a new Action](https://auth0.com/docs/customize/actions/write-your-first-action), and select the `Login / Post Login` trigger because you’ll be adding the Action to the Login flow. Copy the following code to the Actions Code Editor:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  // In Actions, an API will be referred to as a Resource Server.\n  const { identifier } = event.resource_server || {};\n  if (identifier === \"https://api.example.com\") {\n    api.access.deny(\"end_users_not_allowed\");\n  }\n}\n```\n\nFinally, add the Action you created to the [Login Flow](https://manage.auth0.com/#/actions/flows/login/). To learn how to attach Actions to Flows, read the \"Attach the Action to a flow\" section in [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\nIn this case, the `identifier` value for the API is `https://api.example.com`, so this is the audience we will refuse.\n\n## Add user roles to tokens\n\nTo add user roles to Auth0-issued tokens, use the `event.authorization` object along with the `api.idToken.setCustomClaim` and `api.accessToken.setCustomClaim` methods. [Create a new Action](https://auth0.com/docs/customize/actions/write-your-first-action), and select the `Login / Post Login` trigger because you’ll be adding the Action to the Login flow. Copy the following code to the Actions Code Editor:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const namespace = 'https://my-app.example.com';\n  if (event.authorization) {\n    api.idToken.setCustomClaim(`${namespace}/roles`, event.authorization.roles);\n    api.accessToken.setCustomClaim(`${namespace}/roles`, event.authorization.roles);\n  }\n}\n```\n\nFinally, add the Action you created to the [Login Flow](https://manage.auth0.com/#/actions/flows/login/). To learn how to attach Actions to Flows, read the \"Attach the Action to a flow\" section in [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\nRemember:\n\n*   The JWT returned to the requesting application is built and signed at the end of the trigger processing. The final, signed JWT is not accessible in an Action.",
  "title": "Sample Use Cases: Actions with Authorization",
  "description": "Learn how to use Actions with roles-based access control (RBAC). ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/configure-core-rbac",
  "markdown": "# Configure Core Authorization Features for Role-Based Access Control\n\nThe core Authorization features of Auth0 allow for role-based access control (RBAC) of your APIs.\n\nFor RBAC to work properly, you must enable it for your API using either the Dashboard or the Management API. To learn more, read [Enable Role-Based Access Control for APIs](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis).\n\nAuthorization Core functionality is different from the Authorization Extension. For a comparison between the two products, read [Authorization Core vs. Authorization Extension](https://auth0.com/docs/manage-users/access-control/authorization-core-vs-authorization-extension).\n\nTo use the core functionality most efficiently, you should do the following:\n\n1.  [Register API with Auth0](https://auth0.com/docs/get-started/auth0-overview/set-up-apis)\n    \n2.  [Define permissions for API](https://auth0.com/docs/get-started/apis/add-api-permissions)\n    \n3.  [Create roles](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles/create-roles)\n    \n4.  [Assign roles to users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-roles-to-users)\n    \n5.  [Assign permissions to users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-permissions-to-users), if needed.\n    \n\n## Learn more\n\n*   [Enable Role-Based Access Control for APIs](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis)\n*   [Manage Role-Based Access Control Roles](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles)\n*   [Manage Role-Based Access Control Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users)\n*   [Manage Role-Based Access Control Permissions](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/manage-permissions)",
  "title": "Configure Core Authorization Features for Role-Based Access Control",
  "description": "Learn how to configure Auth0 Core Authorization features for role-based access control (RBAC) of your APIs.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/access-control/authorization-core-vs-authorization-extension",
  "markdown": "# Authorization Core vs. Authorization Extension\n\nAuth0 currently provides two ways of implementing [role-based access control (RBAC)](https://auth0.com/docs/manage-users/access-control/rbac): our Core implementation and our Authorization Extension. Our Core implementation improves performance and scalability.\n\nWe recommend using Authorization Core for most implementations. If you are looking to represent teams, business customers, or partners in a B2B or SaaS application, we recommend representing them as [Organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview) and using Authorization Core. The Authorization Extension does not have support for Organizations.\n\nTo help you decide which feature is right for your implementation, we present the differences between the two:\n\n| Feature | Authorization Core | Authorization Extension |\n| --- | --- | --- |\n| Enhanced performance and scalability | Yes - Read [Entity Limit Policy](https://auth0.com/docs/policies/entity-limit-policy) | No - Limited to 500KB of data (1000 groups, 3000 users, where each user is a member of 3 groups; or 20 groups, 7000 users, where each user is a member of 3 groups) |\n| Create/edit/delete Roles | Yes | Yes |\n| Roles can contain permissions from one or more APIs | Yes | No  |\n| Users and Roles can be assigned to Groups | No  | Yes |\n| Roles are attached to specific applications | No  | Yes |\n| Create/edit/delete Users | Yes | Yes |\n| Search Users by user, email, connection | Yes | Yes |\n| Search Users by identity provider, login count, last login, phone number | Yes | No  |\n| Search Users using Lucene syntax | Yes | No  |\n| User import/export via JSON | Not currently | Yes |\n| Create custom authorization policies | Yes | No  |\n\n## Learn more\n\n*   [Authorization Policies](https://auth0.com/docs/manage-users/access-control/authorization-policies)\n*   [Configure Core Authorization Features for Role-Based Access Control](https://auth0.com/docs/manage-users/access-control/configure-core-rbac)\n*   [Entity Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/entity-limit-policy)\n*   [Authorization Extension](https://auth0.com/docs/customize/extensions/authorization-extension)\n*   [Troubleshoot Authorization Extension](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-authorization-extension)\n*   [Troubleshoot Role-Based Access Control and Authorization](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-rbac-authorization)",
  "title": "Authorization Core vs. Authorization Extension",
  "description": "Understand the differences between Auth0's core RBAC release and the Authorization Extension.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/configure-a-custom-email-provider",
  "markdown": "# Configure a Custom Email Provider\n\nYou can set up any email provider using the Custom Email Provider option. It leverages our [Actions Code Editor](https://auth0.com/docs/customize/actions/actions-overview) to give you full control of the email delivery process.\n\n## Configure Custom Email Provider\n\n1.  Go to [Auth0 Dashboard > Branding > Email Provider](https://manage.auth0.com/#/templates/provider).\n    \n2.  Enable the **Use my own email provider** toggle.\n    \n3.  In the **Email Provider** Section, select **Custom Provider**.\n    \n4.  Click the **+** button next to **Custom Email Provider** to open the Actions Code Editor.\n    \n5.  In the Actions Code Editor Window, add the appropriate code to deliver messages to your provider:\n    \n    1.  Consult with your provider's documentation to understand how to deliver messages to their API.\n        \n    2.  Add any required [secrets](https://auth0.com/docs/customize/actions/write-your-first-action) to authenticate with the API.\n        \n    3.  Like other Actions, use the [Management API](https://auth0.com/docs/api/management/v2/actions/get-actions) to manage the Action and its [versions](https://auth0.com/docs/customize/actions/manage-versions).\n        \n6.  Deploy your action by clicking the **Deploy** button in the top right corner of the page.\n    \n7.  Navigate back by clicking **Back to Email Provider** in the top left corner. You should see a green check and **Enabled** in the **Provider Configuration** section.\n    \n8.  Finalize your custom provider by clicking **Save**.\n    \n9.  Make sure to test your configuration by sending a test email using the **Send Test Email** button.\n    \n\n## Use Cases\n\nWhile the primary use case is to deliver messages to providers that are not supported by the default email options, other use cases include:\n\n*   Retrying failures\n    \n*   Changing recipient(s)\n    \n*   Changing message payload\n    \n*   Creating Organization-specific logic\n    \n\n## Remove the Action\n\nThe **Custom Email Provider** option on [Auth0 Dashboard > Branding > Email Provider](https://manage.auth0.com/#/templates/provider) must be disabled before the Action can be deleted in order to prevent accidental email delivery failures.",
  "title": "Configure a Custom Email Provider",
  "description": "Learn how to set up a code-based custom email provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/customize-blocked-account-emails",
  "markdown": "# Customize Blocked Account Emails\n\nWhen Auth0 sends an email to notify a user that their account has been blocked due to suspicious activity, the message contains a link to re-enable the origin of the request.\n\nThe email sent to the user looks like this:\n\n![Example blocked access attempt email](https://images.ctfassets.net/cdy7uua7fh8z/YE2n7LHBZzI1JviQVARYC/0f400783c5c7563b8abc3b5443f7ddda/bfp-2015-12-29_1832.png)\n\n1.  To customize the template used for this message, go to [Dashboard > Branding > Email Templates](https://manage.auth0.com/#/templates).\n    \n2.  From the **Template** dropdown, select **Blocked Account Email**.\n    \n    ![Dashboard Branding Email Templates Blocked Account Email Template](https://images.ctfassets.net/cdy7uua7fh8z/7IeblHplWeWajmEhlLWwGR/8f76e4b9aa88fcb03a6206df381e4c07/dashboard-branding-email-templates-blocked-account-email.png)\n3.  Make the desired changes. To learn more, read [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n    \n4.  To test, click **Try,** enter a valid email address that you have access to view, and choose the correct connection type.\n    \n5.  Click **Cancel**, returning to the email template page. You can make any changes and try again, then select **Save** when you are satisfied with the results.\n    \n\n## Learn more\n\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)",
  "title": "Customize Blocked Account Emails",
  "description": "Describes how to customize blocked account emails.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/smtp-email-providers",
  "markdown": "# Configure External SMTP Email Providers\n\nAuth0 allows you to configure your own SMTP email provider so you can more completely manage, monitor, and troubleshoot your email communications. Auth0's built-in email infrastructure should be used for testing emails only. You can only configure one email provider which will be used for all emails.\n\nAuth0 currently supports the following providers:\n\n*   [Mandrill](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mandrill-as-external-smtp-email-provider)\n    \n*   [Amazon SES](https://auth0.com/docs/customize/email/smtp-email-providers/configure-amazon-ses-as-external-smtp-email-provider)\n    \n*   [Azure Communication Services](https://auth0.com/docs/customize/email/smtp-email-providers/configure-azure-comm-service-as-smtp-email-provider)\n    \n*   [Microsoft 365](https://auth0.com/docs/customize/email/smtp-email-providers/configure-365-exchange-as-smtp-email-provider)\n    \n*   [SendGrid](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sendgrid-as-external-smtp-email-provider)\n    \n*   [SparkPost](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sparkpost-as-external-smtp-email-provider)\n    \n*   [Mailgun](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mailgun-as-external-smtp-email-provider)\n    \n\nYou can also configure a [third-party email provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider) such as Gmail or Yahoo.\n\nYou configure external email providers at [Auth0 Dashboard > Branding > Email Provider](https://manage.auth0.com/#/templates/provider).\n\n![Auth0 Branding Email Provider External SMTP](https://images.ctfassets.net/cdy7uua7fh8z/7isvLmP7JGkOivXcyeihM6/55a2657bf424f9e4f3b75c0d674957ba/Custom_Email_Provider__1_.png)\n\n## Learn more\n\n*   [Configure Custom External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider)\n*   [Configure Amazon SES as External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-amazon-ses-as-external-smtp-email-provider)\n*   [Configure Mandrill as External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mandrill-as-external-smtp-email-provider)\n*   [Configure SendGrid as External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sendgrid-as-external-smtp-email-provider)\n*   [Configure SparkPost as External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sparkpost-as-external-smtp-email-provider)\n*   [Configure Mailgun as External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mailgun-as-external-smtp-email-provider)",
  "title": "Configure External SMTP Email Providers",
  "description": "Learn how to configure your own SMTP email provider, so you can more completely manage, monitor, and troubleshoot your email communications.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/manage-email-flow",
  "markdown": "# Customize Email Handling\n\nOur default email flow can address the requirements of most applications. Sometimes, however, you may require more flexibility, such as when implementing:\n\n*   localization\n    \n*   custom **Redirect To** URLs based on user or tenant\n    \n*   different email templates per application or tenant\n    \n\nThe Auth0 Management API provides endpoints to help you manage your email flow to control when and how emails are sent. If necessary, you can also implement your own Custom Email endpoints and use the Auth0 Management API endpoints to help manage the rest of the flow.\n\n## Verification emails\n\nA verification email should be sent to every user for which the `email_verified` property is `false`. Typically, these are users in database connections or users authenticating with social providers that do not validate email addresses upon new user registration.\n\nYou can send verification emails in more than one way:\n\nThe [Send an email address verification email endpoint](https://auth0.com/docs/api/management/v2#!/Jobs/post_verification_email) sends the user an email prompting them to verify their email address.\n\n*   [cURL](#e983c89301e347ecad0326b393b7fa1b_shell)\n*   [C#](#e983c89301e347ecad0326b393b7fa1b_csharp)\n*   [Go](#e983c89301e347ecad0326b393b7fa1b_go)\n*   [Java](#e983c89301e347ecad0326b393b7fa1b_java)\n*   [Node.JS](#e983c89301e347ecad0326b393b7fa1b_node)\n*   [Obj-C](#e983c89301e347ecad0326b393b7fa1b_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/jobs/verification-email' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"user_id\": \"{userIdOfVerifyEmailRecipient}\", \"client_id\": \"{yourAppClientId}\",\"identity\": {\"user_id\": \"5457edea1b8f22891a000004\",\"provider\": \"google-oauth2\"}, \"organization_id\": \"{yourOrganizationId}\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/jobs/verification-email\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"application/json\", \"{ \\\"user_id\\\": \\\"{userIdOfVerifyEmailRecipient}\\\", \\\"client_id\\\": \\\"{yourAppClientId}\\\",\\\"identity\\\": {\\\"user_id\\\": \\\"5457edea1b8f22891a000004\\\",\\\"provider\\\": \\\"google-oauth2\\\"}, \\\"organization_id\\\": \\\"{yourOrganizationId}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/jobs/verification-email\"\n\n\tpayload := strings.NewReader(\"{ \\\"user_id\\\": \\\"{userIdOfVerifyEmailRecipient}\\\", \\\"client_id\\\": \\\"{yourAppClientId}\\\",\\\"identity\\\": {\\\"user_id\\\": \\\"5457edea1b8f22891a000004\\\",\\\"provider\\\": \\\"google-oauth2\\\"}, \\\"organization_id\\\": \\\"{yourOrganizationId}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/jobs/verification-email\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{ \\\"user_id\\\": \\\"{userIdOfVerifyEmailRecipient}\\\", \\\"client_id\\\": \\\"{yourAppClientId}\\\",\\\"identity\\\": {\\\"user_id\\\": \\\"5457edea1b8f22891a000004\\\",\\\"provider\\\": \\\"google-oauth2\\\"}, \\\"organization_id\\\": \\\"{yourOrganizationId}\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/jobs/verification-email',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer {yourMgmtApiAccessToken}'\n  },\n  data: {\n    user_id: '{userIdOfVerifyEmailRecipient}',\n    client_id: '{yourAppClientId}',\n    identity: {user_id: '5457edea1b8f22891a000004', provider: 'google-oauth2'},\n    organization_id: '{yourOrganizationId}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"user_id\": @\"{userIdOfVerifyEmailRecipient}\",\n                              @\"client_id\": @\"{yourAppClientId}\",\n                              @\"identity\": @{ @\"user_id\": @\"5457edea1b8f22891a000004\", @\"provider\": @\"google-oauth2\" },\n                              @\"organization_id\": @\"{yourOrganizationId}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/jobs/verification-email\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/jobs/verification-email\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"user_id\\\": \\\"{userIdOfVerifyEmailRecipient}\\\", \\\"client_id\\\": \\\"{yourAppClientId}\\\",\\\"identity\\\": {\\\"user_id\\\": \\\"5457edea1b8f22891a000004\\\",\\\"provider\\\": \\\"google-oauth2\\\"}, \\\"organization_id\\\": \\\"{yourOrganizationId}\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"user_id\\\": \\\"{userIdOfVerifyEmailRecipient}\\\", \\\"client_id\\\": \\\"{yourAppClientId}\\\",\\\"identity\\\": {\\\"user_id\\\": \\\"5457edea1b8f22891a000004\\\",\\\"provider\\\": \\\"google-oauth2\\\"}, \\\"organization_id\\\": \\\"{yourOrganizationId}\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/jobs/verification-email\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/jobs/verification-email\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{ \\\"user_id\\\": \\\"{userIdOfVerifyEmailRecipient}\\\", \\\"client_id\\\": \\\"{yourAppClientId}\\\",\\\"identity\\\": {\\\"user_id\\\": \\\"5457edea1b8f22891a000004\\\",\\\"provider\\\": \\\"google-oauth2\\\"}, \\\"organization_id\\\": \\\"{yourOrganizationId}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\"\n]\nlet parameters = [\n  \"user_id\": \"{userIdOfVerifyEmailRecipient}\",\n  \"client_id\": \"{yourAppClientId}\",\n  \"identity\": [\n    \"user_id\": \"5457edea1b8f22891a000004\",\n    \"provider\": \"google-oauth2\"\n  ],\n  \"organization_id\": \"{yourOrganizationId}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/jobs/verification-email\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Require verified email for login\n\nYou can require users to verify their email before logging in with a rule:\n\n```\nfunction (user, context, callback) {\n  if (!user.email_verified) {\n    return callback(new UnauthorizedError('Please verify your email before logging in.'));\n  } else {\n    return callback(null, user, context);\n  }\n}\n```\n\n### Custom redirects\n\nA custom redirect is useful when you want to direct users to certain URLs based on user attributes or on the tenant. The Auth0 Management API provides a [Create Email Verification Ticket endpoint](https://auth0.com/docs/api/management/v2/#!/Tickets/post_email_verification) that generates the verification link for each user. This endpoint allows you to specify the `result_url` to which users will be redirected after they have validated their email address by clicking the link in the verification email.\n\nWe recommend AllowList the URL in the [Auth0 Dashboard](https://manage.auth0.com/#/templates/provider). For details, see [Add Addresses to AllowList](https://auth0.com/docs/secure/security-guidance/data-security/allowlist).\n\n## Welcome emails\n\nA welcome email is sent to users once they have verified their email address.\n\n### Send welcome email using your own API\n\nUsing a [rule](https://auth0.com/docs/customize/rules), you can call your API to send a welcome email only if the user's email address has been verified and the email has not been sent previously.\n\n```\nfunction (user, context, callback) {\n\n  const request = require('request');\n\n  if (!user.email_verified || user.welcome_email_sent) {\n    return callback(null, user, context);\n  }\n\n  request.post({\n    url: 'https://yourapi.yourcompany.com/mail/welcome',\n    json: {\n      user: user,\n      context: context,\n      secretToken: configuration.MY_SECRET_TOKEN,\n    },\n    timeout: 5000\n  }, function(err, response, body){\n    if (err)\n      return callback(new Error(err));\n\n    // Email sent flag persisted in the user's profile.\n    user.app_metadata.welcome_email_sent = true;\n    return callback(null, user, context);\n  });\n}\n```\n\n## Password reset emails\n\nYou can create a password change ticket using the Auth0 Management API [Create a Password Change Ticket](https://auth0.com/docs/api/management/v2/#!/Tickets/post_password_change) endpoint, and then send the password change ticket URL in an email to the user. When the user clicks the link, they will be prompted to reset their password through the Universal Login flow.\n\n## Learn more\n\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)",
  "title": "Customize Email Handling",
  "description": "Learn how to customize email flow and control when and how emails are sent.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider",
  "markdown": "# Configure Custom External SMTP Email Provider\n\n#### Before you start\n\n*   Provider must support LOGIN [authentication](https://en.wikipedia.org/wiki/SMTP_Authentication).\n    \n*   Provider must support [TLS 1.2](https://en.wikipedia.org/wiki/STARTTLS) or higher.\n    \n*   Provider must have a certificate signed by a public certificate authority (CA).\n    \n*   Configure your provider to [allow inbound connections from Auth0](https://auth0.com/docs/secure/security-guidance/data-security/allowlist). To see the list of required IP addresses, Public Cloud customers can navigate to [Auth0 Dashboard > Branding > Email Provider](https://manage.auth0.com/#/templates/provider). Private Cloud customers can contact [Auth0 Support](https://support.auth0.com/) and request IPs specific to their instance.\n    \n\nYou can configure your own SMTP email provider to manage, monitor, and troubleshoot your email communications, and customize email templates.\n\n## Configure custom SMTP server\n\n1.  Go to [Auth0 Dashboard > Branding > Email Provider](https://manage.auth0.com/#/templates/provider).\n    \n2.  Enable the **Use my own email provider** toggle.\n    \n3.  Select **SMTP**.\n    \n4.  Enter a **From** email address, and then enter your SMTP server's **Host**, **Port**, **Username**, and **Password**. Common ports include 25 and 587. Avoid using port 25 if possible, as many providers have limitations on this port.\n    \n    ![Auth0 Branding Email Provider SMTP Provider Settings](https://images.ctfassets.net/cdy7uua7fh8z/7jYUb6ktBllv6yr25f5zJK/b18e9f1812afb7dced38acb3823e10e4/Dashboard_-_Branding_-_Email_Provider_-_SMTP_Provider_Settings.png)\n5.  Click **Save**.\n    \n\n## Test email delivery\n\nYou can now send a test email using the **Send Test Email** button. If you have configured everything correctly, you will receive a confirmation email. If you do not receive an email after a few minutes, please check your [Auth0 logs](https://manage.auth0.com/#/logs) for any failures.\n\nSMTP makes it easy to set up test services that allow you to test that your setup is working without spamming your users. To learn more, see [Set Up Test SMTP Servers](https://auth0.com/docs/email/testing).\n\n## Learn more\n\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)",
  "title": "Configure Custom External SMTP Email Provider",
  "description": "Learn how to configure a custom external SMTP email provider.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/troubleshoot-custom-email-provider-delivery-issues",
  "markdown": "# Troubleshoot Custom Email Provider Delivery Issues\n\nAuth0 allows you to configure your own SMTP email providers to manage, monitor, and troubleshoot your email communications. If you experience email delivery issues, there are several settings to review before contacting Auth0 support.\n\nYou must use a custom email provider. The [built-in email provider](https://manage.auth0.com/#/templates/provider) is for testing only and should not be a substitute for long term email management.\n\n## Review your infrastructure and domain configuration\n\nConfigure your email provider with the following authentication standards:\n\n*   DomainKeys Identified Mail ([DKIM](http://dkim.org/))\n    \n*   Sender Policy Framework ([SPF](https://datatracker.ietf.org/doc/rfc7208/))\n    \n*   Domain-based Message Authentication, Reporting, and Conformance ([DMARC](https://dmarc.org/))\n    \n\nYou can use several tools to review the settings of DNS records relating to DKIM, SPF, and DMARC. Built-in command line tools like `dig` and `nslookup` can help you diagnose your MX records and other common routing issues.\n\nOnline tools like [MXToolBox](https://mxtoolbox.com/) and [DNSChecker](https://dnschecker.org/all-tools.php) can also analyze settings related to authentication standards and are helpful in identifying misconfigurations or changes needed in your email settings.\n\n## Microsoft Exchange specific issues\n\nIf you use Microsoft Exchange as your email provider, your emails may be quarantined if Exchange deems them as high-risk. This can happen when emails route from an outside source.\n\nIf Microsoft Exchange quarantines messages, an administrator can view the messages in a special inbox and determine if there is a DMARC alignment failure, causing the messages to appear as spam.\n\n## SendGrid specific issues\n\nIf you use SendGrid as your email provider, your emails may be suppressed if the recipient's email server rejects the message. To learn more, read [Different Types of Suppression in SendGrid Docs](https://docs.sendgrid.com/ui/sending-email/index-suppressions#different-types-of-suppressions).\n\nIn certain cases, SendGrid will “Drop” a message to a specific email address in order to protect your sender reputation. To learn more about \"Drops\" and how to remove them, read [Drops on SendGrid Docs](https://docs.sendgrid.com/glossary/drops).\n\nIf you are using [passwordless authentication with email](https://auth0.com/docs/authenticate/passwordless#email), ensure that the **From** email address value for your passwordless connection matches the **From** email address value you're using for SendGrid.\n\n## Contacting Auth0 Support\n\nIf you review your custom email provider settings and ensure your domain implements DKIM, SPF, and DMARC protocols and your email delivery is still failing, you may need to contact the Auth0 support team for review.\n\nOur support team can verify if your email provider receives messages and the error returned if they are not accepted. To learn more, read [Open and Manage Support Tickets](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets).\n\n## Diagnose email delivery issues\n\nIf you have configured a custom provider but are not receiving notifications that emails are being sent, verify your provider configuration details in Auth0 and confirm your custom provider is available. To view log data regarding email notification errors, go to [Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs) and filter results on the `Failed Sending Notification` event type.\n\n## Learn more\n\n*   [Customize Emails](https://auth0.com/docs/customize/email)",
  "title": "Troubleshoot Custom Email Provider Delivery Issues",
  "description": "Describes the steps to find and resolve email delivery issues.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/configure-test-smtp-email-servers",
  "markdown": "# Configure Test SMTP Email Server\n\nWhile working in your development or testing environment, we recommend that you use a test SMTP server so that you can:\n\n*   Check for successful email deliveries.\n    \n*   View how emails you sent appear to recipients prior to go live.\n    \n\nYou can either set up your own SMTP server or use a third-party service. Once you have either your own SMTP server set up or a test service available, you provide its credentials the way you typically would for a [third-party email provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider).\n\nAuth0 does not allow certain \"false\" domains commonly used during testing. Use real email addresses to avoid disruption or errors.\n\nHere are some third-party email testing services you can use:\n\n*   [Debug Mail](https://debugmail.io/)\n    \n*   [FakeSMTP](https://nilhcem.github.io/FakeSMTP/)\n    \n*   [Haraka](https://haraka.github.io/)\n    \n*   [MailTrap](https://mailtrap.io/)\n    \n*   [smtp4dev](https://smtp4dev.codeplex.com/)\n    \n\n## Learn more\n\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)\n*   [Configure Custom External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider)",
  "title": "Configure Test SMTP Email Server",
  "description": "Describes how to set up a test SMTP server while in development or testing stages.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/customize/email/send-email-invitations-for-application-signup",
  "markdown": "# Send Email Invitations for Application Signup\n\nTo restrict user signups or create accounts in bulk for your application, your application can provision users with user invitations.\n\nA typical user invitation workflow follows the steps below:\n\n1.  Administrator creates a user account.\n    \n2.  Administrator sends a registration email invitation to the user.\n    \n3.  User follows a link in the invitation email to set up a password for the account.\n    \n4.  User creates and verifies a password.\n    \n5.  User signs in.\n    \n\n## Generate invitations\n\nA user invitation is basically a change password link repurposed as an invitation. The user invitation email is derived from the \"change password\" template. With Auth0, there are two common approaches to implementing user invitations:\n\n*   [Customize an email template](https://auth0.com/docs/customize/email/email-templates) and use it to [send a change password email](https://auth0.com/docs/customize/email/manage-email-flow).\n    \n*   Create a password change ticket.\n    \n\nYou can allow a user to access an existing account that you have created on their behalf. Then, send the user a unique link to set their password. You generate the unique link by creating a Password Change ticket where your invitation app calls the `/password-change` [Management API endpoint](https://auth0.com/docs/api/management/v2/#!/Tickets/post_password_change). You will need to:\n\n*   [Create an Auth0 database user](https://auth0.com/docs/authenticate/database-connections) with the `user.email_verified` parameter set to `false`. You can use the [Create a User](https://auth0.com/docs/api/management/v2/#!/Users/post_users) endpoint.\n    \n*   Have access to and [configure an external email service](https://auth0.com/docs/customize/email/smtp-email-providers)\n    \n*   [Get a Management API access token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)\n    \n\n### Create password change tickets\n\n1.  Specify the user using `user_id` or email and `connection_id` to the \n    \n    [Management API endpoint](https://auth0.com/docs/api/management/v2#!/Tickets/post_password_change)\n    \n2.  Specify where the redirect sends the user. The `result_url` parameter is the redirect location your application sends the user after they set their password. In this case, the `result_url` should be your app login page. To learn more, read [Redirect Users After Login](https://auth0.com/docs/authenticate/login/redirect-users-after-login).\n    \n3.  Specify the lifespan of the invitation link. Use the `ttl_sec` parameter to set how long the invitation link will remain active. The `ttl_sec` parameter should align with your relevant security concerns. The link is a one-time use, so once the user has set their password, it is not vulnerable to reuse.\n    \n4.  Verify the email address. If sent to a registered email account, set the `mark_email_as_verified` parameter as `true`. You **should not** set the email verification to `true` if the email account is not registered. A successful request to this endpoint will return a ticket URL. You will use that URL to create the user invitation.\n    \n\n```\ncurl -- request POST \\\n  --url 'https://{yourAuth0Tenant}/api/v2/tickets/password-change' \\\n  --header \"Content-Type: application/json\" \\\n  --data '{\"result_url\": \"{yourResultURL}\",\"user_id\":,{yourUserID}\",\"client_id\":\"{yourClientID\",\"ttl_sec\":0,\"mark_email_as_verified\":false,\"includeEmailInRedirect\":false}'\n```\n\n### Add query parameters ticket URL\n\nYou can add query parameters to the URL to customize the password reset UI. The returned URL has a unique code value that allows the user to set their password followed by a `#`. Do not edit anything before the `#`.\n\nAdd a parameter to specify a set password workflow UI. Example:\n\nAdd a parameter to identify the target app. Example:\n\n### Create email template\n\nThe email invitation needs to be sent with your existing email service provider. [Customize the password change email template](https://auth0.com/docs/customize/email/email-templates) so the language in the email aligns with your use case. Include the link generated from the steps above. The text in the email should explain:\n\n*   The next steps to claiming the user account.\n    \n*   The expiration of the link.\n    \n*   Steps to generate a new invite if it has expired.\n    \n\nFor example, when creating the user to invite, you might add a property to `user.app_metadata` that shows this user account was invited. Then in your email template you could check for this property:\n\n```\n{% if user.app_metadata.invitedToMyApp == true %}\n  // user invitation email\n{% else %}\n  // password change email\n{% endif %}\n```\n\n## Customize Password Reset UI\n\nOnce the user clicks the link in the invitation they will be brought to the Universal Login Password Reset page where they will set a password for their account. Since this page is used both for the forgot password workflow and for your user invitations, you will want to use the query parameters you defined earlier to identify the invite workflow and customize the UI accordingly. To learn more, read [Customize Password Reset Page](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page).\n\n## Complete the user experience\n\nIn most cases, once the user has set their password, you grant them access to the target app. The target app initiates the login sequence with the following steps:\n\n1.  User submits password.\n    \n2.  Change password screen redirects return URL.\n    \n3.  Target app redirects to `/authorize`.\n    \n4.  User submits their credentials.\n    \n5.  User is authenticated into the app.\n    \n\nThe workflow involves redirects but it is possible for the transition from the set password form to the login form to appear seamless to the end user.\n\nIf you're using Classic Login, the `result_url` you set when you created the password change ticket is where the user will be redirected after creating their password. In this case, you want the URL to be on the site the user has been invited to so that it can initiate the login workflow. Your target app will need to parse the `success` parameter to confirm no errors occurred then immediately initiate the redirect back to Auth0 to log the user in.\n\nTo optimize the user experience, you can have the target app parse the `email` parameter and include it with the authentication request as the `login_hint` parameter. This will pre-fill the user's email address in the login form.\n\n## Learn more\n\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Customize Email Handling](https://auth0.com/docs/customize/email/manage-email-flow)\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)",
  "title": "Send Email Invitations for Application Signup",
  "description": "Describes how to customize the signup process to invite users to signup for an account in the context of a specific Auth0 application. ",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/cookies/authentication-api-cookies",
  "markdown": "# Authentication API Cookies\n\nThe Auth0 Authentication API uses a set of HTTP cookies to enable [single sign-on (SSO)](https://auth0.com/docs/authenticate/single-sign-on), [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication), and [attack protection](https://auth0.com/docs/secure/attack-protection) capabilities. The table below shows some of the cookies that the Authentication API relies on and describes their purposes:\n\n| **Cookie** | **Feature** | **Purpose** |\n| --- | --- | --- |\n| `auth0` | Single Sign-on | Used to implement the [Auth0 session layer](https://auth0.com/docs/manage-users/sessions/session-layers). |\n| `auth0_compat` | Single Sign-on | Fallback cookie for single sign-on on browsers that don’t support the `sameSite=None` attribute. |\n| `auth0-mf` | Multi-factor Authentication | Used to establish the trust level for a given device. |\n| `auth0-mf_compat` | Multi-factor Authentication | Fallback cookie for multi-factor authentication on browsers that don’t support the `sameSite=None` attribute. |\n| `a0_users:sess` | Classic Login | Used for CSRF protection in Classic Login flows. |\n| `a0_users:sess.sig` | Classic Login | Used for CSRF protection in Classic Login flows. |\n| `did` | Attack Protection | Device identification for attack protection. |\n| `did_compat` | Attack Protection | Fallback cookie for anomaly detection on browsers that don’t support the `sameSite=None` attribute. |\n\n## Cookies and custom domains\n\nIf you are using [custom domains](https://auth0.com/docs/customize/custom-domains), cookies from the Authentication API are sent to the custom host name, or CNAME you set up in the Auth0 Dashboard. Each cookie's domain attribute, which specifies the domain for which the cookie is valid, is defined in the cookie request header and domain-matches with the domain attribute.\n\nIf no domain is specified, the domain attribute defaults to the request-host. If you use IETF’s [HTTP State Management Mechanism](https://datatracker.ietf.org/doc/html/rfc2109#section-2) spec to set cookies on the parent domain, the cookie will be shared with all subdomains of the parent domain.\n\nFor example, you set your CNAME to `login.example_domain.com` as a subdomain of `example_domain.com`. You host other applications under the parent domain, such as `app1.example_domain.com` and `app2.example_domain.com`. When users visit `login.example_domain.com`, cookies from `app1.example_domain.com` and `app2.example_domain.com` may be sent along with requests to Auth0’s Authentication API.\n\nTo safeguard our platform and because these cookies may grow to a considerable size and can be shared with other subdomains, Auth0 may reject requests carrying excessively large (multiple kilobytes) headers. Applications should be designed such that excessively large cookies are not sent to the Auth0 Authentication API. To learn more about cookie behavior with custom domains, read [Sending Cookies to the Origin Server](https://datatracker.ietf.org/doc/html/rfc2109#section-4.3.4).\n\n## Learn more\n\n*   [SameSite Cookie Attribute Changes](https://auth0.com/docs/manage-users/cookies/samesite-cookie-attribute-changes)\n*   [Verify Domain](https://auth0.com/docs/troubleshoot/basic-issues/verify-domain)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
  "title": "Authentication API Cookies",
  "description": "Learn about Authentication API cookies, including what they are, what they are used for, and how they should be handled.",
  "languageCode": null
},
{
  "url": "https://auth0.com/docs/manage-users/cookies/samesite-cookie-attribute-changes",
  "markdown": "# SameSite Cookie Attribute Changes\n\nCookies, which are used for authentication and the maintenance of sessions, can be secured by setting attributes. Auth0 uses cookies for the following:\n\n*   OIDC Enterprise with `form_post`\n    \n*   SAML HTTP-POST Binding\n    \n*   Web message (aka `checkSession`)\n    \n\n## SameSite attributes\n\nYou can add [SameSite cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite) attributes in the `set-cookie` HTTP response header to restricts browser behavior. It may prevent the browser from sending the cookie's `key=value` pair based on the type of interaction that triggered the HTTP request.\n\nAccepted attribute values are as follows:\n\n| Attribute | Description |\n| --- | --- |\n| `strict` | Send the cookie if the user is navigating within the website origin bounds |\n| `lax` | Send the cookie if the user is navigating between domains but not for 3rd party contexts (iframes or posts) |\n| `none` | Send the cookie with requests crossing the website origin bounds. Unless other conditions are present (i.e., third-party cookies are blocked), do not send the cookie. |\n\nSome of the cookie attributes you may be familiar with include:\n\n| Attribute | Description |\n| --- | --- |\n| `httpOnly` | Allows a cookie to be sent only with HTTP requests; not readable using Javascript's `document.cookie` |\n| `secure` | Allows the browser to send the cookie only to a secure context; whether the context is considered secure or not is browser-dependent, but this typically requires the use of HTTPS |\n| `max-age / expires` | Controls whether the cookie is a **session** cookie (e.g., dropped when your browser terminates its session) or **per