[{
  "url": "https://react.dev/reference/react",
  "markdown": "# React Reference Overview ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\nThis section provides detailed reference documentation for working with React. For an introduction to React, please visit the [Learn](https://react.dev/learn) section.\n\nThe React reference documentation is broken down into functional subsections:\n\n## React[](#react \"Link for React \")\n\nProgrammatic React features:\n\n*   [Hooks](https://react.dev/reference/react/hooks) - Use different React features from your components.\n*   [Components](https://react.dev/reference/react/components) - Documents built-in components that you can use in your JSX.\n*   [APIs](https://react.dev/reference/react/apis) - APIs that are useful for defining components.\n*   [Directives](https://react.dev/reference/rsc/directives) - Provide instructions to bundlers compatible with React Server Components.\n\n## React DOM[](#react-dom \"Link for React DOM \")\n\nReact-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:\n\n*   [Hooks](https://react.dev/reference/react-dom/hooks) - Hooks for web applications which run in the browser DOM environment.\n*   [Components](https://react.dev/reference/react-dom/components) - React supports all of the browser built-in HTML and SVG components.\n*   [APIs](https://react.dev/reference/react-dom) - The `react-dom` package contains methods supported only in web applications.\n*   [Client APIs](https://react.dev/reference/react-dom/client) - The `react-dom/client` APIs let you render React components on the client (in the browser).\n*   [Server APIs](https://react.dev/reference/react-dom/server) - The `react-dom/server` APIs let you render React components to HTML on the server.\n\n## Rules of React[](#rules-of-react \"Link for Rules of React \")\n\nReact has idioms ‚Äî or rules ‚Äî for how to express patterns in a way that is easy to understand and yields high-quality applications:\n\n*   [Components and Hooks must be pure](https://react.dev/reference/rules/components-and-hooks-must-be-pure) ‚Äì Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly.\n*   [React calls Components and Hooks](https://react.dev/reference/rules/react-calls-components-and-hooks) ‚Äì React is responsible for rendering components and hooks when necessary to optimize the user experience.\n*   [Rules of Hooks](https://react.dev/reference/rules/rules-of-hooks) ‚Äì Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.\n\n## Legacy APIs[](#legacy-apis \"Link for Legacy APIs \")\n\n*   [Legacy APIs](https://react.dev/reference/react/legacy) - Exported from the `react` package, but not recommended for use in newly written code.",
  "title": "React Reference Overview ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/createContext",
  "markdown": "# createContext ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`createContext` lets you create a [context](https://react.dev/learn/passing-data-deeply-with-context) that components can provide or read.\n\n```\nconst SomeContext = createContext(defaultValue)\n```\n\n*   [Reference](#reference)\n    *   [`createContext(defaultValue)`](#createcontext)\n    *   [`SomeContext.Provider`](#provider)\n    *   [`SomeContext.Consumer`](#consumer)\n*   [Usage](#usage)\n    *   [Creating context](#creating-context)\n    *   [Importing and exporting context from a file](#importing-and-exporting-context-from-a-file)\n*   [Troubleshooting](#troubleshooting)\n    *   [I can‚Äôt find a way to change the context value](#i-cant-find-a-way-to-change-the-context-value)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `createContext(defaultValue)`[](#createcontext \"Link for this heading\")\n\nCall `createContext` outside of any components to create a context.\n\n```\nimport { createContext } from 'react';const ThemeContext = createContext('light');\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `defaultValue`: The value that you want the context to have when there is no matching context provider in the tree above the component that reads context. If you don‚Äôt have any meaningful default value, specify `null`. The default value is meant as a ‚Äúlast resort‚Äù fallback. It is static and never changes over time.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`createContext` returns a context object.\n\n**The context object itself does not hold any information.** It represents _which_ context other components read or provide. Typically, you will use [`SomeContext.Provider`](#provider) in components above to specify the context value, and call [`useContext(SomeContext)`](https://react.dev/reference/react/useContext) in components below to read it. The context object has a few properties:\n\n*   `SomeContext.Provider` lets you provide the context value to components.\n*   `SomeContext.Consumer` is an alternative and rarely used way to read the context value.\n\n* * *\n\n### `SomeContext.Provider`[](#provider \"Link for this heading\")\n\nWrap your components into a context provider to specify the value of this context for all components inside:\n\n```\nfunction App() {const [theme, setTheme] = useState('light');// ...return (<ThemeContext.Provider value={theme}><Page /></ThemeContext.Provider>);}\n```\n\n#### Props[](#provider-props \"Link for Props \")\n\n*   `value`: The value that you want to pass to all the components reading this context inside this provider, no matter how deep. The context value can be of any type. A component calling [`useContext(SomeContext)`](https://react.dev/reference/react/useContext) inside of the provider receives the `value` of the innermost corresponding context provider above it.\n\n* * *\n\n### `SomeContext.Consumer`[](#consumer \"Link for this heading\")\n\nBefore `useContext` existed, there was an older way to read context:\n\n```\nfunction Button() {// üü° Legacy way (not recommended)return (<ThemeContext.Consumer>{theme => (<button className={theme} />)}</ThemeContext.Consumer>);}\n```\n\nAlthough this older way still works, but **newly written code should read context with [`useContext()`](https://react.dev/reference/react/useContext) instead:**\n\n```\nfunction Button() {// ‚úÖ Recommended wayconst theme = useContext(ThemeContext);return <button className={theme} />;}\n```\n\n#### Props[](#consumer-props \"Link for Props \")\n\n*   `children`: A function. React will call the function you pass with the current context value determined by the same algorithm as [`useContext()`](https://react.dev/reference/react/useContext) does, and render the result you return from this function. React will also re-run this function and update the UI whenever the context from the parent components changes.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Creating context[](#creating-context \"Link for Creating context \")\n\nContext lets components [pass information deep down](https://react.dev/learn/passing-data-deeply-with-context) without explicitly passing props.\n\nCall `createContext` outside any components to create one or more contexts.\n\n```\nimport { createContext } from 'react';const ThemeContext = createContext('light');const AuthContext = createContext(null);\n```\n\n`createContext` returns a context object. Components can read context by passing it to [`useContext()`](https://react.dev/reference/react/useContext):\n\n```\nfunction Button() {const theme = useContext(ThemeContext);// ...}function Profile() {const currentUser = useContext(AuthContext);// ...}\n```\n\nBy default, the values they receive will be the default values you have specified when creating the contexts. However, by itself this isn‚Äôt useful because the default values never change.\n\nContext is useful because you can **provide other, dynamic values from your components:**\n\n```\nfunction App() {const [theme, setTheme] = useState('dark');const [currentUser, setCurrentUser] = useState({ name: 'Taylor' });// ...return (<ThemeContext.Provider value={theme}><AuthContext.Provider value={currentUser}><Page /></AuthContext.Provider></ThemeContext.Provider>);}\n```\n\nNow the `Page` component and any components inside it, no matter how deep, will ‚Äúsee‚Äù the passed context values. If the passed context values change, React will re-render the components reading the context as well.\n\n[Read more about reading and providing context and see examples.](https://react.dev/reference/react/useContext)\n\n* * *\n\n### Importing and exporting context from a file[](#importing-and-exporting-context-from-a-file \"Link for Importing and exporting context from a file \")\n\nOften, components in different files will need access to the same context. This is why it‚Äôs common to declare contexts in a separate file. Then you can use the [`export` statement](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export) to make context available for other files:\n\n```\n// Contexts.jsimport { createContext } from 'react';export const ThemeContext = createContext('light');export const AuthContext = createContext(null);\n```\n\nComponents declared in other files can then use the [`import`](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/import) statement to read or provide this context:\n\n```\n// Button.jsimport { ThemeContext } from './Contexts.js';function Button() {const theme = useContext(ThemeContext);// ...}\n```\n\n```\n// App.jsimport { ThemeContext, AuthContext } from './Contexts.js';function App() {// ...return (<ThemeContext.Provider value={theme}><AuthContext.Provider value={currentUser}><Page /></AuthContext.Provider></ThemeContext.Provider>);}\n```\n\nThis works similar to [importing and exporting components.](https://react.dev/learn/importing-and-exporting-components)\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### I can‚Äôt find a way to change the context value[](#i-cant-find-a-way-to-change-the-context-value \"Link for I can‚Äôt find a way to change the context value \")\n\nCode like this specifies the _default_ context value:\n\n```\nconst ThemeContext = createContext('light');\n```\n\nThis value never changes. React only uses this value as a fallback if it can‚Äôt find a matching provider above.\n\nTo make context change over time, [add state and wrap components in a context provider.](https://react.dev/reference/react/useContext#updating-data-passed-via-context)",
  "title": "createContext ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/cache",
  "markdown": "# cache ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Canary\n\n*   `cache` is only for use with [React Server Components](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components). See [frameworks](https://react.dev/learn/start-a-new-react-project#bleeding-edge-react-frameworks) that support React Server Components.\n    \n*   `cache` is only available in React‚Äôs [Canary](https://react.dev/community/versioning-policy#canary-channel) and [experimental](https://react.dev/community/versioning-policy#experimental-channel) channels. Please ensure you understand the limitations before using `cache` in production. Learn more about [React‚Äôs release channels here](https://react.dev/community/versioning-policy#all-release-channels).\n    \n\n`cache` lets you cache the result of a data fetch or computation.\n\n```\nconst cachedFn = cache(fn);\n```\n\n*   [Reference](#reference)\n    *   [`cache(fn)`](#cache)\n*   [Usage](#usage)\n    *   [Cache an expensive computation](#cache-expensive-computation)\n    *   [Share a snapshot of data](#take-and-share-snapshot-of-data)\n    *   [Preload data](#preload-data)\n*   [Troubleshooting](#troubleshooting)\n    *   [My memoized function still runs even though I‚Äôve called it with the same arguments](#memoized-function-still-runs)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `cache(fn)`[](#cache \"Link for this heading\")\n\nCall `cache` outside of any components to create a version of the function with caching.\n\n```\nimport {cache} from 'react';import calculateMetrics from 'lib/metrics';const getMetrics = cache(calculateMetrics);function Chart({data}) {const report = getMetrics(data);// ...}\n```\n\nWhen `getMetrics` is first called with `data`, `getMetrics` will call `calculateMetrics(data)` and store the result in cache. If `getMetrics` is called again with the same `data`, it will return the cached result instead of calling `calculateMetrics(data)` again.\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `fn`: The function you want to cache results for. `fn` can take any arguments and return any value.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`cache` returns a cached version of `fn` with the same type signature. It does not call `fn` in the process.\n\nWhen calling `cachedFn` with given arguments, it first checks if a cached result exists in the cache. If a cached result exists, it returns the result. If not, it calls `fn` with the arguments, stores the result in the cache, and returns the result. The only time `fn` is called is when there is a cache miss.\n\n### Note\n\nThe optimization of caching return values based on inputs is known as [_memoization_](https://en.wikipedia.org/wiki/Memoization). We refer to the function returned from `cache` as a memoized function.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   React will invalidate the cache for all memoized functions for each server request.\n*   Each call to `cache` creates a new function. This means that calling `cache` with the same function multiple times will return different memoized functions that do not share the same cache.\n*   `cachedFn` will also cache errors. If `fn` throws an error for certain arguments, it will be cached, and the same error is re-thrown when `cachedFn` is called with those same arguments.\n*   `cache` is for use in [Server Components](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components) only.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Cache an expensive computation[](#cache-expensive-computation \"Link for Cache an expensive computation \")\n\nUse `cache` to skip duplicate work.\n\n```\nimport {cache} from 'react';import calculateUserMetrics from 'lib/user';const getUserMetrics = cache(calculateUserMetrics);function Profile({user}) {const metrics = getUserMetrics(user);// ...}function TeamReport({users}) {for (let user in users) {const metrics = getUserMetrics(user);// ...}// ...}\n```\n\nIf the same `user` object is rendered in both `Profile` and `TeamReport`, the two components can share work and only call `calculateUserMetrics` once for that `user`.\n\nAssume `Profile` is rendered first. It will call `getUserMetrics`, and check if there is a cached result. Since it is the first time `getUserMetrics` is called with that `user`, there will be a cache miss. `getUserMetrics` will then call `calculateUserMetrics` with that `user` and write the result to cache.\n\nWhen `TeamReport` renders its list of `users` and reaches the same `user` object, it will call `getUserMetrics` and read the result from cache.\n\n### Pitfall\n\n##### Calling different memoized functions will read from different caches.[](#pitfall-different-memoized-functions \"Link for Calling different memoized functions will read from different caches. \")\n\nTo access the same cache, components must call the same memoized function.\n\n```\n// Temperature.jsimport {cache} from 'react';import {calculateWeekReport} from './report';export function Temperature({cityData}) {// üö© Wrong: Calling `cache` in component creates new `getWeekReport` for each renderconst getWeekReport = cache(calculateWeekReport);const report = getWeekReport(cityData);// ...}\n```\n\n```\n// Precipitation.jsimport {cache} from 'react';import {calculateWeekReport} from './report';// üö© Wrong: `getWeekReport` is only accessible for `Precipitation` component.const getWeekReport = cache(calculateWeekReport);export function Precipitation({cityData}) {const report = getWeekReport(cityData);// ...}\n```\n\nIn the above example, `Precipitation` and `Temperature` each call `cache` to create a new memoized function with their own cache look-up. If both components render for the same `cityData`, they will do duplicate work to call `calculateWeekReport`.\n\nIn addition, `Temperature` creates a new memoized function each time the component is rendered which doesn‚Äôt allow for any cache sharing.\n\nTo maximize cache hits and reduce work, the two components should call the same memoized function to access the same cache. Instead, define the memoized function in a dedicated module that can be [`import`\\-ed](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) across components.\n\n```\n// getWeekReport.jsimport {cache} from 'react';import {calculateWeekReport} from './report';export default cache(calculateWeekReport);\n```\n\n```\n// Temperature.jsimport getWeekReport from './getWeekReport';export default function Temperature({cityData}) {const report = getWeekReport(cityData);// ...}\n```\n\n```\n// Precipitation.jsimport getWeekReport from './getWeekReport';export default function Precipitation({cityData}) {const report = getWeekReport(cityData);// ...}\n```\n\nHere, both components call the same memoized function exported from `./getWeekReport.js` to read and write to the same cache.\n\nTo share a snapshot of data between components, call `cache` with a data-fetching function like `fetch`. When multiple components make the same data fetch, only one request is made and the data returned is cached and shared across components. All components refer to the same snapshot of data across the server render.\n\n```\nimport {cache} from 'react';import {fetchTemperature} from './api.js';const getTemperature = cache(async (city) => {return await fetchTemperature(city);});async function AnimatedWeatherCard({city}) {const temperature = await getTemperature(city);// ...}async function MinimalWeatherCard({city}) {const temperature = await getTemperature(city);// ...}\n```\n\nIf `AnimatedWeatherCard` and `MinimalWeatherCard` both render for the same city, they will receive the same snapshot of data from the memoized function.\n\nIf `AnimatedWeatherCard` and `MinimalWeatherCard` supply different city arguments to `getTemperature`, then `fetchTemperature` will be called twice and each call site will receive different data.\n\nThe city acts as a cache key.\n\n### Note\n\nAsynchronous rendering is only supported for Server Components.\n\n```\nasync function AnimatedWeatherCard({city}) {const temperature = await getTemperature(city);// ...}\n```\n\n### Preload data[](#preload-data \"Link for Preload data \")\n\nBy caching a long-running data fetch, you can kick off asynchronous work prior to rendering the component.\n\n```\nconst getUser = cache(async (id) => {return await db.user.query(id);})async function Profile({id}) {const user = await getUser(id);return (<section><img src={user.profilePic} /><h2>{user.name}</h2></section>);}function Page({id}) {// ‚úÖ Good: start fetching the user datagetUser(id);// ... some computational workreturn (<><Profile id={id} /></>);}\n```\n\nWhen rendering `Page`, the component calls `getUser` but note that it doesn‚Äôt use the returned data. This early `getUser` call kicks off the asynchronous database query that occurs while `Page` is doing other computational work and rendering children.\n\nWhen rendering `Profile`, we call `getUser` again. If the initial `getUser` call has already returned and cached the user data, when `Profile` asks and waits for this data, it can simply read from the cache without requiring another remote procedure call. If the initial data request hasn‚Äôt been completed, preloading data in this pattern reduces delay in data-fetching.\n\n##### Deep Dive\n\n#### Caching asynchronous work[](#caching-asynchronous-work \"Link for Caching asynchronous work \")\n\nWhen evaluating an [asynchronous function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function), you will receive a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) for that work. The promise holds the state of that work (_pending_, _fulfilled_, _failed_) and its eventual settled result.\n\nIn this example, the asynchronous function `fetchData` returns a promise that is awaiting the `fetch`.\n\n```\nasync function fetchData() {return await fetch(`https://...`);}const getData = cache(fetchData);async function MyComponent() {getData();// ... some computational work  await getData();// ...}\n```\n\nIn calling `getData` the first time, the promise returned from `fetchData` is cached. Subsequent look-ups will then return the same promise.\n\nNotice that the first `getData` call does not `await` whereas the second does. [`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) is a JavaScript operator that will wait and return the settled result of the promise. The first `getData` call simply initiates the `fetch` to cache the promise for the second `getData` to look-up.\n\nIf by the second call the promise is still _pending_, then `await` will pause for the result. The optimization is that while we wait on the `fetch`, React can continue with computational work, thus reducing the wait time for the second call.\n\nIf the promise is already settled, either to an error or the _fulfilled_ result, `await` will return that value immediately. In both outcomes, there is a performance benefit.\n\n### Pitfall\n\n##### Calling a memoized function outside of a component will not use the cache.[](#pitfall-memoized-call-outside-component \"Link for Calling a memoized function outside of a component will not use the cache. \")\n\n```\nimport {cache} from 'react';const getUser = cache(async (userId) => {return await db.user.query(userId);});// üö© Wrong: Calling memoized function outside of component will not memoize.getUser('demo-id');async function DemoProfile() {// ‚úÖ Good: `getUser` will memoize.const user = await getUser('demo-id');return <Profile user={user} />;}\n```\n\nReact only provides cache access to the memoized function in a component. When calling `getUser` outside of a component, it will still evaluate the function but not read or update the cache.\n\nThis is because cache access is provided through a [context](https://react.dev/learn/passing-data-deeply-with-context) which is only accessible from a component.\n\n##### Deep Dive\n\n#### When should I use `cache`, [`memo`](https://react.dev/reference/react/memo), or [`useMemo`](https://react.dev/reference/react/useMemo)?[](#cache-memo-usememo \"Link for this heading\")\n\nAll mentioned APIs offer memoization but the difference is what they‚Äôre intended to memoize, who can access the cache, and when their cache is invalidated.\n\n#### `useMemo`[](#deep-dive-use-memo \"Link for this heading\")\n\nIn general, you should use [`useMemo`](https://react.dev/reference/react/useMemo) for caching a expensive computation in a Client Component across renders. As an example, to memoize a transformation of data within a component.\n\n```\n'use client';function WeatherReport({record}) {const avgTemp = useMemo(() => calculateAvg(record)), record);// ...}function App() {const record = getRecord();return (<><WeatherReport record={record} /><WeatherReport record={record} /></>);}\n```\n\nIn this example, `App` renders two `WeatherReport`s with the same record. Even though both components do the same work, they cannot share work. `useMemo`‚Äôs cache is only local to the component.\n\nHowever, `useMemo` does ensure that if `App` re-renders and the `record` object doesn‚Äôt change, each component instance would skip work and use the memoized value of `avgTemp`. `useMemo` will only cache the last computation of `avgTemp` with the given dependencies.\n\n#### `cache`[](#deep-dive-cache \"Link for this heading\")\n\nIn general, you should use `cache` in Server Components to memoize work that can be shared across components.\n\n```\nconst cachedFetchReport = cache(fetchReport);function WeatherReport({city}) {const report = cachedFetchReport(city);// ...}function App() {const city = \"Los Angeles\";return (<><WeatherReport city={city} /><WeatherReport city={city} /></>);}\n```\n\nRe-writing the previous example to use `cache`, in this case the second instance of `WeatherReport` will be able to skip duplicate work and read from the same cache as the first `WeatherReport`. Another difference from the previous example is that `cache` is also recommended for memoizing data fetches, unlike `useMemo` which should only be used for computations.\n\nAt this time, `cache` should only be used in Server Components and the cache will be invalidated across server requests.\n\n#### `memo`[](#deep-dive-memo \"Link for this heading\")\n\nYou should use [`memo`](https://react.dev/reference/react/memo) to prevent a component re-rendering if its props are unchanged.\n\n```\n'use client';function WeatherReport({record}) {const avgTemp = calculateAvg(record); // ...}const MemoWeatherReport = memo(WeatherReport);function App() {const record = getRecord();return (<><MemoWeatherReport record={record} /><MemoWeatherReport record={record} /></>);}\n```\n\nIn this example, both `MemoWeatherReport` components will call `calculateAvg` when first rendered. However, if `App` re-renders, with no changes to `record`, none of the props have changed and `MemoWeatherReport` will not re-render.\n\nCompared to `useMemo`, `memo` memoizes the component render based on props vs. specific computations. Similar to `useMemo`, the memoized component only caches the last render with the last prop values. Once the props change, the cache invalidates and the component re-renders.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### My memoized function still runs even though I‚Äôve called it with the same arguments[](#memoized-function-still-runs \"Link for My memoized function still runs even though I‚Äôve called it with the same arguments \")\n\nSee prior mentioned pitfalls\n\n*   [Calling different memoized functions will read from different caches.](#pitfall-different-memoized-functions)\n*   [Calling a memoized function outside of a component will not use the cache.](#pitfall-memoized-call-outside-component)\n\nIf none of the above apply, it may be a problem with how React checks if something exists in cache.\n\nIf your arguments are not [primitives](https://developer.mozilla.org/en-US/docs/Glossary/Primitive) (ex. objects, functions, arrays), ensure you‚Äôre passing the same object reference.\n\nWhen calling a memoized function, React will look up the input arguments to see if a result is already cached. React will use shallow equality of the arguments to determine if there is a cache hit.\n\n```\nimport {cache} from 'react';const calculateNorm = cache((vector) => {// ...});function MapMarker(props) {// üö© Wrong: props is an object that changes every render.const length = calculateNorm(props);// ...}function App() {return (<><MapMarker x={10} y={10} z={10} /><MapMarker x={10} y={10} z={10} /></>);}\n```\n\nIn this case the two `MapMarker`s look like they‚Äôre doing the same work and calling `calculateNorm` with the same value of `{x: 10, y: 10, z:10}`. Even though the objects contain the same values, they are not the same object reference as each component creates its own `props` object.\n\nReact will call [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) on the input to verify if there is a cache hit.\n\n```\nimport {cache} from 'react';const calculateNorm = cache((x, y, z) => {// ...});function MapMarker(props) {// ‚úÖ Good: Pass primitives to memoized functionconst length = calculateNorm(props.x, props.y, props.z);// ...}function App() {return (<><MapMarker x={10} y={10} z={10} /><MapMarker x={10} y={10} z={10} /></>);}\n```\n\nOne way to address this could be to pass the vector dimensions to `calculateNorm`. This works because the dimensions themselves are primitives.\n\nAnother solution may be to pass the vector object itself as a prop to the component. We‚Äôll need to pass the same object to both component instances.\n\n```\nimport {cache} from 'react';const calculateNorm = cache((vector) => {// ...});function MapMarker(props) {// ‚úÖ Good: Pass the same `vector` objectconst length = calculateNorm(props.vector);// ...}function App() {const vector = [10, 10, 10];return (<><MapMarker vector={vector} /><MapMarker vector={vector} /></>);}\n```",
  "title": "cache ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/forwardRef",
  "markdown": "# forwardRef ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`forwardRef` lets your component expose a DOM node to parent component with a [ref.](https://react.dev/learn/manipulating-the-dom-with-refs)\n\n```\nconst SomeComponent = forwardRef(render)\n```\n\n*   [Reference](#reference)\n    *   [`forwardRef(render)`](#forwardref)\n    *   [`render` function](#render-function)\n*   [Usage](#usage)\n    *   [Exposing a DOM node to the parent component](#exposing-a-dom-node-to-the-parent-component)\n    *   [Forwarding a ref through multiple components](#forwarding-a-ref-through-multiple-components)\n    *   [Exposing an imperative handle instead of a DOM node](#exposing-an-imperative-handle-instead-of-a-dom-node)\n*   [Troubleshooting](#troubleshooting)\n    *   [My component is wrapped in `forwardRef`, but the `ref` to it is always `null`](#my-component-is-wrapped-in-forwardref-but-the-ref-to-it-is-always-null)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `forwardRef(render)`[](#forwardref \"Link for this heading\")\n\nCall `forwardRef()` to let your component receive a ref and forward it to a child component:\n\n```\nimport { forwardRef } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {// ...});\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `render`: The render function for your component. React calls this function with the props and `ref` that your component received from its parent. The JSX you return will be the output of your component.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`forwardRef` returns a React component that you can render in JSX. Unlike React components defined as plain functions, a component returned by `forwardRef` is also able to receive a `ref` prop.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   In Strict Mode, React will **call your render function twice** in order to [help you find accidental impurities.](https://react.dev/reference/react/useState#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. If your render function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.\n\n* * *\n\n### `render` function[](#render-function \"Link for this heading\")\n\n`forwardRef` accepts a render function as an argument. React calls this function with `props` and `ref`:\n\n```\nconst MyInput = forwardRef(function MyInput(props, ref) {return (<label>{props.label}<input ref={ref} /></label>);});\n```\n\n#### Parameters[](#render-parameters \"Link for Parameters \")\n\n*   `props`: The props passed by the parent component.\n    \n*   `ref`: The `ref` attribute passed by the parent component. The `ref` can be an object or a function. If the parent component has not passed a ref, it will be `null`. You should either pass the `ref` you receive to another component, or pass it to [`useImperativeHandle`.](https://react.dev/reference/react/useImperativeHandle)\n    \n\n#### Returns[](#render-returns \"Link for Returns \")\n\n`forwardRef` returns a React component that you can render in JSX. Unlike React components defined as plain functions, the component returned by `forwardRef` is able to take a `ref` prop.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Exposing a DOM node to the parent component[](#exposing-a-dom-node-to-the-parent-component \"Link for Exposing a DOM node to the parent component \")\n\nBy default, each component‚Äôs DOM nodes are private. However, sometimes it‚Äôs useful to expose a DOM node to the parent‚Äîfor example, to allow focusing it. To opt in, wrap your component definition into `forwardRef()`:\n\n```\nimport { forwardRef } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {const { label, ...otherProps } = props;return (<label>{label}<input {...otherProps} /></label>);});\n```\n\nYou will receive a ref as the second argument after props. Pass it to the DOM node that you want to expose:\n\n```\nimport { forwardRef } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {const { label, ...otherProps } = props;return (<label>{label}<input {...otherProps} ref={ref} /></label>);});\n```\n\nThis lets the parent `Form` component access the `<input>` DOM node exposed by `MyInput`:\n\n```\nfunction Form() {const ref = useRef(null);function handleClick() {ref.current.focus();}return (<form><MyInput label=\"Enter your name:\" ref={ref} /><button type=\"button\" onClick={handleClick}>        Edit</button></form>);}\n```\n\nThis `Form` component [passes a ref](https://react.dev/reference/react/useRef#manipulating-the-dom-with-a-ref) to `MyInput`. The `MyInput` component _forwards_ that ref to the `<input>` browser tag. As a result, the `Form` component can access that `<input>` DOM node and call [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) on it.\n\nKeep in mind that exposing a ref to the DOM node inside your component makes it harder to change your component‚Äôs internals later. You will typically expose DOM nodes from reusable low-level components like buttons or text inputs, but you won‚Äôt do it for application-level components like an avatar or a comment.\n\n#### Examples of forwarding a ref[](#examples \"Link for Examples of forwarding a ref\")\n\n#### Focusing a text input[](#focusing-a-text-input \"Link for this heading\")\n\nClicking the button will focus the input. The `Form` component defines a ref and passes it to the `MyInput` component. The `MyInput` component forwards that ref to the browser `<input>`. This lets the `Form` component focus the `<input>`.\n\nimport { useRef } from 'react';\nimport MyInput from './MyInput.js';\n\nexport default function Form() {\n  const ref = useRef(null);\n\n  function handleClick() {\n    ref.current.focus();\n  }\n\n  return (\n    <form\\>\n      <MyInput label\\=\"Enter your name:\" ref\\={ref} />\n      <button type\\=\"button\" onClick\\={handleClick}\\>\n        Edit\n      </button\\>\n    </form\\>\n  );\n}\n\n* * *\n\n### Forwarding a ref through multiple components[](#forwarding-a-ref-through-multiple-components \"Link for Forwarding a ref through multiple components \")\n\nInstead of forwarding a `ref` to a DOM node, you can forward it to your own component like `MyInput`:\n\n```\nconst FormField = forwardRef(function FormField(props, ref) {// ...return (<><MyInput ref={ref} />      ...</>);});\n```\n\nIf that `MyInput` component forwards a ref to its `<input>`, a ref to `FormField` will give you that `<input>`:\n\n```\nfunction Form() {const ref = useRef(null);function handleClick() {ref.current.focus();}return (<form><FormField label=\"Enter your name:\" ref={ref} isRequired={true} /><button type=\"button\" onClick={handleClick}>        Edit</button></form>);}\n```\n\nThe `Form` component defines a ref and passes it to `FormField`. The `FormField` component forwards that ref to `MyInput`, which forwards it to a browser `<input>` DOM node. This is how `Form` accesses that DOM node.\n\nimport { useRef } from 'react';\nimport FormField from './FormField.js';\n\nexport default function Form() {\n  const ref = useRef(null);\n\n  function handleClick() {\n    ref.current.focus();\n  }\n\n  return (\n    <form\\>\n      <FormField label\\=\"Enter your name:\" ref\\={ref} isRequired\\={true} />\n      <button type\\=\"button\" onClick\\={handleClick}\\>\n        Edit\n      </button\\>\n    </form\\>\n  );\n}\n\n* * *\n\n### Exposing an imperative handle instead of a DOM node[](#exposing-an-imperative-handle-instead-of-a-dom-node \"Link for Exposing an imperative handle instead of a DOM node \")\n\nInstead of exposing an entire DOM node, you can expose a custom object, called an _imperative handle,_ with a more constrained set of methods. To do this, you‚Äôd need to define a separate ref to hold the DOM node:\n\n```\nconst MyInput = forwardRef(function MyInput(props, ref) {const inputRef = useRef(null);// ...return <input {...props} ref={inputRef} />;});\n```\n\nPass the `ref` you received to [`useImperativeHandle`](https://react.dev/reference/react/useImperativeHandle) and specify the value you want to expose to the `ref`:\n\n```\nimport { forwardRef, useRef, useImperativeHandle } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {const inputRef = useRef(null);useImperativeHandle(ref, () => {return {focus() {inputRef.current.focus();},scrollIntoView() {inputRef.current.scrollIntoView();},};}, []);return <input {...props} ref={inputRef} />;});\n```\n\nIf some component gets a ref to `MyInput`, it will only receive your `{ focus, scrollIntoView }` object instead of the DOM node. This lets you limit the information you expose about your DOM node to the minimum.\n\nimport { useRef } from 'react';\nimport MyInput from './MyInput.js';\n\nexport default function Form() {\n  const ref = useRef(null);\n\n  function handleClick() {\n    ref.current.focus();\n    \n    \n  }\n\n  return (\n    <form\\>\n      <MyInput placeholder\\=\"Enter your name\" ref\\={ref} />\n      <button type\\=\"button\" onClick\\={handleClick}\\>\n        Edit\n      </button\\>\n    </form\\>\n  );\n}\n\n[Read more about using imperative handles.](https://react.dev/reference/react/useImperativeHandle)\n\n### Pitfall\n\n**Do not overuse refs.** You should only use refs for _imperative_ behaviors that you can‚Äôt express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.\n\n**If you can express something as a prop, you should not use a ref.** For example, instead of exposing an imperative handle like `{ open, close }` from a `Modal` component, it is better to take `isOpen` as a prop like `<Modal isOpen={isOpen} />`. [Effects](https://react.dev/learn/synchronizing-with-effects) can help you expose imperative behaviors via props.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### My component is wrapped in `forwardRef`, but the `ref` to it is always `null`[](#my-component-is-wrapped-in-forwardref-but-the-ref-to-it-is-always-null \"Link for this heading\")\n\nThis usually means that you forgot to actually use the `ref` that you received.\n\nFor example, this component doesn‚Äôt do anything with its `ref`:\n\n```\nconst MyInput = forwardRef(function MyInput({ label }, ref) {return (<label>{label}<input /></label>);});\n```\n\nTo fix it, pass the `ref` down to a DOM node or another component that can accept a ref:\n\n```\nconst MyInput = forwardRef(function MyInput({ label }, ref) {return (<label>{label}<input ref={ref} /></label>);});\n```\n\nThe `ref` to `MyInput` could also be `null` if some of the logic is conditional:\n\n```\nconst MyInput = forwardRef(function MyInput({ label, showInput }, ref) {return (<label>{label}{showInput && <input ref={ref} />}</label>);});\n```\n\nIf `showInput` is `false`, then the ref won‚Äôt be forwarded to any node, and a ref to `MyInput` will remain empty. This is particularly easy to miss if the condition is hidden inside another component, like `Panel` in this example:\n\n```\nconst MyInput = forwardRef(function MyInput({ label, showInput }, ref) {return (<label>{label}<Panel isExpanded={showInput}><input ref={ref} /></Panel></label>);});\n```",
  "title": "forwardRef ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/memo",
  "markdown": "# memo ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`memo` lets you skip re-rendering a component when its props are unchanged.\n\n```\nconst MemoizedComponent = memo(SomeComponent, arePropsEqual?)\n```\n\n*   [Reference](#reference)\n    *   [`memo(Component, arePropsEqual?)`](#memo)\n*   [Usage](#usage)\n    *   [Skipping re-rendering when props are unchanged](#skipping-re-rendering-when-props-are-unchanged)\n    *   [Updating a memoized component using state](#updating-a-memoized-component-using-state)\n    *   [Updating a memoized component using a context](#updating-a-memoized-component-using-a-context)\n    *   [Minimizing props changes](#minimizing-props-changes)\n    *   [Specifying a custom comparison function](#specifying-a-custom-comparison-function)\n*   [Troubleshooting](#troubleshooting)\n    *   [My component re-renders when a prop is an object, array, or function](#my-component-rerenders-when-a-prop-is-an-object-or-array)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `memo(Component, arePropsEqual?)`[](#memo \"Link for this heading\")\n\nWrap a component in `memo` to get a _memoized_ version of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee.\n\n```\nimport { memo } from 'react';const SomeComponent = memo(function SomeComponent(props) {// ...});\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `Component`: The component that you want to memoize. The `memo` does not modify this component, but returns a new, memoized component instead. Any valid React component, including functions and [`forwardRef`](https://react.dev/reference/react/forwardRef) components, is accepted.\n    \n*   **optional** `arePropsEqual`: A function that accepts two arguments: the component‚Äôs previous props, and its new props. It should return `true` if the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should return `false`. Usually, you will not specify this function. By default, React will compare each prop with [`Object.is`.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)\n    \n\n#### Returns[](#returns \"Link for Returns \")\n\n`memo` returns a new React component. It behaves the same as the component provided to `memo` except that React will not always re-render it when its parent is being re-rendered unless its props have changed.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Skipping re-rendering when props are unchanged[](#skipping-re-rendering-when-props-are-unchanged \"Link for Skipping re-rendering when props are unchanged \")\n\nReact normally re-renders a component whenever its parent re-renders. With `memo`, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to be _memoized_.\n\nTo memoize a component, wrap it in `memo` and use the value that it returns in place of your original component:\n\n```\nconst Greeting = memo(function Greeting({ name }) {return <h1>Hello, {name}!</h1>;});export default Greeting;\n```\n\nA React component should always have [pure rendering logic.](https://react.dev/learn/keeping-components-pure) This means that it must return the same output if its props, state, and context haven‚Äôt changed. By using `memo`, you are telling React that your component complies with this requirement, so React doesn‚Äôt need to re-render as long as its props haven‚Äôt changed. Even with `memo`, your component will re-render if its own state changes or if a context that it‚Äôs using changes.\n\nIn this example, notice that the `Greeting` component re-renders whenever `name` is changed (because that‚Äôs one of its props), but not when `address` is changed (because it‚Äôs not passed to `Greeting` as a prop):\n\nimport { memo, useState } from 'react';\n\nexport default function MyApp() {\n  const \\[name, setName\\] = useState('');\n  const \\[address, setAddress\\] = useState('');\n  return (\n    <\\>\n      <label\\>\n        Name{': '}\n        <input value\\={name} onChange\\={e \\=> setName(e.target.value)} />\n      </label\\>\n      <label\\>\n        Address{': '}\n        <input value\\={address} onChange\\={e \\=> setAddress(e.target.value)} />\n      </label\\>\n      <Greeting name\\={name} />\n    </\\>\n  );\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n  return <h3\\>Hello{name && ', '}{name}!</h3\\>;\n});\n\n### Note\n\n**You should only rely on `memo` as a performance optimization.** If your code doesn‚Äôt work without it, find the underlying problem and fix it first. Then you may add `memo` to improve performance.\n\n##### Deep Dive\n\n#### Should you add memo everywhere?[](#should-you-add-memo-everywhere \"Link for Should you add memo everywhere? \")\n\nIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.\n\nOptimizing with `memo` is only valuable when your component re-renders often with the same exact props, and its re-rendering logic is expensive. If there is no perceptible lag when your component re-renders, `memo` is unnecessary. Keep in mind that `memo` is completely useless if the props passed to your component are _always different,_ such as if you pass an object or a plain function defined during rendering. This is why you will often need [`useMemo`](https://react.dev/reference/react/useMemo#skipping-re-rendering-of-components) and [`useCallback`](https://react.dev/reference/react/useCallback#skipping-re-rendering-of-components) together with `memo`.\n\nThere is no benefit to wrapping a component in `memo` in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that‚Äôs ‚Äúalways new‚Äù is enough to break memoization for an entire component.\n\n**In practice, you can make a lot of memoization unnecessary by following a few principles:**\n\n1.  When a component visually wraps other components, let it [accept JSX as children.](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) This way, when the wrapper component updates its own state, React knows that its children don‚Äôt need to re-render.\n2.  Prefer local state and don‚Äôt [lift state up](https://react.dev/learn/sharing-state-between-components) any further than necessary. For example, don‚Äôt keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\n3.  Keep your [rendering logic pure.](https://react.dev/learn/keeping-components-pure) If re-rendering a component causes a problem or produces some noticeable visual artifact, it‚Äôs a bug in your component! Fix the bug instead of adding memoization.\n4.  Avoid [unnecessary Effects that update state.](https://react.dev/learn/you-might-not-need-an-effect) Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\n5.  Try to [remove unnecessary dependencies from your Effects.](https://react.dev/learn/removing-effect-dependencies) For example, instead of memoization, it‚Äôs often simpler to move some object or a function inside an Effect or outside the component.\n\nIf a specific interaction still feels laggy, [use the React Developer Tools profiler](https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html) to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it‚Äôs good to follow them in any case. In the long term, we‚Äôre researching [doing granular memoization automatically](https://www.youtube.com/watch?v=lGEMwh32soc) to solve this once and for all.\n\n* * *\n\n### Updating a memoized component using state[](#updating-a-memoized-component-using-state \"Link for Updating a memoized component using state \")\n\nEven when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent.\n\nimport { memo, useState } from 'react';\n\nexport default function MyApp() {\n  const \\[name, setName\\] = useState('');\n  const \\[address, setAddress\\] = useState('');\n  return (\n    <\\>\n      <label\\>\n        Name{': '}\n        <input value\\={name} onChange\\={e \\=> setName(e.target.value)} />\n      </label\\>\n      <label\\>\n        Address{': '}\n        <input value\\={address} onChange\\={e \\=> setAddress(e.target.value)} />\n      </label\\>\n      <Greeting name\\={name} />\n    </\\>\n  );\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log('Greeting was rendered at', new Date().toLocaleTimeString());\n  const \\[greeting, setGreeting\\] = useState('Hello');\n  return (\n    <\\>\n      <h3\\>{greeting}{name && ', '}{name}!</h3\\>\n      <GreetingSelector value\\={greeting} onChange\\={setGreeting} />\n    </\\>\n  );\n});\n\nfunction GreetingSelector({ value, onChange }) {\n  return (\n    <\\>\n      <label\\>\n        <input\n          type\\=\"radio\"\n          checked\\={value === 'Hello'}\n          onChange\\={e \\=> onChange('Hello')}\n        />\n        Regular greeting\n      </label\\>\n      <label\\>\n        <input\n          type\\=\"radio\"\n          checked\\={value === 'Hello and welcome'}\n          onChange\\={e \\=> onChange('Hello and welcome')}\n        />\n        Enthusiastic greeting\n      </label\\>\n    </\\>\n  );\n}\n\nIf you set a state variable to its current value, React will skip re-rendering your component even without `memo`. You may still see your component function being called an extra time, but the result will be discarded.\n\n* * *\n\n### Updating a memoized component using a context[](#updating-a-memoized-component-using-a-context \"Link for Updating a memoized component using a context \")\n\nEven when a component is memoized, it will still re-render when a context that it‚Äôs using changes. Memoization only has to do with props that are passed to the component from its parent.\n\nimport { createContext, memo, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  const \\[theme, setTheme\\] = useState('dark');\n\n  function handleClick() {\n    setTheme(theme === 'dark' ? 'light' : 'dark'); \n  }\n\n  return (\n    <ThemeContext.Provider value\\={theme}\\>\n      <button onClick\\={handleClick}\\>\n        Switch theme\n      </button\\>\n      <Greeting name\\=\"Taylor\" />\n    </ThemeContext.Provider\\>\n  );\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n  const theme = useContext(ThemeContext);\n  return (\n    <h3 className\\={theme}\\>Hello, {name}!</h3\\>\n  );\n});\n\nTo make your component re-render only when a _part_ of some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop.\n\n* * *\n\n### Minimizing props changes[](#minimizing-props-changes \"Link for Minimizing props changes \")\n\nWhen you use `memo`, your component re-renders whenever any prop is not _shallowly equal_ to what it was previously. This means that React compares every prop in your component with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. Note that `Object.is(3, 3)` is `true`, but `Object.is({}, {})` is `false`.\n\nTo get the most out of `memo`, minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by using [`useMemo`:](https://react.dev/reference/react/useMemo)\n\n```\nfunction Page() {const [name, setName] = useState('Taylor');const [age, setAge] = useState(42);const person = useMemo(() => ({ name, age }),[name, age]);return <Profile person={person} />;}const Profile = memo(function Profile({ person }) {// ...});\n```\n\nA better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object:\n\n```\nfunction Page() {const [name, setName] = useState('Taylor');const [age, setAge] = useState(42);return <Profile name={name} age={age} />;}const Profile = memo(function Profile({ name, age }) {// ...});\n```\n\nEven individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself:\n\n```\nfunction GroupsLanding({ person }) {const hasGroups = person.groups !== null;return <CallToAction hasGroups={hasGroups} />;}const CallToAction = memo(function CallToAction({ hasGroups }) {// ...});\n```\n\nWhen you need to pass a function to memoized component, either declare it outside your component so that it never changes, or [`useCallback`](https://react.dev/reference/react/useCallback#skipping-re-rendering-of-components) to cache its definition between re-renders.\n\n* * *\n\n### Specifying a custom comparison function[](#specifying-a-custom-comparison-function \"Link for Specifying a custom comparison function \")\n\nIn rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument to `memo`. It should return `true` only if the new props would result in the same output as the old props; otherwise it should return `false`.\n\n```\nconst Chart = memo(function Chart({ dataPoints }) {// ...}, arePropsEqual);function arePropsEqual(oldProps, newProps) {return (oldProps.dataPoints.length === newProps.dataPoints.length &&oldProps.dataPoints.every((oldPoint, index) => {const newPoint = newProps.dataPoints[index];return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y;}));}\n```\n\nIf you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised.\n\nWhen you do performance measurements, make sure that React is running in the production mode.\n\n### Pitfall\n\nIf you provide a custom `arePropsEqual` implementation, **you must compare every prop, including functions.** Functions often [close over](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) the props and state of parent components. If you return `true` when `oldProps.onClick !== newProps.onClick`, your component will keep ‚Äúseeing‚Äù the props and state from a previous render inside its `onClick` handler, leading to very confusing bugs.\n\nAvoid doing deep equality checks inside `arePropsEqual` unless you are 100% sure that the data structure you‚Äôre working with has a known limited depth. **Deep equality checks can become incredibly slow** and can freeze your app for many seconds if someone changes the data structure later.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### My component re-renders when a prop is an object, array, or function[](#my-component-rerenders-when-a-prop-is-an-object-or-array \"Link for My component re-renders when a prop is an object, array, or function \")\n\nReact compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this, [simplify props or memoize props in the parent component](#minimizing-props-changes).",
  "title": "memo ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/startTransition",
  "markdown": "# startTransition ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`startTransition` lets you update the state without blocking the UI.\n\n*   [Reference](#reference)\n    *   [`startTransition(scope)`](#starttransitionscope)\n*   [Usage](#usage)\n    *   [Marking a state update as a non-blocking Transition](#marking-a-state-update-as-a-non-blocking-transition)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `startTransition(scope)`[](#starttransitionscope \"Link for this heading\")\n\nThe `startTransition` function lets you mark a state update as a Transition.\n\n```\nimport { startTransition } from 'react';function TabContainer() {const [tab, setTab] = useState('about');function selectTab(nextTab) {startTransition(() => {setTab(nextTab);});}// ...}\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `scope`: A function that updates some state by calling one or more [`set` functions.](https://react.dev/reference/react/useState#setstate) React immediately calls `scope` with no arguments and marks all state updates scheduled synchronously during the `scope` function call as Transitions. They will be [non-blocking](https://react.dev/reference/react/useTransition#marking-a-state-update-as-a-non-blocking-transition) and [will not display unwanted loading indicators.](https://react.dev/reference/react/useTransition#preventing-unwanted-loading-indicators)\n\n#### Returns[](#returns \"Link for Returns \")\n\n`startTransition` does not return anything.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   `startTransition` does not provide a way to track whether a Transition is pending. To show a pending indicator while the Transition is ongoing, you need [`useTransition`](https://react.dev/reference/react/useTransition) instead.\n    \n*   You can wrap an update into a Transition only if you have access to the `set` function of that state. If you want to start a Transition in response to some prop or a custom Hook return value, try [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue) instead.\n    \n*   The function you pass to `startTransition` must be synchronous. React immediately executes this function, marking all state updates that happen while it executes as Transitions. If you try to perform more state updates later (for example, in a timeout), they won‚Äôt be marked as Transitions.\n    \n*   A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update.\n    \n*   Transition updates can‚Äôt be used to control text inputs.\n    \n*   If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that will likely be removed in a future release.\n    \n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Marking a state update as a non-blocking Transition[](#marking-a-state-update-as-a-non-blocking-transition \"Link for Marking a state update as a non-blocking Transition \")\n\nYou can mark a state update as a _Transition_ by wrapping it in a `startTransition` call:\n\n```\nimport { startTransition } from 'react';function TabContainer() {const [tab, setTab] = useState('about');function selectTab(nextTab) {startTransition(() => {setTab(nextTab);});}// ...}\n```\n\nTransitions let you keep the user interface updates responsive even on slow devices.\n\nWith a Transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish.\n\n### Note",
  "title": "startTransition ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/lazy",
  "markdown": "# lazy ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`lazy` lets you defer loading component‚Äôs code until it is rendered for the first time.\n\n```\nconst SomeComponent = lazy(load)\n```\n\n*   [Reference](#reference)\n    *   [`lazy(load)`](#lazy)\n    *   [`load` function](#load)\n*   [Usage](#usage)\n    *   [Lazy-loading components with Suspense](#suspense-for-code-splitting)\n*   [Troubleshooting](#troubleshooting)\n    *   [My `lazy` component‚Äôs state gets reset unexpectedly](#my-lazy-components-state-gets-reset-unexpectedly)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `lazy(load)`[](#lazy \"Link for this heading\")\n\nCall `lazy` outside your components to declare a lazy-loaded React component:\n\n```\nimport { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `load`: A function that returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or another _thenable_ (a Promise-like object with a `then` method). React will not call `load` until the first time you attempt to render the returned component. After React first calls `load`, it will wait for it to resolve, and then render the resolved value‚Äôs `.default` as a React component. Both the returned Promise and the Promise‚Äôs resolved value will be cached, so React will not call `load` more than once. If the Promise rejects, React will `throw` the rejection reason for the nearest Error Boundary to handle.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`lazy` returns a React component you can render in your tree. While the code for the lazy component is still loading, attempting to render it will _suspend._ Use [`<Suspense>`](https://react.dev/reference/react/Suspense) to display a loading indicator while it‚Äôs loading.\n\n* * *\n\n### `load` function[](#load \"Link for this heading\")\n\n#### Parameters[](#load-parameters \"Link for Parameters \")\n\n`load` receives no parameters.\n\n#### Returns[](#load-returns \"Link for Returns \")\n\nYou need to return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or some other _thenable_ (a Promise-like object with a `then` method). It needs to eventually resolve to an object whose `.default` property is a valid React component type, such as a function, [`memo`](https://react.dev/reference/react/memo), or a [`forwardRef`](https://react.dev/reference/react/forwardRef) component.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Lazy-loading components with Suspense[](#suspense-for-code-splitting \"Link for Lazy-loading components with Suspense \")\n\nUsually, you import components with the static [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) declaration:\n\n```\nimport MarkdownPreview from './MarkdownPreview.js';\n```\n\nTo defer loading this component‚Äôs code until it‚Äôs rendered for the first time, replace this import with:\n\n```\nimport { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n```\n\nThis code relies on [dynamic `import()`,](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) which might require support from your bundler or framework. Using this pattern requires that the lazy component you‚Äôre importing was exported as the `default` export.\n\nNow that your component‚Äôs code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a [`<Suspense>`](https://react.dev/reference/react/Suspense) boundary:\n\n```\n<Suspense fallback={<Loading />}><h2>Preview</h2><MarkdownPreview /></Suspense>\n```\n\nIn this example, the code for `MarkdownPreview` won‚Äôt be loaded until you attempt to render it. If `MarkdownPreview` hasn‚Äôt loaded yet, `Loading` will be shown in its place. Try ticking the checkbox:\n\nThis demo loads with an artificial delay. The next time you untick and tick the checkbox, `Preview` will be cached, so there will be no loading state. To see the loading state again, click ‚ÄúReset‚Äù on the sandbox.\n\n[Learn more about managing loading states with Suspense.](https://react.dev/reference/react/Suspense)\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### My `lazy` component‚Äôs state gets reset unexpectedly[](#my-lazy-components-state-gets-reset-unexpectedly \"Link for this heading\")\n\nDo not declare `lazy` components _inside_ other components:\n\n```\nimport { lazy } from 'react';function Editor() {// üî¥ Bad: This will cause all state to be reset on re-rendersconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));// ...}\n```\n\nInstead, always declare them at the top level of your module:\n\n```\nimport { lazy } from 'react';// ‚úÖ Good: Declare lazy components outside of your componentsconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));function Editor() {// ...}\n```",
  "title": "lazy ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/use",
  "markdown": "# use ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Canary\n\n`use` is a React API that lets you read the value of a resource like a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or [context](https://react.dev/learn/passing-data-deeply-with-context).\n\n```\nconst value = use(resource);\n```\n\n*   [Reference](#reference)\n    *   [`use(resource)`](#use)\n*   [Usage](#usage)\n    *   [Reading context with `use`](#reading-context-with-use)\n    *   [Streaming data from the server to the client](#streaming-data-from-server-to-client)\n    *   [Dealing with rejected Promises](#dealing-with-rejected-promises)\n*   [Troubleshooting](#troubleshooting)\n    *   [‚ÄúSuspense Exception: This is not a real error!‚Äù](#suspense-exception-error)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `use(resource)`[](#use \"Link for this heading\")\n\nCall `use` in your component to read the value of a resource like a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or [context](https://react.dev/learn/passing-data-deeply-with-context).\n\n```\nimport { use } from 'react';function MessageComponent({ messagePromise }) {const message = use(messagePromise);const theme = use(ThemeContext);// ...\n```\n\nUnlike React Hooks, `use` can be called within loops and conditional statements like `if`. Like React Hooks, the function that calls `use` must be a Component or Hook.\n\nWhen called with a Promise, the `use` API integrates with [`Suspense`](https://react.dev/reference/react/Suspense) and [error boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary). The component calling `use` _suspends_ while the Promise passed to `use` is pending. If the component that calls `use` is wrapped in a Suspense boundary, the fallback will be displayed. Once the Promise is resolved, the Suspense fallback is replaced by the rendered components using the data returned by the `use` API. If the Promise passed to `use` is rejected, the fallback of the nearest Error Boundary will be displayed.\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `resource`: this is the source of the data you want to read a value from. A resource can be a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or a [context](https://react.dev/learn/passing-data-deeply-with-context).\n\n#### Returns[](#returns \"Link for Returns \")\n\nThe `use` API returns the value that was read from the resource like the resolved value of a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or [context](https://react.dev/learn/passing-data-deeply-with-context).\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   The `use` API must be called inside a Component or a Hook.\n*   When fetching data in a [Server Component](https://react.dev/reference/rsc/use-server), prefer `async` and `await` over `use`. `async` and `await` pick up rendering from the point where `await` was invoked, whereas `use` re-renders the component after the data is resolved.\n*   Prefer creating Promises in [Server Components](https://react.dev/reference/rsc/use-server) and passing them to [Client Components](https://react.dev/reference/rsc/use-client) over creating Promises in Client Components. Promises created in Client Components are recreated on every render. Promises passed from a Server Component to a Client Component are stable across re-renders. [See this example](#streaming-data-from-server-to-client).\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Reading context with `use`[](#reading-context-with-use \"Link for this heading\")\n\nWhen a [context](https://react.dev/learn/passing-data-deeply-with-context) is passed to `use`, it works similarly to [`useContext`](https://react.dev/reference/react/useContext). While `useContext` must be called at the top level of your component, `use` can be called inside conditionals like `if` and loops like `for`. `use` is preferred over `useContext` because it is more flexible.\n\n```\nimport { use } from 'react';function Button() {const theme = use(ThemeContext);// ...\n```\n\n`use` returns the context value for the context you passed. To determine the context value, React searches the component tree and finds **the closest context provider above** for that particular context.\n\nTo pass context to a `Button`, wrap it or one of its parent components into the corresponding context provider.\n\n```\nfunction MyPage() {return (<ThemeContext.Provider value=\"dark\"><Form /></ThemeContext.Provider>);}function Form() {// ... renders buttons inside ...}\n```\n\nIt doesn‚Äôt matter how many layers of components there are between the provider and the `Button`. When a `Button` _anywhere_ inside of `Form` calls `use(ThemeContext)`, it will receive `\"dark\"` as the value.\n\nUnlike [`useContext`](https://react.dev/reference/react/useContext), `use` can be called in conditionals and loops like `if`.\n\n```\nfunction HorizontalRule({ show }) {if (show) {const theme = use(ThemeContext);return <hr className={theme} />;}return false;}\n```\n\n`use` is called from inside a `if` statement, allowing you to conditionally read values from a Context.\n\n### Pitfall\n\nLike `useContext`, `use(context)` always looks for the closest context provider _above_ the component that calls it. It searches upwards and **does not** consider context providers in the component from which you‚Äôre calling `use(context)`.\n\nimport { createContext, use } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  return (\n    <ThemeContext.Provider value\\=\"dark\"\\>\n      <Form />\n    </ThemeContext.Provider\\>\n  )\n}\n\nfunction Form() {\n  return (\n    <Panel title\\=\"Welcome\"\\>\n      <Button show\\={true}\\>Sign up</Button\\>\n      <Button show\\={false}\\>Log in</Button\\>\n    </Panel\\>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = use(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className\\={className}\\>\n      <h1\\>{title}</h1\\>\n      {children}\n    </section\\>\n  )\n}\n\nfunction Button({ show, children }) {\n  if (show) {\n    const theme = use(ThemeContext);\n    const className = 'button-' + theme;\n    return (\n      <button className\\={className}\\>\n        {children}\n      </button\\>\n    );\n  }\n  return false\n}\n\n### Streaming data from the server to the client[](#streaming-data-from-server-to-client \"Link for Streaming data from the server to the client \")\n\nData can be streamed from the server to the client by passing a Promise as a prop from a Server Component to a Client Component.\n\n```\nimport { fetchMessage } from './lib.js';import { Message } from './message.js';export default function App() {const messagePromise = fetchMessage();return (<Suspense fallback={<p>waiting for message...</p>}><Message messagePromise={messagePromise} /></Suspense>);}\n```\n\nThe Client Component then takes the Promise it received as a prop and passes it to the `use` API. This allows the Client Component to read the value from the Promise that was initially created by the Server Component.\n\n```\n// message.js'use client';import { use } from 'react';export function Message({ messagePromise }) {const messageContent = use(messagePromise);return <p>Here is the message: {messageContent}</p>;}\n```\n\nBecause `Message` is wrapped in [`Suspense`](https://react.dev/reference/react/Suspense), the fallback will be displayed until the Promise is resolved. When the Promise is resolved, the value will be read by the `use` API and the `Message` component will replace the Suspense fallback.\n\n\"use client\";\n\nimport { use, Suspense } from \"react\";\n\nfunction Message({ messagePromise }) {\n  const messageContent = use(messagePromise);\n  return <p\\>Here is the message: {messageContent}</p\\>;\n}\n\nexport function MessageContainer({ messagePromise }) {\n  return (\n    <Suspense fallback\\={<p\\>‚åõDownloading message...</p\\>}\\>\n      <Message messagePromise\\={messagePromise} />\n    </Suspense\\>\n  );\n}\n\n### Note\n\nWhen passing a Promise from a Server Component to a Client Component, its resolved value must be serializable to pass between server and client. Data types like functions aren‚Äôt serializable and cannot be the resolved value of such a Promise.\n\n##### Deep Dive\n\n#### Should I resolve a Promise in a Server or Client Component?[](#resolve-promise-in-server-or-client-component \"Link for Should I resolve a Promise in a Server or Client Component? \")\n\nA Promise can be passed from a Server Component to a Client Component and resolved in the Client Component with the `use` API. You can also resolve the Promise in a Server Component with `await` and pass the required data to the Client Component as a prop.\n\n```\nexport default async function App() {const messageContent = await fetchMessage();return <Message messageContent={messageContent} />}\n```\n\nBut using `await` in a [Server Component](https://react.dev/reference/react/components#server-components) will block its rendering until the `await` statement is finished. Passing a Promise from a Server Component to a Client Component prevents the Promise from blocking the rendering of the Server Component.\n\n### Dealing with rejected Promises[](#dealing-with-rejected-promises \"Link for Dealing with rejected Promises \")\n\nIn some cases a Promise passed to `use` could be rejected. You can handle rejected Promises by either:\n\n1.  [Displaying an error to users with an error boundary.](#displaying-an-error-to-users-with-error-boundary)\n2.  [Providing an alternative value with `Promise.catch`](#providing-an-alternative-value-with-promise-catch)\n\n### Pitfall\n\n`use` cannot be called in a try-catch block. Instead of a try-catch block [wrap your component in an Error Boundary](#displaying-an-error-to-users-with-error-boundary), or [provide an alternative value to use with the Promise‚Äôs `.catch` method](#providing-an-alternative-value-with-promise-catch).\n\n#### Displaying an error to users with an error boundary[](#displaying-an-error-to-users-with-error-boundary \"Link for Displaying an error to users with an error boundary \")\n\nIf you‚Äôd like to display an error to your users when a Promise is rejected, you can use an [error boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary). To use an error boundary, wrap the component where you are calling the `use` API in an error boundary. If the Promise passed to `use` is rejected the fallback for the error boundary will be displayed.\n\n\"use client\";\n\nimport { use, Suspense } from \"react\";\nimport { ErrorBoundary } from \"react-error-boundary\";\n\nexport function MessageContainer({ messagePromise }) {\n  return (\n    <ErrorBoundary fallback\\={<p\\>‚ö†Ô∏èSomething went wrong</p\\>}\\>\n      <Suspense fallback\\={<p\\>‚åõDownloading message...</p\\>}\\>\n        <Message messagePromise\\={messagePromise} />\n      </Suspense\\>\n    </ErrorBoundary\\>\n  );\n}\n\nfunction Message({ messagePromise }) {\n  const content = use(messagePromise);\n  return <p\\>Here is the message: {content}</p\\>;\n}\n\n#### Providing an alternative value with `Promise.catch`[](#providing-an-alternative-value-with-promise-catch \"Link for this heading\")\n\nIf you‚Äôd like to provide an alternative value when the Promise passed to `use` is rejected you can use the Promise‚Äôs [`catch`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch) method.\n\n```\nimport { Message } from './message.js';export default function App() {const messagePromise = new Promise((resolve, reject) => {reject();}).catch(() => {return \"no new message found.\";});return (<Suspense fallback={<p>waiting for message...</p>}><Message messagePromise={messagePromise} /></Suspense>);}\n```\n\nTo use the Promise‚Äôs `catch` method, call `catch` on the Promise object. `catch` takes a single argument: a function that takes an error message as an argument. Whatever is returned by the function passed to `catch` will be used as the resolved value of the Promise.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### ‚ÄúSuspense Exception: This is not a real error!‚Äù[](#suspense-exception-error \"Link for ‚ÄúSuspense Exception: This is not a real error!‚Äù \")\n\nYou are either calling `use` outside of a React Component or Hook function, or calling `use` in a try‚Äìcatch block. If you are calling `use` inside a try‚Äìcatch block, wrap your component in an error boundary, or call the Promise‚Äôs `catch` to catch the error and resolve the Promise with another value. [See these examples](#dealing-with-rejected-promises).\n\nIf you are calling `use` outside a React Component or Hook function, move the `use` call to a React Component or Hook function.\n\n```\nfunction MessageComponent({messagePromise}) {function download() {// ‚ùå the function calling `use` is not a Component or Hookconst message = use(messagePromise);// ...\n```\n\nInstead, call `use` outside any component closures, where the function that calls `use` is a Component or Hook.\n\n```\nfunction MessageComponent({messagePromise}) {// ‚úÖ `use` is being called from a component. const message = use(messagePromise);// ...\n```",
  "title": "use ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/experimental_taintObjectReference",
  "markdown": "# experimental\\_taintObjectReference ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Under Construction\n\n**This API is experimental and is not available in a stable version of React yet.**\n\nYou can try it by upgrading React packages to the most recent experimental version:\n\n*   `react@experimental`\n*   `react-dom@experimental`\n*   `eslint-plugin-react-hooks@experimental`\n\nExperimental versions of React may contain bugs. Don‚Äôt use them in production.\n\nThis API is only available inside React Server Components.\n\n`taintObjectReference` lets you prevent a specific object instance from being passed to a Client Component like a `user` object.\n\n```\nexperimental_taintObjectReference(message, object);\n```\n\nTo prevent passing a key, hash or token, see [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue).\n\n*   [Reference](#reference)\n    *   [`taintObjectReference(message, object)`](#taintobjectreference)\n*   [Usage](#usage)\n    *   [Prevent user data from unintentionally reaching the client](#prevent-user-data-from-unintentionally-reaching-the-client)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `taintObjectReference(message, object)`[](#taintobjectreference \"Link for this heading\")\n\nCall `taintObjectReference` with an object to register it with React as something that should not be allowed to be passed to the Client as is:\n\n```\nimport {experimental_taintObjectReference} from 'react';experimental_taintObjectReference('Do not pass ALL environment variables to the client.',process.env);\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `message`: The message you want to display if the object gets passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if the object gets passed to a Client Component.\n    \n*   `object`: The object to be tainted. Functions and class instances can be passed to `taintObjectReference` as `object`. Functions and classes are already blocked from being passed to Client Components but the React‚Äôs default error message will be replaced by what you defined in `message`. When a specific instance of a Typed Array is passed to `taintObjectReference` as `object`, any other copies of the Typed Array will not be tainted.\n    \n\n#### Returns[](#returns \"Link for Returns \")\n\n`experimental_taintObjectReference` returns `undefined`.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   Recreating or cloning a tainted object creates a new untainted object which may contain sensitive data. For example, if you have a tainted `user` object, `const userInfo = {name: user.name, ssn: user.ssn}` or `{...user}` will create new objects which are not tainted. `taintObjectReference` only protects against simple mistakes when the object is passed through to a Client Component unchanged.\n\n### Pitfall\n\n**Do not rely on just tainting for security.** Tainting an object doesn‚Äôt prevent leaking of every possible derived value. For example, the clone of a tainted object will create a new untainted object. Using data from a tainted object (e.g. `{secret: taintedObj.secret}`) will create a new value or object that is not tainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Prevent user data from unintentionally reaching the client[](#prevent-user-data-from-unintentionally-reaching-the-client \"Link for Prevent user data from unintentionally reaching the client \")\n\nA Client Component should never accept objects that carry sensitive data. Ideally, the data fetching functions should not expose data that the current user should not have access to. Sometimes mistakes happen during refactoring. To protect against these mistakes happening down the line we can ‚Äútaint‚Äù the user object in our data API.\n\n```\nimport {experimental_taintObjectReference} from 'react';export async function getUser(id) {const user = await db`SELECT * FROM users WHERE id = ${id}`;experimental_taintObjectReference('Do not pass the entire user object to the client. ' +'Instead, pick off the specific properties you need for this use case.',user,);return user;}\n```\n\nNow whenever anyone tries to pass this object to a Client Component, an error will be thrown with the passed in error message instead.\n\n##### Deep Dive\n\n#### Protecting against leaks in data fetching[](#protecting-against-leaks-in-data-fetching \"Link for Protecting against leaks in data fetching \")\n\nIf you‚Äôre running a Server Components environment that has access to sensitive data, you have to be careful not to pass objects straight through:\n\n```\n// api.jsexport async function getUser(id) {const user = await db`SELECT * FROM users WHERE id = ${id}`;return user;}\n```\n\n```\nimport { getUser } from 'api.js';import { InfoCard } from 'components.js';export async function Profile(props) {const user = await getUser(props.userId);// DO NOT DO THISreturn <InfoCard user={user} />;}\n```\n\n```\n// components.js\"use client\";export async function InfoCard({ user }) {return <div>{user.name}</div>;}\n```\n\nIdeally, the `getUser` should not expose data that the current user should not have access to. To prevent passing the `user` object to a Client Component down the line we can ‚Äútaint‚Äù the user object:\n\n```\n// api.jsimport {experimental_taintObjectReference} from 'react';export async function getUser(id) {const user = await db`SELECT * FROM users WHERE id = ${id}`;experimental_taintObjectReference('Do not pass the entire user object to the client. ' +'Instead, pick off the specific properties you need for this use case.',user,);return user;}\n```\n\nNow if anyone tries to pass the `user` object to a Client Component, an error will be thrown with the passed in error message.",
  "title": "experimental_taintObjectReference ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/legacy",
  "markdown": "# Legacy React APIs ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\nThese APIs are exported from the `react` package, but they are not recommended for use in newly written code. See the linked individual API pages for the suggested alternatives.\n\n* * *\n\n## Legacy APIs[](#legacy-apis \"Link for Legacy APIs \")\n\n*   [`Children`](https://react.dev/reference/react/Children) lets you manipulate and transform the JSX received as the `children` prop. [See alternatives.](https://react.dev/reference/react/Children#alternatives)\n*   [`cloneElement`](https://react.dev/reference/react/cloneElement) lets you create a React element using another element as a starting point. [See alternatives.](https://react.dev/reference/react/cloneElement#alternatives)\n*   [`Component`](https://react.dev/reference/react/Component) lets you define a React component as a JavaScript class. [See alternatives.](https://react.dev/reference/react/Component#alternatives)\n*   [`createElement`](https://react.dev/reference/react/createElement) lets you create a React element. Typically, you‚Äôll use JSX instead.\n*   [`createRef`](https://react.dev/reference/react/createRef) creates a ref object which can contain arbitrary value. [See alternatives.](https://react.dev/reference/react/createRef#alternatives)\n*   [`isValidElement`](https://react.dev/reference/react/isValidElement) checks whether a value is a React element. Typically used with [`cloneElement`.](https://react.dev/reference/react/cloneElement)\n*   [`PureComponent`](https://react.dev/reference/react/PureComponent) is similar to [`Component`,](https://react.dev/reference/react/Component) but it skip re-renders with same props. [See alternatives.](https://react.dev/reference/react/PureComponent#alternatives)\n\n* * *\n\n## Deprecated APIs[](#deprecated-apis \"Link for Deprecated APIs \")\n\n### Deprecated\n\nThese APIs will be removed in a future major version of React.\n\n*   [`createFactory`](https://react.dev/reference/react/createFactory) lets you create a function that produces React elements of a certain type.",
  "title": "Legacy React APIs ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/experimental_taintUniqueValue",
  "markdown": "# experimental\\_taintUniqueValue ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Under Construction\n\n**This API is experimental and is not available in a stable version of React yet.**\n\nYou can try it by upgrading React packages to the most recent experimental version:\n\n*   `react@experimental`\n*   `react-dom@experimental`\n*   `eslint-plugin-react-hooks@experimental`\n\nExperimental versions of React may contain bugs. Don‚Äôt use them in production.\n\nThis API is only available inside [React Server Components](https://react.dev/reference/rsc/use-client).\n\n`taintUniqueValue` lets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.\n\n```\ntaintUniqueValue(errMessage, lifetime, value)\n```\n\nTo prevent passing an object containing sensitive data, see [`taintObjectReference`](https://react.dev/reference/react/experimental_taintObjectReference).\n\n*   [Reference](#reference)\n    *   [`taintUniqueValue(message, lifetime, value)`](#taintuniquevalue)\n*   [Usage](#usage)\n    *   [Prevent a token from being passed to Client Components](#prevent-a-token-from-being-passed-to-client-components)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `taintUniqueValue(message, lifetime, value)`[](#taintuniquevalue \"Link for this heading\")\n\nCall `taintUniqueValue` with a password, token, key or hash to register it with React as something that should not be allowed to be passed to the Client as is:\n\n```\nimport {experimental_taintUniqueValue} from 'react';experimental_taintUniqueValue('Do not pass secret keys to the client.',process,process.env.SECRET_KEY);\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `message`: The message you want to display if `value` is passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if `value` is passed to a Client Component.\n    \n*   `lifetime`: Any object that indicates how long `value` should be tainted. `value` will be blocked from being sent to any Client Component while this object still exists. For example, passing `globalThis` blocks the value for the lifetime of an app. `lifetime` is typically an object whose properties contains `value`.\n    \n*   `value`: A string, bigint or TypedArray. `value` must be a unique sequence of characters or bytes with high entropy such as a cryptographic token, private key, hash, or a long password. `value` will be blocked from being sent to any Client Component.\n    \n\n#### Returns[](#returns \"Link for Returns \")\n\n`experimental_taintUniqueValue` returns `undefined`.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   Deriving new values from tainted values can compromise tainting protection. New values created by uppercasing tainted values, concatenating tainted string values into a larger string, converting tainted values to base64, substringing tainted values, and other similar transformations are not tainted unless you explicitly call `taintUniqueValue` on these newly created values.\n*   Do not use `taintUniqueValue` to protect low-entropy values such as PIN codes or phone numbers. If any value in a request is controlled by an attacker, they could infer which value is tainted by enumerating all possible values of the secret.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Prevent a token from being passed to Client Components[](#prevent-a-token-from-being-passed-to-client-components \"Link for Prevent a token from being passed to Client Components \")\n\nTo ensure that sensitive information such as passwords, session tokens, or other unique values do not inadvertently get passed to Client Components, the `taintUniqueValue` function provides a layer of protection. When a value is tainted, any attempt to pass it to a Client Component will result in an error.\n\nThe `lifetime` argument defines the duration for which the value remains tainted. For values that should remain tainted indefinitely, objects like [`globalThis`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis) or `process` can serve as the `lifetime` argument. These objects have a lifespan that spans the entire duration of your app‚Äôs execution.\n\n```\nimport {experimental_taintUniqueValue} from 'react';experimental_taintUniqueValue('Do not pass a user password to the client.',globalThis,process.env.SECRET_KEY);\n```\n\nIf the tainted value‚Äôs lifespan is tied to a object, the `lifetime` should be the object that encapsulates the value. This ensures the tainted value remains protected for the lifetime of the encapsulating object.\n\n```\nimport {experimental_taintUniqueValue} from 'react';export async function getUser(id) {const user = await db`SELECT * FROM users WHERE id = ${id}`;experimental_taintUniqueValue('Do not pass a user session token to the client.',user,user.session.token);return user;}\n```\n\nIn this example, the `user` object serves as the `lifetime` argument. If this object gets stored in a global cache or is accessible by another request, the session token remains tainted.\n\n### Pitfall\n\n**Do not rely solely on tainting for security.** Tainting a value doesn‚Äôt block every possible derived value. For example, creating a new value by upper casing a tainted string will not taint the new value.\n\n```\nimport {experimental_taintUniqueValue} from 'react';const password = 'correct horse battery staple';experimental_taintUniqueValue('Do not pass the password to the client.',globalThis,password);const uppercasePassword = password.toUpperCase() // `uppercasePassword` is not tainted\n```\n\nIn this example, the constant `password` is tainted. Then `password` is used to create a new value `uppercasePassword` by calling the `toUpperCase` method on `password`. The newly created `uppercasePassword` is not tainted.\n\nOther similar ways of deriving new values from tainted values like concatenating it into a larger string, converting it to base64, or returning a substring create untained values.\n\nTainting only protects against simple mistakes like explicitly passing secret values to the client. Mistakes in calling the `taintUniqueValue` like using a global store outside of React, without the corresponding lifetime object, can cause the tainted value to become untainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns.\n\n##### Deep Dive\n\n#### Using `server-only` and `taintUniqueValue` to prevent leaking secrets[](#using-server-only-and-taintuniquevalue-to-prevent-leaking-secrets \"Link for this heading\")\n\nIf you‚Äôre running a Server Components environment that has access to private keys or passwords such as database passwords, you have to be careful not to pass that to a Client Component.\n\n```\nexport async function Dashboard(props) {// DO NOT DO THISreturn <Overview password={process.env.API_PASSWORD} />;}\n```\n\n```\n\"use client\";import {useEffect} from '...'export async function Overview({ password }) {useEffect(() => {const headers = { Authorization: password };fetch(url, { headers }).then(...);}, [password]);...}\n```\n\nThis example would leak the secret API token to the client. If this API token can be used to access data this particular user shouldn‚Äôt have access to, it could lead to a data breach.\n\nIdeally, secrets like this are abstracted into a single helper file that can only be imported by trusted data utilities on the server. The helper can even be tagged with [`server-only`](https://www.npmjs.com/package/server-only) to ensure that this file isn‚Äôt imported on the client.\n\n```\nimport \"server-only\";export function fetchAPI(url) {const headers = { Authorization: process.env.API_PASSWORD };return fetch(url, { headers });}\n```\n\nSometimes mistakes happen during refactoring and not all of your colleagues might know about this. To protect against this mistakes happening down the line we can ‚Äútaint‚Äù the actual password:\n\n```\nimport \"server-only\";import {experimental_taintUniqueValue} from 'react';experimental_taintUniqueValue('Do not pass the API token password to the client. ' +'Instead do all fetches on the server.'process,process.env.API_PASSWORD);\n```\n\nNow whenever anyone tries to pass this password to a Client Component, or send the password to a Client Component with a Server Action, an error will be thrown with message you defined when you called `taintUniqueValue`.\n\n* * *",
  "title": "experimental_taintUniqueValue ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/Children",
  "markdown": "# Children ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Pitfall\n\nUsing `Children` is uncommon and can lead to fragile code. [See common alternatives.](#alternatives)\n\n`Children` lets you manipulate and transform the JSX you received as the [`children` prop.](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)\n\n```\nconst mappedChildren = Children.map(children, child =><div className=\"Row\">{child}</div>);\n```\n\n*   [Reference](#reference)\n    *   [`Children.count(children)`](#children-count)\n    *   [`Children.forEach(children, fn, thisArg?)`](#children-foreach)\n    *   [`Children.map(children, fn, thisArg?)`](#children-map)\n    *   [`Children.only(children)`](#children-only)\n    *   [`Children.toArray(children)`](#children-toarray)\n*   [Usage](#usage)\n    *   [Transforming children](#transforming-children)\n    *   [Running some code for each child](#running-some-code-for-each-child)\n    *   [Counting children](#counting-children)\n    *   [Converting children to an array](#converting-children-to-an-array)\n*   [Alternatives](#alternatives)\n    *   [Exposing multiple components](#exposing-multiple-components)\n    *   [Accepting an array of objects as a prop](#accepting-an-array-of-objects-as-a-prop)\n    *   [Calling a render prop to customize rendering](#calling-a-render-prop-to-customize-rendering)\n*   [Troubleshooting](#troubleshooting)\n    *   [I pass a custom component, but the `Children` methods don‚Äôt show its render result](#i-pass-a-custom-component-but-the-children-methods-dont-show-its-render-result)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `Children.count(children)`[](#children-count \"Link for this heading\")\n\nCall `Children.count(children)` to count the number of children in the `children` data structure.\n\n```\nimport { Children } from 'react';function RowList({ children }) {return (<><h1>Total rows: {Children.count(children)}</h1>      ...</>);}\n```\n\n[See more examples below.](#counting-children)\n\n#### Parameters[](#children-count-parameters \"Link for Parameters \")\n\n*   `children`: The value of the [`children` prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.\n\n#### Returns[](#children-count-returns \"Link for Returns \")\n\nThe number of nodes inside these `children`.\n\n#### Caveats[](#children-count-caveats \"Link for Caveats \")\n\n*   Empty nodes (`null`, `undefined`, and Booleans), strings, numbers, and [React elements](https://react.dev/reference/react/createElement) count as individual nodes. Arrays don‚Äôt count as individual nodes, but their children do. **The traversal does not go deeper than React elements:** they don‚Äôt get rendered, and their children aren‚Äôt traversed. [Fragments](https://react.dev/reference/react/Fragment) don‚Äôt get traversed.\n\n* * *\n\n### `Children.forEach(children, fn, thisArg?)`[](#children-foreach \"Link for this heading\")\n\nCall `Children.forEach(children, fn, thisArg?)` to run some code for each child in the `children` data structure.\n\n```\nimport { Children } from 'react';function SeparatorList({ children }) {const result = [];Children.forEach(children, (child, index) => {result.push(child);result.push(<hr key={index} />);});// ...\n```\n\n[See more examples below.](#running-some-code-for-each-child)\n\n#### Parameters[](#children-foreach-parameters \"Link for Parameters \")\n\n*   `children`: The value of the [`children` prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.\n*   `fn`: The function you want to run for each child, similar to the [array `forEach` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) callback. It will be called with the child as the first argument and its index as the second argument. The index starts at `0` and increments on each call.\n*   **optional** `thisArg`: The [`this` value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) with which the `fn` function should be called. If omitted, it‚Äôs `undefined`.\n\n#### Returns[](#children-foreach-returns \"Link for Returns \")\n\n`Children.forEach` returns `undefined`.\n\n#### Caveats[](#children-foreach-caveats \"Link for Caveats \")\n\n*   Empty nodes (`null`, `undefined`, and Booleans), strings, numbers, and [React elements](https://react.dev/reference/react/createElement) count as individual nodes. Arrays don‚Äôt count as individual nodes, but their children do. **The traversal does not go deeper than React elements:** they don‚Äôt get rendered, and their children aren‚Äôt traversed. [Fragments](https://react.dev/reference/react/Fragment) don‚Äôt get traversed.\n\n* * *\n\n### `Children.map(children, fn, thisArg?)`[](#children-map \"Link for this heading\")\n\nCall `Children.map(children, fn, thisArg?)` to map or transform each child in the `children` data structure.\n\n```\nimport { Children } from 'react';function RowList({ children }) {return (<div className=\"RowList\">{Children.map(children, child =><div className=\"Row\">{child}</div>)}</div>);}\n```\n\n[See more examples below.](#transforming-children)\n\n#### Parameters[](#children-map-parameters \"Link for Parameters \")\n\n*   `children`: The value of the [`children` prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.\n*   `fn`: The mapping function, similar to the [array `map` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) callback. It will be called with the child as the first argument and its index as the second argument. The index starts at `0` and increments on each call. You need to return a React node from this function. This may be an empty node (`null`, `undefined`, or a Boolean), a string, a number, a React element, or an array of other React nodes.\n*   **optional** `thisArg`: The [`this` value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) with which the `fn` function should be called. If omitted, it‚Äôs `undefined`.\n\n#### Returns[](#children-map-returns \"Link for Returns \")\n\nIf `children` is `null` or `undefined`, returns the same value.\n\nOtherwise, returns a flat array consisting of the nodes you‚Äôve returned from the `fn` function. The returned array will contain all nodes you returned except for `null` and `undefined`.\n\n#### Caveats[](#children-map-caveats \"Link for Caveats \")\n\n*   Empty nodes (`null`, `undefined`, and Booleans), strings, numbers, and [React elements](https://react.dev/reference/react/createElement) count as individual nodes. Arrays don‚Äôt count as individual nodes, but their children do. **The traversal does not go deeper than React elements:** they don‚Äôt get rendered, and their children aren‚Äôt traversed. [Fragments](https://react.dev/reference/react/Fragment) don‚Äôt get traversed.\n    \n*   If you return an element or an array of elements with keys from `fn`, **the returned elements‚Äô keys will be automatically combined with the key of the corresponding original item from `children`.** When you return multiple elements from `fn` in an array, their keys only need to be unique locally amongst each other.\n    \n\n* * *\n\n### `Children.only(children)`[](#children-only \"Link for this heading\")\n\nCall `Children.only(children)` to assert that `children` represent a single React element.\n\n```\nfunction Box({ children }) {const element = Children.only(children);// ...\n```\n\n#### Parameters[](#children-only-parameters \"Link for Parameters \")\n\n*   `children`: The value of the [`children` prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.\n\n#### Returns[](#children-only-returns \"Link for Returns \")\n\nIf `children` [is a valid element,](https://react.dev/reference/react/isValidElement) returns that element.\n\nOtherwise, throws an error.\n\n#### Caveats[](#children-only-caveats \"Link for Caveats \")\n\n*   This method always **throws if you pass an array (such as the return value of `Children.map`) as `children`.** In other words, it enforces that `children` is a single React element, not that it‚Äôs an array with a single element.\n\n* * *\n\n### `Children.toArray(children)`[](#children-toarray \"Link for this heading\")\n\nCall `Children.toArray(children)` to create an array out of the `children` data structure.\n\n```\nimport { Children } from 'react';export default function ReversedList({ children }) {const result = Children.toArray(children);result.reverse();// ...\n```\n\n#### Parameters[](#children-toarray-parameters \"Link for Parameters \")\n\n*   `children`: The value of the [`children` prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.\n\n#### Returns[](#children-toarray-returns \"Link for Returns \")\n\nReturns a flat array of elements in `children`.\n\n#### Caveats[](#children-toarray-caveats \"Link for Caveats \")\n\n*   Empty nodes (`null`, `undefined`, and Booleans) will be omitted in the returned array. **The returned elements‚Äô keys will be calculated from the original elements‚Äô keys and their level of nesting and position.** This ensures that flattening the array does not introduce changes in behavior.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Transforming children[](#transforming-children \"Link for Transforming children \")\n\nTo transform the children JSX that your component [receives as the `children` prop,](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) call `Children.map`:\n\n```\nimport { Children } from 'react';function RowList({ children }) {return (<div className=\"RowList\">{Children.map(children, child =><div className=\"Row\">{child}</div>)}</div>);}\n```\n\nIn the example above, the `RowList` wraps every child it receives into a `<div className=\"Row\">` container. For example, let‚Äôs say the parent component passes three `<p>` tags as the `children` prop to `RowList`:\n\n```\n<RowList><p>This is the first item.</p><p>This is the second item.</p><p>This is the third item.</p></RowList>\n```\n\nThen, with the `RowList` implementation above, the final rendered result will look like this:\n\n```\n<div className=\"RowList\"><div className=\"Row\"><p>This is the first item.</p></div><div className=\"Row\"><p>This is the second item.</p></div><div className=\"Row\"><p>This is the third item.</p></div></div>\n```\n\n`Children.map` is similar to [to transforming arrays with `map()`.](https://react.dev/learn/rendering-lists) The difference is that the `children` data structure is considered _opaque._ This means that even if it‚Äôs sometimes an array, you should not assume it‚Äôs an array or any other particular data type. This is why you should use `Children.map` if you need to transform it.\n\n##### Deep Dive\n\n#### Why is the children prop not always an array?[](#why-is-the-children-prop-not-always-an-array \"Link for Why is the children prop not always an array? \")\n\nIn React, the `children` prop is considered an _opaque_ data structure. This means that you shouldn‚Äôt rely on how it is structured. To transform, filter, or count children, you should use the `Children` methods.\n\nIn practice, the `children` data structure is often represented as an array internally. However, if there is only a single child, then React won‚Äôt create an extra array since this would lead to unnecessary memory overhead. As long as you use the `Children` methods instead of directly introspecting the `children` prop, your code will not break even if React changes how the data structure is actually implemented.\n\nEven when `children` is an array, `Children.map` has useful special behavior. For example, `Children.map` combines the [keys](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) on the returned elements with the keys on the `children` you‚Äôve passed to it. This ensures the original JSX children don‚Äôt ‚Äúlose‚Äù keys even if they get wrapped like in the example above.\n\n### Pitfall\n\nThe `children` data structure **does not include rendered output** of the components you pass as JSX. In the example below, the `children` received by the `RowList` only contains two items rather than three:\n\n1.  `<p>This is the first item.</p>`\n2.  `<MoreRows />`\n\nThis is why only two row wrappers are generated in this example:\n\nimport RowList from './RowList.js';\n\nexport default function App() {\n  return (\n    <RowList\\>\n      <p\\>This is the first item.</p\\>\n      <MoreRows />\n    </RowList\\>\n  );\n}\n\nfunction MoreRows() {\n  return (\n    <\\>\n      <p\\>This is the second item.</p\\>\n      <p\\>This is the third item.</p\\>\n    </\\>\n  );\n}\n\n**There is no way to get the rendered output of an inner component** like `<MoreRows />` when manipulating `children`. This is why [it‚Äôs usually better to use one of the alternative solutions.](#alternatives)\n\n* * *\n\n### Running some code for each child[](#running-some-code-for-each-child \"Link for Running some code for each child \")\n\nCall `Children.forEach` to iterate over each child in the `children` data structure. It does not return any value and is similar to the [array `forEach` method.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) You can use it to run custom logic like constructing your own array.\n\n### Pitfall\n\nAs mentioned earlier, there is no way to get the rendered output of an inner component when manipulating `children`. This is why [it‚Äôs usually better to use one of the alternative solutions.](#alternatives)\n\n* * *\n\n### Counting children[](#counting-children \"Link for Counting children \")\n\nCall `Children.count(children)` to calculate the number of children.\n\nimport { Children } from 'react';\n\nexport default function RowList({ children }) {\n  return (\n    <div className\\=\"RowList\"\\>\n      <h1 className\\=\"RowListHeader\"\\>\n        Total rows: {Children.count(children)}\n      </h1\\>\n      {Children.map(children, child \\=>\n        <div className\\=\"Row\"\\>\n          {child}\n        </div\\>\n      )}\n    </div\\>\n  );\n}\n\n### Pitfall\n\nAs mentioned earlier, there is no way to get the rendered output of an inner component when manipulating `children`. This is why [it‚Äôs usually better to use one of the alternative solutions.](#alternatives)\n\n* * *\n\n### Converting children to an array[](#converting-children-to-an-array \"Link for Converting children to an array \")\n\nCall `Children.toArray(children)` to turn the `children` data structure into a regular JavaScript array. This lets you manipulate the array with built-in array methods like [`filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter), [`sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort), or [`reverse`.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)\n\n### Pitfall\n\nAs mentioned earlier, there is no way to get the rendered output of an inner component when manipulating `children`. This is why [it‚Äôs usually better to use one of the alternative solutions.](#alternatives)\n\n* * *\n\n## Alternatives[](#alternatives \"Link for Alternatives \")\n\n### Note\n\nThis section describes alternatives to the `Children` API (with capital `C`) that‚Äôs imported like this:\n\n```\nimport { Children } from 'react';\n```\n\nDon‚Äôt confuse it with [using the `children` prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) (lowercase `c`), which is good and encouraged.\n\n### Exposing multiple components[](#exposing-multiple-components \"Link for Exposing multiple components \")\n\nManipulating children with the `Children` methods often leads to fragile code. When you pass children to a component in JSX, you don‚Äôt usually expect the component to manipulate or transform the individual children.\n\nWhen you can, try to avoid using the `Children` methods. For example, if you want every child of `RowList` to be wrapped in `<div className=\"Row\">`, export a `Row` component, and manually wrap every row into it like this:\n\nimport { RowList, Row } from './RowList.js';\n\nexport default function App() {\n  return (\n    <RowList\\>\n      <Row\\>\n        <p\\>This is the first item.</p\\>\n      </Row\\>\n      <Row\\>\n        <p\\>This is the second item.</p\\>\n      </Row\\>\n      <Row\\>\n        <p\\>This is the third item.</p\\>\n      </Row\\>\n    </RowList\\>\n  );\n}\n\nUnlike using `Children.map`, this approach does not wrap every child automatically. **However, this approach has a significant benefit compared to the [earlier example with `Children.map`](#transforming-children) because it works even if you keep extracting more components.** For example, it still works if you extract your own `MoreRows` component:\n\nimport { RowList, Row } from './RowList.js';\n\nexport default function App() {\n  return (\n    <RowList\\>\n      <Row\\>\n        <p\\>This is the first item.</p\\>\n      </Row\\>\n      <MoreRows />\n    </RowList\\>\n  );\n}\n\nfunction MoreRows() {\n  return (\n    <\\>\n      <Row\\>\n        <p\\>This is the second item.</p\\>\n      </Row\\>\n      <Row\\>\n        <p\\>This is the third item.</p\\>\n      </Row\\>\n    </\\>\n  );\n}\n\nThis wouldn‚Äôt work with `Children.map` because it would ‚Äúsee‚Äù `<MoreRows />` as a single child (and a single row).\n\n* * *\n\n### Accepting an array of objects as a prop[](#accepting-an-array-of-objects-as-a-prop \"Link for Accepting an array of objects as a prop \")\n\nYou can also explicitly pass an array as a prop. For example, this `RowList` accepts a `rows` array as a prop:\n\nSince `rows` is a regular JavaScript array, the `RowList` component can use built-in array methods like [`map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) on it.\n\nThis pattern is especially useful when you want to be able to pass more information as structured data together with children. In the below example, the `TabSwitcher` component receives an array of objects as the `tabs` prop:\n\nimport TabSwitcher from './TabSwitcher.js';\n\nexport default function App() {\n  return (\n    <TabSwitcher tabs\\={\\[\n      {\n        id: 'first',\n        header: 'First',\n        content: <p\\>This is the first item.</p\\>\n      },\n      {\n        id: 'second',\n        header: 'Second',\n        content: <p\\>This is the second item.</p\\>\n      },\n      {\n        id: 'third',\n        header: 'Third',\n        content: <p\\>This is the third item.</p\\>\n      }\n    \\]} />\n  );\n}\n\nUnlike passing the children as JSX, this approach lets you associate some extra data like `header` with each item. Because you are working with the `tabs` directly, and it is an array, you do not need the `Children` methods.\n\n* * *\n\n### Calling a render prop to customize rendering[](#calling-a-render-prop-to-customize-rendering \"Link for Calling a render prop to customize rendering \")\n\nInstead of producing JSX for every single item, you can also pass a function that returns JSX, and call that function when necessary. In this example, the `App` component passes a `renderContent` function to the `TabSwitcher` component. The `TabSwitcher` component calls `renderContent` only for the selected tab:\n\nA prop like `renderContent` is called a _render prop_ because it is a prop that specifies how to render a piece of the user interface. However, there is nothing special about it: it is a regular prop which happens to be a function.\n\nRender props are functions, so you can pass information to them. For example, this `RowList` component passes the `id` and the `index` of each row to the `renderRow` render prop, which uses `index` to highlight even rows:\n\nimport { RowList, Row } from './RowList.js';\n\nexport default function App() {\n  return (\n    <RowList\n      rowIds\\={\\['first', 'second', 'third'\\]}\n      renderRow\\={(id, index) \\=> {\n        return (\n          <Row isHighlighted\\={index % 2 === 0}\\>\n            <p\\>This is the {id} item.</p\\>\n          </Row\\> \n        );\n      }}\n    />\n  );\n}\n\nThis is another example of how parent and child components can cooperate without manipulating the children.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### I pass a custom component, but the `Children` methods don‚Äôt show its render result[](#i-pass-a-custom-component-but-the-children-methods-dont-show-its-render-result \"Link for this heading\")\n\nSuppose you pass two children to `RowList` like this:\n\n```\n<RowList><p>First item</p><MoreRows /></RowList>\n```\n\nIf you do `Children.count(children)` inside `RowList`, you will get `2`. Even if `MoreRows` renders 10 different items, or if it returns `null`, `Children.count(children)` will still be `2`. From the `RowList`‚Äôs perspective, it only ‚Äúsees‚Äù the JSX it has received. It does not ‚Äúsee‚Äù the internals of the `MoreRows` component.\n\nThe limitation makes it hard to extract a component. This is why [alternatives](#alternatives) are preferred to using `Children`.",
  "title": "Children ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/cloneElement",
  "markdown": "# cloneElement ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Pitfall\n\nUsing `cloneElement` is uncommon and can lead to fragile code. [See common alternatives.](#alternatives)\n\n`cloneElement` lets you create a new React element using another element as a starting point.\n\n```\nconst clonedElement = cloneElement(element, props, ...children)\n```\n\n*   [Reference](#reference)\n    *   [`cloneElement(element, props, ...children)`](#cloneelement)\n*   [Usage](#usage)\n    *   [Overriding props of an element](#overriding-props-of-an-element)\n*   [Alternatives](#alternatives)\n    *   [Passing data with a render prop](#passing-data-with-a-render-prop)\n    *   [Passing data through context](#passing-data-through-context)\n    *   [Extracting logic into a custom Hook](#extracting-logic-into-a-custom-hook)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `cloneElement(element, props, ...children)`[](#cloneelement \"Link for this heading\")\n\nCall `cloneElement` to create a React element based on the `element`, but with different `props` and `children`:\n\n```\nimport { cloneElement } from 'react';// ...const clonedElement = cloneElement(<Row title=\"Cabbage\">    Hello</Row>,{ isHighlighted: true },'Goodbye');console.log(clonedElement); // <Row title=\"Cabbage\" isHighlighted={true}>Goodbye</Row>\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `element`: The `element` argument must be a valid React element. For example, it could be a JSX node like `<Something />`, the result of calling [`createElement`](https://react.dev/reference/react/createElement), or the result of another `cloneElement` call.\n    \n*   `props`: The `props` argument must either be an object or `null`. If you pass `null`, the cloned element will retain all of the original `element.props`. Otherwise, for every prop in the `props` object, the returned element will ‚Äúprefer‚Äù the value from `props` over the value from `element.props`. The rest of the props will be filled from the original `element.props`. If you pass `props.key` or `props.ref`, they will replace the original ones.\n    \n*   **optional** `...children`: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers, [portals](https://react.dev/reference/react-dom/createPortal), empty nodes (`null`, `undefined`, `true`, and `false`), and arrays of React nodes. If you don‚Äôt pass any `...children` arguments, the original `element.props.children` will be preserved.\n    \n\n#### Returns[](#returns \"Link for Returns \")\n\n`cloneElement` returns a React element object with a few properties:\n\n*   `type`: Same as `element.type`.\n*   `props`: The result of shallowly merging `element.props` with the overriding `props` you have passed.\n*   `ref`: The original `element.ref`, unless it was overridden by `props.ref`.\n*   `key`: The original `element.key`, unless it was overridden by `props.key`.\n\nUsually, you‚Äôll return the element from your component or make it a child of another element. Although you may read the element‚Äôs properties, it‚Äôs best to treat every element as opaque after it‚Äôs created, and only render it.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   Cloning an element **does not modify the original element.**\n    \n*   You should only **pass children as multiple arguments to `cloneElement` if they are all statically known,** like `cloneElement(element, null, child1, child2, child3)`. If your children are dynamic, pass the entire array as the third argument: `cloneElement(element, null, listItems)`. This ensures that React will [warn you about missing `key`s](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) for any dynamic lists. For static lists this is not necessary because they never reorder.\n    \n*   `cloneElement` makes it harder to trace the data flow, so **try the [alternatives](#alternatives) instead.**\n    \n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Overriding props of an element[](#overriding-props-of-an-element \"Link for Overriding props of an element \")\n\nTo override the props of some React element, pass it to `cloneElement` with the props you want to override:\n\n```\nimport { cloneElement } from 'react';// ...const clonedElement = cloneElement(<Row title=\"Cabbage\" />,{ isHighlighted: true });\n```\n\nHere, the resulting cloned element will be `<Row title=\"Cabbage\" isHighlighted={true} />`.\n\n**Let‚Äôs walk through an example to see when it‚Äôs useful.**\n\nImagine a `List` component that renders its [`children`](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) as a list of selectable rows with a ‚ÄúNext‚Äù button that changes which row is selected. The `List` component needs to render the selected `Row` differently, so it clones every `<Row>` child that it has received, and adds an extra `isHighlighted: true` or `isHighlighted: false` prop:\n\n```\nexport default function List({ children }) {const [selectedIndex, setSelectedIndex] = useState(0);return (<div className=\"List\">{Children.map(children, (child, index) =>cloneElement(child, {isHighlighted: index === selectedIndex }))}\n```\n\nLet‚Äôs say the original JSX received by `List` looks like this:\n\n```\n<List><Row title=\"Cabbage\" /><Row title=\"Garlic\" /><Row title=\"Apple\" /></List>\n```\n\nBy cloning its children, the `List` can pass extra information to every `Row` inside. The result looks like this:\n\n```\n<List><Rowtitle=\"Cabbage\"isHighlighted={true} /><Rowtitle=\"Garlic\"isHighlighted={false} /><Rowtitle=\"Apple\"isHighlighted={false} /></List>\n```\n\nNotice how pressing ‚ÄúNext‚Äù updates the state of the `List`, and highlights a different row:\n\nimport { Children, cloneElement, useState } from 'react';\n\nexport default function List({ children }) {\n  const \\[selectedIndex, setSelectedIndex\\] = useState(0);\n  return (\n    <div className\\=\"List\"\\>\n      {Children.map(children, (child, index) \\=>\n        cloneElement(child, {\n          isHighlighted: index === selectedIndex \n        })\n      )}\n      <hr />\n      <button onClick\\={() \\=> {\n        setSelectedIndex(i \\=>\n          (i + 1) % Children.count(children)\n        );\n      }}\\>\n        Next\n      </button\\>\n    </div\\>\n  );\n}\n\nTo summarize, the `List` cloned the `<Row />` elements it received and added an extra prop to them.\n\n### Pitfall\n\nCloning children makes it hard to tell how the data flows through your app. Try one of the [alternatives.](#alternatives)\n\n* * *\n\n## Alternatives[](#alternatives \"Link for Alternatives \")\n\n### Passing data with a render prop[](#passing-data-with-a-render-prop \"Link for Passing data with a render prop \")\n\nInstead of using `cloneElement`, consider accepting a _render prop_ like `renderItem`. Here, `List` receives `renderItem` as a prop. `List` calls `renderItem` for every item and passes `isHighlighted` as an argument:\n\n```\nexport default function List({ items, renderItem }) {const [selectedIndex, setSelectedIndex] = useState(0);return (<div className=\"List\">{items.map((item, index) => {const isHighlighted = index === selectedIndex;return renderItem(item, isHighlighted);})}\n```\n\nThe `renderItem` prop is called a ‚Äúrender prop‚Äù because it‚Äôs a prop that specifies how to render something. For example, you can pass a `renderItem` implementation that renders a `<Row>` with the given `isHighlighted` value:\n\n```\n<Listitems={products}renderItem={(product, isHighlighted) =><Rowkey={product.id}title={product.title}isHighlighted={isHighlighted}/>}/>\n```\n\nThe end result is the same as with `cloneElement`:\n\n```\n<List><Rowtitle=\"Cabbage\"isHighlighted={true} /><Rowtitle=\"Garlic\"isHighlighted={false} /><Rowtitle=\"Apple\"isHighlighted={false} /></List>\n```\n\nHowever, you can clearly trace where the `isHighlighted` value is coming from.\n\nimport { useState } from 'react';\n\nexport default function List({ items, renderItem }) {\n  const \\[selectedIndex, setSelectedIndex\\] = useState(0);\n  return (\n    <div className\\=\"List\"\\>\n      {items.map((item, index) \\=> {\n        const isHighlighted = index === selectedIndex;\n        return renderItem(item, isHighlighted);\n      })}\n      <hr />\n      <button onClick\\={() \\=> {\n        setSelectedIndex(i \\=>\n          (i + 1) % items.length\n        );\n      }}\\>\n        Next\n      </button\\>\n    </div\\>\n  );\n}\n\nThis pattern is preferred to `cloneElement` because it is more explicit.\n\n* * *\n\n### Passing data through context[](#passing-data-through-context \"Link for Passing data through context \")\n\nAnother alternative to `cloneElement` is to [pass data through context.](https://react.dev/learn/passing-data-deeply-with-context)\n\nFor example, you can call [`createContext`](https://react.dev/reference/react/createContext) to define a `HighlightContext`:\n\n```\nexport const HighlightContext = createContext(false);\n```\n\nYour `List` component can wrap every item it renders into a `HighlightContext` provider:\n\n```\nexport default function List({ items, renderItem }) {const [selectedIndex, setSelectedIndex] = useState(0);return (<div className=\"List\">{items.map((item, index) => {const isHighlighted = index === selectedIndex;return (<HighlightContext.Provider key={item.id} value={isHighlighted}>{renderItem(item)}</HighlightContext.Provider>);})}\n```\n\nWith this approach, `Row` does not need to receive an `isHighlighted` prop at all. Instead, it reads the context:\n\n```\nexport default function Row({ title }) {const isHighlighted = useContext(HighlightContext);// ...\n```\n\nThis allows the calling component to not know or worry about passing `isHighlighted` to `<Row>`:\n\n```\n<Listitems={products}renderItem={product =><Row title={product.title} />}/>\n```\n\nInstead, `List` and `Row` coordinate the highlighting logic through context.\n\nimport { useState } from 'react';\nimport { HighlightContext } from './HighlightContext.js';\n\nexport default function List({ items, renderItem }) {\n  const \\[selectedIndex, setSelectedIndex\\] = useState(0);\n  return (\n    <div className\\=\"List\"\\>\n      {items.map((item, index) \\=> {\n        const isHighlighted = index === selectedIndex;\n        return (\n          <HighlightContext.Provider\n            key\\={item.id}\n            value\\={isHighlighted}\n          \\>\n            {renderItem(item)}\n          </HighlightContext.Provider\\>\n        );\n      })}\n      <hr />\n      <button onClick\\={() \\=> {\n        setSelectedIndex(i \\=>\n          (i + 1) % items.length\n        );\n      }}\\>\n        Next\n      </button\\>\n    </div\\>\n  );\n}\n\n[Learn more about passing data through context.](https://react.dev/reference/react/useContext#passing-data-deeply-into-the-tree)\n\n* * *\n\nAnother approach you can try is to extract the ‚Äúnon-visual‚Äù logic into your own Hook, and use the information returned by your Hook to decide what to render. For example, you could write a `useList` custom Hook like this:\n\n```\nimport { useState } from 'react';export default function useList(items) {const [selectedIndex, setSelectedIndex] = useState(0);function onNext() {setSelectedIndex(i =>(i + 1) % items.length);}const selected = items[selectedIndex];return [selected, onNext];}\n```\n\nThen you could use it like this:\n\n```\nexport default function App() {const [selected, onNext] = useList(products);return (<div className=\"List\">{products.map(product =><Rowkey={product.id}title={product.title}isHighlighted={selected === product}/>)}<hr /><button onClick={onNext}>        Next</button></div>);}\n```\n\nThe data flow is explicit, but the state is inside the `useList` custom Hook that you can use from any component:\n\nimport Row from './Row.js';\nimport useList from './useList.js';\nimport { products } from './data.js';\n\nexport default function App() {\n  const \\[selected, onNext\\] = useList(products);\n  return (\n    <div className\\=\"List\"\\>\n      {products.map(product \\=>\n        <Row\n          key\\={product.id}\n          title\\={product.title}\n          isHighlighted\\={selected === product}\n        />\n      )}\n      <hr />\n      <button onClick\\={onNext}\\>\n        Next\n      </button\\>\n    </div\\>\n  );\n}\n\nThis approach is particularly useful if you want to reuse this logic between different components.",
  "title": "cloneElement ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/Component",
  "markdown": "# Component ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Pitfall\n\nWe recommend defining components as functions instead of classes. [See how to migrate.](#alternatives)\n\n`Component` is the base class for the React components defined as [JavaScript classes.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) Class components are still supported by React, but we don‚Äôt recommend using them in new code.\n\n```\nclass Greeting extends Component {render() {return <h1>Hello, {this.props.name}!</h1>;}}\n```\n\n*   [Reference](#reference)\n    *   [`Component`](#component)\n    *   [`context`](#context)\n    *   [`props`](#props)\n    *   [`refs`](#refs)\n    *   [`state`](#state)\n    *   [`constructor(props)`](#constructor)\n    *   [`componentDidCatch(error, info)`](#componentdidcatch)\n    *   [`componentDidMount()`](#componentdidmount)\n    *   [`componentDidUpdate(prevProps, prevState, snapshot?)`](#componentdidupdate)\n    *   [`componentWillMount()`](#componentwillmount)\n    *   [`componentWillReceiveProps(nextProps)`](#componentwillreceiveprops)\n    *   [`componentWillUpdate(nextProps, nextState)`](#componentwillupdate)\n    *   [`componentWillUnmount()`](#componentwillunmount)\n    *   [`forceUpdate(callback?)`](#forceupdate)\n    *   [`getChildContext()`](#getchildcontext)\n    *   [`getSnapshotBeforeUpdate(prevProps, prevState)`](#getsnapshotbeforeupdate)\n    *   [`render()`](#render)\n    *   [`setState(nextState, callback?)`](#setstate)\n    *   [`shouldComponentUpdate(nextProps, nextState, nextContext)`](#shouldcomponentupdate)\n    *   [`UNSAFE_componentWillMount()`](#unsafe_componentwillmount)\n    *   [`UNSAFE_componentWillReceiveProps(nextProps, nextContext)`](#unsafe_componentwillreceiveprops)\n    *   [`UNSAFE_componentWillUpdate(nextProps, nextState)`](#unsafe_componentwillupdate)\n    *   [`static childContextTypes`](#static-childcontexttypes)\n    *   [`static contextTypes`](#static-contexttypes)\n    *   [`static contextType`](#static-contexttype)\n    *   [`static defaultProps`](#static-defaultprops)\n    *   [`static propTypes`](#static-proptypes)\n    *   [`static getDerivedStateFromError(error)`](#static-getderivedstatefromerror)\n    *   [`static getDerivedStateFromProps(props, state)`](#static-getderivedstatefromprops)\n*   [Usage](#usage)\n    *   [Defining a class component](#defining-a-class-component)\n    *   [Adding state to a class component](#adding-state-to-a-class-component)\n    *   [Adding lifecycle methods to a class component](#adding-lifecycle-methods-to-a-class-component)\n    *   [Catching rendering errors with an error boundary](#catching-rendering-errors-with-an-error-boundary)\n*   [Alternatives](#alternatives)\n    *   [Migrating a simple component from a class to a function](#migrating-a-simple-component-from-a-class-to-a-function)\n    *   [Migrating a component with state from a class to a function](#migrating-a-component-with-state-from-a-class-to-a-function)\n    *   [Migrating a component with lifecycle methods from a class to a function](#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)\n    *   [Migrating a component with context from a class to a function](#migrating-a-component-with-context-from-a-class-to-a-function)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `Component`[](#component \"Link for this heading\")\n\nTo define a React component as a class, extend the built-in `Component` class and define a [`render` method:](#render)\n\n```\nimport { Component } from 'react';class Greeting extends Component {render() {return <h1>Hello, {this.props.name}!</h1>;}}\n```\n\nOnly the `render` method is required, other methods are optional.\n\n[See more examples below.](#usage)\n\n* * *\n\n### `context`[](#context \"Link for this heading\")\n\nThe [context](https://react.dev/learn/passing-data-deeply-with-context) of a class component is available as `this.context`. It is only available if you specify _which_ context you want to receive using [`static contextType`](#static-contexttype) (modern) or [`static contextTypes`](#static-contexttypes) (deprecated).\n\nA class component can only read one context at a time.\n\n```\nclass Button extends Component {static contextType = ThemeContext;render() {const theme = this.context;const className = 'button-' + theme;return (<button className={className}>{this.props.children}</button>);}}\n```\n\n### Note\n\nReading `this.context` in class components is equivalent to [`useContext`](https://react.dev/reference/react/useContext) in function components.\n\n[See how to migrate.](#migrating-a-component-with-context-from-a-class-to-a-function)\n\n* * *\n\n### `props`[](#props \"Link for this heading\")\n\nThe props passed to a class component are available as `this.props`.\n\n```\nclass Greeting extends Component {render() {return <h1>Hello, {this.props.name}!</h1>;}}<Greeting name=\"Taylor\" />\n```\n\n### Note\n\nReading `this.props` in class components is equivalent to [declaring props](https://react.dev/learn/passing-props-to-a-component#step-2-read-props-inside-the-child-component) in function components.\n\n[See how to migrate.](#migrating-a-simple-component-from-a-class-to-a-function)\n\n* * *\n\n### `refs`[](#refs \"Link for this heading\")\n\n### Deprecated\n\nLets you access [legacy string refs](https://reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs) for this component.\n\n* * *\n\n### `state`[](#state \"Link for this heading\")\n\nThe state of a class component is available as `this.state`. The `state` field must be an object. Do not mutate the state directly. If you wish to change the state, call `setState` with the new state.\n\n```\nclass Counter extends Component {state = {age: 42,};handleAgeChange = () => {this.setState({age: this.state.age + 1 });};render() {return (<><button onClick={this.handleAgeChange}>        Increment age</button><p>You are {this.state.age}.</p></>);}}\n```\n\n### Note\n\nDefining `state` in class components is equivalent to calling [`useState`](https://react.dev/reference/react/useState) in function components.\n\n[See how to migrate.](#migrating-a-component-with-state-from-a-class-to-a-function)\n\n* * *\n\n### `constructor(props)`[](#constructor \"Link for this heading\")\n\nThe [constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor) runs before your class component _mounts_ (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and [bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind) your class methods to the class instance:\n\n```\nclass Counter extends Component {constructor(props) {super(props);this.state = { counter: 0 };this.handleClick = this.handleClick.bind(this);}handleClick() {// ...}\n```\n\nIf you use modern JavaScript syntax, constructors are rarely needed. Instead, you can rewrite this code above using the [public class field syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields) which is supported both by modern browsers and tools like [Babel:](https://babeljs.io/)\n\n```\nclass Counter extends Component {state = { counter: 0 };handleClick = () => {// ...}\n```\n\nA constructor should not contain any side effects or subscriptions.\n\n#### Parameters[](#constructor-parameters \"Link for Parameters \")\n\n*   `props`: The component‚Äôs initial props.\n\n#### Returns[](#constructor-returns \"Link for Returns \")\n\n`constructor` should not return anything.\n\n#### Caveats[](#constructor-caveats \"Link for Caveats \")\n\n*   Do not run any side effects or subscriptions in the constructor. Instead, use [`componentDidMount`](#componentdidmount) for that.\n    \n*   Inside a constructor, you need to call `super(props)` before any other statement. If you don‚Äôt do that, `this.props` will be `undefined` while the constructor runs, which can be confusing and cause bugs.\n    \n*   Constructor is the only place where you can assign [`this.state`](#state) directly. In all other methods, you need to use [`this.setState()`](#setstate) instead. Do not call `setState` in the constructor.\n    \n*   When you use [server rendering,](https://react.dev/reference/react-dom/server) the constructor will run on the server too, followed by the [`render`](#render) method. However, lifecycle methods like `componentDidMount` or `componentWillUnmount` will not run on the server.\n    \n*   When [Strict Mode](https://react.dev/reference/react/StrictMode) is on, React will call `constructor` twice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of the `constructor`.\n    \n\n### Note\n\nThere is no exact equivalent for `constructor` in function components. To declare state in a function component, call [`useState`.](https://react.dev/reference/react/useState) To avoid recalculating the initial state, [pass a function to `useState`.](https://react.dev/reference/react/useState#avoiding-recreating-the-initial-state)\n\n* * *\n\n### `componentDidCatch(error, info)`[](#componentdidcatch \"Link for this heading\")\n\nIf you define `componentDidCatch`, React will call it when some child component (including distant children) throws an error during rendering. This lets you log that error to an error reporting service in production.\n\nTypically, it is used together with [`static getDerivedStateFromError`](#static-getderivedstatefromerror) which lets you update state in response to an error and display an error message to the user. A component with these methods is called an _error boundary._\n\n[See an example.](#catching-rendering-errors-with-an-error-boundary)\n\n#### Parameters[](#componentdidcatch-parameters \"Link for Parameters \")\n\n*   `error`: The error that was thrown. In practice, it will usually be an instance of [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) but this is not guaranteed because JavaScript allows to [`throw`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw) any value, including strings or even `null`.\n    \n*   `info`: An object containing additional information about the error. Its `componentStack` field contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks.\n    \n\n#### Returns[](#componentdidcatch-returns \"Link for Returns \")\n\n`componentDidCatch` should not return anything.\n\n#### Caveats[](#componentdidcatch-caveats \"Link for Caveats \")\n\n*   In the past, it was common to call `setState` inside `componentDidCatch` in order to update the UI and display the fallback error message. This is deprecated in favor of defining [`static getDerivedStateFromError`.](#static-getderivedstatefromerror)\n    \n*   Production and development builds of React slightly differ in the way `componentDidCatch` handles errors. In development, the errors will bubble up to `window`, which means that any `window.onerror` or `window.addEventListener('error', callback)` will intercept the errors that have been caught by `componentDidCatch`. In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by `componentDidCatch`.\n    \n\n### Note\n\nThere is no direct equivalent for `componentDidCatch` in function components yet. If you‚Äôd like to avoid creating class components, write a single `ErrorBoundary` component like above and use it throughout your app. Alternatively, you can use the [`react-error-boundary`](https://github.com/bvaughn/react-error-boundary) package which does that for you.\n\n* * *\n\n### `componentDidMount()`[](#componentdidmount \"Link for this heading\")\n\nIf you define the `componentDidMount` method, React will call it when your component is added _(mounted)_ to the screen. This is a common place to start data fetching, set up subscriptions, or manipulate the DOM nodes.\n\nIf you implement `componentDidMount`, you usually need to implement other lifecycle methods to avoid bugs. For example, if `componentDidMount` reads some state or props, you also have to implement [`componentDidUpdate`](#componentdidupdate) to handle their changes, and [`componentWillUnmount`](#componentwillunmount) to clean up whatever `componentDidMount` was doing.\n\n```\nclass ChatRoom extends Component {state = {serverUrl: 'https://localhost:1234'};componentDidMount() {this.setupConnection();}componentDidUpdate(prevProps, prevState) {if (this.props.roomId !== prevProps.roomId ||this.state.serverUrl !== prevState.serverUrl) {this.destroyConnection();this.setupConnection();}}componentWillUnmount() {this.destroyConnection();}// ...}\n```\n\n[See more examples.](#adding-lifecycle-methods-to-a-class-component)\n\n#### Parameters[](#componentdidmount-parameters \"Link for Parameters \")\n\n`componentDidMount` does not take any parameters.\n\n#### Returns[](#componentdidmount-returns \"Link for Returns \")\n\n`componentDidMount` should not return anything.\n\n#### Caveats[](#componentdidmount-caveats \"Link for Caveats \")\n\n*   When [Strict Mode](https://react.dev/reference/react/StrictMode) is on, in development React will call `componentDidMount`, then immediately call [`componentWillUnmount`,](#componentwillunmount) and then call `componentDidMount` again. This helps you notice if you forgot to implement `componentWillUnmount` or if its logic doesn‚Äôt fully ‚Äúmirror‚Äù what `componentDidMount` does.\n    \n*   Although you may call [`setState`](#setstate) immediately in `componentDidMount`, it‚Äôs best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the [`render`](#render) will be called twice in this case, the user won‚Äôt see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the [`constructor`](#constructor) instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n    \n\n### Note\n\nFor many use cases, defining `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` together in class components is equivalent to calling [`useEffect`](https://react.dev/reference/react/useEffect) in function components. In the rare cases where it‚Äôs important for the code to run before browser paint, [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect) is a closer match.\n\n[See how to migrate.](#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)\n\n* * *\n\n### `componentDidUpdate(prevProps, prevState, snapshot?)`[](#componentdidupdate \"Link for this heading\")\n\nIf you define the `componentDidUpdate` method, React will call it immediately after your component has been re-rendered with updated props or state. This method is not called for the initial render.\n\nYou can use it to manipulate the DOM after an update. This is also a common place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). Typically, you‚Äôd use it together with [`componentDidMount`](#componentdidmount) and [`componentWillUnmount`:](#componentwillunmount)\n\n```\nclass ChatRoom extends Component {state = {serverUrl: 'https://localhost:1234'};componentDidMount() {this.setupConnection();}componentDidUpdate(prevProps, prevState) {if (this.props.roomId !== prevProps.roomId ||this.state.serverUrl !== prevState.serverUrl) {this.destroyConnection();this.setupConnection();}}componentWillUnmount() {this.destroyConnection();}// ...}\n```\n\n[See more examples.](#adding-lifecycle-methods-to-a-class-component)\n\n#### Parameters[](#componentdidupdate-parameters \"Link for Parameters \")\n\n*   `prevProps`: Props before the update. Compare `prevProps` to [`this.props`](#props) to determine what changed.\n    \n*   `prevState`: State before the update. Compare `prevState` to [`this.state`](#state) to determine what changed.\n    \n*   `snapshot`: If you implemented [`getSnapshotBeforeUpdate`](#getsnapshotbeforeupdate), `snapshot` will contain the value you returned from that method. Otherwise, it will be `undefined`.\n    \n\n#### Returns[](#componentdidupdate-returns \"Link for Returns \")\n\n`componentDidUpdate` should not return anything.\n\n#### Caveats[](#componentdidupdate-caveats \"Link for Caveats \")\n\n*   `componentDidUpdate` will not get called if [`shouldComponentUpdate`](#shouldcomponentupdate) is defined and returns `false`.\n    \n*   The logic inside `componentDidUpdate` should usually be wrapped in conditions comparing `this.props` with `prevProps`, and `this.state` with `prevState`. Otherwise, there‚Äôs a risk of creating infinite loops.\n    \n*   Although you may call [`setState`](#setstate) immediately in `componentDidUpdate`, it‚Äôs best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the [`render`](#render) will be called twice in this case, the user won‚Äôt see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n    \n\n### Note\n\nFor many use cases, defining `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` together in class components is equivalent to calling [`useEffect`](https://react.dev/reference/react/useEffect) in function components. In the rare cases where it‚Äôs important for the code to run before browser paint, [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect) is a closer match.\n\n[See how to migrate.](#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)\n\n* * *\n\n### `componentWillMount()`[](#componentwillmount \"Link for this heading\")\n\n### Deprecated\n\nThis API has been renamed from `componentWillMount` to [`UNSAFE_componentWillMount`.](#unsafe_componentwillmount) The old name has been deprecated. In a future major version of React, only the new name will work.\n\nRun the [`rename-unsafe-lifecycles` codemod](https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) to automatically update your components.\n\n* * *\n\n### `componentWillReceiveProps(nextProps)`[](#componentwillreceiveprops \"Link for this heading\")\n\n### Deprecated\n\nThis API has been renamed from `componentWillReceiveProps` to [`UNSAFE_componentWillReceiveProps`.](#unsafe_componentwillreceiveprops) The old name has been deprecated. In a future major version of React, only the new name will work.\n\nRun the [`rename-unsafe-lifecycles` codemod](https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) to automatically update your components.\n\n* * *\n\n### `componentWillUpdate(nextProps, nextState)`[](#componentwillupdate \"Link for this heading\")\n\n### Deprecated\n\nThis API has been renamed from `componentWillUpdate` to [`UNSAFE_componentWillUpdate`.](#unsafe_componentwillupdate) The old name has been deprecated. In a future major version of React, only the new name will work.\n\nRun the [`rename-unsafe-lifecycles` codemod](https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) to automatically update your components.\n\n* * *\n\n### `componentWillUnmount()`[](#componentwillunmount \"Link for this heading\")\n\nIf you define the `componentWillUnmount` method, React will call it before your component is removed _(unmounted)_ from the screen. This is a common place to cancel data fetching or remove subscriptions.\n\nThe logic inside `componentWillUnmount` should ‚Äúmirror‚Äù the logic inside [`componentDidMount`.](#componentdidmount) For example, if `componentDidMount` sets up a subscription, `componentWillUnmount` should clean up that subscription. If the cleanup logic in your `componentWillUnmount` reads some props or state, you will usually also need to implement [`componentDidUpdate`](#componentdidupdate) to clean up resources (such as subscriptions) corresponding to the old props and state.\n\n```\nclass ChatRoom extends Component {state = {serverUrl: 'https://localhost:1234'};componentDidMount() {this.setupConnection();}componentDidUpdate(prevProps, prevState) {if (this.props.roomId !== prevProps.roomId ||this.state.serverUrl !== prevState.serverUrl) {this.destroyConnection();this.setupConnection();}}componentWillUnmount() {this.destroyConnection();}// ...}\n```\n\n[See more examples.](#adding-lifecycle-methods-to-a-class-component)\n\n#### Parameters[](#componentwillunmount-parameters \"Link for Parameters \")\n\n`componentWillUnmount` does not take any parameters.\n\n#### Returns[](#componentwillunmount-returns \"Link for Returns \")\n\n`componentWillUnmount` should not return anything.\n\n#### Caveats[](#componentwillunmount-caveats \"Link for Caveats \")\n\n*   When [Strict Mode](https://react.dev/reference/react/StrictMode) is on, in development React will call [`componentDidMount`,](#componentdidmount) then immediately call `componentWillUnmount`, and then call `componentDidMount` again. This helps you notice if you forgot to implement `componentWillUnmount` or if its logic doesn‚Äôt fully ‚Äúmirror‚Äù what `componentDidMount` does.\n\n### Note\n\nFor many use cases, defining `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` together in class components is equivalent to calling [`useEffect`](https://react.dev/reference/react/useEffect) in function components. In the rare cases where it‚Äôs important for the code to run before browser paint, [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect) is a closer match.\n\n[See how to migrate.](#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)\n\n* * *\n\n### `forceUpdate(callback?)`[](#forceupdate \"Link for this heading\")\n\nForces a component to re-render.\n\nUsually, this is not necessary. If your component‚Äôs [`render`](#render) method only reads from [`this.props`](#props), [`this.state`](#state), or [`this.context`,](#context) it will re-render automatically when you call [`setState`](#setstate) inside your component or one of its parents. However, if your component‚Äôs `render` method reads directly from an external data source, you have to tell React to update the user interface when that data source changes. That‚Äôs what `forceUpdate` lets you do.\n\nTry to avoid all uses of `forceUpdate` and only read from `this.props` and `this.state` in `render`.\n\n#### Parameters[](#forceupdate-parameters \"Link for Parameters \")\n\n*   **optional** `callback` If specified, React will call the `callback` you‚Äôve provided after the update is committed.\n\n#### Returns[](#forceupdate-returns \"Link for Returns \")\n\n`forceUpdate` does not return anything.\n\n#### Caveats[](#forceupdate-caveats \"Link for Caveats \")\n\n*   If you call `forceUpdate`, React will re-render without calling [`shouldComponentUpdate`.](#shouldcomponentupdate)\n\n### Note\n\nReading an external data source and forcing class components to re-render in response to its changes with `forceUpdate` has been superseded by [`useSyncExternalStore`](https://react.dev/reference/react/useSyncExternalStore) in function components.\n\n* * *\n\n### `getChildContext()`[](#getchildcontext \"Link for this heading\")\n\n### Deprecated\n\nLets you specify the values for the [legacy context](https://reactjs.org/docs/legacy-context.html) is provided by this component.\n\n* * *\n\n### `getSnapshotBeforeUpdate(prevProps, prevState)`[](#getsnapshotbeforeupdate \"Link for this heading\")\n\nIf you implement `getSnapshotBeforeUpdate`, React will call it immediately before React updates the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to [`componentDidUpdate`.](#componentdidupdate)\n\nFor example, you can use it in a UI like a chat thread that needs to preserve its scroll position during updates:\n\n```\nclass ScrollingList extends React.Component {constructor(props) {super(props);this.listRef = React.createRef();}getSnapshotBeforeUpdate(prevProps, prevState) {// Are we adding new items to the list?// Capture the scroll position so we can adjust scroll later.if (prevProps.list.length < this.props.list.length) {const list = this.listRef.current;return list.scrollHeight - list.scrollTop;}return null;}componentDidUpdate(prevProps, prevState, snapshot) {// If we have a snapshot value, we've just added new items.// Adjust scroll so these new items don't push the old ones out of view.// (snapshot here is the value returned from getSnapshotBeforeUpdate)if (snapshot !== null) {const list = this.listRef.current;list.scrollTop = list.scrollHeight - snapshot;}}render() {return (<div ref={this.listRef}>{/* ...contents... */}</div>);}}\n```\n\nIn the above example, it is important to read the `scrollHeight` property directly in `getSnapshotBeforeUpdate`. It is not safe to read it in [`render`](#render), [`UNSAFE_componentWillReceiveProps`](#unsafe_componentwillreceiveprops), or [`UNSAFE_componentWillUpdate`](#unsafe_componentwillupdate) because there is a potential time gap between these methods getting called and React updating the DOM.\n\n#### Parameters[](#getsnapshotbeforeupdate-parameters \"Link for Parameters \")\n\n*   `prevProps`: Props before the update. Compare `prevProps` to [`this.props`](#props) to determine what changed.\n    \n*   `prevState`: State before the update. Compare `prevState` to [`this.state`](#state) to determine what changed.\n    \n\n#### Returns[](#getsnapshotbeforeupdate-returns \"Link for Returns \")\n\nYou should return a snapshot value of any type that you‚Äôd like, or `null`. The value you returned will be passed as the third argument to [`componentDidUpdate`.](#componentdidupdate)\n\n#### Caveats[](#getsnapshotbeforeupdate-caveats \"Link for Caveats \")\n\n*   `getSnapshotBeforeUpdate` will not get called if [`shouldComponentUpdate`](#shouldcomponentupdate) is defined and returns `false`.\n\n### Note\n\nAt the moment, there is no equivalent to `getSnapshotBeforeUpdate` for function components. This use case is very uncommon, but if you have the need for it, for now you‚Äôll have to write a class component.\n\n* * *\n\n### `render()`[](#render \"Link for this heading\")\n\nThe `render` method is the only required method in a class component.\n\nThe `render` method should specify what you want to appear on the screen, for example:\n\n```\nimport { Component } from 'react';class Greeting extends Component {render() {return <h1>Hello, {this.props.name}!</h1>;}}\n```\n\nReact may call `render` at any moment, so you shouldn‚Äôt assume that it runs at a particular time. Usually, the `render` method should return a piece of [JSX](https://react.dev/learn/writing-markup-with-jsx), but a few [other return types](#render-returns) (like strings) are supported. To calculate the returned JSX, the `render` method can read [`this.props`](#props), [`this.state`](#state), and [`this.context`](#context).\n\nYou should write the `render` method as a pure function, meaning that it should return the same result if props, state, and context are the same. It also shouldn‚Äôt contain side effects (like setting up subscriptions) or interact with the browser APIs. Side effects should happen either in event handlers or methods like [`componentDidMount`.](#componentdidmount)\n\n#### Parameters[](#render-parameters \"Link for Parameters \")\n\n`render` does not take any parameters.\n\n#### Returns[](#render-returns \"Link for Returns \")\n\n`render` can return any valid React node. This includes React elements such as `<div />`, strings, numbers, [portals](https://react.dev/reference/react-dom/createPortal), empty nodes (`null`, `undefined`, `true`, and `false`), and arrays of React nodes.\n\n#### Caveats[](#render-caveats \"Link for Caveats \")\n\n*   `render` should be written as a pure function of props, state, and context. It should not have side effects.\n    \n*   `render` will not get called if [`shouldComponentUpdate`](#shouldcomponentupdate) is defined and returns `false`.\n    \n*   When [Strict Mode](https://react.dev/reference/react/StrictMode) is on, React will call `render` twice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of the `render` method.\n    \n*   There is no one-to-one correspondence between the `render` call and the subsequent `componentDidMount` or `componentDidUpdate` call. Some of the `render` call results may be discarded by React when it‚Äôs beneficial.\n    \n\n* * *\n\n### `setState(nextState, callback?)`[](#setstate \"Link for this heading\")\n\nCall `setState` to update the state of your React component.\n\n```\nclass Form extends Component {state = {name: 'Taylor',};handleNameChange = (e) => {const newName = e.target.value;this.setState({name: newName});}render() {return (<><input value={this.state.name} onChange={this.handleNameChange} /><p>Hello, {this.state.name}.</p></>);}}\n```\n\n`setState` enqueues changes to the component state. It tells React that this component and its children need to re-render with the new state. This is the main way you‚Äôll update the user interface in response to interactions.\n\n### Pitfall\n\nCalling `setState` **does not** change the current state in the already executing code:\n\n```\nfunction handleClick() {console.log(this.state.name); // \"Taylor\"this.setState({name: 'Robin'});console.log(this.state.name); // Still \"Taylor\"!}\n```\n\nIt only affects what `this.state` will return starting from the _next_ render.\n\nYou can also pass a function to `setState`. It lets you update state based on the previous state:\n\n```\nhandleIncreaseAge = () => {this.setState(prevState => {return {age: prevState.age + 1};});}\n```\n\nYou don‚Äôt have to do this, but it‚Äôs handy if you want to update state multiple times during the same event.\n\n#### Parameters[](#setstate-parameters \"Link for Parameters \")\n\n*   `nextState`: Either an object or a function.\n    \n    *   If you pass an object as `nextState`, it will be shallowly merged into `this.state`.\n    *   If you pass a function as `nextState`, it will be treated as an _updater function_. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged into `this.state`. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.\n*   **optional** `callback`: If specified, React will call the `callback` you‚Äôve provided after the update is committed.\n    \n\n#### Returns[](#setstate-returns \"Link for Returns \")\n\n`setState` does not return anything.\n\n#### Caveats[](#setstate-caveats \"Link for Caveats \")\n\n*   Think of `setState` as a _request_ rather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it in [`flushSync`,](https://react.dev/reference/react-dom/flushSync) but this may hurt performance.\n    \n*   `setState` does not update `this.state` immediately. This makes reading `this.state` right after calling `setState` a potential pitfall. Instead, use [`componentDidUpdate`](#componentdidupdate) or the setState `callback` argument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function to `nextState` as described above.\n    \n\n### Note\n\nCalling `setState` in class components is similar to calling a [`set` function](https://react.dev/reference/react/useState#setstate) in function components.\n\n[See how to migrate.](#migrating-a-component-with-state-from-a-class-to-a-function)\n\n* * *\n\n### `shouldComponentUpdate(nextProps, nextState, nextContext)`[](#shouldcomponentupdate \"Link for this heading\")\n\nIf you define `shouldComponentUpdate`, React will call it to determine whether a re-render can be skipped.\n\nIf you are confident you want to write it by hand, you may compare `this.props` with `nextProps` and `this.state` with `nextState` and return `false` to tell React the update can be skipped.\n\n```\nclass Rectangle extends Component {state = {isHovered: false};shouldComponentUpdate(nextProps, nextState) {if (nextProps.position.x === this.props.position.x &&nextProps.position.y === this.props.position.y &&nextProps.size.width === this.props.size.width &&nextProps.size.height === this.props.size.height &&nextState.isHovered === this.state.isHovered) {// Nothing has changed, so a re-render is unnecessaryreturn false;}return true;}// ...}\n```\n\nReact calls `shouldComponentUpdate` before rendering when new props or state are being received. Defaults to `true`. This method is not called for the initial render or when [`forceUpdate`](#forceupdate) is used.\n\n#### Parameters[](#shouldcomponentupdate-parameters \"Link for Parameters \")\n\n*   `nextProps`: The next props that the component is about to render with. Compare `nextProps` to [`this.props`](#props) to determine what changed.\n*   `nextState`: The next state that the component is about to render with. Compare `nextState` to [`this.state`](#props) to determine what changed.\n*   `nextContext`: The next context that the component is about to render with. Compare `nextContext` to [`this.context`](#context) to determine what changed. Only available if you specify [`static contextType`](#static-contexttype) (modern) or [`static contextTypes`](#static-contexttypes) (legacy).\n\n#### Returns[](#shouldcomponentupdate-returns \"Link for Returns \")\n\nReturn `true` if you want the component to re-render. That‚Äôs the default behavior.\n\nReturn `false` to tell React that re-rendering can be skipped.\n\n#### Caveats[](#shouldcomponentupdate-caveats \"Link for Caveats \")\n\n*   This method _only_ exists as a performance optimization. If your component breaks without it, fix that first.\n    \n*   Consider using [`PureComponent`](https://react.dev/reference/react/PureComponent) instead of writing `shouldComponentUpdate` by hand. `PureComponent` shallowly compares props and state, and reduces the chance that you‚Äôll skip a necessary update.\n    \n*   We do not recommend doing deep equality checks or using `JSON.stringify` in `shouldComponentUpdate`. It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it.\n    \n*   Returning `false` does not prevent child components from re-rendering when _their_ state changes.\n    \n*   Returning `false` does not _guarantee_ that the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons.\n    \n\n### Note\n\nOptimizing class components with `shouldComponentUpdate` is similar to optimizing function components with [`memo`.](https://react.dev/reference/react/memo) Function components also offer more granular optimization with [`useMemo`.](https://react.dev/reference/react/useMemo)\n\n* * *\n\n### `UNSAFE_componentWillMount()`[](#unsafe_componentwillmount \"Link for this heading\")\n\nIf you define `UNSAFE_componentWillMount`, React will call it immediately after the [`constructor`.](#constructor) It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n\n*   To initialize state, declare [`state`](#state) as a class field or set `this.state` inside the [`constructor`.](#constructor)\n*   If you need to run a side effect or set up a subscription, move that logic to [`componentDidMount`](#componentdidmount) instead.\n\n[See examples of migrating away from unsafe lifecycles.](https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#examples)\n\n#### Parameters[](#unsafe_componentwillmount-parameters \"Link for Parameters \")\n\n`UNSAFE_componentWillMount` does not take any parameters.\n\n#### Returns[](#unsafe_componentwillmount-returns \"Link for Returns \")\n\n`UNSAFE_componentWillMount` should not return anything.\n\n#### Caveats[](#unsafe_componentwillmount-caveats \"Link for Caveats \")\n\n*   `UNSAFE_componentWillMount` will not get called if the component implements [`static getDerivedStateFromProps`](#static-getderivedstatefromprops) or [`getSnapshotBeforeUpdate`.](#getsnapshotbeforeupdate)\n    \n*   Despite its naming, `UNSAFE_componentWillMount` does not guarantee that the component _will_ get mounted if your app uses modern React features like [`Suspense`.](https://react.dev/reference/react/Suspense) If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is ‚Äúunsafe‚Äù. Code that relies on mounting (like adding a subscription) should go into [`componentDidMount`.](#componentdidmount)\n    \n*   `UNSAFE_componentWillMount` is the only lifecycle method that runs during [server rendering.](https://react.dev/reference/react-dom/server) For all practical purposes, it is identical to [`constructor`,](#constructor) so you should use the `constructor` for this type of logic instead.\n    \n\n### Note\n\nCalling [`setState`](#setstate) inside `UNSAFE_componentWillMount` in a class component to initialize state is equivalent to passing that state as the initial state to [`useState`](https://react.dev/reference/react/useState) in a function component.\n\n* * *\n\n### `UNSAFE_componentWillReceiveProps(nextProps, nextContext)`[](#unsafe_componentwillreceiveprops \"Link for this heading\")\n\nIf you define `UNSAFE_componentWillReceiveProps`, React will call it when the component receives new props. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n\n*   If you need to **run a side effect** (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop changes, move that logic to [`componentDidUpdate`](#componentdidupdate) instead.\n*   If you need to **avoid re-computing some data only when a prop changes,** use a [memoization helper](https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization) instead.\n*   If you need to **‚Äúreset‚Äù some state when a prop changes,** consider either making a component [fully controlled](https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component) or [fully uncontrolled with a key](https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key) instead.\n*   If you need to **‚Äúadjust‚Äù some state when a prop changes,** check whether you can compute all the necessary information from props alone during rendering. If you can‚Äôt, use [`static getDerivedStateFromProps`](https://react.dev/reference/react/Component#static-getderivedstatefromprops) instead.\n\n[See examples of migrating away from unsafe lifecycles.](https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props)\n\n#### Parameters[](#unsafe_componentwillreceiveprops-parameters \"Link for Parameters \")\n\n*   `nextProps`: The next props that the component is about to receive from its parent component. Compare `nextProps` to [`this.props`](#props) to determine what changed.\n*   `nextContext`: The next context that the component is about to receive from the closest provider. Compare `nextContext` to [`this.context`](#context) to determine what changed. Only available if you specify [`static contextType`](#static-contexttype) (modern) or [`static contextTypes`](#static-contexttypes) (legacy).\n\n#### Returns[](#unsafe_componentwillreceiveprops-returns \"Link for Returns \")\n\n`UNSAFE_componentWillReceiveProps` should not return anything.\n\n#### Caveats[](#unsafe_componentwillreceiveprops-caveats \"Link for Caveats \")\n\n*   `UNSAFE_componentWillReceiveProps` will not get called if the component implements [`static getDerivedStateFromProps`](#static-getderivedstatefromprops) or [`getSnapshotBeforeUpdate`.](#getsnapshotbeforeupdate)\n    \n*   Despite its naming, `UNSAFE_componentWillReceiveProps` does not guarantee that the component _will_ receive those props if your app uses modern React features like [`Suspense`.](https://react.dev/reference/react/Suspense) If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is ‚Äúunsafe‚Äù. Code that should run only for committed updates (like resetting a subscription) should go into [`componentDidUpdate`.](#componentdidupdate)\n    \n*   `UNSAFE_componentWillReceiveProps` does not mean that the component has received _different_ props than the last time. You need to compare `nextProps` and `this.props` yourself to check if something changed.\n    \n*   React doesn‚Äôt call `UNSAFE_componentWillReceiveProps` with initial props during mounting. It only calls this method if some of component‚Äôs props are going to be updated. For example, calling [`setState`](#setstate) doesn‚Äôt generally trigger `UNSAFE_componentWillReceiveProps` inside the same component.\n    \n\n### Note\n\n* * *\n\n### `UNSAFE_componentWillUpdate(nextProps, nextState)`[](#unsafe_componentwillupdate \"Link for this heading\")\n\nIf you define `UNSAFE_componentWillUpdate`, React will call it before rendering with the new props or state. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n\n*   If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop or state changes, move that logic to [`componentDidUpdate`](#componentdidupdate) instead.\n*   If you need to read some information from the DOM (for example, to save the current scroll position) so that you can use it in [`componentDidUpdate`](#componentdidupdate) later, read it inside [`getSnapshotBeforeUpdate`](#getsnapshotbeforeupdate) instead.\n\n[See examples of migrating away from unsafe lifecycles.](https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#examples)\n\n#### Parameters[](#unsafe_componentwillupdate-parameters \"Link for Parameters \")\n\n*   `nextProps`: The next props that the component is about to render with. Compare `nextProps` to [`this.props`](#props) to determine what changed.\n*   `nextState`: The next state that the component is about to render with. Compare `nextState` to [`this.state`](#state) to determine what changed.\n\n#### Returns[](#unsafe_componentwillupdate-returns \"Link for Returns \")\n\n`UNSAFE_componentWillUpdate` should not return anything.\n\n#### Caveats[](#unsafe_componentwillupdate-caveats \"Link for Caveats \")\n\n*   `UNSAFE_componentWillUpdate` will not get called if [`shouldComponentUpdate`](#shouldcomponentupdate) is defined and returns `false`.\n    \n*   `UNSAFE_componentWillUpdate` will not get called if the component implements [`static getDerivedStateFromProps`](#static-getderivedstatefromprops) or [`getSnapshotBeforeUpdate`.](#getsnapshotbeforeupdate)\n    \n*   It‚Äôs not supported to call [`setState`](#setstate) (or any method that leads to `setState` being called, like dispatching a Redux action) during `componentWillUpdate`.\n    \n*   Despite its naming, `UNSAFE_componentWillUpdate` does not guarantee that the component _will_ update if your app uses modern React features like [`Suspense`.](https://react.dev/reference/react/Suspense) If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is ‚Äúunsafe‚Äù. Code that should run only for committed updates (like resetting a subscription) should go into [`componentDidUpdate`.](#componentdidupdate)\n    \n*   `UNSAFE_componentWillUpdate` does not mean that the component has received _different_ props or state than the last time. You need to compare `nextProps` with `this.props` and `nextState` with `this.state` yourself to check if something changed.\n    \n*   React doesn‚Äôt call `UNSAFE_componentWillUpdate` with initial props and state during mounting.\n    \n\n### Note\n\nThere is no direct equivalent to `UNSAFE_componentWillUpdate` in function components.\n\n* * *\n\n### `static childContextTypes`[](#static-childcontexttypes \"Link for this heading\")\n\n### Deprecated\n\nThis API will be removed in a future major version of React. [Use `static contextType` instead.](#static-contexttype)\n\nLets you specify which [legacy context](https://reactjs.org/docs/legacy-context.html) is provided by this component.\n\n* * *\n\n### `static contextTypes`[](#static-contexttypes \"Link for this heading\")\n\n### Deprecated\n\nThis API will be removed in a future major version of React. [Use `static contextType` instead.](#static-contexttype)\n\nLets you specify which [legacy context](https://reactjs.org/docs/legacy-context.html) is consumed by this component.\n\n* * *\n\n### `static contextType`[](#static-contexttype \"Link for this heading\")\n\nIf you want to read [`this.context`](#context-instance-field) from your class component, you must specify which context it needs to read. The context you specify as the `static contextType` must be a value previously created by [`createContext`.](https://react.dev/reference/react/createContext)\n\n```\nclass Button extends Component {static contextType = ThemeContext;render() {const theme = this.context;const className = 'button-' + theme;return (<button className={className}>{this.props.children}</button>);}}\n```\n\n### Note\n\nReading `this.context` in class components is equivalent to [`useContext`](https://react.dev/reference/react/useContext) in function components.\n\n[See how to migrate.](#migrating-a-component-with-context-from-a-class-to-a-function)\n\n* * *\n\n### `static defaultProps`[](#static-defaultprops \"Link for this heading\")\n\nYou can define `static defaultProps` to set the default props for the class. They will be used for `undefined` and missing props, but not for `null` props.\n\nFor example, here is how you define that the `color` prop should default to `'blue'`:\n\n```\nclass Button extends Component {static defaultProps = {color: 'blue'};render() {return <button className={this.props.color}>click me</button>;}}\n```\n\nIf the `color` prop is not provided or is `undefined`, it will be set by default to `'blue'`:\n\n```\n<>{/* this.props.color is \"blue\" */}<Button />{/* this.props.color is \"blue\" */}<Button color={undefined} />{/* this.props.color is null */}<Button color={null} />{/* this.props.color is \"red\" */}<Button color=\"red\" /></>\n```\n\n### Note\n\nDefining `defaultProps` in class components is similar to using [default values](https://react.dev/learn/passing-props-to-a-component#specifying-a-default-value-for-a-prop) in function components.\n\n* * *\n\n### `static propTypes`[](#static-proptypes \"Link for this heading\")\n\nYou can define `static propTypes` together with the [`prop-types`](https://www.npmjs.com/package/prop-types) library to declare the types of the props accepted by your component. These types will be checked during rendering and in development only.\n\n```\nimport PropTypes from 'prop-types';class Greeting extends React.Component {static propTypes = {name: PropTypes.string};render() {return (<h1>Hello, {this.props.name}</h1>);}}\n```\n\n### Note\n\nWe recommend using [TypeScript](https://www.typescriptlang.org/) instead of checking prop types at runtime.\n\n* * *\n\n### `static getDerivedStateFromError(error)`[](#static-getderivedstatefromerror \"Link for this heading\")\n\nIf you define `static getDerivedStateFromError`, React will call it when a child component (including distant children) throws an error during rendering. This lets you display an error message instead of clearing the UI.\n\nTypically, it is used together with [`componentDidCatch`](#componentdidcatch) which lets you send the error report to some analytics service. A component with these methods is called an _error boundary._\n\n[See an example.](#catching-rendering-errors-with-an-error-boundary)\n\n#### Parameters[](#static-getderivedstatefromerror-parameters \"Link for Parameters \")\n\n*   `error`: The error that was thrown. In practice, it will usually be an instance of [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) but this is not guaranteed because JavaScript allows to [`throw`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw) any value, including strings or even `null`.\n\n#### Returns[](#static-getderivedstatefromerror-returns \"Link for Returns \")\n\n`static getDerivedStateFromError` should return the state telling the component to display the error message.\n\n#### Caveats[](#static-getderivedstatefromerror-caveats \"Link for Caveats \")\n\n*   `static getDerivedStateFromError` should be a pure function. If you want to perform a side effect (for example, to call an analytics service), you need to also implement [`componentDidCatch`.](#componentdidcatch)\n\n### Note\n\nThere is no direct equivalent for `static getDerivedStateFromError` in function components yet. If you‚Äôd like to avoid creating class components, write a single `ErrorBoundary` component like above and use it throughout your app. Alternatively, use the [`react-error-boundary`](https://github.com/bvaughn/react-error-boundary) package which does that.\n\n* * *\n\n### `static getDerivedStateFromProps(props, state)`[](#static-getderivedstatefromprops \"Link for this heading\")\n\nIf you define `static getDerivedStateFromProps`, React will call it right before calling [`render`,](#render) both on the initial mount and on subsequent updates. It should return an object to update the state, or `null` to update nothing.\n\nThis method exists for [rare use cases](https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state) where the state depends on changes in props over time. For example, this `Form` component resets the `email` state when the `userID` prop changes:\n\n```\nclass Form extends Component {state = {email: this.props.defaultEmail,prevUserID: this.props.userID};static getDerivedStateFromProps(props, state) {// Any time the current user changes,// Reset any parts of state that are tied to that user.// In this simple example, that's just the email.if (props.userID !== state.prevUserID) {return {prevUserID: props.userID,email: props.defaultEmail};}return null;}// ...}\n```\n\nNote that this pattern requires you to keep a previous value of the prop (like `userID`) in state (like `prevUserID`).\n\n### Pitfall\n\n#### Parameters[](#static-getderivedstatefromprops-parameters \"Link for Parameters \")\n\n*   `props`: The next props that the component is about to render with.\n*   `state`: The next state that the component is about to render with.\n\n#### Returns[](#static-getderivedstatefromprops-returns \"Link for Returns \")\n\n`static getDerivedStateFromProps` return an object to update the state, or `null` to update nothing.\n\n#### Caveats[](#static-getderivedstatefromprops-caveats \"Link for Caveats \")\n\n*   This method is fired on _every_ render, regardless of the cause. This is different from [`UNSAFE_componentWillReceiveProps`](#unsafe_cmoponentwillreceiveprops), which only fires when the parent causes a re-render and not as a result of a local `setState`.\n    \n*   This method doesn‚Äôt have access to the component instance. If you‚Äôd like, you can reuse some code between `static getDerivedStateFromProps` and the other class methods by extracting pure functions of the component props and state outside the class definition.\n    \n\n### Note\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Defining a class component[](#defining-a-class-component \"Link for Defining a class component \")\n\nTo define a React component as a class, extend the built-in `Component` class and define a [`render` method:](#render)\n\n```\nimport { Component } from 'react';class Greeting extends Component {render() {return <h1>Hello, {this.props.name}!</h1>;}}\n```\n\nReact will call your [`render`](#render) method whenever it needs to figure out what to display on the screen. Usually, you will return some [JSX](https://react.dev/learn/writing-markup-with-jsx) from it. Your `render` method should be a [pure function:](https://en.wikipedia.org/wiki/Pure_function) it should only calculate the JSX.\n\nSimilarly to [function components,](https://react.dev/learn/your-first-component#defining-a-component) a class component can [receive information by props](https://react.dev/learn/your-first-component#defining-a-component) from its parent component. However, the syntax for reading props is different. For example, if the parent component renders `<Greeting name=\"Taylor\" />`, then you can read the `name` prop from [`this.props`](#props), like `this.props.name`:\n\nNote that Hooks (functions starting with `use`, like [`useState`](https://react.dev/reference/react/useState)) are not supported inside class components.\n\n### Pitfall\n\nWe recommend defining components as functions instead of classes. [See how to migrate.](#migrating-a-simple-component-from-a-class-to-a-function)\n\n* * *\n\n### Adding state to a class component[](#adding-state-to-a-class-component \"Link for Adding state to a class component \")\n\nTo add [state](https://react.dev/learn/state-a-components-memory) to a class, assign an object to a property called [`state`](#state). To update state, call [`this.setState`](#setstate).\n\n### Pitfall\n\nWe recommend defining components as functions instead of classes. [See how to migrate.](#migrating-a-component-with-state-from-a-class-to-a-function)\n\n* * *\n\n### Adding lifecycle methods to a class component[](#adding-lifecycle-methods-to-a-class-component \"Link for Adding lifecycle methods to a class component \")\n\nThere are a few special methods you can define on your class.\n\nIf you define the [`componentDidMount`](#componentdidmount) method, React will call it when your component is added _(mounted)_ to the screen. React will call [`componentDidUpdate`](#componentdidupdate) after your component re-renders due to changed props or state. React will call [`componentWillUnmount`](#componentwillunmount) after your component has been removed _(unmounted)_ from the screen.\n\nIf you implement `componentDidMount`, you usually need to implement all three lifecycles to avoid bugs. For example, if `componentDidMount` reads some state or props, you also have to implement `componentDidUpdate` to handle their changes, and `componentWillUnmount` to clean up whatever `componentDidMount` was doing.\n\nFor example, this `ChatRoom` component keeps a chat connection synchronized with props and state:\n\nNote that in development when [Strict Mode](https://react.dev/reference/react/StrictMode) is on, React will call `componentDidMount`, immediately call `componentWillUnmount`, and then call `componentDidMount` again. This helps you notice if you forgot to implement `componentWillUnmount` or if its logic doesn‚Äôt fully ‚Äúmirror‚Äù what `componentDidMount` does.\n\n### Pitfall\n\nWe recommend defining components as functions instead of classes. [See how to migrate.](#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)\n\n* * *\n\n### Catching rendering errors with an error boundary[](#catching-rendering-errors-with-an-error-boundary \"Link for Catching rendering errors with an error boundary \")\n\nBy default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into an _error boundary_. An error boundary is a special component that lets you display some fallback UI instead of the part that crashed‚Äîfor example, an error message.\n\nTo implement an error boundary component, you need to provide [`static getDerivedStateFromError`](#static-getderivedstatefromerror) which lets you update state in response to an error and display an error message to the user. You can also optionally implement [`componentDidCatch`](#componentdidcatch) to add some extra logic, for example, to log the error to an analytics service.\n\n```\nclass ErrorBoundary extends React.Component {constructor(props) {super(props);this.state = { hasError: false };}static getDerivedStateFromError(error) {// Update state so the next render will show the fallback UI.return { hasError: true };}componentDidCatch(error, info) {// Example \"componentStack\"://   in ComponentThatThrows (created by App)//   in ErrorBoundary (created by App)//   in div (created by App)//   in ApplogErrorToMyService(error, info.componentStack);}render() {if (this.state.hasError) {// You can render any custom fallback UIreturn this.props.fallback;}return this.props.children;}}\n```\n\nThen you can wrap a part of your component tree with it:\n\n```\n<ErrorBoundary fallback={<p>Something went wrong</p>}><Profile /></ErrorBoundary>\n```\n\nIf `Profile` or its child component throws an error, `ErrorBoundary` will ‚Äúcatch‚Äù that error, display a fallback UI with the error message you‚Äôve provided, and send a production error report to your error reporting service.\n\nYou don‚Äôt need to wrap every component into a separate error boundary. When you think about the [granularity of error boundaries,](https://www.brandondail.com/posts/fault-tolerance-react) consider where it makes sense to display an error message. For example, in a messaging app, it makes sense to place an error boundary around the list of conversations. It also makes sense to place one around every individual message. However, it wouldn‚Äôt make sense to place a boundary around every avatar.\n\n### Note\n\nThere is currently no way to write an error boundary as a function component. However, you don‚Äôt have to write the error boundary class yourself. For example, you can use [`react-error-boundary`](https://github.com/bvaughn/react-error-boundary) instead.\n\n* * *\n\n## Alternatives[](#alternatives \"Link for Alternatives \")\n\n### Migrating a simple component from a class to a function[](#migrating-a-simple-component-from-a-class-to-a-function \"Link for Migrating a simple component from a class to a function \")\n\nTypically, you will [define components as functions](https://react.dev/learn/your-first-component#defining-a-component) instead.\n\nFor example, suppose you‚Äôre converting this `Greeting` class component to a function:\n\nDefine a function called `Greeting`. This is where you will move the body of your `render` function.\n\n```\nfunction Greeting() {// ... move the code from the render method here ...}\n```\n\nInstead of `this.props.name`, define the `name` prop [using the destructuring syntax](https://react.dev/learn/passing-props-to-a-component) and read it directly:\n\n```\nfunction Greeting({ name }) {return <h1>Hello, {name}!</h1>;}\n```\n\nHere is a complete example:\n\n* * *\n\n### Migrating a component with state from a class to a function[](#migrating-a-component-with-state-from-a-class-to-a-function \"Link for Migrating a component with state from a class to a function \")\n\nSuppose you‚Äôre converting this `Counter` class component to a function:\n\nStart by declaring a function with the necessary [state variables:](https://react.dev/reference/react/useState#adding-state-to-a-component)\n\n```\nimport { useState } from 'react';function Counter() {const [name, setName] = useState('Taylor');const [age, setAge] = useState(42);// ...\n```\n\nNext, convert the event handlers:\n\n```\nfunction Counter() {const [name, setName] = useState('Taylor');const [age, setAge] = useState(42);function handleNameChange(e) {setName(e.target.value);}function handleAgeChange() {setAge(age + 1);}// ...\n```\n\nFinally, replace all references starting with `this` with the variables and functions you defined in your component. For example, replace `this.state.age` with `age`, and replace `this.handleNameChange` with `handleNameChange`.\n\nHere is a fully converted component:\n\n* * *\n\n### Migrating a component with lifecycle methods from a class to a function[](#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function \"Link for Migrating a component with lifecycle methods from a class to a function \")\n\nSuppose you‚Äôre converting this `ChatRoom` class component with lifecycle methods to a function:\n\nFirst, verify that your [`componentWillUnmount`](#componentwillunmount) does the opposite of [`componentDidMount`.](#componentdidmount) In the above example, that‚Äôs true: it disconnects the connection that `componentDidMount` sets up. If such logic is missing, add it first.\n\nNext, verify that your [`componentDidUpdate`](#componentdidupdate) method handles changes to any props and state you‚Äôre using in `componentDidMount`. In the above example, `componentDidMount` calls `setupConnection` which reads `this.state.serverUrl` and `this.props.roomId`. This is why `componentDidUpdate` checks whether `this.state.serverUrl` and `this.props.roomId` have changed, and resets the connection if they did. If your `componentDidUpdate` logic is missing or doesn‚Äôt handle changes to all relevant props and state, fix that first.\n\nIn the above example, the logic inside the lifecycle methods connects the component to a system outside of React (a chat server). To connect a component to an external system, [describe this logic as a single Effect:](https://react.dev/reference/react/useEffect#connecting-to-an-external-system)\n\n```\nimport { useState, useEffect } from 'react';function ChatRoom({ roomId }) {const [serverUrl, setServerUrl] = useState('https://localhost:1234');useEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => {connection.disconnect();};}, [serverUrl, roomId]);// ...}\n```\n\nThis [`useEffect`](https://react.dev/reference/react/useEffect) call is equivalent to the logic in the lifecycle methods above. If your lifecycle methods do multiple unrelated things, [split them into multiple independent Effects.](https://react.dev/learn/removing-effect-dependencies#is-your-effect-doing-several-unrelated-things) Here is a complete example you can play with:\n\n### Note\n\n* * *\n\n### Migrating a component with context from a class to a function[](#migrating-a-component-with-context-from-a-class-to-a-function \"Link for Migrating a component with context from a class to a function \")\n\nIn this example, the `Panel` and `Button` class components read [context](https://react.dev/learn/passing-data-deeply-with-context) from [`this.context`:](#context)\n\nWhen you convert them to function components, replace `this.context` with [`useContext`](https://react.dev/reference/react/useContext) calls:",
  "title": "Component ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/createElement",
  "markdown": "# createElement ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`createElement` lets you create a React element. It serves as an alternative to writing [JSX.](https://react.dev/learn/writing-markup-with-jsx)\n\n```\nconst element = createElement(type, props, ...children)\n```\n\n*   [Reference](#reference)\n    *   [`createElement(type, props, ...children)`](#createelement)\n*   [Usage](#usage)\n    *   [Creating an element without JSX](#creating-an-element-without-jsx)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `createElement(type, props, ...children)`[](#createelement \"Link for this heading\")\n\nCall `createElement` to create a React element with the given `type`, `props`, and `children`.\n\n```\nimport { createElement } from 'react';function Greeting({ name }) {return createElement('h1',{ className: 'greeting' },'Hello');}\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `type`: The `type` argument must be a valid React component type. For example, it could be a tag name string (such as `'div'` or `'span'`), or a React component (a function, a class, or a special component like [`Fragment`](https://react.dev/reference/react/Fragment)).\n    \n*   `props`: The `props` argument must either be an object or `null`. If you pass `null`, it will be treated the same as an empty object. React will create an element with props matching the `props` you have passed. Note that `ref` and `key` from your `props` object are special and will _not_ be available as `element.props.ref` and `element.props.key` on the returned `element`. They will be available as `element.ref` and `element.key`.\n    \n*   **optional** `...children`: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers, [portals](https://react.dev/reference/react-dom/createPortal), empty nodes (`null`, `undefined`, `true`, and `false`), and arrays of React nodes.\n    \n\n#### Returns[](#returns \"Link for Returns \")\n\n`createElement` returns a React element object with a few properties:\n\n*   `type`: The `type` you have passed.\n*   `props`: The `props` you have passed except for `ref` and `key`. If the `type` is a component with legacy `type.defaultProps`, then any missing or undefined `props` will get the values from `type.defaultProps`.\n*   `ref`: The `ref` you have passed. If missing, `null`.\n*   `key`: The `key` you have passed, coerced to a string. If missing, `null`.\n\nUsually, you‚Äôll return the element from your component or make it a child of another element. Although you may read the element‚Äôs properties, it‚Äôs best to treat every element as opaque after it‚Äôs created, and only render it.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   You must **treat React elements and their props as [immutable](https://en.wikipedia.org/wiki/Immutable_object)** and never change their contents after creation. In development, React will [freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) the returned element and its `props` property shallowly to enforce this.\n    \n*   When you use JSX, **you must start a tag with a capital letter to render your own custom component.** In other words, `<Something />` is equivalent to `createElement(Something)`, but `<something />` (lowercase) is equivalent to `createElement('something')` (note it‚Äôs a string, so it will be treated as a built-in HTML tag).\n    \n*   You should only **pass children as multiple arguments to `createElement` if they are all statically known,** like `createElement('h1', {}, child1, child2, child3)`. If your children are dynamic, pass the entire array as the third argument: `createElement('ul', {}, listItems)`. This ensures that React will [warn you about missing `key`s](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) for any dynamic lists. For static lists this is not necessary because they never reorder.\n    \n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Creating an element without JSX[](#creating-an-element-without-jsx \"Link for Creating an element without JSX \")\n\nIf you don‚Äôt like [JSX](https://react.dev/learn/writing-markup-with-jsx) or can‚Äôt use it in your project, you can use `createElement` as an alternative.\n\nTo create an element without JSX, call `createElement` with some type, props, and children:\n\n```\nimport { createElement } from 'react';function Greeting({ name }) {return createElement('h1',{ className: 'greeting' },'Hello ',createElement('i', null, name),'. Welcome!');}\n```\n\nThe children are optional, and you can pass as many as you need (the example above has three children). This code will display a `<h1>` header with a greeting. For comparison, here is the same example rewritten with JSX:\n\n```\nfunction Greeting({ name }) {return (<h1 className=\"greeting\">Hello <i>{name}</i>. Welcome!</h1>);}\n```\n\nTo render your own React component, pass a function like `Greeting` as the type instead of a string like `'h1'`:\n\n```\nexport default function App() {return createElement(Greeting, { name: 'Taylor' });}\n```\n\nWith JSX, it would look like this:\n\n```\nexport default function App() {return <Greeting name=\"Taylor\" />;}\n```\n\nHere is a complete example written with `createElement`:\n\nBoth coding styles are fine, so you can use whichever one you prefer for your project. The main benefit of using JSX compared to `createElement` is that it‚Äôs easy to see which closing tag corresponds to which opening tag.\n\n##### Deep Dive\n\n#### What is a React element, exactly?[](#what-is-a-react-element-exactly \"Link for What is a React element, exactly? \")\n\nAn element is a lightweight description of a piece of the user interface. For example, both `<Greeting name=\"Taylor\" />` and `createElement(Greeting, { name: 'Taylor' })` produce an object like this:\n\n```\n// Slightly simplified{  type: Greeting,props: {    name: 'Taylor'},  key: null,ref: null,}\n```\n\n**Note that creating this object does not render the `Greeting` component or create any DOM elements.**\n\nA React element is more like a description‚Äîan instruction for React to later render the `Greeting` component. By returning this object from your `App` component, you tell React what to do next.\n\nCreating elements is extremely cheap so you don‚Äôt need to try to optimize or avoid it.",
  "title": "createElement ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/isValidElement",
  "markdown": "# isValidElement ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`isValidElement` checks whether a value is a React element.\n\n```\nconst isElement = isValidElement(value)\n```\n\n*   [Reference](#reference)\n    *   [`isValidElement(value)`](#isvalidelement)\n*   [Usage](#usage)\n    *   [Checking if something is a React element](#checking-if-something-is-a-react-element)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `isValidElement(value)`[](#isvalidelement \"Link for this heading\")\n\nCall `isValidElement(value)` to check whether `value` is a React element.\n\n```\nimport { isValidElement, createElement } from 'react';// ‚úÖ React elementsconsole.log(isValidElement(<p />)); // trueconsole.log(isValidElement(createElement('p'))); // true// ‚ùå Not React elementsconsole.log(isValidElement(25)); // falseconsole.log(isValidElement('Hello')); // falseconsole.log(isValidElement({ age: 42 })); // false\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `value`: The `value` you want to check. It can be any a value of any type.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`isValidElement` returns `true` if the `value` is a React element. Otherwise, it returns `false`.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   **Only [JSX tags](https://react.dev/learn/writing-markup-with-jsx) and objects returned by [`createElement`](https://react.dev/reference/react/createElement) are considered to be React elements.** For example, even though a number like `42` is a valid React _node_ (and can be returned from a component), it is not a valid React element. Arrays and portals created with [`createPortal`](https://react.dev/reference/react-dom/createPortal) are also _not_ considered to be React elements.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Checking if something is a React element[](#checking-if-something-is-a-react-element \"Link for Checking if something is a React element \")\n\nCall `isValidElement` to check if some value is a _React element._\n\nReact elements are:\n\n*   Values produced by writing a [JSX tag](https://react.dev/learn/writing-markup-with-jsx)\n*   Values produced by calling [`createElement`](https://react.dev/reference/react/createElement)\n\nFor React elements, `isValidElement` returns `true`:\n\n```\nimport { isValidElement, createElement } from 'react';// ‚úÖ JSX tags are React elementsconsole.log(isValidElement(<p />)); // trueconsole.log(isValidElement(<MyComponent />)); // true// ‚úÖ Values returned by createElement are React elementsconsole.log(isValidElement(createElement('p'))); // trueconsole.log(isValidElement(createElement(MyComponent))); // true\n```\n\nAny other values, such as strings, numbers, or arbitrary objects and arrays, are not React elements.\n\nFor them, `isValidElement` returns `false`:\n\n```\n// ‚ùå These are *not* React elementsconsole.log(isValidElement(null)); // falseconsole.log(isValidElement(25)); // falseconsole.log(isValidElement('Hello')); // falseconsole.log(isValidElement({ age: 42 })); // falseconsole.log(isValidElement([<div />, <div />])); // falseconsole.log(isValidElement(MyComponent)); // false\n```\n\nIt is very uncommon to need `isValidElement`. It‚Äôs mostly useful if you‚Äôre calling another API that _only_ accepts elements (like [`cloneElement`](https://react.dev/reference/react/cloneElement) does) and you want to avoid an error when your argument is not a React element.\n\nUnless you have some very specific reason to add an `isValidElement` check, you probably don‚Äôt need it.\n\n##### Deep Dive\n\n#### React elements vs React nodes[](#react-elements-vs-react-nodes \"Link for React elements vs React nodes \")\n\nWhen you write a component, you can return any kind of _React node_ from it:\n\n```\nfunction MyComponent() {// ... you can return any React node ...}\n```\n\nA React node can be:\n\n*   A React element created like `<div />` or `createElement('div')`\n*   A portal created with [`createPortal`](https://react.dev/reference/react-dom/createPortal)\n*   A string\n*   A number\n*   `true`, `false`, `null`, or `undefined` (which are not displayed)\n*   An array of other React nodes\n\n**Note `isValidElement` checks whether the argument is a _React element,_ not whether it‚Äôs a React node.** For example, `42` is not a valid React element. However, it is a perfectly valid React node:\n\n```\nfunction MyComponent() {return 42; // It's ok to return a number from component}\n```\n\nThis is why you shouldn‚Äôt use `isValidElement` as a way to check whether something can be rendered.",
  "title": "isValidElement ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/createRef",
  "markdown": "# createRef ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`createRef` creates a [ref](https://react.dev/learn/referencing-values-with-refs) object which can contain arbitrary value.\n\n```\nclass MyInput extends Component {inputRef = createRef();// ...}\n```\n\n`createRef` takes no parameters.\n\nTo declare a ref inside a [class component,](https://react.dev/reference/react/Component) call `createRef` and assign its result to a class field:\n\nIf you now pass `ref={this.inputRef}` to an `<input>` in your JSX, React will populate `this.inputRef.current` with the input DOM node. For example, here is how you make a button that focuses the input:",
  "title": "createRef ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/PureComponent",
  "markdown": "# PureComponent ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Pitfall\n\nWe recommend defining components as functions instead of classes. [See how to migrate.](#alternatives)\n\n`PureComponent` is similar to [`Component`](https://react.dev/reference/react/Component) but it skips re-renders for same props and state. Class components are still supported by React, but we don‚Äôt recommend using them in new code.\n\n```\nclass Greeting extends PureComponent {render() {return <h1>Hello, {this.props.name}!</h1>;}}\n```\n\n*   [Reference](#reference)\n    *   [`PureComponent`](#purecomponent)\n*   [Usage](#usage)\n    *   [Skipping unnecessary re-renders for class components](#skipping-unnecessary-re-renders-for-class-components)\n*   [Alternatives](#alternatives)\n    *   [Migrating from a `PureComponent` class component to a function](#migrating-from-a-purecomponent-class-component-to-a-function)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `PureComponent`[](#purecomponent \"Link for this heading\")\n\nTo skip re-rendering a class component for same props and state, extend `PureComponent` instead of [`Component`:](https://react.dev/reference/react/Component)\n\n```\nimport { PureComponent } from 'react';class Greeting extends PureComponent {render() {return <h1>Hello, {this.props.name}!</h1>;}}\n```\n\n`PureComponent` is a subclass of `Component` and supports [all the `Component` APIs.](https://react.dev/reference/react/Component#reference) Extending `PureComponent` is equivalent to defining a custom [`shouldComponentUpdate`](https://react.dev/reference/react/Component#shouldcomponentupdate) method that shallowly compares props and state.\n\n[See more examples below.](#usage)\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Skipping unnecessary re-renders for class components[](#skipping-unnecessary-re-renders-for-class-components \"Link for Skipping unnecessary re-renders for class components \")\n\nReact normally re-renders a component whenever its parent re-renders. As an optimization, you can create a component that React will not re-render when its parent re-renders so long as its new props and state are the same as the old props and state. [Class components](https://react.dev/reference/react/Component) can opt into this behavior by extending `PureComponent`:\n\n```\nclass Greeting extends PureComponent {render() {return <h1>Hello, {this.props.name}!</h1>;}}\n```\n\nA React component should always have [pure rendering logic.](https://react.dev/learn/keeping-components-pure) This means that it must return the same output if its props, state, and context haven‚Äôt changed. By using `PureComponent`, you are telling React that your component complies with this requirement, so React doesn‚Äôt need to re-render as long as its props and state haven‚Äôt changed. However, your component will still re-render if a context that it‚Äôs using changes.\n\nIn this example, notice that the `Greeting` component re-renders whenever `name` is changed (because that‚Äôs one of its props), but not when `address` is changed (because it‚Äôs not passed to `Greeting` as a prop):\n\n### Pitfall\n\nWe recommend defining components as functions instead of classes. [See how to migrate.](#alternatives)\n\n* * *\n\n## Alternatives[](#alternatives \"Link for Alternatives \")\n\n### Migrating from a `PureComponent` class component to a function[](#migrating-from-a-purecomponent-class-component-to-a-function \"Link for this heading\")\n\nWe recommend using function components instead of [class components](https://react.dev/reference/react/Component) in new code. If you have some existing class components using `PureComponent`, here is how you can convert them. This is the original code:\n\n### Note",
  "title": "PureComponent ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/createFactory",
  "markdown": "# createFactory ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Deprecated\n\nThis API will be removed in a future major version of React. [See the alternatives.](#alternatives)\n\n`createFactory` lets you create a function that produces React elements of a given type.\n\n```\nconst factory = createFactory(type)\n```\n\n*   [Reference](#reference)\n    *   [`createFactory(type)`](#createfactory)\n*   [Usage](#usage)\n    *   [Creating React elements with a factory](#creating-react-elements-with-a-factory)\n*   [Alternatives](#alternatives)\n    *   [Copying `createFactory` into your project](#copying-createfactory-into-your-project)\n    *   [Replacing `createFactory` with `createElement`](#replacing-createfactory-with-createelement)\n    *   [Replacing `createFactory` with JSX](#replacing-createfactory-with-jsx)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `createFactory(type)`[](#createfactory \"Link for this heading\")\n\nCall `createFactory(type)` to create a factory function which produces React elements of a given `type`.\n\n```\nimport { createFactory } from 'react';const button = createFactory('button');\n```\n\nThen you can use it to create React elements without JSX:\n\n```\nexport default function App() {return button({onClick: () => {alert('Clicked!')}}, 'Click me');}\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `type`: The `type` argument must be a valid React component type. For example, it could be a tag name string (such as `'div'` or `'span'`), or a React component (a function, a class, or a special component like [`Fragment`](https://react.dev/reference/react/Fragment)).\n\n#### Returns[](#returns \"Link for Returns \")\n\nReturns a factory function. That factory function receives a `props` object as the first argument, followed by a list of `...children` arguments, and returns a React element with the given `type`, `props` and `children`.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Creating React elements with a factory[](#creating-react-elements-with-a-factory \"Link for Creating React elements with a factory \")\n\nAlthough most React projects use [JSX](https://react.dev/learn/writing-markup-with-jsx) to describe the user interface, JSX is not required. In the past, `createFactory` used to be one of the ways you could describe the user interface without JSX.\n\nCall `createFactory` to create a _factory function_ for a specific element type like `'button'`:\n\n```\nimport { createFactory } from 'react';const button = createFactory('button');\n```\n\nCalling that factory function will produce React elements with the props and children you have provided:\n\nThis is how `createFactory` was used as an alternative to JSX. However, `createFactory` is deprecated, and you should not call `createFactory` in any new code. See how to migrate away from `createFactory` below.\n\n* * *\n\n## Alternatives[](#alternatives \"Link for Alternatives \")\n\n### Copying `createFactory` into your project[](#copying-createfactory-into-your-project \"Link for this heading\")\n\nIf your project has many `createFactory` calls, copy this `createFactory.js` implementation into your project:\n\nThis lets you keep all of your code unchanged except the imports.\n\n* * *\n\n### Replacing `createFactory` with `createElement`[](#replacing-createfactory-with-createelement \"Link for this heading\")\n\nIf you have a few `createFactory` calls that you don‚Äôt mind porting manually, and you don‚Äôt want to use JSX, you can replace every call a factory function with a [`createElement`](https://react.dev/reference/react/createElement) call. For example, you can replace this code:\n\n```\nimport { createFactory } from 'react';const button = createFactory('button');export default function App() {return button({onClick: () => {alert('Clicked!')}}, 'Click me');}\n```\n\nwith this code:\n\n```\nimport { createElement } from 'react';export default function App() {return createElement('button', {onClick: () => {alert('Clicked!')}}, 'Click me');}\n```\n\nHere is a complete example of using React without JSX:\n\n* * *\n\n### Replacing `createFactory` with JSX[](#replacing-createfactory-with-jsx \"Link for this heading\")\n\nFinally, you can use JSX instead of `createFactory`. This is the most common way to use React:\n\n### Pitfall\n\nSometimes, your existing code might pass some variable as a `type` instead of a constant like `'button'`:\n\n```\nfunction Heading({ isSubheading, ...props }) {const type = isSubheading ? 'h2' : 'h1';const factory = createFactory(type);return factory(props);}\n```\n\nTo do the same in JSX, you need to rename your variable to start with an uppercase letter like `Type`:\n\n```\nfunction Heading({ isSubheading, ...props }) {const Type = isSubheading ? 'h2' : 'h1';return <Type {...props} />;}\n```\n\nOtherwise React will interpret `<type>` as a built-in HTML tag because it is lowercase.",
  "title": "createFactory ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/hooks",
  "markdown": "# Built-in React Hooks ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n_Hooks_ let you use different React features from your components. You can either use the built-in Hooks or combine them to build your own. This page lists all built-in Hooks in React.\n\n* * *\n\n## State Hooks[](#state-hooks \"Link for State Hooks \")\n\n_State_ lets a component [‚Äúremember‚Äù information like user input.](https://react.dev/learn/state-a-components-memory) For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.\n\nTo add state to a component, use one of these Hooks:\n\n*   [`useState`](https://react.dev/reference/react/useState) declares a state variable that you can update directly.\n*   [`useReducer`](https://react.dev/reference/react/useReducer) declares a state variable with the update logic inside a [reducer function.](https://react.dev/learn/extracting-state-logic-into-a-reducer)\n\n```\nfunction ImageGallery() {const [index, setIndex] = useState(0);// ...\n```\n\n* * *\n\n## Context Hooks[](#context-hooks \"Link for Context Hooks \")\n\n_Context_ lets a component [receive information from distant parents without passing it as props.](https://react.dev/learn/passing-props-to-a-component) For example, your app‚Äôs top-level component can pass the current UI theme to all components below, no matter how deep.\n\n*   [`useContext`](https://react.dev/reference/react/useContext) reads and subscribes to a context.\n\n```\nfunction Button() {const theme = useContext(ThemeContext);// ...\n```\n\n* * *\n\n## Ref Hooks[](#ref-hooks \"Link for Ref Hooks \")\n\n_Refs_ let a component [hold some information that isn‚Äôt used for rendering,](https://react.dev/learn/referencing-values-with-refs) like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an ‚Äúescape hatch‚Äù from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.\n\n*   [`useRef`](https://react.dev/reference/react/useRef) declares a ref. You can hold any value in it, but most often it‚Äôs used to hold a DOM node.\n*   [`useImperativeHandle`](https://react.dev/reference/react/useImperativeHandle) lets you customize the ref exposed by your component. This is rarely used.\n\n```\nfunction Form() {const inputRef = useRef(null);// ...\n```\n\n* * *\n\n## Effect Hooks[](#effect-hooks \"Link for Effect Hooks \")\n\n_Effects_ let a component [connect to and synchronize with external systems.](https://react.dev/learn/synchronizing-with-effects) This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.\n\n*   [`useEffect`](https://react.dev/reference/react/useEffect) connects a component to an external system.\n\n```\nfunction ChatRoom({ roomId }) {useEffect(() => {const connection = createConnection(roomId);connection.connect();return () => connection.disconnect();}, [roomId]);// ...\n```\n\nEffects are an ‚Äúescape hatch‚Äù from the React paradigm. Don‚Äôt use Effects to orchestrate the data flow of your application. If you‚Äôre not interacting with an external system, [you might not need an Effect.](https://react.dev/learn/you-might-not-need-an-effect)\n\nThere are two rarely used variations of `useEffect` with differences in timing:\n\n*   [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect) fires before the browser repaints the screen. You can measure layout here.\n*   [`useInsertionEffect`](https://react.dev/reference/react/useInsertionEffect) fires before React makes changes to the DOM. Libraries can insert dynamic CSS here.\n\n* * *\n\n## Performance Hooks[](#performance-hooks \"Link for Performance Hooks \")\n\nA common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.\n\nTo skip calculations and unnecessary re-rendering, use one of these Hooks:\n\n*   [`useMemo`](https://react.dev/reference/react/useMemo) lets you cache the result of an expensive calculation.\n*   [`useCallback`](https://react.dev/reference/react/useCallback) lets you cache a function definition before passing it down to an optimized component.\n\n```\nfunction TodoList({ todos, tab, theme }) {const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);// ...}\n```\n\nSometimes, you can‚Äôt skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don‚Äôt need to block the user interface (like updating a chart).\n\nTo prioritize rendering, use one of these Hooks:\n\n*   [`useTransition`](https://react.dev/reference/react/useTransition) lets you mark a state transition as non-blocking and allow other updates to interrupt it.\n*   [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue) lets you defer updating a non-critical part of the UI and let other parts update first.\n\n* * *\n\n## Other Hooks[](#other-hooks \"Link for Other Hooks \")\n\nThese Hooks are mostly useful to library authors and aren‚Äôt commonly used in the application code.\n\n*   [`useDebugValue`](https://react.dev/reference/react/useDebugValue) lets you customize the label React DevTools displays for your custom Hook.\n*   [`useId`](https://react.dev/reference/react/useId) lets a component associate a unique ID with itself. Typically used with accessibility APIs.\n*   [`useSyncExternalStore`](https://react.dev/reference/react/useSyncExternalStore) lets a component subscribe to an external store.\n\n*   [`useActionState`](https://react.dev/reference/react/useActionState) allows you to manage state of actions.\n\n* * *\n\n## Your own Hooks[](#your-own-hooks \"Link for Your own Hooks \")\n\nYou can also [define your own custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks#extracting-your-own-custom-hook-from-a-component) as JavaScript functions.",
  "title": "Built-in React Hooks ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useActionState",
  "markdown": "# useActionState ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Canary\n\nThe `useActionState` Hook is currently only available in React‚Äôs Canary and experimental channels. Learn more about [release channels here](https://react.dev/community/versioning-policy#all-release-channels). In addition, you need to use a framework that supports [React Server Components](https://react.dev/reference/rsc/use-client) to get the full benefit of `useActionState`.\n\n### Note\n\nIn earlier React Canary versions, this API was part of React DOM and called `useFormState`.\n\n`useActionState` is a Hook that allows you to update state based on the result of a form action.\n\n```\nconst [state, formAction] = useActionState(fn, initialState, permalink?);\n```\n\n*   [Reference](#reference)\n    *   [`useActionState(action, initialState, permalink?)`](#useactionstate)\n*   [Usage](#usage)\n    *   [Using information returned by a form action](#using-information-returned-by-a-form-action)\n*   [Troubleshooting](#troubleshooting)\n    *   [My action can no longer read the submitted form data](#my-action-can-no-longer-read-the-submitted-form-data)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useActionState(action, initialState, permalink?)`[](#useactionstate \"Link for this heading\")\n\nCall `useActionState` at the top level of your component to create component state that is updated [when a form action is invoked](https://react.dev/reference/react-dom/components/form). You pass `useActionState` an existing form action function as well as an initial state, and it returns a new action that you use in your form, along with the latest form state. The latest form state is also passed to the function that you provided.\n\n```\nimport { useActionState } from \"react\";async function increment(previousState, formData) {return previousState + 1;}function StatefulForm({}) {const [state, formAction] = useActionState(increment, 0);return (<form>{state}<button formAction={formAction}>Increment</button></form>)}\n```\n\nThe form state is the value returned by the action when the form was last submitted. If the form has not yet been submitted, it is the initial state that you pass.\n\nIf used with a Server Action, `useActionState` allows the server‚Äôs response from submitting the form to be shown even before hydration has completed.\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `fn`: The function to be called when the form is submitted or button pressed. When the function is called, it will receive the previous state of the form (initially the `initialState` that you pass, subsequently its previous return value) as its initial argument, followed by the arguments that a form action normally receives.\n*   `initialState`: The value you want the state to be initially. It can be any serializable value. This argument is ignored after the action is first invoked.\n*   **optional** `permalink`: A string containing the unique page URL that this form modifies. For use on pages with dynamic content (eg: feeds) in conjunction with progressive enhancement: if `fn` is a [server action](https://react.dev/reference/rsc/use-server) and the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL, rather than the current page‚Äôs URL. Ensure that the same form component is rendered on the destination page (including the same action `fn` and `permalink`) so that React knows how to pass the state through. Once the form has been hydrated, this parameter has no effect.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`useActionState` returns an array with exactly two values:\n\n1.  The current state. During the first render, it will match the `initialState` you have passed. After the action is invoked, it will match the value returned by the action.\n2.  A new action that you can pass as the `action` prop to your `form` component or `formAction` prop to any `button` component within the form.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   When used with a framework that supports React Server Components, `useActionState` lets you make forms interactive before JavaScript has executed on the client. When used without Server Components, it is equivalent to component local state.\n*   The function passed to `useActionState` receives an extra argument, the previous or initial state, as its first argument. This makes its signature different than if it were used directly as a form action without using `useActionState`.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Using information returned by a form action[](#using-information-returned-by-a-form-action \"Link for Using information returned by a form action \")\n\nCall `useActionState` at the top level of your component to access the return value of an action from the last time a form was submitted.\n\n```\nimport { useActionState } from 'react';import { action } from './actions.js';function MyComponent() {const [state, formAction] = useActionState(action, null);// ...return (<form action={formAction}>{/* ... */}</form>);}\n```\n\n`useActionState` returns an array with exactly two items:\n\n1.  The current state of the form, which is initially set to the initial state you provided, and after the form is submitted is set to the return value of the action you provided.\n2.  A new action that you pass to `<form>` as its `action` prop.\n\nWhen the form is submitted, the action function that you provided will be called. Its return value will become the new current state of the form.\n\nThe action that you provide will also receive a new first argument, namely the current state of the form. The first time the form is submitted, this will be the initial state you provided, while with subsequent submissions, it will be the return value from the last time the action was called. The rest of the arguments are the same as if `useActionState` had not been used.\n\n```\nfunction action(currentState, formData) {// ...return 'next state';}\n```\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### My action can no longer read the submitted form data[](#my-action-can-no-longer-read-the-submitted-form-data \"Link for My action can no longer read the submitted form data \")\n\nWhen you wrap an action with `useActionState`, it gets an extra argument _as its first argument_. The submitted form data is therefore its _second_ argument instead of its first as it would usually be. The new first argument that gets added is the current state of the form.\n\n```\nfunction action(currentState, formData) {// ...}\n```",
  "title": "useActionState ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useDebugValue",
  "markdown": "# useDebugValue ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useDebugValue` is a React Hook that lets you add a label to a custom Hook in [React DevTools.](https://react.dev/learn/react-developer-tools)\n\n```\nuseDebugValue(value, format?)\n```\n\n*   [Reference](#reference)\n    *   [`useDebugValue(value, format?)`](#usedebugvalue)\n*   [Usage](#usage)\n    *   [Adding a label to a custom Hook](#adding-a-label-to-a-custom-hook)\n    *   [Deferring formatting of a debug value](#deferring-formatting-of-a-debug-value)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useDebugValue(value, format?)`[](#usedebugvalue \"Link for this heading\")\n\nCall `useDebugValue` at the top level of your [custom Hook](https://react.dev/learn/reusing-logic-with-custom-hooks) to display a readable debug value:\n\n```\nimport { useDebugValue } from 'react';function useOnlineStatus() {// ...useDebugValue(isOnline ? 'Online' : 'Offline');// ...}\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `value`: The value you want to display in React DevTools. It can have any type.\n*   **optional** `format`: A formatting function. When the component is inspected, React DevTools will call the formatting function with the `value` as the argument, and then display the returned formatted value (which may have any type). If you don‚Äôt specify the formatting function, the original `value` itself will be displayed.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`useDebugValue` does not return anything.\n\n## Usage[](#usage \"Link for Usage \")\n\n### Adding a label to a custom Hook[](#adding-a-label-to-a-custom-hook \"Link for Adding a label to a custom Hook \")\n\nCall `useDebugValue` at the top level of your [custom Hook](https://react.dev/learn/reusing-logic-with-custom-hooks) to display a readable debug value for [React DevTools.](https://react.dev/learn/react-developer-tools)\n\n```\nimport { useDebugValue } from 'react';function useOnlineStatus() {// ...useDebugValue(isOnline ? 'Online' : 'Offline');// ...}\n```\n\nThis gives components calling `useOnlineStatus` a label like `OnlineStatus: \"Online\"` when you inspect them:\n\n![A screenshot of React DevTools showing the debug value](https://react.dev/images/docs/react-devtools-usedebugvalue.png)\n\nWithout the `useDebugValue` call, only the underlying data (in this example, `true`) would be displayed.\n\nimport { useSyncExternalStore, useDebugValue } from 'react';\n\nexport function useOnlineStatus() {\n  const isOnline = useSyncExternalStore(subscribe, () \\=> navigator.onLine, () \\=> true);\n  useDebugValue(isOnline ? 'Online' : 'Offline');\n  return isOnline;\n}\n\nfunction subscribe(callback) {\n  window.addEventListener('online', callback);\n  window.addEventListener('offline', callback);\n  return () \\=> {\n    window.removeEventListener('online', callback);\n    window.removeEventListener('offline', callback);\n  };\n}\n\n### Note\n\nDon‚Äôt add debug values to every custom Hook. It‚Äôs most valuable for custom Hooks that are part of shared libraries and that have a complex internal data structure that‚Äôs difficult to inspect.\n\n* * *\n\n### Deferring formatting of a debug value[](#deferring-formatting-of-a-debug-value \"Link for Deferring formatting of a debug value \")\n\nYou can also pass a formatting function as the second argument to `useDebugValue`:\n\n```\nuseDebugValue(date, date => date.toDateString());\n```\n\nYour formatting function will receive the debug value as a parameter and should return a formatted display value. When your component is inspected, React DevTools will call this function and display its result.\n\nThis lets you avoid running potentially expensive formatting logic unless the component is actually inspected. For example, if `date` is a Date value, this avoids calling `toDateString()` on it for every render.",
  "title": "useDebugValue ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useContext",
  "markdown": "# useContext ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useContext` is a React Hook that lets you read and subscribe to [context](https://react.dev/learn/passing-data-deeply-with-context) from your component.\n\n```\nconst value = useContext(SomeContext)\n```\n\n*   [Reference](#reference)\n    *   [`useContext(SomeContext)`](#usecontext)\n*   [Usage](#usage)\n    *   [Passing data deeply into the tree](#passing-data-deeply-into-the-tree)\n    *   [Updating data passed via context](#updating-data-passed-via-context)\n    *   [Specifying a fallback default value](#specifying-a-fallback-default-value)\n    *   [Overriding context for a part of the tree](#overriding-context-for-a-part-of-the-tree)\n    *   [Optimizing re-renders when passing objects and functions](#optimizing-re-renders-when-passing-objects-and-functions)\n*   [Troubleshooting](#troubleshooting)\n    *   [My component doesn‚Äôt see the value from my provider](#my-component-doesnt-see-the-value-from-my-provider)\n    *   [I am always getting `undefined` from my context although the default value is different](#i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useContext(SomeContext)`[](#usecontext \"Link for this heading\")\n\nCall `useContext` at the top level of your component to read and subscribe to [context.](https://react.dev/learn/passing-data-deeply-with-context)\n\n```\nimport { useContext } from 'react';function MyComponent() {const theme = useContext(ThemeContext);// ...\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `SomeContext`: The context that you‚Äôve previously created with [`createContext`](https://react.dev/reference/react/createContext). The context itself does not hold the information, it only represents the kind of information you can provide or read from components.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`useContext` returns the context value for the calling component. It is determined as the `value` passed to the closest `SomeContext.Provider` above the calling component in the tree. If there is no such provider, then the returned value will be the `defaultValue` you have passed to [`createContext`](https://react.dev/reference/react/createContext) for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   `useContext()` call in a component is not affected by providers returned from the _same_ component. The corresponding `<Context.Provider>` **needs to be _above_** the component doing the `useContext()` call.\n*   React **automatically re-renders** all the children that use a particular context starting from the provider that receives a different `value`. The previous and the next values are compared with the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. Skipping re-renders with [`memo`](https://react.dev/reference/react/memo) does not prevent the children receiving fresh context values.\n*   If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if `SomeContext` that you use to provide context and `SomeContext` that you use to read it are **_exactly_ the same object**, as determined by a `===` comparison.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Passing data deeply into the tree[](#passing-data-deeply-into-the-tree \"Link for Passing data deeply into the tree \")\n\nCall `useContext` at the top level of your component to read and subscribe to [context.](https://react.dev/learn/passing-data-deeply-with-context)\n\n```\nimport { useContext } from 'react';function Button() {const theme = useContext(ThemeContext);// ...\n```\n\n`useContext` returns the context value for the context you passed. To determine the context value, React searches the component tree and finds **the closest context provider above** for that particular context.\n\nTo pass context to a `Button`, wrap it or one of its parent components into the corresponding context provider:\n\n```\nfunction MyPage() {return (<ThemeContext.Provider value=\"dark\"><Form /></ThemeContext.Provider>);}function Form() {// ... renders buttons inside ...}\n```\n\nIt doesn‚Äôt matter how many layers of components there are between the provider and the `Button`. When a `Button` _anywhere_ inside of `Form` calls `useContext(ThemeContext)`, it will receive `\"dark\"` as the value.\n\n### Pitfall\n\n`useContext()` always looks for the closest provider _above_ the component that calls it. It searches upwards and **does not** consider providers in the component from which you‚Äôre calling `useContext()`.\n\nimport { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  return (\n    <ThemeContext.Provider value\\=\"dark\"\\>\n      <Form />\n    </ThemeContext.Provider\\>\n  )\n}\n\nfunction Form() {\n  return (\n    <Panel title\\=\"Welcome\"\\>\n      <Button\\>Sign up</Button\\>\n      <Button\\>Log in</Button\\>\n    </Panel\\>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className\\={className}\\>\n      <h1\\>{title}</h1\\>\n      {children}\n    </section\\>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className\\={className}\\>\n      {children}\n    </button\\>\n  );\n}\n\n* * *\n\n### Updating data passed via context[](#updating-data-passed-via-context \"Link for Updating data passed via context \")\n\nOften, you‚Äôll want the context to change over time. To update context, combine it with [state.](https://react.dev/reference/react/useState) Declare a state variable in the parent component, and pass the current state down as the context value to the provider.\n\n```\nfunction MyPage() {const [theme, setTheme] = useState('dark');return (<ThemeContext.Provider value={theme}><Form /><Button onClick={() => {setTheme('light');}}>        Switch to light theme</Button></ThemeContext.Provider>);}\n```\n\nNow any `Button` inside of the provider will receive the current `theme` value. If you call `setTheme` to update the `theme` value that you pass to the provider, all `Button` components will re-render with the new `'light'` value.\n\n#### Examples of updating context[](#examples-basic \"Link for Examples of updating context\")\n\n#### Updating a value via context[](#updating-a-value-via-context \"Link for this heading\")\n\nIn this example, the `MyApp` component holds a state variable which is then passed to the `ThemeContext` provider. Checking the ‚ÄúDark mode‚Äù checkbox updates the state. Changing the provided value re-renders all the components using that context.\n\nimport { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  const \\[theme, setTheme\\] = useState('light');\n  return (\n    <ThemeContext.Provider value\\={theme}\\>\n      <Form />\n      <label\\>\n        <input\n          type\\=\"checkbox\"\n          checked\\={theme === 'dark'}\n          onChange\\={(e) \\=> {\n            setTheme(e.target.checked ? 'dark' : 'light')\n          }}\n        />\n        Use dark mode\n      </label\\>\n    </ThemeContext.Provider\\>\n  )\n}\n\nfunction Form({ children }) {\n  return (\n    <Panel title\\=\"Welcome\"\\>\n      <Button\\>Sign up</Button\\>\n      <Button\\>Log in</Button\\>\n    </Panel\\>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className\\={className}\\>\n      <h1\\>{title}</h1\\>\n      {children}\n    </section\\>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className\\={className}\\>\n      {children}\n    </button\\>\n  );\n}\n\nNote that `value=\"dark\"` passes the `\"dark\"` string, but `value={theme}` passes the value of the JavaScript `theme` variable with [JSX curly braces.](https://react.dev/learn/javascript-in-jsx-with-curly-braces) Curly braces also let you pass context values that aren‚Äôt strings.\n\n* * *\n\n### Specifying a fallback default value[](#specifying-a-fallback-default-value \"Link for Specifying a fallback default value \")\n\nIf React can‚Äôt find any providers of that particular context in the parent tree, the context value returned by `useContext()` will be equal to the default value that you specified when you [created that context](https://react.dev/reference/react/createContext):\n\n```\nconst ThemeContext = createContext(null);\n```\n\nThe default value **never changes**. If you want to update context, use it with state as [described above.](#updating-data-passed-via-context)\n\nOften, instead of `null`, there is some more meaningful value you can use as a default, for example:\n\n```\nconst ThemeContext = createContext('light');\n```\n\nThis way, if you accidentally render some component without a corresponding provider, it won‚Äôt break. This also helps your components work well in a test environment without setting up a lot of providers in the tests.\n\nIn the example below, the ‚ÄúToggle theme‚Äù button is always light because it‚Äôs **outside any theme context provider** and the default context theme value is `'light'`. Try editing the default theme to be `'dark'`.\n\nimport { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext('light');\n\nexport default function MyApp() {\n  const \\[theme, setTheme\\] = useState('light');\n  return (\n    <\\>\n      <ThemeContext.Provider value\\={theme}\\>\n        <Form />\n      </ThemeContext.Provider\\>\n      <Button onClick\\={() \\=> {\n        setTheme(theme === 'dark' ? 'light' : 'dark');\n      }}\\>\n        Toggle theme\n      </Button\\>\n    </\\>\n  )\n}\n\nfunction Form({ children }) {\n  return (\n    <Panel title\\=\"Welcome\"\\>\n      <Button\\>Sign up</Button\\>\n      <Button\\>Log in</Button\\>\n    </Panel\\>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className\\={className}\\>\n      <h1\\>{title}</h1\\>\n      {children}\n    </section\\>\n  )\n}\n\nfunction Button({ children, onClick }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className\\={className} onClick\\={onClick}\\>\n      {children}\n    </button\\>\n  );\n}\n\n* * *\n\n### Overriding context for a part of the tree[](#overriding-context-for-a-part-of-the-tree \"Link for Overriding context for a part of the tree \")\n\nYou can override the context for a part of the tree by wrapping that part in a provider with a different value.\n\n```\n<ThemeContext.Provider value=\"dark\">  ...<ThemeContext.Provider value=\"light\"><Footer /></ThemeContext.Provider>  ...</ThemeContext.Provider>\n```\n\nYou can nest and override providers as many times as you need.\n\n#### Examples of overriding context[](#examples \"Link for Examples of overriding context\")\n\n#### Overriding a theme[](#overriding-a-theme \"Link for this heading\")\n\nHere, the button _inside_ the `Footer` receives a different context value (`\"light\"`) than the buttons outside (`\"dark\"`).\n\nimport { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  return (\n    <ThemeContext.Provider value\\=\"dark\"\\>\n      <Form />\n    </ThemeContext.Provider\\>\n  )\n}\n\nfunction Form() {\n  return (\n    <Panel title\\=\"Welcome\"\\>\n      <Button\\>Sign up</Button\\>\n      <Button\\>Log in</Button\\>\n      <ThemeContext.Provider value\\=\"light\"\\>\n        <Footer />\n      </ThemeContext.Provider\\>\n    </Panel\\>\n  );\n}\n\nfunction Footer() {\n  return (\n    <footer\\>\n      <Button\\>Settings</Button\\>\n    </footer\\>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className\\={className}\\>\n      {title && <h1\\>{title}</h1\\>}\n      {children}\n    </section\\>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className\\={className}\\>\n      {children}\n    </button\\>\n  );\n}\n\n* * *\n\n### Optimizing re-renders when passing objects and functions[](#optimizing-re-renders-when-passing-objects-and-functions \"Link for Optimizing re-renders when passing objects and functions \")\n\nYou can pass any values via context, including objects and functions.\n\n```\nfunction MyApp() {const [currentUser, setCurrentUser] = useState(null);function login(response) {storeCredentials(response.credentials);setCurrentUser(response.user);}return (<AuthContext.Provider value={{ currentUser, login }}><Page /></AuthContext.Provider>);}\n```\n\nHere, the context value is a JavaScript object with two properties, one of which is a function. Whenever `MyApp` re-renders (for example, on a route update), this will be a _different_ object pointing at a _different_ function, so React will also have to re-render all components deep in the tree that call `useContext(AuthContext)`.\n\nIn smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like `currentUser`, has not changed. To help React take advantage of that fact, you may wrap the `login` function with [`useCallback`](https://react.dev/reference/react/useCallback) and wrap the object creation into [`useMemo`](https://react.dev/reference/react/useMemo). This is a performance optimization:\n\n```\nimport { useCallback, useMemo } from 'react';function MyApp() {const [currentUser, setCurrentUser] = useState(null);const login = useCallback((response) => {storeCredentials(response.credentials);setCurrentUser(response.user);}, []);const contextValue = useMemo(() => ({currentUser,login}), [currentUser, login]);return (<AuthContext.Provider value={contextValue}><Page /></AuthContext.Provider>);}\n```\n\nAs a result of this change, even if `MyApp` needs to re-render, the components calling `useContext(AuthContext)` won‚Äôt need to re-render unless `currentUser` has changed.\n\nRead more about [`useMemo`](https://react.dev/reference/react/useMemo#skipping-re-rendering-of-components) and [`useCallback`.](https://react.dev/reference/react/useCallback#skipping-re-rendering-of-components)\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### My component doesn‚Äôt see the value from my provider[](#my-component-doesnt-see-the-value-from-my-provider \"Link for My component doesn‚Äôt see the value from my provider \")\n\nThere are a few common ways that this can happen:\n\n1.  You‚Äôre rendering `<SomeContext.Provider>` in the same component (or below) as where you‚Äôre calling `useContext()`. Move `<SomeContext.Provider>` _above and outside_ the component calling `useContext()`.\n2.  You may have forgotten to wrap your component with `<SomeContext.Provider>`, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using [React DevTools.](https://react.dev/learn/react-developer-tools)\n3.  You might be running into some build issue with your tooling that causes `SomeContext` as seen from the providing component and `SomeContext` as seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals like `window.SomeContext1` and `window.SomeContext2` and then checking whether `window.SomeContext1 === window.SomeContext2` in the console. If they‚Äôre not the same, fix that issue on the build tool level.\n\n### I am always getting `undefined` from my context although the default value is different[](#i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different \"Link for this heading\")\n\nYou might have a provider without a `value` in the tree:\n\n```\n// üö© Doesn't work: no value prop<ThemeContext.Provider><Button /></ThemeContext.Provider>\n```\n\nIf you forget to specify `value`, it‚Äôs like passing `value={undefined}`.\n\nYou may have also mistakingly used a different prop name by mistake:\n\n```\n// üö© Doesn't work: prop should be called \"value\"<ThemeContext.Provider theme={theme}><Button /></ThemeContext.Provider>\n```\n\nIn both of these cases you should see a warning from React in the console. To fix them, call the prop `value`:\n\n```\n// ‚úÖ Passing the value prop<ThemeContext.Provider value={theme}><Button /></ThemeContext.Provider>\n```\n\nNote that the [default value from your `createContext(defaultValue)` call](#specifying-a-fallback-default-value) is only used **if there is no matching provider above at all.** If there is a `<SomeContext.Provider value={undefined}>` component somewhere in the parent tree, the component calling `useContext(SomeContext)` _will_ receive `undefined` as the context value.",
  "title": "useContext ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useCallback",
  "markdown": "# useCallback ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useCallback` is a React Hook that lets you cache a function definition between re-renders.\n\n```\nconst cachedFn = useCallback(fn, dependencies)\n```\n\n*   [Reference](#reference)\n    *   [`useCallback(fn, dependencies)`](#usecallback)\n*   [Usage](#usage)\n    *   [Skipping re-rendering of components](#skipping-re-rendering-of-components)\n    *   [Updating state from a memoized callback](#updating-state-from-a-memoized-callback)\n    *   [Preventing an Effect from firing too often](#preventing-an-effect-from-firing-too-often)\n    *   [Optimizing a custom Hook](#optimizing-a-custom-hook)\n*   [Troubleshooting](#troubleshooting)\n    *   [Every time my component renders, `useCallback` returns a different function](#every-time-my-component-renders-usecallback-returns-a-different-function)\n    *   [I need to call `useCallback` for each list item in a loop, but it‚Äôs not allowed](#i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useCallback(fn, dependencies)`[](#usecallback \"Link for this heading\")\n\nCall `useCallback` at the top level of your component to cache a function definition between re-renders:\n\n```\nimport { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) {const handleSubmit = useCallback((orderDetails) => {post('/product/' + productId + '/buy', {referrer,orderDetails,});}, [productId, referrer]);\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `fn`: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the `dependencies` have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.\n    \n*   `dependencies`: The list of all reactive values referenced inside of the `fn` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://react.dev/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison algorithm.\n    \n\n#### Returns[](#returns \"Link for Returns \")\n\nOn the initial render, `useCallback` returns the `fn` function you have passed.\n\nDuring subsequent renders, it will either return an already stored `fn` function from the last render (if the dependencies haven‚Äôt changed), or return the `fn` function you have passed during this render.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   `useCallback` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n*   React **will not throw away the cached function unless there is a specific reason to do that.** For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache‚Äîfor example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on `useCallback` as a performance optimization. Otherwise, a [state variable](https://react.dev/reference/react/useState#im-trying-to-set-state-to-a-function-but-it-gets-called-instead) or a [ref](https://react.dev/reference/react/useRef#avoiding-recreating-the-ref-contents) may be more appropriate.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Skipping re-rendering of components[](#skipping-re-rendering-of-components \"Link for Skipping re-rendering of components \")\n\nWhen you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let‚Äôs first look at the syntax for how to do this, and then see in which cases it‚Äôs useful.\n\nTo cache a function between re-renders of your component, wrap its definition into the `useCallback` Hook:\n\n```\nimport { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) {const handleSubmit = useCallback((orderDetails) => {post('/product/' + productId + '/buy', {referrer,orderDetails,});}, [productId, referrer]);// ...\n```\n\nYou need to pass two things to `useCallback`:\n\n1.  A function definition that you want to cache between re-renders.\n2.  A list of dependencies including every value within your component that‚Äôs used inside your function.\n\nOn the initial render, the returned function you‚Äôll get from `useCallback` will be the function you passed.\n\nOn the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), `useCallback` will return the same function as before. Otherwise, `useCallback` will return the function you passed on _this_ render.\n\nIn other words, `useCallback` caches a function between re-renders until its dependencies change.\n\n**Let‚Äôs walk through an example to see when this is useful.**\n\nSay you‚Äôre passing a `handleSubmit` function down from the `ProductPage` to the `ShippingForm` component:\n\n```\nfunction ProductPage({ productId, referrer, theme }) {// ...return (<div className={theme}><ShippingForm onSubmit={handleSubmit} /></div>);\n```\n\nYou‚Äôve noticed that toggling the `theme` prop freezes the app for a moment, but if you remove `<ShippingForm />` from your JSX, it feels fast. This tells you that it‚Äôs worth trying to optimize the `ShippingForm` component.\n\n**By default, when a component re-renders, React re-renders all of its children recursively.** This is why, when `ProductPage` re-renders with a different `theme`, the `ShippingForm` component _also_ re-renders. This is fine for components that don‚Äôt require much calculation to re-render. But if you verified a re-render is slow, you can tell `ShippingForm` to skip re-rendering when its props are the same as on last render by wrapping it in [`memo`:](https://react.dev/reference/react/memo)\n\n```\nimport { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) {// ...});\n```\n\n**With this change, `ShippingForm` will skip re-rendering if all of its props are the _same_ as on the last render.** This is when caching a function becomes important! Let‚Äôs say you defined `handleSubmit` without `useCallback`:\n\n```\nfunction ProductPage({ productId, referrer, theme }) {// Every time the theme changes, this will be a different function...function handleSubmit(orderDetails) {post('/product/' + productId + '/buy', {referrer,orderDetails,});}return (<div className={theme}>{/* ... so ShippingForm's props will never be the same, and it will re-render every time */}<ShippingForm onSubmit={handleSubmit} /></div>);}\n```\n\n**In JavaScript, a `function () {}` or `() => {}` always creates a _different_ function,** similar to how the `{}` object literal always creates a new object. Normally, this wouldn‚Äôt be a problem, but it means that `ShippingForm` props will never be the same, and your [`memo`](https://react.dev/reference/react/memo) optimization won‚Äôt work. This is where `useCallback` comes in handy:\n\n```\nfunction ProductPage({ productId, referrer, theme }) {// Tell React to cache your function between re-renders...const handleSubmit = useCallback((orderDetails) => {post('/product/' + productId + '/buy', {referrer,orderDetails,});}, [productId, referrer]); // ...so as long as these dependencies don't change...return (<div className={theme}>{/* ...ShippingForm will receive the same props and can skip re-rendering */}<ShippingForm onSubmit={handleSubmit} /></div>);}\n```\n\n**By wrapping `handleSubmit` in `useCallback`, you ensure that it‚Äôs the _same_ function between the re-renders** (until dependencies change). You don‚Äôt _have to_ wrap a function in `useCallback` unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in [`memo`,](https://react.dev/reference/react/memo) and this lets it skip re-rendering. There are other reasons you might need `useCallback` which are described further on this page.\n\n### Note\n\n**You should only rely on `useCallback` as a performance optimization.** If your code doesn‚Äôt work without it, find the underlying problem and fix it first. Then you may add `useCallback` back.\n\n##### Deep Dive\n\nYou will often see [`useMemo`](https://react.dev/reference/react/useMemo) alongside `useCallback`. They are both useful when you‚Äôre trying to optimize a child component. They let you [memoize](https://en.wikipedia.org/wiki/Memoization) (or, in other words, cache) something you‚Äôre passing down:\n\n```\nimport { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) {const product = useData('/product/' + productId);const requirements = useMemo(() => { // Calls your function and caches its resultreturn computeRequirements(product);}, [product]);const handleSubmit = useCallback((orderDetails) => { // Caches your function itselfpost('/product/' + productId + '/buy', {referrer,orderDetails,});}, [productId, referrer]);return (<div className={theme}><ShippingForm requirements={requirements} onSubmit={handleSubmit} /></div>);}\n```\n\nThe difference is in _what_ they‚Äôre letting you cache:\n\n*   **[`useMemo`](https://react.dev/reference/react/useMemo) caches the _result_ of calling your function.** In this example, it caches the result of calling `computeRequirements(product)` so that it doesn‚Äôt change unless `product` has changed. This lets you pass the `requirements` object down without unnecessarily re-rendering `ShippingForm`. When necessary, React will call the function you‚Äôve passed during rendering to calculate the result.\n*   **`useCallback` caches _the function itself._** Unlike `useMemo`, it does not call the function you provide. Instead, it caches the function you provided so that `handleSubmit` _itself_ doesn‚Äôt change unless `productId` or `referrer` has changed. This lets you pass the `handleSubmit` function down without unnecessarily re-rendering `ShippingForm`. Your code won‚Äôt run until the user submits the form.\n\nIf you‚Äôre already familiar with [`useMemo`,](https://react.dev/reference/react/useMemo) you might find it helpful to think of `useCallback` as this:\n\n```\n// Simplified implementation (inside React)function useCallback(fn, dependencies) {return useMemo(() => fn, dependencies);}\n```\n\n[Read more about the difference between `useMemo` and `useCallback`.](https://react.dev/reference/react/useMemo#memoizing-a-function)\n\n##### Deep Dive\n\n#### Should you add useCallback everywhere?[](#should-you-add-usecallback-everywhere \"Link for Should you add useCallback everywhere? \")\n\nIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.\n\nCaching a function with `useCallback` is only valuable in a few cases:\n\n*   You pass it as a prop to a component wrapped in [`memo`.](https://react.dev/reference/react/memo) You want to skip re-rendering if the value hasn‚Äôt changed. Memoization lets your component re-render only if dependencies changed.\n*   The function you‚Äôre passing is later used as a dependency of some Hook. For example, another function wrapped in `useCallback` depends on it, or you depend on this function from [`useEffect.`](https://react.dev/reference/react/useEffect)\n\nThere is no benefit to wrapping a function in `useCallback` in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value that‚Äôs ‚Äúalways new‚Äù is enough to break memoization for an entire component.\n\nNote that `useCallback` does not prevent _creating_ the function. You‚Äôre always creating a function (and that‚Äôs fine!), but React ignores it and gives you back a cached function if nothing changed.\n\n**In practice, you can make a lot of memoization unnecessary by following a few principles:**\n\n1.  When a component visually wraps other components, let it [accept JSX as children.](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) Then, if the wrapper component updates its own state, React knows that its children don‚Äôt need to re-render.\n2.  Prefer local state and don‚Äôt [lift state up](https://react.dev/learn/sharing-state-between-components) any further than necessary. Don‚Äôt keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\n3.  Keep your [rendering logic pure.](https://react.dev/learn/keeping-components-pure) If re-rendering a component causes a problem or produces some noticeable visual artifact, it‚Äôs a bug in your component! Fix the bug instead of adding memoization.\n4.  Avoid [unnecessary Effects that update state.](https://react.dev/learn/you-might-not-need-an-effect) Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\n5.  Try to [remove unnecessary dependencies from your Effects.](https://react.dev/learn/removing-effect-dependencies) For example, instead of memoization, it‚Äôs often simpler to move some object or a function inside an Effect or outside the component.\n\nIf a specific interaction still feels laggy, [use the React Developer Tools profiler](https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html) to see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it‚Äôs good to follow them in any case. In long term, we‚Äôre researching [doing memoization automatically](https://www.youtube.com/watch?v=lGEMwh32soc) to solve this once and for all.\n\n* * *\n\n### Updating state from a memoized callback[](#updating-state-from-a-memoized-callback \"Link for Updating state from a memoized callback \")\n\nSometimes, you might need to update state based on previous state from a memoized callback.\n\nThis `handleAddTodo` function specifies `todos` as a dependency because it computes the next todos from it:\n\n```\nfunction TodoList() {const [todos, setTodos] = useState([]);const handleAddTodo = useCallback((text) => {const newTodo = { id: nextId++, text };setTodos([...todos, newTodo]);}, [todos]);// ...\n```\n\nYou‚Äôll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing an [updater function](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state) instead:\n\n```\nfunction TodoList() {const [todos, setTodos] = useState([]);const handleAddTodo = useCallback((text) => {const newTodo = { id: nextId++, text };setTodos(todos => [...todos, newTodo]);}, []); // ‚úÖ No need for the todos dependency// ...\n```\n\nHere, instead of making `todos` a dependency and reading it inside, you pass an instruction about _how_ to update the state (`todos => [...todos, newTodo]`) to React. [Read more about updater functions.](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state)\n\n* * *\n\n### Preventing an Effect from firing too often[](#preventing-an-effect-from-firing-too-often \"Link for Preventing an Effect from firing too often \")\n\nSometimes, you might want to call a function from inside an [Effect:](https://react.dev/learn/synchronizing-with-effects)\n\n```\nfunction ChatRoom({ roomId }) {const [message, setMessage] = useState('');function createOptions() {return {serverUrl: 'https://localhost:1234',roomId: roomId};}useEffect(() => {const options = createOptions();const connection = createConnection();connection.connect();// ...\n```\n\nThis creates a problem. [Every reactive value must be declared as a dependency of your Effect.](https://react.dev/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency) However, if you declare `createOptions` as a dependency, it will cause your Effect to constantly reconnect to the chat room:\n\n```\nuseEffect(() => {const options = createOptions();const connection = createConnection();connection.connect();return () => connection.disconnect();}, [createOptions]); // üî¥ Problem: This dependency changes on every render// ...\n```\n\nTo solve this, you can wrap the function you need to call from an Effect into `useCallback`:\n\n```\nfunction ChatRoom({ roomId }) {const [message, setMessage] = useState('');const createOptions = useCallback(() => {return {serverUrl: 'https://localhost:1234',roomId: roomId};}, [roomId]); // ‚úÖ Only changes when roomId changesuseEffect(() => {const options = createOptions();const connection = createConnection();connection.connect();return () => connection.disconnect();}, [createOptions]); // ‚úÖ Only changes when createOptions changes// ...\n```\n\nThis ensures that the `createOptions` function is the same between re-renders if the `roomId` is the same. **However, it‚Äôs even better to remove the need for a function dependency.** Move your function _inside_ the Effect:\n\n```\nfunction ChatRoom({ roomId }) {const [message, setMessage] = useState('');useEffect(() => {function createOptions() { // ‚úÖ No need for useCallback or function dependencies!return {serverUrl: 'https://localhost:1234',roomId: roomId};}const options = createOptions();const connection = createConnection();connection.connect();return () => connection.disconnect();}, [roomId]); // ‚úÖ Only changes when roomId changes// ...\n```\n\nNow your code is simpler and doesn‚Äôt need `useCallback`. [Learn more about removing Effect dependencies.](https://react.dev/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect)\n\n* * *\n\n### Optimizing a custom Hook[](#optimizing-a-custom-hook \"Link for Optimizing a custom Hook \")\n\nIf you‚Äôre writing a [custom Hook,](https://react.dev/learn/reusing-logic-with-custom-hooks) it‚Äôs recommended to wrap any functions that it returns into `useCallback`:\n\n```\nfunction useRouter() {const { dispatch } = useContext(RouterStateContext);const navigate = useCallback((url) => {dispatch({ type: 'navigate', url });}, [dispatch]);const goBack = useCallback(() => {dispatch({ type: 'back' });}, [dispatch]);return {navigate,goBack,};}\n```\n\nThis ensures that the consumers of your Hook can optimize their own code when needed.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### Every time my component renders, `useCallback` returns a different function[](#every-time-my-component-renders-usecallback-returns-a-different-function \"Link for this heading\")\n\nMake sure you‚Äôve specified the dependency array as a second argument!\n\nIf you forget the dependency array, `useCallback` will return a new function every time:\n\n```\nfunction ProductPage({ productId, referrer }) {const handleSubmit = useCallback((orderDetails) => {post('/product/' + productId + '/buy', {referrer,orderDetails,});}); // üî¥ Returns a new function every time: no dependency array// ...\n```\n\nThis is the corrected version passing the dependency array as a second argument:\n\n```\nfunction ProductPage({ productId, referrer }) {const handleSubmit = useCallback((orderDetails) => {post('/product/' + productId + '/buy', {referrer,orderDetails,});}, [productId, referrer]); // ‚úÖ Does not return a new function unnecessarily// ...\n```\n\nIf this doesn‚Äôt help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:\n\n```\nconst handleSubmit = useCallback((orderDetails) => {// ..}, [productId, referrer]);console.log([productId, referrer]);\n```\n\nYou can then right-click on the arrays from different re-renders in the console and select ‚ÄúStore as a global variable‚Äù for both of them. Assuming the first one got saved as `temp1` and the second one got saved as `temp2`, you can then use the browser console to check whether each dependency in both arrays is the same:\n\n```\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n```\n\nWhen you find which dependency is breaking memoization, either find a way to remove it, or [memoize it as well.](https://react.dev/reference/react/useMemo#memoizing-a-dependency-of-another-hook)\n\n* * *\n\n### I need to call `useCallback` for each list item in a loop, but it‚Äôs not allowed[](#i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed \"Link for this heading\")\n\nSuppose the `Chart` component is wrapped in [`memo`](https://react.dev/reference/react/memo). You want to skip re-rendering every `Chart` in the list when the `ReportList` component re-renders. However, you can‚Äôt call `useCallback` in a loop:\n\n```\nfunction ReportList({ items }) {return (<article>{items.map(item => {// üî¥ You can't call useCallback in a loop like this:const handleClick = useCallback(() => {sendReport(item)}, [item]);return (<figure key={item.id}><Chart onClick={handleClick} /></figure>);})}</article>);}\n```\n\nInstead, extract a component for an individual item, and put `useCallback` there:\n\n```\nfunction ReportList({ items }) {return (<article>{items.map(item =><Report key={item.id} item={item} />)}</article>);}function Report({ item }) {// ‚úÖ Call useCallback at the top level:const handleClick = useCallback(() => {sendReport(item)}, [item]);return (<figure><Chart onClick={handleClick} /></figure>);}\n```\n\nAlternatively, you could remove `useCallback` in the last snippet and instead wrap `Report` itself in [`memo`.](https://react.dev/reference/react/memo) If the `item` prop does not change, `Report` will skip re-rendering, so `Chart` will skip re-rendering too:\n\n```\nfunction ReportList({ items }) {// ...}const Report = memo(function Report({ item }) {function handleClick() {sendReport(item);}return (<figure><Chart onClick={handleClick} /></figure>);});\n```",
  "title": "useCallback ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useDeferredValue",
  "markdown": "# useDeferredValue ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useDeferredValue` is a React Hook that lets you defer updating a part of the UI.\n\n```\nconst deferredValue = useDeferredValue(value)\n```\n\n*   [Reference](#reference)\n    *   [`useDeferredValue(value, initialValue?)`](#usedeferredvalue)\n*   [Usage](#usage)\n    *   [Showing stale content while fresh content is loading](#showing-stale-content-while-fresh-content-is-loading)\n    *   [Indicating that the content is stale](#indicating-that-the-content-is-stale)\n    *   [Deferring re-rendering for a part of the UI](#deferring-re-rendering-for-a-part-of-the-ui)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useDeferredValue(value, initialValue?)`[](#usedeferredvalue \"Link for this heading\")\n\nCall `useDeferredValue` at the top level of your component to get a deferred version of that value.\n\n```\nimport { useState, useDeferredValue } from 'react';function SearchPage() {const [query, setQuery] = useState('');const deferredQuery = useDeferredValue(query);// ...}\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `value`: The value you want to defer. It can have any type.\n*   Canary only **optional** `initialValue`: A value to use during the initial render of a component. If this option is omitted, `useDeferredValue` will not defer during the initial render, because there‚Äôs no previous version of `value` that it can render instead.\n\n#### Returns[](#returns \"Link for Returns \")\n\n*   `currentValue`: During the initial render, the returned deferred value will be the same as the value you provided. During updates, React will first attempt a re-render with the old value (so it will return the old value), and then try another re-render in the background with the new value (so it will return the updated value).\n\n### Canary\n\nIn the latest React Canary versions, `useDeferredValue` returns the `initialValue` on initial render, and schedules a re-render in the background with the `value` returned.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   When an update is inside a Transition, `useDeferredValue` always returns the new `value` and does not spawn a deferred render, since the update is already deferred.\n    \n*   The values you pass to `useDeferredValue` should either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it to `useDeferredValue`, it will be different on every render, causing unnecessary background re-renders.\n    \n*   When `useDeferredValue` receives a different value (compared with [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there‚Äôs another update to the `value`, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing.\n    \n*   `useDeferredValue` is integrated with [`<Suspense>`.](https://react.dev/reference/react/Suspense) If the background update caused by a new value suspends the UI, the user will not see the fallback. They will see the old deferred value until the data loads.\n    \n*   `useDeferredValue` does not by itself prevent extra network requests.\n    \n*   There is no fixed delay caused by `useDeferredValue` itself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it.\n    \n*   The background re-render caused by `useDeferredValue` does not fire Effects until it‚Äôs committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates.\n    \n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Showing stale content while fresh content is loading[](#showing-stale-content-while-fresh-content-is-loading \"Link for Showing stale content while fresh content is loading \")\n\nCall `useDeferredValue` at the top level of your component to defer updating some part of your UI.\n\n```\nimport { useState, useDeferredValue } from 'react';function SearchPage() {const [query, setQuery] = useState('');const deferredQuery = useDeferredValue(query);// ...}\n```\n\nDuring the initial render, the deferred value will be the same as the value you provided.\n\nDuring updates, the deferred value will ‚Äúlag behind‚Äù the latest value. In particular, React will first re-render _without_ updating the deferred value, and then try to re-render with the newly received value in the background.\n\n**Let‚Äôs walk through an example to see when this is useful.**\n\n### Note\n\nIn this example, the `SearchResults` component [suspends](https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading) while fetching the search results. Try typing `\"a\"`, waiting for the results, and then editing it to `\"ab\"`. The results for `\"a\"` get replaced by the loading fallback.\n\nimport { Suspense, useState } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const \\[query, setQuery\\] = useState('');\n  return (\n    <\\>\n      <label\\>\n        Search albums:\n        <input value\\={query} onChange\\={e \\=> setQuery(e.target.value)} />\n      </label\\>\n      <Suspense fallback\\={<h2\\>Loading...</h2\\>}\\>\n        <SearchResults query\\={query} />\n      </Suspense\\>\n    </\\>\n  );\n}\n\nA common alternative UI pattern is to _defer_ updating the list of results and to keep showing the previous results until the new results are ready. Call `useDeferredValue` to pass a deferred version of the query down:\n\n```\nexport default function App() {const [query, setQuery] = useState('');const deferredQuery = useDeferredValue(query);return (<><label>        Search albums:<input value={query} onChange={e => setQuery(e.target.value)} /></label><Suspense fallback={<h2>Loading...</h2>}><SearchResults query={deferredQuery} /></Suspense></>);}\n```\n\nThe `query` will update immediately, so the input will display the new value. However, the `deferredQuery` will keep its previous value until the data has loaded, so `SearchResults` will show the stale results for a bit.\n\nEnter `\"a\"` in the example below, wait for the results to load, and then edit the input to `\"ab\"`. Notice how instead of the Suspense fallback, you now see the stale result list until the new results have loaded:\n\nimport { Suspense, useState, useDeferredValue } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const \\[query, setQuery\\] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  return (\n    <\\>\n      <label\\>\n        Search albums:\n        <input value\\={query} onChange\\={e \\=> setQuery(e.target.value)} />\n      </label\\>\n      <Suspense fallback\\={<h2\\>Loading...</h2\\>}\\>\n        <SearchResults query\\={deferredQuery} />\n      </Suspense\\>\n    </\\>\n  );\n}\n\n##### Deep Dive\n\n#### How does deferring a value work under the hood?[](#how-does-deferring-a-value-work-under-the-hood \"Link for How does deferring a value work under the hood? \")\n\nYou can think of it as happening in two steps:\n\n1.  **First, React re-renders with the new `query` (`\"ab\"`) but with the old `deferredQuery` (still `\"a\")`.** The `deferredQuery` value, which you pass to the result list, is _deferred:_ it ‚Äúlags behind‚Äù the `query` value.\n    \n2.  **In the background, React tries to re-render with _both_ `query` and `deferredQuery` updated to `\"ab\"`.** If this re-render completes, React will show it on the screen. However, if it suspends (the results for `\"ab\"` have not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded. The user will keep seeing the stale deferred value until the data is ready.\n    \n\nThe deferred ‚Äúbackground‚Äù rendering is interruptible. For example, if you type into the input again, React will abandon it and restart with the new value. React will always use the latest provided value.\n\nNote that there is still a network request per each keystroke. What‚Äôs being deferred here is displaying results (until they‚Äôre ready), not the network requests themselves. Even if the user continues typing, responses for each keystroke get cached, so pressing Backspace is instant and doesn‚Äôt fetch again.\n\n* * *\n\n### Indicating that the content is stale[](#indicating-that-the-content-is-stale \"Link for Indicating that the content is stale \")\n\nIn the example above, there is no indication that the result list for the latest query is still loading. This can be confusing to the user if the new results take a while to load. To make it more obvious to the user that the result list does not match the latest query, you can add a visual indication when the stale result list is displayed:\n\n```\n<div style={{opacity: query !== deferredQuery ? 0.5 : 1,}}><SearchResults query={deferredQuery} /></div>\n```\n\nWith this change, as soon as you start typing, the stale result list gets slightly dimmed until the new result list loads. You can also add a CSS transition to delay dimming so that it feels gradual, like in the example below:\n\nimport { Suspense, useState, useDeferredValue } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const \\[query, setQuery\\] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n  return (\n    <\\>\n      <label\\>\n        Search albums:\n        <input value\\={query} onChange\\={e \\=> setQuery(e.target.value)} />\n      </label\\>\n      <Suspense fallback\\={<h2\\>Loading...</h2\\>}\\>\n        <div style\\={{\n          opacity: isStale ? 0.5 : 1,\n          transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear'\n        }}\\>\n          <SearchResults query\\={deferredQuery} />\n        </div\\>\n      </Suspense\\>\n    </\\>\n  );\n}\n\n* * *\n\n### Deferring re-rendering for a part of the UI[](#deferring-re-rendering-for-a-part-of-the-ui \"Link for Deferring re-rendering for a part of the UI \")\n\nYou can also apply `useDeferredValue` as a performance optimization. It is useful when a part of your UI is slow to re-render, there‚Äôs no easy way to optimize it, and you want to prevent it from blocking the rest of the UI.\n\nImagine you have a text field and a component (like a chart or a long list) that re-renders on every keystroke:\n\n```\nfunction App() {const [text, setText] = useState('');return (<><input value={text} onChange={e => setText(e.target.value)} /><SlowList text={text} /></>);}\n```\n\nFirst, optimize `SlowList` to skip re-rendering when its props are the same. To do this, [wrap it in `memo`:](https://react.dev/reference/react/memo#skipping-re-rendering-when-props-are-unchanged)\n\n```\nconst SlowList = memo(function SlowList({ text }) {// ...});\n```\n\nHowever, this only helps if the `SlowList` props are _the same_ as during the previous render. The problem you‚Äôre facing now is that it‚Äôs slow when they‚Äôre _different,_ and when you actually need to show different visual output.\n\nConcretely, the main performance problem is that whenever you type into the input, the `SlowList` receives new props, and re-rendering its entire tree makes the typing feel janky. In this case, `useDeferredValue` lets you prioritize updating the input (which must be fast) over updating the result list (which is allowed to be slower):\n\n```\nfunction App() {const [text, setText] = useState('');const deferredText = useDeferredValue(text);return (<><input value={text} onChange={e => setText(e.target.value)} /><SlowList text={deferredText} /></>);}\n```\n\nThis does not make re-rendering of the `SlowList` faster. However, it tells React that re-rendering the list can be deprioritized so that it doesn‚Äôt block the keystrokes. The list will ‚Äúlag behind‚Äù the input and then ‚Äúcatch up‚Äù. Like before, React will attempt to update the list as soon as possible, but will not block the user from typing.\n\n#### The difference between useDeferredValue and unoptimized re-rendering[](#examples \"Link for The difference between useDeferredValue and unoptimized re-rendering\")\n\n#### Deferred re-rendering of the list[](#deferred-re-rendering-of-the-list \"Link for this heading\")\n\nIn this example, each item in the `SlowList` component is **artificially slowed down** so that you can see how `useDeferredValue` lets you keep the input responsive. Type into the input and notice that typing feels snappy while the list ‚Äúlags behind‚Äù it.\n\n### Pitfall\n\nThis optimization requires `SlowList` to be wrapped in [`memo`.](https://react.dev/reference/react/memo) This is because whenever the `text` changes, React needs to be able to re-render the parent component quickly. During that re-render, `deferredText` still has its previous value, so `SlowList` is able to skip re-rendering (its props have not changed). Without [`memo`,](https://react.dev/reference/react/memo) it would have to re-render anyway, defeating the point of the optimization.\n\n##### Deep Dive\n\n#### How is deferring a value different from debouncing and throttling?[](#how-is-deferring-a-value-different-from-debouncing-and-throttling \"Link for How is deferring a value different from debouncing and throttling? \")\n\nThere are two common optimization techniques you might have used before in this scenario:\n\n*   _Debouncing_ means you‚Äôd wait for the user to stop typing (e.g. for a second) before updating the list.\n*   _Throttling_ means you‚Äôd update the list every once in a while (e.g. at most once a second).\n\nWhile these techniques are helpful in some cases, `useDeferredValue` is better suited to optimizing rendering because it is deeply integrated with React itself and adapts to the user‚Äôs device.\n\nUnlike debouncing or throttling, it doesn‚Äôt require choosing any fixed delay. If the user‚Äôs device is fast (e.g. powerful laptop), the deferred re-render would happen almost immediately and wouldn‚Äôt be noticeable. If the user‚Äôs device is slow, the list would ‚Äúlag behind‚Äù the input proportionally to how slow the device is.\n\nAlso, unlike with debouncing or throttling, deferred re-renders done by `useDeferredValue` are interruptible by default. This means that if React is in the middle of re-rendering a large list, but the user makes another keystroke, React will abandon that re-render, handle the keystroke, and then start rendering in the background again. By contrast, debouncing and throttling still produce a janky experience because they‚Äôre _blocking:_ they merely postpone the moment when rendering blocks the keystroke.\n\nIf the work you‚Äôre optimizing doesn‚Äôt happen during rendering, debouncing and throttling are still useful. For example, they can let you fire fewer network requests. You can also use these techniques together.",
  "title": "useDeferredValue ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useId",
  "markdown": "# useId ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useId` is a React Hook for generating unique IDs that can be passed to accessibility attributes.\n\n*   [Reference](#reference)\n    *   [`useId()`](#useid)\n*   [Usage](#usage)\n    *   [Generating unique IDs for accessibility attributes](#generating-unique-ids-for-accessibility-attributes)\n    *   [Generating IDs for several related elements](#generating-ids-for-several-related-elements)\n    *   [Specifying a shared prefix for all generated IDs](#specifying-a-shared-prefix-for-all-generated-ids)\n    *   [Using the same ID prefix on the client and the server](#using-the-same-id-prefix-on-the-client-and-the-server)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useId()`[](#useid \"Link for this heading\")\n\nCall `useId` at the top level of your component to generate a unique ID:\n\n```\nimport { useId } from 'react';function PasswordField() {const passwordHintId = useId();// ...\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n`useId` does not take any parameters.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`useId` returns a unique ID string associated with this particular `useId` call in this particular component.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   `useId` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n    \n*   `useId` **should not be used to generate keys** in a list. [Keys should be generated from your data.](https://react.dev/learn/rendering-lists#where-to-get-your-key)\n    \n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Pitfall\n\n### Generating unique IDs for accessibility attributes[](#generating-unique-ids-for-accessibility-attributes \"Link for Generating unique IDs for accessibility attributes \")\n\nCall `useId` at the top level of your component to generate a unique ID:\n\n```\nimport { useId } from 'react';function PasswordField() {const passwordHintId = useId();// ...\n```\n\nYou can then pass the generated ID to different attributes:\n\n```\n<><input type=\"password\" aria-describedby={passwordHintId} /><p id={passwordHintId}></>\n```\n\n**Let‚Äôs walk through an example to see when this is useful.**\n\n[HTML accessibility attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) like [`aria-describedby`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-describedby) let you specify that two tags are related to each other. For example, you can specify that an element (like an input) is described by another element (like a paragraph).\n\nIn regular HTML, you would write it like this:\n\n```\n<label>  Password:<inputtype=\"password\"aria-describedby=\"password-hint\"/></label><p id=\"password-hint\">  The password should contain at least 18 characters</p>\n```\n\nHowever, hardcoding IDs like this is not a good practice in React. A component may be rendered more than once on the page‚Äîbut IDs have to be unique! Instead of hardcoding an ID, generate a unique ID with `useId`:\n\n```\nimport { useId } from 'react';function PasswordField() {const passwordHintId = useId();return (<><label>        Password:<inputtype=\"password\"aria-describedby={passwordHintId}/></label><p id={passwordHintId}>        The password should contain at least 18 characters</p></>);}\n```\n\nNow, even if `PasswordField` appears multiple times on the screen, the generated IDs won‚Äôt clash.\n\nimport { useId } from 'react';\n\nfunction PasswordField() {\n  const passwordHintId = useId();\n  return (\n    <\\>\n      <label\\>\n        Password:\n        <input\n          type\\=\"password\"\n          aria-describedby\\={passwordHintId}\n        />\n      </label\\>\n      <p id\\={passwordHintId}\\>\n        The password should contain at least 18 characters\n      </p\\>\n    </\\>\n  );\n}\n\nexport default function App() {\n  return (\n    <\\>\n      <h2\\>Choose password</h2\\>\n      <PasswordField />\n      <h2\\>Confirm password</h2\\>\n      <PasswordField />\n    </\\>\n  );\n}\n\n[Watch this video](https://www.youtube.com/watch?v=0dNzNcuEuOo) to see the difference in the user experience with assistive technologies.\n\n### Pitfall\n\nWith [server rendering](https://react.dev/reference/react-dom/server), **`useId` requires an identical component tree on the server and the client**. If the trees you render on the server and the client don‚Äôt match exactly, the generated IDs won‚Äôt match.\n\n##### Deep Dive\n\n#### Why is useId better than an incrementing counter?[](#why-is-useid-better-than-an-incrementing-counter \"Link for Why is useId better than an incrementing counter? \")\n\nYou might be wondering why `useId` is better than incrementing a global variable like `nextId++`.\n\nThe primary benefit of `useId` is that React ensures that it works with [server rendering.](https://react.dev/reference/react-dom/server) During server rendering, your components generate HTML output. Later, on the client, [hydration](https://react.dev/reference/react-dom/client/hydrateRoot) attaches your event handlers to the generated HTML. For hydration to work, the client output must match the server HTML.\n\nThis is very difficult to guarantee with an incrementing counter because the order in which the Client Components are hydrated may not match the order in which the server HTML was emitted. By calling `useId`, you ensure that hydration will work, and the output will match between the server and the client.\n\nInside React, `useId` is generated from the ‚Äúparent path‚Äù of the calling component. This is why, if the client and the server tree are the same, the ‚Äúparent path‚Äù will match up regardless of rendering order.\n\n* * *\n\nIf you need to give IDs to multiple related elements, you can call `useId` to generate a shared prefix for them:\n\nThis lets you avoid calling `useId` for every single element that needs a unique ID.\n\n* * *\n\n### Specifying a shared prefix for all generated IDs[](#specifying-a-shared-prefix-for-all-generated-ids \"Link for Specifying a shared prefix for all generated IDs \")\n\nIf you render multiple independent React applications on a single page, pass `identifierPrefix` as an option to your [`createRoot`](https://react.dev/reference/react-dom/client/createRoot#parameters) or [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) calls. This ensures that the IDs generated by the two different apps never clash because every identifier generated with `useId` will start with the distinct prefix you‚Äôve specified.\n\n* * *\n\n### Using the same ID prefix on the client and the server[](#using-the-same-id-prefix-on-the-client-and-the-server \"Link for Using the same ID prefix on the client and the server \")\n\nIf you [render multiple independent React apps on the same page](#specifying-a-shared-prefix-for-all-generated-ids), and some of these apps are server-rendered, make sure that the `identifierPrefix` you pass to the [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) call on the client side is the same as the `identifierPrefix` you pass to the [server APIs](https://react.dev/reference/react-dom/server) such as [`renderToPipeableStream`.](https://react.dev/reference/react-dom/server/renderToPipeableStream)\n\n```\n// Serverimport { renderToPipeableStream } from 'react-dom/server';const { pipe } = renderToPipeableStream(<App />,{ identifierPrefix: 'react-app1' });\n```\n\n```\n// Clientimport { hydrateRoot } from 'react-dom/client';const domNode = document.getElementById('root');const root = hydrateRoot(domNode,reactNode,{ identifierPrefix: 'react-app1' });\n```\n\nYou do not need to pass `identifierPrefix` if you only have one React app on the page.",
  "title": "useId ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useImperativeHandle",
  "markdown": "# useImperativeHandle ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useImperativeHandle` is a React Hook that lets you customize the handle exposed as a [ref.](https://react.dev/learn/manipulating-the-dom-with-refs)\n\n```\nuseImperativeHandle(ref, createHandle, dependencies?)\n```\n\n*   [Reference](#reference)\n    *   [`useImperativeHandle(ref, createHandle, dependencies?)`](#useimperativehandle)\n*   [Usage](#usage)\n    *   [Exposing a custom ref handle to the parent component](#exposing-a-custom-ref-handle-to-the-parent-component)\n    *   [Exposing your own imperative methods](#exposing-your-own-imperative-methods)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useImperativeHandle(ref, createHandle, dependencies?)`[](#useimperativehandle \"Link for this heading\")\n\nCall `useImperativeHandle` at the top level of your component to customize the ref handle it exposes:\n\n```\nimport { forwardRef, useImperativeHandle } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {useImperativeHandle(ref, () => {return {// ... your methods ...};}, []);// ...\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `ref`: The `ref` you received as the second argument from the [`forwardRef` render function.](https://react.dev/reference/react/forwardRef#render-function)\n    \n*   `createHandle`: A function that takes no arguments and returns the ref handle you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose.\n    \n*   **optional** `dependencies`: The list of all reactive values referenced inside of the `createHandle` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://react.dev/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. If a re-render resulted in a change to some dependency, or if you omitted this argument, your `createHandle` function will re-execute, and the newly created handle will be assigned to the ref.\n    \n\n#### Returns[](#returns \"Link for Returns \")\n\n`useImperativeHandle` returns `undefined`.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Exposing a custom ref handle to the parent component[](#exposing-a-custom-ref-handle-to-the-parent-component \"Link for Exposing a custom ref handle to the parent component \")\n\nBy default, components don‚Äôt expose their DOM nodes to parent components. For example, if you want the parent component of `MyInput` to [have access](https://react.dev/learn/manipulating-the-dom-with-refs) to the `<input>` DOM node, you have to opt in with [`forwardRef`:](https://react.dev/reference/react/forwardRef)\n\n```\nimport { forwardRef } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {return <input {...props} ref={ref} />;});\n```\n\nWith the code above, [a ref to `MyInput` will receive the `<input>` DOM node.](https://react.dev/reference/react/forwardRef#exposing-a-dom-node-to-the-parent-component) However, you can expose a custom value instead. To customize the exposed handle, call `useImperativeHandle` at the top level of your component:\n\n```\nimport { forwardRef, useImperativeHandle } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {useImperativeHandle(ref, () => {return {// ... your methods ...};}, []);return <input {...props} />;});\n```\n\nNote that in the code above, the `ref` is no longer forwarded to the `<input>`.\n\nFor example, suppose you don‚Äôt want to expose the entire `<input>` DOM node, but you want to expose two of its methods: `focus` and `scrollIntoView`. To do this, keep the real browser DOM in a separate ref. Then use `useImperativeHandle` to expose a handle with only the methods that you want the parent component to call:\n\n```\nimport { forwardRef, useRef, useImperativeHandle } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {const inputRef = useRef(null);useImperativeHandle(ref, () => {return {focus() {inputRef.current.focus();},scrollIntoView() {inputRef.current.scrollIntoView();},};}, []);return <input {...props} ref={inputRef} />;});\n```\n\nNow, if the parent component gets a ref to `MyInput`, it will be able to call the `focus` and `scrollIntoView` methods on it. However, it will not have full access to the underlying `<input>` DOM node.\n\n* * *\n\n### Exposing your own imperative methods[](#exposing-your-own-imperative-methods \"Link for Exposing your own imperative methods \")\n\nThe methods you expose via an imperative handle don‚Äôt have to match the DOM methods exactly. For example, this `Post` component exposes a `scrollAndFocusAddComment` method via an imperative handle. This lets the parent `Page` scroll the list of comments _and_ focus the input field when you click the button:\n\n### Pitfall\n\n**Do not overuse refs.** You should only use refs for _imperative_ behaviors that you can‚Äôt express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.\n\n**If you can express something as a prop, you should not use a ref.** For example, instead of exposing an imperative handle like `{ open, close }` from a `Modal` component, it is better to take `isOpen` as a prop like `<Modal isOpen={isOpen} />`. [Effects](https://react.dev/learn/synchronizing-with-effects) can help you expose imperative behaviors via props.",
  "title": "useImperativeHandle ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useEffect",
  "markdown": "# useEffect ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useEffect` is a React Hook that lets you [synchronize a component with an external system.](https://react.dev/learn/synchronizing-with-effects)\n\n```\nuseEffect(setup, dependencies?)\n```\n\n*   [Reference](#reference)\n    *   [`useEffect(setup, dependencies?)`](#useeffect)\n*   [Usage](#usage)\n    *   [Connecting to an external system](#connecting-to-an-external-system)\n    *   [Wrapping Effects in custom Hooks](#wrapping-effects-in-custom-hooks)\n    *   [Controlling a non-React widget](#controlling-a-non-react-widget)\n    *   [Fetching data with Effects](#fetching-data-with-effects)\n    *   [Specifying reactive dependencies](#specifying-reactive-dependencies)\n    *   [Updating state based on previous state from an Effect](#updating-state-based-on-previous-state-from-an-effect)\n    *   [Removing unnecessary object dependencies](#removing-unnecessary-object-dependencies)\n    *   [Removing unnecessary function dependencies](#removing-unnecessary-function-dependencies)\n    *   [Reading the latest props and state from an Effect](#reading-the-latest-props-and-state-from-an-effect)\n    *   [Displaying different content on the server and the client](#displaying-different-content-on-the-server-and-the-client)\n*   [Troubleshooting](#troubleshooting)\n    *   [My Effect runs twice when the component mounts](#my-effect-runs-twice-when-the-component-mounts)\n    *   [My Effect runs after every re-render](#my-effect-runs-after-every-re-render)\n    *   [My Effect keeps re-running in an infinite cycle](#my-effect-keeps-re-running-in-an-infinite-cycle)\n    *   [My cleanup logic runs even though my component didn‚Äôt unmount](#my-cleanup-logic-runs-even-though-my-component-didnt-unmount)\n    *   [My Effect does something visual, and I see a flicker before it runs](#my-effect-does-something-visual-and-i-see-a-flicker-before-it-runs)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useEffect(setup, dependencies?)`[](#useeffect \"Link for this heading\")\n\nCall `useEffect` at the top level of your component to declare an Effect:\n\n```\nimport { useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {const [serverUrl, setServerUrl] = useState('https://localhost:1234');useEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => {connection.disconnect();};}, [serverUrl, roomId]);// ...}\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `setup`: The function with your Effect‚Äôs logic. Your setup function may also optionally return a _cleanup_ function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.\n    \n*   **optional** `dependencies`: The list of all reactive values referenced inside of the `setup` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://react.dev/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. If you omit this argument, your Effect will re-run after every re-render of the component. [See the difference between passing an array of dependencies, an empty array, and no dependencies at all.](#examples-dependencies)\n    \n\n#### Returns[](#returns \"Link for Returns \")\n\n`useEffect` returns `undefined`.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   `useEffect` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n    \n*   If you‚Äôre **not trying to synchronize with some external system,** [you probably don‚Äôt need an Effect.](https://react.dev/learn/you-might-not-need-an-effect)\n    \n*   When Strict Mode is on, React will **run one extra development-only setup+cleanup cycle** before the first real setup. This is a stress-test that ensures that your cleanup logic ‚Äúmirrors‚Äù your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, [implement the cleanup function.](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)\n    \n*   If some of your dependencies are objects or functions defined inside the component, there is a risk that they will **cause the Effect to re-run more often than needed.** To fix this, remove unnecessary [object](#removing-unnecessary-object-dependencies) and [function](#removing-unnecessary-function-dependencies) dependencies. You can also [extract state updates](#updating-state-based-on-previous-state-from-an-effect) and [non-reactive logic](#reading-the-latest-props-and-state-from-an-effect) outside of your Effect.\n    \n*   If your Effect wasn‚Äôt caused by an interaction (like a click), React will generally let the browser **paint the updated screen first before running your Effect.** If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace `useEffect` with [`useLayoutEffect`.](https://react.dev/reference/react/useLayoutEffect)\n    \n*   If your Effect is caused by an interaction (like a click), **React may run your Effect before the browser paints the updated screen**. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as an `alert()`, you can use `setTimeout`. See [reactwg/react-18/128](https://github.com/reactwg/react-18/discussions/128) for more information.\n    \n*   Even if your Effect was caused by an interaction (like a click), **React may allow the browser to repaint the screen before processing the state updates inside your Effect.** Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replace `useEffect` with [`useLayoutEffect`.](https://react.dev/reference/react/useLayoutEffect)\n    \n*   Effects **only run on the client.** They don‚Äôt run during server rendering.\n    \n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Connecting to an external system[](#connecting-to-an-external-system \"Link for Connecting to an external system \")\n\nSome components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren‚Äôt controlled by React, so they are called _external._\n\nTo [connect your component to some external system,](https://react.dev/learn/synchronizing-with-effects) call `useEffect` at the top level of your component:\n\n```\nimport { useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {const [serverUrl, setServerUrl] = useState('https://localhost:1234');useEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => {connection.disconnect();};}, [serverUrl, roomId]);// ...}\n```\n\nYou need to pass two arguments to `useEffect`:\n\n1.  A _setup function_ with setup code that connects to that system.\n    *   It should return a _cleanup function_ with cleanup code that disconnects from that system.\n2.  A list of dependencies including every value from your component used inside of those functions.\n\n**React calls your setup and cleanup functions whenever it‚Äôs necessary, which may happen multiple times:**\n\n1.  Your setup code runs when your component is added to the page _(mounts)_.\n2.  After every re-render of your component where the dependencies have changed:\n    *   First, your cleanup code runs with the old props and state.\n    *   Then, your setup code runs with the new props and state.\n3.  Your cleanup code runs one final time after your component is removed from the page _(unmounts)._\n\n**Let‚Äôs illustrate this sequence for the example above.**\n\nWhen the `ChatRoom` component above gets added to the page, it will connect to the chat room with the initial `serverUrl` and `roomId`. If either `serverUrl` or `roomId` change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will _disconnect from the previous room, and connect to the next one._ When the `ChatRoom` component is removed from the page, your Effect will disconnect one last time.\n\n**To [help you find bugs,](https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed) in development React runs setup and cleanup one extra time before the setup.** This is a stress-test that verifies your Effect‚Äôs logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn‚Äôt be able to distinguish between the setup being called once (as in production) and a _setup_ ‚Üí _cleanup_ ‚Üí _setup_ sequence (as in development). [See common solutions.](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)\n\n**Try to [write every Effect as an independent process](https://react.dev/learn/lifecycle-of-reactive-effects#each-effect-represents-a-separate-synchronization-process) and [think about a single setup/cleanup cycle at a time.](https://react.dev/learn/lifecycle-of-reactive-effects#thinking-from-the-effects-perspective)** It shouldn‚Äôt matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly ‚Äúmirrors‚Äù the setup logic, your Effect is resilient to running setup and cleanup as often as needed.\n\n### Note\n\n#### Examples of connecting to an external system[](#examples-connecting \"Link for Examples of connecting to an external system\")\n\n#### Connecting to a chat server[](#connecting-to-a-chat-server \"Link for this heading\")\n\nIn this example, the `ChatRoom` component uses an Effect to stay connected to an external system defined in `chat.js`. Press ‚ÄúOpen chat‚Äù to make the `ChatRoom` component appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as [explained here.](https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed) Try changing the `roomId` and `serverUrl` using the dropdown and the input, and see how the Effect re-connects to the chat. Press ‚ÄúClose chat‚Äù to see the Effect disconnect one last time.\n\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n  const \\[serverUrl, setServerUrl\\] = useState('https://localhost:1234');\n\n  useEffect(() \\=> {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () \\=> {\n      connection.disconnect();\n    };\n  }, \\[roomId, serverUrl\\]);\n\n  return (\n    <\\>\n      <label\\>\n        Server URL:{' '}\n        <input\n          value\\={serverUrl}\n          onChange\\={e \\=> setServerUrl(e.target.value)}\n        />\n      </label\\>\n      <h1\\>Welcome to the {roomId} room!</h1\\>\n    </\\>\n  );\n}\n\nexport default function App() {\n  const \\[roomId, setRoomId\\] = useState('general');\n  const \\[show, setShow\\] = useState(false);\n  return (\n    <\\>\n      <label\\>\n        Choose the chat room:{' '}\n        <select\n          value\\={roomId}\n          onChange\\={e \\=> setRoomId(e.target.value)}\n        \\>\n          <option value\\=\"general\"\\>general</option\\>\n          <option value\\=\"travel\"\\>travel</option\\>\n          <option value\\=\"music\"\\>music</option\\>\n        </select\\>\n      </label\\>\n      <button onClick\\={() \\=> setShow(!show)}\\>\n        {show ? 'Close chat' : 'Open chat'}\n      </button\\>\n      {show && <hr />}\n      {show && <ChatRoom roomId\\={roomId} />}\n    </\\>\n  );\n}\n\n* * *\n\n### Wrapping Effects in custom Hooks[](#wrapping-effects-in-custom-hooks \"Link for Wrapping Effects in custom Hooks \")\n\nEffects are an [‚Äúescape hatch‚Äù:](https://react.dev/learn/escape-hatches) you use them when you need to ‚Äústep outside React‚Äù and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it‚Äôs usually a sign that you need to extract some [custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks) for common behaviors your components rely on.\n\nFor example, this `useChatRoom` custom Hook ‚Äúhides‚Äù the logic of your Effect behind a more declarative API:\n\n```\nfunction useChatRoom({ serverUrl, roomId }) {useEffect(() => {const options = {serverUrl: serverUrl,roomId: roomId};const connection = createConnection(options);connection.connect();return () => connection.disconnect();}, [roomId, serverUrl]);}\n```\n\nThen you can use it from any component like this:\n\n```\nfunction ChatRoom({ roomId }) {const [serverUrl, setServerUrl] = useState('https://localhost:1234');useChatRoom({roomId: roomId,serverUrl: serverUrl});// ...\n```\n\nThere are also many excellent custom Hooks for every purpose available in the React ecosystem.\n\n[Learn more about wrapping Effects in custom Hooks.](https://react.dev/learn/reusing-logic-with-custom-hooks)\n\n#### Examples of wrapping Effects in custom Hooks[](#examples-custom-hooks \"Link for Examples of wrapping Effects in custom Hooks\")\n\n#### Custom `useChatRoom` Hook[](#custom-usechatroom-hook \"Link for this heading\")\n\nThis example is identical to one of the [earlier examples,](#examples-connecting) but the logic is extracted to a custom Hook.\n\nimport { useState } from 'react';\nimport { useChatRoom } from './useChatRoom.js';\n\nfunction ChatRoom({ roomId }) {\n  const \\[serverUrl, setServerUrl\\] = useState('https://localhost:1234');\n\n  useChatRoom({\n    roomId: roomId,\n    serverUrl: serverUrl\n  });\n\n  return (\n    <\\>\n      <label\\>\n        Server URL:{' '}\n        <input\n          value\\={serverUrl}\n          onChange\\={e \\=> setServerUrl(e.target.value)}\n        />\n      </label\\>\n      <h1\\>Welcome to the {roomId} room!</h1\\>\n    </\\>\n  );\n}\n\nexport default function App() {\n  const \\[roomId, setRoomId\\] = useState('general');\n  const \\[show, setShow\\] = useState(false);\n  return (\n    <\\>\n      <label\\>\n        Choose the chat room:{' '}\n        <select\n          value\\={roomId}\n          onChange\\={e \\=> setRoomId(e.target.value)}\n        \\>\n          <option value\\=\"general\"\\>general</option\\>\n          <option value\\=\"travel\"\\>travel</option\\>\n          <option value\\=\"music\"\\>music</option\\>\n        </select\\>\n      </label\\>\n      <button onClick\\={() \\=> setShow(!show)}\\>\n        {show ? 'Close chat' : 'Open chat'}\n      </button\\>\n      {show && <hr />}\n      {show && <ChatRoom roomId\\={roomId} />}\n    </\\>\n  );\n}\n\n* * *\n\n### Controlling a non-React widget[](#controlling-a-non-react-widget \"Link for Controlling a non-React widget \")\n\nSometimes, you want to keep an external system synchronized to some prop or state of your component.\n\nFor example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a `MapWidget` class defined in `map-widget.js`. When you change the `zoomLevel` prop of the `Map` component, the Effect calls the `setZoom()` on the class instance to keep it synchronized:\n\nimport { useRef, useEffect } from 'react';\nimport { MapWidget } from './map-widget.js';\n\nexport default function Map({ zoomLevel }) {\n  const containerRef = useRef(null);\n  const mapRef = useRef(null);\n\n  useEffect(() \\=> {\n    if (mapRef.current === null) {\n      mapRef.current = new MapWidget(containerRef.current);\n    }\n\n    const map = mapRef.current;\n    map.setZoom(zoomLevel);\n  }, \\[zoomLevel\\]);\n\n  return (\n    <div\n      style\\={{ width: 200, height: 200 }}\n      ref\\={containerRef}\n    />\n  );\n}\n\nIn this example, a cleanup function is not needed because the `MapWidget` class manages only the DOM node that was passed to it. After the `Map` React component is removed from the tree, both the DOM node and the `MapWidget` class instance will be automatically garbage-collected by the browser JavaScript engine.\n\n* * *\n\n### Fetching data with Effects[](#fetching-data-with-effects \"Link for Fetching data with Effects \")\n\nYou can use an Effect to fetch data for your component. Note that [if you use a framework,](https://react.dev/learn/start-a-new-react-project#production-grade-react-frameworks) using your framework‚Äôs data fetching mechanism will be a lot more efficient than writing Effects manually.\n\nIf you want to fetch data from an Effect manually, your code might look like this:\n\n```\nimport { useState, useEffect } from 'react';import { fetchBio } from './api.js';export default function Page() {const [person, setPerson] = useState('Alice');const [bio, setBio] = useState(null);useEffect(() => {let ignore = false;setBio(null);fetchBio(person).then(result => {if (!ignore) {setBio(result);}});return () => {ignore = true;};}, [person]);// ...\n```\n\nNote the `ignore` variable which is initialized to `false`, and is set to `true` during cleanup. This ensures [your code doesn‚Äôt suffer from ‚Äúrace conditions‚Äù:](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect) network responses may arrive in a different order than you sent them.\n\nimport { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n  const \\[person, setPerson\\] = useState('Alice');\n  const \\[bio, setBio\\] = useState(null);\n  useEffect(() \\=> {\n    let ignore = false;\n    setBio(null);\n    fetchBio(person).then(result \\=> {\n      if (!ignore) {\n        setBio(result);\n      }\n    });\n    return () \\=> {\n      ignore = true;\n    }\n  }, \\[person\\]);\n\n  return (\n    <\\>\n      <select value\\={person} onChange\\={e \\=> {\n        setPerson(e.target.value);\n      }}\\>\n        <option value\\=\"Alice\"\\>Alice</option\\>\n        <option value\\=\"Bob\"\\>Bob</option\\>\n        <option value\\=\"Taylor\"\\>Taylor</option\\>\n      </select\\>\n      <hr />\n      <p\\><i\\>{bio ?? 'Loading...'}</i\\></p\\>\n    </\\>\n  );\n}\n\nYou can also rewrite using the [`async` / `await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) syntax, but you still need to provide a cleanup function:\n\nimport { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n  const \\[person, setPerson\\] = useState('Alice');\n  const \\[bio, setBio\\] = useState(null);\n  useEffect(() \\=> {\n    async function startFetching() {\n      setBio(null);\n      const result = await fetchBio(person);\n      if (!ignore) {\n        setBio(result);\n      }\n    }\n\n    let ignore = false;\n    startFetching();\n    return () \\=> {\n      ignore = true;\n    }\n  }, \\[person\\]);\n\n  return (\n    <\\>\n      <select value\\={person} onChange\\={e \\=> {\n        setPerson(e.target.value);\n      }}\\>\n        <option value\\=\"Alice\"\\>Alice</option\\>\n        <option value\\=\"Bob\"\\>Bob</option\\>\n        <option value\\=\"Taylor\"\\>Taylor</option\\>\n      </select\\>\n      <hr />\n      <p\\><i\\>{bio ?? 'Loading...'}</i\\></p\\>\n    </\\>\n  );\n}\n\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. [It‚Äôs easier to use a custom Hook‚Äîeither your own or maintained by the community.](https://react.dev/learn/reusing-logic-with-custom-hooks#when-to-use-custom-hooks)\n\n##### Deep Dive\n\n#### What are good alternatives to data fetching in Effects?[](#what-are-good-alternatives-to-data-fetching-in-effects \"Link for What are good alternatives to data fetching in Effects? \")\n\nWriting `fetch` calls inside Effects is a [popular way to fetch data](https://www.robinwieruch.de/react-hooks-fetch-data/), especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\n\n*   **Effects don‚Äôt run on the server.** This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\n*   **Fetching directly in Effects makes it easy to create ‚Äúnetwork waterfalls‚Äù.** You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\n*   **Fetching directly in Effects usually means you don‚Äôt preload or cache data.** For example, if the component unmounts and then mounts again, it would have to fetch the data again.\n*   **It‚Äôs not very ergonomic.** There‚Äôs quite a bit of boilerplate code involved when writing `fetch` calls in a way that doesn‚Äôt suffer from bugs like [race conditions.](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect)\n\nThis list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n\n*   **If you use a [framework](https://react.dev/learn/start-a-new-react-project#production-grade-react-frameworks), use its built-in data fetching mechanism.** Modern React frameworks have integrated data fetching mechanisms that are efficient and don‚Äôt suffer from the above pitfalls.\n*   **Otherwise, consider using or building a client-side cache.** Popular open source solutions include [React Query](https://tanstack.com/query/latest/), [useSWR](https://swr.vercel.app/), and [React Router 6.4+.](https://beta.reactrouter.com/en/main/start/overview) You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).\n\nYou can continue fetching data directly in Effects if neither of these approaches suit you.\n\n* * *\n\n### Specifying reactive dependencies[](#specifying-reactive-dependencies \"Link for Specifying reactive dependencies \")\n\n**Notice that you can‚Äôt ‚Äúchoose‚Äù the dependencies of your Effect.** Every reactive value used by your Effect‚Äôs code must be declared as a dependency. Your Effect‚Äôs dependency list is determined by the surrounding code:\n\n```\nfunction ChatRoom({ roomId }) { // This is a reactive valueconst [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value toouseEffect(() => {const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive valuesconnection.connect();return () => connection.disconnect();}, [serverUrl, roomId]); // ‚úÖ So you must specify them as dependencies of your Effect// ...}\n```\n\nIf either `serverUrl` or `roomId` change, your Effect will reconnect to the chat using the new values.\n\n**[Reactive values](https://react.dev/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values) include props and all variables and functions declared directly inside of your component.** Since `roomId` and `serverUrl` are reactive values, you can‚Äôt remove them from the dependencies. If you try to omit them and [your linter is correctly configured for React,](https://react.dev/learn/editor-setup#linting) the linter will flag this as a mistake you need to fix:\n\n```\nfunction ChatRoom({ roomId }) {const [serverUrl, setServerUrl] = useState('https://localhost:1234');useEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => connection.disconnect();}, []); // üî¥ React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'// ...}\n```\n\n**To remove a dependency, you need to [‚Äúprove‚Äù to the linter that it _doesn‚Äôt need_ to be a dependency.](https://react.dev/learn/removing-effect-dependencies#removing-unnecessary-dependencies)** For example, you can move `serverUrl` out of your component to prove that it‚Äôs not reactive and won‚Äôt change on re-renders:\n\n```\nconst serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) {useEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => connection.disconnect();}, [roomId]); // ‚úÖ All dependencies declared// ...}\n```\n\nNow that `serverUrl` is not a reactive value (and can‚Äôt change on a re-render), it doesn‚Äôt need to be a dependency. **If your Effect‚Äôs code doesn‚Äôt use any reactive values, its dependency list should be empty (`[]`):**\n\n```\nconst serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() {useEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => connection.disconnect();}, []); // ‚úÖ All dependencies declared// ...}\n```\n\n[An Effect with empty dependencies](https://react.dev/learn/lifecycle-of-reactive-effects#what-an-effect-with-empty-dependencies-means) doesn‚Äôt re-run when any of your component‚Äôs props or state change.\n\n### Pitfall\n\nIf you have an existing codebase, you might have some Effects that suppress the linter like this:\n\n```\nuseEffect(() => {// ...// üî¥ Avoid suppressing the linter like this:// eslint-ignore-next-line react-hooks/exhaustive-deps}, []);\n```\n\n**When dependencies don‚Äôt match the code, there is a high risk of introducing bugs.** By suppressing the linter, you ‚Äúlie‚Äù to React about the values your Effect depends on. [Instead, prove they‚Äôre unnecessary.](https://react.dev/learn/removing-effect-dependencies#removing-unnecessary-dependencies)\n\n#### Examples of passing reactive dependencies[](#examples-dependencies \"Link for Examples of passing reactive dependencies\")\n\n#### Passing a dependency array[](#passing-a-dependency-array \"Link for this heading\")\n\nIf you specify the dependencies, your Effect runs **after the initial render _and_ after re-renders with changed dependencies.**\n\n```\nuseEffect(() => {// ...}, [a, b]); // Runs again if a or b are different\n```\n\nIn the below example, `serverUrl` and `roomId` are [reactive values,](https://react.dev/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values) so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since `message` isn‚Äôt used in the Effect (and so it isn‚Äôt a dependency), editing the message doesn‚Äôt re-connect to the chat.\n\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n  const \\[serverUrl, setServerUrl\\] = useState('https://localhost:1234');\n  const \\[message, setMessage\\] = useState('');\n\n  useEffect(() \\=> {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () \\=> {\n      connection.disconnect();\n    };\n  }, \\[serverUrl, roomId\\]);\n\n  return (\n    <\\>\n      <label\\>\n        Server URL:{' '}\n        <input\n          value\\={serverUrl}\n          onChange\\={e \\=> setServerUrl(e.target.value)}\n        />\n      </label\\>\n      <h1\\>Welcome to the {roomId} room!</h1\\>\n      <label\\>\n        Your message:{' '}\n        <input value\\={message} onChange\\={e \\=> setMessage(e.target.value)} />\n      </label\\>\n    </\\>\n  );\n}\n\nexport default function App() {\n  const \\[show, setShow\\] = useState(false);\n  const \\[roomId, setRoomId\\] = useState('general');\n  return (\n    <\\>\n      <label\\>\n        Choose the chat room:{' '}\n        <select\n          value\\={roomId}\n          onChange\\={e \\=> setRoomId(e.target.value)}\n        \\>\n          <option value\\=\"general\"\\>general</option\\>\n          <option value\\=\"travel\"\\>travel</option\\>\n          <option value\\=\"music\"\\>music</option\\>\n        </select\\>\n        <button onClick\\={() \\=> setShow(!show)}\\>\n          {show ? 'Close chat' : 'Open chat'}\n        </button\\>\n      </label\\>\n      {show && <hr />}\n      {show && <ChatRoom roomId\\={roomId}/>}\n    </\\>\n  );\n}\n\n* * *\n\n### Updating state based on previous state from an Effect[](#updating-state-based-on-previous-state-from-an-effect \"Link for Updating state based on previous state from an Effect \")\n\nWhen you want to update state based on previous state from an Effect, you might run into a problem:\n\n```\nfunction Counter() {const [count, setCount] = useState(0);useEffect(() => {const intervalId = setInterval(() => {setCount(count + 1); // You want to increment the counter every second...}, 1000)return () => clearInterval(intervalId);}, [count]); // üö© ... but specifying `count` as a dependency always resets the interval.// ...}\n```\n\nSince `count` is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the `count` changes. This is not ideal.\n\nTo fix this, [pass the `c => c + 1` state updater](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state) to `setCount`:\n\nNow that you‚Äôre passing `c => c + 1` instead of `count + 1`, [your Effect no longer needs to depend on `count`.](https://react.dev/learn/removing-effect-dependencies#are-you-reading-some-state-to-calculate-the-next-state) As a result of this fix, it won‚Äôt need to cleanup and setup the interval again every time the `count` changes.\n\n* * *\n\n### Removing unnecessary object dependencies[](#removing-unnecessary-object-dependencies \"Link for Removing unnecessary object dependencies \")\n\nIf your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the `options` object is [different for every render:](https://react.dev/learn/removing-effect-dependencies#does-some-reactive-value-change-unintentionally)\n\n```\nconst serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {const [message, setMessage] = useState('');const options = { // üö© This object is created from scratch on every re-renderserverUrl: serverUrl,roomId: roomId};useEffect(() => {const connection = createConnection(options); // It's used inside the Effectconnection.connect();return () => connection.disconnect();}, [options]); // üö© As a result, these dependencies are always different on a re-render// ...\n```\n\nAvoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:\n\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const \\[message, setMessage\\] = useState('');\n\n  useEffect(() \\=> {\n    const options = {\n      serverUrl: serverUrl,\n      roomId: roomId\n    };\n    const connection = createConnection(options);\n    connection.connect();\n    return () \\=> connection.disconnect();\n  }, \\[roomId\\]);\n\n  return (\n    <\\>\n      <h1\\>Welcome to the {roomId} room!</h1\\>\n      <input value\\={message} onChange\\={e \\=> setMessage(e.target.value)} />\n    </\\>\n  );\n}\n\nexport default function App() {\n  const \\[roomId, setRoomId\\] = useState('general');\n  return (\n    <\\>\n      <label\\>\n        Choose the chat room:{' '}\n        <select\n          value\\={roomId}\n          onChange\\={e \\=> setRoomId(e.target.value)}\n        \\>\n          <option value\\=\"general\"\\>general</option\\>\n          <option value\\=\"travel\"\\>travel</option\\>\n          <option value\\=\"music\"\\>music</option\\>\n        </select\\>\n      </label\\>\n      <hr />\n      <ChatRoom roomId\\={roomId} />\n    </\\>\n  );\n}\n\nNow that you create the `options` object inside the Effect, the Effect itself only depends on the `roomId` string.\n\nWith this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike an object which gets re-created, a string like `roomId` doesn‚Äôt change unless you set it to another value. [Read more about removing dependencies.](https://react.dev/learn/removing-effect-dependencies)\n\n* * *\n\n### Removing unnecessary function dependencies[](#removing-unnecessary-function-dependencies \"Link for Removing unnecessary function dependencies \")\n\nIf your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the `createOptions` function is [different for every render:](https://react.dev/learn/removing-effect-dependencies#does-some-reactive-value-change-unintentionally)\n\n```\nfunction ChatRoom({ roomId }) {const [message, setMessage] = useState('');function createOptions() { // üö© This function is created from scratch on every re-renderreturn {serverUrl: serverUrl,roomId: roomId};}useEffect(() => {const options = createOptions(); // It's used inside the Effectconst connection = createConnection();connection.connect();return () => connection.disconnect();}, [createOptions]); // üö© As a result, these dependencies are always different on a re-render// ...\n```\n\nBy itself, creating a function from scratch on every re-render is not a problem. You don‚Äôt need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render.\n\nAvoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:\n\nimport { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const \\[message, setMessage\\] = useState('');\n\n  useEffect(() \\=> {\n    function createOptions() {\n      return {\n        serverUrl: serverUrl,\n        roomId: roomId\n      };\n    }\n\n    const options = createOptions();\n    const connection = createConnection(options);\n    connection.connect();\n    return () \\=> connection.disconnect();\n  }, \\[roomId\\]);\n\n  return (\n    <\\>\n      <h1\\>Welcome to the {roomId} room!</h1\\>\n      <input value\\={message} onChange\\={e \\=> setMessage(e.target.value)} />\n    </\\>\n  );\n}\n\nexport default function App() {\n  const \\[roomId, setRoomId\\] = useState('general');\n  return (\n    <\\>\n      <label\\>\n        Choose the chat room:{' '}\n        <select\n          value\\={roomId}\n          onChange\\={e \\=> setRoomId(e.target.value)}\n        \\>\n          <option value\\=\"general\"\\>general</option\\>\n          <option value\\=\"travel\"\\>travel</option\\>\n          <option value\\=\"music\"\\>music</option\\>\n        </select\\>\n      </label\\>\n      <hr />\n      <ChatRoom roomId\\={roomId} />\n    </\\>\n  );\n}\n\nNow that you define the `createOptions` function inside the Effect, the Effect itself only depends on the `roomId` string. With this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike a function which gets re-created, a string like `roomId` doesn‚Äôt change unless you set it to another value. [Read more about removing dependencies.](https://react.dev/learn/removing-effect-dependencies)\n\n* * *\n\n### Reading the latest props and state from an Effect[](#reading-the-latest-props-and-state-from-an-effect \"Link for Reading the latest props and state from an Effect \")\n\n### Under Construction\n\nThis section describes an **experimental API that has not yet been released** in a stable version of React.\n\nBy default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect ‚Äúreacts‚Äù to every change of that value. For most dependencies, that‚Äôs the behavior you want.\n\n**However, sometimes you‚Äôll want to read the _latest_ props and state from an Effect without ‚Äúreacting‚Äù to them.** For example, imagine you want to log the number of the items in the shopping cart for every page visit:\n\n```\nfunction Page({ url, shoppingCart }) {useEffect(() => {logVisit(url, shoppingCart.length);}, [url, shoppingCart]); // ‚úÖ All dependencies declared// ...}\n```\n\n**What if you want to log a new page visit after every `url` change, but _not_ if only the `shoppingCart` changes?** You can‚Äôt exclude `shoppingCart` from dependencies without breaking the [reactivity rules.](#specifying-reactive-dependencies) However, you can express that you _don‚Äôt want_ a piece of code to ‚Äúreact‚Äù to changes even though it is called from inside an Effect. [Declare an _Effect Event_](https://react.dev/learn/separating-events-from-effects#declaring-an-effect-event) with the [`useEffectEvent`](https://react.dev/reference/react/experimental_useEffectEvent) Hook, and move the code reading `shoppingCart` inside of it:\n\n```\nfunction Page({ url, shoppingCart }) {const onVisit = useEffectEvent(visitedUrl => {logVisit(visitedUrl, shoppingCart.length)});useEffect(() => {onVisit(url);}, [url]); // ‚úÖ All dependencies declared// ...}\n```\n\n**Effect Events are not reactive and must always be omitted from dependencies of your Effect.** This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading `shoppingCart` inside of `onVisit`, you ensure that `shoppingCart` won‚Äôt re-run your Effect.\n\n[Read more about how Effect Events let you separate reactive and non-reactive code.](https://react.dev/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events)\n\n* * *\n\n### Displaying different content on the server and the client[](#displaying-different-content-on-the-server-and-the-client \"Link for Displaying different content on the server and the client \")\n\nIf your app uses server rendering (either [directly](https://react.dev/reference/react-dom/server) or via a [framework](https://react.dev/learn/start-a-new-react-project#production-grade-react-frameworks)), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for [hydration](https://react.dev/reference/react-dom/client/hydrateRoot#hydrating-server-rendered-html) to work, your initial render output must be identical on the client and the server.\n\nIn rare cases, you might need to display different content on the client. For example, if your app reads some data from [`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage), it can‚Äôt possibly do that on the server. Here is how you could implement this:\n\n```\nfunction MyComponent() {const [didMount, setDidMount] = useState(false);useEffect(() => {setDidMount(true);}, []);if (didMount) {// ... return client-only JSX ...}  else {// ... return initial JSX ...}}\n```\n\nWhile the app is loading, the user will see the initial render output. Then, when it‚Äôs loaded and hydrated, your Effect will run and set `didMount` to `true`, triggering a re-render. This will switch to the client-only render output. Effects don‚Äôt run on the server, so this is why `didMount` was `false` during the initial server render.\n\nUse this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time‚Äîpotentially, many seconds‚Äîso you don‚Äôt want to make jarring changes to your component‚Äôs appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### My Effect runs twice when the component mounts[](#my-effect-runs-twice-when-the-component-mounts \"Link for My Effect runs twice when the component mounts \")\n\nWhen Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.\n\nThis is a stress-test that verifies your Effect‚Äôs logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn‚Äôt be able to distinguish between the setup being called once (as in production) and a setup ‚Üí cleanup ‚Üí setup sequence (as in development).\n\nRead more about [how this helps find bugs](https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed) and [how to fix your logic.](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)\n\n* * *\n\n### My Effect runs after every re-render[](#my-effect-runs-after-every-re-render \"Link for My Effect runs after every re-render \")\n\nFirst, check that you haven‚Äôt forgotten to specify the dependency array:\n\n```\nuseEffect(() => {// ...}); // üö© No dependency array: re-runs after every render!\n```\n\nIf you‚Äôve specified the dependency array but your Effect still re-runs in a loop, it‚Äôs because one of your dependencies is different on every re-render.\n\nYou can debug this problem by manually logging your dependencies to the console:\n\n```\nuseEffect(() => {// ..}, [serverUrl, roomId]);console.log([serverUrl, roomId]);\n```\n\nYou can then right-click on the arrays from different re-renders in the console and select ‚ÄúStore as a global variable‚Äù for both of them. Assuming the first one got saved as `temp1` and the second one got saved as `temp2`, you can then use the browser console to check whether each dependency in both arrays is the same:\n\n```\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n```\n\nWhen you find the dependency that is different on every re-render, you can usually fix it in one of these ways:\n\n*   [Updating state based on previous state from an Effect](#updating-state-based-on-previous-state-from-an-effect)\n*   [Removing unnecessary object dependencies](#removing-unnecessary-object-dependencies)\n*   [Removing unnecessary function dependencies](#removing-unnecessary-function-dependencies)\n*   [Reading the latest props and state from an Effect](#reading-the-latest-props-and-state-from-an-effect)\n\nAs a last resort (if these methods didn‚Äôt help), wrap its creation with [`useMemo`](https://react.dev/reference/react/useMemo#memoizing-a-dependency-of-another-hook) or [`useCallback`](https://react.dev/reference/react/useCallback#preventing-an-effect-from-firing-too-often) (for functions).\n\n* * *\n\n### My Effect keeps re-running in an infinite cycle[](#my-effect-keeps-re-running-in-an-infinite-cycle \"Link for My Effect keeps re-running in an infinite cycle \")\n\nIf your Effect runs in an infinite cycle, these two things must be true:\n\n*   Your Effect is updating some state.\n*   That state leads to a re-render, which causes the Effect‚Äôs dependencies to change.\n\nBefore you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application‚Äôs data flow with it?\n\nIf there is no external system, consider whether [removing the Effect altogether](https://react.dev/learn/you-might-not-need-an-effect) would simplify your logic.\n\nIf you‚Äôre genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component‚Äôs visual output? If you need to keep track of some data that isn‚Äôt used by rendering, a [ref](https://react.dev/reference/react/useRef#referencing-a-value-with-a-ref) (which doesn‚Äôt trigger re-renders) might be more appropriate. Verify your Effect doesn‚Äôt update the state (and trigger re-renders) more than needed.\n\nFinally, if your Effect is updating the state at the right time, but there is still a loop, it‚Äôs because that state update leads to one of the Effect‚Äôs dependencies changing. [Read how to debug dependency changes.](https://react.dev/reference/react/useEffect#my-effect-runs-after-every-re-render)\n\n* * *\n\n### My cleanup logic runs even though my component didn‚Äôt unmount[](#my-cleanup-logic-runs-even-though-my-component-didnt-unmount \"Link for My cleanup logic runs even though my component didn‚Äôt unmount \")\n\nThe cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React [runs setup+cleanup one extra time immediately after component mounts.](#my-effect-runs-twice-when-the-component-mounts)\n\nIf you have cleanup code without corresponding setup code, it‚Äôs usually a code smell:\n\n```\nuseEffect(() => {// üî¥ Avoid: Cleanup logic without corresponding setup logicreturn () => {doSomething();};}, []);\n```\n\nYour cleanup logic should be ‚Äúsymmetrical‚Äù to the setup logic, and should stop or undo whatever setup did:\n\n```\nuseEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => {connection.disconnect();};}, [serverUrl, roomId]);\n```\n\n[Learn how the Effect lifecycle is different from the component‚Äôs lifecycle.](https://react.dev/learn/lifecycle-of-reactive-effects#the-lifecycle-of-an-effect)\n\n* * *\n\n### My Effect does something visual, and I see a flicker before it runs[](#my-effect-does-something-visual-and-i-see-a-flicker-before-it-runs \"Link for My Effect does something visual, and I see a flicker before it runs \")\n\nIf your Effect must block the browser from [painting the screen,](https://react.dev/learn/render-and-commit#epilogue-browser-paint) replace `useEffect` with [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect). Note that **this shouldn‚Äôt be needed for the vast majority of Effects.** You‚Äôll only need this if it‚Äôs crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.",
  "title": "useEffect ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useOptimistic",
  "markdown": "# useOptimistic ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Canary\n\n`useOptimistic` is a React Hook that lets you optimistically update the UI.\n\n```\nconst [optimisticState, addOptimistic] = useOptimistic(state, updateFn);\n```\n\n*   [Reference](#reference)\n    *   [`useOptimistic(state, updateFn)`](#use)\n*   [Usage](#usage)\n    *   [Optimistically updating forms](#optimistically-updating-with-forms)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useOptimistic(state, updateFn)`[](#use \"Link for this heading\")\n\n`useOptimistic` is a React Hook that lets you show a different state while an async action is underway. It accepts some state as an argument and returns a copy of that state that can be different during the duration of an async action such as a network request. You provide a function that takes the current state and the input to the action, and returns the optimistic state to be used while the action is pending.\n\nThis state is called the ‚Äúoptimistic‚Äù state because it is usually used to immediately present the user with the result of performing an action, even though the action actually takes time to complete.\n\n```\nimport { useOptimistic } from 'react';function AppContainer() {const [optimisticState, addOptimistic] = useOptimistic(state,// updateFn(currentState, optimisticValue) => {// merge and return new state// with optimistic value});}\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `state`: the value to be returned initially and whenever no action is pending.\n*   `updateFn(currentState, optimisticValue)`: a function that takes the current state and the optimistic value passed to `addOptimistic` and returns the resulting optimistic state. It must be a pure function. `updateFn` takes in two parameters. The `currentState` and the `optimisticValue`. The return value will be the merged value of the `currentState` and `optimisticValue`.\n\n#### Returns[](#returns \"Link for Returns \")\n\n*   `optimisticState`: The resulting optimistic state. It is equal to `state` unless an action is pending, in which case it is equal to the value returned by `updateFn`.\n*   `addOptimistic`: `addOptimistic` is the dispatching function to call when you have an optimistic update. It takes one argument, `optimisticValue`, of any type and will call the `updateFn` with `state` and `optimisticValue`.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Optimistically updating forms[](#optimistically-updating-with-forms \"Link for Optimistically updating forms \")\n\nThe `useOptimistic` Hook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server‚Äôs response to reflect the changes, the interface is immediately updated with the expected outcome.\n\nFor example, when a user types a message into the form and hits the ‚ÄúSend‚Äù button, the `useOptimistic` Hook allows the message to immediately appear in the list with a ‚ÄúSending‚Ä¶‚Äù label, even before the message is actually sent to a server. This ‚Äúoptimistic‚Äù approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the ‚ÄúSending‚Ä¶‚Äù label is removed.",
  "title": "useOptimistic ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useLayoutEffect",
  "markdown": "# useLayoutEffect ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Pitfall\n\n`useLayoutEffect` can hurt performance. Prefer [`useEffect`](https://react.dev/reference/react/useEffect) when possible.\n\n`useLayoutEffect` is a version of [`useEffect`](https://react.dev/reference/react/useEffect) that fires before the browser repaints the screen.\n\n```\nuseLayoutEffect(setup, dependencies?)\n```\n\n*   [Reference](#reference)\n    *   [`useLayoutEffect(setup, dependencies?)`](#useinsertioneffect)\n*   [Usage](#usage)\n    *   [Measuring layout before the browser repaints the screen](#measuring-layout-before-the-browser-repaints-the-screen)\n*   [Troubleshooting](#troubleshooting)\n    *   [I‚Äôm getting an error: ‚Äú`useLayoutEffect` does nothing on the server‚Äù](#im-getting-an-error-uselayouteffect-does-nothing-on-the-server)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useLayoutEffect(setup, dependencies?)`[](#useinsertioneffect \"Link for this heading\")\n\nCall `useLayoutEffect` to perform the layout measurements before the browser repaints the screen:\n\n```\nimport { useState, useRef, useLayoutEffect } from 'react';function Tooltip() {const ref = useRef(null);const [tooltipHeight, setTooltipHeight] = useState(0);useLayoutEffect(() => {const { height } = ref.current.getBoundingClientRect();setTooltipHeight(height);}, []);// ...\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `setup`: The function with your Effect‚Äôs logic. Your setup function may also optionally return a _cleanup_ function. Before your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function.\n    \n*   **optional** `dependencies`: The list of all reactive values referenced inside of the `setup` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://react.dev/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. If you omit this argument, your Effect will re-run after every re-render of the component.\n    \n\n#### Returns[](#returns \"Link for Returns \")\n\n`useLayoutEffect` returns `undefined`.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   `useLayoutEffect` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a component and move the Effect there.\n    \n*   When Strict Mode is on, React will **run one extra development-only setup+cleanup cycle** before the first real setup. This is a stress-test that ensures that your cleanup logic ‚Äúmirrors‚Äù your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, [implement the cleanup function.](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)\n    \n*   If some of your dependencies are objects or functions defined inside the component, there is a risk that they will **cause the Effect to re-run more often than needed.** To fix this, remove unnecessary [object](https://react.dev/reference/react/useEffect#removing-unnecessary-object-dependencies) and [function](https://react.dev/reference/react/useEffect#removing-unnecessary-function-dependencies) dependencies. You can also [extract state updates](https://react.dev/reference/react/useEffect#updating-state-based-on-previous-state-from-an-effect) and [non-reactive logic](https://react.dev/reference/react/useEffect#reading-the-latest-props-and-state-from-an-effect) outside of your Effect.\n    \n*   Effects **only run on the client.** They don‚Äôt run during server rendering.\n    \n*   The code inside `useLayoutEffect` and all state updates scheduled from it **block the browser from repainting the screen.** When used excessively, this makes your app slow. When possible, prefer [`useEffect`.](https://react.dev/reference/react/useEffect)\n    \n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Measuring layout before the browser repaints the screen[](#measuring-layout-before-the-browser-repaints-the-screen \"Link for Measuring layout before the browser repaints the screen \")\n\nMost components don‚Äôt need to know their position and size on the screen to decide what to render. They only return some JSX. Then the browser calculates their _layout_ (position and size) and repaints the screen.\n\nSometimes, that‚Äôs not enough. Imagine a tooltip that appears next to some element on hover. If there‚Äôs enough space, the tooltip should appear above the element, but if it doesn‚Äôt fit, it should appear below. In order to render the tooltip at the right final position, you need to know its height (i.e. whether it fits at the top).\n\nTo do this, you need to render in two passes:\n\n1.  Render the tooltip anywhere (even with a wrong position).\n2.  Measure its height and decide where to place the tooltip.\n3.  Render the tooltip _again_ in the correct place.\n\n**All of this needs to happen before the browser repaints the screen.** You don‚Äôt want the user to see the tooltip moving. Call `useLayoutEffect` to perform the layout measurements before the browser repaints the screen:\n\n```\nfunction Tooltip() {const ref = useRef(null);const [tooltipHeight, setTooltipHeight] = useState(0); // You don't know real height yetuseLayoutEffect(() => {const { height } = ref.current.getBoundingClientRect();setTooltipHeight(height); // Re-render now that you know the real height}, []);// ...use tooltipHeight in the rendering logic below...}\n```\n\nHere‚Äôs how this works step by step:\n\n1.  `Tooltip` renders with the initial `tooltipHeight = 0` (so the tooltip may be wrongly positioned).\n2.  React places it in the DOM and runs the code in `useLayoutEffect`.\n3.  Your `useLayoutEffect` [measures the height](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect) of the tooltip content and triggers an immediate re-render.\n4.  `Tooltip` renders again with the real `tooltipHeight` (so the tooltip is correctly positioned).\n5.  React updates it in the DOM, and the browser finally displays the tooltip.\n\nHover over the buttons below and see how the tooltip adjusts its position depending on whether it fits:\n\nimport { useRef, useLayoutEffect, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport TooltipContainer from './TooltipContainer.js';\n\nexport default function Tooltip({ children, targetRect }) {\n  const ref = useRef(null);\n  const \\[tooltipHeight, setTooltipHeight\\] = useState(0);\n\n  useLayoutEffect(() \\=> {\n    const { height } = ref.current.getBoundingClientRect();\n    setTooltipHeight(height);\n    console.log('Measured tooltip height: ' + height);\n  }, \\[\\]);\n\n  let tooltipX = 0;\n  let tooltipY = 0;\n  if (targetRect !== null) {\n    tooltipX = targetRect.left;\n    tooltipY = targetRect.top - tooltipHeight;\n    if (tooltipY < 0) {\n      \n      tooltipY = targetRect.bottom;\n    }\n  }\n\n  return createPortal(\n    <TooltipContainer x\\={tooltipX} y\\={tooltipY} contentRef\\={ref}\\>\n      {children}\n    </TooltipContainer\\>,\n    document.body\n  );\n}\n\nNotice that even though the `Tooltip` component has to render in two passes (first, with `tooltipHeight` initialized to `0` and then with the real measured height), you only see the final result. This is why you need `useLayoutEffect` instead of [`useEffect`](https://react.dev/reference/react/useEffect) for this example. Let‚Äôs look at the difference in detail below.\n\n#### useLayoutEffect vs useEffect[](#examples \"Link for useLayoutEffect vs useEffect\")\n\n#### `useLayoutEffect` blocks the browser from repainting[](#uselayouteffect-blocks-the-browser-from-repainting \"Link for this heading\")\n\nReact guarantees that the code inside `useLayoutEffect` and any state updates scheduled inside it will be processed **before the browser repaints the screen.** This lets you render the tooltip, measure it, and re-render the tooltip again without the user noticing the first extra render. In other words, `useLayoutEffect` blocks the browser from painting.\n\nimport { useRef, useLayoutEffect, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport TooltipContainer from './TooltipContainer.js';\n\nexport default function Tooltip({ children, targetRect }) {\n  const ref = useRef(null);\n  const \\[tooltipHeight, setTooltipHeight\\] = useState(0);\n\n  useLayoutEffect(() \\=> {\n    const { height } = ref.current.getBoundingClientRect();\n    setTooltipHeight(height);\n  }, \\[\\]);\n\n  let tooltipX = 0;\n  let tooltipY = 0;\n  if (targetRect !== null) {\n    tooltipX = targetRect.left;\n    tooltipY = targetRect.top - tooltipHeight;\n    if (tooltipY < 0) {\n      \n      tooltipY = targetRect.bottom;\n    }\n  }\n\n  return createPortal(\n    <TooltipContainer x\\={tooltipX} y\\={tooltipY} contentRef\\={ref}\\>\n      {children}\n    </TooltipContainer\\>,\n    document.body\n  );\n}\n\n### Note\n\nRendering in two passes and blocking the browser hurts performance. Try to avoid this when you can.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### I‚Äôm getting an error: ‚Äú`useLayoutEffect` does nothing on the server‚Äù[](#im-getting-an-error-uselayouteffect-does-nothing-on-the-server \"Link for this heading\")\n\nThe purpose of `useLayoutEffect` is to let your component [use layout information for rendering:](#measuring-layout-before-the-browser-repaints-the-screen)\n\n1.  Render the initial content.\n2.  Measure the layout _before the browser repaints the screen._\n3.  Render the final content using the layout information you‚Äôve read.\n\nWhen you or your framework uses [server rendering](https://react.dev/reference/react-dom/server), your React app renders to HTML on the server for the initial render. This lets you show the initial HTML before the JavaScript code loads.\n\nThe problem is that on the server, there is no layout information.\n\nIn the [earlier example](#measuring-layout-before-the-browser-repaints-the-screen), the `useLayoutEffect` call in the `Tooltip` component lets it position itself correctly (either above or below content) depending on the content height. If you tried to render `Tooltip` as a part of the initial server HTML, this would be impossible to determine. On the server, there is no layout yet! So, even if you rendered it on the server, its position would ‚Äújump‚Äù on the client after the JavaScript loads and runs.\n\nUsually, components that rely on layout information don‚Äôt need to render on the server anyway. For example, it probably doesn‚Äôt make sense to show a `Tooltip` during the initial render. It is triggered by a client interaction.\n\nHowever, if you‚Äôre running into this problem, you have a few different options:\n\n*   Replace `useLayoutEffect` with [`useEffect`.](https://react.dev/reference/react/useEffect) This tells React that it‚Äôs okay to display the initial render result without blocking the paint (because the original HTML will become visible before your Effect runs).\n    \n*   Alternatively, [mark your component as client-only.](https://react.dev/reference/react/Suspense#providing-a-fallback-for-server-errors-and-client-only-content) This tells React to replace its content up to the closest [`<Suspense>`](https://react.dev/reference/react/Suspense) boundary with a loading fallback (for example, a spinner or a glimmer) during server rendering.\n    \n*   Alternatively, you can render a component with `useLayoutEffect` only after hydration. Keep a boolean `isMounted` state that‚Äôs initialized to `false`, and set it to `true` inside a `useEffect` call. Your rendering logic can then be like `return isMounted ? <RealContent /> : <FallbackContent />`. On the server and during the hydration, the user will see `FallbackContent` which should not call `useLayoutEffect`. Then React will replace it with `RealContent` which runs on the client only and can include `useLayoutEffect` calls.\n    \n*   If you synchronize your component with an external data store and rely on `useLayoutEffect` for different reasons than measuring layout, consider [`useSyncExternalStore`](https://react.dev/reference/react/useSyncExternalStore) instead which [supports server rendering.](https://react.dev/reference/react/useSyncExternalStore#adding-support-for-server-rendering)",
  "title": "useLayoutEffect ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useMemo",
  "markdown": "# useMemo ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useMemo` is a React Hook that lets you cache the result of a calculation between re-renders.\n\n```\nconst cachedValue = useMemo(calculateValue, dependencies)\n```\n\n*   [Reference](#reference)\n    *   [`useMemo(calculateValue, dependencies)`](#usememo)\n*   [Usage](#usage)\n    *   [Skipping expensive recalculations](#skipping-expensive-recalculations)\n    *   [Skipping re-rendering of components](#skipping-re-rendering-of-components)\n    *   [Memoizing a dependency of another Hook](#memoizing-a-dependency-of-another-hook)\n    *   [Memoizing a function](#memoizing-a-function)\n*   [Troubleshooting](#troubleshooting)\n    *   [My calculation runs twice on every re-render](#my-calculation-runs-twice-on-every-re-render)\n    *   [My `useMemo` call is supposed to return an object, but returns undefined](#my-usememo-call-is-supposed-to-return-an-object-but-returns-undefined)\n    *   [Every time my component renders, the calculation in `useMemo` re-runs](#every-time-my-component-renders-the-calculation-in-usememo-re-runs)\n    *   [I need to call `useMemo` for each list item in a loop, but it‚Äôs not allowed](#i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useMemo(calculateValue, dependencies)`[](#usememo \"Link for this heading\")\n\nCall `useMemo` at the top level of your component to cache a calculation between re-renders:\n\n```\nimport { useMemo } from 'react';function TodoList({ todos, tab }) {const visibleTodos = useMemo(() => filterTodos(todos, tab),[todos, tab]);// ...}\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `calculateValue`: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the `dependencies` have not changed since the last render. Otherwise, it will call `calculateValue`, return its result, and store it so it can be reused later.\n    \n*   `dependencies`: The list of all reactive values referenced inside of the `calculateValue` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://react.dev/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison.\n    \n\n#### Returns[](#returns \"Link for Returns \")\n\nOn the initial render, `useMemo` returns the result of calling `calculateValue` with no arguments.\n\nDuring next renders, it will either return an already stored value from the last render (if the dependencies haven‚Äôt changed), or call `calculateValue` again, and return the result that `calculateValue` has returned.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   `useMemo` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n*   In Strict Mode, React will **call your calculation function twice** in order to [help you find accidental impurities.](#my-calculation-runs-twice-on-every-re-render) This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect your logic. The result from one of the calls will be ignored.\n*   React **will not throw away the cached value unless there is a specific reason to do that.** For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache‚Äîfor example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should be fine if you rely on `useMemo` solely as a performance optimization. Otherwise, a [state variable](https://react.dev/reference/react/useState#avoiding-recreating-the-initial-state) or a [ref](https://react.dev/reference/react/useRef#avoiding-recreating-the-ref-contents) may be more appropriate.\n\n### Note\n\nCaching return values like this is also known as [_memoization_,](https://en.wikipedia.org/wiki/Memoization) which is why this Hook is called `useMemo`.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Skipping expensive recalculations[](#skipping-expensive-recalculations \"Link for Skipping expensive recalculations \")\n\nTo cache a calculation between re-renders, wrap it in a `useMemo` call at the top level of your component:\n\n```\nimport { useMemo } from 'react';function TodoList({ todos, tab, theme }) {const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);// ...}\n```\n\nYou need to pass two things to `useMemo`:\n\n1.  A calculation function that takes no arguments, like `() =>`, and returns what you wanted to calculate.\n2.  A list of dependencies including every value within your component that‚Äôs used inside your calculation.\n\nOn the initial render, the value you‚Äôll get from `useMemo` will be the result of calling your calculation.\n\nOn every subsequent render, React will compare the dependencies with the dependencies you passed during the last render. If none of the dependencies have changed (compared with [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), `useMemo` will return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value.\n\nIn other words, `useMemo` caches a calculation result between re-renders until its dependencies change.\n\n**Let‚Äôs walk through an example to see when this is useful.**\n\nBy default, React will re-run the entire body of your component every time that it re-renders. For example, if this `TodoList` updates its state or receives new props from its parent, the `filterTodos` function will re-run:\n\n```\nfunction TodoList({ todos, tab, theme }) {const visibleTodos = filterTodos(todos, tab);// ...}\n```\n\nUsually, this isn‚Äôt a problem because most calculations are very fast. However, if you‚Äôre filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasn‚Äôt changed. If both `todos` and `tab` are the same as they were during the last render, wrapping the calculation in `useMemo` like earlier lets you reuse `visibleTodos` you‚Äôve already calculated before.\n\nThis type of caching is called _[memoization.](https://en.wikipedia.org/wiki/Memoization)_\n\n### Note\n\n**You should only rely on `useMemo` as a performance optimization.** If your code doesn‚Äôt work without it, find the underlying problem and fix it first. Then you may add `useMemo` to improve performance.\n\n##### Deep Dive\n\n#### How to tell if a calculation is expensive?[](#how-to-tell-if-a-calculation-is-expensive \"Link for How to tell if a calculation is expensive? \")\n\nIn general, unless you‚Äôre creating or looping over thousands of objects, it‚Äôs probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:\n\n```\nconsole.time('filter array');const visibleTodos = filterTodos(todos, tab);console.timeEnd('filter array');\n```\n\nPerform the interaction you‚Äôre measuring (for example, typing into the input). You will then see logs like `filter array: 0.15ms` in your console. If the overall logged time adds up to a significant amount (say, `1ms` or more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in `useMemo` to verify whether the total logged time has decreased for that interaction or not:\n\n```\nconsole.time('filter array');const visibleTodos = useMemo(() => {return filterTodos(todos, tab); // Skipped if todos and tab haven't changed}, [todos, tab]);console.timeEnd('filter array');\n```\n\n`useMemo` won‚Äôt make the _first_ render faster. It only helps you skip unnecessary work on updates.\n\nKeep in mind that your machine is probably faster than your users‚Äô so it‚Äôs a good idea to test the performance with an artificial slowdown. For example, Chrome offers a [CPU Throttling](https://developer.chrome.com/blog/new-in-devtools-61/#throttling) option for this.\n\nAlso note that measuring performance in development will not give you the most accurate results. (For example, when [Strict Mode](https://react.dev/reference/react/StrictMode) is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.\n\n##### Deep Dive\n\n#### Should you add useMemo everywhere?[](#should-you-add-usememo-everywhere \"Link for Should you add useMemo everywhere? \")\n\nIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.\n\nOptimizing with `useMemo` is only valuable in a few cases:\n\n*   The calculation you‚Äôre putting in `useMemo` is noticeably slow, and its dependencies rarely change.\n*   You pass it as a prop to a component wrapped in [`memo`.](https://react.dev/reference/react/memo) You want to skip re-rendering if the value hasn‚Äôt changed. Memoization lets your component re-render only when dependencies aren‚Äôt the same.\n*   The value you‚Äôre passing is later used as a dependency of some Hook. For example, maybe another `useMemo` calculation value depends on it. Or maybe you are depending on this value from [`useEffect.`](https://react.dev/reference/react/useEffect)\n\nThere is no benefit to wrapping a calculation in `useMemo` in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that‚Äôs ‚Äúalways new‚Äù is enough to break memoization for an entire component.\n\n**In practice, you can make a lot of memoization unnecessary by following a few principles:**\n\n1.  When a component visually wraps other components, let it [accept JSX as children.](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) This way, when the wrapper component updates its own state, React knows that its children don‚Äôt need to re-render.\n2.  Prefer local state and don‚Äôt [lift state up](https://react.dev/learn/sharing-state-between-components) any further than necessary. For example, don‚Äôt keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\n3.  Keep your [rendering logic pure.](https://react.dev/learn/keeping-components-pure) If re-rendering a component causes a problem or produces some noticeable visual artifact, it‚Äôs a bug in your component! Fix the bug instead of adding memoization.\n4.  Avoid [unnecessary Effects that update state.](https://react.dev/learn/you-might-not-need-an-effect) Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\n5.  Try to [remove unnecessary dependencies from your Effects.](https://react.dev/learn/removing-effect-dependencies) For example, instead of memoization, it‚Äôs often simpler to move some object or a function inside an Effect or outside the component.\n\nIf a specific interaction still feels laggy, [use the React Developer Tools profiler](https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html) to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it‚Äôs good to follow them in any case. In the long term, we‚Äôre researching [doing granular memoization automatically](https://www.youtube.com/watch?v=lGEMwh32soc) to solve this once and for all.\n\n* * *\n\n### Skipping re-rendering of components[](#skipping-re-rendering-of-components \"Link for Skipping re-rendering of components \")\n\nIn some cases, `useMemo` can also help you optimize performance of re-rendering child components. To illustrate this, let‚Äôs say this `TodoList` component passes the `visibleTodos` as a prop to the child `List` component:\n\n```\nexport default function TodoList({ todos, tab, theme }) {// ...return (<div className={theme}><List items={visibleTodos} /></div>);}\n```\n\nYou‚Äôve noticed that toggling the `theme` prop freezes the app for a moment, but if you remove `<List />` from your JSX, it feels fast. This tells you that it‚Äôs worth trying to optimize the `List` component.\n\n**By default, when a component re-renders, React re-renders all of its children recursively.** This is why, when `TodoList` re-renders with a different `theme`, the `List` component _also_ re-renders. This is fine for components that don‚Äôt require much calculation to re-render. But if you‚Äôve verified that a re-render is slow, you can tell `List` to skip re-rendering when its props are the same as on last render by wrapping it in [`memo`:](https://react.dev/reference/react/memo)\n\n```\nimport { memo } from 'react';const List = memo(function List({ items }) {// ...});\n```\n\n**With this change, `List` will skip re-rendering if all of its props are the _same_ as on the last render.** This is where caching the calculation becomes important! Imagine that you calculated `visibleTodos` without `useMemo`:\n\n```\nexport default function TodoList({ todos, tab, theme }) {// Every time the theme changes, this will be a different array...const visibleTodos = filterTodos(todos, tab);return (<div className={theme}>{/* ... so List's props will never be the same, and it will re-render every time */}<List items={visibleTodos} /></div>);}\n```\n\n**In the above example, the `filterTodos` function always creates a _different_ array,** similar to how the `{}` object literal always creates a new object. Normally, this wouldn‚Äôt be a problem, but it means that `List` props will never be the same, and your [`memo`](https://react.dev/reference/react/memo) optimization won‚Äôt work. This is where `useMemo` comes in handy:\n\n```\nexport default function TodoList({ todos, tab, theme }) {// Tell React to cache your calculation between re-renders...const visibleTodos = useMemo(() => filterTodos(todos, tab),[todos, tab] // ...so as long as these dependencies don't change...);return (<div className={theme}>{/* ...List will receive the same props and can skip re-rendering */}<List items={visibleTodos} /></div>);}\n```\n\n**By wrapping the `visibleTodos` calculation in `useMemo`, you ensure that it has the _same_ value between the re-renders** (until dependencies change). You don‚Äôt _have to_ wrap a calculation in `useMemo` unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in [`memo`,](https://react.dev/reference/react/memo) and this lets it skip re-rendering. There are a few other reasons to add `useMemo` which are described further on this page.\n\n##### Deep Dive\n\n#### Memoizing individual JSX nodes[](#memoizing-individual-jsx-nodes \"Link for Memoizing individual JSX nodes \")\n\nInstead of wrapping `List` in [`memo`](https://react.dev/reference/react/memo), you could wrap the `<List />` JSX node itself in `useMemo`:\n\n```\nexport default function TodoList({ todos, tab, theme }) {const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);const children = useMemo(() => <List items={visibleTodos} />, [visibleTodos]);return (<div className={theme}>{children}</div>);}\n```\n\nThe behavior would be the same. If the `visibleTodos` haven‚Äôt changed, `List` won‚Äôt be re-rendered.\n\nA JSX node like `<List items={visibleTodos} />` is an object like `{ type: List, props: { items: visibleTodos } }`. Creating this object is very cheap, but React doesn‚Äôt know whether its contents is the same as last time or not. This is why by default, React will re-render the `List` component.\n\nHowever, if React sees the same exact JSX as during the previous render, it won‚Äôt try to re-render your component. This is because JSX nodes are [immutable.](https://en.wikipedia.org/wiki/Immutable_object) A JSX node object could not have changed over time, so React knows it‚Äôs safe to skip a re-render. However, for this to work, the node has to _actually be the same object_, not merely look the same in code. This is what `useMemo` does in this example.\n\nManually wrapping JSX nodes into `useMemo` is not convenient. For example, you can‚Äôt do this conditionally. This is usually why you would wrap components with [`memo`](https://react.dev/reference/react/memo) instead of wrapping JSX nodes.\n\n* * *\n\n### Memoizing a dependency of another Hook[](#memoizing-a-dependency-of-another-hook \"Link for Memoizing a dependency of another Hook \")\n\nSuppose you have a calculation that depends on an object created directly in the component body:\n\n```\nfunction Dropdown({ allItems, text }) {const searchOptions = { matchMode: 'whole-word', text };const visibleItems = useMemo(() => {return searchItems(allItems, searchOptions);}, [allItems, searchOptions]); // üö© Caution: Dependency on an object created in the component body// ...\n```\n\nDepending on an object like this defeats the point of memoization. When a component re-renders, all of the code directly inside the component body runs again. **The lines of code creating the `searchOptions` object will also run on every re-render.** Since `searchOptions` is a dependency of your `useMemo` call, and it‚Äôs different every time, React knows the dependencies are different, and recalculate `searchItems` every time.\n\nTo fix this, you could memoize the `searchOptions` object _itself_ before passing it as a dependency:\n\n```\nfunction Dropdown({ allItems, text }) {const searchOptions = useMemo(() => {return { matchMode: 'whole-word', text };}, [text]); // ‚úÖ Only changes when text changesconst visibleItems = useMemo(() => {return searchItems(allItems, searchOptions);}, [allItems, searchOptions]); // ‚úÖ Only changes when allItems or searchOptions changes// ...\n```\n\nIn the example above, if the `text` did not change, the `searchOptions` object also won‚Äôt change. However, an even better fix is to move the `searchOptions` object declaration _inside_ of the `useMemo` calculation function:\n\n```\nfunction Dropdown({ allItems, text }) {const visibleItems = useMemo(() => {const searchOptions = { matchMode: 'whole-word', text };return searchItems(allItems, searchOptions);}, [allItems, text]); // ‚úÖ Only changes when allItems or text changes// ...\n```\n\nNow your calculation depends on `text` directly (which is a string and can‚Äôt ‚Äúaccidentally‚Äù become different).\n\n* * *\n\n### Memoizing a function[](#memoizing-a-function \"Link for Memoizing a function \")\n\nSuppose the `Form` component is wrapped in [`memo`.](https://react.dev/reference/react/memo) You want to pass a function to it as a prop:\n\n```\nexport default function ProductPage({ productId, referrer }) {function handleSubmit(orderDetails) {post('/product/' + productId + '/buy', {referrer,orderDetails});}return <Form onSubmit={handleSubmit} />;}\n```\n\nJust as `{}` creates a different object, function declarations like `function() {}` and expressions like `() => {}` produce a _different_ function on every re-render. By itself, creating a new function is not a problem. This is not something to avoid! However, if the `Form` component is memoized, presumably you want to skip re-rendering it when no props have changed. A prop that is _always_ different would defeat the point of memoization.\n\nTo memoize a function with `useMemo`, your calculation function would have to return another function:\n\n```\nexport default function Page({ productId, referrer }) {const handleSubmit = useMemo(() => {return (orderDetails) => {post('/product/' + productId + '/buy', {referrer,orderDetails});};}, [productId, referrer]);return <Form onSubmit={handleSubmit} />;}\n```\n\nThis looks clunky! **Memoizing functions is common enough that React has a built-in Hook specifically for that. Wrap your functions into [`useCallback`](https://react.dev/reference/react/useCallback) instead of `useMemo`** to avoid having to write an extra nested function:\n\n```\nexport default function Page({ productId, referrer }) {const handleSubmit = useCallback((orderDetails) => {post('/product/' + productId + '/buy', {referrer,orderDetails});}, [productId, referrer]);return <Form onSubmit={handleSubmit} />;}\n```\n\nThe two examples above are completely equivalent. The only benefit to `useCallback` is that it lets you avoid writing an extra nested function inside. It doesn‚Äôt do anything else. [Read more about `useCallback`.](https://react.dev/reference/react/useCallback)\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### My calculation runs twice on every re-render[](#my-calculation-runs-twice-on-every-re-render \"Link for My calculation runs twice on every re-render \")\n\nIn [Strict Mode](https://react.dev/reference/react/StrictMode), React will call some of your functions twice instead of once:\n\n```\nfunction TodoList({ todos, tab }) {// This component function will run twice for every render.const visibleTodos = useMemo(() => {// This calculation will run twice if any of the dependencies change.return filterTodos(todos, tab);}, [todos, tab]);// ...\n```\n\nThis is expected and shouldn‚Äôt break your code.\n\nThis **development-only** behavior helps you [keep components pure.](https://react.dev/learn/keeping-components-pure) React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldn‚Äôt affect your logic. However, if they are accidentally impure, this helps you notice and fix the mistake.\n\nFor example, this impure calculation function mutates an array you received as a prop:\n\n```\nconst visibleTodos = useMemo(() => {// üö© Mistake: mutating a proptodos.push({ id: 'last', text: 'Go for a walk!' });const filtered = filterTodos(todos, tab);return filtered;}, [todos, tab]);\n```\n\nReact calls your function twice, so you‚Äôd notice the todo is added twice. Your calculation shouldn‚Äôt change any existing objects, but it‚Äôs okay to change any _new_ objects you created during the calculation. For example, if the `filterTodos` function always returns a _different_ array, you can mutate _that_ array instead:\n\n```\nconst visibleTodos = useMemo(() => {const filtered = filterTodos(todos, tab);// ‚úÖ Correct: mutating an object you created during the calculationfiltered.push({ id: 'last', text: 'Go for a walk!' });return filtered;}, [todos, tab]);\n```\n\nRead [keeping components pure](https://react.dev/learn/keeping-components-pure) to learn more about purity.\n\nAlso, check out the guides on [updating objects](https://react.dev/learn/updating-objects-in-state) and [updating arrays](https://react.dev/learn/updating-arrays-in-state) without mutation.\n\n* * *\n\n### My `useMemo` call is supposed to return an object, but returns undefined[](#my-usememo-call-is-supposed-to-return-an-object-but-returns-undefined \"Link for this heading\")\n\nThis code doesn‚Äôt work:\n\n```\n// üî¥ You can't return an object from an arrow function with () => {const searchOptions = useMemo(() => {    matchMode: 'whole-word',text: text}, [text]);\n```\n\nIn JavaScript, `() => {` starts the arrow function body, so the `{` brace is not a part of your object. This is why it doesn‚Äôt return an object, and leads to mistakes. You could fix it by adding parentheses like `({` and `})`:\n\n```\n// This works, but is easy for someone to break againconst searchOptions = useMemo(() => ({matchMode: 'whole-word',text: text}), [text]);\n```\n\nHowever, this is still confusing and too easy for someone to break by removing the parentheses.\n\nTo avoid this mistake, write a `return` statement explicitly:\n\n```\n// ‚úÖ This works and is explicitconst searchOptions = useMemo(() => {return {matchMode: 'whole-word',text: text};}, [text]);\n```\n\n* * *\n\n### Every time my component renders, the calculation in `useMemo` re-runs[](#every-time-my-component-renders-the-calculation-in-usememo-re-runs \"Link for this heading\")\n\nMake sure you‚Äôve specified the dependency array as a second argument!\n\nIf you forget the dependency array, `useMemo` will re-run the calculation every time:\n\n```\nfunction TodoList({ todos, tab }) {// üî¥ Recalculates every time: no dependency arrayconst visibleTodos = useMemo(() => filterTodos(todos, tab));// ...\n```\n\nThis is the corrected version passing the dependency array as a second argument:\n\n```\nfunction TodoList({ todos, tab }) {// ‚úÖ Does not recalculate unnecessarilyconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);// ...\n```\n\nIf this doesn‚Äôt help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:\n\n```\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);console.log([todos, tab]);\n```\n\nYou can then right-click on the arrays from different re-renders in the console and select ‚ÄúStore as a global variable‚Äù for both of them. Assuming the first one got saved as `temp1` and the second one got saved as `temp2`, you can then use the browser console to check whether each dependency in both arrays is the same:\n\n```\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\n```\n\nWhen you find which dependency breaks memoization, either find a way to remove it, or [memoize it as well.](#memoizing-a-dependency-of-another-hook)\n\n* * *\n\n### I need to call `useMemo` for each list item in a loop, but it‚Äôs not allowed[](#i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed \"Link for this heading\")\n\nSuppose the `Chart` component is wrapped in [`memo`](https://react.dev/reference/react/memo). You want to skip re-rendering every `Chart` in the list when the `ReportList` component re-renders. However, you can‚Äôt call `useMemo` in a loop:\n\n```\nfunction ReportList({ items }) {return (<article>{items.map(item => {// üî¥ You can't call useMemo in a loop like this:const data = useMemo(() => calculateReport(item), [item]);return (<figure key={item.id}><Chart data={data} /></figure>);})}</article>);}\n```\n\nInstead, extract a component for each item and memoize data for individual items:\n\n```\nfunction ReportList({ items }) {return (<article>{items.map(item =><Report key={item.id} item={item} />)}</article>);}function Report({ item }) {// ‚úÖ Call useMemo at the top level:const data = useMemo(() => calculateReport(item), [item]);return (<figure><Chart data={data} /></figure>);}\n```\n\nAlternatively, you could remove `useMemo` and instead wrap `Report` itself in [`memo`.](https://react.dev/reference/react/memo) If the `item` prop does not change, `Report` will skip re-rendering, so `Chart` will skip re-rendering too:\n\n```\nfunction ReportList({ items }) {// ...}const Report = memo(function Report({ item }) {const data = calculateReport(item);return (<figure><Chart data={data} /></figure>);});\n```",
  "title": "useMemo ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useRef",
  "markdown": "# useRef ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useRef` is a React Hook that lets you reference a value that‚Äôs not needed for rendering.\n\n```\nconst ref = useRef(initialValue)\n```\n\n*   [Reference](#reference)\n    *   [`useRef(initialValue)`](#useref)\n*   [Usage](#usage)\n    *   [Referencing a value with a ref](#referencing-a-value-with-a-ref)\n    *   [Manipulating the DOM with a ref](#manipulating-the-dom-with-a-ref)\n    *   [Avoiding recreating the ref contents](#avoiding-recreating-the-ref-contents)\n*   [Troubleshooting](#troubleshooting)\n    *   [I can‚Äôt get a ref to a custom component](#i-cant-get-a-ref-to-a-custom-component)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useRef(initialValue)`[](#useref \"Link for this heading\")\n\nCall `useRef` at the top level of your component to declare a [ref.](https://react.dev/learn/referencing-values-with-refs)\n\n```\nimport { useRef } from 'react';function MyComponent() {const intervalRef = useRef(0);const inputRef = useRef(null);// ...\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `initialValue`: The value you want the ref object‚Äôs `current` property to be initially. It can be a value of any type. This argument is ignored after the initial render.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`useRef` returns an object with a single property:\n\n*   `current`: Initially, it‚Äôs set to the `initialValue` you have passed. You can later set it to something else. If you pass the ref object to React as a `ref` attribute to a JSX node, React will set its `current` property.\n\nOn the next renders, `useRef` will return the same object.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   You can mutate the `ref.current` property. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldn‚Äôt mutate that object.\n*   When you change the `ref.current` property, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object.\n*   Do not write _or read_ `ref.current` during rendering, except for [initialization.](#avoiding-recreating-the-ref-contents) This makes your component‚Äôs behavior unpredictable.\n*   In Strict Mode, React will **call your component function twice** in order to [help you find accidental impurities.](https://react.dev/reference/react/useState#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. Each ref object will be created twice, but one of the versions will be discarded. If your component function is pure (as it should be), this should not affect the behavior.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Referencing a value with a ref[](#referencing-a-value-with-a-ref \"Link for Referencing a value with a ref \")\n\nCall `useRef` at the top level of your component to declare one or more [refs.](https://react.dev/learn/referencing-values-with-refs)\n\n```\nimport { useRef } from 'react';function Stopwatch() {const intervalRef = useRef(0);// ...\n```\n\n`useRef` returns a ref object with a single `current` property initially set to the initial value you provided.\n\nOn the next renders, `useRef` will return the same object. You can change its `current` property to store information and read it later. This might remind you of [state](https://react.dev/reference/react/useState), but there is an important difference.\n\n**Changing a ref does not trigger a re-render.** This means refs are perfect for storing information that doesn‚Äôt affect the visual output of your component. For example, if you need to store an [interval ID](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) and retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change its `current` property:\n\n```\nfunction handleStartClick() {const intervalId = setInterval(() => {// ...}, 1000);intervalRef.current = intervalId;}\n```\n\nLater, you can read that interval ID from the ref so that you can call [clear that interval](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval):\n\n```\nfunction handleStopClick() {const intervalId = intervalRef.current;clearInterval(intervalId);}\n```\n\nBy using a ref, you ensure that:\n\n*   You can **store information** between re-renders (unlike regular variables, which reset on every render).\n*   Changing it **does not trigger a re-render** (unlike state variables, which trigger a re-render).\n*   The **information is local** to each copy of your component (unlike the variables outside, which are shared).\n\nChanging a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more about [choosing between `useRef` and `useState`.](https://react.dev/learn/referencing-values-with-refs#differences-between-refs-and-state)\n\n#### Examples of referencing a value with useRef[](#examples-value \"Link for Examples of referencing a value with useRef\")\n\n#### Click counter[](#click-counter \"Link for this heading\")\n\nThis component uses a ref to keep track of how many times the button was clicked. Note that it‚Äôs okay to use a ref instead of state here because the click count is only read and written in an event handler.\n\nimport { useRef } from 'react';\n\nexport default function Counter() {\n  let ref = useRef(0);\n\n  function handleClick() {\n    ref.current = ref.current + 1;\n    alert('You clicked ' + ref.current + ' times!');\n  }\n\n  return (\n    <button onClick\\={handleClick}\\>\n      Click me!\n    </button\\>\n  );\n}\n\nIf you show `{ref.current}` in the JSX, the number won‚Äôt update on click. This is because setting `ref.current` does not trigger a re-render. Information that‚Äôs used for rendering should be state instead.\n\n### Pitfall\n\n**Do not write _or read_ `ref.current` during rendering.**\n\nReact expects that the body of your component [behaves like a pure function](https://react.dev/learn/keeping-components-pure):\n\n*   If the inputs ([props](https://react.dev/learn/passing-props-to-a-component), [state](https://react.dev/learn/state-a-components-memory), and [context](https://react.dev/learn/passing-data-deeply-with-context)) are the same, it should return exactly the same JSX.\n*   Calling it in a different order or with different arguments should not affect the results of other calls.\n\nReading or writing a ref **during rendering** breaks these expectations.\n\n```\nfunction MyComponent() {// ...// üö© Don't write a ref during renderingmyRef.current = 123;// ...// üö© Don't read a ref during renderingreturn <h1>{myOtherRef.current}</h1>;}\n```\n\nYou can read or write refs **from event handlers or effects instead**.\n\n```\nfunction MyComponent() {// ...useEffect(() => {// ‚úÖ You can read or write refs in effectsmyRef.current = 123;});// ...function handleClick() {// ‚úÖ You can read or write refs in event handlersdoSomething(myOtherRef.current);}// ...}\n```\n\nIf you _have to_ read [or write](https://react.dev/reference/react/useState#storing-information-from-previous-renders) something during rendering, [use state](https://react.dev/reference/react/useState) instead.\n\nWhen you break these rules, your component might still work, but most of the newer features we‚Äôre adding to React will rely on these expectations. Read more about [keeping your components pure.](https://react.dev/learn/keeping-components-pure#where-you-_can_-cause-side-effects)\n\n* * *\n\n### Manipulating the DOM with a ref[](#manipulating-the-dom-with-a-ref \"Link for Manipulating the DOM with a ref \")\n\nIt‚Äôs particularly common to use a ref to manipulate the [DOM.](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API) React has built-in support for this.\n\nFirst, declare a ref object with an initial value of `null`:\n\n```\nimport { useRef } from 'react';function MyComponent() {const inputRef = useRef(null);// ...\n```\n\nThen pass your ref object as the `ref` attribute to the JSX of the DOM node you want to manipulate:\n\n```\n// ...return <input ref={inputRef} />;\n```\n\nAfter React creates the DOM node and puts it on the screen, React will set the `current` property of your ref object to that DOM node. Now you can access the `<input>`‚Äôs DOM node and call methods like [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus):\n\n```\nfunction handleClick() {inputRef.current.focus();}\n```\n\nReact will set the `current` property back to `null` when the node is removed from the screen.\n\nRead more about [manipulating the DOM with refs.](https://react.dev/learn/manipulating-the-dom-with-refs)\n\n#### Examples of manipulating the DOM with useRef[](#examples-dom \"Link for Examples of manipulating the DOM with useRef\")\n\n#### Focusing a text input[](#focusing-a-text-input \"Link for this heading\")\n\nIn this example, clicking the button will focus the input:\n\nimport { useRef } from 'react';\n\nexport default function Form() {\n  const inputRef = useRef(null);\n\n  function handleClick() {\n    inputRef.current.focus();\n  }\n\n  return (\n    <\\>\n      <input ref\\={inputRef} />\n      <button onClick\\={handleClick}\\>\n        Focus the input\n      </button\\>\n    </\\>\n  );\n}\n\n* * *\n\n### Avoiding recreating the ref contents[](#avoiding-recreating-the-ref-contents \"Link for Avoiding recreating the ref contents \")\n\nReact saves the initial ref value once and ignores it on the next renders.\n\n```\nfunction Video() {const playerRef = useRef(new VideoPlayer());// ...\n```\n\nAlthough the result of `new VideoPlayer()` is only used for the initial render, you‚Äôre still calling this function on every render. This can be wasteful if it‚Äôs creating expensive objects.\n\nTo solve it, you may initialize the ref like this instead:\n\n```\nfunction Video() {const playerRef = useRef(null);if (playerRef.current === null) {playerRef.current = new VideoPlayer();}// ...\n```\n\nNormally, writing or reading `ref.current` during render is not allowed. However, it‚Äôs fine in this case because the result is always the same, and the condition only executes during initialization so it‚Äôs fully predictable.\n\n##### Deep Dive\n\n#### How to avoid null checks when initializing useRef later[](#how-to-avoid-null-checks-when-initializing-use-ref-later \"Link for How to avoid null checks when initializing useRef later \")\n\nIf you use a type checker and don‚Äôt want to always check for `null`, you can try a pattern like this instead:\n\n```\nfunction Video() {const playerRef = useRef(null);function getPlayer() {if (playerRef.current !== null) {return playerRef.current;}const player = new VideoPlayer();playerRef.current = player;return player;}// ...\n```\n\nHere, the `playerRef` itself is nullable. However, you should be able to convince your type checker that there is no case in which `getPlayer()` returns `null`. Then use `getPlayer()` in your event handlers.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### I can‚Äôt get a ref to a custom component[](#i-cant-get-a-ref-to-a-custom-component \"Link for I can‚Äôt get a ref to a custom component \")\n\nIf you try to pass a `ref` to your own component like this:\n\n```\nconst inputRef = useRef(null);return <MyInput ref={inputRef} />;\n```\n\nYou might get an error in the console:\n\nWarning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\n\nBy default, your own components don‚Äôt expose refs to the DOM nodes inside them.\n\nTo fix this, find the component that you want to get a ref to:\n\n```\nexport default function MyInput({ value, onChange }) {return (<inputvalue={value}onChange={onChange}/>);}\n```\n\nAnd then wrap it in [`forwardRef`](https://react.dev/reference/react/forwardRef) like this:\n\n```\nimport { forwardRef } from 'react';const MyInput = forwardRef(({ value, onChange }, ref) => {return (<inputvalue={value}onChange={onChange}ref={ref}/>);});export default MyInput;\n```\n\nThen the parent component can get a ref to it.\n\nRead more about [accessing another component‚Äôs DOM nodes.](https://react.dev/learn/manipulating-the-dom-with-refs#accessing-another-components-dom-nodes)",
  "title": "useRef ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useReducer",
  "markdown": "# useReducer ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useReducer` is a React Hook that lets you add a [reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer) to your component.\n\n```\nconst [state, dispatch] = useReducer(reducer, initialArg, init?)\n```\n\n*   [Reference](#reference)\n    *   [`useReducer(reducer, initialArg, init?)`](#usereducer)\n    *   [`dispatch` function](#dispatch)\n*   [Usage](#usage)\n    *   [Adding a reducer to a component](#adding-a-reducer-to-a-component)\n    *   [Writing the reducer function](#writing-the-reducer-function)\n    *   [Avoiding recreating the initial state](#avoiding-recreating-the-initial-state)\n*   [Troubleshooting](#troubleshooting)\n    *   [I‚Äôve dispatched an action, but logging gives me the old state value](#ive-dispatched-an-action-but-logging-gives-me-the-old-state-value)\n    *   [I‚Äôve dispatched an action, but the screen doesn‚Äôt update](#ive-dispatched-an-action-but-the-screen-doesnt-update)\n    *   [A part of my reducer state becomes undefined after dispatching](#a-part-of-my-reducer-state-becomes-undefined-after-dispatching)\n    *   [My entire reducer state becomes undefined after dispatching](#my-entire-reducer-state-becomes-undefined-after-dispatching)\n    *   [I‚Äôm getting an error: ‚ÄúToo many re-renders‚Äù](#im-getting-an-error-too-many-re-renders)\n    *   [My reducer or initializer function runs twice](#my-reducer-or-initializer-function-runs-twice)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useReducer(reducer, initialArg, init?)`[](#usereducer \"Link for this heading\")\n\nCall `useReducer` at the top level of your component to manage its state with a [reducer.](https://react.dev/learn/extracting-state-logic-into-a-reducer)\n\n```\nimport { useReducer } from 'react';function reducer(state, action) {// ...}function MyComponent() {const [state, dispatch] = useReducer(reducer, { age: 42 });// ...\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `reducer`: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types.\n*   `initialArg`: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the next `init` argument.\n*   **optional** `init`: The initializer function that should return the initial state. If it‚Äôs not specified, the initial state is set to `initialArg`. Otherwise, the initial state is set to the result of calling `init(initialArg)`.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`useReducer` returns an array with exactly two values:\n\n1.  The current state. During the first render, it‚Äôs set to `init(initialArg)` or `initialArg` (if there‚Äôs no `init`).\n2.  The [`dispatch` function](#dispatch) that lets you update the state to a different value and trigger a re-render.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   `useReducer` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n*   In Strict Mode, React will **call your reducer and initializer twice** in order to [help you find accidental impurities.](#my-reducer-or-initializer-function-runs-twice) This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they should be), this should not affect your logic. The result from one of the calls is ignored.\n\n* * *\n\n### `dispatch` function[](#dispatch \"Link for this heading\")\n\nThe `dispatch` function returned by `useReducer` lets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to the `dispatch` function:\n\n```\nconst [state, dispatch] = useReducer(reducer, { age: 42 });function handleClick() {dispatch({ type: 'incremented_age' });// ...\n```\n\nReact will set the next state to the result of calling the `reducer` function you‚Äôve provided with the current `state` and the action you‚Äôve passed to `dispatch`.\n\n#### Parameters[](#dispatch-parameters \"Link for Parameters \")\n\n*   `action`: The action performed by the user. It can be a value of any type. By convention, an action is usually an object with a `type` property identifying it and, optionally, other properties with additional information.\n\n#### Returns[](#dispatch-returns \"Link for Returns \")\n\n`dispatch` functions do not have a return value.\n\n#### Caveats[](#setstate-caveats \"Link for Caveats \")\n\n*   The `dispatch` function **only updates the state variable for the _next_ render**. If you read the state variable after calling the `dispatch` function, [you will still get the old value](#ive-dispatched-an-action-but-logging-gives-me-the-old-state-value) that was on the screen before your call.\n    \n*   If the new value you provide is identical to the current `state`, as determined by an [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison, React will **skip re-rendering the component and its children.** This is an optimization. React may still need to call your component before ignoring the result, but it shouldn‚Äôt affect your code.\n    \n*   React [batches state updates.](https://react.dev/learn/queueing-a-series-of-state-updates) It updates the screen **after all the event handlers have run** and have called their `set` functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use [`flushSync`.](https://react.dev/reference/react-dom/flushSync)\n    \n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Adding a reducer to a component[](#adding-a-reducer-to-a-component \"Link for Adding a reducer to a component \")\n\nCall `useReducer` at the top level of your component to manage state with a [reducer.](https://react.dev/learn/extracting-state-logic-into-a-reducer)\n\n```\nimport { useReducer } from 'react';function reducer(state, action) {// ...}function MyComponent() {const [state, dispatch] = useReducer(reducer, { age: 42 });// ...\n```\n\n`useReducer` returns an array with exactly two items:\n\n1.  The current state of this state variable, initially set to the initial state you provided.\n2.  The `dispatch` function that lets you change it in response to interaction.\n\nTo update what‚Äôs on the screen, call `dispatch` with an object representing what the user did, called an _action_:\n\n```\nfunction handleClick() {dispatch({ type: 'incremented_age' });}\n```\n\nReact will pass the current state and the action to your reducer function. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI.\n\n`useReducer` is very similar to [`useState`](https://react.dev/reference/react/useState), but it lets you move the state update logic from event handlers into a single function outside of your component. Read more about [choosing between `useState` and `useReducer`.](https://react.dev/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer)\n\n* * *\n\n### Writing the reducer function[](#writing-the-reducer-function \"Link for Writing the reducer function \")\n\nA reducer function is declared like this:\n\n```\nfunction reducer(state, action) {// ...}\n```\n\nThen you need to fill in the code that will calculate and return the next state. By convention, it is common to write it as a [`switch` statement.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch) For each `case` in the `switch`, calculate and return some next state.\n\n```\nfunction reducer(state, action) {switch (action.type) {case 'incremented_age': {return {name: state.name,age: state.age + 1};}case 'changed_name': {return {name: action.nextName,age: state.age};}}throw Error('Unknown action: ' + action.type);}\n```\n\nActions can have any shape. By convention, it‚Äôs common to pass objects with a `type` property identifying the action. It should include the minimal necessary information that the reducer needs to compute the next state.\n\n```\nfunction Form() {const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });function handleButtonClick() {dispatch({ type: 'incremented_age' });}function handleInputChange(e) {dispatch({type: 'changed_name',nextName: e.target.value});}// ...\n```\n\nThe action type names are local to your component. [Each action describes a single interaction, even if that leads to multiple changes in data.](https://react.dev/learn/extracting-state-logic-into-a-reducer#writing-reducers-well) The shape of the state is arbitrary, but usually it‚Äôll be an object or an array.\n\nRead [extracting state logic into a reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer) to learn more.\n\n### Pitfall\n\nState is read-only. Don‚Äôt modify any objects or arrays in state:\n\n```\nfunction reducer(state, action) {switch (action.type) {case 'incremented_age': {// üö© Don't mutate an object in state like this:state.age = state.age + 1;return state;}\n```\n\nInstead, always return new objects from your reducer:\n\n```\nfunction reducer(state, action) {switch (action.type) {case 'incremented_age': {// ‚úÖ Instead, return a new objectreturn {...state,age: state.age + 1};}\n```\n\nRead [updating objects in state](https://react.dev/learn/updating-objects-in-state) and [updating arrays in state](https://react.dev/learn/updating-arrays-in-state) to learn more.\n\n* * *\n\n### Avoiding recreating the initial state[](#avoiding-recreating-the-initial-state \"Link for Avoiding recreating the initial state \")\n\nReact saves the initial state once and ignores it on the next renders.\n\n```\nfunction createInitialState(username) {// ...}function TodoList({ username }) {const [state, dispatch] = useReducer(reducer, createInitialState(username));// ...\n```\n\nAlthough the result of `createInitialState(username)` is only used for the initial render, you‚Äôre still calling this function on every render. This can be wasteful if it‚Äôs creating large arrays or performing expensive calculations.\n\nTo solve this, you may **pass it as an _initializer_ function** to `useReducer` as the third argument instead:\n\n```\nfunction createInitialState(username) {// ...}function TodoList({ username }) {const [state, dispatch] = useReducer(reducer, username, createInitialState);// ...\n```\n\nNotice that you‚Äôre passing `createInitialState`, which is the _function itself_, and not `createInitialState()`, which is the result of calling it. This way, the initial state does not get re-created after initialization.\n\nIn the above example, `createInitialState` takes a `username` argument. If your initializer doesn‚Äôt need any information to compute the initial state, you may pass `null` as the second argument to `useReducer`.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### I‚Äôve dispatched an action, but logging gives me the old state value[](#ive-dispatched-an-action-but-logging-gives-me-the-old-state-value \"Link for I‚Äôve dispatched an action, but logging gives me the old state value \")\n\nCalling the `dispatch` function **does not change state in the running code**:\n\n```\nfunction handleClick() {console.log(state.age);  // 42dispatch({ type: 'incremented_age' }); // Request a re-render with 43console.log(state.age);  // Still 42!setTimeout(() => {console.log(state.age); // Also 42!}, 5000);}\n```\n\nThis is because [states behaves like a snapshot.](https://react.dev/learn/state-as-a-snapshot) Updating state requests another render with the new state value, but does not affect the `state` JavaScript variable in your already-running event handler.\n\nIf you need to guess the next state value, you can calculate it manually by calling the reducer yourself:\n\n```\nconst action = { type: 'incremented_age' };dispatch(action);const nextState = reducer(state, action);console.log(state);     // { age: 42 }console.log(nextState); // { age: 43 }\n```\n\n* * *\n\n### I‚Äôve dispatched an action, but the screen doesn‚Äôt update[](#ive-dispatched-an-action-but-the-screen-doesnt-update \"Link for I‚Äôve dispatched an action, but the screen doesn‚Äôt update \")\n\nReact will **ignore your update if the next state is equal to the previous state,** as determined by an [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. This usually happens when you change an object or an array in state directly:\n\n```\nfunction reducer(state, action) {switch (action.type) {case 'incremented_age': {// üö© Wrong: mutating existing objectstate.age++;return state;}case 'changed_name': {// üö© Wrong: mutating existing objectstate.name = action.nextName;return state;}// ...}}\n```\n\nYou mutated an existing `state` object and returned it, so React ignored the update. To fix this, you need to ensure that you‚Äôre always [updating objects in state](https://react.dev/learn/updating-objects-in-state) and [updating arrays in state](https://react.dev/learn/updating-arrays-in-state) instead of mutating them:\n\n```\nfunction reducer(state, action) {switch (action.type) {case 'incremented_age': {// ‚úÖ Correct: creating a new objectreturn {...state,age: state.age + 1};}case 'changed_name': {// ‚úÖ Correct: creating a new objectreturn {...state,name: action.nextName};}// ...}}\n```\n\n* * *\n\n### A part of my reducer state becomes undefined after dispatching[](#a-part-of-my-reducer-state-becomes-undefined-after-dispatching \"Link for A part of my reducer state becomes undefined after dispatching \")\n\nMake sure that every `case` branch **copies all of the existing fields** when returning the new state:\n\n```\nfunction reducer(state, action) {switch (action.type) {case 'incremented_age': {return {...state, // Don't forget this!age: state.age + 1};}// ...\n```\n\nWithout `...state` above, the returned next state would only contain the `age` field and nothing else.\n\n* * *\n\n### My entire reducer state becomes undefined after dispatching[](#my-entire-reducer-state-becomes-undefined-after-dispatching \"Link for My entire reducer state becomes undefined after dispatching \")\n\nIf your state unexpectedly becomes `undefined`, you‚Äôre likely forgetting to `return` state in one of the cases, or your action type doesn‚Äôt match any of the `case` statements. To find why, throw an error outside the `switch`:\n\n```\nfunction reducer(state, action) {switch (action.type) {case 'incremented_age': {// ...}case 'edited_name': {// ...}}throw Error('Unknown action: ' + action.type);}\n```\n\nYou can also use a static type checker like TypeScript to catch such mistakes.\n\n* * *\n\n### I‚Äôm getting an error: ‚ÄúToo many re-renders‚Äù[](#im-getting-an-error-too-many-re-renders \"Link for I‚Äôm getting an error: ‚ÄúToo many re-renders‚Äù \")\n\nYou might get an error that says: `Too many re-renders. React limits the number of renders to prevent an infinite loop.` Typically, this means that you‚Äôre unconditionally dispatching an action _during render_, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:\n\n```\n// üö© Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ‚úÖ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ‚úÖ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>\n```\n\nIf you can‚Äôt find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific `dispatch` function call responsible for the error.\n\n* * *\n\n### My reducer or initializer function runs twice[](#my-reducer-or-initializer-function-runs-twice \"Link for My reducer or initializer function runs twice \")\n\nIn [Strict Mode](https://react.dev/reference/react/StrictMode), React will call your reducer and initializer functions twice. This shouldn‚Äôt break your code.\n\nThis **development-only** behavior helps you [keep components pure.](https://react.dev/learn/keeping-components-pure) React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldn‚Äôt affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.\n\nFor example, this impure reducer function mutates an array in state:\n\n```\nfunction reducer(state, action) {switch (action.type) {case 'added_todo': {// üö© Mistake: mutating statestate.todos.push({ id: nextId++, text: action.text });return state;}// ...}}\n```\n\nBecause React calls your reducer function twice, you‚Äôll see the todo was added twice, so you‚Äôll know that there is a mistake. In this example, you can fix the mistake by [replacing the array instead of mutating it](https://react.dev/learn/updating-arrays-in-state#adding-to-an-array):\n\n```\nfunction reducer(state, action) {switch (action.type) {case 'added_todo': {// ‚úÖ Correct: replacing with new statereturn {...state,todos: [...state.todos,{ id: nextId++, text: action.text }]};}// ...}}\n```\n\nNow that this reducer function is pure, calling it an extra time doesn‚Äôt make a difference in behavior. This is why React calling it twice helps you find mistakes. **Only component, initializer, and reducer functions need to be pure.** Event handlers don‚Äôt need to be pure, so React will never call your event handlers twice.\n\nRead [keeping components pure](https://react.dev/learn/keeping-components-pure) to learn more.",
  "title": "useReducer ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useSyncExternalStore",
  "markdown": "# useSyncExternalStore ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useSyncExternalStore` is a React Hook that lets you subscribe to an external store.\n\n```\nconst snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)\n```\n\n*   [Reference](#reference)\n    *   [`useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)`](#usesyncexternalstore)\n*   [Usage](#usage)\n    *   [Subscribing to an external store](#subscribing-to-an-external-store)\n    *   [Subscribing to a browser API](#subscribing-to-a-browser-api)\n    *   [Extracting the logic to a custom Hook](#extracting-the-logic-to-a-custom-hook)\n    *   [Adding support for server rendering](#adding-support-for-server-rendering)\n*   [Troubleshooting](#troubleshooting)\n    *   [I‚Äôm getting an error: ‚ÄúThe result of `getSnapshot` should be cached‚Äù](#im-getting-an-error-the-result-of-getsnapshot-should-be-cached)\n    *   [My `subscribe` function gets called after every re-render](#my-subscribe-function-gets-called-after-every-re-render)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)`[](#usesyncexternalstore \"Link for this heading\")\n\nCall `useSyncExternalStore` at the top level of your component to read a value from an external data store.\n\n```\nimport { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() {const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);// ...}\n```\n\nIt returns the snapshot of the data in the store. You need to pass two functions as arguments:\n\n1.  The `subscribe` function should subscribe to the store and return a function that unsubscribes.\n2.  The `getSnapshot` function should read a snapshot of the data from the store.\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `subscribe`: A function that takes a single `callback` argument and subscribes it to the store. When the store changes, it should invoke the provided `callback`. This will cause the component to re-render. The `subscribe` function should return a function that cleans up the subscription.\n    \n*   `getSnapshot`: A function that returns a snapshot of the data in the store that‚Äôs needed by the component. While the store has not changed, repeated calls to `getSnapshot` must return the same value. If the store changes and the returned value is different (as compared by [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), React re-renders the component.\n    \n*   **optional** `getServerSnapshot`: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error.\n    \n\n#### Returns[](#returns \"Link for Returns \")\n\nThe current snapshot of the store which you can use in your rendering logic.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   The store snapshot returned by `getSnapshot` must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot.\n    \n*   If a different `subscribe` function is passed during a re-render, React will re-subscribe to the store using the newly passed `subscribe` function. You can prevent this by declaring `subscribe` outside the component.\n    \n*   If the store is mutated during a [non-blocking Transition update](https://react.dev/reference/react/useTransition), React will fall back to performing that update as blocking. Specifically, for every Transition update, React will call `getSnapshot` a second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store.\n    \n*   It‚Äôs not recommended to _suspend_ a render based on a store value returned by `useSyncExternalStore`. The reason is that mutations to the external store cannot be marked as [non-blocking Transition updates](https://react.dev/reference/react/useTransition), so they will trigger the nearest [`Suspense` fallback](https://react.dev/reference/react/Suspense), replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX.\n    \n    For example, the following are discouraged:\n    \n    ```\n    const LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));function ShoppingApp() {const selectedProductId = useSyncExternalStore(...);// ‚ùå Calling `use` with a Promise dependent on `selectedProductId`const data = use(fetchItem(selectedProductId))// ‚ùå Conditionally rendering a lazy component based on `selectedProductId`return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;}\n    ```\n    \n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Subscribing to an external store[](#subscribing-to-an-external-store \"Link for Subscribing to an external store \")\n\nMost of your React components will only read data from their [props,](https://react.dev/learn/passing-props-to-a-component) [state,](https://react.dev/reference/react/useState) and [context.](https://react.dev/reference/react/useContext) However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes:\n\n*   Third-party state management libraries that hold state outside of React.\n*   Browser APIs that expose a mutable value and events to subscribe to its changes.\n\nCall `useSyncExternalStore` at the top level of your component to read a value from an external data store.\n\n```\nimport { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() {const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);// ...}\n```\n\nIt returns the snapshot of the data in the store. You need to pass two functions as arguments:\n\n1.  The `subscribe` function should subscribe to the store and return a function that unsubscribes.\n2.  The `getSnapshot` function should read a snapshot of the data from the store.\n\nReact will use these functions to keep your component subscribed to the store and re-render it on changes.\n\nFor example, in the sandbox below, `todosStore` is implemented as an external store that stores data outside of React. The `TodosApp` component connects to that external store with the `useSyncExternalStore` Hook.\n\nimport { useSyncExternalStore } from 'react';\nimport { todosStore } from './todoStore.js';\n\nexport default function TodosApp() {\n  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\n  return (\n    <\\>\n      <button onClick\\={() \\=> todosStore.addTodo()}\\>Add todo</button\\>\n      <hr />\n      <ul\\>\n        {todos.map(todo \\=> (\n          <li key\\={todo.id}\\>{todo.text}</li\\>\n        ))}\n      </ul\\>\n    </\\>\n  );\n}\n\n### Note\n\nWhen possible, we recommend using built-in React state with [`useState`](https://react.dev/reference/react/useState) and [`useReducer`](https://react.dev/reference/react/useReducer) instead. The `useSyncExternalStore` API is mostly useful if you need to integrate with existing non-React code.\n\n* * *\n\n### Subscribing to a browser API[](#subscribing-to-a-browser-api \"Link for Subscribing to a browser API \")\n\nAnother reason to add `useSyncExternalStore` is when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property called [`navigator.onLine`.](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/onLine)\n\nThis value can change without React‚Äôs knowledge, so you should read it with `useSyncExternalStore`.\n\n```\nimport { useSyncExternalStore } from 'react';function ChatIndicator() {const isOnline = useSyncExternalStore(subscribe, getSnapshot);// ...}\n```\n\nTo implement the `getSnapshot` function, read the current value from the browser API:\n\n```\nfunction getSnapshot() {return navigator.onLine;}\n```\n\nNext, you need to implement the `subscribe` function. For example, when `navigator.onLine` changes, the browser fires the [`online`](https://developer.mozilla.org/en-US/docs/Web/API/Window/online_event) and [`offline`](https://developer.mozilla.org/en-US/docs/Web/API/Window/offline_event) events on the `window` object. You need to subscribe the `callback` argument to the corresponding events, and then return a function that cleans up the subscriptions:\n\n```\nfunction subscribe(callback) {window.addEventListener('online', callback);window.addEventListener('offline', callback);return () => {window.removeEventListener('online', callback);window.removeEventListener('offline', callback);};}\n```\n\nNow React knows how to read the value from the external `navigator.onLine` API and how to subscribe to its changes. Disconnect your device from the network and notice that the component re-renders in response:\n\nimport { useSyncExternalStore } from 'react';\n\nexport default function ChatIndicator() {\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\n  return <h1\\>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1\\>;\n}\n\nfunction getSnapshot() {\n  return navigator.onLine;\n}\n\nfunction subscribe(callback) {\n  window.addEventListener('online', callback);\n  window.addEventListener('offline', callback);\n  return () \\=> {\n    window.removeEventListener('online', callback);\n    window.removeEventListener('offline', callback);\n  };\n}\n\n* * *\n\nUsually you won‚Äôt write `useSyncExternalStore` directly in your components. Instead, you‚Äôll typically call it from your own custom Hook. This lets you use the same external store from different components.\n\nFor example, this custom `useOnlineStatus` Hook tracks whether the network is online:\n\n```\nimport { useSyncExternalStore } from 'react';export function useOnlineStatus() {const isOnline = useSyncExternalStore(subscribe, getSnapshot);return isOnline;}function getSnapshot() {// ...}function subscribe(callback) {// ...}\n```\n\nNow different components can call `useOnlineStatus` without repeating the underlying implementation:\n\nimport { useOnlineStatus } from './useOnlineStatus.js';\n\nfunction StatusBar() {\n  const isOnline = useOnlineStatus();\n  return <h1\\>{isOnline ? '‚úÖ Online' : '‚ùå Disconnected'}</h1\\>;\n}\n\nfunction SaveButton() {\n  const isOnline = useOnlineStatus();\n\n  function handleSaveClick() {\n    console.log('‚úÖ Progress saved');\n  }\n\n  return (\n    <button disabled\\={!isOnline} onClick\\={handleSaveClick}\\>\n      {isOnline ? 'Save progress' : 'Reconnecting...'}\n    </button\\>\n  );\n}\n\nexport default function App() {\n  return (\n    <\\>\n      <SaveButton />\n      <StatusBar />\n    </\\>\n  );\n}\n\n* * *\n\n### Adding support for server rendering[](#adding-support-for-server-rendering \"Link for Adding support for server rendering \")\n\nIf your React app uses [server rendering,](https://react.dev/reference/react-dom/server) your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store:\n\n*   If you‚Äôre connecting to a browser-only API, it won‚Äôt work because it does not exist on the server.\n*   If you‚Äôre connecting to a third-party data store, you‚Äôll need its data to match between the server and client.\n\nTo solve these issues, pass a `getServerSnapshot` function as the third argument to `useSyncExternalStore`:\n\n```\nimport { useSyncExternalStore } from 'react';export function useOnlineStatus() {const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);return isOnline;}function getSnapshot() {return navigator.onLine;}function getServerSnapshot() {return true; // Always show \"Online\" for server-generated HTML}function subscribe(callback) {// ...}\n```\n\nThe `getServerSnapshot` function is similar to `getSnapshot`, but it runs only in two situations:\n\n*   It runs on the server when generating the HTML.\n*   It runs on the client during [hydration](https://react.dev/reference/react-dom/client/hydrateRoot), i.e. when React takes the server HTML and makes it interactive.\n\nThis lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument to [force rendering on the client.](https://react.dev/reference/react/Suspense#providing-a-fallback-for-server-errors-and-client-only-content)\n\n### Note\n\nMake sure that `getServerSnapshot` returns the same exact data on the initial client render as it returned on the server. For example, if `getServerSnapshot` returned some prepopulated store content on the server, you need to transfer this content to the client. One way to do this is to emit a `<script>` tag during server rendering that sets a global like `window.MY_STORE_DATA`, and read from that global on the client in `getServerSnapshot`. Your external store should provide instructions on how to do that.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### I‚Äôm getting an error: ‚ÄúThe result of `getSnapshot` should be cached‚Äù[](#im-getting-an-error-the-result-of-getsnapshot-should-be-cached \"Link for this heading\")\n\nThis error means your `getSnapshot` function returns a new object every time it‚Äôs called, for example:\n\n```\nfunction getSnapshot() {// üî¥ Do not return always different objects from getSnapshotreturn {todos: myStore.todos};}\n```\n\nReact will re-render the component if `getSnapshot` return value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error.\n\nYour `getSnapshot` object should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly:\n\n```\nfunction getSnapshot() {// ‚úÖ You can return immutable datareturn myStore.todos;}\n```\n\nIf your store data is mutable, your `getSnapshot` function should return an immutable snapshot of it. This means it _does_ need to create new objects, but it shouldn‚Äôt do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store.\n\n* * *\n\n### My `subscribe` function gets called after every re-render[](#my-subscribe-function-gets-called-after-every-re-render \"Link for this heading\")\n\nThis `subscribe` function is defined _inside_ a component so it is different on every re-render:\n\n```\nfunction ChatIndicator() {const isOnline = useSyncExternalStore(subscribe, getSnapshot);// üö© Always a different function, so React will resubscribe on every re-renderfunction subscribe() {// ...}// ...}\n```\n\nReact will resubscribe to your store if you pass a different `subscribe` function between re-renders. If this causes performance issues and you‚Äôd like to avoid resubscribing, move the `subscribe` function outside:\n\n```\nfunction ChatIndicator() {const isOnline = useSyncExternalStore(subscribe, getSnapshot);// ...}// ‚úÖ Always the same function, so React won't need to resubscribefunction subscribe() {// ...}\n```\n\nAlternatively, wrap `subscribe` into [`useCallback`](https://react.dev/reference/react/useCallback) to only resubscribe when some argument changes:\n\n```\nfunction ChatIndicator({ userId }) {const isOnline = useSyncExternalStore(subscribe, getSnapshot);// ‚úÖ Same function as long as userId doesn't changeconst subscribe = useCallback(() => {// ...}, [userId]);// ...}\n```",
  "title": "useSyncExternalStore ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useTransition",
  "markdown": "# useTransition ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useTransition` is a React Hook that lets you update the state without blocking the UI.\n\n```\nconst [isPending, startTransition] = useTransition()\n```\n\n*   [Reference](#reference)\n    *   [`useTransition()`](#usetransition)\n    *   [`startTransition` function](#starttransition)\n*   [Usage](#usage)\n    *   [Marking a state update as a non-blocking Transition](#marking-a-state-update-as-a-non-blocking-transition)\n    *   [Updating the parent component in a Transition](#updating-the-parent-component-in-a-transition)\n    *   [Displaying a pending visual state during the Transition](#displaying-a-pending-visual-state-during-the-transition)\n    *   [Preventing unwanted loading indicators](#preventing-unwanted-loading-indicators)\n    *   [Building a Suspense-enabled router](#building-a-suspense-enabled-router)\n    *   [Displaying an error to users with an error boundary](#displaying-an-error-to-users-with-error-boundary)\n*   [Troubleshooting](#troubleshooting)\n    *   [Updating an input in a Transition doesn‚Äôt work](#updating-an-input-in-a-transition-doesnt-work)\n    *   [React doesn‚Äôt treat my state update as a Transition](#react-doesnt-treat-my-state-update-as-a-transition)\n    *   [I want to call `useTransition` from outside a component](#i-want-to-call-usetransition-from-outside-a-component)\n    *   [The function I pass to `startTransition` executes immediately](#the-function-i-pass-to-starttransition-executes-immediately)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useTransition()`[](#usetransition \"Link for this heading\")\n\nCall `useTransition` at the top level of your component to mark some state updates as Transitions.\n\n```\nimport { useTransition } from 'react';function TabContainer() {const [isPending, startTransition] = useTransition();// ...}\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n`useTransition` does not take any parameters.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`useTransition` returns an array with exactly two items:\n\n1.  The `isPending` flag that tells you whether there is a pending Transition.\n2.  The [`startTransition` function](#starttransition) that lets you mark a state update as a Transition.\n\n* * *\n\n### `startTransition` function[](#starttransition \"Link for this heading\")\n\nThe `startTransition` function returned by `useTransition` lets you mark a state update as a Transition.\n\n```\nfunction TabContainer() {const [isPending, startTransition] = useTransition();const [tab, setTab] = useState('about');function selectTab(nextTab) {startTransition(() => {setTab(nextTab);});}// ...}\n```\n\n#### Parameters[](#starttransition-parameters \"Link for Parameters \")\n\n*   `scope`: A function that updates some state by calling one or more [`set` functions.](https://react.dev/reference/react/useState#setstate) React immediately calls `scope` with no parameters and marks all state updates scheduled synchronously during the `scope` function call as Transitions. They will be [non-blocking](#marking-a-state-update-as-a-non-blocking-transition) and [will not display unwanted loading indicators.](#preventing-unwanted-loading-indicators)\n\n#### Returns[](#starttransition-returns \"Link for Returns \")\n\n`startTransition` does not return anything.\n\n#### Caveats[](#starttransition-caveats \"Link for Caveats \")\n\n*   `useTransition` is a Hook, so it can only be called inside components or custom Hooks. If you need to start a Transition somewhere else (for example, from a data library), call the standalone [`startTransition`](https://react.dev/reference/react/startTransition) instead.\n    \n*   You can wrap an update into a Transition only if you have access to the `set` function of that state. If you want to start a Transition in response to some prop or a custom Hook value, try [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue) instead.\n    \n*   The function you pass to `startTransition` must be synchronous. React immediately executes this function, marking all state updates that happen while it executes as Transitions. If you try to perform more state updates later (for example, in a timeout), they won‚Äôt be marked as Transitions.\n    \n*   A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input update.\n    \n*   Transition updates can‚Äôt be used to control text inputs.\n    \n*   If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that will likely be removed in a future release.\n    \n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Marking a state update as a non-blocking Transition[](#marking-a-state-update-as-a-non-blocking-transition \"Link for Marking a state update as a non-blocking Transition \")\n\nCall `useTransition` at the top level of your component to mark state updates as non-blocking _Transitions_.\n\n```\nimport { useState, useTransition } from 'react';function TabContainer() {const [isPending, startTransition] = useTransition();// ...}\n```\n\n`useTransition` returns an array with exactly two items:\n\n1.  The `isPending` flag that tells you whether there is a pending Transition.\n2.  The `startTransition` function that lets you mark a state update as a Transition.\n\nYou can then mark a state update as a Transition like this:\n\n```\nfunction TabContainer() {const [isPending, startTransition] = useTransition();const [tab, setTab] = useState('about');function selectTab(nextTab) {startTransition(() => {setTab(nextTab);});}// ...}\n```\n\nTransitions let you keep the user interface updates responsive even on slow devices.\n\nWith a Transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish.\n\n#### The difference between useTransition and regular state updates[](#examples \"Link for The difference between useTransition and regular state updates\")\n\n#### Updating the current tab in a Transition[](#updating-the-current-tab-in-a-transition \"Link for this heading\")\n\nIn this example, the ‚ÄúPosts‚Äù tab is **artificially slowed down** so that it takes at least a second to render.\n\nClick ‚ÄúPosts‚Äù and then immediately click ‚ÄúContact‚Äù. Notice that this interrupts the slow render of ‚ÄúPosts‚Äù. The ‚ÄúContact‚Äù tab shows immediately. Because this state update is marked as a Transition, a slow re-render did not freeze the user interface.\n\nimport { useState, useTransition } from 'react';\nimport TabButton from './TabButton.js';\nimport AboutTab from './AboutTab.js';\nimport PostsTab from './PostsTab.js';\nimport ContactTab from './ContactTab.js';\n\nexport default function TabContainer() {\n  const \\[isPending, startTransition\\] = useTransition();\n  const \\[tab, setTab\\] = useState('about');\n\n  function selectTab(nextTab) {\n    startTransition(() \\=> {\n      setTab(nextTab);\n    });\n  }\n\n  return (\n    <\\>\n      <TabButton\n        isActive\\={tab === 'about'}\n        onClick\\={() \\=> selectTab('about')}\n      \\>\n        About\n      </TabButton\\>\n      <TabButton\n        isActive\\={tab === 'posts'}\n        onClick\\={() \\=> selectTab('posts')}\n      \\>\n        Posts (slow)\n      </TabButton\\>\n      <TabButton\n        isActive\\={tab === 'contact'}\n        onClick\\={() \\=> selectTab('contact')}\n      \\>\n        Contact\n      </TabButton\\>\n      <hr />\n      {tab === 'about' && <AboutTab />}\n      {tab === 'posts' && <PostsTab />}\n      {tab === 'contact' && <ContactTab />}\n    </\\>\n  );\n}\n\n* * *\n\n### Updating the parent component in a Transition[](#updating-the-parent-component-in-a-transition \"Link for Updating the parent component in a Transition \")\n\nYou can update a parent component‚Äôs state from the `useTransition` call, too. For example, this `TabButton` component wraps its `onClick` logic in a Transition:\n\n```\nexport default function TabButton({ children, isActive, onClick }) {const [isPending, startTransition] = useTransition();if (isActive) {return <b>{children}</b>}return (<button onClick={() => {startTransition(() => {onClick();});}}>{children}</button>);}\n```\n\nBecause the parent component updates its state inside the `onClick` event handler, that state update gets marked as a Transition. This is why, like in the earlier example, you can click on ‚ÄúPosts‚Äù and then immediately click ‚ÄúContact‚Äù. Updating the selected tab is marked as a Transition, so it does not block user interactions.\n\nimport { useTransition } from 'react';\n\nexport default function TabButton({ children, isActive, onClick }) {\n  const \\[isPending, startTransition\\] = useTransition();\n  if (isActive) {\n    return <b\\>{children}</b\\>\n  }\n  return (\n    <button onClick\\={() \\=> {\n      startTransition(() \\=> {\n        onClick();\n      });\n    }}\\>\n      {children}\n    </button\\>\n  );\n}\n\n* * *\n\n### Displaying a pending visual state during the Transition[](#displaying-a-pending-visual-state-during-the-transition \"Link for Displaying a pending visual state during the Transition \")\n\nYou can use the `isPending` boolean value returned by `useTransition` to indicate to the user that a Transition is in progress. For example, the tab button can have a special ‚Äúpending‚Äù visual state:\n\n```\nfunction TabButton({ children, isActive, onClick }) {const [isPending, startTransition] = useTransition();// ...if (isPending) {return <b className=\"pending\">{children}</b>;}// ...\n```\n\nNotice how clicking ‚ÄúPosts‚Äù now feels more responsive because the tab button itself updates right away:\n\nimport { useTransition } from 'react';\n\nexport default function TabButton({ children, isActive, onClick }) {\n  const \\[isPending, startTransition\\] = useTransition();\n  if (isActive) {\n    return <b\\>{children}</b\\>\n  }\n  if (isPending) {\n    return <b className\\=\"pending\"\\>{children}</b\\>;\n  }\n  return (\n    <button onClick\\={() \\=> {\n      startTransition(() \\=> {\n        onClick();\n      });\n    }}\\>\n      {children}\n    </button\\>\n  );\n}\n\n* * *\n\n### Preventing unwanted loading indicators[](#preventing-unwanted-loading-indicators \"Link for Preventing unwanted loading indicators \")\n\nIn this example, the `PostsTab` component fetches some data using a [Suspense-enabled](https://react.dev/reference/react/Suspense) data source. When you click the ‚ÄúPosts‚Äù tab, the `PostsTab` component _suspends_, causing the closest loading fallback to appear:\n\nimport { Suspense, useState } from 'react';\nimport TabButton from './TabButton.js';\nimport AboutTab from './AboutTab.js';\nimport PostsTab from './PostsTab.js';\nimport ContactTab from './ContactTab.js';\n\nexport default function TabContainer() {\n  const \\[tab, setTab\\] = useState('about');\n  return (\n    <Suspense fallback\\={<h1\\>üåÄ Loading...</h1\\>}\\>\n      <TabButton\n        isActive\\={tab === 'about'}\n        onClick\\={() \\=> setTab('about')}\n      \\>\n        About\n      </TabButton\\>\n      <TabButton\n        isActive\\={tab === 'posts'}\n        onClick\\={() \\=> setTab('posts')}\n      \\>\n        Posts\n      </TabButton\\>\n      <TabButton\n        isActive\\={tab === 'contact'}\n        onClick\\={() \\=> setTab('contact')}\n      \\>\n        Contact\n      </TabButton\\>\n      <hr />\n      {tab === 'about' && <AboutTab />}\n      {tab === 'posts' && <PostsTab />}\n      {tab === 'contact' && <ContactTab />}\n    </Suspense\\>\n  );\n}\n\nHiding the entire tab container to show a loading indicator leads to a jarring user experience. If you add `useTransition` to `TabButton`, you can instead indicate display the pending state in the tab button instead.\n\nNotice that clicking ‚ÄúPosts‚Äù no longer replaces the entire tab container with a spinner:\n\nimport { useTransition } from 'react';\n\nexport default function TabButton({ children, isActive, onClick }) {\n  const \\[isPending, startTransition\\] = useTransition();\n  if (isActive) {\n    return <b\\>{children}</b\\>\n  }\n  if (isPending) {\n    return <b className\\=\"pending\"\\>{children}</b\\>;\n  }\n  return (\n    <button onClick\\={() \\=> {\n      startTransition(() \\=> {\n        onClick();\n      });\n    }}\\>\n      {children}\n    </button\\>\n  );\n}\n\n[Read more about using Transitions with Suspense.](https://react.dev/reference/react/Suspense#preventing-already-revealed-content-from-hiding)\n\n### Note\n\nTransitions will only ‚Äúwait‚Äù long enough to avoid hiding _already revealed_ content (like the tab container). If the Posts tab had a [nested `<Suspense>` boundary,](https://react.dev/reference/react/Suspense#revealing-nested-content-as-it-loads) the Transition would not ‚Äúwait‚Äù for it.\n\n* * *\n\n### Building a Suspense-enabled router[](#building-a-suspense-enabled-router \"Link for Building a Suspense-enabled router \")\n\nIf you‚Äôre building a React framework or a router, we recommend marking page navigations as Transitions.\n\n```\nfunction Router() {const [page, setPage] = useState('/');const [isPending, startTransition] = useTransition();function navigate(url) {startTransition(() => {setPage(url);});}// ...\n```\n\nThis is recommended for two reasons:\n\n*   [Transitions are interruptible,](#marking-a-state-update-as-a-non-blocking-transition) which lets the user click away without waiting for the re-render to complete.\n*   [Transitions prevent unwanted loading indicators,](#preventing-unwanted-loading-indicators) which lets the user avoid jarring jumps on navigation.\n\nHere is a tiny simplified router example using Transitions for navigations.\n\nimport { Suspense, useState, useTransition } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback\\={<BigSpinner />}\\>\n      <Router />\n    </Suspense\\>\n  );\n}\n\nfunction Router() {\n  const \\[page, setPage\\] = useState('/');\n  const \\[isPending, startTransition\\] = useTransition();\n\n  function navigate(url) {\n    startTransition(() \\=> {\n      setPage(url);\n    });\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate\\={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist\\={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout isPending\\={isPending}\\>\n      {content}\n    </Layout\\>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2\\>üåÄ Loading...</h2\\>;\n}\n\n### Note\n\n[Suspense-enabled](https://react.dev/reference/react/Suspense) routers are expected to wrap the navigation updates into Transitions by default.\n\n* * *\n\n### Displaying an error to users with an error boundary[](#displaying-an-error-to-users-with-error-boundary \"Link for Displaying an error to users with an error boundary \")\n\n### Canary\n\nError Boundary for useTransition is currently only available in React‚Äôs canary and experimental channels. Learn more about [React‚Äôs release channels here](https://react.dev/community/versioning-policy#all-release-channels).\n\nIf a function passed to `startTransition` throws an error, you can display an error to your user with an [error boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary). To use an error boundary, wrap the component where you are calling the `useTransition` in an error boundary. Once the function passed to `startTransition` errors, the fallback for the error boundary will be displayed.\n\nimport { useTransition } from \"react\";\nimport { ErrorBoundary } from \"react-error-boundary\";\n\nexport function AddCommentContainer() {\n  return (\n    <ErrorBoundary fallback\\={<p\\>‚ö†Ô∏èSomething went wrong</p\\>}\\>\n      <AddCommentButton />\n    </ErrorBoundary\\>\n  );\n}\n\nfunction addComment(comment) {\n  \n  if (comment == null) {\n    throw new Error(\"Example Error: An error thrown to trigger error boundary\");\n  }\n}\n\nfunction AddCommentButton() {\n  const \\[pending, startTransition\\] = useTransition();\n\n  return (\n    <button\n      disabled\\={pending}\n      onClick\\={() \\=> {\n        startTransition(() \\=> {\n          \n          \n          addComment();\n        });\n      }}\n    \\>\n      Add comment\n    </button\\>\n  );\n}\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### Updating an input in a Transition doesn‚Äôt work[](#updating-an-input-in-a-transition-doesnt-work \"Link for Updating an input in a Transition doesn‚Äôt work \")\n\nYou can‚Äôt use a Transition for a state variable that controls an input:\n\n```\nconst [text, setText] = useState('');// ...function handleChange(e) {// ‚ùå Can't use Transitions for controlled input statestartTransition(() => {setText(e.target.value);});}// ...return <input value={text} onChange={handleChange} />;\n```\n\nThis is because Transitions are non-blocking, but updating an input in response to the change event should happen synchronously. If you want to run a Transition in response to typing, you have two options:\n\n1.  You can declare two separate state variables: one for the input state (which always updates synchronously), and one that you will update in a Transition. This lets you control the input using the synchronous state, and pass the Transition state variable (which will ‚Äúlag behind‚Äù the input) to the rest of your rendering logic.\n2.  Alternatively, you can have one state variable, and add [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue) which will ‚Äúlag behind‚Äù the real value. It will trigger non-blocking re-renders to ‚Äúcatch up‚Äù with the new value automatically.\n\n* * *\n\n### React doesn‚Äôt treat my state update as a Transition[](#react-doesnt-treat-my-state-update-as-a-transition \"Link for React doesn‚Äôt treat my state update as a Transition \")\n\nWhen you wrap a state update in a Transition, make sure that it happens _during_ the `startTransition` call:\n\n```\nstartTransition(() => {// ‚úÖ Setting state *during* startTransition callsetPage('/about');});\n```\n\nThe function you pass to `startTransition` must be synchronous.\n\nYou can‚Äôt mark an update as a Transition like this:\n\n```\nstartTransition(() => {// ‚ùå Setting state *after* startTransition callsetTimeout(() => {setPage('/about');}, 1000);});\n```\n\nInstead, you could do this:\n\n```\nsetTimeout(() => {startTransition(() => {// ‚úÖ Setting state *during* startTransition callsetPage('/about');});}, 1000);\n```\n\nSimilarly, you can‚Äôt mark an update as a Transition like this:\n\n```\nstartTransition(async () => {await someAsyncFunction();// ‚ùå Setting state *after* startTransition callsetPage('/about');});\n```\n\nHowever, this works instead:\n\n```\nawait someAsyncFunction();startTransition(() => {// ‚úÖ Setting state *during* startTransition callsetPage('/about');});\n```\n\n* * *\n\n### I want to call `useTransition` from outside a component[](#i-want-to-call-usetransition-from-outside-a-component \"Link for this heading\")\n\nYou can‚Äôt call `useTransition` outside a component because it‚Äôs a Hook. In this case, use the standalone [`startTransition`](https://react.dev/reference/react/startTransition) method instead. It works the same way, but it doesn‚Äôt provide the `isPending` indicator.\n\n* * *\n\n### The function I pass to `startTransition` executes immediately[](#the-function-i-pass-to-starttransition-executes-immediately \"Link for this heading\")\n\nIf you run this code, it will print 1, 2, 3:\n\n```\nconsole.log(1);startTransition(() => {console.log(2);setPage('/about');});console.log(3);\n```\n\n**It is expected to print 1, 2, 3.** The function you pass to `startTransition` does not get delayed. Unlike with the browser `setTimeout`, it does not run the callback later. React executes your function immediately, but any state updates scheduled _while it is running_ are marked as Transitions. You can imagine that it works like this:\n\n```\n// A simplified version of how React workslet isInsideTransition = false;function startTransition(scope) {isInsideTransition = true;scope();isInsideTransition = false;}function setState() {if (isInsideTransition) {// ... schedule a Transition state update ...} else {// ... schedule an urgent state update ...}}\n```",
  "title": "useTransition ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useState",
  "markdown": "# useState ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useState` is a React Hook that lets you add a [state variable](https://react.dev/learn/state-a-components-memory) to your component.\n\n```\nconst [state, setState] = useState(initialState)\n```\n\n*   [Reference](#reference)\n    *   [`useState(initialState)`](#usestate)\n    *   [`set` functions, like `setSomething(nextState)`](#setstate)\n*   [Usage](#usage)\n    *   [Adding state to a component](#adding-state-to-a-component)\n    *   [Updating state based on the previous state](#updating-state-based-on-the-previous-state)\n    *   [Updating objects and arrays in state](#updating-objects-and-arrays-in-state)\n    *   [Avoiding recreating the initial state](#avoiding-recreating-the-initial-state)\n    *   [Resetting state with a key](#resetting-state-with-a-key)\n    *   [Storing information from previous renders](#storing-information-from-previous-renders)\n*   [Troubleshooting](#troubleshooting)\n    *   [I‚Äôve updated the state, but logging gives me the old value](#ive-updated-the-state-but-logging-gives-me-the-old-value)\n    *   [I‚Äôve updated the state, but the screen doesn‚Äôt update](#ive-updated-the-state-but-the-screen-doesnt-update)\n    *   [I‚Äôm getting an error: ‚ÄúToo many re-renders‚Äù](#im-getting-an-error-too-many-re-renders)\n    *   [My initializer or updater function runs twice](#my-initializer-or-updater-function-runs-twice)\n    *   [I‚Äôm trying to set state to a function, but it gets called instead](#im-trying-to-set-state-to-a-function-but-it-gets-called-instead)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useState(initialState)`[](#usestate \"Link for this heading\")\n\nCall `useState` at the top level of your component to declare a [state variable.](https://react.dev/learn/state-a-components-memory)\n\n```\nimport { useState } from 'react';function MyComponent() {const [age, setAge] = useState(28);const [name, setName] = useState('Taylor');const [todos, setTodos] = useState(() => createTodos());// ...\n```\n\nThe convention is to name state variables like `[something, setSomething]` using [array destructuring.](https://javascript.info/destructuring-assignment)\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `initialState`: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render.\n    *   If you pass a function as `initialState`, it will be treated as an _initializer function_. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state. [See an example below.](#avoiding-recreating-the-initial-state)\n\n#### Returns[](#returns \"Link for Returns \")\n\n`useState` returns an array with exactly two values:\n\n1.  The current state. During the first render, it will match the `initialState` you have passed.\n2.  The [`set` function](#setstate) that lets you update the state to a different value and trigger a re-render.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   `useState` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.\n*   In Strict Mode, React will **call your initializer function twice** in order to [help you find accidental impurities.](#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.\n\n* * *\n\n### `set` functions, like `setSomething(nextState)`[](#setstate \"Link for this heading\")\n\nThe `set` function returned by `useState` lets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:\n\n```\nconst [name, setName] = useState('Edward');function handleClick() {setName('Taylor');setAge(a => a + 1);// ...\n```\n\n#### Parameters[](#setstate-parameters \"Link for Parameters \")\n\n*   `nextState`: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions.\n    *   If you pass a function as `nextState`, it will be treated as an _updater function_. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state. [See an example below.](#updating-state-based-on-the-previous-state)\n\n#### Returns[](#setstate-returns \"Link for Returns \")\n\n`set` functions do not have a return value.\n\n#### Caveats[](#setstate-caveats \"Link for Caveats \")\n\n*   The `set` function **only updates the state variable for the _next_ render**. If you read the state variable after calling the `set` function, [you will still get the old value](#ive-updated-the-state-but-logging-gives-me-the-old-value) that was on the screen before your call.\n    \n*   If the new value you provide is identical to the current `state`, as determined by an [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison, React will **skip re-rendering the component and its children.** This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn‚Äôt affect your code.\n    \n*   React [batches state updates.](https://react.dev/learn/queueing-a-series-of-state-updates) It updates the screen **after all the event handlers have run** and have called their `set` functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use [`flushSync`.](https://react.dev/reference/react-dom/flushSync)\n    \n*   Calling the `set` function _during rendering_ is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to **store information from the previous renders**. [See an example below.](#storing-information-from-previous-renders)\n    \n*   In Strict Mode, React will **call your updater function twice** in order to [help you find accidental impurities.](#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.\n    \n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Adding state to a component[](#adding-state-to-a-component \"Link for Adding state to a component \")\n\nCall `useState` at the top level of your component to declare one or more [state variables.](https://react.dev/learn/state-a-components-memory)\n\n```\nimport { useState } from 'react';function MyComponent() {const [age, setAge] = useState(42);const [name, setName] = useState('Taylor');// ...\n```\n\nThe convention is to name state variables like `[something, setSomething]` using [array destructuring.](https://javascript.info/destructuring-assignment)\n\n`useState` returns an array with exactly two items:\n\n1.  The current state of this state variable, initially set to the initial state you provided.\n2.  The `set` function that lets you change it to any other value in response to interaction.\n\nTo update what‚Äôs on the screen, call the `set` function with some next state:\n\n```\nfunction handleClick() {setName('Robin');}\n```\n\nReact will store the next state, render your component again with the new values, and update the UI.\n\n### Pitfall\n\nCalling the `set` function [**does not** change the current state in the already executing code](#ive-updated-the-state-but-logging-gives-me-the-old-value):\n\n```\nfunction handleClick() {setName('Robin');console.log(name); // Still \"Taylor\"!}\n```\n\nIt only affects what `useState` will return starting from the _next_ render.\n\n#### Basic useState examples[](#examples-basic \"Link for Basic useState examples\")\n\n#### Counter (number)[](#counter-number \"Link for this heading\")\n\nIn this example, the `count` state variable holds a number. Clicking the button increments it.\n\n* * *\n\n### Updating state based on the previous state[](#updating-state-based-on-the-previous-state \"Link for Updating state based on the previous state \")\n\nSuppose the `age` is `42`. This handler calls `setAge(age + 1)` three times:\n\n```\nfunction handleClick() {setAge(age + 1); // setAge(42 + 1)setAge(age + 1); // setAge(42 + 1)setAge(age + 1); // setAge(42 + 1)}\n```\n\nHowever, after one click, `age` will only be `43` rather than `45`! This is because calling the `set` function [does not update](https://react.dev/learn/state-as-a-snapshot) the `age` state variable in the already running code. So each `setAge(age + 1)` call becomes `setAge(43)`.\n\nTo solve this problem, **you may pass an _updater function_** to `setAge` instead of the next state:\n\n```\nfunction handleClick() {setAge(a => a + 1); // setAge(42 => 43)setAge(a => a + 1); // setAge(43 => 44)setAge(a => a + 1); // setAge(44 => 45)}\n```\n\nHere, `a => a + 1` is your updater function. It takes the pending state and calculates the next state from it.\n\nReact puts your updater functions in a [queue.](https://react.dev/learn/queueing-a-series-of-state-updates) Then, during the next render, it will call them in the same order:\n\n1.  `a => a + 1` will receive `42` as the pending state and return `43` as the next state.\n2.  `a => a + 1` will receive `43` as the pending state and return `44` as the next state.\n3.  `a => a + 1` will receive `44` as the pending state and return `45` as the next state.\n\nThere are no other queued updates, so React will store `45` as the current state in the end.\n\nBy convention, it‚Äôs common to name the pending state argument for the first letter of the state variable name, like `a` for `age`. However, you may also call it like `prevAge` or something else that you find clearer.\n\nReact may [call your updaters twice](#my-initializer-or-updater-function-runs-twice) in development to verify that they are [pure.](https://react.dev/learn/keeping-components-pure)\n\n##### Deep Dive\n\n#### Is using an updater always preferred?[](#is-using-an-updater-always-preferred \"Link for Is using an updater always preferred? \")\n\nYou might hear a recommendation to always write code like `setAge(a => a + 1)` if the state you‚Äôre setting is calculated from the previous state. There is no harm in it, but it is also not always necessary.\n\nIn most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the `age` state variable would be updated before the next click. This means there is no risk of a click handler seeing a ‚Äústale‚Äù `age` at the beginning of the event handler.\n\nHowever, if you do multiple updates within the same event, updaters can be helpful. They‚Äôre also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders).\n\nIf you prefer consistency over slightly more verbose syntax, it‚Äôs reasonable to always write an updater if the state you‚Äôre setting is calculated from the previous state. If it‚Äôs calculated from the previous state of some _other_ state variable, you might want to combine them into one object and [use a reducer.](https://react.dev/learn/extracting-state-logic-into-a-reducer)\n\n#### The difference between passing an updater and passing the next state directly[](#examples-updater \"Link for The difference between passing an updater and passing the next state directly\")\n\n#### Passing the updater function[](#passing-the-updater-function \"Link for this heading\")\n\nThis example passes the updater function, so the ‚Äú+3‚Äù button works.\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const \\[age, setAge\\] = useState(42);\n\n  function increment() {\n    setAge(a \\=> a + 1);\n  }\n\n  return (\n    <\\>\n      <h1\\>Your age: {age}</h1\\>\n      <button onClick\\={() \\=> {\n        increment();\n        increment();\n        increment();\n      }}\\>+3</button\\>\n      <button onClick\\={() \\=> {\n        increment();\n      }}\\>+1</button\\>\n    </\\>\n  );\n}\n\n* * *\n\n### Updating objects and arrays in state[](#updating-objects-and-arrays-in-state \"Link for Updating objects and arrays in state \")\n\nYou can put objects and arrays into state. In React, state is considered read-only, so **you should _replace_ it rather than _mutate_ your existing objects**. For example, if you have a `form` object in state, don‚Äôt mutate it:\n\n```\n// üö© Don't mutate an object in state like this:form.firstName = 'Taylor';\n```\n\nInstead, replace the whole object by creating a new one:\n\n```\n// ‚úÖ Replace state with a new objectsetForm({...form,firstName: 'Taylor'});\n```\n\nRead [updating objects in state](https://react.dev/learn/updating-objects-in-state) and [updating arrays in state](https://react.dev/learn/updating-arrays-in-state) to learn more.\n\n#### Examples of objects and arrays in state[](#examples-objects \"Link for Examples of objects and arrays in state\")\n\n#### Form (object)[](#form-object \"Link for this heading\")\n\nIn this example, the `form` state variable holds an object. Each input has a change handler that calls `setForm` with the next state of the entire form. The `{ ...form }` spread syntax ensures that the state object is replaced rather than mutated.\n\nimport { useState } from 'react';\n\nexport default function Form() {\n  const \\[form, setForm\\] = useState({\n    firstName: 'Barbara',\n    lastName: 'Hepworth',\n    email: 'bhepworth@sculpture.com',\n  });\n\n  return (\n    <\\>\n      <label\\>\n        First name:\n        <input\n          value\\={form.firstName}\n          onChange\\={e \\=> {\n            setForm({\n              ...form,\n              firstName: e.target.value\n            });\n          }}\n        />\n      </label\\>\n      <label\\>\n        Last name:\n        <input\n          value\\={form.lastName}\n          onChange\\={e \\=> {\n            setForm({\n              ...form,\n              lastName: e.target.value\n            });\n          }}\n        />\n      </label\\>\n      <label\\>\n        Email:\n        <input\n          value\\={form.email}\n          onChange\\={e \\=> {\n            setForm({\n              ...form,\n              email: e.target.value\n            });\n          }}\n        />\n      </label\\>\n      <p\\>\n        {form.firstName}{' '}\n        {form.lastName}{' '}\n        ({form.email})\n      </p\\>\n    </\\>\n  );\n}\n\n* * *\n\n### Avoiding recreating the initial state[](#avoiding-recreating-the-initial-state \"Link for Avoiding recreating the initial state \")\n\nReact saves the initial state once and ignores it on the next renders.\n\n```\nfunction TodoList() {const [todos, setTodos] = useState(createInitialTodos());// ...\n```\n\nAlthough the result of `createInitialTodos()` is only used for the initial render, you‚Äôre still calling this function on every render. This can be wasteful if it‚Äôs creating large arrays or performing expensive calculations.\n\nTo solve this, you may **pass it as an _initializer_ function** to `useState` instead:\n\n```\nfunction TodoList() {const [todos, setTodos] = useState(createInitialTodos);// ...\n```\n\nNotice that you‚Äôre passing `createInitialTodos`, which is the _function itself_, and not `createInitialTodos()`, which is the result of calling it. If you pass a function to `useState`, React will only call it during initialization.\n\nReact may [call your initializers twice](#my-initializer-or-updater-function-runs-twice) in development to verify that they are [pure.](https://react.dev/learn/keeping-components-pure)\n\n#### The difference between passing an initializer and passing the initial state directly[](#examples-initializer \"Link for The difference between passing an initializer and passing the initial state directly\")\n\n#### Passing the initializer function[](#passing-the-initializer-function \"Link for this heading\")\n\nThis example passes the initializer function, so the `createInitialTodos` function only runs during initialization. It does not run when component re-renders, such as when you type into the input.\n\nimport { useState } from 'react';\n\nfunction createInitialTodos() {\n  const initialTodos = \\[\\];\n  for (let i = 0; i < 50; i++) {\n    initialTodos.push({\n      id: i,\n      text: 'Item ' + (i + 1)\n    });\n  }\n  return initialTodos;\n}\n\nexport default function TodoList() {\n  const \\[todos, setTodos\\] = useState(createInitialTodos);\n  const \\[text, setText\\] = useState('');\n\n  return (\n    <\\>\n      <input\n        value\\={text}\n        onChange\\={e \\=> setText(e.target.value)}\n      />\n      <button onClick\\={() \\=> {\n        setText('');\n        setTodos(\\[{\n          id: todos.length,\n          text: text\n        }, ...todos\\]);\n      }}\\>Add</button\\>\n      <ul\\>\n        {todos.map(item \\=> (\n          <li key\\={item.id}\\>\n            {item.text}\n          </li\\>\n        ))}\n      </ul\\>\n    </\\>\n  );\n}\n\n* * *\n\n### Resetting state with a key[](#resetting-state-with-a-key \"Link for Resetting state with a key \")\n\nYou‚Äôll often encounter the `key` attribute when [rendering lists.](https://react.dev/learn/rendering-lists) However, it also serves another purpose.\n\nYou can **reset a component‚Äôs state by passing a different `key` to a component.** In this example, the Reset button changes the `version` state variable, which we pass as a `key` to the `Form`. When the `key` changes, React re-creates the `Form` component (and all of its children) from scratch, so its state gets reset.\n\nRead [preserving and resetting state](https://react.dev/learn/preserving-and-resetting-state) to learn more.\n\nimport { useState } from 'react';\n\nexport default function App() {\n  const \\[version, setVersion\\] = useState(0);\n\n  function handleReset() {\n    setVersion(version + 1);\n  }\n\n  return (\n    <\\>\n      <button onClick\\={handleReset}\\>Reset</button\\>\n      <Form key\\={version} />\n    </\\>\n  );\n}\n\nfunction Form() {\n  const \\[name, setName\\] = useState('Taylor');\n\n  return (\n    <\\>\n      <input\n        value\\={name}\n        onChange\\={e \\=> setName(e.target.value)}\n      />\n      <p\\>Hello, {name}.</p\\>\n    </\\>\n  );\n}\n\n* * *\n\n### Storing information from previous renders[](#storing-information-from-previous-renders \"Link for Storing information from previous renders \")\n\nUsually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering ‚Äî for example, you might want to change a state variable when a prop changes.\n\nIn most cases, you don‚Äôt need this:\n\n*   **If the value you need can be computed entirely from the current props or other state, [remove that redundant state altogether.](https://react.dev/learn/choosing-the-state-structure#avoid-redundant-state)** If you‚Äôre worried about recomputing too often, the [`useMemo` Hook](https://react.dev/reference/react/useMemo) can help.\n*   If you want to reset the entire component tree‚Äôs state, [pass a different `key` to your component.](#resetting-state-with-a-key)\n*   If you can, update all the relevant state in the event handlers.\n\nIn the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a `set` function while your component is rendering.\n\nHere‚Äôs an example. This `CountLabel` component displays the `count` prop passed to it:\n\n```\nexport default function CountLabel({ count }) {return <h1>{count}</h1>}\n```\n\nSay you want to show whether the counter has _increased or decreased_ since the last change. The `count` prop doesn‚Äôt tell you this ‚Äî you need to keep track of its previous value. Add the `prevCount` state variable to track it. Add another state variable called `trend` to hold whether the count has increased or decreased. Compare `prevCount` with `count`, and if they‚Äôre not equal, update both `prevCount` and `trend`. Now you can show both the current count prop and _how it has changed since the last render_.\n\nimport { useState } from 'react';\n\nexport default function CountLabel({ count }) {\n  const \\[prevCount, setPrevCount\\] = useState(count);\n  const \\[trend, setTrend\\] = useState(null);\n  if (prevCount !== count) {\n    setPrevCount(count);\n    setTrend(count > prevCount ? 'increasing' : 'decreasing');\n  }\n  return (\n    <\\>\n      <h1\\>{count}</h1\\>\n      {trend && <p\\>The count is {trend}</p\\>}\n    </\\>\n  );\n}\n\nNote that if you call a `set` function while rendering, it must be inside a condition like `prevCount !== count`, and there must be a call like `setPrevCount(count)` inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the _currently rendering_ component like this. Calling the `set` function of _another_ component during rendering is an error. Finally, your `set` call should still [update state without mutation](#updating-objects-and-arrays-in-state) ‚Äî this doesn‚Äôt mean you can break other rules of [pure functions.](https://react.dev/learn/keeping-components-pure)\n\nThis pattern can be hard to understand and is usually best avoided. However, it‚Äôs better than updating state in an effect. When you call the `set` function during render, React will re-render that component immediately after your component exits with a `return` statement, and before rendering the children. This way, children don‚Äôt need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early `return;` to restart rendering earlier.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### I‚Äôve updated the state, but logging gives me the old value[](#ive-updated-the-state-but-logging-gives-me-the-old-value \"Link for I‚Äôve updated the state, but logging gives me the old value \")\n\nCalling the `set` function **does not change state in the running code**:\n\n```\nfunction handleClick() {console.log(count);  // 0setCount(count + 1); // Request a re-render with 1console.log(count);  // Still 0!setTimeout(() => {console.log(count); // Also 0!}, 5000);}\n```\n\nThis is because [states behaves like a snapshot.](https://react.dev/learn/state-as-a-snapshot) Updating state requests another render with the new state value, but does not affect the `count` JavaScript variable in your already-running event handler.\n\nIf you need to use the next state, you can save it in a variable before passing it to the `set` function:\n\n```\nconst nextCount = count + 1;setCount(nextCount);console.log(count);     // 0console.log(nextCount); // 1\n```\n\n* * *\n\n### I‚Äôve updated the state, but the screen doesn‚Äôt update[](#ive-updated-the-state-but-the-screen-doesnt-update \"Link for I‚Äôve updated the state, but the screen doesn‚Äôt update \")\n\nReact will **ignore your update if the next state is equal to the previous state,** as determined by an [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. This usually happens when you change an object or an array in state directly:\n\n```\nobj.x = 10;  // üö© Wrong: mutating existing objectsetObj(obj); // üö© Doesn't do anything\n```\n\nYou mutated an existing `obj` object and passed it back to `setObj`, so React ignored the update. To fix this, you need to ensure that you‚Äôre always [_replacing_ objects and arrays in state instead of _mutating_ them](#updating-objects-and-arrays-in-state):\n\n```\n// ‚úÖ Correct: creating a new objectsetObj({...obj,x: 10});\n```\n\n* * *\n\n### I‚Äôm getting an error: ‚ÄúToo many re-renders‚Äù[](#im-getting-an-error-too-many-re-renders \"Link for I‚Äôm getting an error: ‚ÄúToo many re-renders‚Äù \")\n\nYou might get an error that says: `Too many re-renders. React limits the number of renders to prevent an infinite loop.` Typically, this means that you‚Äôre unconditionally setting state _during render_, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:\n\n```\n// üö© Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ‚úÖ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ‚úÖ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>\n```\n\nIf you can‚Äôt find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific `set` function call responsible for the error.\n\n* * *\n\n### My initializer or updater function runs twice[](#my-initializer-or-updater-function-runs-twice \"Link for My initializer or updater function runs twice \")\n\nIn [Strict Mode](https://react.dev/reference/react/StrictMode), React will call some of your functions twice instead of once:\n\n```\nfunction TodoList() {// This component function will run twice for every render.const [todos, setTodos] = useState(() => {// This initializer function will run twice during initialization.return createTodos();});function handleClick() {setTodos(prevTodos => {// This updater function will run twice for every click.return [...prevTodos, createTodo()];});}// ...\n```\n\nThis is expected and shouldn‚Äôt break your code.\n\nThis **development-only** behavior helps you [keep components pure.](https://react.dev/learn/keeping-components-pure) React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn‚Äôt affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.\n\nFor example, this impure updater function mutates an array in state:\n\n```\nsetTodos(prevTodos => {// üö© Mistake: mutating stateprevTodos.push(createTodo());});\n```\n\nBecause React calls your updater function twice, you‚Äôll see the todo was added twice, so you‚Äôll know that there is a mistake. In this example, you can fix the mistake by [replacing the array instead of mutating it](#updating-objects-and-arrays-in-state):\n\n```\nsetTodos(prevTodos => {// ‚úÖ Correct: replacing with new statereturn [...prevTodos, createTodo()];});\n```\n\nNow that this updater function is pure, calling it an extra time doesn‚Äôt make a difference in behavior. This is why React calling it twice helps you find mistakes. **Only component, initializer, and updater functions need to be pure.** Event handlers don‚Äôt need to be pure, so React will never call your event handlers twice.\n\nRead [keeping components pure](https://react.dev/learn/keeping-components-pure) to learn more.\n\n* * *\n\n### I‚Äôm trying to set state to a function, but it gets called instead[](#im-trying-to-set-state-to-a-function-but-it-gets-called-instead \"Link for I‚Äôm trying to set state to a function, but it gets called instead \")\n\nYou can‚Äôt put a function into state like this:\n\n```\nconst [fn, setFn] = useState(someFunction);function handleClick() {setFn(someOtherFunction);}\n```\n\nBecause you‚Äôre passing a function, React assumes that `someFunction` is an [initializer function](#avoiding-recreating-the-initial-state), and that `someOtherFunction` is an [updater function](#updating-state-based-on-the-previous-state), so it tries to call them and store the result. To actually _store_ a function, you have to put `() =>` before them in both cases. Then React will store the functions you pass.\n\n```\nconst [fn, setFn] = useState(() => someFunction);function handleClick() {setFn(() => someOtherFunction);}\n```",
  "title": "useState ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/useInsertionEffect",
  "markdown": "# useInsertionEffect ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n### Pitfall\n\n`useInsertionEffect` is for CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably want [`useEffect`](https://react.dev/reference/react/useEffect) or [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect) instead.\n\n`useInsertionEffect` allows inserting elements into the DOM before any layout Effects fire.\n\n```\nuseInsertionEffect(setup, dependencies?)\n```\n\n*   [Reference](#reference)\n    *   [`useInsertionEffect(setup, dependencies?)`](#useinsertioneffect)\n*   [Usage](#usage)\n    *   [Injecting dynamic styles from CSS-in-JS libraries](#injecting-dynamic-styles-from-css-in-js-libraries)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `useInsertionEffect(setup, dependencies?)`[](#useinsertioneffect \"Link for this heading\")\n\nCall `useInsertionEffect` to insert styles before any Effects fire that may need to read layout:\n\n```\nimport { useInsertionEffect } from 'react';// Inside your CSS-in-JS libraryfunction useCSS(rule) {useInsertionEffect(() => {// ... inject <style> tags here ...});return rule;}\n```\n\n[See more examples below.](#usage)\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `setup`: The function with your Effect‚Äôs logic. Your setup function may also optionally return a _cleanup_ function. When your component is added to the DOM, but before any layout Effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function.\n    \n*   **optional** `dependencies`: The list of all reactive values referenced inside of the `setup` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://react.dev/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison algorithm. If you don‚Äôt specify the dependencies at all, your Effect will re-run after every re-render of the component.\n    \n\n#### Returns[](#returns \"Link for Returns \")\n\n`useInsertionEffect` returns `undefined`.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   Effects only run on the client. They don‚Äôt run during server rendering.\n*   You can‚Äôt update state from inside `useInsertionEffect`.\n*   By the time `useInsertionEffect` runs, refs are not attached yet.\n*   `useInsertionEffect` may run either before or after the DOM has been updated. You shouldn‚Äôt rely on the DOM being updated at any particular time.\n*   Unlike other types of Effects, which fire cleanup for every Effect and then setup for every Effect, `useInsertionEffect` will fire both cleanup and setup one component at a time. This results in an ‚Äúinterleaving‚Äù of the cleanup and setup functions.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Injecting dynamic styles from CSS-in-JS libraries[](#injecting-dynamic-styles-from-css-in-js-libraries \"Link for Injecting dynamic styles from CSS-in-JS libraries \")\n\nTraditionally, you would style React components using plain CSS.\n\n```\n// In your JS file:<button className=\"success\" />// In your CSS file:.success { color: green; }\n```\n\nSome teams prefer to author styles directly in JavaScript code instead of writing CSS files. This usually requires using a CSS-in-JS library or a tool. There are three common approaches to CSS-in-JS:\n\n1.  Static extraction to CSS files with a compiler\n2.  Inline styles, e.g. `<div style={{ opacity: 1 }}>`\n3.  Runtime injection of `<style>` tags\n\nIf you use CSS-in-JS, we recommend a combination of the first two approaches (CSS files for static styles, inline styles for dynamic styles). **We don‚Äôt recommend runtime `<style>` tag injection for two reasons:**\n\n1.  Runtime injection forces the browser to recalculate the styles a lot more often.\n2.  Runtime injection can be very slow if it happens at the wrong time in the React lifecycle.\n\nThe first problem is not solvable, but `useInsertionEffect` helps you solve the second problem.\n\nCall `useInsertionEffect` to insert the styles before any layout Effects fire:\n\n```\n// Inside your CSS-in-JS librarylet isInserted = new Set();function useCSS(rule) {useInsertionEffect(() => {// As explained earlier, we don't recommend runtime injection of <style> tags.// But if you have to do it, then it's important to do in useInsertionEffect.if (!isInserted.has(rule)) {isInserted.add(rule);document.head.appendChild(getStyleForRule(rule));}});return rule;}function Button() {const className = useCSS('...');return <div className={className} />;}\n```\n\nSimilarly to `useEffect`, `useInsertionEffect` does not run on the server. If you need to collect which CSS rules have been used on the server, you can do it during rendering:\n\n```\nlet collectedRulesSet = new Set();function useCSS(rule) {if (typeof window === 'undefined') {collectedRulesSet.add(rule);}useInsertionEffect(() => {// ...});return rule;}\n```\n\n[Read more about upgrading CSS-in-JS libraries with runtime injection to `useInsertionEffect`.](https://github.com/reactwg/react-18/discussions/110)\n\n##### Deep Dive\n\n#### How is this better than injecting styles during rendering or useLayoutEffect?[](#how-is-this-better-than-injecting-styles-during-rendering-or-uselayouteffect \"Link for How is this better than injecting styles during rendering or useLayoutEffect? \")\n\nIf you insert styles during rendering and React is processing a [non-blocking update,](https://react.dev/reference/react/useTransition#marking-a-state-update-as-a-non-blocking-transition) the browser will recalculate the styles every single frame while rendering a component tree, which can be **extremely slow.**\n\n`useInsertionEffect` is better than inserting styles during [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect) or [`useEffect`](https://react.dev/reference/react/useEffect) because it ensures that by the time other Effects run in your components, the `<style>` tags have already been inserted. Otherwise, layout calculations in regular Effects would be wrong due to outdated styles.",
  "title": "useInsertionEffect ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/components",
  "markdown": "# Built-in React Components ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\nReact exposes a few built-in components that you can use in your JSX.\n\n* * *\n\n## Built-in components[](#built-in-components \"Link for Built-in components \")\n\n*   [`<Fragment>`](https://react.dev/reference/react/Fragment), alternatively written as `<>...</>`, lets you group multiple JSX nodes together.\n*   [`<Profiler>`](https://react.dev/reference/react/Profiler) lets you measure rendering performance of a React tree programmatically.\n*   [`<Suspense>`](https://react.dev/reference/react/Suspense) lets you display a fallback while the child components are loading.\n*   [`<StrictMode>`](https://react.dev/reference/react/StrictMode) enables extra development-only checks that help you find bugs early.\n\n* * *\n\n## Your own components[](#your-own-components \"Link for Your own components \")\n\nYou can also [define your own components](https://react.dev/learn/your-first-component) as JavaScript functions.",
  "title": "Built-in React Components ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/Fragment",
  "markdown": "# <Fragment> (<>...</>) ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`<Fragment>`, often used via `<>...</>` syntax, lets you group elements without a wrapper node.\n\n```\n<><OneChild /><AnotherChild /></>\n```\n\n*   [Reference](#reference)\n    *   [`<Fragment>`](#fragment)\n*   [Usage](#usage)\n    *   [Returning multiple elements](#returning-multiple-elements)\n    *   [Assigning multiple elements to a variable](#assigning-multiple-elements-to-a-variable)\n    *   [Grouping elements with text](#grouping-elements-with-text)\n    *   [Rendering a list of Fragments](#rendering-a-list-of-fragments)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `<Fragment>`[](#fragment \"Link for this heading\")\n\nWrap elements in `<Fragment>` to group them together in situations where you need a single element. Grouping elements in `Fragment` has no effect on the resulting DOM; it is the same as if the elements were not grouped. The empty JSX tag `<></>` is shorthand for `<Fragment></Fragment>` in most cases.\n\n#### Props[](#props \"Link for Props \")\n\n*   **optional** `key`: Fragments declared with the explicit `<Fragment>` syntax may have [keys.](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   If you want to pass `key` to a Fragment, you can‚Äôt use the `<>...</>` syntax. You have to explicitly import `Fragment` from `'react'` and render `<Fragment key={yourKey}>...</Fragment>`.\n    \n*   React does not [reset state](https://react.dev/learn/preserving-and-resetting-state) when you go from rendering `<><Child /></>` to `[<Child />]` or back, or when you go from rendering `<><Child /></>` to `<Child />` and back. This only works a single level deep: for example, going from `<><><Child /></></>` to `<Child />` resets the state. See the precise semantics [here.](https://gist.github.com/clemmy/b3ef00f9507909429d8aa0d3ee4f986b)\n    \n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Returning multiple elements[](#returning-multiple-elements \"Link for Returning multiple elements \")\n\nUse `Fragment`, or the equivalent `<>...</>` syntax, to group multiple elements together. You can use it to put multiple elements in any place where a single element can go. For example, a component can only return one element, but by using a Fragment you can group multiple elements together and then return them as a group:\n\n```\nfunction Post() {return (<><PostTitle /><PostBody /></>);}\n```\n\nFragments are useful because grouping elements with a Fragment has no effect on layout or styles, unlike if you wrapped the elements in another container like a DOM element. If you inspect this example with the browser tools, you‚Äôll see that all `<h1>` and `<article>` DOM nodes appear as siblings without wrappers around them:\n\nexport default function Blog() {\n  return (\n    <\\>\n      <Post title\\=\"An update\" body\\=\"It's been a while since I posted...\" />\n      <Post title\\=\"My new blog\" body\\=\"I am starting a new blog!\" />\n    </\\>\n  )\n}\n\nfunction Post({ title, body }) {\n  return (\n    <\\>\n      <PostTitle title\\={title} />\n      <PostBody body\\={body} />\n    </\\>\n  );\n}\n\nfunction PostTitle({ title }) {\n  return <h1\\>{title}</h1\\>\n}\n\nfunction PostBody({ body }) {\n  return (\n    <article\\>\n      <p\\>{body}</p\\>\n    </article\\>\n  );\n}\n\n##### Deep Dive\n\n#### How to write a Fragment without the special syntax?[](#how-to-write-a-fragment-without-the-special-syntax \"Link for How to write a Fragment without the special syntax? \")\n\nThe example above is equivalent to importing `Fragment` from React:\n\n```\nimport { Fragment } from 'react';function Post() {return (<Fragment><PostTitle /><PostBody /></Fragment>);}\n```\n\nUsually you won‚Äôt need this unless you need to [pass a `key` to your `Fragment`.](#rendering-a-list-of-fragments)\n\n* * *\n\n### Assigning multiple elements to a variable[](#assigning-multiple-elements-to-a-variable \"Link for Assigning multiple elements to a variable \")\n\nLike any other element, you can assign Fragment elements to variables, pass them as props, and so on:\n\n```\nfunction CloseDialog() {const buttons = (<><OKButton /><CancelButton /></>);return (<AlertDialog buttons={buttons}>      Are you sure you want to leave this page?</AlertDialog>);}\n```\n\n* * *\n\n### Grouping elements with text[](#grouping-elements-with-text \"Link for Grouping elements with text \")\n\nYou can use `Fragment` to group text together with components:\n\n```\nfunction DateRangePicker({ start, end }) {return (<>      From<DatePicker date={start} />      to<DatePicker date={end} /></>);}\n```\n\n* * *\n\n### Rendering a list of Fragments[](#rendering-a-list-of-fragments \"Link for Rendering a list of Fragments \")\n\nHere‚Äôs a situation where you need to write `Fragment` explicitly instead of using the `<></>` syntax. When you [render multiple elements in a loop](https://react.dev/learn/rendering-lists), you need to assign a `key` to each element. If the elements within the loop are Fragments, you need to use the normal JSX element syntax in order to provide the `key` attribute:\n\n```\nfunction Blog() {return posts.map(post =><Fragment key={post.id}><PostTitle title={post.title} /><PostBody body={post.body} /></Fragment>);}\n```\n\nYou can inspect the DOM to verify that there are no wrapper elements around the Fragment children:\n\nimport { Fragment } from 'react';\n\nconst posts = \\[\n  { id: 1, title: 'An update', body: \"It's been a while since I posted...\" },\n  { id: 2, title: 'My new blog', body: 'I am starting a new blog!' }\n\\];\n\nexport default function Blog() {\n  return posts.map(post \\=>\n    <Fragment key\\={post.id}\\>\n      <PostTitle title\\={post.title} />\n      <PostBody body\\={post.body} />\n    </Fragment\\>\n  );\n}\n\nfunction PostTitle({ title }) {\n  return <h1\\>{title}</h1\\>\n}\n\nfunction PostBody({ body }) {\n  return (\n    <article\\>\n      <p\\>{body}</p\\>\n    </article\\>\n  );\n}",
  "title": "<Fragment> (<>...</>) ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/Profiler",
  "markdown": "# <Profiler> ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`<Profiler>` lets you measure rendering performance of a React tree programmatically.\n\n```\n<Profiler id=\"App\" onRender={onRender}><App /></Profiler>\n```\n\n*   [Reference](#reference)\n    *   [`<Profiler>`](#profiler)\n    *   [`onRender` callback](#onrender-callback)\n*   [Usage](#usage)\n    *   [Measuring rendering performance programmatically](#measuring-rendering-performance-programmatically)\n    *   [Measuring different parts of the application](#measuring-different-parts-of-the-application)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `<Profiler>`[](#profiler \"Link for this heading\")\n\nWrap a component tree in a `<Profiler>` to measure its rendering performance.\n\n```\n<Profiler id=\"App\" onRender={onRender}><App /></Profiler>\n```\n\n#### Props[](#props \"Link for Props \")\n\n*   `id`: A string identifying the part of the UI you are measuring.\n*   `onRender`: An [`onRender` callback](#onrender-callback) that React calls every time components within the profiled tree update. It receives information about what was rendered and how much time it took.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   Profiling adds some additional overhead, so **it is disabled in the production build by default.** To opt into production profiling, you need to enable a [special production build with profiling enabled.](https://fb.me/react-profiling)\n\n* * *\n\n### `onRender` callback[](#onrender-callback \"Link for this heading\")\n\nReact will call your `onRender` callback with information about what was rendered.\n\n```\nfunction onRender(id, phase, actualDuration, baseDuration, startTime, commitTime) {// Aggregate or log render timings...}\n```\n\n#### Parameters[](#onrender-parameters \"Link for Parameters \")\n\n*   `id`: The string `id` prop of the `<Profiler>` tree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers.\n*   `phase`: `\"mount\"`, `\"update\"` or `\"nested-update\"`. This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or Hooks.\n*   `actualDuration`: The number of milliseconds spent rendering the `<Profiler>` and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. [`memo`](https://react.dev/reference/react/memo) and [`useMemo`](https://react.dev/reference/react/useMemo)). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.\n*   `baseDuration`: The number of milliseconds estimating how much time it would take to re-render the entire `<Profiler>` subtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). Compare `actualDuration` against it to see if memoization is working.\n*   `startTime`: A numeric timestamp for when React began rendering the current update.\n*   `commitTime`: A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Measuring rendering performance programmatically[](#measuring-rendering-performance-programmatically \"Link for Measuring rendering performance programmatically \")\n\nWrap the `<Profiler>` component around a React tree to measure its rendering performance.\n\n```\n<App><Profiler id=\"Sidebar\" onRender={onRender}><Sidebar /></Profiler><PageContent /></App>\n```\n\nIt requires two props: an `id` (string) and an `onRender` callback (function) which React calls any time a component within the tree ‚Äúcommits‚Äù an update.\n\n### Pitfall\n\n### Note\n\n`<Profiler>` lets you gather measurements programmatically. If you‚Äôre looking for an interactive profiler, try the Profiler tab in [React Developer Tools](https://react.dev/learn/react-developer-tools). It exposes similar functionality as a browser extension.\n\n* * *\n\n### Measuring different parts of the application[](#measuring-different-parts-of-the-application \"Link for Measuring different parts of the application \")\n\nYou can use multiple `<Profiler>` components to measure different parts of your application:\n\n```\n<App><Profiler id=\"Sidebar\" onRender={onRender}><Sidebar /></Profiler><Profiler id=\"Content\" onRender={onRender}><Content /></Profiler></App>\n```\n\nYou can also nest `<Profiler>` components:\n\n```\n<App><Profiler id=\"Sidebar\" onRender={onRender}><Sidebar /></Profiler><Profiler id=\"Content\" onRender={onRender}><Content><Profiler id=\"Editor\" onRender={onRender}><Editor /></Profiler><Preview /></Content></Profiler></App>\n```\n\nAlthough `<Profiler>` is a lightweight component, it should be used only when necessary. Each use adds some CPU and memory overhead to an application.\n\n* * *",
  "title": "<Profiler> ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/StrictMode",
  "markdown": "# <StrictMode> ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`<StrictMode>` lets you find common bugs in your components early during development.\n\n```\n<StrictMode><App /></StrictMode>\n```\n\n*   [Reference](#reference)\n    *   [`<StrictMode>`](#strictmode)\n*   [Usage](#usage)\n    *   [Enabling Strict Mode for entire app](#enabling-strict-mode-for-entire-app)\n    *   [Enabling Strict Mode for a part of the app](#enabling-strict-mode-for-a-part-of-the-app)\n    *   [Fixing bugs found by double rendering in development](#fixing-bugs-found-by-double-rendering-in-development)\n    *   [Fixing bugs found by re-running Effects in development](#fixing-bugs-found-by-re-running-effects-in-development)\n    *   [Fixing deprecation warnings enabled by Strict Mode](#fixing-deprecation-warnings-enabled-by-strict-mode)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `<StrictMode>`[](#strictmode \"Link for this heading\")\n\nUse `StrictMode` to enable additional development behaviors and warnings for the component tree inside:\n\n```\nimport { StrictMode } from 'react';import { createRoot } from 'react-dom/client';const root = createRoot(document.getElementById('root'));root.render(<StrictMode><App /></StrictMode>);\n```\n\n[See more examples below.](#usage)\n\nStrict Mode enables the following development-only behaviors:\n\n*   Your components will [re-render an extra time](#fixing-bugs-found-by-double-rendering-in-development) to find bugs caused by impure rendering.\n*   Your components will [re-run Effects an extra time](#fixing-bugs-found-by-re-running-effects-in-development) to find bugs caused by missing Effect cleanup.\n*   Your components will [be checked for usage of deprecated APIs.](#fixing-deprecation-warnings-enabled-by-strict-mode)\n\n#### Props[](#props \"Link for Props \")\n\n`StrictMode` accepts no props.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   There is no way to opt out of Strict Mode inside a tree wrapped in `<StrictMode>`. This gives you confidence that all components inside `<StrictMode>` are checked. If two teams working on a product disagree whether they find the checks valuable, they need to either reach consensus or move `<StrictMode>` down in the tree.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Enabling Strict Mode for entire app[](#enabling-strict-mode-for-entire-app \"Link for Enabling Strict Mode for entire app \")\n\nStrict Mode enables extra development-only checks for the entire component tree inside the `<StrictMode>` component. These checks help you find common bugs in your components early in the development process.\n\nTo enable Strict Mode for your entire app, wrap your root component with `<StrictMode>` when you render it:\n\n```\nimport { StrictMode } from 'react';import { createRoot } from 'react-dom/client';const root = createRoot(document.getElementById('root'));root.render(<StrictMode><App /></StrictMode>);\n```\n\nWe recommend wrapping your entire app in Strict Mode, especially for newly created apps. If you use a framework that calls [`createRoot`](https://react.dev/reference/react-dom/client/createRoot) for you, check its documentation for how to enable Strict Mode.\n\nAlthough the Strict Mode checks **only run in development,** they help you find bugs that already exist in your code but can be tricky to reliably reproduce in production. Strict Mode lets you fix bugs before your users report them.\n\n### Note\n\nStrict Mode enables the following checks in development:\n\n*   Your components will [re-render an extra time](#fixing-bugs-found-by-double-rendering-in-development) to find bugs caused by impure rendering.\n*   Your components will [re-run Effects an extra time](#fixing-bugs-found-by-re-running-effects-in-development) to find bugs caused by missing Effect cleanup.\n*   Your components will [be checked for usage of deprecated APIs.](#fixing-deprecation-warnings-enabled-by-strict-mode)\n\n**All of these checks are development-only and do not impact the production build.**\n\n* * *\n\n### Enabling Strict Mode for a part of the app[](#enabling-strict-mode-for-a-part-of-the-app \"Link for Enabling Strict Mode for a part of the app \")\n\nYou can also enable Strict Mode for any part of your application:\n\n```\nimport { StrictMode } from 'react';function App() {return (<><Header /><StrictMode><main><Sidebar /><Content /></main></StrictMode><Footer /></>);}\n```\n\nIn this example, Strict Mode checks will not run against the `Header` and `Footer` components. However, they will run on `Sidebar` and `Content`, as well as all of the components inside them, no matter how deep.\n\n* * *\n\n### Fixing bugs found by double rendering in development[](#fixing-bugs-found-by-double-rendering-in-development \"Link for Fixing bugs found by double rendering in development \")\n\n[React assumes that every component you write is a pure function.](https://react.dev/learn/keeping-components-pure) This means that React components you write must always return the same JSX given the same inputs (props, state, and context).\n\nComponents breaking this rule behave unpredictably and cause bugs. To help you find accidentally impure code, Strict Mode calls some of your functions (only the ones that should be pure) **twice in development.** This includes:\n\n*   Your component function body (only top-level logic, so this doesn‚Äôt include code inside event handlers)\n*   Functions that you pass to [`useState`](https://react.dev/reference/react/useState), [`set` functions](https://react.dev/reference/react/useState#setstate), [`useMemo`](https://react.dev/reference/react/useMemo), or [`useReducer`](https://react.dev/reference/react/useReducer)\n*   Some class component methods like [`constructor`](https://react.dev/reference/react/Component#constructor), [`render`](https://react.dev/reference/react/Component#render), [`shouldComponentUpdate`](https://react.dev/reference/react/Component#shouldcomponentupdate) ([see the whole list](https://reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects))\n\nIf a function is pure, running it twice does not change its behavior because a pure function produces the same result every time. However, if a function is impure (for example, it mutates the data it receives), running it twice tends to be noticeable (that‚Äôs what makes it impure!) This helps you spot and fix the bug early.\n\n**Here is an example to illustrate how double rendering in Strict Mode helps you find bugs early.**\n\nThis `StoryTray` component takes an array of `stories` and adds one last ‚ÄúCreate Story‚Äù item at the end:\n\nThere is a mistake in the code above. However, it is easy to miss because the initial output appears correct.\n\nThis mistake will become more noticeable if the `StoryTray` component re-renders multiple times. For example, let‚Äôs make the `StoryTray` re-render with a different background color whenever you hover over it:\n\nimport { useState } from 'react';\n\nexport default function StoryTray({ stories }) {\n  const \\[isHover, setIsHover\\] = useState(false);\n  const items = stories;\n  items.push({ id: 'create', label: 'Create Story' });\n  return (\n    <ul\n      onPointerEnter\\={() \\=> setIsHover(true)}\n      onPointerLeave\\={() \\=> setIsHover(false)}\n      style\\={{\n        backgroundColor: isHover ? '#ddd' : '#fff'\n      }}\n    \\>\n      {items.map(story \\=> (\n        <li key\\={story.id}\\>\n          {story.label}\n        </li\\>\n      ))}\n    </ul\\>\n  );\n}\n\nNotice how every time you hover over the `StoryTray` component, ‚ÄúCreate Story‚Äù gets added to the list again. The intention of the code was to add it once at the end. But `StoryTray` directly modifies the `stories` array from the props. Every time `StoryTray` renders, it adds ‚ÄúCreate Story‚Äù again at the end of the same array. In other words, `StoryTray` is not a pure function‚Äîrunning it multiple times produces different results.\n\nTo fix this problem, you can make a copy of the array, and modify that copy instead of the original one:\n\n```\nexport default function StoryTray({ stories }) {const items = stories.slice(); // Clone the array// ‚úÖ Good: Pushing into a new arrayitems.push({ id: 'create', label: 'Create Story' });\n```\n\nThis would [make the `StoryTray` function pure.](https://react.dev/learn/keeping-components-pure) Each time it is called, it would only modify a new copy of the array, and would not affect any external objects or variables. This solves the bug, but you had to make the component re-render more often before it became obvious that something is wrong with its behavior.\n\n**In the original example, the bug wasn‚Äôt obvious. Now let‚Äôs wrap the original (buggy) code in `<StrictMode>`:**\n\n**Strict Mode _always_ calls your rendering function twice, so you can see the mistake right away** (‚ÄúCreate Story‚Äù appears twice). This lets you notice such mistakes early in the process. When you fix your component to render in Strict Mode, you _also_ fix many possible future production bugs like the hover functionality from before:\n\nimport { useState } from 'react';\n\nexport default function StoryTray({ stories }) {\n  const \\[isHover, setIsHover\\] = useState(false);\n  const items = stories.slice(); \n  items.push({ id: 'create', label: 'Create Story' });\n  return (\n    <ul\n      onPointerEnter\\={() \\=> setIsHover(true)}\n      onPointerLeave\\={() \\=> setIsHover(false)}\n      style\\={{\n        backgroundColor: isHover ? '#ddd' : '#fff'\n      }}\n    \\>\n      {items.map(story \\=> (\n        <li key\\={story.id}\\>\n          {story.label}\n        </li\\>\n      ))}\n    </ul\\>\n  );\n}\n\nWithout Strict Mode, it was easy to miss the bug until you added more re-renders. Strict Mode made the same bug appear right away. Strict Mode helps you find bugs before you push them to your team and to your users.\n\n[Read more about keeping components pure.](https://react.dev/learn/keeping-components-pure)\n\n### Note\n\nIf you have [React DevTools](https://react.dev/learn/react-developer-tools) installed, any `console.log` calls during the second render call will appear slightly dimmed. React DevTools also offers a setting (off by default) to suppress them completely.\n\n* * *\n\n### Fixing bugs found by re-running Effects in development[](#fixing-bugs-found-by-re-running-effects-in-development \"Link for Fixing bugs found by re-running Effects in development \")\n\nStrict Mode can also help find bugs in [Effects.](https://react.dev/learn/synchronizing-with-effects)\n\nEvery Effect has some setup code and may have some cleanup code. Normally, React calls setup when the component _mounts_ (is added to the screen) and calls cleanup when the component _unmounts_ (is removed from the screen). React then calls cleanup and setup again if its dependencies changed since the last render.\n\nWhen Strict Mode is on, React will also run **one extra setup+cleanup cycle in development for every Effect.** This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.\n\n**Here is an example to illustrate how re-running Effects in Strict Mode helps you find bugs early.**\n\nConsider this example that connects a component to a chat:\n\nThere is an issue with this code, but it might not be immediately clear.\n\nTo make the issue more obvious, let‚Äôs implement a feature. In the example below, `roomId` is not hardcoded. Instead, the user can select the `roomId` that they want to connect to from a dropdown. Click ‚ÄúOpen chat‚Äù and then select different chat rooms one by one. Keep track of the number of active connections in the console:\n\nYou‚Äôll notice that the number of open connections always keeps growing. In a real app, this would cause performance and network problems. The issue is that [your Effect is missing a cleanup function:](https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed)\n\n```\nuseEffect(() => {const connection = createConnection(serverUrl, roomId);connection.connect();return () => connection.disconnect();}, [roomId]);\n```\n\nNow that your Effect ‚Äúcleans up‚Äù after itself and destroys the outdated connections, the leak is solved. However, notice that the problem did not become visible until you‚Äôve added more features (the select box).\n\n**In the original example, the bug wasn‚Äôt obvious. Now let‚Äôs wrap the original (buggy) code in `<StrictMode>`:**\n\n**With Strict Mode, you immediately see that there is a problem** (the number of active connections jumps to 2). Strict Mode runs an extra setup+cleanup cycle for every Effect. This Effect has no cleanup logic, so it creates an extra connection but doesn‚Äôt destroy it. This is a hint that you‚Äôre missing a cleanup function.\n\nStrict Mode lets you notice such mistakes early in the process. When you fix your Effect by adding a cleanup function in Strict Mode, you _also_ fix many possible future production bugs like the select box from before:",
  "title": "<StrictMode> ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/apis",
  "markdown": "# Built-in React APIs ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\nIn addition to [Hooks](https://react.dev/reference/react) and [Components](https://react.dev/reference/react/components), the `react` package exports a few other APIs that are useful for defining components. This page lists all the remaining modern React APIs.\n\n* * *\n\n*   [`createContext`](https://react.dev/reference/react/createContext) lets you define and provide context to the child components. Used with [`useContext`.](https://react.dev/reference/react/useContext)\n*   [`forwardRef`](https://react.dev/reference/react/forwardRef) lets your component expose a DOM node as a ref to the parent. Used with [`useRef`.](https://react.dev/reference/react/useRef)\n*   [`lazy`](https://react.dev/reference/react/lazy) lets you defer loading a component‚Äôs code until it‚Äôs rendered for the first time.\n*   [`memo`](https://react.dev/reference/react/memo) lets your component skip re-renders with same props. Used with [`useMemo`](https://react.dev/reference/react/useMemo) and [`useCallback`.](https://react.dev/reference/react/useCallback)\n*   [`startTransition`](https://react.dev/reference/react/startTransition) lets you mark a state update as non-urgent. Similar to [`useTransition`.](https://react.dev/reference/react/useTransition)\n*   [`act`](https://react.dev/reference/react/act) lets you wrap renders and interactions in tests to ensure updates have processed before making assertions.\n\n* * *\n\n## Resource APIs[](#resource-apis \"Link for Resource APIs \")\n\n_Resources_ can be accessed by a component without having them as part of their state. For example, a component can read a message from a Promise or read styling information from a context.\n\nTo read a value from a resource, use this API:\n\n*   [`use`](https://react.dev/reference/react/use) lets you read the value of a resource like a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or [context](https://react.dev/learn/passing-data-deeply-with-context).\n\n```\nfunction MessageComponent({ messagePromise }) {const message = use(messagePromise);const theme = use(ThemeContext);// ...}\n```",
  "title": "Built-in React APIs ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/Suspense",
  "markdown": "# <Suspense> ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`<Suspense>` lets you display a fallback until its children have finished loading.\n\n```\n<Suspense fallback={<Loading />}><SomeComponent /></Suspense>\n```\n\n*   [Reference](#reference)\n    *   [`<Suspense>`](#suspense)\n*   [Usage](#usage)\n    *   [Displaying a fallback while content is loading](#displaying-a-fallback-while-content-is-loading)\n    *   [Revealing content together at once](#revealing-content-together-at-once)\n    *   [Revealing nested content as it loads](#revealing-nested-content-as-it-loads)\n    *   [Showing stale content while fresh content is loading](#showing-stale-content-while-fresh-content-is-loading)\n    *   [Preventing already revealed content from hiding](#preventing-already-revealed-content-from-hiding)\n    *   [Indicating that a Transition is happening](#indicating-that-a-transition-is-happening)\n    *   [Resetting Suspense boundaries on navigation](#resetting-suspense-boundaries-on-navigation)\n    *   [Providing a fallback for server errors and client-only content](#providing-a-fallback-for-server-errors-and-client-only-content)\n*   [Troubleshooting](#troubleshooting)\n    *   [How do I prevent the UI from being replaced by a fallback during an update?](#preventing-unwanted-fallbacks)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `<Suspense>`[](#suspense \"Link for this heading\")\n\n#### Props[](#props \"Link for Props \")\n\n*   `children`: The actual UI you intend to render. If `children` suspends while rendering, the Suspense boundary will switch to rendering `fallback`.\n*   `fallback`: An alternate UI to render in place of the actual UI if it has not finished loading. Any valid React node is accepted, though in practice, a fallback is a lightweight placeholder view, such as a loading spinner or skeleton. Suspense will automatically switch to `fallback` when `children` suspends, and back to `children` when the data is ready. If `fallback` suspends while rendering, it will activate the closest parent Suspense boundary.\n\n#### Caveats[](#caveats \"Link for Caveats \")\n\n*   React does not preserve any state for renders that got suspended before they were able to mount for the first time. When the component has loaded, React will retry rendering the suspended tree from scratch.\n*   If Suspense was displaying content for the tree, but then it suspended again, the `fallback` will be shown again unless the update causing it was caused by [`startTransition`](https://react.dev/reference/react/startTransition) or [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue).\n*   If React needs to hide the already visible content because it suspended again, it will clean up [layout Effects](https://react.dev/reference/react/useLayoutEffect) in the content tree. When the content is ready to be shown again, React will fire the layout Effects again. This ensures that Effects measuring the DOM layout don‚Äôt try to do this while the content is hidden.\n*   React includes under-the-hood optimizations like _Streaming Server Rendering_ and _Selective Hydration_ that are integrated with Suspense. Read [an architectural overview](https://github.com/reactwg/react-18/discussions/37) and watch [a technical talk](https://www.youtube.com/watch?v=pj5N-Khihgc) to learn more.\n\n* * *\n\n## Usage[](#usage \"Link for Usage \")\n\n### Displaying a fallback while content is loading[](#displaying-a-fallback-while-content-is-loading \"Link for Displaying a fallback while content is loading \")\n\nYou can wrap any part of your application with a Suspense boundary:\n\n```\n<Suspense fallback={<Loading />}><Albums /></Suspense>\n```\n\nReact will display your loading fallback until all the code and data needed by the children has been loaded.\n\nIn the example below, the `Albums` component _suspends_ while fetching the list of albums. Until it‚Äôs ready to render, React switches the closest Suspense boundary above to show the fallback‚Äîyour `Loading` component. Then, when the data loads, React hides the `Loading` fallback and renders the `Albums` component with data.\n\nimport { Suspense } from 'react';\nimport Albums from './Albums.js';\n\nexport default function ArtistPage({ artist }) {\n  return (\n    <\\>\n      <h1\\>{artist.name}</h1\\>\n      <Suspense fallback\\={<Loading />}\\>\n        <Albums artistId\\={artist.id} />\n      </Suspense\\>\n    </\\>\n  );\n}\n\nfunction Loading() {\n  return <h2\\>üåÄ Loading...</h2\\>;\n}\n\n### Note\n\n**Only Suspense-enabled data sources will activate the Suspense component.** They include:\n\n*   Data fetching with Suspense-enabled frameworks like [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) and [Next.js](https://nextjs.org/docs/getting-started/react-essentials)\n*   Lazy-loading component code with [`lazy`](https://react.dev/reference/react/lazy)\n*   Reading the value of a Promise with [`use`](https://react.dev/reference/react/use)\n\nSuspense **does not** detect when data is fetched inside an Effect or event handler.\n\nThe exact way you would load data in the `Albums` component above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.\n\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\n\n* * *\n\n### Revealing content together at once[](#revealing-content-together-at-once \"Link for Revealing content together at once \")\n\nBy default, the whole tree inside Suspense is treated as a single unit. For example, even if _only one_ of these components suspends waiting for some data, _all_ of them together will be replaced by the loading indicator:\n\n```\n<Suspense fallback={<Loading />}><Biography /><Panel><Albums /></Panel></Suspense>\n```\n\nThen, after all of them are ready to be displayed, they will all appear together at once.\n\nIn the example below, both `Biography` and `Albums` fetch some data. However, because they are grouped under a single Suspense boundary, these components always ‚Äúpop in‚Äù together at the same time.\n\nimport { Suspense } from 'react';\nimport Albums from './Albums.js';\nimport Biography from './Biography.js';\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n  return (\n    <\\>\n      <h1\\>{artist.name}</h1\\>\n      <Suspense fallback\\={<Loading />}\\>\n        <Biography artistId\\={artist.id} />\n        <Panel\\>\n          <Albums artistId\\={artist.id} />\n        </Panel\\>\n      </Suspense\\>\n    </\\>\n  );\n}\n\nfunction Loading() {\n  return <h2\\>üåÄ Loading...</h2\\>;\n}\n\nComponents that load data don‚Äôt have to be direct children of the Suspense boundary. For example, you can move `Biography` and `Albums` into a new `Details` component. This doesn‚Äôt change the behavior. `Biography` and `Albums` share the same closest parent Suspense boundary, so their reveal is coordinated together.\n\n```\n<Suspense fallback={<Loading />}><Details artistId={artist.id} /></Suspense>function Details({ artistId }) {return (<><Biography artistId={artistId} /><Panel><Albums artistId={artistId} /></Panel></>);}\n```\n\n* * *\n\n### Revealing nested content as it loads[](#revealing-nested-content-as-it-loads \"Link for Revealing nested content as it loads \")\n\nWhen a component suspends, the closest parent Suspense component shows the fallback. This lets you nest multiple Suspense components to create a loading sequence. Each Suspense boundary‚Äôs fallback will be filled in as the next level of content becomes available. For example, you can give the album list its own fallback:\n\n```\n<Suspense fallback={<BigSpinner />}><Biography /><Suspense fallback={<AlbumsGlimmer />}><Panel><Albums /></Panel></Suspense></Suspense>\n```\n\nWith this change, displaying the `Biography` doesn‚Äôt need to ‚Äúwait‚Äù for the `Albums` to load.\n\nThe sequence will be:\n\n1.  If `Biography` hasn‚Äôt loaded yet, `BigSpinner` is shown in place of the entire content area.\n2.  Once `Biography` finishes loading, `BigSpinner` is replaced by the content.\n3.  If `Albums` hasn‚Äôt loaded yet, `AlbumsGlimmer` is shown in place of `Albums` and its parent `Panel`.\n4.  Finally, once `Albums` finishes loading, it replaces `AlbumsGlimmer`.\n\nimport { Suspense } from 'react';\nimport Albums from './Albums.js';\nimport Biography from './Biography.js';\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n  return (\n    <\\>\n      <h1\\>{artist.name}</h1\\>\n      <Suspense fallback\\={<BigSpinner />}\\>\n        <Biography artistId\\={artist.id} />\n        <Suspense fallback\\={<AlbumsGlimmer />}\\>\n          <Panel\\>\n            <Albums artistId\\={artist.id} />\n          </Panel\\>\n        </Suspense\\>\n      </Suspense\\>\n    </\\>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2\\>üåÄ Loading...</h2\\>;\n}\n\nfunction AlbumsGlimmer() {\n  return (\n    <div className\\=\"glimmer-panel\"\\>\n      <div className\\=\"glimmer-line\" />\n      <div className\\=\"glimmer-line\" />\n      <div className\\=\"glimmer-line\" />\n    </div\\>\n  );\n}\n\nSuspense boundaries let you coordinate which parts of your UI should always ‚Äúpop in‚Äù together at the same time, and which parts should progressively reveal more content in a sequence of loading states. You can add, move, or delete Suspense boundaries in any place in the tree without affecting the rest of your app‚Äôs behavior.\n\nDon‚Äôt put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience. If you work with a designer, ask them where the loading states should be placed‚Äîit‚Äôs likely that they‚Äôve already included them in their design wireframes.\n\n* * *\n\n### Showing stale content while fresh content is loading[](#showing-stale-content-while-fresh-content-is-loading \"Link for Showing stale content while fresh content is loading \")\n\nIn this example, the `SearchResults` component suspends while fetching the search results. Type `\"a\"`, wait for the results, and then edit it to `\"ab\"`. The results for `\"a\"` will get replaced by the loading fallback.\n\nimport { Suspense, useState } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const \\[query, setQuery\\] = useState('');\n  return (\n    <\\>\n      <label\\>\n        Search albums:\n        <input value\\={query} onChange\\={e \\=> setQuery(e.target.value)} />\n      </label\\>\n      <Suspense fallback\\={<h2\\>Loading...</h2\\>}\\>\n        <SearchResults query\\={query} />\n      </Suspense\\>\n    </\\>\n  );\n}\n\nA common alternative UI pattern is to _defer_ updating the list and to keep showing the previous results until the new results are ready. The [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue) Hook lets you pass a deferred version of the query down:\n\n```\nexport default function App() {const [query, setQuery] = useState('');const deferredQuery = useDeferredValue(query);return (<><label>        Search albums:<input value={query} onChange={e => setQuery(e.target.value)} /></label><Suspense fallback={<h2>Loading...</h2>}><SearchResults query={deferredQuery} /></Suspense></>);}\n```\n\nThe `query` will update immediately, so the input will display the new value. However, the `deferredQuery` will keep its previous value until the data has loaded, so `SearchResults` will show the stale results for a bit.\n\nTo make it more obvious to the user, you can add a visual indication when the stale result list is displayed:\n\n```\n<div style={{opacity: query !== deferredQuery ? 0.5 : 1 }}><SearchResults query={deferredQuery} /></div>\n```\n\nEnter `\"a\"` in the example below, wait for the results to load, and then edit the input to `\"ab\"`. Notice how instead of the Suspense fallback, you now see the dimmed stale result list until the new results have loaded:\n\nimport { Suspense, useState, useDeferredValue } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const \\[query, setQuery\\] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n  return (\n    <\\>\n      <label\\>\n        Search albums:\n        <input value\\={query} onChange\\={e \\=> setQuery(e.target.value)} />\n      </label\\>\n      <Suspense fallback\\={<h2\\>Loading...</h2\\>}\\>\n        <div style\\={{ opacity: isStale ? 0.5 : 1 }}\\>\n          <SearchResults query\\={deferredQuery} />\n        </div\\>\n      </Suspense\\>\n    </\\>\n  );\n}\n\n### Note\n\nBoth deferred values and [Transitions](#preventing-already-revealed-content-from-hiding) let you avoid showing Suspense fallback in favor of inline indicators. Transitions mark the whole update as non-urgent so they are typically used by frameworks and router libraries for navigation. Deferred values, on the other hand, are mostly useful in application code where you want to mark a part of UI as non-urgent and let it ‚Äúlag behind‚Äù the rest of the UI.\n\n* * *\n\n### Preventing already revealed content from hiding[](#preventing-already-revealed-content-from-hiding \"Link for Preventing already revealed content from hiding \")\n\nWhen a component suspends, the closest parent Suspense boundary switches to showing the fallback. This can lead to a jarring user experience if it was already displaying some content. Try pressing this button:\n\nimport { Suspense, useState } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback\\={<BigSpinner />}\\>\n      <Router />\n    </Suspense\\>\n  );\n}\n\nfunction Router() {\n  const \\[page, setPage\\] = useState('/');\n\n  function navigate(url) {\n    setPage(url);\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate\\={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist\\={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout\\>\n      {content}\n    </Layout\\>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2\\>üåÄ Loading...</h2\\>;\n}\n\nWhen you pressed the button, the `Router` component rendered `ArtistPage` instead of `IndexPage`. A component inside `ArtistPage` suspended, so the closest Suspense boundary started showing the fallback. The closest Suspense boundary was near the root, so the whole site layout got replaced by `BigSpinner`.\n\nTo prevent this, you can mark the navigation state update as a _Transition_ with [`startTransition`:](https://react.dev/reference/react/startTransition)\n\n```\nfunction Router() {const [page, setPage] = useState('/');function navigate(url) {startTransition(() => {setPage(url);      });}// ...\n```\n\nThis tells React that the state transition is not urgent, and it‚Äôs better to keep showing the previous page instead of hiding any already revealed content. Now clicking the button ‚Äúwaits‚Äù for the `Biography` to load:\n\nimport { Suspense, startTransition, useState } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback\\={<BigSpinner />}\\>\n      <Router />\n    </Suspense\\>\n  );\n}\n\nfunction Router() {\n  const \\[page, setPage\\] = useState('/');\n\n  function navigate(url) {\n    startTransition(() \\=> {\n      setPage(url);\n    });\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate\\={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist\\={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout\\>\n      {content}\n    </Layout\\>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2\\>üåÄ Loading...</h2\\>;\n}\n\nA Transition doesn‚Äôt wait for _all_ content to load. It only waits long enough to avoid hiding already revealed content. For example, the website `Layout` was already revealed, so it would be bad to hide it behind a loading spinner. However, the nested `Suspense` boundary around `Albums` is new, so the Transition doesn‚Äôt wait for it.\n\n### Note\n\nSuspense-enabled routers are expected to wrap the navigation updates into Transitions by default.\n\n* * *\n\n### Indicating that a Transition is happening[](#indicating-that-a-transition-is-happening \"Link for Indicating that a Transition is happening \")\n\nIn the above example, once you click the button, there is no visual indication that a navigation is in progress. To add an indicator, you can replace [`startTransition`](https://react.dev/reference/react/startTransition) with [`useTransition`](https://react.dev/reference/react/useTransition) which gives you a boolean `isPending` value. In the example below, it‚Äôs used to change the website header styling while a Transition is happening:\n\nimport { Suspense, useState, useTransition } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback\\={<BigSpinner />}\\>\n      <Router />\n    </Suspense\\>\n  );\n}\n\nfunction Router() {\n  const \\[page, setPage\\] = useState('/');\n  const \\[isPending, startTransition\\] = useTransition();\n\n  function navigate(url) {\n    startTransition(() \\=> {\n      setPage(url);\n    });\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate\\={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist\\={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout isPending\\={isPending}\\>\n      {content}\n    </Layout\\>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2\\>üåÄ Loading...</h2\\>;\n}\n\n* * *\n\n### Resetting Suspense boundaries on navigation[](#resetting-suspense-boundaries-on-navigation \"Link for Resetting Suspense boundaries on navigation \")\n\nDuring a Transition, React will avoid hiding already revealed content. However, if you navigate to a route with different parameters, you might want to tell React it is _different_ content. You can express this with a `key`:\n\n```\n<ProfilePage key={queryParams.id} />\n```\n\nImagine you‚Äôre navigating within a user‚Äôs profile page, and something suspends. If that update is wrapped in a Transition, it will not trigger the fallback for already visible content. That‚Äôs the expected behavior.\n\nHowever, now imagine you‚Äôre navigating between two different user profiles. In that case, it makes sense to show the fallback. For example, one user‚Äôs timeline is _different content_ from another user‚Äôs timeline. By specifying a `key`, you ensure that React treats different users‚Äô profiles as different components, and resets the Suspense boundaries during navigation. Suspense-integrated routers should do this automatically.\n\n* * *\n\n### Providing a fallback for server errors and client-only content[](#providing-a-fallback-for-server-errors-and-client-only-content \"Link for Providing a fallback for server errors and client-only content \")\n\nIf you use one of the [streaming server rendering APIs](https://react.dev/reference/react-dom/server) (or a framework that relies on them), React will also use your `<Suspense>` boundaries to handle errors on the server. If a component throws an error on the server, React will not abort the server render. Instead, it will find the closest `<Suspense>` component above it and include its fallback (such as a spinner) into the generated server HTML. The user will see a spinner at first.\n\nOn the client, React will attempt to render the same component again. If it errors on the client too, React will throw the error and display the closest [error boundary.](https://react.dev/reference/react/Component#static-getderivedstatefromerror) However, if it does not error on the client, React will not display the error to the user since the content was eventually displayed successfully.\n\nYou can use this to opt out some components from rendering on the server. To do this, throw an error in the server environment and then wrap them in a `<Suspense>` boundary to replace their HTML with fallbacks:\n\n```\n<Suspense fallback={<Loading />}><Chat /></Suspense>function Chat() {if (typeof window === 'undefined') {throw Error('Chat should only render on the client.');}// ...}\n```\n\nThe server HTML will include the loading indicator. It will be replaced by the `Chat` component on the client.\n\n* * *\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### How do I prevent the UI from being replaced by a fallback during an update?[](#preventing-unwanted-fallbacks \"Link for How do I prevent the UI from being replaced by a fallback during an update? \")\n\nReplacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user.\n\nTo prevent this from happening, [mark the update as non-urgent using `startTransition`](#preventing-already-revealed-content-from-hiding). During a Transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing:\n\n```\nfunction handleNextPageClick() {// If this update suspends, don't hide the already displayed contentstartTransition(() => {setCurrentPage(currentPage + 1);});}\n```\n\nThis will avoid hiding existing content. However, any newly rendered `Suspense` boundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available.\n\n**React will only prevent unwanted fallbacks during non-urgent updates**. It will not delay a render if it‚Äôs the result of an urgent update. You must opt in with an API like [`startTransition`](https://react.dev/reference/react/startTransition) or [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue).\n\nIf your router is integrated with Suspense, it should wrap its updates into [`startTransition`](https://react.dev/reference/react/startTransition) automatically.",
  "title": "<Suspense> ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/act",
  "markdown": "# act ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`act` is a test helper to apply pending React updates before making assertions.\n\nTo prepare a component for assertions, wrap the code rendering it and performing updates inside an `await act()` call. This makes your test run closer to how React works in the browser.\n\n### Note\n\nYou might find using `act()` directly a bit too verbose. To avoid some of the boilerplate, you could use a library like [React Testing Library](https://testing-library.com/docs/react-testing-library/intro), whose helpers are wrapped with `act()`.\n\n*   [Reference](#reference)\n    *   [`await act(async actFn)`](#await-act-async-actfn)\n*   [Usage](#usage)\n    *   [Rendering components in tests](#rendering-components-in-tests)\n    *   [Dispatching events in tests](#dispatching-events-in-tests)\n*   [Troubleshooting](#troubleshooting)\n    *   [I‚Äôm getting an error: ‚ÄúThe current testing environment is not configured to support act‚Äù(‚Ä¶)‚Äù](#error-the-current-testing-environment-is-not-configured-to-support-act)\n\n* * *\n\n## Reference[](#reference \"Link for Reference \")\n\n### `await act(async actFn)`[](#await-act-async-actfn \"Link for this heading\")\n\nWhen writing UI tests, tasks like rendering, user events, or data fetching can be considered as ‚Äúunits‚Äù of interaction with a user interface. React provides a helper called `act()` that makes sure all updates related to these ‚Äúunits‚Äù have been processed and applied to the DOM before you make any assertions.\n\nThe name `act` comes from the [Arrange-Act-Assert](https://wiki.c2.com/?ArrangeActAssert) pattern.\n\n```\nit ('renders with button disabled', async () => {await act(async () => {root.render(<TestComponent />)});expect(container.querySelector('button')).toBeDisabled();});\n```\n\n### Note\n\nWe recommend using `act` with `await` and an `async` function. Although the sync version works in many cases, it doesn‚Äôt work in all cases and due to the way React schedules updates internally, it‚Äôs difficult to predict when you can use the sync version.\n\nWe will deprecate and remove the sync version in the future.\n\n#### Parameters[](#parameters \"Link for Parameters \")\n\n*   `async actFn`: An async function wrapping renders or interactions for components being tested. Any updates triggered within the `actFn`, are added to an internal act queue, which are then flushed together to process and apply any changes to the DOM. Since it is async, React will also run any code that crosses an async boundary, and flush any updates scheduled.\n\n#### Returns[](#returns \"Link for Returns \")\n\n`act` does not return anything.\n\n## Usage[](#usage \"Link for Usage \")\n\nWhen testing a component, you can use `act` to make assertions about its output.\n\nFor example, let‚Äôs say we have this `Counter` component, the usage examples below show how to test it:\n\n```\nfunction Counter() {const [count, setCount] = useState(0);const handleClick = () => {setCount(prev => prev + 1);}useEffect(() => {document.title = `You clicked ${this.state.count} times`;}, [count]);return (<div><p>You clicked {this.state.count} times</p><button onClick={this.handleClick}>        Click me</button></div>)}\n```\n\n### Rendering components in tests[](#rendering-components-in-tests \"Link for Rendering components in tests \")\n\nTo test the render output of a component, wrap the render inside `act()`:\n\n```\nimport {act} from 'react';import ReactDOM from 'react-dom/client';import Counter from './Counter';it('can render and update a counter', async () => {container = document.createElement('div');document.body.appendChild(container);// ‚úÖ Render the component inside act().await act(() => {ReactDOM.createRoot(container).render(<Counter />);});const button = container.querySelector('button');const label = container.querySelector('p');expect(label.textContent).toBe('You clicked 0 times');expect(document.title).toBe('You clicked 0 times');});\n```\n\nHere, we create a container, append it to the document, and render the `Counter` component inside `act()`. This ensures that the component is rendered and its effects are applied before making assertions.\n\nUsing `act` ensures that all updates have been applied before we make assertions.\n\n### Dispatching events in tests[](#dispatching-events-in-tests \"Link for Dispatching events in tests \")\n\nTo test events, wrap the event dispatch inside `act()`:\n\n```\nimport {act} from 'react';import ReactDOM from 'react-dom/client';import Counter from './Counter';it.only('can render and update a counter', async () => {const container = document.createElement('div');document.body.appendChild(container);await act( async () => {ReactDOMClient.createRoot(container).render(<Counter />);});// ‚úÖ Dispatch the event inside act().await act(async () => {button.dispatchEvent(new MouseEvent('click', { bubbles: true }));});const button = container.querySelector('button');const label = container.querySelector('p');expect(label.textContent).toBe('You clicked 1 times');expect(document.title).toBe('You clicked 1 times');});\n```\n\nHere, we render the component with `act`, and then dispatch the event inside another `act()`. This ensures that all updates from the event are applied before making assertions.\n\n### Pitfall\n\nDon‚Äôt forget that dispatching DOM events only works when the DOM container is added to the document. You can use a library like [React Testing Library](https://testing-library.com/docs/react-testing-library/intro) to reduce the boilerplate code.\n\n## Troubleshooting[](#troubleshooting \"Link for Troubleshooting \")\n\n### I‚Äôm getting an error: ‚ÄúThe current testing environment is not configured to support act‚Äù(‚Ä¶)‚Äù[](#error-the-current-testing-environment-is-not-configured-to-support-act \"Link for I‚Äôm getting an error: ‚ÄúThe current testing environment is not configured to support act‚Äù(‚Ä¶)‚Äù \")\n\nUsing `act` requires setting `global.IS_REACT_ACT_ENVIRONMENT=true` in your test environment. This is to ensure that `act` is only used in the correct environment.\n\nIf you don‚Äôt set the global, you will see an error like this:\n\nWarning: The current testing environment is not configured to support act(‚Ä¶)\n\nTo fix, add this to your global setup file for React tests:\n\n```\nglobal.IS_REACT_ACT_ENVIRONMENT=true\n```\n\n### Note",
  "title": "act ‚Äì React",
  "description": null,
  "languageCode": "en"
},
{
  "url": "https://react.dev/reference/react/experimental_useEffectEvent",
  "markdown": "# experimental\\_useEffectEvent ‚Äì React - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary - This feature is available in the latest Canary\n\n`useEffectEvent` is a React Hook that lets you extract non-reactive logic into an [Effect Event.](https://react.dev/learn/separating-events-from-effects#declaring-an-effect-event)\n\n```\nconst onSomething = useEffectEvent(callback)\n```",
  "title": "experimental_useEffectEvent ‚Äì React",
  "description": null,
  "languageCode": "en"
}]