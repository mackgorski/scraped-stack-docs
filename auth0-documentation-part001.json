[
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa",
    "markdown": "# Customize Multi-Factor Authentication Pages\n\nYou can customize the MFA pages that appear to your users by adjusting the Universal Login branding options in the [Universal Login Settings](https://manage.auth0.com/#/login_settings) section of the Auth0 Dashboard.\n\nIf you are using the Universal Login experience, you can customize the page using its flow customization options.\n\nYou can also customize the full HTML content to reflect your organization's particular user experience requirements. To learn more, read [MFA Widget Theme Options](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-widget-theme-options).\n\nWith the Universal Login Experience, MFA is presented even more simply to the user. Once they have entered their credentials to log in, they are presented with the MFA screen. If they have no MFA factor enrolled, they will be asked to enroll, and if they do, they will be asked to present their MFA credential.\n\n## Use the MFA API\n\nAuth0 provides an [MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) for the following scenarios:\n\n*   [Authenticate users with the Resource Owner Password Grant](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa).\n    \n*   Build an interface to [let users manage their own authentication factors](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api).\n    \n*   Invite users to enroll in MFA using [enrollment tickets](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets).\n    \n\nTo use the MFA API, you must enable the MFA grant type for your application. To enable the MFA grant in the Auth0 Dashboard:\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and select your application.\n    \n2.  At the bottom of the **Settings** tab, click **Advanced Settings**.\n    \n3.  Click the **Grant Types** tab and select **MFA**.\n    \n    ![Dashboard Applications Applications Advanced Settings Grant Types tab](https://images.ctfassets.net/cdy7uua7fh8z/3knG7flXhvUi0b2yhH0JEp/bd76163ad3d571c7216f22128f63527c/Screen_Shot_2021-05-18_at_2.24.26_PM.png)\n    \n    To learn more, read [Enable Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication/enable-mfa).\n    \n4.  Click **Save Changes**.\n    \n\n### Limitations\n\nThe MFA API is designed to work with SMS, push notifications within the Guardian application, email, and OTP factors. It does not support enrolling with Duo.\n\n## Customize MFA policy with Actions\n\nYou can use Actions to customize the MFA policy for your tenant, including requiring MFA for users of specific applications, users with specific user metadata or IP ranges, and more.\n\nIf you're unfamiliar with creating Actions, read [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\nWhen writing Actions, you can use the `provider` setting to specify whether to force MFA, and which factor you use. The behavior is different depending on whether you use the Classic or the Universal Login experience:\n\n| Provider | Classic Experience | New Experience |\n| --- | --- | --- |\n| any | Push, SMS, or OTP | Push, SMS, Voice, OTP, Email, or WebAuthN security key (when enabled) |\n| guardian | Push, SMS, or OTP | Push, SMS, OTP, or Email |\n| google-authenticator | Google Authenticator | Push, SMS, OTP, or Email |\n| duo | Duo | Duo |\n\nIf you are using Universal Login you can get the behavior of the Classic Login experience if you enable customization of the MFA login page.\n\nSetting the `provider` to a specific option manually overrides the enabled/disabled toggles in the Dashboard. You can use the following Action to prompt the user to enroll in Duo even if other factors are enabled in the Dashboard:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n    // Forcing the provider to Duo programmatically\n    api.multifactor.enable('duo')\n}\n```\n\n## Common use case examples\n\nHere are some common contextual MFA scenarios that can be handled by Actions.\n\n### Require MFA for specific applications\n\nYou can customize MFA to only trigger when users are logging in to to specific applications.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\tconst CLIENTS_WITH_MFA = [\n\t\t'{yourClientId1}', \n\t\t'{yourClientId2}',\n\t\t'{yourClientId3}'\n\t];\n\n\tif (CLIENTS_WITH_MFA.includes(event.client.client_id)) {\n\t\tapi.multifactor.enable('duo', { allowRememberBrowser: false })\n\t}\n}\n```\n\n### Require MFA for specific users\n\nYou can customize MFA to only trigger for users who are marked to use MFA.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.user.user_metadata && event.user.user_metadata.use_mfa) {\n    api.multifactor.enable('duo', { allowRememberBrowser: false });\n  }\n}\n```\n\n### Change frequency of MFA prompts\n\nIn some scenarios, you may not want to prompt the user for MFA each time they log in from the same browser. You can alter that behavior by using the `allowRememberBrowser` property:\n\n```\nexports.onExecutePostLogin = async (event, api) => {  \n  api.multifactor.enable('any', { allowRememberBrowser: false });\n}\n```\n\nDepending on the property value the behavior will be as follows:\n\n| Value | Description |\n| --- | --- |\n| `true` | When provider is set to `google-authenticator` or `duo`, the user is prompted for MFA once every 30 days. When provider is set to `guardian`, the MFA prompt displays the enrollment checkbox for users to choose whether or not to enroll. Defaults to `false`. To learn more, read [Customize Multi-Factor Authentication Pages](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa) |\n| `false` | The user is prompted for MFA each time they authenticate. |\n\nThe time values are for active users. If a user is inactive for a period of seven days or more, their cookie will expire and they will be prompted for MFA on their next login attempt (regardless if `allowRememberBrowser` is set to `true` and it has not been 30 days since their last MFA prompt).\n\nWhen you allow the user to skip MFA, a cookie is stored in the user's browser. If the user has the cookie set but you still want to require MFA, you have two options:\n\n*   Set `allowRememberBrowser` to `false`\n    \n*   Set `acr_values` to `http://schemas.openid.net/pape/policies/2007/06/multi-factor` when calling the `/authorize` endpoint.\n    \n\nIn situations where a user loses a trusted device, you can prompt the specific user for MFA during their next login by calling the Auth0 Management API [Invalidate Remember Browser](https://auth0.com/docs/api/management/v2#!/Users/post_invalidate_remember_browser) endpoint.\n\n### Require MFA for users outside of the network\n\nAssuming that access to the specified network of internal IP addresses is well controlled, you can also have Auth0 request MFA only from users whose requests originate from outside the corporate network:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const ipaddr = require('ipaddr.js@1.9.0');\n  const corp_network = '192.168.1.134/26';\n  const current_ip = ipaddr.parse(event.request.ip);\n\n  if (!current_ip.match(ipaddr.parseCIDR(corp_network))) {\n    api.multifactor.enable('any', {allowRememberBrowser: false});\n  }\n}\n```\n\n### Bypass MFA for refresh token requests\n\nIf your users report frequent log-outs, you may need to bypass refresh token requests while using MFA. You can alter the default behavior with a filter Action on the `event.transaction.protocol` object property.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.transaction.protocol !== 'oauth2-refresh-token') {\n    // MFA-related commands here\n    api.multifactor.enable('any');\n  }\n};\n```\n\nTo learn more about the Action `event` object, read [Actions Triggers: post-login - Event Object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object).\n\n## Learn more\n\n*   [Customize MFA for Classic Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login)\n*   [Authenticate Using the Resource Owner Password Flow with MFA](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa)\n*   [Auth0 MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api)\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n*   [MFA Widget Theme Options](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-widget-theme-options)\n*   [MFA Theme Language Dictionary](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/mfa-theme-language-dictionary)",
    "title": "Customize Multi-Factor Authentication Pages",
    "description": "Learn how to customize multi-factor authentication (MFA) pages that appear to users with Universal Login branding options.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa",
    "markdown": "# Authenticate Using the Resource Owner Password Flow with MFA\n\nYou can use the [Auth0 MFA API](https://auth0.com/docs/api/authentication#multi-factor-authentication) to complete the authentication flow using the [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow) when MFA is enabled.\n\n## Prerequisites\n\nBefore you can use the MFA APIs, you'll need to enable the MFA grant type for your application. Go to [Auth0 Dashboard > Applications > Advanced Settings > Grant Types](https://manage.auth0.com/#/applications) and select **MFA**.\n\n## Authenticate user\n\nWhen you use the Resource Owner Password Flow to authenticate, you call the `/oauth/token` endpoint with the user's username and password.\n\n*   [cURL](#62894de16af5416292d79cbd935147e6_shell)\n*   [C#](#62894de16af5416292d79cbd935147e6_csharp)\n*   [Go](#62894de16af5416292d79cbd935147e6_go)\n*   [Java](#62894de16af5416292d79cbd935147e6_java)\n*   [Node.JS](#62894de16af5416292d79cbd935147e6_node)\n*   [Obj-C](#62894de16af5416292d79cbd935147e6_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/oauth/token' \\\n  --header 'content-type: application/x-www-form-urlencoded' \\\n  --data grant_type=password \\\n  --data username=user@example.com \\\n  --data password=pwd \\\n  --data 'client_id={yourClientId}' \\\n  --data 'client_secret={yourClientSecret}' \\\n  --data audience=https://someapi.com/api \\\n  --data 'scope=openid profile read:sample'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/oauth/token\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/x-www-form-urlencoded\");\nrequest.AddParameter(\"application/x-www-form-urlencoded\", \"grant_type=password&username=user%40example.com&password=pwd&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2Fsomeapi.com%2Fapi&scope=openid%20profile%20read%3Asample\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/oauth/token\"\n\n\tpayload := strings.NewReader(\"grant_type=password&username=user%40example.com&password=pwd&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2Fsomeapi.com%2Fapi&scope=openid%20profile%20read%3Asample\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/x-www-form-urlencoded\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/oauth/token\")\n  .header(\"content-type\", \"application/x-www-form-urlencoded\")\n  .body(\"grant_type=password&username=user%40example.com&password=pwd&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2Fsomeapi.com%2Fapi&scope=openid%20profile%20read%3Asample\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/oauth/token',\n  headers: {'content-type': 'application/x-www-form-urlencoded'},\n  data: new URLSearchParams({\n    grant_type: 'password',\n    username: 'user@example.com',\n    password: 'pwd',\n    client_id: '{yourClientId}',\n    client_secret: '{yourClientSecret}',\n    audience: 'https://someapi.com/api',\n    scope: 'openid profile read:sample'\n  })\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/x-www-form-urlencoded\" };\n\nNSMutableData *postData = [[NSMutableData alloc] initWithData:[@\"grant_type=password\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&username=user@example.com\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&password=pwd\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_id={yourClientId}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&client_secret={yourClientSecret}\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&audience=https://someapi.com/api\" dataUsingEncoding:NSUTF8StringEncoding]];\n[postData appendData:[@\"&scope=openid profile read:sample\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/oauth/token\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/oauth/token\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"grant_type=password&username=user%40example.com&password=pwd&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2Fsomeapi.com%2Fapi&scope=openid%20profile%20read%3Asample\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/x-www-form-urlencoded\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"grant_type=password&username=user%40example.com&password=pwd&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2Fsomeapi.com%2Fapi&scope=openid%20profile%20read%3Asample\"\n\nheaders = { 'content-type': \"application/x-www-form-urlencoded\" }\n\nconn.request(\"POST\", \"/{yourDomain}/oauth/token\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/oauth/token\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/x-www-form-urlencoded'\nrequest.body = \"grant_type=password&username=user%40example.com&password=pwd&client_id={yourClientId}&client_secret=%7ByourClientSecret%7D&audience=https%3A%2F%2Fsomeapi.com%2Fapi&scope=openid%20profile%20read%3Asample\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/x-www-form-urlencoded\"]\n\nlet postData = NSMutableData(data: \"grant_type=password\".data(using: String.Encoding.utf8)!)\npostData.append(\"&username=user@example.com\".data(using: String.Encoding.utf8)!)\npostData.append(\"&password=pwd\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_id={yourClientId}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&client_secret={yourClientSecret}\".data(using: String.Encoding.utf8)!)\npostData.append(\"&audience=https://someapi.com/api\".data(using: String.Encoding.utf8)!)\npostData.append(\"&scope=openid profile read:sample\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/oauth/token\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nWhen MFA is enabled, the response includes an `mfa_required` error and a `mfa_token`.\n\n```\n{\n    \"error\": \"mfa_required\",\n    \"error_description\": \"Multifactor authentication required\",\n    \"mfa_token\": \"Fe26...Ha\"\n}\n```\n\n## Retrieve enrolled authenticators\n\nAfter getting the error above, you need to find out if the user has an MFA factor enrolled or not. Call the [MFA Authenticators endpoint](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api), using the MFA token obtained in the previous section.\n\n*   [cURL](#cbfd44952cc04a2eb8fb23976b531a17_shell)\n*   [C#](#cbfd44952cc04a2eb8fb23976b531a17_csharp)\n*   [Go](#cbfd44952cc04a2eb8fb23976b531a17_go)\n*   [Java](#cbfd44952cc04a2eb8fb23976b531a17_java)\n*   [Node.JS](#cbfd44952cc04a2eb8fb23976b531a17_node)\n*   [Obj-C](#cbfd44952cc04a2eb8fb23976b531a17_objc)\n*   [...](#)\n\n```\ncurl --request GET \\\n  --url 'https://{yourDomain}/mfa/authenticators' \\\n  --header 'authorization: Bearer MFA_TOKEN' \\\n  --header 'content-type: application/json'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/mfa/authenticators\");\nvar request = new RestRequest(Method.GET);\nrequest.AddHeader(\"authorization\", \"Bearer MFA_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/mfa/authenticators\"\n\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\n\treq.Header.Add(\"authorization\", \"Bearer MFA_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.get(\"https://{yourDomain}/mfa/authenticators\")\n  .header(\"authorization\", \"Bearer MFA_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'GET',\n  url: 'https://{yourDomain}/mfa/authenticators',\n  headers: {authorization: 'Bearer MFA_TOKEN', 'content-type': 'application/json'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MFA_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/mfa/authenticators\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"GET\"];\n[request setAllHTTPHeaderFields:headers];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/mfa/authenticators\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"GET\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MFA_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\nheaders = {\n    'authorization': \"Bearer MFA_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"GET\", \"/{yourDomain}/mfa/authenticators\", headers=headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/mfa/authenticators\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Get.new(url)\nrequest[\"authorization\"] = 'Bearer MFA_TOKEN'\nrequest[\"content-type\"] = 'application/json'\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MFA_TOKEN\",\n  \"content-type\": \"application/json\"\n]\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/mfa/authenticators\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"GET\"\nrequest.allHTTPHeaderFields = headers\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nYou will get an array with the available authenticators. The array will be empty if the user did not enroll a factor.\n\n```\n[\n    {\n        \"id\": \"recovery-code|dev_O4KYL4FtcLAVRsCl\",\n        \"authenticator_type\": \"recovery-code\",\n        \"active\": true\n    },\n    {\n        \"id\": \"email|dev_NU1Ofuw3Cw0XCt5x\",\n        \"authenticator_type\": \"oob\",\n        \"active\": true,\n        \"oob_channel\": \"email\",\n        \"name\": \"email@address.com\"\n    }\n]\n```\n\n## Enroll MFA factor\n\nIf the user is not enrolled in MFA, use the MFA token obtained earlier and enroll it using the MFA Associate endpoint. See the following links to implement this flow based on the authentication factor:\n\n*   [SMS or voice](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n    \n*   [One-time password (OTP)](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n    \n*   [Push](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)\n    \n*   [Email](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n    \n\n## Challenge user with MFA\n\nIf the user is already enrolled in MFA, you need to challenge the user with one of the existing factors. Use the `authenticator_id` return by the MFA Authenticators endpoint when calling the MFA Challenge endpoint.\n\nAfter the challenge is complete, call `/oauth/token` endpoint again to finalize the authentication flow and get the authentication tokens.\n\nSee the links below to implement this flow depending on the authentication factor:\n\n*   [SMS or voice](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n    \n*   [One-time password (OTP)](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n    \n*   [Push](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)\n    \n*   [Email](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n    \n\n## Learn more\n\n*   [Enroll and Challenge SMS and Voice Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-challenge-sms-voice-authenticators)\n*   [Enroll and Challenge OTP Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-otp-authenticators)\n*   [Enroll and Challenge Push Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-push-authenticators)\n*   [Enroll and Challenge Email Authenticators](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators)\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)\n*   [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors)",
    "title": "Authenticate Using the Resource Owner Password Flow with MFA",
    "description": "Learn how to authenticate users using the Resource Owner Password Flow with MFA.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication",
    "markdown": "# Add Step-up Authentication\n\nWith step-up authentication, applications that allow access to different types of resources can require users to authenticate with a stronger authentication mechanism to access sensitive resources.\n\nYou can add step-up authentication to your app with Auth0's extensible multi-factor authentication (MFA) support. Your app can verify that the user has logged in using MFA and, if not, require the user to step-up to access certain resources.\n\n## How it works\n\nAs an example, Fabrikam's Intranet requires users to authenticate with their username and password to access customer data. However, a request for access to employee data (which may contain sensitive salary information) triggers a stronger authentication mechanism like MFA.\n\n![MFA Step-up Authentication flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/3w3duzjtD5B2Nu3oVQcbh/22d3a24aa3c3054fa089effbfa9d654c/step-up-flow.png)\n\n## Step-up Authentication for APIs\n\nWhen your audience is an API, you can implement step-up authentication with Auth0 using [scopes](https://auth0.com/docs/get-started/apis/scopes), [access tokens](https://auth0.com/docs/secure/tokens/access-tokens), and [Actions](https://auth0.com/docs/customize/actions). You can use an Action to trigger the step-up authentication mechanism (for example, prompt MFA) whenever the user requests scopes that map to sensitive resources.\n\nIn our example, a user signs into Fabrikam's web app. The standard login gives to this user the ability to interact with their API and fetch the user's account list. This means that the access token that the application receives after the user authentication contains a scope like `read:accounts`.\n\nNow the user wishes to transfer funds from one account to another, which is deemed a high-value transaction. In order to perform this action, the API requires the scope `transfer:funds`.\n\nThe user's current access token does not include this scope and the application knows it (because the application knows the set of scopes it requested in the initial authentication call). The application performs another authentication call, but this time it requests the scope `transfer:funds`. The browser redirects to Auth0. Per Fabrikam's Action, Auth0 challenges the user to authenticate with MFA because a high-value scope was requested. Once the user successfully authenticates with MFA, Auth0 generates and sends a new access token that includes the high-value scope. The application passes the access token to the API, which discards it after verification, thereby treating it as a single-use token.\n\nTo learn more, read [Configure Step-up Authentication for APIs](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-apis).\n\n## Step-up Authentication for web apps\n\nIf it is a web app that verifies the authentication level, and not an API, then you do not have an access token. In this case, you can check if a user has logged in with MFA by reviewing the contents of their ID token. You can then configure your application to deny access to pages with sensitive information if the ID token indicates that the user did not log in with MFA, and use an Action to trigger the step-up authentication mechanism (for example, prompt MFA). For example, you might have an employee app that authenticates users with usernames and passwords, but if a user wants to access salary information, they have to provide a second factor such as a mobile push notification.\n\nYou can implement this by checking the ID token when the user tries to access that page. If the claims show that the user already has authenticated with MFA then display the sensitive information. Otherwise, trigger authentication again and, using an Action, prompt the user to authenticate with MFA.\n\nTo learn more, read [Configure Step-up Authentication for Web Apps](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-web-apps).\n\n## Learn more\n\n*   [Configure Step-up Authentication for APIs](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-apis)\n*   [Configure Step-up Authentication for Web Apps](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication/configure-step-up-authentication-for-web-apps)",
    "title": "Add Step-up Authentication",
    "description": "Describes how step-up authentication works for APIs and web apps to verify that the user has logged in using MFA and if not, require the user to step-up to access certain resources.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis",
    "markdown": "# Manage Authentication Factors with APIs\n\nAuth0 provides two different APIs to help you and your users manage MFA authentication factors.\n\n## Auth0 Authentication API\n\nUse the [Authentication API Multi-factor Authentication endpoints](https://auth0.com/docs/api/authentication#multi-factor-authentication) to allow your users to manage their own MFA authentication factors.\n\nThis method relies on authenticating using the Resource Owner Password Grant (ROPG) authentication flow. To learn more, read [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authentication-methods-with-management-api).\n\n## Auth0 Management API\n\nUse the [Management API Users endpoints](https://auth0.com/docs/api/management/v2) to manage your users' MFA authentication factors.\n\nThis method relies on authenticating using a confidential application. To learn more, read [Manage Authentication Methods with Management API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authentication-methods-with-management-api).\n\n## Learn more\n\n*   [Manage Authentication Methods with Management API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authentication-methods-with-management-api)\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)",
    "title": "Manage Authentication Factors with APIs",
    "description": "Learn how to manage MFA authentication factors with the Authentication API and Management API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/configure-recovery-codes-for-mfa",
    "markdown": "# Configure Recovery Codes for MFA\n\nA recovery code is a unique code, generated by Auth0, allowing a user to regain account access. So if a user cannot access the device or account used for multi-factor authentication (MFA) enrollment, they can use a recovery code to authenticate.\n\n## How it works\n\nWhen using Universal Login with recovery codes enabled:\n\n1.  A user starts MFA enrollment.\n    \n2.  Auth0 generates a recovery code.\n    \n3.  During MFA enrollment the user is shown the recovery code prompt.\n    \n4.  The user saves the recovery code and completes the enrollment process.\n    \n5.  Now the user can complete MFA with the recovery code they saved if they lose access to their device or account they enrolled for MFA.\n    \n\n![Example recovery code prompt during multi-factor authentication enrollment](https://images.ctfassets.net/cdy7uua7fh8z/6LkXKthRal1r4vIPi3137l/b8e3fe552e37ab8dcdcb57df0b24b813/recovery-code-prompt.png)\n\nWhen using Universal Login with recovery codes disabled:\n\n*   Users will not see the recovery code prompt during MFA enrollment.\n    \n*   Users cannot authenticate with a recovery code.\n    \n\n## Enable recovery codes\n\nRecovery codes are disabled by default. You can enable recovery codes by going to [Dashboard > Security > Multifactor Auth](https://manage.auth0.com/#/security/mfa).\n\n## Learn more\n\n*   [Challenge with Recovery Codes](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/challenge-with-recovery-codes)",
    "title": "Configure Recovery Codes for MFA",
    "description": "How to configure recovery codes for multi-factor authentication.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources",
    "markdown": "# Multi-Factor Authentication Developer Resources\n\nUsing Auth0 SDKs, you can customize your users' multi-factor authentication (MFA) experience and even build applications on top of our multi-factor capabilities.\n\n## MFA API\n\n[MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api) endpoints allow you to enforce MFA when users interact with the [Token endpoints](https://auth0.com/docs/api/authentication#get-token), as well as enroll and manage MFA factors.\n\n## Create custom MFA pages\n\nUse the following client libraries to customize the look-and-feel of the MFA page so it matches your organization.\n\n*   [Auth0 MFA Client library](https://github.com/auth0/auth0-guardian.js)\n    \n*   [Create Custom MFA Widget](https://github.com/auth0/auth0-guardian.js/tree/master/example)\n    \n\n## Create custom enrollments\n\nYou can [customize the enrollment](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/create-custom-enrollment-tickets) process for your users by creating custom enrollment tickets.\n\n## Build custom mobile applications\n\nBuild custom Guardian-like applications or add multi-factor functionality into your applications using our SDKs.\n\n*   [Guardian for Android](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk)\n    \n*   [Guardian for iOS](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk)\n    \n\n## Learn more\n\n*   [Auth0 Guardian](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian)\n*   [Guardian for Android SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk)\n*   [Guardian.swift iOS SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk)\n*   [Auth0 MFA API](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-developer-resources/mfa-api)",
    "title": "Multi-Factor Authentication Developer Resources",
    "description": "Describes developer resources such as the Auth0 MFA API and the Guardian SDKs for multi-factor authentication (MFA).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa",
    "markdown": "# Reset User Multi-Factor Authentication and Recovery Codes\n\nIf a user has lost their mobile device, they can use their recovery code to log in. If they do not have a recovery code, they will need their tenant administrator to reset their multi-factor authentication (MFA). This action is equivalent to removing or deleting the user's MFA registration. The MFA settings associated with the user will be removed, which allows them to set up MFA as if they were a new user on their next login attempt. To reset an admin's MFA as opposed to an end user's MFA, please contact [Auth0 Support](https://auth0.com/docs/troubleshoot/customer-support).\n\n## Use the Dashboard\n\n1.  Go to [Dashboard > Users Management > Users](https://manage.auth0.com/#/users).\n    \n2.  Click on the user whose MFA you want to reset.\n    \n3.  Click on the **Actions** button on the top right of the screen.\n    \n4.  Select **Reset Multi-factor** from the dropdown. Admins will also see a **Reset MFA** link at the bottom of the **Multi-Factor Authentication** tab of the **User Details** page if the user is already enrolled in MFA. Both these methods function the same way. There will be a pop-up box to confirm your decision.\n    \n5.  Click **Yes, reset it** to reset the user's MFA.\n    \n\nThe next time the user logs in, they will need to set up their MFA just like a new user.\n\n## Use the Management API\n\nAs an admin, you can also use the Management API to delete a user's MFA enrollment using `DELETE` `/api/v2/users/{id}/authentication-methods`. If the user has more than one enrollment, you will need to repeat the process for each enrollment.\n\n## Recovery codes\n\nWith most MFA factors, the end user will be given a recovery code upon signup, which should be noted and kept secret. If they do not have their device or are otherwise temporarily unable to use their normal MFA process, the user can log in by entering this code after their username and password. If a recovery code is used, a new recovery code will be provided at that time.\n\n![Reset User MFA Recovery Code example](https://images.ctfassets.net/cdy7uua7fh8z/P4BtAvr47zyL2kqhRHTro/3d7f49d9d476270db43c45eb65283e62/recovery-code.png)\n\nIf a user uninstalls then later re-installs Guardian, they may be prompted to enter their recovery code. If the recovery code has been lost, the user can perform a new installation of the app by disabling automatic restoration of their Guardian backup. To do so, the user will need to uninstall Guardian, temporarily disable automatic restoration of backups within their device settings (steps to do so will vary according to the device), then re-install the app. They will then need to add their MFA account(s) to the app as if performing a first-time setup. If automatic backups or automatic restoration are not enabled on the user's device, re-installation of the app will not prompt for a recovery code and the user will be required to add their MFA account(s) as in a first-time configuration.\n\n## Learn more\n\n*   [Reset Account Passwords](https://auth0.com/docs/troubleshoot/customer-support/reset-account-passwords)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
    "title": "Reset User Multi-Factor Authentication and Recovery Codes",
    "description": "Learn how to reset a user's MFA in case they lose their mobile device and do not have a recovery code.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/manage-users-using-the-management-api",
    "markdown": "# Manage Users Using the Management API\n\nIn addition to using the Dashboard, you can retrieve, create, update or delete users using the [Management API](https://auth0.com/docs/api/management/v2#!/Users/get_users). If you want to call the Management API directly, you will first need to generate the appropriate access token. To learn more, read [Access Tokens for the Management API](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens). Alternatively, you can use an SDK to implement the functionality you need to call the Management API from your application. For a list of available SDKs, read [the SDKs section of our Support Matrix](https://auth0.com/docs/troubleshoot/customer-support/product-support-matrix).\n\nTo learn how to manage Auth0 Dashboard access for your team members, read [Manage Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access).\n\n## Permissions\n\nUse the following permissions to get an access token for the machine-to-machine applications. To learn more, read [Register Machine-to-Machine Applications.](https://auth0.com/docs/get-started/auth0-overview/create-applications/machine-to-machine-apps)\n\n| Permissions | Descriptions |\n| --- | --- |\n| `read:users` | Applications can search and retrieve any user records stored in an Auth0 tenant. This includes reading via the `/api/v2/users` , `/api/v2/users-by-email`, and `/api/v2/jobs/users-export` endpoints. |\n| `create:users` | Applications can create users in any database or passwordless connection in an Auth0 tenant. This includes creating via the `/api/v2/users` and `/api/v2/jobs/users-import` endpoints.<br><br>The `/api/v2/users` endpoint also requires the client ID to be added to the `enabled_clients` property of the connection, similar to the [sign-up endpoint](https://auth0.com/docs/api/authentication#signup). |\n| `update:users` | Applications can update any user stored in an Auth0 tenant. This includes updating via the `/api/v2/users` endpoint. |\n| `update:users_app_metadata` | Applications can update only the `user.app_metadata` attribute for any user stored in an Auth0 tenant. This includes updating via the `/api/v2/users endpoint`. |\n| `delete:users` | Applications can delete any user stored in an Auth0 tenant. This includes deleting via the `/api/v2/users` endpoint. |\n\n## Limitations\n\nBy default, user profile attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable because they are updated from the identity provider each time the user logs in.\n\nTo be able to edit the `name`, `nickname`, `given_name`, `family_name`, or `picture` root attributes on the normalized user profile, you must [configure your connection sync with Auth0](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0) so that user attributes will be updated from the identity provider only on user profile creation. These root attributes will then be available to be edited individually or by bulk imports\n\nYou can set passwords using the `create` or `update` endpoints, but for security purposes, passwords cannot be viewed with the `get` or `list user` commands. The right side of the API explorer provides hints on the user profile attributes which can be viewed or modified for any given call.\n\n## Endpoints\n\n*   Use the [`/users`](https://auth0.com/docs/api/v2#!/Users/get_users) endpoint to [retrieve information about all users](https://auth0.com/docs/api/v2#!/Users/get_users). You can also include search criteria to find specific users.\n    \n*   Use the [`/user_id`](https://auth0.com/docs/api/v2#!/Users/get_users_by_id) to [retrieve information about one user](https://auth0.com/docs/api/v2#!/Users/get_users_by_id) based on the `user_id`. The `user_id` is an internal identifier that consists of a connection name and a unique identifier for the user. The `user_id` is different from the ID token.\n    \n*   The [`/userinfo`](https://auth0.com/docs/api/authentication/reference#get-user-info) endpoint takes as input the [Auth0 access token and returns user profile information](https://auth0.com/docs/api/authentication/reference#get-user-info). This endpoint will include the results of any rules that may have altered the user profile during the authentication transaction, but the resulting user profile will not be filtered by any [Scoping](https://auth0.com/docs/scopes/api-scopes).\n    \n*   The [`/tokeninfo`](https://auth0.com/docs/api/authentication/reference#get-token-info) endpoint takes as input the [Auth0 ID token and returns user profile information](https://auth0.com/docs/api/authentication/reference#get-token-info). This endpoint will return a result that does not include the results of any rules that alter the user profile.\n    \n\n## Learn more\n\n*   [Check Error Messages](https://auth0.com/docs/troubleshoot/basic-issues/check-error-messages)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles)\n*   [Auth0.swift: User Management](https://auth0.com/docs/libraries/auth0-swift/auth0-swift-user-management)\n*   [Auth0.Android: User Management](https://auth0.com/docs/libraries/auth0-android/auth0-android-user-management)",
    "title": "Manage Users Using the Management API",
    "description": "Learn how to create a user and view users and their profile details using the Management API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/verify-emails",
    "markdown": "# Verify Emails using Auth0\n\nWhen using an email address supplied by a user, it is important to verify the user has access to that email. This is true anytime you send an email to a user or if you use email as an index for search. Auth0 does not recommend using an email address as a way to validate that a user is who they say they are.\n\nEmail verification is crucial for applications that:\n\n*   use email addresses as one of the primary ways to index users\n    \n*   send out emails to users\n    \n*   use email addresses to recommend account linking\n    \n*   let users create accounts connected to an email address\n    \n\nAuth0 provides several ways to add email verification to your application.\n\n## Choose the right approach\n\nThere are several ways to mark emails as verified or unverified. To figure out which method is right for you, here are a few questions to ask yourself or your team:\n\n*   Am I storing (or planning to store) usernames and passwords in Auth0 (or in a database connected through Auth0)?\n    \n*   Do I have special email verification requirements that prevent me from using Auth0's built in verify email flow?  \n    \n*   Do I need to bulk set a large number of users to email verified?\n    \n*   Do I have users coming from Azure AD, ADFS, or other enterprise connections that will need their emails verified?\n    \n\nIf you are storing usernames and passwords in Auth0 or using a custom DB connection to store users in your own system then you can likely use Auth0's [built-in email verification flow](#magic-link-in-a-verification-email).\n\nIf you have requirements preventing you from using Auth0's built in flow or you need to bulk set a large number of users, we have [API endpoints](#custom-or-bulk-verification-with-the-management-api) to help.\n\nLastly, if you have users from enterprise connections, some of those connections have special email verification workflows. To learn more, read [Special Verification Support](#special-verification-support).\n\n## Magic link in a verification email\n\nA common way to verify emails with Auth0 is to email a magic link, or verification link, to the user. When the user clicks the link, the user's `email_verified` flag is set to `true`.\n\n**By default, Auth0 emails magic links to users when they sign up.**\n\nYou can also customize when Auth0 sends verification emails. For example, if you need to verify emails in bulk or if you want to delay verification until the user performs an action requiring a verified email.\n\nThere are two ways to control when the user gets the verification email :\n\n*   Use the [email verification job](https://auth0.com/docs/api/management/v2#!/Jobs/post_verification_email). This triggers Auth0 to send the verification email using the verify email template\n    \n*   Create an [email verification ticket](https://auth0.com/docs/api/management/v2#!/Tickets/post_email_verification) and send the email yourself, including the ticket the user should click to verify their email\n    \n\n## Custom or bulk verification with the Management API\n\nIn some cases you may want to verify email through other means. For example, you have a list of users to verify in bulk or you have some other means for verifying a user's email through a custom workflow you've built yourself.\n\nIn these cases you can use the [PATCH `/api/v2/users` endpoint](https://auth0.com/docs/api/management/v2/#!/Users/patch_users_by_id) to set `email_verified` to `true`.\n\n## Special verification support\n\nFor Azure AD and ADFS enterprise connections, Auth0 supports some custom email verification workflows. This can help you ensure users coming from other systems have verified emails in an accurate and secure way. To learn more, read [Email Verification for Azure AD and ADFS](https://auth0.com/docs/connections/azuread-adfs-email-verification).\n\n## Learn more\n\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles)",
    "title": "Verify Emails using Auth0",
    "description": "Overview of the different ways to verify user emails using Auth0",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/manage-users-using-the-dashboard",
    "markdown": "# Manage Users Using the Dashboard\n\nYou can use the Dashboard to manage your users. To begin, go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users). This is where you create, view, modify, or delete users.\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nBy default, user profile attributes provided by identity providers other than Auth0 (such as Google, Facebook, or X) are not directly editable because they are updated from the identity provider each time the user logs in.\n\nTo be able to edit the `name`, `nickname`, `given_name`, `family_name`, or `picture` root attributes on the normalized user profile, you must [configure your connection sync with Auth0](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0) so that user attributes will be updated from the identity provider only on user profile creation. These root attributes will then be available to be edited individually or by bulk imports\n\nTo learn how to manage Auth0 Dashboard access for your team members, read [Manage Dashboard Access](https://auth0.com/docs/get-started/manage-dashboard-access).\n\n## Learn more\n\n*   [Search for Users](https://auth0.com/docs/manage-users/user-search)\n*   [User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles)\n*   [Import and Export Users](https://auth0.com/docs/manage-users/user-migration)",
    "title": "Manage Users Using the Dashboard",
    "description": "Describes how to manage users in the Auth0 Dashboard.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles",
    "markdown": "# User Profiles\n\nTo access any of the applications in your tenant, each user must have a profile in the tenant. User profiles contain information about your users such as name and contact information. You can manage user profiles through the [Auth0 Dashboard](https://auth0.com/docs/get-started/auth0-overview/dashboard) and the [Auth0 Management API](https://auth0.com/docs/api/management/v2). \n\n## User data sources\n\nUser data can come from many sources, including your own databases as well as social, legal, and enterprise identity providers. Some examples include Google, Facebook, Active Directory, or SAML. You can normalize user data that comes from any supported data source. \n\nUser profile attributes can include information from the identity provider. These are examples:\n\n| User data from... | Might include... |\n| --- | --- |\n| LinkedIn | Current employer or degrees achieved |\n| Facebook | Profile picture, birthday, or relationship status |\n| Active Directory | Employee number, job title, or department |\n\nAuth0 refers to all user data sources as **connections** because Auth0 connects to them to authenticate the user.\n\n### User data normalization\n\nAuth0 supports a variety of [Identity Providers](https://auth0.com/docs/authenticate/identity-providers) and [Database Connections](https://auth0.com/docs/authenticate/database-connections). Each connection can return a different set of user attributes. Sometimes different connections use different names for the same attribute. For example, `surname` from one connection might be `last_name` and `family_name` from other user data sources. \n\nTo handle this complexity, Auth0 provides a [normalized user profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles), an Auth0-specific standard for storing user data.\n\n### User profile attribute mapping\n\n#### AD/LDAP connector\n\nFor Active Directory or any other LDAP connections that use the Auth0 AD/LDAP connector, there is a mechanism for mapping user profile attributes in the directory service to the Auth0 normalized user profile. A `profileMapper.js` file, located in the installation directory of the AD/LDAP connector, maps the attributes when a user authenticates.\n\n#### SAML assertions\n\nIf your application uses the SAML protocol to communicate with Auth0, one of two mechanisms match the user attributes to the Auth0 normalized user profile:\n\n| If Auth0 is a... | Then... |\n| --- | --- |\n| SAML Service Provider | Use the SAML connection's Mappings tab to map attributes coming from an IDP to attributes in the Auth0 user profile: Go to [Dashboard > Authentication > Enterprise > SAMLP](https://manage.auth0.com/#/connections/database/enterprise/samlp). Click on the name of the SAML connection and click **Mappings**. |\n| SAML Identity Provider | Use the Settings tab of Application AddOns to map attributes from the Auth0 user profile to attributes in the SAML Assertion sent back to the Service Provider: Go to [Dashboard > Applications](https://manage.auth0.com/#/connections/database/applications). Click on the name of your application, click **Addons**, and click **SAML2 Web App**. |\n\n### Account linking\n\nUsers can log into an application initially using one connection (such as a custom database), then later log in using a different connection (such as Facebook). In this case, the `user_id` for the second authentication is different from the `user_id` for the first authentication.\n\nAuth0 provides a mechanism to link the two accounts. When Auth0 links the two accounts, it stores two elements in the `identities` array portion of the user profile, one for each connection.\n\nAuth0 does not merge user profile attributes from multiple providers. Auth0 sources **core** user profile attributes from the first provider used.\n\nTo learn more, read [User Account Linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking).\n\n### Caching user profiles\n\nAuth0 caches the user profile received from a connection before passing it on to the calling application. This cache is in the Auth0 database. Each time the user authenticates, Auth0 updates the cache. To learn more, read [Update User Profile Using Your Database](https://auth0.com/docs/manage-users/user-accounts/user-profiles/update-user-profiles-using-your-database).\n\n## Custom user profile data\n\nAuth0 lets you store [metadata](https://auth0.com/docs/manage-users/user-accounts/metadata), which is data related to each user that has not come from the identity provider. You can use `user_metadata` to store custom attributes such as the user's favorite color or hobby.\n\n## Change user profile data\n\nYou can modify a user's profile information in a number of ways.\n\n*   [Scopes](https://auth0.com/docs/get-started/apis/scopes): The authentication flows supported by Auth0 include an optional parameter that lets you specify a scope. This controls the user profile information (claims) included in the ID token (JWT).\n    \n*   [Auth0 Dashboard](https://auth0.com/docs/manage-users/user-accounts/manage-users-using-the-dashboard): The Dashboard lets you manually edit the `user_metadata` and `app_metadata` portions of any user’s profile.\n    \n*   [Management API](https://auth0.com/docs/manage-users/user-accounts/manage-users-using-the-management-api): You can read, update, and delete user profiles stored in the Auth0 database.\n    \n*   [Custom database scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/templates): If you’re using a custom database as a connection, you can write scripts to implement lifecycle events such as create, login, verify, delete and change password. Auth0 provides templates for these scripts that you can modify for the particular database and schema.\n    \n*   [Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules): Use Rules to augment the user profile during the authentication transaction, and optionally persist those changes back to Auth0. \n    \n\n## Access user profiles\n\nBoth apps and the Auth0 Management API can a user's profile information.\n\n### Access user profiles from apps\n\nOnce Auth0 completes authentication and returns control to your application, it provides the user profile to the application. At a low level, you can accomplish this using one of the application [protocols](https://auth0.com/docs/authenticate/protocols) supported by Auth0. However, most developers prefer to use the Auth0 SDKs. To learn more, read [Quickstarts](https://auth0.com/docs/quickstarts).\n\nOne SDK is the Auth0 Lock widget, which provides a user login interface. To learn more, read:\n\n*   [Lock for Web](https://auth0.com/docs/libraries/lock)\n    \n*   [Lock Swift](https://auth0.com/docs/libraries/lock-swift)\n    \n*   [Lock.Android](https://auth0.com/docs/libraries/lock-android)\n    \n\nIf you want your web app to have a custom login UI, you can use Auth0.js. This headless JavaScript library for Auth0 invokes authentication flow (and other tasks) and receives a User Profile object in return. To learn more, read [Auth0.js v9 Reference](https://auth0.com/docs/libraries/auth0js).\n\n### Access user profiles from the Management API\n\nAuth0 provides a REST API that allows applications and services to access and manipulate the User Profile object.\n\nThe API Explorer lets users interactively explore the Management API. It provides:\n\n*   API calls available\n    \n*   Information required for each call\n    \n*   Information returned by each call\n    \n\nWith the explorer, users can try each endpoint in the explorer UI or via a CuRL command on the command line. To try one of the Management API commands, go to the [API Explorer](https://auth0.com/docs/api/management/v2). Select the access required under **Scopes** within the command you choose, such as `update:users`, and then click **TRY**.\n\nThe Auth0 Authentication API is specifically for authentication flows. To learn more, read [Authentication API Explorer](https://auth0.com/docs/api/authentication). Typically, most of these endpoints are used by the various Auth0 SDKs, not your own code.\n\n## The difference between user profiles and tokens\n\nIn the authentication flows described above, Auth0 returns a set of tokens in lieu of a full user profile.\n\nOne of the returned tokens is the ID token, which is a JSON Web Token (JWT) that contains user profile attributes represented in the form of claims. These claims are statements about the user. A claim can be trusted if the consumer of the token can verify its signature, which (in the case of HS256) is generated with the Auth0 app’s client secret. If your app uses RS256 encryption, the ID token will be signed with a private key and verified with a public key. Your app can then decode the JWT and get the user information contained in its payload. Examples of this information are the user's name, email, and other data that is typically part of the user experience.\n\nThe claims within a JWT generally contain only a subset of the information available in the user profile. The purpose is to minimize the token size. To learn more, read [JSON Web Tokens](https://auth0.com/docs/secure/tokens/json-web-tokens).\n\nThere are three other types of tokens that can be returned during authentication:\n\n*   Auth0 access token\n    \n*   Third-party provider access token\n    \n*   Refresh token\n    \n\nTo learn more about tokens and claims, read [Tokens](https://auth0.com/docs/secure/tokens).\n\n## Learn more\n\n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [Troubleshoot SAML Errors](https://auth0.com/docs/troubleshoot/authentication-issues/saml-errors)\n*   [Verify Connections](https://auth0.com/docs/troubleshoot/basic-issues/verify-connections)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Auth0.Android Login, Logout, and User Profiles](https://auth0.com/docs/libraries/auth0-android/auth0-android-login-logout-and-user-profiles)",
    "title": "User Profiles",
    "description": "Understand how user profiles work in Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/metadata",
    "markdown": "# Understand How Metadata Works in User Profiles\n\nAuth0 provides a comprehensive system for storing metadata in the Auth0 user profile. You can use metadata to do the following activities:\n\n*   Store application-specific data in the user profile.\n    \n*   Record whether or not specific operations have occurred for a user.\n    \n*   Cache the results of expensive operations on the user profile so they can be re-used in future logins.\n    \n*   Store information that does not originate from an identity provider or that overrides what an identity provider supplies.\n    \n\nThe metadata can be modified as part of a user’s login flow.\n\nYou can configure connection sync so that user root attributes are updated by the identity provider only on user profile creation. You can then edit root attributes individually or by bulk import. To learn more, read [Configure Identify Provider Connection for User Profiles Updates](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0).\n\n## Metadata types\n\nAuth0 uses three types of metadata to store specific kinds of information.\n\n| **Metadata Type** | **Field Name** | **Description** |\n| --- | --- | --- |\n| **User Information** | `user_metadata` | Stores user attributes such as preferences that do not impact a user's core functionality. This data **can** be edited by logged in users if you build a form using the Management API and should **not** be used as a secure data store. |\n| **Access Information** | `app_metadata` | Stores information such as permissions, Auth0 plan, and external IDs that can impact user access to features. This data **cannot** be edited by users and there are restrictions for what can be stored in this field. |\n| **Application Information** | `client_metadata` in the `Client` object, `context.clientMetadata` in Rules, and `event.client.metadata` in post-login Actions. | Stores information about an application (or _client_ in OIDC OAuth2 terminology). For example, the URL for the application home page (any value that Auth0 doesn’t set in the application settings). |\n\n## Manage metadata\n\nYou can create and update metadata using Rules, the Authentication API, the Management API, the Auth0 Dashboard, and the Lock library.\n\nIt is not recommended that `app_metadata` or `user_metadata` be returned by\n\n*   custom DB scripts\n    \n*   the `fetchUserProfile` script of custom social connections\n    \n\n### Use Actions\n\n[Actions](https://auth0.com/docs/customize/actions) are secure, tenant-specific, versioned functions written in Node.js that execute at certain points within the Auth0 platform. Actions are used to customize and extend Auth0's capabilities with custom logic.\n\nTo learn more, read [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata).\n\n### Use the Management API\n\nA user can request an access token with the appropriate scopes and use the following [Management API](https://auth0.com/docs/api/management/v2) endpoints to view, create, or update `user_metadata`, or remove an MFA configuration.\n\nAn access token is required to call the Auth0 Management API. To learn more, read [Access Tokens for the Management API](https://auth0.com/docs/api/management/v2/tokens) and [Get Management API Tokens for SPAs](https://auth0.com/docs/api/management/v2/get-access-tokens-for-spas).\n\n### Use the Dashboard\n\nUse the Auth0 Dashboard to configure application metadata which contains key/value pairs. To learn more, read [Configure Application Metadata](https://auth0.com/docs/get-started/applications/configure-application-metadata).\n\n### Use the Lock library\n\nUse the [Lock](https://auth0.com/docs/libraries/lock) library to define, add, read, and update `user_metadata.` Read `user_metadata` properties the same way you would read any other user profile property. For example, the following code snippet retrieves the value associated with `user_metadata.hobby` and assigns it to an element on the page:\n\n```\n// Use the accessToken acquired upon authentication to call getUserInfo\nlock.getUserInfo(accessToken, function(error, profile) {\n  if (!error) {\n    document.getElementById('hobby').textContent = profile.user_metadata.hobby;\n  }\n});\n```\n\nYou can use `additionalSignUpFields` to add custom fields to user sign-up forms. When a user adds data in a custom field, Auth0 stores entered values in that user's `user_metadata`. To learn more about adding `user_metadata` on signup, read [Additional Signup Fields](https://auth0.com/docs/libraries/lock/v10/customization#additionalsignupfields-array-).\n\n## Custom database connections and metadata\n\nIf you have a [custom database connection](https://auth0.com/docs/connections/database#using-your-own-user-store), you can use the Authentication API [`/dbconnections/signup`](https://auth0.com/docs/api/authentication?shell#signup) endpoint to set the `user_metadata` for a user. To learn more about working with metadata during a custom signup process, read [Custom Signup](https://auth0.com/docs/libraries/custom-signup).\n\nWhen you set the `user_metadata` field using the Authentication API `/dbconnections/signup` endpoint, you are limited to a maximum of 10 string fields and 500 characters.\n\n## Custom emails and metadata\n\nUse metadata to store information that you want to use to customize Auth0 emails. For example, use `user_metadata.lang` if you want the user to be able to change the field's value, then use the information to customize the language for an email. To learn more, read [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\nIf you are having issues with Lock, review [Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors). If you are having issues with the Management API, review [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n\n## Learn more\n\n*   [Metadata Field Names and Data Types](https://auth0.com/docs/manage-users/user-accounts/metadata/metadata-fields-data)\n*   [Manage Metadata with Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules)\n*   [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api)\n*   [Manage Metadata with Lock](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-lock)\n*   [Configure Application Metadata](https://auth0.com/docs/get-started/applications/configure-application-metadata)\n*   [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata)",
    "title": "Understand How Metadata Works in User Profiles",
    "description": "Describes Auth0 user, application, and client metadata. Learn how you can use metadata to store information that does not originate from an identity provider.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-account-linking/unlink-user-accounts",
    "markdown": "# Unlink User Accounts\n\nUse the Auth0 Management API [Unlink a User Account](https://auth0.com/docs/api/management/v2#!/Users/delete_user_identity_by_user_id) endpoint or the Auth0.js library to unlink an identity from the target user account making it a separate user account again.\n\nThe result of the unlinking process is the following:\n\n*   The secondary account is removed from the identities array of the primary account.\n    \n*   A new secondary user account is created.\n    \n*   The secondary account will have no metadata.\n    \n\nIf your goal is to delete the secondary identity entirely, you must first unlink the accounts, and then [delete the newly created secondary account](https://auth0.com/docs/manage-users/user-accounts/delete-users).\n\nDepending on from where you call the endpoint, use one of these two scopes:\n\n*   `update:current_user_identities` from [client-side code](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation)\n    \n*   `update:users` from [server-side code](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)\n    \n\nThe endpoint uses the following parameters:\n\n| Parameter | Type | Description |\n| --- | --- | --- |\n| `id` | `string` | ID of the primary user account (required) |\n| `provider` | `string` | identity provider name of the secondary linked account (e.g. `google-oauth2`) |\n| `user_id` | `string` | ID of the secondary linked account (e.g. `123456789081523216417` part after the \\` |\n\nIf your instance has users from multiple providers, you may also include `[connection_name]|` before the `user_id` string to name the provider (for example, `\"user-id\": \"google-oauth2|123456789081523216417\").`\n\n## Response example\n\n```\n[\n  {\n    \"connection\": \"Initial-Connection\",\n    \"user_id\": \"5457edea1b8f22891a000004\",\n    \"provider\": \"auth0\",\n    \"isSocial\": false,\n    \"access_token\": \"\",\n    \"profileData\": {\n      \"email\": \"\",\n      \"email_verified\": false,\n      \"name\": \"\",\n      \"username\": \"johndoe\",\n      \"given_name\": \"\",\n      \"phone_number\": \"\",\n      \"phone_verified\": false,\n      \"family_name\": \"\"\n    }\n  }\n]\n```\n\n## Use JWT from the primary account\n\nTo unlink accounts, call the Management API [Unlink a User Account endpoint](https://auth0.com/docs/api/v2#!/Users/delete_user_identity_by_user_id) using the JWT from the primary account for authorization:\n\n```\nfunction unlinkAccount(secondaryProvider, secondaryUserId){\n  var primaryUserId = localStorage.getItem('user_id');\n  var primaryJWT = localStorage.getItem('id_token');\n  $.ajax({\n    type: 'DELETE',\n    url: 'https://' + '{yourDomain}' + '/api/v2/users/' + primaryUserId +\n         '/identities/' + secondaryProvider + '/' + secondaryUserId,\n    headers: {\n      'Authorization': 'Bearer ' + primaryJWT\n    }\n  }).then(function(identities){\n    alert('unlinked!');\n    showLinkedAccounts(identities);\n  }).fail(function(jqXHR){\n    alert('Error unlinking Accounts: ' + jqXHR.status + ' ' + jqXHR.responseText);\n  });\n}\n```\n\n## Use Access Token with the update:users scope\n\nIf you need to unlink two or more user accounts, call the Management API [Unlink a User Account endpoint](https://auth0.com/docs/api/v2#!/Users/delete_user_identity_by_user_id) using an [Management API Access Token](https://auth0.com/docs/api/v2/tokens) with the `update:users` scope.\n\n```\nfunction unlinkAccount(secondaryProvider, secondaryUserId) {\n  var primaryUserId = localStorage.getItem('user_id');\n  var primaryAccessToken = localStorage.getItem('access_token');\n\n  // Uses the Access Token of the primary user as a bearer token to identify the account\n  // which will have the account unlinked to, and the user id of the secondary user, to identify\n  // the user that will be unlinked from the primary account.\n\n  $.ajax({\n    type: 'DELETE',\n    url: 'https://' + AUTH0_DOMAIN +'/api/v2/users/' + primaryUserId +\n         '/identities/' + secondaryProvider + '/' + secondaryUserId,\n    headers: {\n      'Authorization': 'Bearer ' + primaryAccessToken\n    }\n  }).then(function(identities){\n    alert('unlinked!');\n    showLinkedAccounts(identities);\n  }).fail(function(jqXHR){\n    alert('Error unlinking Accounts: ' + jqXHR.status + ' ' + jqXHR.responseText);\n  });\n}\n```\n\n## Unlink accounts from server-side code\n\n1.  Update the user in session with the new array of identities (each of which represent a separate user account).\n    \n\n```\nconst ensureLoggedIn = require('connect-ensure-login').ensureLoggedIn();\nconst Auth0Client = require('../Auth0Client');\nconst express = require('express');\nconst router = express.Router();\n...\nrouter.post('/unlink-accounts/:targetUserProvider/:targetUserId',ensureLoggedIn, (req,res,next) => {\n  Auth0Client.unlinkAccounts(req.user.id, req.params.targetUserProvider, req.params.targetUserId)\n  .then( identities => {\n    req.user.identities = req.user._json.identities = identities;\n    res.send(identities);\n  })\n  .catch( err => {\n    console.log('Error unlinking accounts!',err);\n    next(err);\n  });\n});\n```\n\n1.  Call the Management API v2 [Unlink a User Account endpoint](https://auth0.com/docs/api/v2#!/Users/delete_user_identity_by_user_id) using an [Management API Access Token](https://auth0.com/docs/api/v2/tokens) with the `update:users` scope.\n    \n\n```\nconst request = require('request');\n\nclass Auth0Client {\n  ...\n  unlinkAccounts(rootUserId, targetUserProvider, targetUserId){\n    return new Promise((resolve,reject) => {\n      var reqOpts = {\n        method: 'DELETE',\n        url: 'https://{yourDomain}/api/v2/users/' + rootUserId +\n            '/identities/' + targetUserProvider + '/' + targetUserId,\n        headers: {\n          'Authorization': 'Bearer ' + process.env.AUTH0_APIV2_TOKEN\n        }\n      };\n      request(reqOpts,(error, response, body) => {\n        if (error) {\n          return reject(error);\n        } else if (response.statusCode !== 200) {\n          return reject('Error unlinking accounts. Status: '+ response.statusCode + ' ' + JSON.stringify(body));\n        } else {\n          resolve(JSON.parse(body));\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = new Auth0Client();\n```\n\n## Learn more\n\n*   [Link User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts)\n*   [User Account Linking: Server-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)\n*   [User-Initiated Account Linking: Client-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation)",
    "title": "Unlink User Accounts",
    "description": "Learn how to use the Management API Unlink a User Account endpoint to unlink an identity from the target user account making it a separate user account again.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation",
    "markdown": "# User-Initiated Account Linking: Client-Side Implementation\n\nAuth0 supports the linking of user accounts from various identity providers. One way to implement this functionality is to enable the user to explicitly link accounts. In this scenario, the user authenticates through the UI of your Single Page Application (SPA) and can later use a link or button to link another account to the first one. When the user clicks on this link/button, your application makes a call so that when the user logs in with the second provider, the second account is linked with the first.\n\nWhen you initiate account linking, you can select which identity to use as the primary account and which to use as the secondary. This choice depends on which set of attributes you want to retain in the primary profile, as you will only retain the attributes from the primary account.\n\nCreate a React Sample Single Page Application with this project [on GitHub](https://github.com/auth0-samples/auth0-link-accounts-sample/tree/master/SPA).\n\nIn this project, open the `auth_config.json` file in your text editor and update the domain and `client_id` with your details.\n\nAdd `http://localhost:3000` in the “Allowed Callback URLs”, “Allowed Logout URLs”, “Allowed Web Origins” field.\n\n1.  Log the user in to your application.\n    \n    The user authenticates to your SPA using using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login), requesting an [Access Token for the Management API](https://auth0.com/docs/api/management/v2/get-access-tokens-for-spas).\n    \n    In the typical SPA login, the callback is handled client-side by the same page, and a JWT is received after successful authentication. To learn more, read the [Single-Page App Quickstart](https://auth0.com/docs/quickstart/spa).\n    \n2.  The user initiates account linking. Your SPA must provide a UI for the user to initiate a link to their other accounts. For example, your SPA could contain a user's settings page:\n    \n    When the user clicks on the **Link Account** button, your app redirects the user to the Universal Login page, when they log in with the connection they want to link to. After successful authentication, use the obtained token to link the accounts.\n    \n    You could also add a button for each connection (e.g. 'Link Facebook Account', 'Link Google Account') and redirect the user to `/authorize` with the `connection` parameter set (e.g. `/authorize?connection=facebook`).\n    \n    ![Example profile page with user account linking](https://images.ctfassets.net/cdy7uua7fh8z/4qxdXGBnlVRDaTkw2wv9WP/8792cff7c5fc21910ec12495828539da/account-linking-spa.png)\n3.  Link accounts by calling the Auth0 Management API's [Link a User Account endpoint](https://auth0.com/docs/api/v2#!/Users/post_identities).\n    \n4.  In the `linkAccount` function, call the Management API. Authenticate with the API using the primary JWT, which is the Access Token, and link using the primary user's ID and the secondary JWT, which is the secondary user's ID Token.\n    \n    ```\n    const linkAccount = async () => {\n      const accessToken = await auth0.getTokenSilently();\n      const { sub } = await auth0.getUser();\n      // authenticateUser should authenticate the user with the account to be linked\n      // See the Github sample for more details\n      const {\n        __raw: targetUserIdToken,\n        email_verified,\n        email,\n      } = await authenticateUser();\n      if (!email_verified) {\n        throw new Error(\n          `Account linking is only allowed to a verified account. Please verify your email ${email}.`\n        );\n      }\n      await fetch(`https://${config.domain}/api/v2/users/${sub}/identities`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${accessToken}`,\n        },\n        body: JSON.stringify({\n          link_with: targetUserIdToken,\n        }),\n      });\n    };\n    ```\n    \n\n#### Account Linking: Access Tokens vs. ID Tokens\n\nPreviously, in some cases, you could use ID Tokens to link and unlink user accounts. This functionality is being deprecated. You will have to use Access Tokens in all cases. The change in the unlinking of accounts is that you can no longer use an ID Token in the Authorization header. An Access Token must be used instead. The functionality is still available but not recommended and affected users are encouraged to migrate. See [Migration Guide: Account Linking with Access Tokens vs. ID Tokens](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/link-user-accounts-with-access-tokens-migration) for details.\n\n## Learn more\n\n*   [Link User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts)\n*   [Unlink User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/unlink-user-accounts)\n*   [User Account Linking: Server-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)",
    "title": "User-Initiated Account Linking: Client-Side Implementation",
    "description": "Learn how to provide a client-side UI that allows users to authenticate to their other accounts and link these to their primary account using a SPA.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation",
    "markdown": "# User Account Linking: Server-Side Implementation\n\n##### User Account Linking: Server-Side Implementation\n\nManage Users\n\nManage Access\n\nAuth0 supports the linking of user accounts from various identity providers. You can use server-side code to link accounts on a regular web application, engaging the user and asking them for permission before proceeding. Your code will authenticate users and search for and identify users using their email addresses. Your application will then prompt the user to link their accounts by authenticating with the target account's credentials, and later link the accounts.\n\nYou can find the full source of this sample application [on GitHub](https://github.com/auth0-samples/auth0-link-accounts-sample/tree/master/RegularWebApp).\n\n1.  Log the user into your application.\n    \n    The user authenticates to your application using [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login). To learn more, read the [Regular Web App Quickstart](https://auth0.com/docs/quickstart/webapp), asking for a token for the Auth0 Management API audience (audience=`https://{yourDomain}/api/v2/`).\n    \n2.  Search for users with identical email addresses.\n    \n    You can get the user profile and the list of users with the same verified email.\n    \n    ```\n    router.get(\"/\", async (req, res) => {\n      const { sub, email_verified } = req.openid.user;\n      //fetch user profile containing the user_metadata and app_metadata properties\n      try {\n        let getUsersWithSameVerifiedEmail = [];\n        const getUserProfile = auth0Client.getUser(sub);\n        if (email_verified)\n          // account linking is only offered verified email\n          getUsersWithSameVerifiedEmail = auth0Client.getUsersWithSameVerifiedEmail(\n            req.openid.user\n          );\n    \n        const [user, suggestedUsers] = await Promise.all([\n          getUserProfile,\n          getUsersWithSameVerifiedEmail,\n        ]);\n    \n        const flashError = clear(req);\n        res.render(\"user\", {\n          user,\n          suggestedUsers,\n          wrongAccountError: flashError && flashError === Errors.WrongAccount,\n        });\n      } catch (err) {\n        debug(\"GET /user[s] failed: %o\", err);\n        res.render(\"error\", err);\n      }\n    });\n    ```\n    \n    To get a list of all of the user records with the same email address, your application calls the Auth0 Management API's [Get Users By Email endpoint](https://auth0.com/docs/api/v2#!/users-by-email/get_users_by_email) using a [Management API Access Token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) with the `read:users` scope.\n    \n    ```\n    const request = require('request');\n    class Auth0Client {\n    ...\n    async getUsersWithSameVerifiedEmail({ sub, email }) {\n      return await this.request({\n        url: `${process.env.ISSUER_BASE_URL}/api/v2/users-by-email?email=${email}`,\n      });\n    }\n    ```\n    \n3.  Prompt the user to link accounts.\n    \n    1.  If Auth0 returns one or more records with matching email addresses, the user will see the list along with the following message prompting them to link the accounts.\n        \n    2.  If the user wants to link a given account, they can click **Link** next to the appropriate account.\n        \n        ![Example application with server-side account linking page](https://images.ctfassets.net/cdy7uua7fh8z/7unQjUtxTZUc4tRFOxhaP3/050fb853d2b3be37795ce88b8a60ffed/account-linking-webapp-small__1_.png)\n4.  When the user clicks **Link**, your application will ask the user to authenticate with the target account, and then perform account linking.\n    \n    The following code snippet shows how to verify and merge metadata:\n    \n    ```\n    async function accountLink(req, res, next) {\n    const {\n      linking: { targetUserId },\n    } = req.appSession;\n    const { sub: authenticatedTargetUserId } = req.openidTokens.claims();\n    if (authenticatedTargetUserId !== targetUserId) {\n      debug(\n        \"Skipping account linking as the authenticated user(%s)  is different than target linking user (%s)\",\n        authenticatedTargetUserId,\n        targetUserId\n      );\n      set(req, Errors.WrongAccount);\n      return next();\n    }\n    \n    debug(\n      \"User %s succesfully authenticated. Account linking with %s... \",\n      authenticatedTargetUserId,\n      targetUserId\n    );\n    const { id_token: targetIdToken } = req.openidTokens;\n    const { sub: primaryUserId } = req.appSession.claims;\n    \n    try {\n      await mergeMetadata(primaryUserId, authenticatedTargetUserId);\n      await auth0Client.linkAccounts(primaryUserId, targetIdToken);\n      debug(\"Accounts linked.\");\n    } catch (err) {\n      debug(\"Linking failed %o\", err);\n    } finally {\n      next();\n    }\n    }\n    ```\n    \n5.  Your application calls the Auth0 Management API's [Link a User Account endpoint](https://auth0.com/docs/api/v2#!/Users/post_identities) using a [Management API Access Token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens) with the `update:users` scope.\n    \n\n## Metadata merge example\n\nThe following example shows explicitly how the `user_metadata` and `app_metadata` from the secondary account gets merged into the primary account using the [Node.js Auth0 SDK for API V2](https://github.com/auth0/node-auth0).\n\n```\n/*\n * Recursively merges user_metadata and app_metadata from secondary into primary user.\n * Data of primary user takes preponderance.\n * Array fields are joined.\n */\nasync function mergeMetadata(primaryUserId, secondaryUserId) {\n  // load both users with metedata.\n  const [primaryUser, secondaryUser] = await Promise.all(\n    [primaryUserId, secondaryUserId].map((uid) => auth0Client.getUser(uid))\n  );\n\n  const customizerCallback = function (objectValue, sourceValue) {\n    if (_.isArray(objectValue)) {\n      return sourceValue.concat(objectValue);\n    }\n  };\n  const mergedUserMetadata = _.merge(\n    {},\n    secondaryUser.user_metadata,\n    primaryUser.user_metadata,\n    customizerCallback\n  );\n  const mergedAppMetadata = _.merge(\n    {},\n    secondaryUser.app_metadata,\n    primaryUser.app_metadata,\n    customizerCallback\n  );\n  await auth0Client.updateUser(primaryUserId, {\n    user_metadata: mergedUserMetadata,\n    app_metadata: mergedAppMetadata,\n  });\n}\n```\n\n## Learn more\n\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Troubleshoot Invalid Token Errors](https://auth0.com/docs/troubleshoot/basic-issues/invalid-token-errors)\n\nWas this article helpful?",
    "title": "User Account Linking: Server-Side Implementation",
    "description": "Describes how to link user accounts with a regular web app using server-side code using a sample scenario.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-account-linking",
    "markdown": "# User Account Linking\n\nAuth0 supports the linking of user accounts from various identity providers. This allows a user to authenticate from any of their accounts and still be recognized by your app and associated with the same user profile.\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nAuth0 treats all identities as separate by default. For example, if a user logs in first against the Auth0 database and then via Google or Facebook, these two attempts would appear to Auth0 as two separate users. You can implement functionality to enable a user to explicitly link accounts. In this scenario, the user would log in with an initial provider, perhaps Google. Your application would provide a link or button to enable them to link another account to the first one. The user would click on this link/button and your application would make a call so that when the user logs in with the second provider, the second account is linked with the first.\n\n## Advantages of linking accounts\n\n*   Allows users to log in with any identity provider without creating a separate profile for each\n    \n*   Allows registered users to use a new social or passwordless login but continue using their existing profile\n    \n*   Allows users that registered using a passwordless login to link to an account with a more complete profile\n    \n*   Allows your apps to retrieve user profile data stored in various connections\n    \n\n## Precautions\n\nInsecurely linking accounts can allow malicious actors to access legitimate user accounts. Please remain aware of the following:\n\nFor both manual and automatic account links, your tenant should request authentication for **both** accounts before linking occurs.\n\nIn addition, **every** manual account link should prompt the user to enter credentials.\n\n## How it works\n\nThe process of linking accounts merges two existing user profiles into a single one. When linking accounts, a **primary account** and a **secondary account** must be specified.\n\nIn the example below you can see how the resulting linked profile will be for the sample primary and secondary accounts.\n\n*   [Profile of primary account](#profile-primary)\n*   [Profile of secondary account](#profile-secondary)\n*   [Linked profile](#profile-linked)\n\n```\n{\n  \"email\": \"your0@email.com\",\n  \"email_verified\": true,\n  \"name\": \"John Doe\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n  \"picture\": \"https://lh3.googleusercontent..../photo.jpg\",\n  \"gender\": \"male\",\n  \"locale\": \"en\",\n  \"user_id\": \"google-oauth2|115015401343387192604\",\n  \"identities\": [\n    {\n      \"provider\": \"google-oauth2\",\n      \"user_id\": \"115015401343387192604\",\n      \"connection\": \"google-oauth2\",\n      \"isSocial\": true\n    }\n  ],\n  \"user_metadata\": {\n    \"color\": \"red\"\n  },\n  \"app_metadata\": {\n    \"roles\": [\n      \"Admin\"\n    ]\n  },\n  ...\n}\n```\n\n```\n{\n  \"phone_number\": \"+14258831929\",\n  \"phone_verified\": true,\n  \"name\": \"+14258831929\",\n  \"updated_at\": \"2015-10-08T18:35:18.102Z\",\n  \"user_id\": \"sms|560ebaeef609ee1adaa7c551\",\n  \"identities\": [\n    {\n      \"user_id\": \"560ebaeef609ee1adaa7c551\",\n      \"provider\": \"sms\",\n      \"connection\": \"sms\",\n      \"isSocial\": false\n    }\n  ],\n  \"user_metadata\": {\n    \"color\": \"blue\"\n  },\n  \"app_metadata\": {\n    \"roles\": [\n      \"AppAdmin\"\n    ]\n  },\n  ...\n}\n```\n\n```\n{\n  \"email\": \"your0@email.com\",\n  \"email_verified\": true,\n  \"name\": \"John Doe\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n  \"picture\": \"https://lh3.googleusercontent..../photo.jpg\",\n  \"gender\": \"male\",\n  \"locale\": \"en\",\n  \"user_id\": \"google-oauth2|115015401343387192604\",\n  \"identities\": [\n    {\n      \"provider\": \"google-oauth2\",\n      \"user_id\": \"115015401343387192604\",\n      \"connection\": \"google-oauth2\",\n      \"isSocial\": true\n    },\n    {\n      \"profileData\": {\n        \"phone_number\": \"+14258831929\",\n        \"phone_verified\": true,\n        \"name\": \"+14258831929\"\n      },\n      \"user_id\": \"560ebaeef609ee1adaa7c551\",\n      \"provider\": \"sms\",\n      \"connection\": \"sms\",\n      \"isSocial\": false\n    }\n  ],\n  \"user_metadata\": {\n    \"color\": \"red\"\n  },\n  \"app_metadata\": {\n    \"roles\": [\n      \"Admin\"\n    ]\n  },\n  ...\n}\n```\n\nNote that:\n\n*   The `user_id` and all other main profile properties continue to be those of the primary identity\n    \n*   The first identity in the `user.identities` array is the primary identity\n    \n*   The secondary account is now embedded in the `user.identities` array of the primary profile\n    \n*   The attributes of the secondary account are placed inside the `profileData` field of the corresponding identity inside the array\n    \n*   The `user_metadata` and `app_metadata` of the primary account have not changed\n    \n*   The `user_metadata` and `app_metadata` of the secondary account are discarded\n    \n*   There is no automatic merging of user profiles with associated identities\n    \n*   The secondary account is removed from the users list\n    \n*   If you delete the primary account, the secondary account is deleted as well\n    \n\n### Metadata merge\n\nMetadata is not automatically merged during account linking. If you want to merge it, you have to do it manually using the Manage API [`/users/patch_users_by_id`](https://auth0.com/docs/api/v2#!/Users/patch_users_by_id) endpoint.\n\nThe [Auth0 Node.js SDK for APIv2](https://github.com/auth0/node-auth0/) is also available.\n\nTo learn more, read [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata)\n\n## Scenarios\n\nThere are two different ways of implementing account linking:\n\n*   User-initiated account linking: allow your users to link their accounts using an admin screen in your app.\n    \n*   Suggested account linking: identify accounts with the same email address and prompt the user in your app to link them.\n    \n\n### User-initiated account linking\n\nTypically, account linking will be initiated by an authenticated user. Your app must provide the UI, such as a **Link accounts** button on the user's profile page.\n\nTo learn more about how to implement user-initiated account linking in a Single Page Application, read [Client-Side Account Linking](https://auth0.com/docs/users/references/link-accounts-client-side-scenario). To learn more about how to implement user-initiated account linking in a Regular Web Application, read [Server-Side Account Linking](https://auth0.com/docs/users/references/link-accounts-server-side-scenario).\n\n### Suggested account linking\n\nYou can find accounts with the same email, and prompt the users to link them. For example, a user can create an account with Google with the user@gmail.com, and then log in with Facebook, with an account linked to the same email.\n\nIf that occurs, you can show users the list of available accounts so they can link them, by first authenticating with the account they will be linking to.\n\nYou can also use the [Account Link Extension](https://auth0.com/docs/extensions/account-link) to achieve the same outcome.\n\n## Learn more\n\n*   [Link User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts)\n*   [Unlink User Accounts](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/unlink-user-accounts)\n*   [User-Initiated Account Linking: Client-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/user-initiated-account-linking-client-side-implementation)\n*   [User Account Linking: Server-Side Implementation](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/suggested-account-linking-server-side-implementation)",
    "title": "User Account Linking",
    "description": "Understand how user accounts can be linked in Auth0 from various identity providers.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/create-users",
    "markdown": "# Create Users\n\nYou can create a user using Auth0's Dashboard or via the [Auth0 Management API](https://auth0.com/docs/api/management/v2/users/post-users).\n\n1.  Go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users) and click **Create User**.\n    \n    ![Auth0 Dashboard List of Users](https://images.ctfassets.net/cdy7uua7fh8z/HCtwONFHssBzi7LSbhKNn/5c1c118902b235c0ffc3686e1c73022a/Screen_Shot_2021-05-18_at_9.45.13_PM.png)\n2.  Enter your user's **Email**, **Password**, and **Repeat Password**, then select the **Connection**.\n    \n    | Attribute | Description |\n    | --- | --- |\n    | Email | The user's email address. The maximum length is 64 characters for the user/local-part and 256 characters for the domain. The character limit for each level of a multi-level subdomain (separated by a period, such as example.example.com) is 63 characters. |\n    | Password | The user's password. There is no maximum limit for password length. |\n    | Repeat Password | Confirm password. |\n    | Connection | The database connection to use to authenticate the user. The dropdown lists all the configured database connections in your tenant. The connection you use must be associated with an application, otherwise you will receive an error message that says the connection is disabled. |\n    \n3.  Click **Create**. The user is created and you will be directed to the newly-created user's profile.\n    \n\nThe **User Details** page will show **pending** when a user is first created until they have logged in for the first time.\n\n## Learn more\n\n*   [Assign Permissions to Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-permissions-to-users)\n*   [Assign Roles to Users](https://auth0.com/docs/manage-users/access-control/configure-core-rbac/rbac-users/assign-roles-to-users)\n*   [Identify Users](https://auth0.com/docs/manage-users/user-accounts/identify-users)\n*   [Delete Users](https://auth0.com/docs/manage-users/user-accounts/delete-users)",
    "title": "Create Users",
    "description": "Describes how to create users in the Auth0 Dashboard.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/identify-users",
    "markdown": "# Identify Users\n\nThere are two recommended options to uniquely identify your users:\n\n1.  By the `user_id` property. This is guaranteed to be unique (within a tenant) per user (such as `{identity provider id}|{unique id in the provider}` or `facebook|1234567890`). A user may have the same `user_id` property across multiple Auth0 tenants, but consistency is not guaranteed.\n    \n2.  By a natural key, like the `email` property. In this case, it is recommended that you enable email verification and only use this option with providers that require that users verify their emails.\n    \n\nIf you use [custom databases](https://auth0.com/docs/connections/database/mysql), you must return a unique `user_id` property. If you have multiple custom databases and expect possible collisions between ids from different connections, you should use a prefix identifying the connection. For example:\n\n```\nfunction login (email, password, callback) {\n  var user = getUserFromDB(email);\n  var profile = {\n    user_id: 'MyConnection1|' + user.id,\n    email: user.email,\n    [...]\n  };\n  callback(null, profile);\n}\n```",
    "title": "Identify Users",
    "description": "Learn how to uniquely identify users.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/view-user-details",
    "markdown": "# View User Details\n\nThe [Users](https://manage.auth0.com/#/users) page lists the users who are associated with your apps. To open a particular user, click the user profile picture or name in the \"Name\" column. The User Details page will open and display information for that user.\n\nThe User Details page has links for five tabs:\n\n1.  Details\n    \n2.  Devices\n    \n3.  History\n    \n4.  Locations\n    \n5.  Raw JSON\n    \n\n## User Details: Details Tab\n\nThe Details tab contains three sections that provide a high-level overview of the information in the user's profile:\n\n*   **User Identity** provides at-a-glance details about the user, including their email address, associated Connections, and access rights.\n    \n*   **Metadata** displays the `app_metadata` and `user_metadata` information. You can edit these values.\n    \n*   **Identity Provider Attributes** displays the information retrieved from the authentication provider. Note that identity provider attributes are read-only.\n    \n\n## User Details: Devices Tab\n\nThe Devices tab lists the devices with which the user has requested authentication. Requesting authorization on a device links the device to the user's account.\n\nLogin details for the user are associated with the Refresh Token assigned to that device. To revoke the Refresh Token, click **Unlink** next to the device.\n\n## User Details: History Tab\n\nThe History tab displays a log of the user's account activity for the past 2 days.\n\nThe logs include information about:\n\n*   Events that have occurred\n    \n*   When the events occurred\n    \n*   The apps associated with the events\n    \n*   The identity provider used for authentication\n    \n*   The originating IP addresses for the events\n    \n*   Where the events originated\n    \n\n## User Details: Locations Tab\n\nThe Locations tab displays a map with pins indicating the user's location(s) when they logged in to the apps.\n\n## User Details: Raw JSON Tab\n\nThe Raw JSON tab displays all of the information contained on the user's profile in JSON format so you can quickly view all of the available information about the user.",
    "title": "View User Details",
    "description": "How to view users and their profile details.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/change-user-picture",
    "markdown": "# Change User Pictures\n\nAuth0 normalizes common profile properties in the User Profile, this includes the `name`, `picture` field and more. The picture field is populated by either the social provider profile picture or the Gravatar image associated with the user's email address.\n\nBy default, all database users will have a placeholder image with their initials. When you authenticate the user, this picture field is referred to as `user.picture`.\n\n![Dashboard User Management User Details Tab](https://images.ctfassets.net/cdy7uua7fh8z/6LjSQ5sf6OzmbtxYNLppJl/39dc86641cfdd57648b36750f1553dd3/dashboard-user-management-user-details.png)\n\n## Use the Management API\n\nThe `user.picture` attribute is not directly editable when provided by identity providers other than Auth0 such as Google, Facebook, or X. To edit this attribute, you must configure your connection sync with Auth0 so that user attributes will be updated from the identity provider only on user profile creation. To learn more, read [Configure Identity Provider Connection for User Profile Updates](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0). Root attributes will then be available to be edited individually or by bulk import using the Management API. To learn more, read [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports).\n\nAlternatively, you can use metadata to store the picture attribute for users. For example, if your app provides a way to upload profile pictures, once the picture is uploaded, you can set the URL to the picture in the `user.user_metadata.picture`:\n\n*   [cURL](#fe0579cb485b4b0587346c2dea471724_shell)\n*   [C#](#fe0579cb485b4b0587346c2dea471724_csharp)\n*   [Go](#fe0579cb485b4b0587346c2dea471724_go)\n*   [Java](#fe0579cb485b4b0587346c2dea471724_java)\n*   [Node.JS](#fe0579cb485b4b0587346c2dea471724_node)\n*   [Obj-C](#fe0579cb485b4b0587346c2dea471724_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/users/USER_ID' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"user_metadata\": {\"picture\": \"https://example.com/some-image.png\"}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/users/USER_ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"user_metadata\\\": {\\\"picture\\\": \\\"https://example.com/some-image.png\\\"}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/users/USER_ID\"\n\n\tpayload := strings.NewReader(\"{\\\"user_metadata\\\": {\\\"picture\\\": \\\"https://example.com/some-image.png\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/users/USER_ID\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"user_metadata\\\": {\\\"picture\\\": \\\"https://example.com/some-image.png\\\"}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/users/USER_ID',\n  headers: {\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {user_metadata: {picture: 'https://example.com/some-image.png'}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"user_metadata\": @{ @\"picture\": @\"https://example.com/some-image.png\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/users/USER_ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/users/USER_ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"user_metadata\\\": {\\\"picture\\\": \\\"https://example.com/some-image.png\\\"}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"user_metadata\\\": {\\\"picture\\\": \\\"https://example.com/some-image.png\\\"}}\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/users/USER_ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/users/USER_ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"user_metadata\\\": {\\\"picture\\\": \\\"https://example.com/some-image.png\\\"}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"user_metadata\": [\"picture\": \"https://example.com/some-image.png\"]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/users/USER_ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Use Actions\n\nTo ensure that the picture from the `user_metadata` is returned in the ID Token, we'll need to [create a new Action](https://auth0.com/docs/customize/actions/write-your-first-action) to check whether the `event.user.user_metadata.picture` attribute is present, and if so, replace the `user.picture` attribute with that value. This ensures that the picture from the `user_metadata` is returned in the `picture` claim of the ID Token.\n\n1.  Navigate to [Auth0 Dashboard > Actions > Library](https://manage.auth0.com/#/actions/library), and select **Build Custom**.\n    \n2.  Enter a descriptive **Name** for your Action (for example, `Change user pictures`), select the `Login / Post Login` trigger because you’ll be adding the Action to the Login flow, then select **Create**.\n    \n3.  Locate the Actions Code Editor, copy the following JavaScript code into it, and select **Save Draft** to save your changes:\n    \n    ```\n    exports.onExecutePostLogin = async (event, api) => {\n      const { picture } = event.user.user_metadata;\n      if (picture) {\n        // Return the persisted user_metadata.picture in the ID token\n        api.idToken.setCustomClaim(\"picture\", picture)\n      }\n    };\n    ```\n    \n4.  From the Actions Code Editor sidebar, select Test (play icon), then select **Run** to [test your code](https://auth0.com/docs/customize/actions/test-actions).\n    \n5.  When you’re ready for the Action to go live, select **Deploy**.\n    \n\nFinally, add the Action you created to the [Login Flow](https://manage.auth0.com/#/actions/flows/login/). To learn how to attach Actions to Flows, read the \"Attach the Action to a flow\" section in [Write Your First Action](https://auth0.com/docs/customize/actions/write-your-first-action).\n\n## Change default picture for all users\n\nTo change the default picture for all users who have not set a profile picture, you can use an Action. For example:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const DEFAULT_PROFILE_IMAGE = '{yourDefaultImageUrl}';\n  api.idToken.setCustomClaim(\"picture\", {defaultProfileImage});\n};\n```\n\nIn this Action, the custom picture is returned in the ID Token and overrides any `picture` property that may come from an external identity provider login, such as Google.\n\n## Limitations\n\nThe Auth0 data store is limited and to prevent your application's data from exceeding the limits, we recommend that you use an external database to store user pictures. This allows you to keep your Auth0 data store small and to use a more efficient external database to hold the additional data. To learn more, read [User Data Storage](https://auth0.com/docs/secure/security-guidance/data-security/user-data-storage).\n\n## Learn more\n\n*   [User Profile Structure](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure)\n*   [User Profile Root Attributes](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes)\n*   [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata)\n*   [Manage Metadata Using the Management API](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-api)\n*   [Manage Metadata with Rules](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-metadata-rules)\n*   [Bulk User Imports](https://auth0.com/docs/manage-users/user-migration/bulk-user-imports)",
    "title": "Change User Pictures",
    "description": "Learn how to use user metadata to change a user's picture field and how to change the default picture for all users.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/manage-user-access-to-applications",
    "markdown": "# Manage User Access to Applications\n\nAll users associated with a single Auth0 tenant are shared between the tenant's applications (and therefore have access to the applications).\n\n*   To keep users separate and restrict their access, we recommend that you [create an additional tenant](https://auth0.com/docs/get-started/auth0-overview/create-tenants/create-multiple-tenants) with applications you want groups of users to access.\n    \n\n*   To restrict users' access to certain applications, you can use [rules](https://auth0.com/docs/customize/rules).\n    \n    *   Inside a rule, the `context.clientName` and `context.clientID` variables are available to check which application the user is using for login.\n        \n    *   See [this rule for an example](https://github.com/auth0/rules/blob/aeaf93bc058408e260192d0941a688963449d6be/src/rules/simple-user-whitelist-for-app.js).\n        \n\n*   To restrict users from applications by configuring a new connection and only giving access to a specific application.\n    \n    *   Go to [Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social) and click on a connection.\n        \n    *   On the **Applications** tab, enable/disable applications.\n        \n\n*   To disable users' access to your applications, you can [block and unblock users](https://auth0.com/docs/manage-users/user-accounts/block-and-unblock-users) in the Dashboard.\n    \n\n## Learn more\n\n*   [Create Multiple Tenants](https://auth0.com/docs/get-started/auth0-overview/create-tenants/create-multiple-tenants)\n*   [Select from Multiple Connection Options](https://auth0.com/docs/libraries/lock/selecting-from-multiple-connection-options)\n*   [Set Up Multiple Environments](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments)",
    "title": "Manage User Access to Applications",
    "description": "Explains the basics of a user profile, how to create a user and view users and their profile details.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/block-and-unblock-users",
    "markdown": "# Block and Unblock Users\n\nYou can use the Dashboard to block or unblock a specific user's access to your applications. If a blocked user tries to log in to an application, they will be redirected from the application with the error message `user is blocked` in the URL. Blocking users does not expire. You must unblock the user to allow the user to have access to your applications again.\n\n## Block users\n\n1.  Go to the [Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n    \n    ![Auth0 Dashboard List of Users](https://images.ctfassets.net/cdy7uua7fh8z/HCtwONFHssBzi7LSbhKNn/5c1c118902b235c0ffc3686e1c73022a/Screen_Shot_2021-05-18_at_9.45.13_PM.png)\n2.  To the right of the user's name that you want to block, click **...** and choose **Block**. Alternatively, you can click the user's name and scroll to the bottom of the **Details** tab, next to **Block user**, click **Block**.\n    \n\n![Dashboard - User Management - Users - Danger Zone](https://images.ctfassets.net/cdy7uua7fh8z/bWZQONwa0bP9CSIymiaVI/cd20958f4543c8e84a5799c24a1c4010/dashboard-users-edit_view-details_danger-zone.png)\n\n## Unblock users\n\nTo unblock users, we provide multiple methods, which match the way in which the user was blocked. Users can be blocked in a few different ways:\n\n*   blocked automatically due to the user providing an excessive number of incorrect credentials\n    \n*   blocked through the Auth0 Dashboard by an administrator\n    \n*   blocked through the Management API by updating the user profile to set `blocked` to `false`\n    \n\n### Unblock a user who was automatically blocked\n\nWhen a user is blocked due to the user providing an excessive number of incorrect credentials, you can use Auth0's Management API to unblock them.\n\nUse the [Unblock by Identifier endpoint](https://auth0.com/docs/api/management/v2#!/User_Blocks/delete_user_blocks) to pass an identifier (username, phone number, or email):\n\n```\ncurl -X DELETE  https://{yourAuth0Tenant}.auth0.com/api/v2/user-blocks/john.doe%40gmail.com\n```\n\nOr use the [Updat](https://auth0.com/docs/api/management/v2#\\!/Users/patch_users_by_id)[e a User endpoint](https://auth0.com/docs/api/management/v2#\\!/Users/patch_users_by_id) to patch the `user_id`:\n\n```\ncurl -X PATCH -H \"Content-Type: application/json\" -d '{\"blocked\":false}' https://{yourAuth0Tenant}.auth0.com/api/v2/users/{user_id}\n```\n\n### Unblock a user who was blocked through the user profile\n\nWhen a user is blocked through their user profile using either the Management API or by an administrator using the Auth0 Dashboard, you can unblock them in one of two ways: by having an administrator unblock them through their user profile using the Auth0 Dashboard or by updating the `blocked` attribute in their user profile using the Management API.\n\n#### Using the Auth0 Dashboard\n\nTo unblock a user using the Auth0 Dashboard, an administrator should:\n\n1.  Go to the [Dashboard > User Management > Users](https://manage.auth0.com/#/users).\n    \n2.  To the right of the user's name you want to unblock, click **...** and choose **Unblock**. Alternatively, you can click a previously blocked user's name and scroll to the bottom of the **Details** tab, next to **Unblock user**, click **Unblock.**\n    \n\n#### Using the Management API\n\nTo unblock a user using the Management API, use the [Update a User endpoint](https://auth0.com/docs/api/management/v2#!/Users/patch_users_by_id) to set the `blocked` attribute to `false`:\n\n```\ncurl -X PATCH -H \"Content-Type: application/json\" -d '{\"blocked\":false}' https://{yourAuth0Tenant}.auth0.com/api/v2/users/{user_id}\n```\n\n## Learn more\n\n*   [Manage User Access to Applications](https://auth0.com/docs/manage-users/user-accounts/manage-user-access-to-applications)",
    "title": "Block and Unblock Users",
    "description": "Describes how to block and unblock users.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/delete-users",
    "markdown": "# Delete Users\n\n1.  Go to the [Dashboard > User Management - Users](https://manage.auth0.com/#/users).\n    \n    ![Auth0 Dashboard List of Users](https://images.ctfassets.net/cdy7uua7fh8z/HCtwONFHssBzi7LSbhKNn/5c1c118902b235c0ffc3686e1c73022a/Screen_Shot_2021-05-18_at_9.45.13_PM.png)\n2.  Click the name of the user you want to delete.\n    \n3.  On the **Details** tab, scroll to the bottom, next to **Delete user**, and click **Delete**.\n    \n    ![Dashboard - User Management - Users - Danger Zone](https://images.ctfassets.net/cdy7uua7fh8z/bWZQONwa0bP9CSIymiaVI/cd20958f4543c8e84a5799c24a1c4010/dashboard-users-edit_view-details_danger-zone.png)\n    \n    A popup will warn you that the action cannot be undone and prompt you to confirm that you want to delete the user. Click the **Yes, Delete It** button to confirm. This will permanently delete the user.\n    \n\nWas this article helpful?",
    "title": "Delete Users",
    "description": "Describes how to delete users.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/unlink-devices-from-users",
    "markdown": "# Unlink Devices from Users\n\nYou can unlink the devices assigned to a user using the Auth0 Dashboard. This revokes the refresh token for the selected device.\n\n1.  Go to [Dashboard > User Management > Users](https://manage.auth0.com/#/users) and click the name of the user.\n    \n    ![Auth0 Dashboard List of Users](https://images.ctfassets.net/cdy7uua7fh8z/HCtwONFHssBzi7LSbhKNn/5c1c118902b235c0ffc3686e1c73022a/Screen_Shot_2021-05-18_at_9.45.13_PM.png)\n2.  Click the **Devices** view, then click the trashcan icon next to the device you want to unlink, and confirm.\n    \n    ![Dashboard - Users & Roles - Users - Devices View](https://images.ctfassets.net/cdy7uua7fh8z/SvkfrGgmpTBLisUq0tViL/ba091efbcc897870d59810b84c753682/Screen_Shot_2021-05-18_at_9.59.16_PM.png)\n\n## Learn more\n\n*   [Configure Device User Code Settings](https://auth0.com/docs/get-started/tenant-settings/configure-device-user-code-settings)\n*   [Device Authorization Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)\n\nWas this article helpful?",
    "title": "Unlink Devices from Users",
    "description": "Describes how to unlink devices assigned to a user using the Auth0 Dashboard. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/deny-api-access",
    "markdown": "# Deny User Access to an API with Rules\n\nGo to [Dashboard > Auth0 Pipeline > Rules](https://manage.auth0.com/#/rules). You can set up [](https://auth0.com/docs/rules)[Rules](https://auth0.com/docs/customize/rules) for a number of different purposes, from user management to enriching user profiles. If you need to deny a user access to your API, you can create Roles with assigned scopes, then create a rule to remove scopes from the Access Token:\n\n```\n{\nfunction (user, context, callback) {\n  var permissions = user.permissions || [];\n  var requestedScopes = context.request.body.scope || context.request.query.scope;\n  var filteredScopes = requestedScopes.split(' ').filter( function(x) {\n      return x.indexOf(':') < 0;\n  });\n\n  var allScopes = filteredScopes.concat(permissions);\n  context.accessToken.scope = allScopes.join(' ');\n\n  callback(null, user, context);\n}\n```",
    "title": "Deny User Access to an API with Rules",
    "description": "Learn how to use Auth0's Authorization Extension to deny users access to an API using rules.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/get-user-information-on-unbounce-landing-pages",
    "markdown": "# Get User Information on Unbounce Landing Pages\n\n## Auth0 Configuration\n\n1.  Create an Auth0 account and navigate to the [dashboard](https://manage.auth0.com/#).\n    \n2.  Go to [Dashboard > Applications](https://manage.auth0.com/#/applications) and click **\\+ Create Application**. Pick the `Single-Page Application` option and go to **Settings**. Note the **Client ID** and **Domain**.\n    \n3.  Add the `callback URL` in both **Allowed Callback URLs** and **Allowed Origins (CORS)**. Make it your Unbounce page URL. For example: `http://unbouncepages.com/changeit`.\n    \n4.  Go to [Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social) and enable the social providers you want to support.\n    \n\n## Unbounce Configuration\n\n1.  Create a new UI element, like a button, that will trigger the login with the provider. Note the UI element's ID under **Properties > Element Metadata**.\n    \n2.  Add a new JavaScript to your Unbounce landing page, select `Before Body End Tag` under `Placement` and add this code. Also make sure to check jQuery as a dependency.\n    \n\n```\n<script src=\"https://cdn.auth0.com/js/auth0/9.11/auth0.min.js\"></script>\n<script type=\"application/javascript\">\n  var webAuth = new auth0.WebAuth({\n    domain:       '{yourDomain}',\n    clientID:     '{yourClientId}',\n    audience: 'https://{yourClientId}/userinfo'\n    redirectUri:  '{yourUnbouncePageUrl}', // e.g http://unbouncepages.com/changeit\n    scope: 'openid profile email',\n    responseType: 'token id_token',\n  });\n</script>\n```\n\nYou should use the Client ID and Domain of the application you just configured.\n\nNext, you need a way to pass the information coming from the social providers to Unbounce:\n\n1.  Creating a Form and add `Hidden fields` for each field. For example: the `name` and `email` fields.\n    \n2.  Return to the JavaScript editor at Unbounce.\n    \n3.  Add a click handler for each button to trigger the social authentication.\n    \n    1.  Replace the button ID you took note of previously and the [connection name](https://auth0.com/docs/authenticate/identity-providers/locate-the-connection-id). For example, for Google you would use `google-oauth2` and for LinkedIn, `linkedin`.\n        \n    2.  Make sure that you replace the IDs properly. Instead of `#name` and `#email` you should put the ID of the form fields in question (you can see them while editing the form, under `Field Name and ID`).\n        \n\n```\n$('#{buttonId}').bind('click', function() { \n  webAuth.authorize({\n    connection: '{yourConnectionName}'\n  });\n});\n\n// After authentication occurs, the parseHash method parses a URL hash fragment to extract the result of an Auth0 authentication response.\n\nwebAuth.parseHash({ hash: window.location.hash }, function(err, authResult) { \n  if (err) { \n    return console.log(err); \n  }\n\n  if (authResult != null && authResult.accessToken != null) {\n    webAuth.client.userInfo(authResult.accessToken, function(err, user) {\n      $('#name').val(user.name); \n      $('#email').val(user.email); \n    }); \n  } \n\n});\n```\n\nNow you will be able to see the information provided by the IdP in the `Leads` section of your Unbounce Admin Panel, after the user submits the form.",
    "title": "Get User Information on Unbounce Landing Pages",
    "description": "How to get user information with one-click social authentication on Unbounce landing pages.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions",
    "markdown": "# Redirect with Actions\n\nYou can use post-login Actions to redirect users before an authentication transaction is complete. This lets you implement custom authentication flows that require additional user interaction beyond the standard login form.\n\nRedirects are commonly used to do custom [Multi-factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) in Auth0, but they can also be used to:\n\n*   Allow for custom privacy policy acceptance, terms of service, and data disclosure forms.\n    \n*   Perform a one-time collection of additional required profile data securely.\n    \n*   Allow remote Active Directory users to change their password.\n    \n*   Require users to provide additional verification when logging in from unknown locations.\n    \n*   Gather more information about your users than they provided at initial signup.\n    \n\n## Overview\n\nAt a high level, a Redirect Action works in the following manner:\n\n1.  An Action issues a redirect to a URL.\n    \n2.  The Actions pipeline is suspended after that Action completes its execution.\n    \n3.  The user is redirected to the URL along with a `state` parameter.\n    \n4.  When the external flow has concluded, the external site redirects the user to a `/continue` endpoint along with the `state` parameter.\n    \n5.  The Actions pipeline is resumed on the same Action that invoked the redirect.\n    \n\n## Start a redirect\n\nCall the `api.redirect.sendUserTo()` function as follows:\n\n```\n/**\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  api.redirect.sendUserTo(\"https://my-app.exampleco.com\");\n};\n```\n\nActions will finish the execution of this Action, and then suspend the actions pipeline to send the user to the `https://my-app.exampleco.com`. In other words, any Actions that are bound to the post-login triggers that run after the Action invoking the redirect will not execute until the authentication flow has been resumed. If you are familiar with Redirect Rules, then note that this is a key difference between Redirect Actions and Redirect Rules.\n\nAfter the Action has finished executing, Auth0 redirects the user to the URL specified in the `api.redirect.sendUserTo()` function. Auth0 also passes a `state` parameter in that URL. For example: \n\n`https://my-app.exampleco.com/?state=abc123`\n\nYour redirect URL will need to extract the `state` parameter and send it back to Auth0 to resume the authentication transaction. State is an opaque value used to prevent [Cross-Site Request Forgery (CSRF) attacks](https://auth0.com/docs/secure/security-guidance/prevent-threats).\n\n## Resume the authentication flow\n\nAfter the redirect, resume authentication by redirecting the user to the `/continue` endpoint and including the `state` parameter you received in the URL. If you do not send the original state back to the `/continue` endpoint, Auth0 will lose the context of the login transaction and the user will not be able to log in due to an `invalid_request` error.\n\nFor example:\n\n`https://{yourAuth0Domain}/continue?state=THE_ORIGINAL_STATE`\n\nIn this example, `THE_ORIGINAL_STATE` is the value that Auth0 generated and sent to the redirect URL. For example, if your Action redirects to `https://my-app.exampleco.com/`, Auth0 would use a redirect URL similar to `https://my-app.exampleco.com/?state=abc123`, making `abc123` the `THE_ORIGINAL_STATE`. To resume the authentication transaction, you would redirect to:\n\n`https://{yourAuth0Domain}/continue?state=abc123`\n\nWhen a user has been redirected to the `/continue` endpoint, the Actions pipeline will resume on the same Action that invoked the redirect by calling the `onContinuePostLogin` function. For redirects to work properly, you must have a function with the following signature in the same Action that invoked the redirect:\n\n```\n/**\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  api.redirect.sendUserTo(\"https://my-app.exampleco.com\");\n};\n\n/**\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\n\nexports.onContinuePostLogin = async (event, api) => {\n}\n```\n\n## Pass data to the external site\n\nTo pass data to the external site, we recommend encoding that data in a signed [JWT](https://auth0.com/docs/secure/tokens/json-web-tokens) so that your application can be certain it was not tampered with during transit. With Actions, this can be done with the `api.redirect.encodeToken` and `api.redirect.sendUserTo` functions:\n\n```\n/**\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n  const YOUR_AUTH0_DOMAIN = event.secrets.YOUR_AUTH0_DOMAIN || event.request.hostname\n\n  // Craft a signed session token\n  const token = api.redirect.encodeToken({\n    secret: event.secrets.MY_REDIRECT_SECRET,\n    expiresInSeconds: 60, \n    payload: {\n      // Custom claims to be added to the token\n      email: event.user.email,\n      externalUserId: 1234,\n      continue_uri: `https://${YOUR_AUTH0_DOMAIN}/continue`\n    },\n  });\n\n  // Send the user to https://my-app.exampleco.com along\n  // with a `session_token` query string param including\n  // the email.\n  api.redirect.sendUserTo(\"https://my-app.exampleco.com\", {\n    query: { session_token: token }\n  });\n}\n```\n\nThe code above appends a `session_token` query string parameter to the URL used in the redirect (in addition to the `state` parameter that Auth0 adds automatically). This token will contain the following:\n\n| Token Element | Description |\n| --- | --- |\n| `sub` | Auth0 `user_id` of the user. |\n| `iss` | Hostname of your Auth0 tenant domain (e.g., `example.auth0.com`). |\n| `exp` | Expiration time (in seconds) specified with the `expiresInSeconds` parameter. Should be as short as possible to avoid re-use of the token. Defaults to 900 seconds (15 minutes). |\n| `ip` | IP Address of the originating authentication request. |\n| `email` | Custom claim with a value specified in the `payload.email` parameter. |\n| `externalUserId` | Custom claim with a value specified in the `payload.externalUserId` parameter. |\n| `signature` | Using the secret specified above, the token will be signed with HS256 algorithm. |\n\n### Ensure the token has not been tampered with\n\nThe external system should verify that this token has not been tampered with during transit. To accomplish this, the remote system should ensure the token’s signature is valid and, if applicable, that the session in the external system belongs to the same Auth0 user provided in the `sub` claim of the token.\n\n## Pass data back to Auth0\n\nAfter the user completes the custom flow in the external site, they should be redirected to the `/continue` endpoint. In some situations, you may want to pass data back to Auth0 to impact the authentication or authorization flow for that user (for example, if you are implementing CAPTCHA checks or custom MFA).\n\n### Use app metadata where possible\n\nIf possible, the remote system should use the [Auth0 Management API](https://auth0.com/docs/api/management/v2/) to store custom information as application metadata on the Auth0 user profile. When the Auth0 Action flow is resumed, this information will be available on the `event.user.app_metadata` object. This approach avoids passing sensitive information to Auth0 on the front channel.\n\n### Be selective when storing data on the Auth0 user profile\n\nAvoid storing too much data in the Auth0 profile. This data is intended to be used for authentication and authorization purposes. The metadata and search capabilities of Auth0 are not designed for scenarios that require high search or update frequency, such as marketing research. Your system is likely to run into scalability and performance issues if you use Auth0 for these kinds of purposes.\n\nIf your application requires access to substantive user data, the recommended approach is to store that data in an external system and store a foreign key (the user ID) in Auth0 so that back-end systems can fetch the data if needed.\n\n## Send data on the front channel\n\nPassing information back and forth in the front channel opens up surface area for bad actors to attack. If information must be sent on the front channel, then consider the following guidance:\n\n### Pass information back to the Action\n\nA signed session token should be used to send sensitive information back to Auth0. This token can be easily validated within an Action with the following code:\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onContinuePostLogin = async (event, api) => {\n  const payload = api.redirect.validateToken({\n    secret: event.secrets.PRECONFIGURED_SECRET,\n    tokenParameterName: 'my_token',\n  });\n\n  // use the data encoded in the token, such as: \n  api.idToken.setCustomClaim('color', payload.favorite_color);\n}\n```\n\nThe token will be validated to ensure that:\n\n*   The signature is valid.\n    \n*   The token is not expired.\n    \n*   The `state` claim within the token matches the `state` parameter used as part of the redirect.\n    \n\n| Token Element | Description |\n| --- | --- |\n| `sub` | Auth0 `user_id` of the user. |\n| `iss` | Application that is targeted for the redirect. |\n| `exp` | Should be as short as possible to avoid reuse of the token. |\n| `state` | state parameter sent to the remote site as part of the redirect. This must be included in the token to avoid replay attacks. |\n| `other` | Any other custom claims will be exposed as the `payload` in the code above. |\n| `signature` | Token should be signed with the HS256 algorithm. |\n\nTo avoid replay attacks, the token should be sent back to Auth0 by making a POST request to the `/continue` endpoint. The `tokenParameterName` option in the code allows you to specify the name of the field that contains your token.\n\n## Custom authentication methods\n\nAfter a successful redirect in the login pipeline, Actions can record custom authentication method events in the user's session. The `event.authentication.methods` array will contain an entry for the custom method for the duration of the user's browser session. Each entry in this array has a timestamp indicating when the authentication method was recorded.\n\nA custom action can trigger a redirect if the required custom method is not in the `event.authentication.methods` array or if the entry is too old.\n\nYou can use `api.redirect.sendUserTo()` to send the user to a page that implements a custom authentication method. You can use the `api.authentication.recordMethod()` in the `exports.onContinuePostLogin` handler to store a record of the completed method in the user's session.\n\nThe record stored in the `event.authentication.methods` array will have a `name` property matching the URL chosen in `api.authentication.recordMethod()`. The URL captured here allows you to search through the current transaction's completed authentication methods to determine if your custom method already completed.\n\nYour workflow may require the custom method to be re-performed periodically during the life of a user's session. For example, custom MFA scenarios may require user re-verification after a specified timeframe.\n\nThe example below compares the timestamp of an existing record to determine when to rerun the custom method:\n\n```\nconst CUSTOM_METHOD_URL = \"https://path.to.prompt\";\nconst PROMPT_TTL = 1000 * 60 * 60 * 24; // 24h\n\n/**\n * Handler that will be called during the execution of a PostLogin flow.\n *\n * @param {Event} event - Details about the user and the context in which\n * they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to\n * change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  // Search authentication method records for an entry representing our\n  // custom method.\n  const methodRecord = event.authentication?.methods.find((record) =>\n    validateCustomRecord(record, CUSTOM_METHOD_URL, PROMPT_TTL)\n  );\n\n  if (!methodRecord) {\n    const sessionToken = api.redirect.encodeToken({\n      payload: {\n        user_id: event.user.user_id,\n      },\n      secret: event.secrets.SESSION_TOKEN_SECRET,\n    });\n\n    // We didn't find a valid record, so we send the user to the\n    // URL that implements the custom method with the signed\n    // data we encoded in `sessionToken`.\n    api.redirect.sendUserTo(CUSTOM_METHOD_URL, {\n      query: { session_token: sessionToken },\n    });\n  }\n};\n\n/**\n * Handler that will be invoked when this action is resuming after an\n * external redirect. If your onExecutePostLogin function does not perform\n * a redirect, this function can be safely ignored.\n *\n * @param {Event} event - Details about the user and the context in which\n * they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to\n * change the behavior of the login.\n */\nexports.onContinuePostLogin = async (event, api) => {\n  const payload = api.redirect.validateToken({\n    secret: event.secrets.SESSION_TOKEN_SECRET,\n    tokenParameterName: \"session_token\",\n  });\n\n  if (!validateSessionToken(payload)) {\n    return api.access.deny(\"Unauthorized\");\n  }\n\n  // Record the completion of our custom authentication method.\n  // THIS NEW API IS ONLY AVAILABLE IN `onContinuePostLogin`.\n  api.authentication.recordMethod(CUSTOM_METHOD_URL);\n};\n\nfunction validateCustomRecord(record, url, ttl) {\n  if (!record) {\n    // No record means it isn't valid.\n    return false;\n  }\n\n  if (record.url !== url) {\n    // This isn't a record of our custom method.\n    return false;\n  }\n\n  // Timestamps are rendered as ISO8601 strings.\n  const timestamp = new Date(record.timestamp);\n\n  // The record is valid if it was recorded recently enough.\n  return timestamp.valueOf() >= Date.now() - ttl;\n}\n\nfunction validateSessionToken(payload) {\n  // Custom validation logic for the data returned by the\n  // custom method goes here.\n  return true;\n}\n```\n\nThe `api.authentication.recordMethod()` API is only available in the `exports.onContinuePostLogin` handler. This avoids potential login exploits by recording the custom method after completing the redirect.\n\n## Restrictions and limitations\n\nRedirect Actions won't work with:\n\n*   [Resource Owner endpoint](https://auth0.com/docs/api/authentication/reference#resource-owner)\n    \n*   [Password exchange](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow)\n    \n*   [Refresh Token exchange](https://auth0.com/docs/secure/tokens/refresh-tokens)\n    \n\n### Resource Owner endpoint\n\nIt is impossible to use redirect Actions when you are calling the Authentication API [Get Token](https://auth0.com/docs/api/authentication#resource-owner-password) endpoint for the Resource Owner Password flow. Since the user is not in a redirect flow to begin with, you can not redirect the user in an Action.\n\n### Flows where prompt=none\n\nSince the goal of `prompt=none` is to avoid any scenario where the user will be required to enter input, any redirection will result in an `error=interaction_required`.\n\nSince Actions run after an authentication session is created, you cannot use `prompt=none` if you have a redirect rule that is attempting to block access to tokens under certain conditions (for example, custom MFA, CAPTCHA with login, and so on).\n\nYou cannot create a redirect flow that blocks token access and bypasses the redirect Action if `prompt=none` because after a failed attempt, a user can simply call again with `prompt=none` and get tokens because their authentication session has been created even though Actions failed the first time.\n\n### Refresh tokens\n\nDue to the fact that using a refresh token requires a back-channel call to the Authentication API [Get Token](https://auth0.com/docs/api/authentication#refresh-token) endpoint, this will also fail if attempting to redirect.\n\nIt is difficult to securely verify that any restrictions on login were carried out. There is not a consistent session ID in the context that could be used to collect information associated with the session such as this user passed MFA challenges. Therefore, you cannot use `prompt=none` at all.\n\nAny time `api.redirect.sendUserTo()` is called in an Action, if `prompt=none` was passed, then the authorization fails with `error=interaction_required`, but since the user's session is created even if Actions fail, we can't trust that a user passed redirect challenges and therefore can't use `prompt=none` as a way to get tokens.\n\nIn this specific case, we recommend that you use refresh tokens exclusively, because you can ensure that a user passed challenges if those challenges are required to generate a refresh token.\n\n## Learn more\n\n*   [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata)",
    "title": "Redirect with Actions",
    "description": "Learn how to use post-login Actions to redirect users before an authentication transaction is complete.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/resend-verification-emails",
    "markdown": "# Resend Verification Emails\n\nIf you need to resend a verification email to a user, you can resend it using the Auth0 User Management Dashboard or the Auth0 Management API.\n\nYou can use the Auth0 Dashboard to resend a verification email to a user.\n\n1.  In the Dashboard, go to [**User Management > Users**](https://manage.auth0.com/#/users).\n    \n2.  Select the user.\n    \n3.  Select the **Actions** dropdown menu, and then select **Send Verification Email**.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/2KicMSDUsa6qlpUm3vHOKE/afd7e1bfca40b8b3c072cd2a11025497/user-email-resend.png)",
    "title": "Resend Verification Emails",
    "description": "Describes how to resend verification emails to users via the Auth0 Management Dashboard and the Auth0 Management API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/native-login",
    "markdown": "# Native Login\n\nNative mobile applications can use native or browser-based login flows.\n\nIn a **browser-based** login flow, the user is shown a web browser and redirected to the Auth0 login page for sign up or log in. For example: an iOS application opens a SafariViewController or an Android application opens a Custom Chrome Tab.\n\nWith a **native** login flow, the user signs up or enters their credentials directly into the app.\n\nRegardless of which option you choose, Auth0 supports either.\n\n## Browser-based login\n\n*   [Android Quickstart](https://auth0.com/docs/quickstart/native/android)\n    \n*   [iOS Swift Quickstart](https://auth0.com/docs/quickstart/native/ios-swift)\n    \n\n## Native embedded login\n\nIf you prefer to embed your own login pages within your native/mobile app, you can implement our login widget, Lock, directly into your app with:\n\n*   [Lock.swift](https://auth0.com/docs/libraries/lock-swift)\n    \n*   [Lock.Android](https://auth0.com/docs/libraries/lock-android)\n    \n\nExamples of native apps with embedded login:\n\n*   [Android](https://github.com/auth0-samples/auth0-android-sample/tree/embedded-login)\n    \n*   [iOS](https://github.com/auth0-samples/auth0-ios-swift-sample/tree/embedded-login/01-Embedded-Login)\n    \n\n### Passwordless\n\n[Embedded Passwordless Login in Native Applications](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/native)\n\n### Considerations\n\n*   Phishing/security concerns: an unauthorized party could decompile or intercept traffic to/from your application to get the Client ID and authentication URL. With this information the unauthorized party could create a rogue application, upload it to an application store, and use it to phish for usernames, passwords, and Access Tokens.\n    \n*   SSO: users have to enter their credentials for each application.\n    \n    *   Can implement SSO with native apps by storing refresh tokens on a shared keychain, but this is not compliant with the OAuth 2.0 specifications.\n        \n*   Takes more time to implement\n    \n*   No automatic improvements when Auth0 adds new features, have to update app code to take advantage of new features vs UL\n    \n*   Not compliant with OAuth 2.0 best practices\n    \n    *   [RFC 8252 OAuth 2.0 for Native Apps](https://tools.ietf.org/html/rfc8252): authorization requests from native apps should only be made through external user-agents, primarily the user's browser\n        \n\nYou can add functionality to your native app letting users authenticate with social identity providers natively, within the application:\n\nFacebook Login:\n\n*   [Add Facebook Login to Native Apps](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/facebook-native)\n    \n*   [Android - Facebook Login](https://auth0.com/docs/quickstart/native/android-facebook-login)\n    \n*   [iOS Swift - Facebook Login](https://auth0.com/docs/quickstart/native/ios-swift-facebook-login)\n    \n\nSign In with Apple:\n\n*   [iOS Swift - Sign In With Apple](https://auth0.com/docs/quickstart/native/ios-swift-siwa)\n    \n*   [Add Sign In with Apple to Native iOS Apps](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/apple-native)\n    \n\n### Rate limits\n\nLimits are only applied to requests related to the Native Social Login flows, which are identified based on the body of the requests with the following initial criteria:\n\n| Request Type | Body |\n| --- | --- |\n| `grant_type` | `urn:ietf:params:oauth:grant-type:token-exchange` |\n| `subject_token_type` | `http://auth0.com/oauth/token-type/apple-authz-code` |\n\n#### Limits for production tenants of paying customers\n\n| Endpoint | Path | Limited By | Rate Limit |\n| --- | --- | --- | --- |\n| Get Token | `/oauth/token` | Any native social login request | 50 per minute with bursts up to 500 requests |\n\n#### Limits for non-production tenants of paying customers and all tenants of free customers\n\n| Endpoint | Path | Limited By | Rate Limit |\n| --- | --- | --- | --- |\n| Get Token | `/oauth/token` | Native social login requests and IP | 30 per minute |",
    "title": "Native Login",
    "description": "Get started using Auth0. Implement authentication for any kind of application in minutes.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/universal-vs-embedded-login",
    "markdown": "# Centralized Universal Login vs. Embedded Login\n\nWhen you design the authentication experience for your application, you have to choose whether the login flow will use **universal** or **embedded** login.\n\n*   With **Universal Login**, when the users try to log in they are redirected to a central domain, through which authentication is performed, and then they are redirected back to the app. An example is G Suite. No matter which service you are trying to access (Gmail, Google calendar, Google docs, etc) if you are not logged in you are redirected to `https://accounts.google.com` and once you successfully log in you are redirected back to the calling app.\n    \n\n*   On the other hand, an **embedded login** flow does not redirect the user somewhere central. The login widget is served from the same page without redirecting the user to another domain. The credentials are then sent to the authentication provider for authentication. In a web app, this is a cross-origin request.\n    \n\n## Pros and cons\n\n| **Feature** | **Centralized** | **Embedded** |\n| --- | --- | --- |\n| **Single Sign-On** | If you are working with mobile apps, you cannot have SSO unless you use Universal Login. With web apps you can, although the most secure way is to use a central service so the cookies are from the same origin. | With embedded login, you'd have to collect the user credentials in an application served from one origin and then send them to another origin, which can present certain security vulnerabilities, including the possibility of a phishing attack. |\n| **Consistency and Maintenance** | Your Authorization Server (the domain that logs the users in) owns all the login pages which makes the management easier and the pages more consistent and secure. You could also use a single login page among your apps, a process that creates an impression that users are logging into a centralized system, rather than an individual app. | If you have more than one app, you must implement more than one login page. You will also have to maintain and manage these pages. Besides the extra effort it can also introduce inconsistencies which results in bad UX. Furthermore, with embedded login you would have to manage the dangers of cross-origin attack vectors. |\n| **Feature Management** | You can turn on and off features such as MFA, across all your apps, using the Dashboard. | Must be done for each application individually. |\n| **User Experience** | Redirected to another subdomain to log in. | Not redirected to another subdomain to login. |\n| **Mobile Apps and Security** | According to the [Best Current Practice for OAuth 2.0 for Native Apps Request For Comments](https://www.rfc-editor.org/rfc/rfc8252.txt), only external user agents (such as the browser) should be used by native applications for authentication flows. Using the browser to make native app authorization requests results in better security and it gives users the confidence that they are entering credentials in the right domain. It also enables use of the user's current authentication state, making Single Sign-on (SSO) possible. | Embedded user agents are deemed unsafe for third parties and should not be implemented. With native login a malicious app could try and phish users for username/password or tokens. Also, if your mobile apps use native login, then your users have to enter their credentials for each of your apps, hence SSO is not possible. |\n\n## Security risks\n\n*   Universal Login is more secure than embedded login. Authentication takes place over the same domain, eliminating cross-origin requests. Cross-origin authentication is inherently more dangerous. Collecting user credentials in an application served from one origin and then sending them to another origin can present certain security vulnerabilities. [](https://auth0.com/blog/all-you-need-to-know-about-the-google-docs-phishing-attack/)Phishing attacks are more likely, as are bucket brigade attacks. Universal Login does not send information between origins, thereby negating cross-origin concerns. To learn more, read [Prevent Common Cybersecurity Attacks](https://auth0.com/docs/secure/security-guidance/prevent-threats).\n    \n\n*   Embedded user agents are unsafe for third parties, including the authorization server itself. If an embedded login is used, the app has access to both the authorization grant and the user's authentication credentials. As a consequence, this data is left vulnerable to recording or malicious use. Even if the app is trusted, allowing it to access the authorization grant as well as the user's full credentials is unnecessary. This violates the principle of least privilege and increases the potential for attack.\n    \n\nGoogle no longer supports an embedded approach when implementing OAuth. Furthermore, according to the [Internet Engineering Task Force (IETF)](https://www.ietf.org/), authorization requests from native apps should only be made through external user agents, primarily the user's browser. Using the browser to make native app authorization requests results in better security. When embedded agents are used, the app has access to the OAuth authorization grant as well as the user's credentials, leaving this data vulnerable to recording or malicious use.\n\nAnother helpful resource is [Modernizing OAuth interactions in Native Apps for Better Usability and Security](https://developers.googleblog.com/2016/08/modernizing-oauth-interactions-in-native-apps.html) at [https://developers.googleblog.com](https://developers.googleblog.com/).\n\n## Universal Login with Auth0\n\nFor most situations, we recommend using a Universal Login strategy, where Auth0 will show a login page if authentication is required. You can customize your login page using the Dashboard.\n\nYou can use Auth0's Custom Domains to persist the same domain across the login page and the app. The redirect to the login page will be transparent to your users because the domain will not change. To learn more, read [Custom Domains](https://auth0.com/docs/customize/custom-domains).\n\nWhenever your app triggers an authentication request, the user will be redirected to the login page in order to authenticate. This will create a cookie. In future authentication requests, Auth0 will check for this cookie, and if it is present the user will not be redirected to the login page. They will see the page only when they need to actually log in. This is the easiest way to implement SSO.\n\nNote that if the incoming authentication request uses an external identity provider (for example, Facebook), the login page will not be displayed. Instead, Auth0 will direct the user to the identity provider's login page.\n\nYou can deploy your custom login page from an external repository, like [GitHub](https://marketplace.auth0.com/integrations/github-actions), [Bitbucket](https://marketplace.auth0.com/integrations/bitbucket-pipeline), [GitLab](https://marketplace.auth0.com/integrations/gitlab-pipeline), or [Microsoft Azure](https://marketplace.auth0.com/integrations/azure-pipeline).\n\nOur recommendation is to use Universal Login when you use Auth0. The first and foremost reason is security. Using Auth0 Universal Login instead of embedding login in your application provides seamless CSRF protection. This helps prevent third-party impersonation or the hijacking of sessions.\n\n## Embedded login with Auth0\n\nEmbedded logins in web apps with Auth0 use cross-origin authentication. (To learn more, read [Cross-Origin Authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication)). This uses third-party cookies to allow for secure authentication transactions across different origins. This does not apply to native applications since they use the standard OAuth 2.0 `/token` endpoint. To learn more about third-party cookies, read [Tracking and privacy: Third-party cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Third-party_cookies) at [https://developer.mozilla.org](https://developer.mozilla.org/).\n\nAuth0 does not recommend using cross-origin authentication, however, if you do, only when authenticating against a directory using a username and password. Social IdPs and enterprise federation use a different mechanism, redirecting via standard protocols like OpenID Connect (OIDC) and SAML. Additionally, cross-origin authentication is only applicable to embedded login on the web (using Lock or auth0.js). Native applications using embedded login make use of the standard OAuth 2.0 Token endpoint.\n\nIn addition, if you have not enabled custom domains, the end-user must have a browser that supports third-party cookies. Otherwise, in some browsers, cross-origin authentication will fail. This limitation applies to both traditional username/password database connections as well as passwordless database connections.\n\n## Learn more\n\n*   [Migrate from Embedded Login to Universal Login](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-embedded-login-to-universal-login)\n*   [Mobile Device Login Flow Best Practices](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow/mobile-device-login-flow-best-practices)\n*   [Prevent Common Cybersecurity Threats](https://auth0.com/docs/secure/security-guidance/prevent-threats)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)",
    "title": "Centralized Universal Login vs. Embedded Login",
    "description": "Describes the differences between centralized Universal Login and Embedded login.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/redirect-users-after-login",
    "markdown": "# Redirect Users\n\nYou can return users to specific pages (URLs) within your application after validating their ID Tokens (authentication). To see an example of how this works, try the [React: Login Quickstart](https://auth0.com/docs/quickstart/spa/react).\n\n## Redirect users to callback URLs on the AllowList\n\nBecause callback URLs can be manipulated by unauthorized parties, Auth0 recognizes only URLs on the AllowList set in the **Allowed Callback URLs** field of an [Application's Settings](https://manage.auth0.com/#/applications/{yourClientId}/settings) as valid. To return users to callback URLs on the AllowList, it is necessary for your application to know how to continue the user on their journey.\n\nThere are two methods for doing this:\n\n*   Using cookies and browser sessions\n    \n*   Using `state` parameters\n    \n\nDuring a user's authentication, the `redirect_uri` request parameter is used as a callback URL. This is where your application receives and processes the response from Auth0, and is often the URL to which users are redirected once the authentication is complete. To learn more about how the `redirect_uri` works, see [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth).\n\nYou can use a cookie or the browser session to store a return URL value. This is a simple solution to implement, however, it can cause issues in cases where a cookie does not persist. There are two separate user sessions initiated in this situation. Each serves a separate purpose and requires some consideration to achieve the desired user experience.\n\n*   **Auth0-provided SSO Session**: Auth0 provides a session for enabling [Single Sign On (SSO)](https://auth0.com/docs/authenticate/single-sign-on) to allow your user to maintain an authentication session without being prompted for credentials more than once. This session is maintained by Auth0 and referenced as a cookie bound to your tenant domain (or `CNAME`). There are two [tenant settings](https://auth0.com/docs/manage-users/sessions/configure-session-lifetime-settings) that determine the length of the Auth0 Session:\n    \n    *   The `idle_session_lifetime` is how long the session will remain alive without interaction.\n        \n    *   The `session_lifetime` is the maximum duration that the session is allowed to remain alive.\n        \n    \n    These settings apply to all applications within your tenant and should be configured to align with the security model that matches your use case.\n    \n*   **Application Session**: Your application must also maintain a concept of a session. Throughout the user session, your application may need to request additional tokens or renew expired ones. You should store these tokens in your application and reference them using an identifier passed back to the browser using a secure cookie.\n    \n\nOnce your user has authenticated with Auth0 it is up to your application to determine how long it persists this session.\n\n## Redirect users to other URLs\n\nSometimes, the callback URL is not necessarily where you want users redirected after authentication. For example, if a user intends to access a protected page in your application, and that action triggers the request to authenticate, you can store that URL to redirect the user back to their intended page after the authentication finishes. Store the desired URL using the following methods:\n\n*   [Redirect users with state parameters](https://auth0.com/docs/secure/attack-protection/state-parameters)\n    \n*   [Redirect users from within rules](https://auth0.com/docs/customize/rules/redirect-users)\n    \n\nChoose the option that works best for your application type and the type of [flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use) that you are using. Create the necessary logic in your application to retrieve the stored URL and redirect your users where you want them to go. The [Auth0 SDKs](https://auth0.com/docs/libraries) also include support for redirect URLs.\n\n## Learn more\n\n*   [Redirect Users with Alternative Logout](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout)\n*   [Understand How Progressive Profiling Works](https://auth0.com/docs/manage-users/user-accounts/user-profiles/progressive-profiling)",
    "title": "Redirect Users",
    "description": "Describes how to redirect users to URLs that have not been added to the AllowList.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/configure-silent-authentication",
    "markdown": "# Configure Silent Authentication\n\nThe [OpenID Connect protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol) supports a `prompt=none` parameter on the authentication request that allows applications to indicate that the authorization server must not display any user interaction (such as authentication, consent, or MFA). Auth0 will either return the requested response back to the application, or return an error if the user is not already authenticated or if some type of consent or prompt is required before proceeding.\n\nUse of the [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post) in SPAs presents security challenges requiring explicit mitigation strategies. You can use the [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) in conjunction with Silent Authentication to renew sessions in SPAs.\n\n## Initiate Silent Authentication requests\n\nTo initiate a silent authentication request, add the `prompt=none` parameter when you redirect a user to the [`/authorize` endpoint of Auth0's authentication API](https://auth0.com/docs/api/authentication#authorize-application). (The individual parameters on the authentication request will vary depending on the specific needs of your app.)\n\nFor example:\n\n```\nGET https://{yourDomain}/authorize\n    ?response_type=id_token token&\n    client_id=...&\n    redirect_uri=...&\n    state=...&\n    scope=openid...&\n    nonce=...&\n    audience=...&\n    response_mode=...&\n    prompt=none\n```\n\nThe `prompt=none` parameter causes Auth0 to immediately send a result to the specified `redirect_uri` (callback URL) using the specified `response_mode` with one of two possible responses: success or error.\n\n### Successful authentication responses\n\nIf the user was already logged in to Auth0 and no other interactive prompts are required, Auth0 will respond exactly as if the user had authenticated manually through the login page.\n\nFor example, when using the Implicit Flow, (`response_type=id_token token`, used for single-page applications), Auth0 will respond with the requested tokens:\n\n```\nGET {https://yourApp/callback}\n    #id_token=...&\n    access_token=...&\n    state=...&\n    expires_in=...\n```\n\nThis response is indistinguishable from a login performed directly without the `prompt=none` parameter.\n\n### Error responses\n\nIf the user was not logged in via Single Sign-on (SSO) or their SSO session had expired, Auth0 will redirect to the specified `redirect_uri` (callback URL) with an error:\n\n```\nGET https://your_callback_url/\n    #error=ERROR_CODE&\n    error_description=ERROR_DESCRIPTION&\n    state=...\n```\n\nThe possible values for `ERROR_CODE` are defined by the [OpenID Connect specification](https://openid.net/specs/openid-connect-core-1_0.html#AuthError):\n\n| Response | Description |\n| --- | --- |\n| `login_required` | The user was not logged in at Auth0, so silent authentication is not possible. This error can occur based on the way the tenant-level **Log In Session Management** settings are configured; specifically, it can occur after the time period set in the **Require log in after** setting. See [Configure Session Lifetime Settings](https://auth0.com/docs/dashboard/guides/tenants/configure-session-lifetime-settings) for details. |\n| `consent_required` | The user was logged in at Auth0, but needs to give consent to authorize the application. |\n| `interaction_required` | The user was logged in at Auth0 and has authorized the application, but needs to be redirected elsewhere before authentication can be completed; for example, when using a [redirect rule](https://auth0.com/docs/rules/redirect). |\n\nIf any of these errors are returned, the user must be redirected to the Auth0 login page without the `prompt=none` parameter to authenticate.\n\n## Renew expired tokens\n\nYou can make a silent authentication request to get new tokens as long as the user still has a valid session at Auth0. The [`checkSession` method from auth0.js](https://auth0.com/docs/libraries/auth0js) uses a silent token request in combination with `response_mode=web_message` for SPAs so that the request happens in a hidden iframe. With SPAs, Auth0.js handles the result processing (either the token or the error code) and passes the information through a callback function provided by the application. This results in no UX disruption (no page refresh or lost state).\n\n### Access Token expiration\n\nAccess Tokens are opaque to applications. This means that applications are unable to inspect the contents of Access Tokens to determine their expiration date.\n\nThere are two options to determine when an Access Token expires:\n\n*   Read the `expires_in` response parameter returned by Auth0.\n    \n*   Ignore expiration dates altogether. Instead, renew the Access Token if your API rejects a request from the application (such as with a 401).\n    \n\nIn the case of the [Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post), the `expires_in` parameter is returned by Auth0 as a hash parameter following a successful authentication. In the [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce), it is returned to the backend server when performing the authorization code exchange.\n\nThe `expires_in` parameter indicates how many seconds the Access Token will be valid for, and can be used to anticipate expiration of the Access Token.\n\n### Error response\n\nYou may receive the `timeout` error response which indicates that timeout during executing `web_message` communication has occurred. This error is typically associated with fallback to cross-origin authentication. To resolve, make sure to add all of the URLs from which you want to perform silent authentication in the **Allowed Web Origins** field for your Application using the Auth0 Dashboard.\n\n## Poll with checkSession()\n\nIn some multi-application scenarios, where Single Logout is desired (a user logging out of one application needs to be logged out of other applications), an application can be set up to periodically poll Auth0 using `checkSession()` to see if a session exists. If the session does not exist, you can then log the user out of the application. The same polling method can be used to implement silent authentication for a Single Sign-on (SSO) scenario.\n\nThe poll interval between checks to `checkSession()` should be at least 15 minutes between calls to avoid any issues in the future with rate limiting of this call.\n\n## Silent authentication with Multi-factor Authentication\n\nIn some scenarios, you may want to avoid prompting the user for [Multi-factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) each time they log in from the same browser. To do this, set up a rule so that MFA occurs only once per session. This is useful when performing silent authentication (`prompt=none`) to renew short-lived Access Tokens in a SPA during the duration of a user's session without having to rely on setting `allowRememberBrowser` to `true`.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  const authMethods = event.authentication?.methods || []\n\n  const completedMfa = !!authMethods.find((method) => method.name === 'mfa')\n\n  if (!completedMfa) {\n    api.multifactor.enable('any', { allowRememberBrowser: true })\n  }\n};\n```\n\nTo learn more, see [Change Authentication Request Frequency](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa).\n\n## Learn more\n\n*   [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation)\n*   [Configure Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/configure-refresh-token-rotation)\n*   [Troubleshoot Invalid Token Errors](https://auth0.com/docs/troubleshoot/basic-issues/invalid-token-errors)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
    "title": "Configure Silent Authentication",
    "description": "Learn how to keep users logged in to your application using silent authentication.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/max-age-reauthentication",
    "markdown": "# Force Reauthentication in OIDC\n\nThe `prompt=login` mechanism can be subverted by simply stripping the parameter as it passes through the user agent (browser) and is only good for providing a UX hint to the OpenID provider (OP) in cases when the relying party (RP) wants to display a link like:\n\n**“Hi Josh. Not you? Click here.”**\n\nHowever, you should not rely on it to validate that a fresh authentication took place. To mitigate this, the client must validate that re-authentication has taken place using the `auth_time` claim if re-authentication is why `max_age` was requested. This claim will be included automatically in the ID token when `prompt-login` or `max_age=0` parameters are given in the authentication request.\n\nYou need to pass the `max_age` parameter to the Authorization API [`/authorize` endpoint](https://auth0.com/docs/api/authentication). If you use [Auth0.js](https://auth0.com/docs/libraries/auth0js) or [Lock](https://auth0.com/docs/libraries/lock/lock-authentication-parameters), you can set the parameter in the appropriate options of the library.\n\nHow you implement re-authentication depends on your specific use-case. Make a distinction between simple re-authentication for sensitive operations vs. [step-up](https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication) (i.e. multi-factor authentication) for sensitive operations. Both are valid security measures. The former requires the end user to re-enter their password, whereas the latter requires them to use a pre-configured means of multifactor authentication as well.\n\n## Limitations of prompt=login parameters\n\nThe [OIDC spec](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) defines the `prompt=login` parameter that can be used to trigger re-authentication UI (usually a login prompt):\n\nHowever, there is an issue with using this parameter to ensure re-authentication: **the RP has no way to validate that a re-authentication action has taken place**. Let's inspect the traffic to understand why. The flow for an authentication request from the RP is as follows:\n\n```\nhttps://mydomain.auth0.com/authorize?\nclient_id=abcd1234\n&redirect_uri= https://mydomain.com/callback \n&scope=openid profile\n&response_type=id_token\n&prompt=login\n```\n\nUpon successful authentication by the AS, the RP will have an ID token delivered:\n\n```\n{\n  \"nickname\": \"user\",\n  \"name\": \"user@mydomain.auth0.com\",\n  \"updated_at\": \"2019-04-01T14:43:03.445Z\",\n  \"iss\": \"https://jcain0.auth0.com/\",\n  \"sub\": \"auth0|l33t\",\n  \"aud\": \"abcd1234\",\n  \"iat\": 1554129793,\n  \"exp\": 1554165793\n}\n```\n\nThe trusted identity document returned by the AS **has no claims that validate when the last login occurred**. This becomes a problem when the initial authorization request comes in the form of a 302 redirect through the end user’s browser. If a malicious actor wants to skip the re-authentication step requested by the RP, they simply have to remove the `prompt=login` parameter and the RP doesn't know the difference in the fields contained in the ID token.\n\nHere’s a diagram of a simplified implicit flow using the `prompt=login` parameter:\n\n![Force Re-Authentication OIDC Implicit Flow](https://images.ctfassets.net/cdy7uua7fh8z/7lhntbIKJ25JqQ1M9uB6rJ/26163ab92ac6e289e1185bcb50db2a72/simplified-implicit-flow-with-prompt-login.png)\n\nNote that all the end-user has to do is remove the `prompt=login` parameter and the re-authentication step can be skipped:\n\n![Simplified Implicit Flow Remove prompt=login](https://images.ctfassets.net/cdy7uua7fh8z/3hye4mnbcsny7oT0L2kxeq/029a66b8f4f98ee56c5d45a2da617e88/simplified-implicit-flow-remove-prompt.png)\n\nThe token(s) returned from the first flow above will be identical to the token(s) returned from the second flow. The RP has no specification-defined way of verifying that re-authentication has taken place, and therefore cannot trust that a `prompt=login` has actually yielded a re-authentication.\n\n## max\\_age authentication request parameter\n\nUnlike `prompt=login`, the `max_age` authentication request parameter provides a mechanism whereby RPs can positively confirm that re-authentication has taken place within a given time interval. The [OIDC spec](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) states:\n\nThe last sentence in the definition is the most important part. When `max_age` is requested by the RP, an `auth_time` claim must be present in the RP. This means that `max_age` can be used in one of two ways:\n\n*   **To enforce a minimum session freshness**: If an app has a requirement that users must re-authenticate once per day, this can be enforced in the context of a much longer SSO session by providing `max_age` with a value. These are defined in seconds.\n    \n*   **To force an immediate re-authentication**: If an app requires that a user re-authenticate prior to access, provide a value of 0 for the `max_age` parameter and the AS will force a fresh login.\n    \n\nThis requirement is described as follows:\n\n![OIDC re-authentication max_age flow](https://images.ctfassets.net/cdy7uua7fh8z/2IHX6TjuCEcMrPZxoHkC41/11a32321789feee0eac6e71e9c64b307/max-age-flow.png)\n\nNote that the RP receives a token with the proper amount of information to validate whether or not re-authentication has taken place. The RP can now consult the `auth_time` claim in the ID token to determine whether or not the `max_age` parameter it requested was fulfilled. In this way, the `max_age=0` parameter is impervious to the same kind of client tampering that could subvert the `prompt=login` parameter.\n\n## Use auth\\_time claims\n\nWe've established that the OIDC spec provides the `max_age` parameter as a way to positively confirm a re-authentication has taken place, but `prompt=login` does not. This does not present very secure options if you want to force a re-authentication:\n\n*   **prompt=login**: Only include the `prompt` parameter and not validate that the AS actually re-authenticated.\n    \n*   **prompt=login & max\\_age=999999**: Include an arbitrary `max_age` such that an `auth_time` claim is present. You can validate a re-authentication took place, but the parameters get messy.\n    \n*   **max\\_age=0**: Effectively force a login prompt using only the `max_age` parameter. Note that a recent spec update further clarified this parameter, stating it is effectively the same as `prompt=login`. This one is not feasible since it blends what should be a UX parameter with a session maintenance parameter.\n    \n\nInstead, Auth0 has made a choice to send the `auth_time` claim in the ID token when responding to a `prompt=login` request parameter. This means that you have the option use `prompt=login` AND validate that a re-authentication took place.\n\n### auth\\_time validation example\n\nThe following example uses the [passport-auth0-openidconnect](https://github.com/auth0/passport-auth0-openidconnect) module to demonstrate how to validate re-authentication. The first (and simplest) way is to add the `max_age=0` option to the `Auth0OidcStrategy`:\n\n```\nvar strategy = new Auth0OidcStrategy(\n  {\n    domain: process.env.AUTH0_DOMAIN,\n    clientID: process.env.AUTH0_CLIENT_ID,\n    clientSecret: process.env.AUTH0_CLIENT_SECRET,\n    callbackURL: process.env.AUTH0_CALLBACK_URL || 'http://localhost:5000/callback',\n    max_age: 0\n  },\n  function(req, issuer, audience, profile, accessToken, refreshToken, params, cb) {\n    // No extra validation required!\n    return cb(null, profile);\n  });\n```\n\nNotice that no further validation steps are required as the strategy already handles validation of the `max_age` parameter:\n\n```\n// https://openid.net/specs/openid-connect-basic-1_0.html#IDTokenValidation - check 8.\nif (meta.params.max_age && (!jwtClaims.auth_time || ((meta.timestamp - meta.params.max_age) > jwtClaims.auth_time))) {\n  return self.error(new Error('auth_time in id_token not included or too old'));\n}\n```\n\nYou can also use `prompt=login` in the same context, but since the standard does not require an `auth_time` to accompany the ID token response, you must handle the validation manually. So, the strategy constructor would be:\n\n```\nvar strategy = new Auth0OidcStrategy(\n  {\n    domain: process.env.AUTH0_DOMAIN,\n    clientID: process.env.AUTH0_CLIENT_ID,\n    clientSecret: process.env.AUTH0_CLIENT_SECRET,\n    callbackURL: process.env.AUTH0_CALLBACK_URL || 'http://localhost:5000/callback',\n    prompt: 'login'\n  },\n  function(req, issuer, audience, profile, accessToken, refreshToken, params, cb) {\n    const tenSecondsAgo = (Date.now() / 1000) - 10;\n    if (isNaN(profile.auth_time) || profile.auth_time < tenSecondsAgo) {\n      return cb('prompt=login requested, but auth_time is greater than 10 seconds old', null);\n    }\n\n    return cb(null, profile);\n  });\n```\n\nUnlike `max_age=0`, the client must manually perform validation on the `auth_time` parameter. To learn more, read [Use auth\\_time claims](https://auth0.com/docs/authenticate/login/max-age-reauthentication#use-auth_time-claims).\n\n## Known issues\n\nAuth0 can only guarantee that an exchange took place with the upstream identity provider. This may be through the user actually signing in to a third-party identity provider or perhaps the user already had a session and didn't have to sign in again. Either way, Auth0’s exchange with the upstream identity provider will result in an updated `auth_time`.\n\nForcing re-authentication within the upstream identity provider is not something Auth0 supports because not all providers support this.\n\nThe diagram below presents an example flow for a user who chooses to reauthenticate with a federated connection:\n\n![Federated connections do not force re-authentication diagram](https://images.ctfassets.net/cdy7uua7fh8z/8o7GZWQo6LKRTwuYC6dDS/119eeb33dcafcdc5e8d992f284fd5134/federated-connection-flow.png)\n\nThis method assumes you use [database connections](https://auth0.com/docs/authenticate/database-connections). External identity providers may or may not support forcing re-authentication. Using `prompt=login` or `prompt=consent` is generally a way to indicate an external (social) identity provider to reauthenticate a user, but Auth0 cannot enforce this.\n\n## Learn more\n\n*   [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post)\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)",
    "title": "Force Reauthentication in OIDC",
    "description": "Describes how to use the max_age authentication request parameter as a mechanism whereby relying parties can positively confirm that re-authentication has taken place within a given time interval.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/embedded-login",
    "markdown": "# Embedded Login\n\nEmbedded Login allows your users to log directly into your application and transmit their credentials to the Auth0 server for authentication. We do not recommend using Embedded Login. To learn more, read [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login).\n\nIf you decide to use Embedded Login, you must [configure your application for Cross-Origin Resource Sharing](https://auth0.com/docs/get-started/applications/set-up-cors) and should [configure a custom domain](https://auth0.com/docs/customize/custom-domains). You can then implement the [Lock SDK](https://auth0.com/docs/libraries/lock) or [Auth0.js SDK](https://auth0.com/docs/libraries/auth0js) within your application, or call the [Auth0 Authentication API](https://auth0.com/docs/api/authentication) directly.\n\nAuth0 supports Embedded Login with Passwordless connections for multiple application types:\n\n*   [Embedded Passwordless Login in Native Applications](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/native)\n    \n*   [Embedded Passwordless Login in Regular Web Applications](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/webapps)\n    \n*   [Embedded Passwordless Authentication for Single-Page Apps](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/spa)\n    \n\n## Learn more\n\n*   [Lock for Web](https://auth0.com/docs/libraries/lock)\n*   [Auth0.js v9 Reference](https://auth0.com/docs/libraries/auth0js)\n*   [Cross-Origin Authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication)",
    "title": "Embedded Login",
    "description": "Describes Auth0 Embedded Login used to log users directly into your application, transmitting credentials to the Auth0 server.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/logout",
    "markdown": "# Logout\n\n#### Overview\n\nKey Concepts\n\n*   Review different session layers.\n    \n*   Learn how to redirect users after logout.\n    \n\nYou can log a user out of the Auth0 session and (optionally) from the identity provider (IdP) session. When you're implementing the logout functionality, there are typically three-session layers you need to consider:\n\n1.  **Application Session Layer**: The first layer is the session inside your application. Though your application uses Auth0 to authenticate users, you'll still need to track that the user has logged in to your application. In a regular web application, you achieve this by storing information inside a cookie. [Log users out of your applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications) by clearing their sessions. You should handle the application session in your application.\n    \n2.  **Auth0 Session Layer**: Auth0 also maintains a session for the user and stores their information inside a cookie. The next time a user is redirected to the Auth0 Lock screen, the user's information will be remembered. [Log users out of Auth0](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0) by clearing the Single Sign-on (SSO) cookie.\n    \n3.  **Identity Provider Session Layer**: The last session layer is the identity provider layer (for example, Facebook or Google). When users attempt to sign in with any of these providers and they are already signed into the provider, they will not be prompted again to sign in. The users may be asked to give permission to share their information with Auth0 and, in turn, your application. It is not necessary to log the users out of this session layer, but you can force the logout. (For more information, see [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps) and [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps).)\n    \n\n## Redirect users after logout\n\nAfter users log out, you can [redirect users](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout) to a specific URL. You need to register the redirect URL in your tenant or application settings. Auth0 only redirects to URLs from the allow list after logout. If you need different redirects for each application, you can add the URLs to your allow list in your application settings.\n\n## Learn more\n\n*   [Log Users Out of Applications](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-applications)\n*   [Log Users Out of Auth0 with OIDC Endpoint](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-auth0)\n*   [Log Users Out of Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-idps)\n*   [Log Users Out of SAML Identity Providers](https://auth0.com/docs/authenticate/login/logout/log-users-out-of-saml-idps)\n*   [Redirect Users with Alternative Logout](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout)\n*   [Check Login and Logout Issues](https://auth0.com/docs/troubleshoot/authentication-issues/check-login-and-logout-issues)",
    "title": "Logout",
    "description": "Describes how logout works with Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/custom-domains/auth0-managed-certificates",
    "markdown": "# Configure Custom Domains with Auth0-Managed Certificates\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nIf you want Auth0 to manage the certificates for your custom domain, you only need to add a CNAME record on the domain. Auth0 validates the record and then generates the certificate on Auth0 servers. These certificates are renewed automatically every three months. You can configure this easily, and you won't have to maintain the certificates yourself.\n\nTo set up your custom domain using Auth0-managed certificates, you must provide your domain name to Auth0 and verify that you own that domain. Once verified, you will need to configure your Auth0 features to start using your custom domain.\n\n## Provide your domain name to Auth0\n\n1.  Go to [Dashboard > Settings > Custom Domains](https://manage.auth0.com/#/tenant/custom_domains) or [Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/custom_domains). Enter your custom domain in the provided box, and select **Auth0-managed certificates.**\n    \n    ![Dashboard Settings Custom Domains Tab Certificate Type Auth0-Managed Certificates](https://images.ctfassets.net/cdy7uua7fh8z/7l8DLGTSWM7Kgj6C9NV74R/754645982613689b962b04d202b27d44/dashboard-settings-custom-domains-auth0-managed-certificates.png)\n2.  Click **Add Domain**. You can only add one domain per tenant even though the **Add Domain** button still appears after you add a domain.\n    \n\n## Verify ownership\n\nBefore you can use the domain with Auth0, you'll need to verify that you own it.\n\n1.  Go to [Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/branding/custom_domains) and add the CNAME verification record listed in the Dashboard to your domain's DNS record.\n    \n    ![Auth0 Branding Custom Domains Auth0-Managed Certificate Verify Domain](https://images.ctfassets.net/cdy7uua7fh8z/3dz8ii70nm0a5amS0PNJ5K/9590026beb0d6f7bd0046d964ab25c89/dashboard-branding-custom_domains-auth0-managed-verify.png)\n2.  Click **Verify** to proceed. It may take a few minutes before Auth0 is able to verify your CNAME record, depending on your DNS settings. If Auth0 was able to verify your domain name, you'll see a confirmation window. This means the verification process is complete. Within 1 to 2 minutes, your custom domain should be ready to use.\n    \n\n## Add CNAME verification record to DNS record\n\nOnce added, the CNAME record must be present at all times to avoid issues during certificate renewal.\n\nIf you need to enable CNAME flattening for all subdomains managed by Cloudfare and also configure a specific subdomain to be an Auth0 custom domain, consider delegating the subdomain for Auth0 to another DNS provider. To learn more, read [Delegating Subdomains Outside of Cloudflare](https://support.cloudflare.com/hc/en-us/articles/360021357131-Delegating-Subdomains-Outside-of-Cloudflare) in the Cloudflare documentation. This will enable you to use CNAME flattening for all subdomains except the one used for Auth0.\n\nThe following steps may vary for your domain host provider.\n\n1.  Log in to your domain management service.\n    \n2.  Create a new record.\n    \n    | Parameter | Value |\n    | --- | --- |\n    | **Record type** | **CNAME** |\n    | **Name** | Enter your custom domain name (such as **login.northwind.com**). |\n    | **Time to Live (TTL)** | Use default value. |\n    | **Value** | Paste in the **CNAME** value provided by the Auth0 Dashboard for your domain's DNS record. |\n    \n3.  When done, save your record.\n    \n\nIf Auth0 was able to verify your domain name, you'll see a confirmation window. This means the verification process is complete. Within 1 to 2 minutes, your custom domain should be ready to use.\n\nIf you are unable to complete the verification process, wait at least 4 hours before repeating these steps. To avoid any interruptions to your service, do not recreate the custom domain when reverifying. For troubleshooting guidelines, see [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains).\n\n## Additional steps for specific Auth0 features\n\nThere are additional configuration steps you must complete depending on which Auth0 features you are using. To learn more, see [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains).\n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [TLS (SSL) Versions and Ciphers](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [Configure Custom Domains with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates)",
    "title": "Configure Custom Domains with Auth0-Managed Certificates",
    "description": "Learn how to configure custom domains where Auth0 manages the TLS (SSL) certificates.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/oidc-conformant-authentication",
    "markdown": "# Adopt OIDC-Conformant Authentication\n\nAuth0 is a [certified OpenID Connect (OIDC) provider](http://openid.net/certification/). As part of Auth0’s efforts to improve security and standards-based interoperability, we roll out new features exclusively on authentication flows that strictly conform to [OIDC specifications](http://openid.net/specs/openid-connect-core-1_0.html).\n\nWe will explain the differences between the OIDC-conformant and legacy pipelines and provide suggestions on how to adapt your existing applications. If you are a developer and/or IT administrator who manages Auth0 integrations in your applications using the [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth). This information is not applicable if you are using SAML or WS-Federation. All authentication flows are described through HTTP requests rather than in the context of any particular language or library implementation.\n\nAll new features target only the OIDC-conformant pipeline, and all legacy Auth0 SDK versions are deprecated, do not receive updates for new features or non-critical security issues, and will eventually be discontinued. In addition, all documentation, libraries, and examples outside of this guide apply to only the OIDC-conformant pipeline. Because of this, we strongly recommend adopting the OIDC-conformant pipeline even if you do not need to leverage any new features or functionality in the immediate future.\n\n## Apply the OIDC-conformant pipeline\n\nDepending on the age of your tenant, you may have different options for applying the OIDC-conformant pipeline.\n\n### New tenants\n\nIf you create a new tenant using the Auth0 Dashboard, the OIDC-conformant pipeline is used by default. This has been a default setting for the Dashboard since early 2019.\n\n### Older tenants\n\nIf you want to force all changes outlined in this guide at the same time for a given application so you can encounter all breaking changes during configuration rather than run time, you must:\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select the desired application.\n    \n2.  Scroll to **Advanced Settings** and go to the **OAuth** tab.\n    \n3.  Enable the **OIDC Conformant** toggle switch and click **Save Changes**.\n    \n\n![Auth0 Dashboard Applications Advanced Settings OAuth Tab](https://images.ctfassets.net/cdy7uua7fh8z/4fD4877KHKW8HWRVwb0YX1/185ebefd15573660ade0c0cce65438a9/dashboard-applications-edit_view-settings_advanced_oauth.png)\n\nIf you want to use the OIDC-conformant pipeline on a per-authentication-request basis and your application needs to call an API with a JWT access token, initiate the request to the [`/social`](https://auth0.com/docs/api/authentication#social) endpoint with an `audience` parameter.\n\nIf you want to use the OIDC-conformant pipeline on a per-authentication-request basis and your application doesn't need to call an API, use the following `audience` parameter:\n\n```\nhttps://{yourDomain}/userinfo\n```\n\n## Differences\n\nEnabling the OIDC-conformant pipeline results in the following changes to the legacy pipeline.\n\n### APIs\n\nApplications and APIs (resources) should be defined as separate Auth0 entities. To learn more, read [OIDC-Conformant Adoption: APIs](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-apis).\n\n### Access tokens\n\n*   APIs should be secured with access tokens instead of ID tokens. To learn more about the differences, read [Tokens](https://auth0.com/docs/secure/tokens).\n    \n*   A defined set of standard claims about users can be returned in ID Tokens or in the response from `/userinfo`.\n    \n*   Custom claims must conform to a named format. To learn more, read [Create Namespaced Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n    \n*   Responses from `/userinfo` will conform to the OIDC specification, similar to the contents of ID tokens\n    \n*   Scopes can be used to request either standard claims or custom API permissions.\n    \n\nTo learn more, read [OIDC-Conformant Adoptions: Access Tokens](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-access-tokens).\n\n*   [Authorization Code Flow](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-auth-code-flow): Structural differences exist in the authentication request, authentication response, code exchange request, code exchange response, ID token structure, and access token structure.\n    \n*   [Client Credentials Flow](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-client-credentials-flow): New flow enabled, which allows applications to authenticate as themselves (rather than on behalf of a user) to programmatically and securely obtain access to an API.\n    \n*   [Implicit Flow](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-implicit-flow): Structural differences exist in the authentication request, authentication response, ID token structure, and access token structure. Specifically:\n    \n    *   `response_type=token` only returns an access token. To get an ID token, use `response_type=id_token` or `response_type=token id_token`.\n        \n    *   ID tokens will be signed asymmetrically using RS256.\n        \n    *   Authentication requests made without a nonce parameter will be rejected. To learn more, read [Mitigate Replay Attacks When Using Implicit Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post/mitigate-replay-attacks-when-using-the-implicit-flow).\n        \n    *   Refresh tokens will no longer be returned when using the Implicit Flow for authentication.\n        \n*   [Resource Owner Password Flow](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-rop-flow): Structural differences exist in the authentication request, authentication response, ID token structure, and access token structure. Specifically:\n    \n    *   the legacy [resource owner endpoint](https://auth0.com/docs/api/authentication#database-ad-ldap-active-) is disabled, which also disables passwordless authentication for embedded login from that endpoint. To [implement Passwordless with embedded login](https://auth0.com/docs/connections/passwordless/guides/embedded-login), you must use the Embedded Passwordless API or our SDKs, depending on your application type.\n        \n    *   the `device` parameter is now considered invalid when requesting a refresh token using the `offline_access` scope.\n        \n\n### Delegation\n\n*   **Deprecated**: [`/delegation`](https://auth0.com/docs/api/authentication#delegation) endpoint, except when used to get third-party API tokens.\n    \n*   OIDC-conformant applications cannot be the source or target of delegation requests.\n    \n\nTo learn more, read [OIDC-Conformant Adoption: Delegation](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-delegation).\n\n### Endpoints\n\n*   **Deprecated**: `/tokeninfo` endpoint\n    \n*   **Disabled**: the [`/oauth/access_token`](https://auth0.com/docs/api/authentication#post-oauth-access_token) endpoint (used for social authentication from native mobile applications).\n    \n*   **Deprecated**: `/ssodata` endpoint\n    \n*   **Deprecated**: [`/delegation`](https://auth0.com/docs/api/authentication#delegation) endpoint except when used to get third-party API tokens.\n    \n\n### Refresh tokens\n\n*   Refresh tokens will no longer be returned when using the Implicit Flow for authentication.\n    \n*   Refresh tokens can be used for confidential applications, but refresh token rotation can increase security for most flows and should always be used for public applications when using the Authorization Code Flow with PKCE. To learn about confidential applications, read [Confidential and Public Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications). To learn more about refresh token rotation, read, [Refresh Token Rotation](https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation).\n    \n*   When getting new tokens, you should use the `/oauth/token` endpoint.\n    \n*   The `device` parameter is no longer needed when requesting a refresh token using the `offline_access` scope in authentication requests.\n    \n\nTo learn more, read [OIDC-Conformation Adoption: Refresh Tokens](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-refresh-tokens).\n\n### Single Sign-on (SSO)\n\n*   SSO can be performed only from Auth0 login pages, which means that you must employ Universal Login.\n    \n*   To determine whether users are logged in via SSO, you must use silent authentication. To learn more, read [Configure Silent Authentication](https://auth0.com/docs/authenticate/login/configure-silent-authentication).\n    \n*   **Deprecated**: `/ssodata` endpoint and `getSSOData()` method from `Lock/auth0.js`.\n    \n\nTo learn more, read [OIDC-Conformant Adoption: Single Sign-On](https://auth0.com/docs/authenticate/login/oidc-conformant-authentication/oidc-adoption-sso).\n\n### Additional features\n\n*   Create third-party applications for your APIs and display consent dialogs for authorization. To learn more, read [User Consent and Third-Party Applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications).\n    \n*   Restrict user profile information provided to applications upon authentication. To learn more, read [User Profiles](https://auth0.com/docs/videos/get-started-series/learn-user-profiles).\n    \n*   Dynamically register applications. To learn more, read [Dynamic Client Registration](https://auth0.com/docs/get-started/applications/dynamic-client-registration).\n    \n*   [Organizations](https://auth0.com/docs/manage-users/organizations) and their related features become available.",
    "title": "Adopt OIDC-Conformant Authentication",
    "description": "Learn about the effect of the OIDC-conformant application setting on the authentication pipeline.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates",
    "markdown": "# Configure Custom Domains with Self-Managed Certificates\n\nIf you choose to manage the certificates for your custom domains without assistance from Auth0, you need to know how to manage your own proxy and certificates for inbound connections that require multiple DNS records on the domain. You have to purchase or provide the certificates and manage the renewals yourself. You will also need a reverse proxy where the certificate will be installed. Once the domain is verified, we will accept traffic from the proxy.\n\nChoose this option to:\n\n*   Have more control of your certificates (such as choosing your own CA or certificate expiration).\n    \n*   Enable additional monitoring over your API calls to Auth0.\n    \n\nTo set up your custom domain using self-managed certificates, you need to provide your domain name to Auth0, verify that you own that domain, and configure the reverse proxy. Once your custom domain has been set up, you will need to configure your Auth0 features to start using your custom domain.\n\n## Provide your domain name to Auth0\n\n1.  Go to [Dashboard > Settings > Custom Domains](https://manage.auth0.com/#/tenant/custom_domains) or [Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/custom_domains). Enter your custom domain in the provided box, and select **Self-managed Certificates** from the drop-down menu.\n    \n    ![Dashboard Settings Custom Domains Tab Certificate Type Self-Managed Certificates](https://images.ctfassets.net/cdy7uua7fh8z/5v7KeS7m64oNZQowWsm1gG/1862702190ef6dc9205409d8c4069f4e/dashboard-settings-custom-domains-self-managed-certificates.png)\n2.  Click **Add Domain**. You can only add one domain per tenant even though the **Add Domain** button still appears after you add a domain.\n    \n\n## Verify ownership\n\nBefore you can use the domain with Auth0, you'll need to verify that you own it.\n\n1.  Go to [Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/branding/custom_domains).\n    \n    ![Auth0 Branding Custom Domains Self-Managed Certificate Verify Domain](https://images.ctfassets.net/cdy7uua7fh8z/4XhEmQwKfoqydOldfHnnud/3d49bd3de7fa059877247c4946d5b463/dashboard_-_branding_-_custom_domains_-_self-managed.png)\n2.  Add the TXT verification information to your domain's DNS record. These steps may vary for your domain host provider:\n    \n    1.  Keep the Auth0 custom domain page open in your browser so you can copy values.\n        \n    2.  Log in to your domain management service.\n        \n    3.  Create a new record, and save it with these settings:\n        \n        | **Parameter** | **Value** |\n        | --- | --- |\n        | Record type | TXT |\n        | Name | Copy and paste your domain's **TXT Record** value from Auth0. |\n        | Time to Live (TTL) | Use default value. |\n        | Value | Copy and paste your domain's **TXT Content** value from Auth0. |\n        \n3.  Click **Verify** to proceed.\n    \n    It may take a few minutes before Auth0 can verify your domain, depending on your DNS settings.\n    \n    If Auth0 successfully verified your domain name, you'll see a confirmation window. Save the information provided in this window, specifically the `cname-api-key` value, since this is the **only** time you'll see this value.\n    \n    ![Auth0 Branding Custom Domains Domain verification](https://images.ctfassets.net/cdy7uua7fh8z/3I2xfwddYVnUBXGY7hGP8q/8423d41642364b3bbb2a0c829317376b/dashboard-branding-custom_domains-domain_verification.png)\n    \n    The verification process is complete, and within 1 to 2 minutes, your custom domain should be ready to use. If you are unable to complete the verification process within three days, repeat these steps.\n    \n\n## Configure reverse proxy\n\nThe reverse proxy server retrieves resources on behalf of your application from one or more servers. These resources are then returned to the application, appearing as if they originated from the proxy server itself.\n\nYou can use a service such as [Cloudflare](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-cloudflare-for-use-as-reverse-proxy), [Azure CDN](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-azure-cdn-for-use-as-reverse-proxy), [Google Cloud Platform](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-gcp-as-reverse-proxy), or [AWS Cloudfront](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-aws-cloudfront-for-use-as-reverse-proxy) and configure settings for your custom domain. You will add the new CNAME value to your DNS for your custom domain pointing to the reverse proxy server domain name for distribution.\n\n1.  After you've created the reverse proxy settings on your service, go to [Auth0 Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/branding/custom_domains) tab.\n    \n2.  Add a new CNAME record to your DNS for your custom domain pointing to the service domain name for your distribution. You can find this by looking for the **Distribution ID** on your reverse proxy server configuration. Once added, the CNAME record must be present at all times to avoid issues during certificate renewal.\n    \n3.  The way you configure the proxy server will vary depending on the service you use. You will likely need to configure the following types of settings:\n    \n\n*   [Distribution](#distribution-settings)\n    \n*   [Origin custom headers](#origin-custom-header-settings)\n    \n*   [Origin hostname](#origin-hostname-settings)\n    \n*   [Default cache behavior](#default-cache-behavior-settings)\n    \n\n### Distribution settings\n\n| **Setting** | **Value** |\n| --- | --- |\n| Origin Domain Name | Set this to the **Origin Domain Name** value obtained from the Auth0 Dashboard during the Custom Domains setup process. |\n| Origin ID | A description for the origin. This value lets you distinguish between multiple origins in the same distribution and therefore must be unique. |\n| Origin Protocol Policy | Set to `HTTPS Only`. |\n| Alternate Domain Names (CNAMEs) | Set to your custom domain name (the same one your configured in the Auth0 Dashboard). |\n\n| **Setting** | **Value** |\n| --- | --- |\n| Header Name | Set to `cname-api-key`. |\n| Value | Set to the CNAME API Key value that you were given immediately after you verified ownership of your domain name with Auth0. |\n\n### Origin hostname settings\n\n| **Setting** | **Value** |\n| --- | --- |\n| Origin hostname | Enter `{yourTenant}-<CUSTOM_DOMAIN_ID>.edge.tenants.us.auth0.com`, making sure to replace `<CUSTOM_DOMAIN_ID>` with the value of the Origin Domain Name (custom domain ID) you received from Auth0 when setting up the new custom domain. If your tenants are not in the US region, use one of the following:<br><br>*   EU: `{yourTenant}-<CUSTOM_DOMAIN_ID>.edge.tenants.eu.auth0.com`<br>*   AU: `{yourTenant}-<CUSTOM_DOMAIN_ID>.edge.tenants.au.auth0.com`<br>*   JP: `{yourTenant}-<CUSTOM_DOMAIN_ID>.edge.tenants.jp.auth0.com`<br><br>For example, if your CUSTOM\\_DOMAIN\\_ID is:<br><br>`cd_TXIdNgQ07HrAFVmz`<br><br>For a US tenant, then the Origin hostname should be:<br><br>`US: {yourTenant}-cd-txIdngq07hrafvmz.edge.tenants.us.auth0.com` |\n| Host header | Use the name you provided for the Origin hostname. |\n\nFor more information on retrieving the details of your custom domain, see [Get custom domain configurations](https://auth0.com/docs/api/management/v2/custom-domains/get-custom-domains).\n\n### Default cache behavior settings\n\n| **Setting** | **Value** |\n| --- | --- |\n| Viewer Protocol Policy | Select **Redirect HTTP to HTTPS**. |\n| Allowed HTTP Methods | Select **GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE**. |\n| Cache Based on Selected Request Headers | Select **Allow list**. |\n| Allow List Headers | The following headers should be allowed: `User-Agent`, `Origin`, `Referer`, `Authorization`, `Accept`, and `Accept-Language`. |\n| Forward Cookies | Select **All**. |\n| Query String Forwarding and Caching | Select **Forward all, cache based on all**. |\n\n## Additional steps for specific Auth0 features\n\nThere are additional configuration steps you must complete depending on which Auth0 features you are using. To learn more, read [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains).\n\nCloudflare uses a feature called CNAME Flattening, which affects Auth0 verification and certificate renewal in the way that it handles DNS records. We recommend that you turn off CNAME Flattening unless it's absolutely necessary. To learn more, read [Cloudflare documentation](https://support.cloudflare.com/hc/en-us/articles/200169056-Understand-and-configure-CNAME-Flattening).\n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Configure Google Cloud Platform with Load Balancing as Reverse Proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-gcp-as-reverse-proxy)\n*   [Configure Cloudflare as Reverse Proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-cloudflare-for-use-as-reverse-proxy)\n*   [Configure AWS CloudFront as Reverse Proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-aws-cloudfront-for-use-as-reverse-proxy)\n*   [Configure Azure CDN as Reverse Proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-azure-cdn-for-use-as-reverse-proxy)\n*   [Configure Akamai as Reverse Proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-akamai-for-use-as-reverse-proxy)",
    "title": "Configure Custom Domains with Self-Managed Certificates",
    "description": "Learn how to configure custom domains where you are responsible for TLS (SSL) certificates, the reverse proxy to handle SSL termination, and forwarding requests to Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider",
    "markdown": "# Configure Auth0 as SAML Service Provider\n\nTo configure Auth0 as the service provider (SP) in a SAML federation, you will need to create an Enterprise connection in Auth0 and then update your SAML identity provider (IdP) with the connection's metadata.\n\nAuth0 supports using Auth0 as the SP in configurations that conform to the SAML 1.1 or SAML 2.0 protocol.\n\n## Get metadata and certificate from the IdP\n\nYou'll need to collect some configuration metadata from the IdP to create a connection in Auth0:\n\n| **Field** | **Description** |\n| --- | --- |\n| Sign In URL | The URL where SAML authentication requests are sent. This is also called the single sign-on (SSO) endpoint. |\n| Sign Out URL | The URL where SAML logout requests are sent. This is also called the single logout (SLO) endpoint. |\n| X509 Signing Certificate | The public-key certificate required by the SP to validate the signature of the authentication assertions that have been digitally signed by the IdP. Auth0 accepts the .pem and .cer formats. |\n\n## Create SAML Enterprise connection in Auth0\n\nYou can create a SAML Enterprise connection in the Auth0 Dashboard or with the Auth0 Management API:\n\n1.  Go to [**Dashboard > Authentication > Enterprise**](https://manage.auth0.com/#/connections/enterprise/samlp) and select **SAML**.\n    \n2.  Select **Create Connection**.\n    \n3.  Configure the following settings:\n    \n    | **Setting** | **Description** |\n    | --- | --- |\n    | Connection Name | Enter a connection name such as `SAML-SP`. |\n    | Sign In URL | Enter the **Sign In URL** that you obtained from the IdP. |\n    | X509 Signing Certificate | Upload the X509 Signing Certificate file (in `.pem` or `.cer` format) that you obtained from the IdP. |\n    | Enable Sign Out | Enable the **Sign Out URL** field. |\n    | Sign Out URL | Enter the **Sign Out URL** obtained from the IdP. |\n    | User ID Attribute | Enter the attribute in the SAML token that will be mapped to the `user_id` property in Auth0. If not set, then the `user_id` will be retrieved from the following (in listed order):<br><br>*   `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`<br>*   `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn`<br>*   `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name` |\n    | Debug Mode | Enable **Debug Mode** for more verbose logging. |\n    | Sign Request | Enable signed SAML authentication requests. |\n    | Sign Request Algorithm | From the dropdown menu, select the hash algorithm to use. |\n    | Sign Request Algorithm Digest | From the dropdown menu, select the algorithm to use to check the validity of the assertion. |\n    | Protocol Binding | From the dropdown menu, select one of the following options:<br><br>*   `HTTP-Redirect`: Enables messages to be transmitted within URL parameters.<br>*   `HTTP-POST`: Enables messages to be transmitted within an HTML form. |\n    | Sync user profile attributes at each login | Enable syncing user profile attributes during each login. |\n    \n4.  Select **Create**.\n    \n\n### Configure SAML connection for proxy gateways\n\nIf you have Auth0 behind a proxy gateway, you’ll need to configure the SAML connection’s `destinationUrl` and `recipientUrl` fields accordingly.\n\n1.  Get your SAML connection's current configuration with the Management API [Get a connection](https://auth0.com/docs/api/management/v2/connections/get-connections-by-id) endpoint.\n    \n2.  Copy the value of the `options` object from the returned response.\n    \n3.  Add the following fields to the `options` object:\n    \n    | **Field** | **Type** | **Value** |\n    | --- | --- | --- |\n    | `destinationUrl` | String | URL of the proxy gateway. |\n    | `recipientUrl` | String | URL of the proxy gateway. |\n    \n4.  Call the Management API [Update a connection](https://auth0.com/docs/api/management/v2/connections/patch-connections-by-id) endpoint with the entire updated `options` object in the request body.\n    \n\n### Customize the request template\n\nWhen Auth0 sends the authentication request to the IdP, the request body contains an `AuthnRequest` object. You can customize the template used for this object:\n\n1.  Go to [Dashboard > Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp), and select your connection.\n    \n2.  Switch to the **Settings** view, and locate the **Request Template** field.\n    \n3.  Modify the template.\n    \n4.  Select **Save Changes**.\n    \n\n#### Template variables\n\nVariables can be placed into the `AuthnRequest` template using the `@@VariableName@@` syntax. The following variables are available:\n\n| **Name** | **Description** |\n| --- | --- |\n| **ID** | The transaction ID. |\n| **IssueInstant** | The transaction date timestamp. |\n| **Issuer** | The entity ID of the SP in `urn` format. For example, `urn:auth0:<YOUR_AUTH0_TENANT_NAME>:<YOUR_AUTH0_CONNECTION_NAME>`. |\n| **ProtocolBinding** | The protocol [binding type](https://www.ibm.com/support/knowledgecenter/en/SSPREK_9.0.4/com.ibm.isam.doc/config/concept/fed_SAML20_bindings.html). |\n| **AssertionConsumerServiceURL** | The URL where the IdP sends the response after the user signs in. Include the `ProtocolBinding` attribute in the request template if you use this. |\n| **Destination** | The URL where Auth0 sends the request. This should be the **Sign In URL** configured for the connection. |\n| **LoginHint** | The username or email of the user logging in. If you are using [Identifier First Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first), Auth0 can send this value to the IdP to pre-populate it in the IdP's login form. |\n| **ProviderName** | The name of the application that initiated the request. |\n| **Connection.<options-key>** | Use dot notation on the `Connection` key to access any of the connection's `options` values as returned from the Auth0 Management API's [Get a Connection](https://auth0.com/docs/api/management/v2/#!/Connections/get_connections_by_id) endpoint. For example, if the connection has `options.some_property: \"value\"`, then you can use `@@Connection.some_property@@` in the template. |\n| **AssertServiceURLAndDestination** | Deprecated. For new configurations, use `AssertionConsumerServiceURL` and `Destination` instead. |\n\n## Configure the IdP\n\nGo to [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings) to find the metadata you'll need to provide to the IdP.\n\nAuth0 supports all SAML IdPs that conform to the SAML 1.1 or SAML 2.0 protocol. We have detailed instructions for configuring specific providers:\n\n*   [ADFS](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-adfs-saml-connections)\n    \n*   [Okta](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-okta-as-saml-identity-provider)\n    \n*   [OneLogin](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-onelogin-as-saml-identity-provider)\n    \n*   [Ping7](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-pingfederate-as-saml-identity-provider)\n    \n*   [Salesforce](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-salesforce-as-saml-identity-provider)\n    \n*   [SiteMinder](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-siteminder-as-saml-identity-provider)\n    \n*   [SSOCircle](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-ssocircle-as-saml-identity-provider)\n    \n\n## Test connection\n\nTo test your connection in the Dashboard:\n\n1.  Go to [Dashboard > Authentication > Enterprise > SAML](https://manage.auth0.com/#/connections/enterprise/samlp).\n    \n2.  Locate the connection you created, select the **...** (three dots) menu icon, and select **Try**.\n    \n3.  A Universal Login Page will appear and prompt you to enter credentials.\n    \n4.  Enter the email address of a user who exists in the IdP. If you configured [Home Realm Discovery](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first#define-home-realm-discovery-identity-providers), make sure you enter an email address that uses one of the specified domains.\n    \n5.  After you are redirected to the login screen for the IdP, log in as you normally would.\n    \n6.  You will be redirected to a page on Auth0 that displays the contents of the authentication assertion sent to Auth0 from the IdP.\n    \n\n## Troubleshoot connection\n\nIf your connection is not working as expected, try the following steps:\n\n*   Clear your browser history, cookies, and cache before each test. If you do not, the browser may not pick up the latest configuration information, or it may have stale cookies that affect execution.\n    \n*   Ensure that your browser allows cookies and has JavaScript enabled.\n    \n*   [Capture a HAR file](https://auth0.com/docs/troubleshoot/troubleshooting-tools/generate-and-analyze-har-files) of the transaction, and then use the [Auth0 SAML Tool](http://samltool.io/) to decode the SAML assertion and inspect its contents.\n    \n\n## Learn more\n\n*   [Customize SAML Assertions](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/customize-saml-assertions)\n*   [Sign and Encrypt SAML Requests](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/sign-and-encrypt-saml-requests)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)\n*   [Troubleshoot SAML Errors](https://auth0.com/docs/troubleshoot/authentication-issues/saml-errors)",
    "title": "Configure Auth0 as SAML Service Provider",
    "description": "Describes how to configure Auth0 to serve as a service provider in a SAML federation.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider",
    "markdown": "# Configure Auth0 as SAML Identity Provider\n\nYou can use Auth0 as the identity provider in SAML configurations with SAML 2.0.\n\n## SSO integrations with built-in Auth0 support\n\n1.  Go to [Dashboard > Applications > SSO Integrations](https://manage.auth0.com/#/externalapps) and select **Create SSO Integration**.\n    \n2.  Choose an SSO identity provider integration. On the next screen, click **Continue**.\n    \n3.  Enter the required details for your selected provider and click **Save**.\n    \n\nOn the Tutorial view, you will see additional configuration instructions that are specific to the integration you have chosen.\n\nSome of the following integrations make use of the [SAML2 Web App addon](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/enable-saml2-web-app-addon).\n\n*   [Amazon Web Services](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-aws)\n    \n*   [Atlassian](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-atlassian)\n    \n*   [Cisco-WebEx](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-cisco-webex)\n    \n*   [DataDog](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-datadog)\n    \n*   [Egencia](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-egencia)\n    \n*   [Oracle Eloqua Marketing Cloud](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-addon-eloqua)\n    \n*   [Freshdesk](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-freshdesk)\n    \n*   [GitHub Enterprise Cloud](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server)\n    \n*   [GitHub Enterprise Server](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-github-enterprise-server)\n    \n*   [Google Workspace](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-idp-for-google-g-suite)\n    \n*   [Heroku](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-saml2-web-app-addon-for-heroku)\n    \n*   [Hosted Graphite](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-hosted-graphite)\n    \n*   [Litmos](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-litmos)\n    \n*   [PluralSight](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-pluralsight)\n    \n*   [Sprout Video](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-sprout-video)\n    \n*   [Tableau Online](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-tableau-online)\n    \n*   [Tableau Server](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-tableau-server)\n    \n*   [Workday](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-workday)\n    \n*   [Workpath](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider/configure-auth0-as-identity-provider-for-workpath)\n    \n\n## Manually configure SSO integrations\n\nYou can manually configure a SAML SSO integration with the SAML2 Web App addon in the Auth0 Dashboard. You can configure the SAML addon using the instructions on the screen along with the information available on the service provider's settings.\n\n### Obtain the Application Callback URL from the service provider\n\nObtain the URL to which the SAML Authentication Assertion should be sent from the service provider. This may be called **Assertion Consumer Service URL**, **Post-back URL**, or **Callback URL**.\n\n### Configure SAML SSO in Auth0\n\n1.  Go to [Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) and either create a new application or click the name of an application to configure.\n    \n2.  Scroll to the bottom of the **Settings** page and click **Advanced Settings**.\n    \n3.  Select the **Certificates** tab and click **Download Certificates** and choose **`PEM`** format. The certificate will be downloaded to a file called `{yourTenant}.pem`. Save this file; you will need to upload it when you configure the service provider.\n    \n    ![Dashboard Applications Advanced Settings Certificates tab](https://images.ctfassets.net/cdy7uua7fh8z/5eB167clrfOiBEtyrMOtkn/fba0b689fda32cb9fd16eba1c0725c65/dashboard-applications-applications-settings-advanced-certificates.png)\n4.  Select the **Endpoints** tab and locate **SAML Protocol URL.** Copy and save it. You will need to provide it to the service provider.\n    \n    ![Dashboard Applications Application Settings Tabs Advanced Endpoints tab](https://images.ctfassets.net/cdy7uua7fh8z/6aYWCyJXwGKwVmP42te2oI/118305c73038e2661286b66d1122b5e2/dashboard-applications-applications-settings-advanced-endpoints.png)\n5.  Scroll to the top and select the **Addons** tab.\n    \n6.  Enable the **SAML2 Web App** toggle.\n    \n7.  On the **Settings** tab, enter the **Application Callback URL** from the service provider (or application) to which the SAML assertions should be sent after Auth0 has authenticated the user. This is the Assertion Consumer Service (ACS) URL.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Settings Tab](https://images.ctfassets.net/cdy7uua7fh8z/6dJgYkcOgMZ73HVTkAWt1x/4e8ba95fc106483148c198446b745360/dashboard-applications-applications-addons-saml2-web-app-settings.png)\n8.  Scroll to the bottom of the tab and click **Enable**.\n    \n9.  If your service provider sends multiple ACS URLs in the SAML request, you will need to add them to the allow list by navigating to your application's **Settings** tab, locating **Allowed Callback URLs**, and adding them.\n    \n\n### Configure SAML SSO on the service provider\n\n1.  Go to the SAML Addon **Usage** tab to view the information that you need to configure the service provider application.\n    \n    ![Dashboard Applications Applications Addons Tab SAML2 Web App Usage Tab](https://images.ctfassets.net/cdy7uua7fh8z/3T90BDpyTXFUWDp1JkncBU/86bdba6bed8130b34b42b25c9bf2d232/dashboard-applications-applications-addons-saml2-web-app-usage.png)\n2.  Locate **Identity Provider Metadata**, and click **Download** to download the metadata file. Add information to the service provider, so it knows how to send SAML-based authentication requests to Auth0. The instructions provided here are generic. You will need to find the appropriate screens and fields on the service provider.\n    \n\n*   If the service provider supports uploading a metadata file, provide the metadata URL obtained on the SAML2 Web Addon **Usage** tab.\n    \n*   If the service provider does not support uploading a metadata file, configure settings manually, using the information from the SAML Addon's **Usage** view.\n    \n    *   For a Login URL, use the **Identity Provider Login URL**, which is the URL to which the service provider should send its SAML Authentication Requests.\n        \n    *   If you have a custom domain, use the custom-domain-based URL rather than your Auth0 domain. Instead of using a URL in this format: `https://{yourTenant}.auth0.com/samlp/CLIENTID?connection=Username-Password-Authentication` You will want to use one in this format: `https://{yourCustomDomain}/samlp/CLIENTID?connection=Username-Password-Authentication`.\n        \n    *   If you are using [Organizations](https://auth0.com/docs/manage-users/organizations), you can direct users to a specific organization's login prompt by providing an organization ID in the query string as the `organization` parameter. Optionally, you can also specify the connection by including the `connection` parameter. Example: `https://{yourTenant}.auth0.com/samlp/CLIENTID?connection=Acme-Saml-Connection&organization=org_123456789`\n        \n    *   If the service provider also has a field for a Logout URL, enter the **Identity Provider Login URL** again; both login and logout are handled by the same URL.\n        \n*   Download the certificate from the SAML Addon's **Usage** view and provide it to the service provider. This certificate will be used to validate the signature of the SAML Authentication Assertions sent from Auth0 to the service provider. If the service provider asks for an **Issuer**, this can also be obtained from the SAML Addon's **Usage** view.\n    \n\n### Test configuration\n\nOnce you have completed the above configuration, test the login.\n\n*   If your application doesn't work the first time, clear your browser history and (ideally) cookies each time before you test. Otherwise, the browser may not pick up the latest version of your HTML page, or it may have stale cookies that impact execution.\n    \n*   To help troubleshoot SSO, capture an HTTP trace of the interaction. Many tools will capture the HTTP traffic from your browser for analysis.\n    \n    *   Search the internet for \"HTTP Trace\" to find and install a tool.\n        \n    *   Capture the login sequence from start to finish and analyze the trace. Track the sequence of GETs to see how far in the expected sequence you get. You should see a redirect from your original site to the SP and then to the IdP, a post of credentials if you had to log in, then a redirect back to the callback URL or the SP, and then a redirect to the callback URL specified in your application.\n        \n*   Make sure that cookies and JavaScript are enabled for your browser.\n    \n*   Use the [http://samltool.io](http://samltool.io/) tool to decode a SAML assertion.\n    \n\n## Learn more\n\n*   [Customize SAML Assertions](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/customize-saml-assertions)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)\n*   [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings)",
    "title": "Configure Auth0 as SAML Identity Provider",
    "description": "Describes how to configure Auth0 to serve as a SAML identity provider in a SAML federation.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-gcp-as-reverse-proxy",
    "markdown": "# Configure Google Cloud Platform with Load Balancing as Reverse Proxy\n\nYou can set up Google Cloud Platform (GCP) with load balancing as a reverse proxy. The following diagram describes components in the configuration.\n\n*   **Google Cloud Platform Load Balancer** distributes traffic across multiple instances of applications.\n    \n*   **Internet Network Endpoint Group** is a backend that resides outside of Google Cloud. See [Internet Network endpoint group](https://cloud.google.com/load-balancing/docs/negs/internet-neg-concepts) for details.\n    \n\n![Google Cloud Platform with Load Balancing as Reverse Proxy flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/62abKXSoxy0b7uxBfmoWjs/4d6c05060d16d36265e5184ccb3d95b9/gcp-load-balancing-reverse-proxy-diagram.png)\n\n1.  [Configure Custom Domains with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates) if you haven't already. Make note of the **Origin Domain Name** and `cname-api-key` values for use later.\n    \n2.  Verify ownership of the domain by adding a TXT record in your DNS server in the [Auth0 Dashboard > Tenant Settings > Custom Domains](https://manage.auth0.com/#/tenant/custom_domains) and click **Verify**.\n    \n3.  Once GCP has verified your domain, log in to the [GCP console](https://console.cloud.google.com/).\n    \n4.  Go to **Network Services > Load Balancing**. Click **Create Load Balancer**. To learn more, see [Google Cloud Platform Load Balancing](https://cloud.google.com/load-balancing/docs) in Google Cloud documentation.\n    \n    1.  Select **HTTP(S) Load Balancing**.\n        \n    2.  Select **From Internet to my VMs** because we need to route the traffic from Internet to Auth0. Click **Continue**.\n        \n    3.  Provide a name for the load balancer such as `auth0-reverse-proxy` and click **Create**.\n        \n5.  Configure the backend.\n    \n    1.  Create an [](https://cloud.google.com/load-balancing/docs/negs/internet-neg-concepts)internet network endpoint group (NEG) which is a backend that resides outside of Google Cloud. To learn more, see [Internet network endpoint groups overview](https://cloud.google.com/load-balancing/docs/negs/internet-neg-concepts) in Google Cloud documentation.\n        \n    2.  Select the newly created Internet NEG as a backend in the backend service configuration and set the `cname-api-key` and `host` value (origin domain name) from your Auth0 tenant.\n        \n    3.  Click **Done**.\n        \n6.  Set up the `host` and `path` rules.\n    \n    1.  Choose **Action** as **Route traffic to a single backend**.\n        \n    2.  In **Host rewrite**, enter your origin domain name from your Auth0 tenant that you saved earlier.\n        \n    3.  Click **Create**.\n        \n7.  Configure the frontend.\n    \n    1.  Create a certificate. The easiest method is to choose **Google-managed certificate** because Google automatically provisions the SSL certificate for you.\n        \n    \n    1.  If you do not choose a Google-managed certificate, then it is your responsibility to renew and upload the SSL certificate with your certificate authority before it expires.\n        \n8.  Review and finalize the configuration. It will take a minute for GCP to configure the load balancer. Typical issues that might cause an error include:\n    \n    *   **Invalid API key**: The `cname-api-key` was not set to Auth0 from GCP.\n        \n    *   **403 Forbidden**: The `host` header was not sent to Auth0 from GCP.\n        \n9.  Log in to your DNS provider and [set up the CNAME](https://auth0.com/docs/custom-domains/configure-custom-domains-with-auth0-managed-certificates#add-cname-verification-record-to-dns-record).\n    \n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [TLS (SSL) Versions and Ciphers](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl)",
    "title": "Configure Google Cloud Platform with Load Balancing as Reverse Proxy",
    "description": "Learn how to set up Google Cloud Platform (GCP) with load balancing for use as the custom domain proxy for Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/secure/security-guidance/data-security/allowlist",
    "markdown": "# Auth0 IP Addresses for Allow Lists\n\nIf you have custom code executing in Auth0 that calls a service inside your network, or if you've configured an on-premise SMTP provider in Auth0, then you may need to configure your firewall to allow inbound traffic from Auth0.\n\nFeatures that may require you to allow inbound traffic from Auth0 include:\n\n*   [Actions](https://auth0.com/docs/customize/actions)\n    \n*   [Rules](https://auth0.com/docs/customize/rules)\n    \n*   [Hooks](https://auth0.com/docs/customize/hooks)\n    \n*   [Custom Database Action Scripts](https://auth0.com/docs/authenticate/database-connections/custom-db/templates)\n    \n*   [Log Streams](https://auth0.com/docs/customize/log-streams)\n    \n*   [External STMP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)\n    \n\n## Outbound calls\n\nWhen Auth0 makes outbound calls, the IP addresses are static. Auth0 translates internal IP addresses to one of the displayed options when reaching out using NAT.\n\n### Public Cloud\n\nFor Public Cloud tenants, the IP addresses that you must allow through your firewall are specific to the tenant's region.\n\nThe list of IP addresses for each region are listed below:\n\n#### United States\n\n174.129.105.183, 18.116.79.126, 18.117.64.128, 18.191.46.63, 18.218.26.94, 18.232.225.224, 18.233.90.226, 3.131.238.180, 3.131.55.63, 3.132.201.78, 3.133.18.220, 3.134.176.17, 3.19.44.88, 3.20.244.231, 3.21.254.195, 3.211.189.167, 34.211.191.214, 34.233.19.82, 34.233.190.223, 35.160.3.103, 35.162.47.8, 35.166.202.113, 35.167.74.121, 35.171.156.124, 35.82.131.220, 44.205.93.104, 44.218.235.21, 44.219.52.110, 52.12.243.90, 52.2.61.131, 52.204.128.250, 52.206.34.127, 52.43.255.209, 52.88.192.232, 52.89.116.72, 54.145.227.59, 54.157.101.160, 54.200.12.78, 54.209.32.202, 54.245.16.146, 54.68.157.8, 54.69.107.228\n\n#### Europe\n\n18.197.9.11, 18.198.229.148, 3.125.185.137, 3.65.249.224, 3.67.233.131, 3.68.125.137, 3.72.27.152, 3.74.90.247, 34.246.118.27, 35.157.198.116, 35.157.221.52, 52.17.111.199, 52.19.3.147, 52.208.95.174, 52.210.121.45, 52.210.122.50, 52.28.184.187, 52.30.153.34, 52.57.230.214, 54.228.204.106, 54.228.86.224, 54.73.137.216, 54.75.208.179, 54.76.184.103\n\n#### Australia\n\n13.210.52.131, 13.238.180.132, 13.55.232.24, 16.50.37.252, 16.51.137.244, 16.51.49.47, 54.153.131.0, 54.252.2.143, 54.79.31.78\n\n#### Canada\n\n15.222.97.193, 3.97.144.31, 40.176.144.225, 40.176.166.165, 40.177.34.170, 99.79.94.44\n\n#### Japan\n\n13.208.85.227, 15.152.185.222, 15.152.2.46, 15.152.28.221, 15.152.56.146, 15.152.95.63, 176.34.22.106, 35.74.30.168, 43.206.201.6, 46.51.243.250, 54.150.87.80, 54.248.192.141\n\n#### United Kingdom\n\n18.135.40.36, 3.10.89.10, 3.8.59.62\n\n### Private Cloud\n\nFor Private Cloud tenants, the IP addresses that you must allow through your firewall are unique to the tenant's environment. Auth0 may receive your tenant's private IP addresses if you enable features like Tenant Logs, Suspicious IP throttling, Custom Databases, and Actions that rely on them.\n\nThese IP addresses are known as **Primary Egress IPs** and are listed under the environment's configuration data available in the [Auth0 Support Center](https://support.auth0.com/tenants/private).\n\n## Inbound calls\n\nIP addresses related to inbound calls to Auth0 may be variable due to the lack of fixed IP addresses on the load balancers. In this case, firewall rules should operate on the name of the service (for example: `<YOUR_TENANT>.<YOUR_REGION>.auth0.com`).\n\nIf your Auth0 subscription allows you to configure a self-managed custom domain, you can configure that custom domain to have a static IP address. Self-managed custom domains give you control over the network entry point and let you ensure that the IP address is fixed. For information on subscription plans, see [Auth0 Pricing](https://auth0.com/pricing).\n\n## Learn more\n\n*   [Auth0 Public Cloud Service Endpoints](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/public-cloud-service-endpoints)\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)\n*   [Custom Database Connection Security Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/connection-security)",
    "title": "Auth0 IP Addresses for Allow Lists ",
    "description": "Lists Auth0 IP addresses for use in allow lists for inbound traffic behind a firewall.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains",
    "markdown": "# Configure Features to Use Custom Domains\n\nTo configure Auth0 features to use your custom domain, you may need to complete additional steps depending on the features you are using. For example, you may need to make changes before you can use your custom domain on your login page or to call your APIs.\n\nIf you have been using Auth0 for some time and decide to enable a custom domain, you will have to migrate your existing apps and update the settings as described below, including to any VPN or firewall you use. Note that existing sessions created at `{yourDomain}` will no longer be valid once you start using your custom domain, so users will have to log in again.\n\n## Prerequisites\n\nYou should have already configured and verified your custom domain.\n\n## Features\n\n| **Feature** | **Section to read** |\n| --- | --- |\n| Universal Login with a customized login page | [Universal Login](#universal-login) |\n| Lock embedded in your application | [Embedded Lock](#embedded-lock) |\n| Auth0 SPA SDK, Auth0.js, or other Auth0 SDKs | [Auth0 SPA SDK, Auth0.js, and other SDKs](#auth0-spa-sdk-auth0-js-and-other-sdks) |\n| Custom domain with Auth0 emails | [Use custom domains in emails](#use-custom-domains-in-emails) |\n| Social identity providers | [Configure social identity providers](#configure-social-identity-providers) |\n| Google Workspace connections with your custom domain | [Configure Google Workspace connections](#configure-g-suite-connections) |\n| Issue Access Tokens for your APIs or access Auth0 APIs from your application | [APIs](#apis) |\n| SAML Identity Providers | [Configure SAML identity providers](#configure-saml-identity-providers) |\n| SAML applications | [Configure SAML applications](#configure-saml-applications) |\n| Web Service Federation (WS-Fed) applications | [Configure WS-Fed applications](#configure-ws-fed-applications) |\n| Azure AD connections | [Configure Azure AD connections](#configure-azure-ad-connections) |\n| ADFS connections | [Configure ADFS connections](#configure-adfs-connections) |\n| AD/LAP connections with Kerberos support | [Configure AD/LAP connections](#configure-ad-ldap-connections) |\n\n## Universal Login\n\nIf you use [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) and you have customized the login page, you must update the code to use your custom domain. If you use the **default** login page without customization, you do not need to make any changes. To learn more, read Auth0 Universal Login.\n\nIf you use [Lock for Web](https://auth0.com/docs/libraries/lock), you must set the `configurationBaseUrl` and `overrides` options as seen in the following sample script:\n\n```\nvar lock = new Auth0Lock(config.clientID, config.auth0Domain, {\n  //code omitted for brevity\n  configurationBaseUrl: config.clientConfigurationBaseUrl,\n  overrides: {\n  \t__tenant: config.auth0Tenant,\n  \t__token_issuer: config.authorizationServer.issuer\n  },\n  //code omitted for brevity\n});\n```\n\nIf you use [Auth0.js](https://auth0.com/docs/libraries/auth0js) on the Universal Login page, you must set the `overrides` option.\n\n```\nvar webAuth = new auth0.WebAuth({\n  clientID: config.clientID,\n  domain: config.auth0Domain,\n  //code omitted for brevity\n  overrides: {\n  \t__tenant: config.auth0Tenant,\n  \t__token_issuer: config.authorizationServer.issuer\n  },\n  //code omitted for brevity\n});\n```\n\nFor most, the Auth0.js and Lock libraries retrieve the tenant name (required for `/usernamepassword/login`) and the issuer (required for `id_token` validation) from the domain. However, if you're a Private Cloud customer who uses a proxy or a custom domain name where the domain name is different from the tenant/issuer, you can use `__tenant` and `__token_issuer` to provide your unique values.\n\n## Embedded Lock\n\nIf you use [Lock for Web](https://auth0.com/docs/libraries/lock) embedded in your application, you must update the code to use your custom domain when initializing Lock. You will also need to set the `configurationBaseUrl` to the appropriate CDN URL.\n\nto configure this snippet with your account\n\n```\nvar lock = new Auth0Lock('{yourClientId}', '{yourCustomDomain}', {\n  //code omitted for brevity\n  configurationBaseUrl: 'https://cdn.us.auth0.com'\n  //code omitted for brevity\n});\n```\n\nThe CDN URL varies by region. Use `https://cdn.[us|eu|au|jp].auth0.com` (`us` for US, `eu` for Europe, `au` for Australia, or `jp` for Japan).\n\n## Auth0 SPA SDK, Auth0.js, and other SDKs\n\nIf you use the [Auth0 SPA SDK](https://auth0.com/docs/libraries/auth0-spa-js), [Auth0.js](https://auth0.com/docs/libraries/auth0js), or [other SDKs](https://auth0.com/docs/support/matrix#auth0-sdks), you will have to initialize the SDK using your custom domain. For example, if you are using the Auth0.js SDK, you must set the following:\n\nto configure this snippet with your account\n\n```\nwebAuth = new auth0.WebAuth({\n  domain: '{yourCustomDomain}',\n  clientID: '{yourClientId}'\n});\n```\n\nAnd for the Auth0 SPA SDK:\n\nto configure this snippet with your account\n\n```\nconst auth0 = await createAuth0Client({\n  domain: '{yourCustomDomain}',\n  client_id: '{yourClientId}'\n});\n```\n\nSee APIs section below if you use a custom domain and also intend to perform [Management API actions with Auth0.js](https://auth0.com/docs/libraries/auth0js/v9#user-management).\n\n## Use custom domains in emails\n\nIf you want to use your custom domain with your Auth0 emails, you must enable this feature.\n\n1.  Go to [Auth0 Dashboard > Branding > Custom Domains](https://manage.auth0.com/#/branding/custom_domains).\n    \n2.  Enable the **Use Custom Domain in Emails** toggle.\n    \n\nIf you want to use your custom domain with Social identity providers (IdP), you must update your IdP's list of Authorized Redirect URIs to include your custom domain (such as `https://login.northwind.com/login/callback`).\n\nYou cannot use [Auth0 developer keys](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/devkeys) with custom domains.\n\n## Configure Google Workspace connections\n\nIf you want to use your custom domain with Google Workspace connections, you must update the Authorized Redirect URI in your OAuth Client Settings. In the Google Developer Console, go to **Credentials**, choose your OAuth client in the list, and you will see a settings page with the app Client ID, secret, and other fields. In the **Authorized redirect URIs** field, add a URL in the format `https://<YOUR-CUSTOM-DOMAIN>/login/callback` that includes your custom domain (such as `https://login.northwind.com/login/callback`).\n\n## APIs\n\nAPI identifiers (i.e. `audience`) will not change. This is a constant value for each API, and despite the fact that it's conventional to use a URI, it is completely independent of the domain used to obtain the token.\n\nAuth0 issues tokens with the `iss` claim of whichever domain you used to obtain the token.\n\n##### Auth0 APIs\n\nContinue to use your default tenant domain name (such as `https://{yourDomain}/userinfo` and `https://{yourDomain}/api/v2/`) instead of your custom domain when specifying an `audience`. This is the only place to use your default tenant domain.\n\nAll requests (i.e. obtaining the token, and actually calling the API) must use the same domain. Tokens obtained via a custom domain must be used on an Auth0 API using the same custom domain.\n\nIf you use an authentication flow with your Custom Domain to request Access Tokens to access the Management API, you must call the Management API endpoint with your Custom Domain too.\n\n```\nPOST https://mycustomdomain.com/oauth/token\n... // other parameters \n...\naudience:https://defaulttenant.eu.auth0.com/api/v2/\n```\n\nYour Access Token request should be something similar to\n\n```\nGET https://mycustomdomain.com/api/v2/clients\n\nHeaders:\nAuthorization: Bearer <access_token>\n```\n\n##### Custom APIs\n\nIf you use Auth0 with a custom domain to issue Access Tokens for your APIs, you must validate the JWT issuer(s) against your custom domain. For example, if you use the [express-jwt](https://github.com/auth0/express-jwt) middleware, you must make the following change:\n\n```\napp.use(jwt({\n  issuer: 'https://<YOUR-CUSTOM-DOMAIN>/',\n  //code omitted for brevity\n}));\n```\n\n## Configure SAML identity providers\n\nTo use your custom domain with SAML Identity Providers (IdPs), you must update your **Assertion Consumer Service (ACS) URL(s)** with the Identity Provider(s). Depending on what is supported by the IdP, you can do this in one of two ways:\n\n1.  You can get the service provider metadata from Auth0 at `https://<YOUR-CUSTOM-DOMAIN>/samlp/metadata?connection=<YOUR-CONNECTION-NAME>`. This will include the updated ACS URL. Then, you must manually update this value in your IdP(s) settings. This change to your IdP(s) must happen at the same time as you begin using your custom domain in your applications. This can pose a problem if there are multiple IdPs to configure.\n    \n2.  If supported by the IdP, you can use signed requests to fulfill this requirement:\n    \n\n*   Download the signing certificate from `https://<TENANT>.auth0.com/pem`. Note that `https://<YOUR-CUSTOM-DOMAIN>.com/pem` will return the same certificate\n    \n*   Give the certificate to the IdP(s) to upload. This enables the IdP to validate the signature on the `AuthnRequest` message that Auth0 sends to the IdP\n    \n*   The IdP will import the certificate and, if necessary, signature verification should be enabled (exact steps vary by IdP)\n    \n*   Turn on the **Sign Request** toggle in the Dashboard under **Connections > Enterprise > SAML > CONNECTION**. This will trigger Auth0 to sign the SAML `AuthnRequest` messages it sends to the IdP.\n    \n\nOnce this is done, and you start using your custom domain when you initiate an authentication request in your application, the IdP will receive that custom domain in your signed request. Because your application’s signed request is trusted, the IdP should automatically override whatever was configured as your ACS URL and replace it with the value sent in the signed request. However, there are IdPs that do **not** accept the ACS URL in the signed request, so you must check with yours first to confirm whether this is supported or not.\n\nIf this is supported, it will prevent you from having to change one or many IdP settings all at the same time and allow you to prepare them to accept your signed requests ahead of time. You can then change the statically configured ACS URL in your IdP settings at a later date as well.\n\nNote that if your SAML identity provider is configured to use your custom domain, testing the connection via the **Try** button in the Dashboard will **not** work and the default links for downloading metadata from Auth0 will always show the default domain, not the custom domain.\n\nIf you have an IdP-initiated authentication flow, you will need to update the IdP(s) and your application(s) at the same time to use the custom domain.\n\n## Configure SAML applications\n\nIf you want to use your custom domain with SAML applications (when Auth0 is the IdP), you must update your service provider with new identity provider metadata from Auth0. You can obtain the updated metadata reflecting the custom domain from `https://<YOUR-CUSTOM-DOMAIN>/samlp/metadata/<YOUR-CLIENT-ID>`. Note that the issuer entity ID for the assertion returned by Auth0 will change when using a custom domain (from something like `urn:northwind.auth0.com` to one with the custom domain, such as `urn:login.northwind.com`).\n\nIf you have an IdP-initiated authentication flow, you will need to update the URL used to invoke the IdP-initiated authentication flow to reflect the custom domain. Instead of `https://<TENANT>.auth0.com/samlp/<YOUR-CLIENT-ID>`, you should use `https://<YOUR-CUSTOM-DOMAIN>/samlp/<YOUR-CLIENT-ID>`.\n\n## Configure WS-Fed applications\n\nIf you want to use your custom domain with WS-Fed applications with Auth0 as the IdP, you must update your Service Provider with new identity provider metadata from Auth0. You can obtain the metadata reflecting the custom domain from `https://<YOUR-CUSTOM-DOMAIN>/wsfed/FederationMetadata/2007-06/FederationMetadata.xml`.\n\nIf you want to use your custom domain with Azure AD connections, you must update the Allowed Reply URL in your Azure AD settings. In your Azure Active Directory, go to **Apps registrations** and select your app. Then click **Settings -> Reply URLs** and add a URL with your custom domain in the format `https://<YOUR-CUSTOM-DOMAIN>/login/callback` (such as `https://login.northwind.com/login/callback`).\n\n## Configure ADFS connections\n\nIf you want to use your custom domain with ADFS connections, you must update the endpoint in your ADFS settings. This will need to be updated to use your custom domain in the callback URL in the format `https://<YOUR-CUSTOM-DOMAIN>/login/callback` (such as `https://login.northwind.com/login/callback`).\n\nIf you do not need Kerberos support, AD/LDAP connections do not require further configuration.\n\nIn order to use AD/LDAP connections with Kerberos support, you will need to update the Ticket endpoint to work with the custom domain. As mentioned in the [Auth0 AD/LDAP connector documentation](https://auth0.com/docs/connector/modify#point-an-ad-ldap-connector-to-a-new-connection), the `config.json` file needs to be modified, with the `PROVISIONING_TICKET` value changed to use your custom domain in the format `https://<YOUR-CUSTOM-DOMAIN>/p/ad/jUG0dN0R`.\n\nOnce this change is saved, you need to restart the AD/LDAP Connector service for the change to take effect.\n\n## Learn more\n\n*   [Configure Custom Domains with Auth0-Managed Certificates](https://auth0.com/docs/customize/custom-domains/auth0-managed-certificates)\n*   [Configure Custom Domains with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)",
    "title": "Configure Features to Use Custom Domains",
    "description": "Learn how to configure a custom domain for Auth0 authentication features. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-azure-cdn-for-use-as-reverse-proxy",
    "markdown": "# Configure Azure CDN as Reverse Proxy\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nTo set up Azure CDN as a reverse proxy, an Azure CDN Premium plan is required.\n\n1.  [Configure Custom Domains with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates) if you haven't already. Make note of the **Origin Domain Name** and **cname-api-key** values since you'll need these later.\n    \n2.  Login to the [Azure Portal](https://portal.azure.com/).\n    \n3.  [Create a new Azure CDN Profile](https://docs.microsoft.com/en-us/azure/cdn/cdn-create-new-endpoint#create-a-new-cdn-profile).\n    \n4.  [Create a new Azure CDN endpoint](https://docs.microsoft.com/en-us/azure/cdn/cdn-create-new-endpoint#create-a-new-cdn-endpoint) using the CDN Profile you just created. For the CDN endpoint settings, use the following values:\n    \n    | Setting | Value |\n    | --- | --- |\n    | Name | We recommend naming your CDN endpoint like your custom domain name, replacing dots with dashes. For example: **login-mydomain-com.azureedge.net**. |\n    | Origin type | Select **Custom Origin** |\n    | Origin hostname | Enter `{yourTenant}.<CUSTOM_DOMAIN_ID>.edge.tenants.us.auth0.com`, making sure to replace `<CUSTOM_DOMAIN_ID>` with the custom domain ID from the **Origin Domain Name** you received from Auth0. If your tenants are not in the US region, use one of the following:<br><br>*   EU: `{yourTenant}.<CUSTOM_DOMAIN_ID>.edge.tenants.eu.auth0.com`<br>*   AU: `{yourTenant}.<CUSTOM_DOMAIN_ID>.edge.tenants.au.auth0.com`<br>*   JP: `{yourTenant}.<CUSTOM_DOMAIN_ID>.edge.tenants.jp.auth0.com` |\n    | Origin path | Leave blank. |\n    | Origin host header | Use the name you provided for the Origin hostname. |\n    | Protocol | Disable HTTP so that only HTTPS is enabled. |\n    \n5.  [Add your custom domain to your Azure CDN endpoint](https://docs.microsoft.com/en-us/azure/cdn/cdn-map-content-to-custom-domain).\n    \n6.  [Configure HTTPS for your Azure CDN custom domain](https://docs.microsoft.com/en-us/azure/cdn/cdn-custom-ssl?tabs=option-1-default-enable-https-with-a-cdn-managed-certificate). This process requires you to verify ownership of the domain. Once done, it may take up to 6 hours to deploy the certificate to all of the CDN pop locations.\n    \n7.  Set up the configuration for the custom domain communication with Auth0 using the Azure CDN Rules engine. (To learn more, see [Override HTTP behavior using the Azure CDN from Verizon Premium rules engine](https://docs.microsoft.com/en-us/azure/cdn/cdn-verizon-premium-rules-engine) in Microsoft documentation.) [Create a new Azure CDN Rule](https://docs.microsoft.com/en-us/azure/cdn/cdn-verizon-premium-rules-engine#tutorial) with the following settings:\n    \n    | Setting | Value |\n    | --- | --- |\n    | Name/Description | Auth0 Custom Domain |\n    | Type of requests | Select the **Edge CName** option, then select your custom domain name from the list. |\n    \n8.  Add the following **Features** to your Azure CDN Rule: We recommend creating another Azure CDN Rule to deny the usage of the **azureedge.net** CNAME.\n    \n    | Setting | Value |\n    | --- | --- |\n    | Bypass Cache | **Enabled** |\n    | Modify Client Request Header | Select **Override**, enter **cname-api-key** for the name, and enter the CNAME API Key provided by Auth0 as the value. |\n    \n9.  Once the Azure CDN Rule is approved, the status will change from Pending XML to Active XML. At this point, Azure CDN will be publishing the rules and certificates. When Azure finishes processing all changes, you can use your custom domain.\n    \n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [TLS (SSL) Versions and Ciphers](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl)",
    "title": "Configure Azure CDN as Reverse Proxy",
    "description": "Learn how to set up Azure CDN for use as the custom domain proxy for Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/libraries/lock/lock-authentication-modes",
    "markdown": "# Lock Authentication Modes\n\nLock can function in two different modes. The default mode is **redirect mode**. In this mode, your user is redirected to be authenticated, and then is returned to the application. In the second mode, **popup mode**, a popup window allows the user to authenticate with the identity provider without leaving the application.\n\n## Redirect Mode\n\nWhen you click the IdP button (For example, Facebook) with redirect mode, you are redirected to Facebook momentarily. Redirect mode is the default with Lock, and is the recommended mode for almost all use cases. Once you successfully login (to Facebook, in this example), Facebook will redirect you back to your app (through Auth0). The majority of examples or samples in the reference documentation employ redirect mode.\n\nIf after you click on the IdP button (Facebook for example), a popup (new tab or window) is opened, it means you are using popup mode. In that popup, you'll see that Facebook page is displayed. Once you successfully login to Facebook, the popup will be closed and your web app will recognize that the user has been authenticated. The web app has **never been redirected to any other page**.\n\nImplementing Lock with Popup Mode is again a simple change of the `redirect` option from its default.\n\nto configure this snippet with your account\n\n```\nvar lock = new Auth0Lock(\n  '{yourClientId}',\n  '{yourDomain}',\n  {\n    auth: {\n      redirect: false\n    }\n  }\n);\n```\n\nMulti-factor authentication (MFA) is not supported when Lock is in popup mode and embedded in your application. Additionally, popup mode does not work with Universal Login.\n\nSome Auth0 features, such as [Single Sign-on (SSO)](https://auth0.com/docs/authenticate/single-sign-on) between multiple applications, depend on users being redirected to Auth0 to set a cookie on `'{yourDomain}'`.\n\nWhen using popup mode, a popup window will be displayed in order to set this cookie. If prompts are unnecessary, this popup window will be blank and be in a hidden iframe to minimize disruption. The reason for this is that cross-origin requests sent from your application to Auth0 are not be able to set cookies.\n\nIf you do not want to display a popup window and do not need SSO between multiple applications, you can set `sso: false` when using Lock or auth0.js.\n\n```\nvar options = {\n  auth: {\n    sso: false\n  }\n}\n```",
    "title": "Lock Authentication Modes",
    "description": "Details about Authentication Modes with Lock.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-cloudflare-for-use-as-reverse-proxy",
    "markdown": "# Configure Cloudflare as Reverse Proxy\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects the availability of this feature. To learn more, read [Auth0's Pricing Page](https://auth0.com/pricing).\n\nTo set up Cloudflare as a reverse proxy using the recommended approach, a Cloudflare Enterprise Plan with the following features is required:\n\n## Configure Cloudflare\n\nTo configure Cloudflare as a reverse proxy, you’ll need to create a CNAME record, a Page Rule, and a Transform Rule in Cloudflare.\n\n1.  [Configure and verify a Custom Domain with Self-Managed Certificates](https://auth0.com/docs/customize/custom-domains/self-managed-certificates) if you haven't already. Make note of the **Origin Domain Name** and **cname-api-key** values since you'll need these later.\n    \n2.  In the Cloudflare dashboard for the target zone, [create a CNAME record](https://developers.cloudflare.com/dns/manage-dns-records/how-to/create-dns-records/#create-dns-records) with the following settings:\n    \n    | **Setting** | **Value** |\n    | --- | --- |\n    | Name | The custom domain name. |\n    | Target | The **Origin Domain Name** value recorded earlier. |\n    | Proxy Status | `Proxied` |\n    \n3.  [Create a Page Rule](https://support.cloudflare.com/hc/en-us/articles/200172336-Creating-Page-Rules) scoped to all URLs under the chosen custom domain and with the following settings:\n    \n    | **Setting** | **Value** |\n    | --- | --- |\n    | Host Header Override | The **Origin Domain Name** value recorded earlier. |\n    | True-Client-IP | `Enable` |\n    \n4.  [Create a Transform Rule](https://developers.cloudflare.com/rules/transform/request-header-modification/create-dashboard/):\n    \n    1.  Switch to the **Modify Request Header** view.\n        \n    2.  Select **Create Rule** and provide a name of your choice.\n        \n    3.  Under **When incoming requests match**, select **Custom filter expression** and set an expression that scopes the Rule to requests associated with the chosen custom domain. For example, use an exact match on the **Hostname** field.\n        \n    4.  Under Modify request header, select **Set static**, and then set the following fields:\n        \n        | **Field** | **Value** |\n        | --- | --- |\n        | Header name | `cname-api-key` |\n        | Value | The **cname-api-key** value recorded earlier. |\n        \n5.  Ensure that [Always Use HTTPS](https://developers.cloudflare.com/ssl/edge-certificates/additional-options/always-use-https/) is enabled and [encryption mode](https://developers.cloudflare.com/ssl/origin-configuration/ssl-modes/) is set, at least, to **Full** for your chosen custom domain.\n    \n\n## Configure Auth0\n\nCall the Auth0 Management API [Update custom domain configuration](https://auth0.com/docs/api/management/v2#!/Custom_Domains/patch_custom_domains_by_id) endpoint with the following payload in the body:\n\n```\n{\n  \"custom_client_ip_header\": \"true-client-ip\"\n}\n```\n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [TLS (SSL) Versions and Ciphers](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl)",
    "title": "Configure Cloudflare as Reverse Proxy",
    "description": "Learn how to set up Cloudflare for use as the custom domain proxy for Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/login-pages/classic-login/customize-lock-error-messages",
    "markdown": "# Customize Lock Error Messages\n\nYou can customize the error messages that will be displayed in certain situations by providing a `languageDictionary` option. A full listing of available `languageDictionary` fields to customize can be found in the GitHub repository's [English Dictionary file for Lock](https://github.com/auth0/lock/blob/master/src/i18n/en.js). Below is an example of some customized error messages:\n\nto configure this snippet with your account\n\n```\n// Examples of customized error messages in the languageDictionary option\nvar options = {\n  languageDictionary: {\n    error: {\n      login: {\n        \"lock.invalid_email_password\": \"Custom message about invalid credentials\",\n        \"lock.network\": \"Custom message indicating a network error and suggesting the user check connection\",\n        \"lock.unauthorized\": \"Custom message about a failure of permissions\",\n        \"too_many_attempts\": \"Custom message indicating the user has failed to login too many times.\"\n      },\n      signUp: {\n        \"invalid_password\": \"Custom message indicating a password was invalid\",\n        \"user_exists\": \"Custom message indicating that a user already exists\"\n      }\n    }\n  }\n};\n\n// Initiating our Auth0Lock\nvar lock = new Auth0Lock(\n  '{yourClientId}',\n  '{yourDomain}',\n  options\n);\n```\n\n## Custom errors in Rules\n\nIf you are returning custom error codes from a [rule](https://auth0.com/docs/customize/rules) or a custom database script, you can handle custom errors:\n\n*   In your application's redirect URL by reading the `error` and `error_mesage` query string parameters.\n    \n*   By redirecting the user back to your hosted pages with a custom error message and displaying the message with a [flash message](https://auth0.com/docs/libraries/lock/lock-api-reference).\n    \n\n## Learn more\n\n*   [Lock for Web](https://auth0.com/docs/libraries/lock)",
    "title": "Customize Lock Error Messages",
    "description": "Customizing error messages with Lock",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-aws-cloudfront-for-use-as-reverse-proxy",
    "markdown": "# Configure AWS CloudFront as Reverse Proxy\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nYou can configure AWS CloudFront for use as the reverse proxy with custom domain names for your Auth0 tenant.\n\n1.  Log in to AWS, and navigate to [CloudFront](https://console.aws.amazon.com/cloudfront).\n    \n2.  Click **Create Distribution**.\n    \n3.  You can choose the delivery method for your content. Click **Get Started** under the **Web** section.\n    \n4.  Configure your distribution settings. Here are the values you'll need to change.\n    \n    | Setting | Value |\n    | --- | --- |\n    | Origin Domain Name | Set this to the **Origin Domain Name** value obtained from the Auth0 Dashboard during the Custom Domains setup process |\n    | Origin ID | A description for the origin. This value lets you distinguish between multiple origins in the same distribution and therefore must be unique. |\n    | Origin Protocol Policy | Set to `HTTPS Only` |\n    | Alternate Domain Names (CNAMEs) | Set to your custom domain name (the same one your configured in the Auth0 Dashboard) |\n    | SSL Certificate | Set to the SSL Certificate for your custom domain stored in AWS Certificate Manager (ACM) in the US East(N. Virginia) Region or in IAM. |\n    \n5.  Provide information on the **Origin Custom Headers** (the **Header Name** and **Value** fields appear only after you've provided an **Origin Domain Name**)\n    \n    | Setting | Value |\n    | --- | --- |\n    | Header Name | Set to `cname-api-key` |\n    | Value | Set to the CNAME API Key value that you were given immediately after you verified ownership of your domain name with Auth0 |\n    \n6.  Configure the **Default Cache Behavior Settings**. Here are the values you'll need to change\n    \n    | Setting | Value |\n    | --- | --- |\n    | Viewer Protocol Policy | Select **Redirect HTTP to HTTPS** |\n    | Allowed HTTP Methods | Select **GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE** |\n    | Cache and origin request settings | Select **Legacy cache settings** |\n    | Cache Based on Selected Request Headers | Select **Include the following headers** |\n    | Add Headers | Enter `User-Agent` and click **Add Custom >>** to add the custom header. Do the same for `Authorization`, `Origin`, `Referer`, `Accept-Language`, and `Accept` headers. |\n    | Forward Cookies | Select **All** |\n    | Query Strings | Select **All** |\n    \n7.  Scroll to the bottom of the page and click **Create Distribution**. You'll see your newly-created distribution in your CloudFront Distributions list. Note that the Status will reflect `In progress` until the distribution is Deployed.\n    \n8.  Add a new CNAME record to your DNS for your custom domain pointing to the CloudFront Domain Name for your Distribution. This can be found by clicking on your Distribution ID, under the General tab, Domain Name (for example, `e2zwy42nt1feu7.cloudfront.net`).\n    \n\n## Learn more\n\n*   [Configure Features to Use Custom Domains](https://auth0.com/docs/customize/custom-domains/configure-features-to-use-custom-domains)\n*   [Troubleshoot Custom Domains](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-custom-domains)\n*   [TLS (SSL) Versions and Ciphers](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/tls-ssl)",
    "title": "Configure AWS CloudFront as Reverse Proxy",
    "description": "Learn how to configure AWS CloudFront for use as the custom domain proxy for Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/internationalization-and-localization/lock-internationalization",
    "markdown": "# Lock Internationalization\n\nYou can change the language of Lock by using the `language` configuration option. This will pull the corresponding language file from the `i18n` directory in Lock.\n\n## Provided languages\n\nTake a look at the [i18n directory](https://github.com/auth0/lock/blob/master/src/i18n/) for language files.\n\n## Set language option\n\nTo use the following examples, you'll need to first include Lock in your page:\n\n`<script src=\"https://cdn.auth0.com/js/lock/11.14/lock.min.js\"></script>`\n\nNext define your `options` object and include the `language` option. The `language` option needs to be a string matching the name of the corresponding file in the `i18n` directory [within Lock](https://github.com/auth0/lock/tree/master/src/i18n). Then instantiate Lock.\n\nto configure this snippet with your account\n\n```\n// Select a supported language\nvar options = {\n  language: 'es'\n};\n\n// Initiating our Auth0Lock\nvar lock = new Auth0Lock(\n  '{yourClientId}',\n  '{yourDomain}',\n  options\n);\n```\n\nTranslation data for Lock comes from language files which have key-value pairs representing various translations. For some languages, certain values may be missing, in which case you will see a warning: `language does not have property <missing prop>`. We encourage you to submit a [pull request](https://github.com/auth0/lock/tree/master/src/i18n) to add these missing values. Alternatively, you may define the missing values in your Lock `options` (see below).\n\n## Replace dictionary terms\n\nYou can also customize your own specific dictionary items using the `languageDictionary` option. This is useful if you are using one of the supported languages, but change the specific wording of a few items. For example, you might re-word the `title` or change the way other labels display to the user while leaving the remaining text on the widget intact.\n\nto configure this snippet with your account\n\n```\n// Customize some languageDictionary attributes\nvar options = {\n  languageDictionary: {\n    emailInputPlaceholder: \"something@youremail.com\",\n    title: \"Log me in\"\n  },\n};\n\n// Initiating our Auth0Lock\nvar lock = new Auth0Lock(\n  '{yourClientId}',\n  '{yourDomain}',\n  options\n);\n```\n\nFor an example of available `languageDictionary` property names and how to structure a `language` file, see the [English dictionary file for Lock](https://github.com/auth0/lock/blob/master/src/i18n/en.js).\n\nThe `languageBaseUrl` option, which takes a string value (a URL), overrides the language source URL for Auth0's provided translations. By default, it uses the Auth0's CDN URL `https://cdn.auth0.com` because that is where the provided language translations are stored. By providing another value, you can use your own source for the language translations as needed for your applications. Your language source should be a JavaScript file.",
    "title": "Lock Internationalization",
    "description": "Lock v11 supports multiple languages, and allows for the addition of other custom language files, as well as for customizing the values of specific pieces of text that are displayed in the Lock widget.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/api-endpoints-for-single-sign-on",
    "markdown": "# API Endpoints for Single Sign-On\n\nWhen implementing Single Sign-on (SS0) and configuring its settings, the following API endpoints will be helpful to you.\n\n## Authentication API endpoints\n\n### POST /login/callback\n\nFor SSO flows initiated by an Identity Provider (IdP), the [POST /login/callback](https://auth0.com/docs/api/authentication#idp-initiated-single-sign-on-sso-flow) endpoint can accept a sign-on SAML request from the identity provider.\n\n## Management API\n\nThe Management API features several endpoints designed to help you manage SSO.\n\nTo call any of the Management API endpoints, you will need to [obtain an Access Token](https://auth0.com/docs/api/management/v2/tokens).\n\n### Clients\n\nAll of your client applications/SSO integrations feature information relevant to your SSO implementation. You can retrieve or change this information by calling one of the Clients endpoints.\n\nOf-interest parameters for each client include:\n\n*   `sso`: Flag applicable only for clients created via SSO integrations. If `true`, Auth0 handles SSO; if `false`, the IdP handles SSO.\n    \n*   `sso_disabled`: Flag used to enable/disable SSO. If `true`, then SSO is disabled; if `false`, SSO is enabled. This option can only be set via the Management API.\n    \n*   `app_type`: Application type. If the client was created using one of Auth0's built-in SSO integrations, the name of the SSO integration would be listed (e.g., `box` or `concur` instead of `native` or `spa`)\n    \n\n#### Get all clients\n\nThe [GET /api/v2/clients](https://auth0.com/docs/api/management/v2#!/Clients/get_clients) endpoint can be used to return information about the client applications you have configured for your tenant.\n\n#### Create a client\n\nThe [POST /api/v2/clients](https://auth0.com/docs/api/management/v2#!/Clients/post_clients) endpoint can be used to create a new client application.\n\n#### Get a client\n\nThe [GET /api/v2/clients/{id}](https://auth0.com/docs/api/management/v2#!/Clients/get_clients_by_id) endpoint can be used to return information about a specific client you have configured for your tenant.\n\n#### Update a client\n\nThe [PATCH /api/v2/clients/{id}](https://auth0.com/docs/api/management/v2#!/Clients/patch_clients_by_id) endpoint can be used to update a specific client, including its SSO-related parameters.\n\n### Tenants\n\nAuth0 allows you to control the following tenant-level parameters that may affect your SSO implementation:\n\n*   `session_lifetime`: Length of time for which the user's Auth0 session will stay valid.\n    \n*   `idle_session_lifetime`: Amount of time that may elapse before the user must sign in again due to inactivity.\n    \n\n### Get tenant settings\n\nThe [GET /api/v2/tenants/settings](https://auth0.com/docs/api/management/v2#!/Tenants/get_settings) endpoint retrieves the settings for your tenant.\n\n### Update tenant settings\n\nThe [POST /api/v2/connections](https://auth0.com/docs/api/management/v2#!/Tenants/patch_settings) endpoint allows you to update your tenant settings.\n\n## Learn more\n\n*   [Deprecation Errors](https://auth0.com/docs/troubleshoot/basic-issues/check-deprecation-errors)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)",
    "title": "API Endpoints for Single Sign-On",
    "description": "Describes Auth0 Authentication API and Management API endpoints relevant when implementing Single Sign-on (SSO).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/inbound-single-sign-on",
    "markdown": "# Service-Provider-Initiated Single Sign-On\n\nFor Service-Provider-initiated Single Sign-On (SSO) implementations, Auth0 is the SSO Service Provider (SP). When a user logs in to an application:\n\n1.  The application presents the user with one or more external Identity Providers (IdPs).\n    \n2.  The user selects an IdP to authenticate with and logs in.\n    \n3.  Upon successful authentication, the user is returned to the application with an active session.\n    \n\nSP-initiated SSO in Auth0 is handled by connections.\n\n## Auth0 SSO sessions vs. application sessions\n\nWhen users log in, various [session layers](https://auth0.com/docs/manage-users/sessions/session-layers) can be created. For SP-initiated SSO implementations, it's important to understand that the SSO experience is made possible by the Auth0 Session Layer, which is stored centrally on the Authorization Server. Leveraging this session layer, users can easily authenticate to different applications, each of which may have its own application session to track whether the user is logged in to it specifically.\n\n## Build your own implementations\n\n### OIDC/OAuth\n\n*   Social Identity Providers\n    \n*   Add a generic OAuth2 Authorization Server to Auth0\n    \n*   [Auth0 Marketplace](https://marketplace.auth0.com/)\n    \n\n### SAML\n\n*   Auth0 provides instructions to configure the following SAML IdPs with Auth0:\n    \n    *   [Okta](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-okta-as-saml-identity-provider)\n        \n    *   [OneLogin](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-onelogin-as-saml-identity-provider)\n        \n    *   [PingFederate 7](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-pingfederate-as-saml-identity-provider)\n        \n    *   [Salesforce](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-salesforce-as-saml-identity-provider)\n        \n    *   [SiteMinder](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-siteminder-as-saml-identity-provider)\n        \n    *   [SSOCircle](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-ssocircle-as-saml-identity-provider)\n        \n*   We also provide generic instructions to [configure Auth0 as a SAML service provider](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider).\n    \n*   [Configure Identity-Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/identity-provider-initiated-single-sign-on)\n    \n\n## Limitations\n\n*   Native applications can only use [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login).\n    \n*   OpenID Connect (OIDC) does not support IdP-initiated SSO.\n    \n\n## Learn more\n\n*   [Identity-Provider-Initiated Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on)\n*   [API Endpoints for Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on/api-endpoints-for-single-sign-on)\n*   [Troubleshoot SAML Configurations](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-saml-configurations)\n*   [Troubleshoot SAML Errors](https://auth0.com/docs/troubleshoot/authentication-issues/saml-errors)",
    "title": "Service-Provider-Initiated Single Sign-On",
    "description": "Overview of Single Sign-on (SSO) initiated by a Service Provider (SP).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/libraries/lock/lock-authentication-parameters",
    "markdown": "# Lock Authentication Parameters\n\nYou can send parameters when starting a login by adding them to the options object. The example below adds a `state` parameter with a value equal to `'foo'`.\n\n```\nvar options = {\n  auth: {\n    params: {state: 'foo'},\n  }\n};\n```\n\nThe above example would be analogous to triggering the login with `https://{yourDomain}/authorize?state=foo&...`.\n\nThe following parameters are supported: `scope`, `device`, `nonce` and `state`.\n\n## Supported parameters\n\n### scope {string}\n\n```\nvar options = {\n  auth: {\n    params: {scope: 'openid email user_metadata app_metadata picture'},\n  }\n};\n```\n\nThere are different values supported for scope. Keep in mind that JWTs are sent on every API request, so it is desirable to keep them as small as possible.\n\nThe default `scope` value in Lock is `openid profile email`. This minimum scope value is required to make the **Last time you logged in with** feature work correctly.\n\n#### Running Lock locally\n\nIf you don't manually specify at least the default scope of `openid profile email` when initializing Lock, and you are running your website from `http://localhost` or `http://127.0.0.1`, you will get the following error in the browser console:\n\n`Consent required. When using getSSOData, the user has to be authenticated with the following scope: openid profile email`\n\nThat will **not** happen when you run your application in production or if you specify the `openid profile email` scope. You can read more about this in the [User consent and third-party applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/user-consent-and-third-party-applications) document.\n\nFor more information about scopes, see the [scopes documentation page](https://auth0.com/docs/get-started/apis/scopes).\n\n#### Example: retrieve a token\n\nIn Lock, if you wish to receive a token with the ability to fetch the user's profile data, you should add the `scope` parameter.\n\n```\nvar options = {\n  auth: {\n    params: {\n        scope: 'openid profile'\n    }\n  }\n};\n```\n\nThere is also a `connectionScopes` configuration option for Lock, which allows you to specify scopes on any specific connection. This will be useful if you want to initially start with a set of scopes (defined on the dashboard), but later on request additional permissions or attributes from a specific connection. Read more about it on the [Lock Configuration Options](https://auth0.com/docs/libraries/lock/lock-configuration) page.\n\n### state {string}\n\nThe `state` parameter is an arbitrary state value that will be maintained across redirects. It is useful to mitigate [XSRF attacks](http://en.wikipedia.org/wiki/Cross-site_request_forgery) and for any contextual information, [such as a return url](https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout) that you might need after the authentication process is finished. If a custom state parameter is not provided, Lock will automatically generate one. For more information, see [State Parameter](https://auth0.com/docs/secure/attack-protection/state-parameters).\n\n### nonce {string}\n\nThe `nonce` parameter is used to help prevent replay attacks, and will be automatically generated by Lock if a custom value is not provided.\n\n### device {string}\n\nThe `device` parameter sets the name of the device or browser requesting authentication.",
    "title": "Lock Authentication Parameters",
    "description": "Lock documentation on setting authentication parameters.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/okta-access-gateway",
    "markdown": "# Okta Access Gateway\n\n**Okta Access Gateway (OAG)** is a solution designed to extend modern identity to legacy on-prem applications to protect your hybrid cloud. Now, you can easily set up Okta Access Gateway to use Auth0 as the identity provider to authenticate users and have Single Sign-On (SSO) when accessing on-prem applications. To learn more about setup, see the [Okta Access Gateway website](https://help.okta.com/oag/en-us/content/topics/access-gateway/ag-main.htm). \n\nAfter correctly setting up, you can view your OAG Applications as **SSO Integrations** on the Auth0 Dashboard.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/7fB4rjisMdL7nNcMrh1b0J/c250ef129d72952b71c2a0c17a2aa1a7/image1.png)",
    "title": "Okta Access Gateway",
    "description": "Overview of Okta Access Gateway (OAG). ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/authentication-methods",
    "markdown": "# Passwordless Authentication Methods\n\nWith Passwordless connections, users can log in without a password. Instead, they can use a variety of other authentication methods. Auth0 Passwordless connections support the following authentication methods:\n\n| Factor | Description |\n| --- | --- |\n| [Email](https://auth0.com/docs/connections/passwordless/authentication-methods/email-otp) | The user is asked to enter their email address, to which Auth0 sends a one-time-use code. The user enters the code into your application. |\n| [Magic Link](https://auth0.com/docs/connections/passwordless/authentication-methods/email-magic-link) | The user is asked to enter their email address, to which Auth0 sends an email with a link in it. The user clicks the link and is directly logged in to your application. |\n| [SMS](https://auth0.com/docs/connections/passwordless/authentication-methods/sms-otp) | The user is asked to enter their phone number, to which Auth0 sends a one-time-use code. By default, Auth0 uses Twilio to send the code, but if you have a custom SMS gateway, you can modify your connection to use that instead. |",
    "title": "Passwordless Authentication Methods",
    "description": "Describes the various authentication methods supported by Auth0 passwordless connections, including email, magic link, and SMS.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/implement-login",
    "markdown": "# Implement Login with Passwordless\n\nAuth0 supports two way of implementing authentication: Embedded Login and Universal Login.\n\nThe industry is aligned in that redirecting to the [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) page is the proper way to implement authentication in all apps, but in the case of Native Applications, sometimes customers prefer to implement Embedded Login for UX reasons.\n\nYou can review the article [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login) for more information to help you decide which solution is best option for your product and customers.\n\n## Learn more\n\n*   [Migrate from Embedded Login to Universal Login](https://auth0.com/docs/troubleshoot/product-lifecycle/past-migrations/migrate-from-embedded-login-to-universal-login)",
    "title": "Implement Login with Passwordless",
    "description": "Describes available login flows to implement via connections ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on",
    "markdown": "# Identity-Provider-Initiated Single Sign-On\n\nFor Identity-Provider-Initiated Single Sign-On (SSO), a third-party Identity Provider (IdP) is the SSO provider. When a user logs in to an application:\n\n1.  The application redirects the user to an identity provider.\n    \n2.  The third-party identity provider performs authentication and authorization.\n    \n3.  Upon successful authentication, the user is returned to the application.\n    \n\n## Pre-defined integrations\n\nAuth0 provides IdP-initiated [SSO Integrations](https://auth0.com/docs/customize/integrations/sso-integrations) for various services, like [Dropbox](https://marketplace.auth0.com/integrations/dropbox-sso), [Slack](https://marketplace.auth0.com/integrations/slack-sso), or [Zoom](https://marketplace.auth0.com/integrations/zoom-sso). To see the full list, explore [Auth0 Marketplace: SSO Integrations](https://marketplace.auth0.com/features/sso-integrations).\n\n## Build your own implementations\n\n## SAML\n\n*   [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings)\n    \n\n## OIDC\n\n*   [Configure Applications with OIDC Discovery](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery)",
    "title": "Identity-Provider-Initiated Single Sign-On",
    "description": "Overview of Single Sign-on (SSO) initiated by Identity Providers (IdPs).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/create-sso-dashboard-application",
    "markdown": "# Create Single Sign-on (SSO) Dashboard Application\n\nUse the Single Sign-On (SSO) Dashboard extension to manage SSO login for your users on multiple enterprise applications. To learn more, [view this extension on GitHub](https://github.com/auth0-extensions/auth0-sso-dashboard-extension).\n\n## Create Auth0 application\n\nBefore you [add the SSO Dashboard extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/install-sso-dashboard-extension), you need to create an application in Auth0:\n\n1.  Go to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and select **+Create Application**.\n    \n2.  Enter a descriptive name for your Application (for example, SSO Dashboard), select **Single-Page Web Application** for the **Application Type**, and then select **Create**.\n    \n3.  On the **Settings** tab, set the **Allowed Callback URLs** based on your tenant's region:\n    \n    1.  For **Admins**: `https://{yourTenant}.YOUR_REGION_KEY.webtask.io/auth0-sso-dashboard/admins/login`\n        \n    2.  For **Users**: `https://{yourTenant}.YOUR_REGION_KEY.webtask.io/auth0-sso-dashboard/login`\n        \n        | **Region** | **Region Key** |\n        | --- | --- |\n        | US-1 | `us12` |\n        | US-3 | `us` |\n        | EU  | `eu12` |\n        | AU  | `au12` |\n        | JP-1 | `jp` |\n        \n4.  Select and copy the **Client ID** value.\n    \n5.  Navigate to the bottom of the page, and then select **Advanced Settings**.\n    \n6.  Select the **OAuth** tab, and then paste the **Client ID** value into the **Allowed APPs / APIs** field.\n    \n7.  Set **JsonWebToken Signature Algorithm** to **RS256**.\n    \n8.  Select **Save Changes**.\n    \n\nBy default, all the connection types are enabled for users to be able to log into the SSO Dashboard. If you would like to change this, navigate to the **Connections** tab for the Application.\n\n## Install SSO Dashboard extension\n\nNext, you will need to [install the SSO Dashboard Extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/install-sso-dashboard-extension) and [add applications](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/add-applications-to-the-sso-dashboard) to the dashboard.\n\n## Learn more\n\n*   [Install Single Sign-On Dashboard Extension](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/install-sso-dashboard-extension)\n*   [Add Applications to Single Sign-On Dashboard](https://auth0.com/docs/customize/extensions/single-sign-on-dashboard-extension/add-applications-to-the-sso-dashboard)\n*   [Troubleshoot Extensions](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-extensions)\n*   [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on)\n*   [Sessions](https://auth0.com/docs/manage-users/sessions)\n*   [Logout](https://auth0.com/docs/authenticate/login/logout)",
    "title": "Create Single Sign-on (SSO) Dashboard Application",
    "description": "Describes how to create an application to use with the SSO Dashboard Extension to enable SSO login for your applications.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/passwordless-with-universal-login",
    "markdown": "# Passwordless with Universal Login\n\nThe Universal Login Experience supports [Passwordless connections](https://auth0.com/docs/authenticate/passwordless), which allow users to provide a phone number or email address, and then receive a one-time password (OTP) to complete authentication.\n\n## Enable Passwordless for Universal Login\n\nTo configure Universal Login to support Passwordless connections, you'll need to set the Authentication Profile to use a supported login flow, and update your application to specify the connection during authentication.\n\n### Enable Identifier First\n\nIn the Auth0 Dashboard, go to [Authentication > Authentication Profile.](https://manage.auth0.com/?/authentication-profiles)\n\nSelect either **Identifier First** or **Identifier First + Biometrics**.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/55saPRLPRJqFMxSjYo9Lvn/d85d8c11ac783efba56c2bd1cf8f377a/image-20221202-233952.png)\n\n### Update your application\n\nDepending on the type of connections you have enabled for your application, you may need to update your application to specify a Passwordless connection during login:\n\n| **Database connection** | **Passwordless connection** | **Need to specify?** | **User experience** |\n| --- | --- | --- | --- |\n| Yes | SMS and/or Email | Yes | Specified Passwordless connection is presented during login. |\n| No  | SMS and Email | No  | Passwordless connection that was created first is presented. |\n| No  | SMS or Email | No  | Passwordless connection is presented (along with any enabled Social connections) during login. |\n\nTo specify a Passwordless connection during login, you must pass the `connection` parameter and its value (either `sms` or `email`) to the [Auth0 Authentication API Login endpoint](https://auth0.com/docs/api/authentication#login):\n\n`https://mytenant.us.auth0.com/authorize?client_id={id}&``**connection={sms|email}**``&scope=…&response_type=code&response_mode=query&state=…&redirect_uri=http%3A%2F%2Flocalhost%3A3000&code_challenge=…`\n\nIf you are using one of our SDKs, you can specify a Passwordless connection during initialization. For example:\n\n```\nauth0 = await createAuth0Client({\n     domain: config.domain,\n     client_id: config.clientId,\n     connection: \"email\"\n  });\n\nauth0 = await createAuth0Client({\n     domain: config.domain,\n     client_id: config.clientId,\n     connection: \"sms\"\n  });\n```\n\n### Test the connection\n\nWhen the user is prompted to enter their OTP, they'll see one of the following screens:\n\n### Signup\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/6ABY0ul7dceiGcdRH7glm6/38dacdca6fe6b277cb4d3b3e14f38b09/Passwordless_SMS_Signup_Prompt.png)\n\n### Login\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/5xHAEaXgnS43Jpnju9FCzZ/79ac7d36abdb06d4ed7f636684a414eb/Passwordless_SMS_Login_Prompt.png)",
    "title": "Passwordless with Universal Login",
    "description": "The document announces support for Universal Login and Passwordless connections.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/sample-use-cases-rules",
    "markdown": "# Sample Use Cases - Rules with Passwordless Authentication\n\nWith [rules](https://auth0.com/docs/customize/rules), you can handle more complicated cases than is possible with [passwordless connections](https://auth0.com/docs/authenticate/passwordless) alone. For instance, you can add extra precautions to further ensure possession of an email address or device.\n\n## Require Multi-factor Authentication for users who are outside the corporate network\n\nLet's say you want to require [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) for any users who are accessing the application using a passwordless connection from outside your corporate network.\n\nUsing a rule, you can check whether a user is authenticating using a passwordless method (`sms`, `email`) and if their session IP falls outside of the designated corporate network, prompt them for a second authentication factor.\n\nTo do this, you would [create the following rule](https://auth0.com/docs/customize/rules/create-rules):\n\n```\nfunction(user, context, callback) {\n  const ipaddr = require('ipaddr.js');\n  const corp_network = \"192.168.1.134/26\";\n  const current_ip = ipaddr.parse(context.request.ip);\n  // is auth method passwordless and IP outside corp network?\n  const passwordlessOutside = context.authentication.methods.find(\n    (method) => (\n      ((method.name === 'sms') || (method.name === 'email')) && \n      (!current_ip.match(ipaddr.parseCIDR(corp_network)))\n    )\n  );\n\n  // if yes, then require MFA\n  if (passwordlessOutside) {\n    context.multifactor = {\n      provider: 'any',\n      allowRememberBrowser: false\n    };\n  }\n  callback(null, user, context);\n}\n```",
    "title": "Sample Use Cases - Rules with Passwordless Authentication",
    "description": "Explore examples using rules with passwordless connections.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics",
    "markdown": "# Configure WebAuthn with Device Biometrics for Passwordless Authentication\n\nYou can configure Universal Login to let users authenticate using [WebAuthn](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn) with Device Biometrics instead of a password.\n\nWebAuthn with Device Biometrics is the most secure and usable authentication factor that's available today, greatly reducing login friction without sacrificing security.\n\n## Prerequisite\n\nTo enable Passwordless with WebAuthn Device Biometrics, you need to:\n\n1.  Make sure the Universal Login experience is enabled and that the HTML for the login page is not customized in [Dashboard > Universal Login](https://manage.auth0.com/#/login_settings).\n    \n2.  Select **Identifier First + Biometrics** in the [Dashboard > Authentication Profile](https://manage.auth0.com/#/authentication-profiles). This will automatically [enable WebAuthn with Device Biometrics](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa) in the Multi-Factor authentication section if it is not enabled yet.\n    \n3.  If you use a [custom database connection](https://auth0.com/docs/authenticate/database-connections/custom-db), ensure **Import Mode** is set to **On.** If it's not, you can run the [getUser script](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user) to the same effect.\n    \n\n## How does it work\n\nUsers that authenticate with username/email and password and have a device that [is capable of using WebAuthn with Device Biometrics](https://webauthn.me/browser-support), are given the option of enrolling their device:\n\n![Example of setting up a Face ID login for specific domain using WebAuthn](https://images.ctfassets.net/cdy7uua7fh8z/1JfsIYEo3O7xmTAxLRwNSs/2f2ba478ff32b0aa86f4f01cd6c0cf3b/2023-01-31_16-34-09.png)\n\nAfter you enable the feature, we provide a few options for users on the Login Faster on This Device dialog box. Users can choose to enroll their device or skip enrollment to reduce the number of times they are prompted:\n\n| Option | Description |\n| --- | --- |\n| `Continue` | Prompts the user for Biometric Factor Enrollment |\n| `Remind me later` | Skips enrollment and prompts for enrollment again in two weeks |\n| `Not on this device` | Does not prompt enrollment for 1 year or as long as the Auth0 cookies are stored in the users' browser |\n\n![Login - webauthn biometrics - log in faster on this device](https://images.ctfassets.net/cdy7uua7fh8z/1w3jwsf0ihbTD0BNudRXN9/6ee65674ffa41e5e9537129bb3f98e79/2023-01-31_16-34-09.png)\n\nIf customers decide to enroll their device, the next time they authenticate from that device they'll be given the option of using their device biometrics or a password:\n\n![Example of using Fingerprint or Face Recognition to login to a domain](https://images.ctfassets.net/cdy7uua7fh8z/4DkewyodXBQ3gncybz7KPI/873d6a3eafb644ee605daa209006d1b3/Docs_Login.png)\n\nWe call this feature 'progressive enrollment', and it's designed to make the transition to WebAuthn-based authentication easy as possible for both developers and users.\n\n## Multi-Factor Authentication\n\nWebAuthn with Device Biometrics allows avoiding requiring another authentication method for performing multi-factor authentication. **WebAuthn with Device Biometrics combines two factors in one**: something you have (the device), and something you are (biometrics) or something you know (the passcode).\n\nThis has several consequences:\n\n*   When you enable MFA in the dashboard, Auth0 will not prompt for MFA if users authenticated with WebAuthn w/Biometrics as first factor.\n    \n*   When MFA is enabled and users create a new account, they will:\n    \n    *   Create a user with a username/password.\n        \n    *   Enroll in MFA, with a non-biometrics authentication method, so they can complete MFA on any device.\n        \n    *   Optionally enroll with Device Biometrics.\n        \n\nThe next time they log in, they can log in with password + another authentication method or with device biometrics.\n\n*   When users authenticate using WebAuthn Biometrics as their only authentication method, the `amr` value in the ID Token will be set to `mfa`.\n    \n*   If you want to enable MFA from our extensibility platform, you’ll be able to consider how users authenticated to decide if they should be prompted for MFA or not. The rule below will only perform MFA if the user did not authenticate with the `webauthn-platform` authentication method:\n    \n\n```\nfunction (user, context, callback) {\n  let authMethods = context.authentication.methods;\n\n  const amr = authMethods.find((method) => method.name === 'webauthn-platform');\n\n  if (!amr) {\n    context.multifactor = {\n      provider: 'any',\n      allowRememberBrowser: false\n    };\n  }\n  return callback(null, user, context);\n}\n```\n\nThis post-login action will have the same effect:\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n  let authMethods = event.authentication.methods;\n\n  let amr = authMethods.find((method) => method.name === 'webauthn-platform');\n\n   if (!amr) {\n     api.multifactor.enable('any');\n  }\n};\n```\n\n## Device Recognition\n\nAuth0 will use the rules to determine if the device is already enrolled or not, and prompt the user for enrollment. To learn more, read [Device recognition](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa#device-recognition) in the article [Configure WebAuthn with Device Biometrics for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa).\n\nTo avoid user enumeration attacks, Auth0 will only prompt users for biometrics as the first factor if users are logging in from a known device. If not, they'll need to login with the password.\n\nFor example:\n\n*   A user logs-in from Chrome in Windows, and is enrolled with Windows Hello. As part of the enrollment information, Auth0 knows that the user enrolled from a Windows device, and stores a 'known device' to recognize the user agent.\n    \n*   The next time the user logs in from Chrome, they will be prompted to use Windows Hello instead of a password.\n    \n*   If the user later logs in from Firefox in Windows, given the 'known device' cookie is not present, users will need to login with their password. As they are already enrolled with Windows Hello, they won't be prompted to enroll again.\n    \n*   The next time the user logs in from Firefox, they will be prompted to use Windows Hello.\n    \n\nThis will not let attackers know if users have an account or not, or if they used WebAuthn device biometrics to authenticate to the site.\n\n## Webauthn.me\n\nAuth0 maintains [webauthn.me](https://a0.to/webauthme-auth0-docs), which has [detailed information](https://webauthn.me/introduction) about WebAuthn and an up-to-date list of browsers supporting WebAuthn.\n\n## Learn more\n\n*   [Configure Universal Login with Passwordless](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login)\n*   [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms)\n*   [Configure WebAuthn with Device Biometrics for MFA](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa)\n*   [FIDO Authentication with WebAuthn](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn)",
    "title": "Configure WebAuthn with Device Biometrics for Passwordless Authentication",
    "description": "Learn how to configure WebAuthn with device biometrics for passwordless authentication.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/passwordless-connection-limitations",
    "markdown": "# Passwordless Connection Limitations\n\nThe type of authentication you want to use depends on which version of Universal Login you configured with your application. If you are using the Universal Login experience, you can set up [passwordless authentication using WebAuthN with Device Biometrics](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics) or use passwordless connections as described below.\n\nYou can set up email or SMS passwordless authentication using the following methods:\n\n1.  Universal Login + passwordless connection parameters\n    \n2.  Classic Login + Lock\n    \n3.  Classic Login + custom UI + Auth0.js\n    \n\nTo learn more about these implementations, read [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms).\n\n### Errors\n\nIf you are using an embedded login, we recommend using custom domains. To learn more, read [Custom Domains](https://auth0.com/docs/customize/custom-domains).\n\n## Considerations\n\n*   You cannot create passwordless users from the Auth0 Dashboard. Create them directly from the [Management API](https://auth0.com/docs/api/management/v2#!/Users/post_users).\n    \n*   Refresh tokens cannot be retrieved when using a passwordless magic link via email, only an OTP.\n    \n\n## Learn more\n\n*   [Passwordless Connections](https://auth0.com/docs/authenticate/passwordless)",
    "title": "Passwordless Connection Limitations",
    "description": "Describes some limitations to using passwordless connections.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/authentication-methods/email-otp",
    "markdown": "# Passwordless Authentication with Email\n\nYou can configure a Passwordless connection to send a one-time password (OTP) to a user through email to complete authentication.\n\nTo learn more, read [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms).\n\n## How it works\n\nWhen a new user receives an OTP and enters it for the first time on your website, their user profile is created on the `email` connection before being authenticated by Auth0.\n\nIf the email address that the OTP was sent to matches an existing user, Auth0 authenticates the user:\n\n### Embedded Login\n\n![Passwordless email workflow diagram with embedded login](https://images.ctfassets.net/cdy7uua7fh8z/3HMLxPTq9eCsq1eR21s0bL/52eaf41d7cf14539ec476b7ee17d64e3/SMS_Email_Flow.png)\n\n### Universal Login\n\n![Passwordless email workflow diagram with universal login](https://images.ctfassets.net/cdy7uua7fh8z/5p3cKrJwmc7MxpQ7pbXsjC/b180e3be9469e634264d2d7f32e32651/Universal_Login.png)\n\n## Configure the connection\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Passwordless](https://manage.auth0.com/#/connections/passwordless), and enable the **Email** toggle.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/6ghwbvjgEt0pyqyJmt871T/12f0110b0f20148eb68a7b267175eb11/connections-passwordless-list.png)\n2.  Select **Email** to open the configuration window, switch to the **Settings** view, and then enter your email's **From**, **Subject**, and **Message** text.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/1seXVjFNAcvKL9KX6fPppQ/0ff58acc4cde37af61b27756d62443fb/dashboard-passwordless-email.png)\n3.  Configure **OTP Expiry** and **OTP Length.**\n    \n    *   Only the last OTP (or link) issued will be accepted. Once the latest one is issued, any others are invalidated. Once used, the latest one is also invalidated.\n        \n    *   Only three failed attempts to input the OTP are allowed. After this, a new code will need to be requested.\n        \n    *   The OTP issued will be valid (by default) for three minutes before it expires.\n        \n    *   If you choose to extend the amount of time it takes for your OTP to expire, you should also extend the length of the OTP. Otherwise, an attacker has a larger window of time to attempt to guess a short code.\n        \n4.  Decide if you want to **Disable Sign Ups**. If you enable this setting, you can allow passwordless access for only existing users, but may expose your application to the threat of user enumeration attacks. To learn more, read [Passwordless Connections Best Practices](https://auth0.com/docs/authenticate/passwordless/best-practices).\n    \n5.  Select **Save**.\n    \n\n### Multi-language support\n\nThe **Message** area supports multiple languages.\n\nTo specify a language, call the [Auth0 Authentication API Get Code or Link endpoint](https://auth0.com/docs/api/authentication#get-code-or-link) and set the value of the `x-request-language` header. When this header is not set, the language is extracted from the `accept-language` header, which is automatically set by the browser.\n\n### Message syntax\n\nThe **Message** area accepts Liquid syntax. You can use this syntax, combined with parameter values, to programmatically construct elements of the message.\n\nFor example, you can reference the `request_language` parameter to change the language of the message:\n\n```\n{% if request_language contains 'dutch' %}\n   Hier is uw verificatie code: {{ code }}\n{% endif %}\n{% if request_language contains 'fr-FR' %}\n   Ceci est votre code: {{ code }}\n{% endif %}\n```\n\nThe following parameters are available when defining the message template:\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `code` | The password to use. |\n| `link` | The generated sign-in link. |\n| `application.name` | The name of the application with which the user is signing up. |\n| `request_language` | The requested language for message content. |\n| `operation` | Indicates when the template has been triggered by an update to a user's email through the API. When triggered, the value is `change_email`, otherwise it is `null`. |\n\nIf the user is logged in through an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview), the following parameters are also available:\n\n*   `organization.id`\n    \n*   `organization.display_name`\n    \n*   `organization.name`\n    \n*   `organization.metadata`\n    \n*   `organization.branding.logo_url`\n    \n*   `organization.branding.colors.primary`\n    \n*   `organization.branding.colors.page_background`\n    \n\nFor more information on these parameters and their values, read the Auth0 Management API [Get organization](https://auth0.com/docs/api/management/v2#!/Organizations/get_organizations_by_id) endpoint.\n\n## Enable applications\n\nSwitch to the **Applications** view, and enable the applications for which you would like to use Passwordless Email.\n\n## Email providers\n\nAuth0 sends emails from its own SMTP provider by default. Auth0's built-in email provider is designed solely for testing purposes and does not support customization of email templates.\n\n[Configure your own SMTP email provider](https://auth0.com/docs/customize/email/smtp-email-providers) to manage, monitor, and troubleshoot your email communications, and customize email templates.\n\nAuth0 supports the following email providers:\n\n*   [Mandrill](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mandrill-as-external-smtp-email-provider)\n    \n*   [Amazon SES](https://auth0.com/docs/customize/email/smtp-email-providers/configure-amazon-ses-as-external-smtp-email-provider)\n    \n*   [Azure Communication Services](https://auth0.com/docs/customize/email/smtp-email-providers/configure-azure-comm-service-as-smtp-email-provider)\n    \n*   [SendGrid](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sendgrid-as-external-smtp-email-provider)\n    \n*   [SparkPost](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sparkpost-as-external-smtp-email-provider)\n    \n*   [Mailgun](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mailgun-as-external-smtp-email-provider)\n    \n*   [Custom SMTP external email provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider)",
    "title": "Passwordless Authentication with Email",
    "description": "Learn how how to use Passwordless connections with the email authentication factor.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/authentication-methods/sms-otp",
    "markdown": "# Passwordless Authentication with SMS\n\nYou can configure a Passwordless connection to send a one-time password (OTP) to a user through SMS to complete authentication.\n\nTo learn more, read [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms).\n\nAuth0 supports using [Twilio](https://www.twilio.com/) and custom SMS gateways to send OTPs. If you would like to use a custom SMS gateway, read [Set Up Custom SMS Gateway for Passwordless Connections](https://auth0.com/docs/authenticate/passwordless/authentication-methods/use-sms-gateway-passwordless).\n\n## How it works\n\nWhen a new user receives a code and enters it for the first time in your application, their user profile is created on the `sms` connection before being authenticated by Auth0.\n\nIf the phone number that the OTP was sent to matches an existing user, Auth0 authenticates the user:\n\n### Embedded Login\n\n![SMS workflow for passwordless authentication](https://images.ctfassets.net/cdy7uua7fh8z/7A1AOmvvAQXheVt9swOtqM/43742694a9005b99e84975633d481e14/SMS_Email_Flow.png)\n\n### Universal Login\n\n![Passwordless email workflow diagram with universal login](https://images.ctfassets.net/cdy7uua7fh8z/5p3cKrJwmc7MxpQ7pbXsjC/b180e3be9469e634264d2d7f32e32651/Universal_Login.png)\n\n## Configure the connection\n\n1.  In the Auth0 Dashboard, go to [Authentication > Passwordless](https://manage.auth0.com/#/connections/passwordless), and then enable the **SMS** toggle.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/6ghwbvjgEt0pyqyJmt871T/12f0110b0f20148eb68a7b267175eb11/connections-passwordless-list.png)\n2.  Select **SMS** to open the configuration window.\n    \n\n### Configure Twilio settings\n\nYou will need a [Twilio Account SID](https://www.twilio.com/docs/glossary/what-is-a-sid) and a [Twilio Auth Token](https://www.twilio.com/help/faq/twilio-basics/what-is-the-auth-token-and-how-can-i-change-it). These are the Twilio API credentials that Auth0 will use to send an SMS to the user.\n\n1.  Enter your **Twilio Account SID** and **Twilio Auth Token.**\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/7fBmOsNz47vBq8LO8mXxZn/662926055e5c381164c74376a8c96cbc/connections-passwordless-sms_2.png)\n2.  Select the **SMS Source,** and then enter either your **Twilio Messaging Service SID** or a **From** phone number. Users will see what you enter as the sender of the SMS.\n    \n\n### Configure a custom SMS gateway\n\nIf you would like to use your own SMS gateway, you will need to create the passwordless connection and then modify it using the Auth0 Management API. To learn more, read [Set Up Custom SMS Gateway for Passwordless Connections](https://auth0.com/docs/authenticate/passwordless/authentication-methods/use-sms-gateway-passwordless).\n\n### Configure Passwordless SMS settings\n\n1.  In **Message**, enter the body text of the SMS.\n    \n2.  Adjust settings for your **OTP Expiry** and **OTP Length**.\n    \n    *   Only the last one-time password (or link) issued will be accepted. Once the latest one is issued, any others are invalidated. Once used, the latest one is also invalidated.\n        \n    *   Only three failed attempts to input the one-time password are allowed. After this, a new code will need to be requested.\n        \n    *   The one-time password issued will be valid (by default) for three minutes before it expires.\n        \n    *   If you choose to extend the amount of time it takes for your one-time password to expire, you should also extend the length of the one-time password code. Otherwise, an attacker has a larger window of time to attempt to guess a short code.\n        \n3.  Decide if you want to **Disable Sign Ups**. If you enable this setting, you can allow passwordless access for only existing users, but may expose your application to the threat of user enumeration attacks. To learn more, read [Passwordless Connections Best Practices](https://auth0.com/docs/authenticate/passwordless/best-practices).\n    \n4.  Select **Save**.\n    \n\n#### Multi-language support\n\nThe **Message** area supports multiple languages.\n\nTo specify a language, call the [Auth0 Authentication API Get Code or Link endpoint](https://auth0.com/docs/api/authentication#get-code-or-link) and set the value of the `x-request-language` header. When this header is not set, the language is extracted from the `accept-language` header, which is automatically set by the browser.\n\n#### Message syntax\n\nThe **Message** area accepts Liquid syntax. You can use this syntax, combined with parameter values, to programmatically construct elements of the message.\n\nFor example, you can reference the `request_language` parameter to change the language of the message:\n\n```\n{% if request_language contains 'dutch' %}\n   Hier is uw verificatie code: {{ password }}\n{% endif %}\n{% if request_language contains 'fr-FR' %}\n   Ceci est votre code: {{ password }}\n{% endif %}\n```\n\nThe following parameters are available when defining the message template:\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `password` or `code` | The password to use. |\n| `phone_number` | The user's phone number. |\n| `application.name` | The name of the application with which the user is signing up. |\n| `request_language` | The requested language for message content. |\n\nTo learn more about using Liquid, read [Liquid for Designers on GitHub](https://github.com/Shopify/liquid/wiki/Liquid-for-Designers).\n\n### Enable applications\n\nSwitch to the **Applications** view, and enable the applications for which you would like to use Passwordless SMS.",
    "title": "Passwordless Authentication with SMS",
    "description": "Learn how to use Passwordless connections with the SMS authentication method.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/best-practices",
    "markdown": "# Passwordless Connections Best Practices\n\n## Implement login\n\nYou can implement Passwordless authentication by redirecting to Auth0's Universal Login or by embedding login in your application. We always recommend that you implement Universal Login. To learn why, read [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login).\n\nTo learn how to implement Passwordless authentication, read the following articles:\n\n*   [Passwordless with Universal Login](https://auth0.com/docs/authenticate/passwordless/passwordless-with-universal-login)\n    \n*   [Passwordless Authentication with Universal Login](https://auth0.com/docs/authenticate/passwordless/implement-login/universal-login)\n    \n*   [Passwordless Authentication with Embedded Login](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login)\n    \n\n## Use SMS and email as authentication factors\n\nAuth0's passwordless implementation enables authenticating users with a single factor. That single factor can be one-time-use code sent by email or SMS, or a magic link sent by email.\n\nAlthough using email or SMS can be more secure than a weak password, both have known issues:\n\n*   Phone numbers are not sufficient for user authentication. The [SS7 phone routing system used by cellular networks has verified weaknesses](https://thehackernews.com/2017/05/ss7-vulnerability-bank-hacking.html) which have led to it not being recommended as an authentication factor. There are many attack vectors available, ranging from the use of social engineering, to swapping SIM cards and buying access to the SS7 network.\n    \n*   Email address possession is not sufficient for user authentication (aliases, forwarding, multiple users in one account are all examples). Email providers vary in their security practices and some do not require any establishment of a user's identity. SMTP is a very old protocol, and many providers still route SMTP traffic unencrypted leading to an increased chance of an interception attack.\n    \n\nFor these reasons, we recommend that if you use passwordless authentication, you also implement [Multi-factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication) with a different factor when the user performs a security-sensitive operation.\n\n## Prevent phishing attacks\n\nAn example of what a possible phishing attack could look like is as follows:\n\n1.  The user clicks a link in a malicious email or website.\n    \n2.  The user lands on the attacker's fake site, where they are prompted to enter their phone number to authenticate.\n    \n3.  The user enters their phone number, and the attacker enters the same phone number in the legitimate application.\n    \n4.  The legitimate application sends an SMS to the user.\n    \n5.  The user types the one-time-use code in the attacker's website.\n    \n6.  The attacker can now log in to the legitimate website.\n    \n\nTo decrease the chances of success for this attack, the user should expect that the SMS clearly identifies the application. You should configure the SMS template so it mentions the tenant name and/or the Application Name:\n\n```\nYour verification code for accessing's Acme @@application.name@@ is @@code@@\n```\n\n## Prevent brute force attacks\n\nAuth0 has the following protections against brute force attacks:\n\n*   Only the most recent one-time-use code (or link) issued will be accepted. Once the latest one is issued, any others are invalidated. Once used, the latest one is also invalidated.\n    \n*   Only three failed attempts to input any single one-time-use code are allowed. After this, a new code will need to be requested.\n    \n*   The one-time-use code issued will be valid for three minutes (by default) before it expires.\n    \n*   If a passwordless user has been blocked [administratively](https://auth0.com/docs/manage-users/user-accounts/block-and-unblock-users), Auth0 will not send any OTP codes over SMS or email until the user is unblocked. This behavior protects your SMS and email providers from receiving unnecessary requests.\n    \n\nThe one-time-use code expiration time can be altered at [Auth0 Dashboard > Authentication > Passwordless](https://manage.auth0.com/#/connections/passwordless).\n\n## Prevent user enumeration attacks\n\nUser enumeration is when a malicious actor uses brute-force techniques to either guess or confirm valid users in a system.\n\nWhen **Disable Sign Ups** is enabled, your application may become vulnerable to user enumeration attacks. Auth0 recommends that you do not enable this setting to ensure the maximum security of your application and its users.\n\nIf you do enable **Disable Signs Ups**, [Brute-force Protection](https://auth0.com/docs/secure/attack-protection/brute-force-protection) may mitigate the threat of some of these attacks, but it does not fully protect your application.\n\n## Link accounts\n\nUsers might want to authenticate using different passwordless factors during their lifetime. For example, they could initially sign up with an SMS, and later start authenticating with an email. You can achieve that by enabling them to link their different profiles using [account linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking/link-user-accounts).\n\nThe `/passwordless/start` endpoint has a [rate limit](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy) of 50 requests per hour per IP address. If you call the API from the server-side, your backend's IP may easily hit these rate limits. To learn how to address this issue, read the Rate Limiting in Passwordless Endpoints section of [Using Passwordless APIs](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/relevant-api-endpoints).",
    "title": "Passwordless Connections Best Practices",
    "description": "Learn about best practices when working with Passwordless connections.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/relevant-api-endpoints",
    "markdown": "# Using Passwordless APIs\n\nPasswordless APIs can be used in two scenarios:\n\n*   When implementing Universal Login and you want to customize the login page using auth0.js to interact with Auth0.\n    \n*   When you want to embed the login flow in your application.\n    \n\nIf you decide to embed login, please make sure you [understand the security implications](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login).\n\nTo learn more about how to implement Passwordless for Universal Login and Embedded login for different scenarios, read [Passwordless Authentication with Universal Login](https://auth0.com/docs/authenticate/passwordless/implement-login/universal-login) or [Passwordless Authentication with Embedded Login](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login).\n\n## Passwordless endpoints\n\n### POST /passwordless/start\n\nThe [POST /passwordless/start](https://auth0.com/docs/api/authentication#get-code-or-link) endpoint can be called to begin the Passwordless authentication process for both Classic Login and Embedded Login.\n\nDepending on the parameters provided to the endpoint, Auth0 begins the user verification process by sending one of the following:\n\n*   A single-use code via email or SMS message\n    \n*   A single-use link via email\n    \n\nThe API call must have the following structure:\n\n```\nPOST https://{yourDomain}/passwordless/start\nContent-Type: application/json\n{\n  \"client_id\": \"{yourClientID}\",\n  \"client_secret\": \"{yourClientSecret}\", // For Regular Web Applications\n  \"connection\": \"email|sms\",\n  \"email\": \"{email}\", //set for connection=email\n  \"phone_number\": \"{phoneNumber}\", //set for connection=sms\n  \"send\": \"link|code\", //if left null defaults to link\n  \"authParams\": { // any authentication parameters that you would like to add\n    \"scope\": \"openid\",     // used when asking for a magic link\n    \"state\": \"{yourState}\"  // used when asking for a magic link, or from the custom login page\n  }\n}\n```\n\nIf you use a magic link, users will receive a link generated by the Authentication API. Users will select the link and trigger a call to {`yourAuth0Tenant}.auth0.com/passwordless/verify-redirect`. Auth0 will redirect the user to the application, and the user will be logged in.\n\nIf you use a code, your application will need to prompt for that code, and then you should use the `/oauth/token` endpoint, or the `passwordlessLogin` method in the Auth0.js SDK to exchange that code for authentication tokens.\n\n### POST /oauth/token\n\nIf you are implementing passwordless for Native Applications or Regular Web Applications, you need to use `/oauth/token` to exchange the OTP code for authentication tokens. You cannot use this endpoint from Single Page Applications.\n\nTo achieve this you first need to enable the **Passwordless OTP** grant for your application at [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications) in your application's settings under **Advanced Settings** > **Grant Types**.\n\nThe user will receive the OTP code and your Native or Web application will prompt the user for it. When the user enters the code, you can complete the authentication flow by calling the `/oauth/token` endpoint with the following parameters:\n\n```\nPOST https://{yourAuth0Domain}/oauth/token\nContent-Type: application/json\n{\n  \"grant_type\" : \"http://auth0.com/oauth/grant-type/passwordless/otp\",\n  \"client_id\": \"{yourAuth0ClientID}\",\n  \"client_secret\": \"{yourClientSecret}\", // only for web apps, native apps don’t have a client secret\n  \"username\":\"<email address>\", // or \"<phone number>\"\n  \"otp\": \"CODE\",\n  \"realm\": \"email\", // or \"sms\" \n  \"audience\" : \"your-api-audience\", // in case you need an access token for a specific API\n  \"scope\": \"openid profile email\" // whatever scopes you need\n}\n```\n\nIf all goes well, Auth0 will return a response similar to the following:\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n{\n\"access_token\":\"eyJz93a...k4laUWw\",\n\"refresh_token\":\"GEbRxBN...edjnXbL\",\n\"id_token\":\"eyJ0XAi...4faeEoQ\",\n\"token_type\":\"Bearer\",\n\"expires_in\":86400\n}\n```\n\nYou can then decode the ID Token to get information about the user, or use the Access Token to call your API as normal.\n\n## Using Auth0.js\n\nWhen implementing Passwordless Authentication in Single Page Applications or in a customized Universal Login page, you should [use Auth0.js and the included passwordlessLogin method](https://auth0.com/docs/libraries/auth0js). The implementation is complex, so we recommend that you use the library instead of calling the APIs directly.\n\n## Rate limiting in passwordless endpoints\n\nAuth0 rate limits and attack protection features only consider the IP from the machine that is making the API call. When the API call is made from a backend server, you usually want Auth0 to consider the IP from the end user, not the one from the server.\n\nAuth0 supports specifying an `auth0-forwarded-for` header in API calls, but it is only considered when:\n\n*   the API call is made for a confidential application.\n    \n*   the API call includes the client secret.\n    \n*   the **Trust Token Endpoint IP Header** toggle is on.\n    \n\nFor a complete explanation, read [Avoid Common Issues with Resource Owner Password Flow and Attack Protection](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection).",
    "title": "Using Passwordless APIs",
    "description": "Describes how to implement Passwordless authentication using Auth0 APIs.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login",
    "markdown": "# Passwordless Authentication with Embedded Login\n\nIf you need to embed the login user interface in your application, you can do it by using our [Embedded Passwordless API](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/relevant-api-endpoints) or our SDKs.\n\nDepending on the kind of application you want to build, you'll need to implement it differently:\n\n*   For Single Page Applications (SPAs) (for example, Angular or React), read [Embedded Passwordless Authentication for Single-page Applications (SPA)](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/spa).\n    \n*   For Native applications (for example, iOS, Android, or desktop applications), read [Embedded Passwordless Login in Native Applications](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/native).\n    \n*   For Regular Web Applications (for example, NodeJS, Java, Rails, or .NET), read [Embedded Passwordless Login in Regular Web Applications](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/webapps).\n    \n\nHowever, embedded logins in web apps with Auth0 use cross-origin authentication, which is not our recommendation. To learn more, read [Cross-Origin Authentication](https://auth0.com/docs/authenticate/login/cross-origin-authentication).\n\n## Learn more\n\n*   [Passwordless Connections](https://auth0.com/docs/authenticate/passwordless)\n*   [Passwordless Connections Best Practices](https://auth0.com/docs/authenticate/passwordless/best-practices)\n*   [Using Passwordless APIs](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login/relevant-api-endpoints)",
    "title": "Passwordless Authentication with Embedded Login",
    "description": "Describes how to implement Passwordless authentication with Universal Login.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/implement-login/universal-login",
    "markdown": "# Passwordless Authentication with Universal Login\n\n[Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) is Auth0's implementation of the login flow. Each time a user needs to prove their identity, your applications redirect to Universal Login and Auth0 will do what is needed to guarantee the user's identity. It's the preferred way to implement Passwordless Authentication.\n\nTo implement Passwordless Authentication in Universal Login you need to customize the login page's HTML.\n\n1.  Go to [Dashboard > Branding > Universal Login](https://manage.auth0.com/#/login_settings) and click **Advanced Options**.\n    \n\n![Screenshot: Passwordless Authentication with Universal Login](https://images.ctfassets.net/cdy7uua7fh8z/3KLxperY1ZgUkkD2FMQ6Yw/cb5c9a709bb6ace14669c1fabee1b8f7/manage.auth0.com_dashboard_us_pavo_universal-login_customizations-new.png)\n\n2\\. Click the **Login** tab, then enable the **Customize Login Page** toggle.\n\n![Custom Login](https://images.ctfassets.net/cdy7uua7fh8z/5iwLcz2O100hLuxlKN4rSs/e4f35f8c44516b98b3584d56bcaac12d/manage.auth0.com_dashboard_us_pavo_login_page__2_.png)\n\n3\\. From the Default Template drop-down menu, choose the **Custom Login Form** template. The HTML template will update with code using CSS and the Auth0.js SDK.\n\n4\\. Use HTML and CSS to customize the template to your specifications, and click **Save Changes**. To learn more about how to use the Auth0.js SDK with the **Custom Login Form** template, see [Auth0.js SDK](https://auth0.com/docs/libraries/auth0js).\n\n5\\. Select the **Preview** tab to review your changes. Make sure to select the correct application for which you want to preview the login page.\n\nTo integrate Universal Login in your application, please refer to our [Quickstarts](https://auth0.com/docs/quickstarts), where you'll find complete examples for all application types and popular platforms.\n\n## Learn more\n\n*   [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login)\n*   [Customize](https://auth0.com/docs/customize)",
    "title": "Passwordless Authentication with Universal Login",
    "description": "Describes how to implement Passwordless authentication with Universal Login.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/okta",
    "markdown": "# Connect Your Auth0 Application with Okta Workforce Enterprise Connection\n\nIf your Auth0 domain name is not shown above and you are not using our [custom domains](https://auth0.com/docs/customize/custom-domains) feature, your domain name is a concatenation of your tenant name, your regional subdomain, and `auth0.com`, separated by the dot (`.`) symbol.\n\nFor example, if your tenant name is `exampleco-enterprises`, and your tenant is in the US region, your Auth0 domain name would be `exampleco-enterprises.us.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.us.auth0.com/login/callback`.\n\nHowever, if your tenant is in the US region and was created before June 2020, then your Auth0 domain name would be `exampleco-enterprises.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.auth0.com/login/callback`.\n\nIf you are using [custom domains](https://auth0.com/docs/customize/custom-domains), your **Redirect URI** would be `https://<YOUR CUSTOM DOMAIN>/login/callback`.",
    "title": "Connect Your Auth0 Application with Okta Workforce Enterprise Connection",
    "description": "Learn how to connect to Okta Workforce Identity Cloud as an OpenID Connect (OIDC) Identity Provider using an enterprise connection.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/passwordless/authentication-methods/email-magic-link",
    "markdown": "# Passwordless Authentication with Magic Links\n\nYou can configure a Passwordless connection to send a Magic Link to a user through email to complete authentication.\n\nTo learn more, read [Configure Email or SMS for Passwordless Authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/email-or-sms).\n\n## How it works\n\nWhen a user opens a Magic Link, Auth0 logs them in directly. It is similar in function to them receiving an email with a one-time password (OTP), returning to your application, and entering the OTP, but without having to actually perform those steps.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/5VsqHQRwtHwT7rx0aiUCP6/5f3a728423cd1114c1c72f1041e969b6/passwordless-email-receive-link.png)\n\n### Limitations\n\nMagic Links are not supported for Universal Login.\n\nWhen using Magic Links with Classic Login, both the initial request and its response must take place in the same browser or the transaction will fail. This is particularly relevant for iOS users, who cannot change their default web browser.\n\nFor example, the user might make the initial request using the Chrome browser, but when the user opens the Magic Link in their email, iOS automatically opens it in Safari (the default browser). If this happens, the transaction will fail.\n\n### Classic Login flow with Magic Links\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/yYsZhaG5uzmVg1MwVCRix/0b735f499987539856fa9a251e2b09d1/Magic_Link_Flow.png)\n\nThe user then clicks the button or link in the email and is automatically signed in to your application.\n\n## Configure the connection\n\n1.  In the Auth0 Dashboard, go to [Authentication > Passwordless](https://manage.auth0.com/#/connections/passwordless), and then enable the **Email** toggle.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/6ghwbvjgEt0pyqyJmt871T/12f0110b0f20148eb68a7b267175eb11/connections-passwordless-list.png)\n2.  Select **Email** to open the configuration window, switch to the **Settings** view, and enter your email's **From**, **Subject**, and **Message** text.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/1seXVjFNAcvKL9KX6fPppQ/0ff58acc4cde37af61b27756d62443fb/dashboard-passwordless-email.png)\n3.  Enter any **Authentication Parameters** you would like to include in the generated sign-in link.\n    \n4.  Decide if you want to **Disable Sign Ups**. If you enable this setting, you can allow passwordless access for only existing users, but may expose your application to the threat of user enumeration attacks. To learn more, read [Passwordless Connections Best Practices](https://auth0.com/docs/authenticate/passwordless/best-practices).\n    \n5.  Select **Save**.\n    \n\n### Multi-language support\n\nThe **Message** area supports multiple languages.\n\nTo specify a language, call the [Auth0 Authentication API Get Code or Link endpoint](https://auth0.com/docs/api/authentication#get-code-or-link) and set the value of the `x-request-language` header. When this header is not set, the language is extracted from the `accept-language` header, which is automatically set by the browser.\n\n### Message syntax\n\nThe **Message** area accepts Liquid syntax. You can use this syntax, combined with parameter values, to programmatically construct elements of the message.\n\nFor example, you can reference the `request_language` parameter to change the language of the message:\n\n```\n{% if request_language contains 'dutch' %}\n   Hier is uw verificatie code: {{ code }}\n{% endif %}\n{% if request_language contains 'fr-FR' %}\n   Ceci est votre code: {{ code }}\n{% endif %}\n```\n\nThe following parameters are available when defining the message template:\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `code` | The password to use. |\n| `link` | The generated sign-in link. |\n| `application.name` | The name of the application with which the user is signing up. |\n| `request_language` | The requested language for message content. |\n| `operation` | Indicates when the template has been triggered by an update to a user's email through the API. When triggered, the value is `change_email`, otherwise it is `null`. |\n\n## Update Classic Login settings\n\nIf you are using Classic Login for your application, you must update the page template to implement Magic Links.\n\n1.  In the Auth0 Dashboard, go to [**Branding > Universal Login > Advanced Options**](https://manage.auth0.com/#/login_settings).\n    \n2.  Switch to the **Login** view, locate the **Default Templates** dropdown, and select **Lock (passwordless).**\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/3PvZFpAUrtaMaq5A2Xi22c/c09dd8a9e34a26a95c574f76128279b5/2022-09-22_14-51-38.png)\n3.  Next, update the `Auth0LockPasswordless` section of code with a new parameter. Add the `passwordlessMethod` to your template.\n    \n    ```\n    passwordlessMethod: 'link',\n    ```\n    \n4.  Select **Save**.\n    \n\nTo learn more about embedded login configuration options, read [Passwordless Authentication with Embedded Login](https://auth0.com/docs/authenticate/passwordless/implement-login/embedded-login).\n\n## Enable applications\n\nSwitch to the **Applications** view, and enable the applications for which you would like to use Passwordless Email.\n\n## Email providers\n\nAuth0 sends emails from its own SMTP provider by default. Auth0's built-in email provider is designed solely for testing purposes and does not support customization of email templates.\n\n[Configure your own SMTP email provider](https://auth0.com/docs/customize/email/smtp-email-providers) to manage, monitor, and troubleshoot your email communications, and customize email templates.\n\nAuth0 supports the following email providers:\n\n*   [Mandrill](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mandrill-as-external-smtp-email-provider)\n    \n*   [Amazon SES](https://auth0.com/docs/customize/email/smtp-email-providers/configure-amazon-ses-as-external-smtp-email-provider)\n    \n*   [SendGrid](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sendgrid-as-external-smtp-email-provider)\n    \n*   [SparkPost](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sparkpost-as-external-smtp-email-provider)\n    \n*   [Mailgun](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mailgun-as-external-smtp-email-provider)\n    \n*   [Custom SMTP external email provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider)",
    "title": "Passwordless Authentication with Magic Links",
    "description": "Learn how to use Passwordless connections with the magic link authentication factor.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections",
    "markdown": "# Test Enterprise Connections\n\nYou can test enterprise connections for applications using Auth0's Dashboard.\n\nTo properly test, you should have already [set up your enterprise connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections).\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select the connection type to view.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Select the **Try** arrow next to the connection you want to test.\n    \n    ![Dashboard - Connections - Enterprise - AD/LDAP - List](https://images.ctfassets.net/cdy7uua7fh8z/1sxfMEARFGmA6cPMlWkx3c/24224f426feac774b7278a2a8bbdf162/dashboard-connections-enterprise-adldap-list_ssl.png)\n3.  Log in and consent to allow access to your app. If you have configured everything correctly, you will see the **It Works!** page.\n    \n    ![Dashboard - Connections - Database - Try - Success](https://images.ctfassets.net/cdy7uua7fh8z/5DWJWLf8zvZJH0rSlhK0cr/f33377edf6f82f17e11e08ec30d8d75a/connection-social-try-success.png)",
    "title": "Test Enterprise Connections",
    "description": "Learn how to test enterprise connections for applications using the Auth Dashboard.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections",
    "markdown": "# Enable Enterprise Connections\n\nYou can enable enterprise connections for applications using the Auth0 Dashboard. To enable your enterprise connection, you should have already set it up.\n\n1.  Go to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), and select the connection type to view.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Select the name of the connection to view.\n    \n    ![Dashboard - Connections - Enterprise - AD/LDAP - List](https://images.ctfassets.net/cdy7uua7fh8z/1sxfMEARFGmA6cPMlWkx3c/24224f426feac774b7278a2a8bbdf162/dashboard-connections-enterprise-adldap-list_ssl.png)\n3.  Select the **Applications** view, and enable or disable the connection for the appropriate application(s).\n    \n    ![Dashboard - Connections - Enterprise - Applications](https://images.ctfassets.net/cdy7uua7fh8z/2Jwoyem76rmja1sveD88It/d66bca3bcd05d50f7cd85f772bf18a53/dashboard-connections-enterprise-adldap-edit_view-connections_ssl.png)\n\nWhen you set up your enterprise IdP connection, remember that the `connection` parameter passed to Auth0's `/authorize,` `/whr,` or `/wsfed` endpoint will redirect to the upstream IdP **unless** it's connected via database or Active Directory.\n\n## Learn more\n\n*   [Test Enterprise Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections)",
    "title": "Enable Enterprise Connections",
    "description": "Describes how to enable enterprise connections for applications using the Auth0 Dashboard.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc",
    "markdown": "# Configure PKCE and Claim Mapping for OIDC Connections\n\nEnterprise connections using [OpenID Connect](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/oidc) or O[kta Workforce](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/okta) as the identity provider can support Proof Key for Code Exchange (PKCE), as well as attribute and token mapping. \n\n## Configure PKCE for OIDC connections\n\nOpenID Connect and Okta Workforce connections are automatically configured to support Proof Key for Code Exchange (PKCE).\n\nIf your OIDC identity provider (IdP) supports PKCE through OIDC Discovery metadata, Auth0 will use the strongest algorithm available by default. For more information on OIDC Discovery metadata, review [OpenID’s documentation](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata). \n\n### View PKCE configuration for a connection\n\nYou can view the PKCE configuration for a specific connection through the Auth0 Dashboard:\n\n1.  Navigate to **Authentication > Enterprise** and choose your OIDC provider (either OpenID Connect or Okta Workforce).\n    \n2.  Select the **Settings** tab.\n    \n3.  In the **General** section, locate the **Connection Profile** field.\n    \n\n![The Connection Profile field available under Settings for Enterprise connections](https://images.ctfassets.net/cdy7uua7fh8z/3kickfUGNFHHjwIu2AWzVf/c7db941828eb458ba8668a75fd11a5a5/Connection_Profile_screenshot.png)\n\nYou can manage the PKCE configuration for a connection through the Auth0 Dashboard:\n\n1.  Navigate to [**Dashboard > Authenticate >Enterprise**](https://manage.auth0.com/#/connections/enterprise) and choose your OIDC provider (either OpenID Connect or Okta Workforce).\n    \n2.  Select the **Settings** tab and locate the **Connection Profile** field.\n    \n3.  Set the `pkce` property to one of the [supported values](#supported-pkce-configuration-values) listed below.\n    \n4.  Select **Save**.\n    \n\n### Supported PKCE configuration values\n\nAuth0 supports the following values for PKCE configuration:\n\n| Value | Description |\n| --- | --- |\n| `auto` | Default value. Uses the strongest algorithm available. |\n| `s256` | Uses the SHA-256 algorithm. Auth0 does not currently support RS512 tokens. |\n| `plain` | Uses plaintext as described in the [PKCE specification](https://www.rfc-editor.org/rfc/rfc7636#section-4.2 \"Proof Key for Code Exchange by OAuth Public Clients - Code Challenge\"). |\n| `disabled` | Disables support for PKCE. |\n\n## Map Claims for OIDC connections\n\nOpenID Connect and Okta Workforce connections can automatically map claims received from the identity provider (IdP). You can configure this mapping through a library template provided by Auth0 or by entering your own template directly.\n\n### Mapping template properties\n\nMapping templates support the `options.attribute_map` object properties listed below. Templates must be in JSON format with valid key/value pairs.\n\n| **Property** | **Required?** | **Description** |\n| --- | --- | --- |\n| `mapping_mode` | Required | Method used to map incoming claims. |\n| `userinfo_scope` | Optional | Scopes to send to the IdP's Userinfo endpoint. |\n| `attributes` | Required | Object containing mapping details for incoming claims. |\n\n### Mapping mode\n\nThe `mapping_mode` property defines the method used to map incoming claims from the IdP to the Auth0 user profile. `mapping_mode` supports the following values:\n\n| **Value** | **Description** |\n| --- | --- |\n| `use_map` | Uses the provided template to map the data. |\n| `bind_all` | Copies all data elements provided by the IdP. |\n\n#### Restricted claims\n\nSome claims are reserved for use by Auth0; such claims cannot be used as attribute keys for user profiles.\n\nIf you set the `mapping_mode` property to `bind_all`, your IdP may attempt to map values to one or more of these restricted claims. While this does not prevent users from authenticating on your connection, values associated with restricted claims are **not** mapped to the Auth0 user profile.\n\nIf you set `mapping_mode` to `use_map`, you can map the incoming restricted claim to a valid one:\n\n```\n\"attribute_map\": {\n        \"mapping_mode\": \"use_map\",\n        \"attributes\": {\n            \"amr\": \"{context.tokenset.amr}\" // `amr` is a restricted claim and will not be mapped\n            \"federated_amr\": \"{context.tokenset.amr}\" // `federated_amr` is not a restricted claim and will be mapped\n        }\n    }\n```\n\nFor a complete list of restricted claims, review [Create Custom Claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims).\n\n### UserInfo scope\n\nThe `userinfo_scope` property defines the scopes that Auth0 sends to the IdP’s UserInfo endpoint when requested.\n\nFor example, if you want to send the standard OIDC scopes and the `groups` scope when requesting the UserInfo endpoint, you can do so as follows:\n\n```\n\"attribute_map\": {\n    . . .\n    \"userinfo_scope\": \"openid email profile groups\",\n    . . .\n}\n```\n\n### Attributes\n\nThe `attributes` property is an object containing mapping information that allows Auth0 to interpret incoming claims from the IdP. Mapping information must be provided as key/value pairs.\n\nThe key to the left corresponds to an Auth0 user profile attribute. The value to the right represents the incoming claim from the IdP, which can be expressed as a literal value, a dynamic context object, or a combination of both. Dynamic context objects are template expressions written in the familiar `${variable}` format.\n\n```\n\"attribute_map\": {\n    . . .\n    \"attributes\": {\n        \"name\": \"${context.tokenset.name}\",\n        \"email\": \"${context.tokenset.email}\",\n        \"username\": \"${context.tokenset.preferred_username}\"\n    }\n}\n```\n\n#### Literal values\n\nA literal value is a static value mapped to a specific profile attribute for all users on your connection.\n\nFor example, if you are configuring a SalesForce OIDC connection and want to assign the same SFDC Community ID to all user profiles, you can do so as follows:\n\n```\n\"attribute_map\": {\n    . . .\n    \"attributes\": {\n        …\n        \"sf_community_id\": \"3423409219032-32\"\n    }\n}\n```\n\n#### Context object\n\nYou can map dynamic values to user profile attributes by using the `context` object. This allows you to store unique values for individual profiles, as opposed to literal values that are static across all profiles.\n\nThe `context` object supports the following properties:\n\n| Property | Description |\n| --- | --- |\n| `context.connection` | Contains the following properties:*   `id`: The connection’s unique identifier (for example, `con_4423423423432423`).<br>  <br>*   `strategy`: The connection’s strategy (for example, `oidc`). |\n| `context.tokenset` | Contains the following properties:*   `access_token`: The entire validated access token sent by the IdP.<br>  <br>*   `<claim name>`: Any ID token claim sent by the IdP. |\n| `context.userinfo` | Contains the following properties:*   `<claim name>`: Any available claim provided by the IdP’s UserInfo endpoint. |\n\n### Examples\n\n#### Simple user claim mapping\n\nThis example demonstrates how to map common user claims to the Auth0 user profile with data from the ID token:\n\n```\n\"attribute_map\": {\n    . . .\n    \"attributes\": {\n        \"name\": \"${context.tokenset.name}\",\n        \"email\": \"${context.tokenset.email}\",\n        \"username\": \"${context.tokenset.preferred_username}\"\n    }\n}\n```\n\n#### Group claim mapping\n\nThis example shows how to map groups to the Auth0 user profile from the incoming IdP:\n\n```\n\"attribute_map\": {\n    . . .\n    \"attributes\": {\n        \"federated_groups\": \"${context.userinfo.groups}\",\n        \"federated_locale\": \"${context.userinfo.locale}\",\n        \"federated_zoneinfo\": \"${context.userinfo.zoneinfo}\"\n    }\n}\n```\n\n#### Combining literal values and context objects\n\nThis example demonstrates how to combine literal values and dynamic template expressions to map a complex value to an attribute on the Auth0 user profile:\n\n```\n\"attribute_map\":{\n    . . .\n    \"attributes\": {\n        \"alt_id\": \"user_email|${context.tokenset.email}\",\n        . . .\n    }\n}\n```",
    "title": "Configure PKCE and Claim Mapping for OIDC Connections",
    "description": "Configure Proof Key for Code Exchange (PKCE) and mapping templates for OpenID Connect and Okta Workforce connections.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/oidc",
    "markdown": "# Connect to OpenID Connect Identity Provider\n\n## Prerequisites\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n    *   Select an appropriate **Application Type**.\n        \n    *   Add an **Allowed Callback URL** of **`{https://yourApp/callback}`**.\n        \n    *   Make sure your Application's [Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n        \n\n## Steps\n\nTo connect your application to an OIDC Identity Provider, you must:\n\n1.  [Set up your app in the OpenID Connect Identity Provider](#set-up-your-app-in-the-openid-connect-identity-provider)\n    \n2.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0)\n    \n3.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application)\n    \n4.  [Test the connection](#test-the-connection)\n    \n\n## Set up your app in the OpenID Connect Identity Provider\n\nTo allow users to log in using an OIDC Identity Provider, you must register your application with the IdP. The process of doing this varies depending on the OIDC Identity Provider, so you will need to follow your IdP's documentation to complete this task.\n\nGenerally, you will want to make sure that at some point you enter your callback URL: `https://{yourDomain}/login/callback`.\n\n#### Find your Auth0 domain name for redirects\n\nIf your Auth0 domain name is not shown above and you are not using our [custom domains](https://auth0.com/docs/customize/custom-domains) feature, your domain name is a concatenation of your tenant name, your regional subdomain, and `auth0.com`, separated by the dot (`.`) symbol.\n\nFor example, if your tenant name is `exampleco-enterprises`, and your tenant is in the US region, your Auth0 domain name would be `exampleco-enterprises.us.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.us.auth0.com/login/callback`.\n\nHowever, if your tenant is in the US region and was created before June 2020, then your Auth0 domain name would be `exampleco-enterprises.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.auth0.com/login/callback`.\n\nIf you are using [custom domains](https://auth0.com/docs/customize/custom-domains), your **Redirect URI** would be `https://<YOUR CUSTOM DOMAIN>/login/callback`.\n\nDuring this process, your OIDC Identity Provider will generate a unique identifier for the registered API, usually called a **Client ID** or an **Application ID**. Make note of this value; you will need it later.\n\n## Create an enterprise connection in Auth0\n\nNext, you will need to create and configure a OIDC Enterprise Connection in Auth0. Make sure you have the **Application (client) ID** and the **Client secret** generated when you set up your app in the OIDC provider.\n\n### Create an enterprise connection using the Dashboard\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **Open ID Connect**, and click its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create:**\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant. Once set, this name can't be changed. |\n    | **Issuer URL** | URL where Auth0 can find the **OpenID Provider Configuration Document**, which should be available in the `/.well-known/openid-configuration` endpoint. You can enter the base URL or the full URL. You will see a green checkmark if it can be found at that location, a red mark if it cannot be found, or an error message if the file is found but the required information is not present in the configuration file. |\n    | **Client ID** | Unique identifier for your registered application. Enter the saved value of the **Client ID** for the app you registered with the OIDC Identity Provider. |\n    | **Callback URL** | URL to which Auth0 redirects users after they authenticate. Ensure that this value is configured for the app you registered with the OIDC Identity Provider. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    \n    #### Find your Auth0 domain name for redirects\n    \n    If your Auth0 domain name is not shown above and you are not using our [custom domains](https://auth0.com/docs/customize/custom-domains) feature, your domain name is a concatenation of your tenant name, your regional subdomain, and `auth0.com`, separated by the dot (`.`) symbol.\n    \n    For example, if your tenant name is `exampleco-enterprises`, and your tenant is in the US region, your Auth0 domain name would be `exampleco-enterprises.us.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.us.auth0.com/login/callback`.\n    \n    However, if your tenant is in the US region and was created before June 2020, then your Auth0 domain name would be `exampleco-enterprises.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.auth0.com/login/callback`.\n    \n    If you are using [custom domains](https://auth0.com/docs/customize/custom-domains), your **Redirect URI** would be `https://<YOUR CUSTOM DOMAIN>/login/callback`.\n    \n    ![Enter OIDC Connection Details](https://images.ctfassets.net/cdy7uua7fh8z/4PO4eBhEM3R0ZMhaTlDVfB/4e1c4cebafd9c8159a4c4913c12b9baf/OpenID_Connect.png)\n3.  In the **Settings** view, make additional configuration adjustments, if necessary.\n    \n    | Field | Description |\n    | --- | --- |\n    | **Issuer URL** | Click **Show Issuer Details** to view the Issuer URL **Advanced Settings** and make adjustments. |\n    | **Type** | Set to **Front Channel** or **Back Channel**. Front Channel uses the OIDC protocol with `response_mode=form_post` and `response_type=id_token`. Back Channel uses `response_type=code`. |\n    | **Scopes** | A comma-separated list of Auth0 scopes to request when connecting to the Identify Provider. This will affect the data stored in the user profile. You are required to include at least the `openid` scope. Note that the connection does not call `/userinfo` endpoint and expects the user claims to be present in the `id_token`. |\n    \n4.  In the **Login Experience** view, configure how users log in with this connection.\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Identity Provider domains** | A comma-separated list of the domains that can be authenticated in the Identify Provider. This is only applicable when using [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication with Universal Login. |\n    | **Add button** (Optional) | Display a button for this connection in the login page. |\n    | **Button display name** (Optional) | Text used to customize the login button for Universal Login. When set the button reads: \"Continue with {Button display name}\". |\n    | **Button logo URL** (Optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    \n5.  Select **Save Changes**.\n    \n\n### Create an enterprise connection using the Management API\n\nThese examples will show you the variety of ways you can create the \\[connection\\](/connections) using Auth0's Management API. You ca configure the connection by either providing a metadata URI or by setting the OIDC URLs explicitly.\n\n#### Use front-channel with discovery endpoint\n\n*   [cURL](#7f7b717752fe46e88d88b77f2f5f0e22_shell)\n*   [C#](#7f7b717752fe46e88d88b77f2f5f0e22_csharp)\n*   [Go](#7f7b717752fe46e88d88b77f2f5f0e22_go)\n*   [Java](#7f7b717752fe46e88d88b77f2f5f0e22_java)\n*   [Node.JS](#7f7b717752fe46e88d88b77f2f5f0e22_node)\n*   [Obj-C](#7f7b717752fe46e88d88b77f2f5f0e22_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --data '{ \"strategy\": \"oidc\", \"name\": \"CONNECTION_NAME\", \"options\": { \"type\": \"front_channel\", \"discovery_url\": \"https://IDP_DOMAIN/.well-known/openid-configuration\", \"client_id\" : \"IDP_CLIENT_ID\",  \"scopes\": \"openid profile\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"undefined\", \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'},\n  data: {\n    strategy: 'oidc',\n    name: 'CONNECTION_NAME',\n    options: {\n      type: 'front_channel',\n      discovery_url: 'https://IDP_DOMAIN/.well-known/openid-configuration',\n      client_id: 'IDP_CLIENT_ID',\n      scopes: 'openid profile'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"oidc\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"type\": @\"front_channel\", @\"discovery_url\": @\"https://IDP_DOMAIN/.well-known/openid-configuration\", @\"client_id\": @\"IDP_CLIENT_ID\", @\"scopes\": @\"openid profile\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\nlet parameters = [\n  \"strategy\": \"oidc\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\n    \"type\": \"front_channel\",\n    \"discovery_url\": \"https://IDP_DOMAIN/.well-known/openid-configuration\",\n    \"client_id\": \"IDP_CLIENT_ID\",\n    \"scopes\": \"openid profile\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Use back-channel with discovery endpoint\n\n*   [cURL](#d537210b80504cae8cfdab7d0a1b3305_shell)\n*   [C#](#d537210b80504cae8cfdab7d0a1b3305_csharp)\n*   [Go](#d537210b80504cae8cfdab7d0a1b3305_go)\n*   [Java](#d537210b80504cae8cfdab7d0a1b3305_java)\n*   [Node.JS](#d537210b80504cae8cfdab7d0a1b3305_node)\n*   [Obj-C](#d537210b80504cae8cfdab7d0a1b3305_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --data '{ \"strategy\": \"oidc\", \"name\": \"CONNECTION_NAME\", \"options\": { \"type\": \"back_channel\", \"discovery_url\": \"https://IDP_DOMAIN/.well-known/openid-configuration\", \"client_id\" : \"IDP_CLIENT_ID\", \"client_secret\" : \"IDP_CLIENT_SECRET\", \"scopes\": \"openid profile\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"undefined\", \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"scopes\\\": \\\"openid profile\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"scopes\\\": \\\"openid profile\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"scopes\\\": \\\"openid profile\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'},\n  data: {\n    strategy: 'oidc',\n    name: 'CONNECTION_NAME',\n    options: {\n      type: 'back_channel',\n      discovery_url: 'https://IDP_DOMAIN/.well-known/openid-configuration',\n      client_id: 'IDP_CLIENT_ID',\n      client_secret: 'IDP_CLIENT_SECRET',\n      scopes: 'openid profile'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"oidc\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"type\": @\"back_channel\", @\"discovery_url\": @\"https://IDP_DOMAIN/.well-known/openid-configuration\", @\"client_id\": @\"IDP_CLIENT_ID\", @\"client_secret\": @\"IDP_CLIENT_SECRET\", @\"scopes\": @\"openid profile\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"scopes\\\": \\\"openid profile\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"discovery_url\\\": \\\"https://IDP_DOMAIN/.well-known/openid-configuration\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\nlet parameters = [\n  \"strategy\": \"oidc\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\n    \"type\": \"back_channel\",\n    \"discovery_url\": \"https://IDP_DOMAIN/.well-known/openid-configuration\",\n    \"client_id\": \"IDP_CLIENT_ID\",\n    \"client_secret\": \"IDP_CLIENT_SECRET\",\n    \"scopes\": \"openid profile\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Use back-channel specifying issuer settings\n\n*   [cURL](#da15fa3d6cd3453f96ffc0b91876b73d_shell)\n*   [C#](#da15fa3d6cd3453f96ffc0b91876b73d_csharp)\n*   [Go](#da15fa3d6cd3453f96ffc0b91876b73d_go)\n*   [Java](#da15fa3d6cd3453f96ffc0b91876b73d_java)\n*   [Node.JS](#da15fa3d6cd3453f96ffc0b91876b73d_node)\n*   [Obj-C](#da15fa3d6cd3453f96ffc0b91876b73d_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --data '{ \"strategy\": \"oidc\", \"name\": \"CONNECTION_NAME\", \"options\": { \"type\": \"back_channel\", \"issuer\": \"https://IDP_DOMAIN\", \"authorization_endpoint\": \"https://IDP_DOMAIN/authorize\", \"client_secret\" : \"IDP_CLIENT_SECRET\", \"client_id\" : \"IDP_CLIENT_ID\",  \"scopes\": \"openid profile\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"undefined\", \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'},\n  data: {\n    strategy: 'oidc',\n    name: 'CONNECTION_NAME',\n    options: {\n      type: 'back_channel',\n      issuer: 'https://IDP_DOMAIN',\n      authorization_endpoint: 'https://IDP_DOMAIN/authorize',\n      client_secret: 'IDP_CLIENT_SECRET',\n      client_id: 'IDP_CLIENT_ID',\n      scopes: 'openid profile'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"oidc\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"type\": @\"back_channel\", @\"issuer\": @\"https://IDP_DOMAIN\", @\"authorization_endpoint\": @\"https://IDP_DOMAIN/authorize\", @\"client_secret\": @\"IDP_CLIENT_SECRET\", @\"client_id\": @\"IDP_CLIENT_ID\", @\"scopes\": @\"openid profile\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"back_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"client_secret\\\" : \\\"IDP_CLIENT_SECRET\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\nlet parameters = [\n  \"strategy\": \"oidc\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\n    \"type\": \"back_channel\",\n    \"issuer\": \"https://IDP_DOMAIN\",\n    \"authorization_endpoint\": \"https://IDP_DOMAIN/authorize\",\n    \"client_secret\": \"IDP_CLIENT_SECRET\",\n    \"client_id\": \"IDP_CLIENT_ID\",\n    \"scopes\": \"openid profile\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n#### Use front-channel specifying issuer settings\n\n*   [cURL](#57b6ee6341ae4f398e9c3b0cf71df0e6_shell)\n*   [C#](#57b6ee6341ae4f398e9c3b0cf71df0e6_csharp)\n*   [Go](#57b6ee6341ae4f398e9c3b0cf71df0e6_go)\n*   [Java](#57b6ee6341ae4f398e9c3b0cf71df0e6_java)\n*   [Node.JS](#57b6ee6341ae4f398e9c3b0cf71df0e6_node)\n*   [Obj-C](#57b6ee6341ae4f398e9c3b0cf71df0e6_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --data '{ \"strategy\": \"oidc\", \"name\": \"CONNECTION_NAME\", \"options\": { \"type\": \"front_channel\", \"issuer\": \"https://IDP_DOMAIN\", \"authorization_endpoint\": \"https://IDP_DOMAIN/authorize\", \"token_endpoint\": \"https://IDP_DOMAIN/oauth/token\", \"client_id\" : \"IDP_CLIENT_ID\",  \"scopes\": \"openid profile\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"undefined\", \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"token_endpoint\\\": \\\"https://IDP_DOMAIN/oauth/token\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"token_endpoint\\\": \\\"https://IDP_DOMAIN/oauth/token\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"token_endpoint\\\": \\\"https://IDP_DOMAIN/oauth/token\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {authorization: 'Bearer MGMT_API_ACCESS_TOKEN'},\n  data: {\n    strategy: 'oidc',\n    name: 'CONNECTION_NAME',\n    options: {\n      type: 'front_channel',\n      issuer: 'https://IDP_DOMAIN',\n      authorization_endpoint: 'https://IDP_DOMAIN/authorize',\n      token_endpoint: 'https://IDP_DOMAIN/oauth/token',\n      client_id: 'IDP_CLIENT_ID',\n      scopes: 'openid profile'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"oidc\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"type\": @\"front_channel\", @\"issuer\": @\"https://IDP_DOMAIN\", @\"authorization_endpoint\": @\"https://IDP_DOMAIN/authorize\", @\"token_endpoint\": @\"https://IDP_DOMAIN/oauth/token\", @\"client_id\": @\"IDP_CLIENT_ID\", @\"scopes\": @\"openid profile\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"token_endpoint\\\": \\\"https://IDP_DOMAIN/oauth/token\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"token_endpoint\\\": \\\"https://IDP_DOMAIN/oauth/token\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nheaders = { 'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\" }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ \\\"strategy\\\": \\\"oidc\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"type\\\": \\\"front_channel\\\", \\\"issuer\\\": \\\"https://IDP_DOMAIN\\\", \\\"authorization_endpoint\\\": \\\"https://IDP_DOMAIN/authorize\\\", \\\"token_endpoint\\\": \\\"https://IDP_DOMAIN/oauth/token\\\", \\\"client_id\\\" : \\\"IDP_CLIENT_ID\\\",  \\\"scopes\\\": \\\"openid profile\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"]\nlet parameters = [\n  \"strategy\": \"oidc\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\n    \"type\": \"front_channel\",\n    \"issuer\": \"https://IDP_DOMAIN\",\n    \"authorization_endpoint\": \"https://IDP_DOMAIN/authorize\",\n    \"token_endpoint\": \"https://IDP_DOMAIN/oauth/token\",\n    \"client_id\": \"IDP_CLIENT_ID\",\n    \"scopes\": \"openid profile\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Configure PKCE and claims mapping\n\nThis Enterprise connection can support Proof Key for Code Exchange (PKCE), as well as attribute and token mapping. To learn more, review [Configure PKCE and Claim Mapping for OIDC Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/configure-pkce-claim-mapping-for-oidc).\n\n## Enable the enterprise connection for your Auth0 application\n\nTo use your new enterprise connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n## Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).\n\n## Manually configure Issuer metadata\n\nIf you click **Show Issuer Details** on the Issuer URL endpoint, you can see the data and adjust it if you need to.\n\n## Federate with Auth0\n\nThe OpenID Connect enterprise connection is extremely useful when federating to another Auth0 tenant. Just enter your Auth0 tenant URL (for example, `https://<tenant>.us.auth0.com`) in the **Issuer** field, and enter the Client ID for any application in the tenant to which you want to federate in the **Client ID** field.",
    "title": "Connect to OpenID Connect Identity Provider",
    "description": "Learn how to connect to OpenID Connect (OIDC) Identity Providers using an enterprise connection.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml",
    "markdown": "# SAML\n\nThe Security Assertion Markup Language (SAML) protocol is an open-standard, XML-based framework for authentication and authorization between two entities without a password:\n\n*   **Service provider** (SP) agrees to trust the identity provider to authenticate users.\n    \n*   **Identity provider** (IdP) authenticates users and provides to service providers an authentication assertion that indicates a user has been authenticated.\n    \n\nAuth0 supports the SAML protocol and can serve as the IdP, the SP, or both including:\n\n*   SAML2 web applications\n    \n*   SAML SSO integrations\n    \n*   IdP-initiated SSO\n    \n*   Microsoft Active Directory Federation Services (ADFS)\n    \n*   SAML request signing and encrypting\n    \n\n## Supported SAML bindings and options\n\nAuth0 supports the following SAML bindings:\n\n*   HTTP Redirect\n    \n*   HTTP POST\n    \n\nAuth0 supports the following SAML options:\n\n*   Web Browser SSO Profile\n    \n*   Single Logout Profile\n    \n*   Name Identifier Management Profile\n    \n*   Name Identifier Mapping Profile",
    "title": "SAML",
    "description": "Learn about the Security Assertion Markup Language (SAML) protocol, which is an open-standard, XML-based framework for authentication and authorization between two entities without a password.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/ws-fed-protocol",
    "markdown": "# Web Services Federation Protocol\n\nWeb Services Federation (WS-Federation or WS-Fed) is part of the larger WS-Security framework and an extension to the functionality of WS-Trust. The features of WS-Federation can be used directly by SOAP applications and web services. WS-Fed is a protocol that can be used to negotiate the issuance of a token. You can use this protocol for your applications (such as a Windows Identity Foundation-based app) and for identity providers (such as Active Directory Federation Services or Azure AppFabric Access Control Service).\n\n## For applications\n\nWhen you register an application in Auth0, it will automatically be assigned a WS-Fed endpoint of the form:\n\n`https://{yourDomain}/wsfed/{yourClientId}`\n\nYou can find all available options for configuring WS-Fed under the [advanced settings](https://manage.auth0.com/#/applications/{yourClientId}/settings) area for your application.\n\nYou will need to configure the **Relying Party**, which can be done using the following metadata endpoint:\n\n`https://{yourDomain}/wsfed/FederationMetadata/2007-06/FederationMetadata.xml`\n\nYou can also use the **samlConfiguration** object, available in [rules](https://auth0.com/docs/customize/rules), to configure claims sent via the token, as well as other lower-level WS-Fed and SAML\\-P settings.\n\nWhen redirecting your users to your WS-Fed endpoint, you can use the following (optional) parameters:\n\n| Parameter | Description |\n| --- | --- |\n| `wa=wsignin1.0` | Whether Auth0 should issue a token for the relying party (default) |\n| `wa=wsignout1.0` | Whether Auth0 should clear the user session/log the user out |\n| `wreply={callback_URL}` | Where the response should be sent |\n| `wctx={state}` | Your application's state |\n| `whr={connection_name}` | Connection to be used (allows users to skip the Auth0 login page) |\n| `wfresh=0` | Whether the user must re-authenticate, even if there's a session in place (`0` requires re-authentication) |\n\nHere's a sample of what your URL with the optional parameters might look like:\n\n`https://{yourDomain}/wsfed/{yourClientId}?whr=google-oauth2`\n\n## Identity providers\n\nIf you're using Auth0 with an identity provider that uses the WS-Federation protocol (such as Active Directory Federation Services, Azure AppFabric Access Control Service, and IdentityServer), the easiest way to set up your integration is to create and use the ADFS connection type in the Dashboard. There are two ways to accomplish this:\n\n*   Import the Federation Metadata file\n    \n*   Enable the Federation Metadata endpoint to check for changes\n    \n\n### Import Federation metadata file\n\nWhen setting up an ADFS-based connection, you can import the required parameters by providing Auth0 with the Federation Metadata endpoint or by importing/uploading your federation metadata file.\n\n![Protocols WS-Fed Import Federation Metadata File ADFS Connection Screen](https://images.ctfassets.net/cdy7uua7fh8z/35pGg8AnNcx2ZIfQIixt1J/2dd75754a7810fac4eb5dfb82fd11dc5/create-adfs-connection.png)\n\nYou will be presented with the instructions you need to finish configuring the integration.\n\n### Enable the Federation Metadata endpoint\n\nThe federation metadata file contains information about the identity provider's certificates. If you provide the Federation Metadata endpoint (typically of the form ending with `/FederationMetadata/2007-06/FederationMetadata.xml`), Auth0 can check daily for changes in the configuration, such as the addition of a new signing certificate that was added in preparation for a rollover. Because of this, enabling the Federation Metadata endpoint is preferred to providing a standalone metadata file. If you provide a standalone metadata file, we will notify you via email when the certificates are close to their expiration date.\n\nIf the Federation Metadata contains both the primary and secondary certificates, you can use both in Auth0.\n\nTo roll over certificates using the Federation Metadata endpoint:\n\n1.  Generate a new certificate, and add it as the secondary certificate for your ADFS environment. This should be done at least **two days** before the expiration of your active primary certificate.\n    \n2.  Allow Auth0 to obtain your new certificate from the Federation Metadata endpoint. Auth0 checks your endpoints once a day, so be sure to allow sufficient time for Auth0 to complete this step. Alternatively, you can manually complete this step by logging in to the Auth0 Dashboard, navigating to the appropriate ADFS connection, and click **Save**. This action results in Auth0 downloading the certificates immediately.\n    \n3.  Set the now-secondary certificate as the primary certificate before the existing primary certificate expires in your ADFS environment.\n    \n\n## Learn more\n\n*   [Configure WS-Fed Applications](https://auth0.com/docs/get-started/applications/configure-ws-fed-applications)",
    "title": "Web Services Federation Protocol",
    "description": "Describes how Auth0 works with the Web Services Federation (WS-Fed) protocol.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/openid-connect-protocol",
    "markdown": "# OpenID Connect Protocol\n\n## What is OpenID Connect (OIDC)?\n\nOpenID Connect (OIDC) is an identity layer built on top of the OAuth 2.0 framework. It allows third-party applications to verify the identity of the end-user and to obtain basic user profile information. OIDC uses JSON web tokens (JWTs), which you can obtain using flows conforming to the OAuth 2.0 specifications. See our [OIDC Handbook](https://auth0.com/resources/ebooks/the-openid-connect-handbook) for more details.\n\n## OpenID vs. OAuth2\n\nWhile OAuth 2.0 is about resource access and sharing, OIDC is about user authentication. Its purpose is to give you one login for multiple sites. Each time you need to log in to a website using OIDC, you are redirected to your OpenID site where you log in, and then taken back to the website. For example, if you chose to sign in to Auth0 using your Google account then you used OIDC. Once you successfully authenticate with Google and authorize Auth0 to access your information, Google sends information back to Auth0 about the user and the authentication performed. This information is returned in a JWT. You'll receive an access token and if requested, an ID token.\n\n## OpenID and JWTs\n\nJWTs contain [claims](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims), which are statements (such as name or email address) about an entity (typically, the user) and additional metadata. The [OpenID Connect specification](https://openid.net/specs/openid-connect-core-1_0.html) defines a set of [standard claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims). The set of standard claims include name, email, gender, birth date, and so on. However, if you want to capture information about a user and there currently isn't a standard claim that best reflects this piece of information, you can create custom claims and add them to your tokens.\n\n## Configure applications with OIDC and OAuth2\n\nYou can automatically [configure your applications with OIDC discovery](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery).\n\n## Learn more\n\n*   [Configure Applications with OIDC Discovery](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery)\n*   [Force Reauthentication in OIDC](https://auth0.com/docs/authenticate/login/max-age-reauthentication)\n*   [Applications in Auth0](https://auth0.com/docs/get-started/applications)\n*   [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on)\n*   [User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles)",
    "title": "OpenID Connect Protocol",
    "description": "Describes how to use OpenID Connect protocol with Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/oauth",
    "markdown": "# OAuth 2.0 Authorization Framework\n\nThe [OAuth 2.0](https://tools.ietf.org/html/rfc6749) authorization framework is a protocol that allows a user to grant a third-party web site or application access to the user's protected resources, without necessarily revealing their long-term credentials or even their identity.\n\nOAuth introduces an authorization layer and separates the role of the client from that of the resource owner. In OAuth, the client requests access to resources controlled by the resource owner and hosted by the resource server and is issued a different set of credentials than those of the resource owner. Instead of using the resource owner's credentials to access protected resources, the client obtains an Access Token\\--a string denoting a specific scope, lifetime, and other access attributes. Access tokens are issued to third-party clients by an authorization server with the approval of the resource owner. Then the client uses the access token to access the protected resources hosted by the resource server.\n\nAuth0 generates access tokens for API authorization scenarios, in [JSON web token (JWT) format](https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-structure). The permissions represented by the access token, in OAuth terms, are known as [scopes](https://auth0.com/docs/get-started/apis/scopes). When an application authenticates with Auth0, it specifies the scopes it wants. If those scopes are authorized by the user, then the access token will represent these authorized scopes.\n\n## Roles\n\nAn OAuth 2.0 flow has the following roles:\n\n*   **Resource Owner**: Entity that can grant access to a protected resource. Typically, this is the end-user.\n    \n*   **Resource Server**: Server hosting the protected resources. This is the API you want to access.\n    \n*   **Client**: Application requesting access to a protected resource on behalf of the Resource Owner.\n    \n*   **Authorization Server**: Server that authenticates the Resource Owner and issues access tokens after getting proper authorization. In this case, Auth0.\n    \n\n## Grant types\n\nOAuth 2.0 defines four flows to get an access token. These flows are called grant types. [Deciding which one is suited for your case](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use) depends mostly on your application type.\n\n*   [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow): used by Web Apps executing on a server. This is also used by mobile apps, using the [Proof Key for Code Exchange (PKCE) technique](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce).\n    \n*   [Implicit Flow with Form Post](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post): used by JavaScript-centric apps (Single-Page Applications) executing on the user's browser.\n    \n*   [Resource Owner Password Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow): used by highly-trusted apps.\n    \n*   [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow): used for machine-to-machine communication.\n    \n\nThe specification also provides an extensibility mechanism for defining additional grant types. To learn more about how each grant type works and when it should be used, see [Authentication and Authorization Flows](https://auth0.com/docs/get-started/authentication-and-authorization-flow).\n\n## Endpoints\n\nOAuth 2.0 uses two endpoints: the `/authorize` endpoint and the `/oauth/token` endpoint.\n\nThe `/authorize` endpoint is used to interact with the resource owner and get the authorization to access the protected resource. To better understand this, imagine that you want to log in to a service using your Google account. First, the service redirects you to Google in order to authenticate (if you are not already logged in) and then you will get a consent screen, where you will be asked to authorize the service to access some of your data (protected resources); for example, your email address and your list of contacts.\n\nThe request parameters of the `/authorize` endpoint are:\n\n| Parameter | Description |\n| --- | --- |\n| `response_type` | Tells the authorization server which grant to execute. |\n| `response_mode` | (Optional) How the result of the authorization request is formatted. Values:  <br>\\- `query`: for Authorization Code grant. `302 Found` triggers redirect.  <br>\\- `fragment`: for Implicit grant. `302 Found` triggers redirect.  <br>\\- `form_post`: `200 OK` with response parameters embedded in an HTML form as hidden parameters.  <br>\\- `web_message`: For Silent Authentication. Uses HTML5 web messaging. |\n| `client_id` | The ID of the application that asks for authorization. |\n| `redirect_uri` | Holds a URL. A successful response from this endpoint results in a redirect to this URL. |\n| `scope` | A space-delimited list of permissions that the application requires. |\n| `state` | An opaque value, used for security purposes. If this request parameter is set in the request, then it is returned to the application as part of the `redirect_uri`. |\n| `connection` | Specifies the connection type for Passwordless connections |\n\nYou can configure custom query parameters when your application makes the initial call to the `/authorize` endpoint to authenticate a user. You can use custom query parameters to provide additional context to the page template for the New Universal Login experience.\n\nYou must enable ID First to use the `connection` parameter. For more information on the `connection` parameter and the New Universal Login experience, review [Passwordless for New Universal Login](https://auth0.com/docs/authenticate/passwordless/passwordless-with-universal-login).\n\nQuery parameters prefixed with `ext-` automatically appear in the [page template context](https://auth0.com/docs/customize/universal-login-pages/universal-login-page-templates#custom-query-parameters).\n\nThis endpoint is used by the Authorization Code and the Implicit grant types. The authorization server needs to know which grant type the application wants to use since it affects the kind of credential it will issue:\n\n*   For the Authorization Code grant, it will issue an authorization code (which can later be exchanged for an access token at the `/oauth/token` endpoint).\n    \n*   For the Implicit grant, it will issue an access token, which is an opaque string (or a JWT in an Auth0 implementation) that denotes who has authorized which permissions (scopes) to which application.\n    \n\nTo inform the authorization server which grant type to use, the `response_type` request parameter is used as follows:\n\n*   For the Authorization Code grant, use `response_type=code` to include the authorization code.\n    \n*   For the Implicit grant, use `response_type=token` to include an access token. An alternative is to use `response_type=id_token token` to include both an access token and an ID token.\n    \n\nAn ID token is a JWT that contains information about the logged in user. It was introduced by OpenID Connect (OIDC).\n\nThe [OAuth 2.0 Multiple Response Type Encoding Practices specification](https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html) added a parameter that specifies how the result of the authorization request is formatted. This parameter is called `response_mode`. It is optional and can take the following values:\n\n| Value | Description |\n| --- | --- |\n| `query` | This is the default for Authorization Code grant. A successful response is `302 Found` which triggers a redirect to the `redirect_uri`. The response parameters are embedded in the query component (the part after `?`) of the `redirect_uri` in the `Location` header.  <br>For example:  <br>`HTTP/1.1 302 Found`  <br>`Location: https://my-redirect-uri.callback?code=js89p2x1` where the authorization code is `js89p21`. |\n| `fragment` | This is the default for Implicit grant. A successful response is `302 Found`, which triggers a redirect to the `redirect_uri` (which is a request parameter). The response parameters are embedded in the fragment component (the part after `#`) of the `redirect_uri` in the `Location` header.  <br>For example:  <br>`HTTP/1.1 302 Found`  <br>`Location: https://my-redirect-uri/callback#access_token=eyB...78f&token_type=Bearer&expires_in=3600`. |\n| `form_post` | The response mode is defined by the [OAuth 2.0 Form Post Response Mode specification](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html). A successful response is `200 OK` and the parameters are embedded in an HTML form as hidden params. The `action` of the form is the `redirect_uri` and the `onload` attribute is configured to submit the form. After the HTML is loaded by the browser, a redirect to the `redirect_uri` is done. |\n| `web_message` | This response mode is defined in [OAuth 2.0 Web Message Response Mode specification](https://tools.ietf.org/html/draft-sakimura-oauth-wmrm-00). It uses HTML5 Web Messaging instead of the redirect for the authorization response from the /authorization endpoint. This is particularly useful when using Silent Authentication. To do this response mode, you must register your app's URL at the **Allowed Web Origins** field in your Auth0 [application settings](https://manage.auth0.com/#/applications/{yourClientId}/settings). |\n\n### Token endpoint\n\nThe `/oauth/token` endpoint is used by the application in order to get an access token or a refresh token. It is used by all flows except for the Implicit Flow because in that case an access token is issued directly.\n\n*   In the Authorization Code Flow, the application exchanges the authorization code it got from the authorization endpoint for an access token.\n    \n*   In the Client Credentials Flow and Resource Owner Password Credentials Grant Exchange, the application authenticates using a set of credentials and then gets an access token.\n    \n\n## State parameters\n\nAuthorization protocols provide a `state` parameter that allows you to restore the previous state of your application. The `state` parameter preserves some state object set by the client in the Authorization request and makes it available to the client in the response. The primary reason for using the state parameter is to mitigate CSRF attacks. See [Use OAuth 2.0 State Parameters](https://auth0.com/docs/secure/attack-protection/state-parameters) for details.\n\n## Learn more\n\n*   [Prevent Attacks and Redirect Users with OAuth 2.0 State Parameters](https://auth0.com/docs/secure/attack-protection/state-parameters)\n*   [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)",
    "title": "OAuth 2.0 Authorization Framework",
    "description": "Learn how Auth0 works with the OAuth 2.0 Authorization Framework. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/ldap-protocol",
    "markdown": "# Lightweight Directory Access Protocol\n\n##### Lightweight Directory Access Protocol\n\n[Contact sales](https://auth0.com/get-started?place=header&type=button&text=talk%20to%20sales) Log in\n\n[\n\n###### Authenticate\n\n](https://auth0.com/docs/authenticate)\n\nAdd Login\n\n*   [Login](https://auth0.com/docs/authenticate/login \"Login\")\n*   [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on \"Single Sign-On\")\n*   [Passwordless](https://auth0.com/docs/authenticate/passwordless \"Passwordless\")\n\nProvision Users\n\n*   [Identity Providers](https://auth0.com/docs/authenticate/identity-providers \"Identity Providers\")\n*   [Database Connections](https://auth0.com/docs/authenticate/database-connections \"Database Connections\")\n*   [Enterprise Connections](https://auth0.com/docs/authenticate/enterprise-connections \"Enterprise Connections\")\n*   [Protocols](https://auth0.com/docs/authenticate/protocols \"Protocols\")\n*   [SAML](https://auth0.com/docs/authenticate/protocols/saml \"SAML\")\n*   [OpenID Connect Protocol](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol \"OpenID Connect Protocol\")\n*   [OAuth 2.0 Authorization Framework](https://auth0.com/docs/authenticate/protocols/oauth \"OAuth 2.0 Authorization Framework\")\n*   [Web Services Federation Protocol](https://auth0.com/docs/authenticate/protocols/ws-fed-protocol \"Web Services Federation Protocol\")\n*   [Lightweight Directory Access Protocol](https://auth0.com/docs/authenticate/protocols/ldap-protocol \"Lightweight Directory Access Protocol\")\n*   [System for Cross-domain Identity Management (SCIM)](https://auth0.com/docs/authenticate/protocols/scim \"System for Cross-domain Identity Management (SCIM)\")\n*   [Connection Settings Best Practices](https://auth0.com/docs/authenticate/connection-settings-best-practices \"Connection Settings Best Practices\")\n\nThe Lightweight Directory Access Protocol (LDAP) is an application protocol, used for accessing and maintaining distributed directory information services over an Internet Protocol (IP) network. The function of LDAP is to enable access to an existing directory like Active Directory (AD). Auth0 uses an [Active Directory/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector) that you install on your network to integrate with AD/LDAP.\n\n## Learn more\n\n*   [AD/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector)\n*   [Auth0 AD/LDAP Connector Health Monitor Extension](https://auth0.com/docs/customize/extensions/ad-ldap-connector-health-monitor)\n*   [Configure AD/LDAP Connector Authentication with Kerberos](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos)\n*   [Deploy AD/LDAP Connectors for High Availability Environments](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-high-availability)\n*   [Point AD/LDAP Connector to Auth0 Connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-to-auth0)\n\nWas this article helpful?",
    "title": "Lightweight Directory Access Protocol",
    "description": "Describes how Auth0 supports the Lightweight Directory Access Protocol (LDAP).",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector",
    "markdown": "# AD/LDAP Connector\n\nAuth0 integrates with Active Directory (AD) using Lightweight Directory Access Protocol (LDAP) through an Active Directory/LDAP Connector that you install on your network.\n\nThe AD/LDAP Connector (1), is a bridge between your Active Directory/LDAP (2) and the Auth0 Service (3). This bridge is necessary because AD/LDAP is typically restricted to your internal network, and Auth0 is a cloud service running in a completely different context.\n\n![AD/LDAP Connector - integrate AD/LDAP with Auth0 - diagram](https://images.ctfassets.net/cdy7uua7fh8z/1xMpdHrtor0TR7F1gZ96zL/130e13f59b728fe14e00f1815b90103f/ldap-connect.png)\n\nWhen a user authenticates with Auth0, they are redirected to the AD/LDAP Connector which validates the user against your AD service and then sends the results of the validation back to Auth0. The AD/LDAP Connector supports authentication based LDAP, [](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos)Kerberos, and [](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-client-certificates)client certificates.\n\nTo learn more, see [Configure AD/LDAP Connector Authentication with Kerberos](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos) and [Configure AD/LDAP Connector Authenticator with Client Certificates](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-client-certificates).\n\n## Caches\n\nThe AD/LDAP Connector caches user profiles and credentials (Auth0 stores a hash of the user's password) to ensure optimal uptime and performance, and updates the data each time a user logs in. The cache is only used when the connector is down or unreachable. The cached data is always stored unless you disable caching credentials in the Dashboard. Values in the cache are case-sensitive, which means that login attempts will only succeed if users provide the exact username that was cached.\n\n## High-availability and load balancing\n\nFor high-availability and load balancing, you can install multiple instances of the connector. All connections are outbound from the connector to the Auth0 Server, so changes to your firewall are generally unnecessary.\n\nEach instance of the high-availability cluster will be always up and running and connected to Auth0. Auth0 will send login transactions and other requests to any of the available connectors. If one of the instances fails because of a network or a hardware issue, Auth0 will redirect the login transactions to the other connector. Having a highly available deployment also allows you to update the connector with zero downtime.\n\n## OpenLDAP directories\n\nThe Connector comes by default highly optimized for Active Directory. To configure it any other LDAP directories (such as OpenLDAP) you will have to customize these settings in the `config.json` file:\n\n```\n\"LDAP_USER_BY_NAME\": \"(cn={0})\",\n      \"LDAP_SEARCH_QUERY\": \"(&(objectClass=person)(cn={0}))\",\n      \"LDAP_SEARCH_ALL_QUERY\": \"(objectClass=person)\",\n```\n\nIn some cases, instead of `cn` it might be better to use `uid`.\n\n### OpenDJ example\n\nWith the **OpenDJ Control Panel** you can retrieve the list of attributes for each user. This list can help you decide which attribute will be used as the username when authenticating with Auth0.\n\n![AD/LDAP Connector OpenDJ Example diagram](https://images.ctfassets.net/cdy7uua7fh8z/14fTMlPqtzUicW2VTZPLPG/3ffa90a44eb864455ad3b77406f8ad32/opendj-attributes.png)\n\nIn this example John's `cn` is **johndoe** and the `mail` field is set to **johndoe@contoso.com**. If your organization wants users to authenticate using their username (`cn`) you can set the `LDAP_USER_BY_NAME` setting to `(cn={0})`, but if users should authenticate using their email address you should set it to `(mail={0})`.\n\n## Learn more\n\n*   [AD/LDAP Connector System Requirements](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-connector-requirements)\n*   [Install and Configure AD/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/install-configure-ad-ldap-connector)\n*   [Configure AD/LDAP Connector Authentication with Client Certificates](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-client-certificates)\n*   [Configure AD/LDAP Connector Authentication with Kerberos](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos)\n*   [Import and Export AD/LDAP Connector Configurations](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/import-export-ad-ldap-connector-configs)\n*   [Troubleshoot AD/LDAP Connector](https://auth0.com/docs/troubleshoot/integration-extensibility-issues/troubleshoot-ad-ldap-connector)",
    "title": "AD/LDAP Connector",
    "description": "Describes the Active Directory LDAP Connector and how it works.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/scim",
    "markdown": "# System for Cross-domain Identity Management (SCIM)\n\nSCIM (System for Cross-domain Identity Management) is a set of application-level protocols to securely manage and communicate user data across multiple domains. SCIM clients can be integrated to manage CRUD (create, replace, update, delete) operations, apply queries and filters, and create user groups within your organization. SCIM allows you to automate user lifecycles and maintain user accounts across platforms.\n\nTo read the SCIM specification, read [System for Cross-domain Identity Management: Core Schema](https://datatracker.ietf.org/doc/rfc7643/).\n\n### SCIM with Auth0\n\nAuth0 supplies an extensible, flexible directory that is designed to support CIAM use cases and focuses on simplifying identity for direct-to-consumer and software-as-a-service applications.\n\nIn an Auth0 tenant, you can use isolated directories via Social, Enterprise, or Database identity provider connections. To learn more about available connections, read [Identity Providers](https://auth0.com/docs/authenticate/identity-providers) or [Database Connections](https://auth0.com/docs/authenticate/database-connections).\n\nWith connections, you can model internal users and external users within Auth0 or connect external directories and choose to update the records in the Auth0 tenant during authentication or on-demand with the Management API.\n\nAuth0 synchronizes user data from federated directories at authentication (just-in-time). Inbound and outbound SCIM synchronization is provided via middleware that interfaces with Auth0’s Management API for supported lifecycle events such as user creation, update, and delete.\n\nTo learn more about using SCIM with Auth0, contact [Professional Services](https://auth0.com/docs/get-started/professional-services).",
    "title": "System for Cross-domain Identity Management (SCIM)",
    "description": "Describes using System for Cross-domain Identity Management (SCIM) schema in identity management",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/protocols/saml/saml-configuration",
    "markdown": "# SAML Configuration\n\n## SAML service providers\n\nApplications, especially custom ones, can authenticate users against an external IdP using protocols such as OpenID Connect (OIDC) or OAuth 2.0. However, you might want to leverage an enterprise SAML provider for authentication, even if you wrote your application to use either protocol.\n\n![Protocols SAML SPs Diagram](https://images.ctfassets.net/cdy7uua7fh8z/F29Tn5sjo1hqHSxslyHhR/52e6ef8ca4e1c9b68be4290011b21afa/saml-case1.png)\n\n## SAML identity providers\n\nSome applications (such as Salesforce, Box, and Workday) allow users to authenticate against an external IdP using the SAML protocol. You can then integrate the application with Auth0, which serves as the application's SAML IdP. Application users will be redirected to Auth0 to log in, and Auth0 can authenticate them using any backend authentication connection, such as an LDAP directory, a database, or another SAML IdP or Social Provider. Once the user is authenticated, Auth0 returns a SAML assertion to the application that indicates such.\n\n![Protocols SAML IdP Diagram](https://images.ctfassets.net/cdy7uua7fh8z/2fREft2nQOfBNh1cZfgsZH/7dcb4e85d171601025423d71a1d8fe19/saml-case2.png)\n\nHere is a list of IdP services known to support the SAML protocol. There may be additional services beyond what is shown below. The following providers have participated in a Kantara interoperability test and are therefore likely to conform well to the SAML spec.\n\n*   adAS\n    \n*   ADFS\n    \n*   Dot Net Workflow\n    \n*   Elastic SSO Team & Enterprise\n    \n*   Entrust GetAccess & IdentityGuard (check protocol supported)\n    \n*   EIC (check protocol supported)\n    \n*   Ilex Sign&go\n    \n*   iWelcome\n    \n*   NetIQ Access Manager\n    \n*   OpenAM\n    \n*   RCDevs Open SAMPL IdP\n    \n*   Optimal IdM VIS Federation Services\n    \n*   Oracle Access Manager (Oracle Identity Federation merged into this)\n    \n*   PingFederate (IDP Light)\n    \n*   RSA Federated Identity (IDP Light)\n    \n*   SecureAuth\n    \n*   Symplified\n    \n*   Tivoli Federated Identity Manager\n    \n*   TrustBuilder\n    \n*   Ubisecure SSO\n    \n*   WSO2 Identity Server\n    \n\nAuth0 provides specific instructions to configure the following SAML identity providers with Auth0:\n\n*   [ADFS](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-adfs-saml-connections)\n    \n*   [Okta](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-okta-as-saml-identity-provider)\n    \n*   [OneLogin](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-onelogin-as-saml-identity-provider)\n    \n*   [PingFederate 7](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-pingfederate-as-saml-identity-provider)\n    \n*   [Salesforce](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-salesforce-as-saml-identity-provider)\n    \n*   [SiteMinder](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-siteminder-as-saml-identity-provider)\n    \n*   [SSOCircle](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider/configure-ssocircle-as-saml-identity-provider)\n    \n\n## Auth0 as service provider\n\nIf Auth0 serves as the service provider in a SAML federation, Auth0 can route authentication requests to an identity provider without already having an account pre-created for a specific user. Using the assertion returned by the identity provider, Auth0 can capture information needed to create a user profile for the user (this process is sometimes called just-in-time provisioning). To learn more, read [Select from Multiple Connection Options](https://auth0.com/docs/libraries/lock/selecting-from-multiple-connection-options).\n\nEven though Auth0 doesn't require pre-created user accounts prior to the authentication process, the application integrated with Auth0 might. If this is the case, you have several options when it comes to handling this:\n\n*   After the identity provider creates the user, you can use an out-of-band process can create the accompanying user in the application (or Auth0) and add any user profile attributes required by the application. If, after authentication, any attributes are missing in the profile, the application can obtain them from the appropriate source and store them in the Auth0 user profile. The additional attributes are then sent to the application (in addition to any added by the identity provider) the next time the user logs in.\n    \n*   You can use an Auth0 rule to call an API to retrieve any missing information and dynamically add it to the Auth0 profile (which is then returned to the application). Rules execute after successful authentication, and your application can retrieve profile attributes each time or you can save the attributes to the Auth0 profile.\n    \n*   Auth0 can pass the basic profile information from the identity provider to the application, which then retrieves any missing information from another source. With the two sets of information, the application creates a local user profile.\n    \n\nYou can specify email domains as part of the Auth0 SAMLP Connection configuration to control the IDP that handles a select group of users. For example, if you add email domain `example.com` to the Auth0 SAMLP Connection configuration for Company X, all users with emails with the `example.com` domain get handled by the specific IDP for Company X.\n\n## Auth0 as identity provider\n\nIf Auth0 serves as the identity provider in a SAML federation, user accounts may be created multiple ways:\n\n*   Using a back-end authentication system, such as an LDAP directory, a database, or another SAML identity provider.\n    \n*   Using the Auth0 Dashboard.\n    \n*   Calling the Auth0 Management API.\n    \n*   Implementing self-service user signup.\n    \n\nIf your application is written to retrieve user profile information from a local store, you'll need to create the local profile after the accounts have been created in Auth0. Some of the ways you might do this include:\n\n*   An out-of-band process creating user profiles in the application;\n    \n*   An Auth0 rule that executes on first login that calls an application API to create the user profile in the application;\n    \n*   Modifying the application to create user profiles dynamically, based on information in the SAML assertion.\n    \n\n## Test SAML SSO using Auth0 as service and identity provider\n\nYou can use Auth0 as both the SAML service provider and the SAML identity provider for testing purposes.\n\n![Protocols Auth0 as SAML SP and IdP Diagram](https://images.ctfassets.net/cdy7uua7fh8z/7Ds9dLC3HaxGBLsG3ry7B9/0c08d51b6d6bb57ef6eff3796ca4cd21/saml-case3.png)\n\n## Learn more\n\n*   [SAML Single Sign-On Integrations](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations)\n*   [Configure Auth0 as SAML Service Provider](https://auth0.com/docs/authenticate/protocols/saml/saml-sso-integrations/configure-auth0-saml-service-provider)\n*   [Configure Auth0 as SAML Identity Provider](https://auth0.com/docs/authenticate/single-sign-on/outbound-single-sign-on/configure-auth0-saml-identity-provider)\n*   [Test SAML SSO with Auth0 as Service Provider and Identity Provider](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/configure-auth0-as-service-and-identity-provider)\n*   [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings)\n*   [Customize SAML Assertions](https://auth0.com/docs/authenticate/protocols/saml/saml-configuration/customize-saml-assertions)",
    "title": "SAML Configuration",
    "description": "Describes how Auth0 works with Security Assertion Markup Language (SAML) protocol.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/oauth2",
    "markdown": "# Connect Apps to Generic OAuth2 Authorization Servers\n\nThe most common [identity providers (IdP)](https://auth0.com/docs/authenticate/identity-providers) are available in [Auth0 Dashboard](https://manage.auth0.com/#) and in the [Auth0 Marketplace](https://marketplace.auth0.com/features/social-connections). You can, however, add any OAuth 2.0 provider as a **Custom Social Connection** in the Auth0 Dashboard.\n\n1.  In the Dashboard, go to [Authentication > Social](https://manage.auth0.com/#/connections/social).\n    \n2.  Select **Create Connection**, go to the bottom of the list, and then select **Create Custom**.\n    \n\nThe form that appears contains several fields that you must use to configure the custom connection:\n\n*   **Connection Name**: Logical identifier for the Connection you are creating. This name cannot be changed, must start and end with an alphanumeric character, and can only contain alphanumeric characters and dashes.\n    \n*   **Authorization URL**: URL to which users are redirected to log in.\n    \n*   **Token URL**: URL used to exchange the received authorization code for access tokens and, if requested, ID tokens.\n    \n*   **Scope**: `scope` parameters to send with the authorization request. Separate multiple scopes with spaces.\n    \n*   **Separate scopes using a space**: Toggle that determines how scopes are delimited if the `connection_scope` parameter is included when [calling the IdP's API](https://auth0.com/docs/authenticate/identity-providers/calling-an-external-idp-api). By default, scopes are delimited by a comma. If the toggle is enabled, scopes are delimited by a space. To learn more, read [Add Scopes/Permissions to Call Identity Provider APIs](https://auth0.com/docs/authenticate/identity-providers/adding-scopes-for-an-external-idp).\n    \n*   **Client ID**: Client ID for Auth0 as an application used to request authorization and exchange the authorization code. To get a Client ID, you will need to register with the identity provider.\n    \n*   **Client Secret**: Client Secret for Auth0 as an application used to exchange the authorization code. To get a Client Secret, you will need to register with the identity provider.\n    \n*   **Fetch User Profile Script**: Node.js script used to call a userinfo URL with the provided access token. To learn more about this script, see [Fetch User Profile Script](#fetch-user-profile-script).\n    \n\nOnce you create the custom connection, you will see the **Applications** view. Here, you can enable and disable applications for which you would like the connection to appear.\n\n## Update authentication flow\n\nWhen you create a connection, the default OAuth 2.0 grant type assigned to the connection is Authorization Code Flow. If you have a public application unable to store a Client Secret, such single-page or native applications, you can use the Management API to update the connection to use [Authorization Code Flow + PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce). To learn more about authorization flows, read [Which OAuth 2.0 Flow Should I Use?](https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use)\n\n1.  Make a `GET` request to the [`/get-connections-by-id`](https://auth0.com/docs/api/management/v2/connections/get-connections-by-id) endpoint. The response will be similar to:\n    \n    ```\n    {\n      \"id\": \"[connectionID]\",\n      \"options\": {\n        \"email\": true,\n        \"scope\": [\n          \"email\",\n          \"profile\"\n        ],\n        \"profile\": true\n      },\n      \"strategy\": \"google-oauth2\",\n      \"name\": \"google-oauth2\",\n      \"is_domain_connection\": false,\n      \"enabled_clients\": [\n        \"[yourAuth0Domain]\"\n      ],\n      \"realms\": [\n        \"google-oauth2\"\n      ]\n    }\n    ```\n    \n2.  Copy the entire `options` object.\n    \n3.  Make a [`PATCH`](https://auth0.com/docs/api/management/v2/connections/patch-connections-by-id) request with the `options` object and add `\"pkce_enabled\":` `true`.\n    \n\n## Fetch User Profile Script\n\nThe fetch user profile script is called after the user has logged in with the OAuth2 provider. Auth0 executes this script to call the OAuth2 provider API and get the user profile:\n\n```\nfunction fetchUserProfile(accessToken, context, callback) {\n  request.get(\n    {\n      url: 'https://auth.example.com/userinfo',\n      headers: {\n        'Authorization': 'Bearer ' + accessToken,\n      }\n    },\n    (err, resp, body) => {\n      if (err) {\n        return callback(err);\n      }\n      if (resp.statusCode !== 200) {\n        return callback(new Error(body));\n      }\n      let bodyParsed;\n      try {\n        bodyParsed = JSON.parse(body);\n      } catch (jsonError) {\n        return callback(new Error(body));\n      }\n      const profile = {\n        user_id: bodyParsed.account.uuid,\n        email: bodyParsed.account.email\n      };\n      callback(null, profile);\n    }\n  );\n}\n```\n\nThe `user_id` property in the returned profile is required, and the `email` property is optional but highly recommended. To learn more about what attributes can be returned, see [User Profile Root Attributes](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes/update-root-attributes-for-users).\n\nYou can filter, add, or remove anything from the profile returned from the provider. However, it is recommended that you keep this script as simple as possible. More sophisticated manipulation of user information can be achieved through the use of [Rules](https://auth0.com/docs/customize/rules). One advantage of using Rules is that they apply to any connection.\n\n## Log in using the custom connection\n\nYou can use any of the Auth0 standard mechanisms to log a user in with your custom connection. A direct link would look like:\n\n```\nhttps://{yourDomain}/authorize\n  ?response_type=code\n  &client_id={yourClientId}\n  &redirect_uri={https://yourApp/callback}\n  &scope=openid%20profile%20email\n  &connection=NAME_OF_CONNECTION\n```\n\n## Modify the icon and display name\n\nTo add an icon to the identity provider's login button or change the text used on the login button, you can use the `icon_url` property of the `options` object and the `display_name` property, respectively, via the [Management API](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id).\n\n*   [cURL](#f321801e2890408f9efd68fb924d2d4a_shell)\n*   [C#](#f321801e2890408f9efd68fb924d2d4a_csharp)\n*   [Go](#f321801e2890408f9efd68fb924d2d4a_go)\n*   [Java](#f321801e2890408f9efd68fb924d2d4a_java)\n*   [Node.JS](#f321801e2890408f9efd68fb924d2d4a_node)\n*   [Obj-C](#f321801e2890408f9efd68fb924d2d4a_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/CONNECTION-ID' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"options\": { \"client_id\": \"...\", \"client_secret\": \"...\", \"icon_url\": \"https://cdn.example.com/assets/icon.png\", \"scripts\": { \"fetchUserProfile\": \"...\" }, \"authorizationURL\": \"https://public-auth.example.com/oauth2/authorize\", \"tokenURL\": \"https://auth.example.com/oauth2/token\", \"scope\": \"auth\" }, \"enabled_clients\": [ \"...\" ] }, \"display_name\": \"Connection Name\"'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"icon_url\\\": \\\"https://cdn.example.com/assets/icon.png\\\", \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }, \\\"display_name\\\": \\\"Connection Name\\\"\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"icon_url\\\": \\\"https://cdn.example.com/assets/icon.png\\\", \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }, \\\"display_name\\\": \\\"Connection Name\\\"\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"icon_url\\\": \\\"https://cdn.example.com/assets/icon.png\\\", \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }, \\\"display_name\\\": \\\"Connection Name\\\"\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/CONNECTION-ID',\n  headers: {'content-type': 'application/json'},\n  data: '{ \"options\": { \"client_id\": \"...\", \"client_secret\": \"...\", \"icon_url\": \"https://cdn.example.com/assets/icon.png\", \"scripts\": { \"fetchUserProfile\": \"...\" }, \"authorizationURL\": \"https://public-auth.example.com/oauth2/authorize\", \"tokenURL\": \"https://auth.example.com/oauth2/token\", \"scope\": \"auth\" }, \"enabled_clients\": [ \"...\" ] }, \"display_name\": \"Connection Name\"'\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\n\nNSData *postData = [[NSData alloc] initWithData:[@\"{ \"options\": { \"client_id\": \"...\", \"client_secret\": \"...\", \"icon_url\": \"https://cdn.example.com/assets/icon.png\", \"scripts\": { \"fetchUserProfile\": \"...\" }, \"authorizationURL\": \"https://public-auth.example.com/oauth2/authorize\", \"tokenURL\": \"https://auth.example.com/oauth2/token\", \"scope\": \"auth\" }, \"enabled_clients\": [ \"...\" ] }, \"display_name\": \"Connection Name\"\" dataUsingEncoding:NSUTF8StringEncoding]];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"icon_url\\\": \\\"https://cdn.example.com/assets/icon.png\\\", \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }, \\\"display_name\\\": \\\"Connection Name\\\"\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"icon_url\\\": \\\"https://cdn.example.com/assets/icon.png\\\", \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }, \\\"display_name\\\": \\\"Connection Name\\\"\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/CONNECTION-ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"icon_url\\\": \\\"https://cdn.example.com/assets/icon.png\\\", \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }, \\\"display_name\\\": \\\"Connection Name\\\"\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\n\nlet postData = NSData(data: \"{ \"options\": { \"client_id\": \"...\", \"client_secret\": \"...\", \"icon_url\": \"https://cdn.example.com/assets/icon.png\", \"scripts\": { \"fetchUserProfile\": \"...\" }, \"authorizationURL\": \"https://public-auth.example.com/oauth2/authorize\", \"tokenURL\": \"https://auth.example.com/oauth2/token\", \"scope\": \"auth\" }, \"enabled_clients\": [ \"...\" ] }, \"display_name\": \"Connection Name\"\".data(using: String.Encoding.utf8)!)\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n![Login screen showing a custom OAuth2 connection with a custom icon and name.](https://images.ctfassets.net/cdy7uua7fh8z/6A2EFnYtrkvMdaPkjUvvv9/98b3f4f0bedff9cde6032c07a013e290/custom-connection-icon.png)\n\n## Pass provider-specific parameters\n\nYou can pass provider-specific parameters to the Authorization endpoint of OAuth 2.0 providers. These can be either static or dynamic.\n\n### Pass static parameters\n\nTo pass static parameters (parameters that are sent with every authorization request), you can use the `authParams` element of the `options` when configuring an OAuth 2.0 connection via the [Management API](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id). The call below will set a static parameter of `custom_param` set to `custom.param.value` on all authorization requests:\n\n*   [cURL](#f6fa5b44bf304c3da2b574bc4e5a9d4b_shell)\n*   [C#](#f6fa5b44bf304c3da2b574bc4e5a9d4b_csharp)\n*   [Go](#f6fa5b44bf304c3da2b574bc4e5a9d4b_go)\n*   [Java](#f6fa5b44bf304c3da2b574bc4e5a9d4b_java)\n*   [Node.JS](#f6fa5b44bf304c3da2b574bc4e5a9d4b_node)\n*   [Obj-C](#f6fa5b44bf304c3da2b574bc4e5a9d4b_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/CONNECTION-ID' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"options\": { \"client_id\": \"...\", \"client_secret\": \"...\", \"authParams\": { \"custom_param\": \"custom.param.value\" }, \"scripts\": { \"fetchUserProfile\": \"...\" }, \"authorizationURL\": \"https://public-auth.example.com/oauth2/authorize\", \"tokenURL\": \"https://auth.example.com/oauth2/token\", \"scope\": \"auth\" }, \"enabled_clients\": [ \"...\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParams\\\": { \\\"custom_param\\\": \\\"custom.param.value\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParams\\\": { \\\"custom_param\\\": \\\"custom.param.value\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParams\\\": { \\\"custom_param\\\": \\\"custom.param.value\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/CONNECTION-ID',\n  headers: {'content-type': 'application/json'},\n  data: {\n    options: {\n      client_id: '...',\n      client_secret: '...',\n      authParams: {custom_param: 'custom.param.value'},\n      scripts: {fetchUserProfile: '...'},\n      authorizationURL: 'https://public-auth.example.com/oauth2/authorize',\n      tokenURL: 'https://auth.example.com/oauth2/token',\n      scope: 'auth'\n    },\n    enabled_clients: ['...']\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"options\": @{ @\"client_id\": @\"...\", @\"client_secret\": @\"...\", @\"authParams\": @{ @\"custom_param\": @\"custom.param.value\" }, @\"scripts\": @{ @\"fetchUserProfile\": @\"...\" }, @\"authorizationURL\": @\"https://public-auth.example.com/oauth2/authorize\", @\"tokenURL\": @\"https://auth.example.com/oauth2/token\", @\"scope\": @\"auth\" },\n                              @\"enabled_clients\": @[ @\"...\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParams\\\": { \\\"custom_param\\\": \\\"custom.param.value\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParams\\\": { \\\"custom_param\\\": \\\"custom.param.value\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/CONNECTION-ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParams\\\": { \\\"custom_param\\\": \\\"custom.param.value\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://public-auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"options\": [\n    \"client_id\": \"...\",\n    \"client_secret\": \"...\",\n    \"authParams\": [\"custom_param\": \"custom.param.value\"],\n    \"scripts\": [\"fetchUserProfile\": \"...\"],\n    \"authorizationURL\": \"https://public-auth.example.com/oauth2/authorize\",\n    \"tokenURL\": \"https://auth.example.com/oauth2/token\",\n    \"scope\": \"auth\"\n  ],\n  \"enabled_clients\": [\"...\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Pass dynamic parameters\n\nIn certain circumstances, you may want to pass a dynamic value to an OAuth 2.0 Identity Provider. In this case, you can use the `authParamsMap` element of the `options` to specify a mapping between one of the existing additional parameters accepted by the [Auth0 `/authorize` endpoint](https://auth0.com/docs/api/authentication#social) to the parameter accepted by the Identity Provider.\n\nUsing the same example above, let's assume that you want to pass the `custom_param` parameter to the authorization endpoint, but you want to specify the actual value of the parameter when calling the Auth0 `/authorize` endpoint.\n\nIn this case, you can use one of the existing addition parameters accepted by the `/authorize` endpoint, such as `access_type`, and map that to the `custom_param` parameter:\n\n*   [cURL](#1aa1ad36fbeb40d3b3bb323d01e674fd_shell)\n*   [C#](#1aa1ad36fbeb40d3b3bb323d01e674fd_csharp)\n*   [Go](#1aa1ad36fbeb40d3b3bb323d01e674fd_go)\n*   [Java](#1aa1ad36fbeb40d3b3bb323d01e674fd_java)\n*   [Node.JS](#1aa1ad36fbeb40d3b3bb323d01e674fd_node)\n*   [Obj-C](#1aa1ad36fbeb40d3b3bb323d01e674fd_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/connections/CONNECTION-ID' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"options\": { \"client_id\": \"...\", \"client_secret\": \"...\", \"authParamsMap\": { \"custom_param\": \"access_type\" }, \"scripts\": { \"fetchUserProfile\": \"...\" }, \"authorizationURL\": \"https://auth.example.com/oauth2/authorize\", \"tokenURL\": \"https://auth.example.com/oauth2/token\", \"scope\": \"auth\" }, \"enabled_clients\": [ \"...\" ] }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParamsMap\\\": { \\\"custom_param\\\": \\\"access_type\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\"\n\n\tpayload := strings.NewReader(\"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParamsMap\\\": { \\\"custom_param\\\": \\\"access_type\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParamsMap\\\": { \\\"custom_param\\\": \\\"access_type\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/connections/CONNECTION-ID',\n  headers: {'content-type': 'application/json'},\n  data: {\n    options: {\n      client_id: '...',\n      client_secret: '...',\n      authParamsMap: {custom_param: 'access_type'},\n      scripts: {fetchUserProfile: '...'},\n      authorizationURL: 'https://auth.example.com/oauth2/authorize',\n      tokenURL: 'https://auth.example.com/oauth2/token',\n      scope: 'auth'\n    },\n    enabled_clients: ['...']\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"options\": @{ @\"client_id\": @\"...\", @\"client_secret\": @\"...\", @\"authParamsMap\": @{ @\"custom_param\": @\"access_type\" }, @\"scripts\": @{ @\"fetchUserProfile\": @\"...\" }, @\"authorizationURL\": @\"https://auth.example.com/oauth2/authorize\", @\"tokenURL\": @\"https://auth.example.com/oauth2/token\", @\"scope\": @\"auth\" },\n                              @\"enabled_clients\": @[ @\"...\" ] };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParamsMap\\\": { \\\"custom_param\\\": \\\"access_type\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\",\n  CURLOPT_HTTPHEADER => [\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParamsMap\\\": { \\\"custom_param\\\": \\\"access_type\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\"\n\nheaders = { 'content-type': \"application/json\" }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/connections/CONNECTION-ID\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{ \\\"options\\\": { \\\"client_id\\\": \\\"...\\\", \\\"client_secret\\\": \\\"...\\\", \\\"authParamsMap\\\": { \\\"custom_param\\\": \\\"access_type\\\" }, \\\"scripts\\\": { \\\"fetchUserProfile\\\": \\\"...\\\" }, \\\"authorizationURL\\\": \\\"https://auth.example.com/oauth2/authorize\\\", \\\"tokenURL\\\": \\\"https://auth.example.com/oauth2/token\\\", \\\"scope\\\": \\\"auth\\\" }, \\\"enabled_clients\\\": [ \\\"...\\\" ] }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\"content-type\": \"application/json\"]\nlet parameters = [\n  \"options\": [\n    \"client_id\": \"...\",\n    \"client_secret\": \"...\",\n    \"authParamsMap\": [\"custom_param\": \"access_type\"],\n    \"scripts\": [\"fetchUserProfile\": \"...\"],\n    \"authorizationURL\": \"https://auth.example.com/oauth2/authorize\",\n    \"tokenURL\": \"https://auth.example.com/oauth2/token\",\n    \"scope\": \"auth\"\n  ],\n  \"enabled_clients\": [\"...\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections/CONNECTION-ID\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nNow when calling the `/authorize` endpoint, you can pass the access type in the `access_type` parameter, and that value will in turn be passed along to the authorization endpoint in the `custom_param` parameter.\n\nIn some instances, you will need to pass extra headers to the Token endpoint of an OAuth 2.0 provider. To configure extra headers, open the Settings for the Connection, and in the **Custom Headers** field, specify a JSON object with the custom headers as key-value pairs:\n\n```\n{\n    \"Header1\" : \"Value\",\n    \"Header2\" : \"Value\"\n}\n```\n\nLet's use an example where an Identity Provider may require you to pass an `Authorization` header with [Basic access authentication](https://en.wikipedia.org/wiki/Basic_access_authentication) credentials. In this scenario, you can specify the following JSON object in the **Custom Headers** field:\n\n```\n{\n  \"Authorization\": \"Basic [your credentials]\"\n}\n```\n\nWhere `[your credentials]` are the actual credentials to send to the Identity Provider.\n\n## Learn more\n\n*   [Social Identity Providers](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers)\n*   [Identity Providers](https://auth0.com/docs/authenticate/identity-providers)\n*   [Protocols](https://auth0.com/docs/authenticate/protocols)",
    "title": "Connect Apps to Generic OAuth2 Authorization Servers",
    "description": "Learn how to add any OAuth2 provider using Auth0 Custom Social Connections.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/apple-native",
    "markdown": "# Add Sign In with Apple to Native iOS Apps\n\nYou can add functionality to your native iOS application to allow your users to authenticate using Sign In with Apple. For more implementation details, you can try the Auth0 [iOS Swift - Sign In with Apple Quickstart](https://auth0.com/docs/quickstart/native/ios-swift-siwa).\n\n## How it works\n\nFor a native app, the Sign in with Apple login flow works as follows:\n\n![Diagram of the Sign In with Apple Authentication Flow](https://images.ctfassets.net/cdy7uua7fh8z/I7xtPQoqoAFiHQiT2p7p5/8646a5231491dfbe64bd6a825ccc8ce7/apple-siwa-authn-flow.png)\n\n*   **Steps 1 & 2**: User authenticates via Apple's SDK on their iOS device, and receive an authorization code in the response. The user does not have to leave the app and use a browser to log in.\n    \n*   **Step 3**: The application calls Auth0's `/oauth/token` endpoint to exchange the Apple authorization code for Auth0 tokens.\n    \n*   **Step 4 & 5**: The Auth0 platform exchanges the Authorization code with Apple for tokens. Auth0 validates the tokens, and uses the claims in the tokens to construct the identity of the user.\n    \n*   **Step 6**: Auth0 saves the user profile, executes rules and authorization, then issues Auth0 access tokens (refresh tokens and ID tokens) as requested. These tokens are used to protect your APIs and users managed by Auth0.\n    \n\n## Prerequisites\n\nBefore you configure Sign In with Apple for your native app in Auth0, you must:\n\n*   Have an [Apple Developer](https://developer.apple.com/programs/) account, which is a paid account with Apple. (There is no free trial available unless you are part of their [iOS Developer University Program](https://developer.apple.com/support/compare-memberships/).)\n    \n*   [Register Your App in the Apple Developer Portal](https://marketplace.auth0.com/integrations/apple-social-connection) if you have not already done so. Make a note of the following IDs and key for the application connection settings in the Auth0 Dashboard:\n    \n    *   App ID\n        \n    *   Apple Team ID\n        \n    *   Client Secret Signing Key\n        \n    *   Key ID\n        \n*   If you are using the Classic Login flow or embedding `Lock.js` in your application, make sure you are using `Lock.js` version 11.16 or later.\n    \n\n## Configure and enable the connection in Auth0\n\nOnce you have the credentials you need from your Apple Developer account, you need to configure the application client and the connection settings in Auth0.\n\n1.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), choose your application, and select the gear icon to view the settings page.\n    \n2.  At the bottom of the page, select **Show Advanced Settings** and then the **Device Settings** view. Under **Native Social Login**, enable the **Enable Sign In with Apple** toggle.\n    \n    ![Application Client Settings: Advanced Device Settings](https://images.ctfassets.net/cdy7uua7fh8z/2xkQ13r9yCb4GBZdeczZjJ/5e95b6039b77bf9cfd6067fba343db8e/dashboard-applications-edit_view-settings-advanced_device-settings_native_apple-enabled.png)\n3.  Under **iOS**, fill in the **App ID** field with the native app's App ID/Bundle Identifier.\n    \n4.  Navigate to [Auth0 Dashboard > Authentication > Social](https://manage.auth0.com/#/connections/social), and select **Create Connection**.\n    \n5.  Select the **Apple** connection and consent.\n    \n6.  On the **Settings** tab, fill in the following fields:\n    \n    *   **Apple Team ID**\n        \n    *   **Client Secret Signing Key**\n        \n    *   **Key ID**\n        \n        ![Apple Social Connection Settings](https://images.ctfassets.net/cdy7uua7fh8z/3mTTVYnrwbVYnUx5Mzy0V9/0ab8174a812908c9290663d3d9d05286/dashboard-connections-social-create_enter-details_apple.png)\n7.  Select the **Applications** view to enable this connection for your application.\n    \n8.  Click **Save**.\n    \n\n## Logout\n\nSince the Native iOS login implementation does not make use of standard browser-based flows, application owners must also take care to perform logout appropriately. When an application needs to perform a logout, it must take the following actions:\n\n*   [Revoke the Auth0 Refresh Token](https://auth0.com/docs/api/authentication#revoke-refresh-token)\n    \n*   Delete the Auth0 refresh token stored in the iCloud Keychain\n    \n*   Delete the Apple user identifier stored in the iCloud keychain Also, keep in mind that logout can result from user actions (for example, clicking a \"log out\" button) or from a user revoking access to the given app. The latter will be indicated through the native [ASAuthorizationAppleIDProvider.getCredentialState](https://developer.apple.com/documentation/authenticationservices/asauthorizationappleidprovider/3175423-getcredentialstate) method.\n    \n\n## Learn more\n\n*   [Rate Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy)",
    "title": "Add Sign In with Apple to Native iOS Apps",
    "description": "Learn how to add native login functionality to your native app with Apple. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/reprompt-permissions",
    "markdown": "# Handle Declined Authorization Permissions\n\nWhen your users are authorizing your application, some providers (such as Facebook) allow the user to select the attributes they wish to share.\n\nBy default, this selection is made only when the user authorizes the app for the first time. If your user chooses to not allow certain attributes (such as their email) that are required by your application, the user will not be able to access your application.\n\nIn such instances, your user will need to be re-prompted to grant permission to the required attribute(s) to login.\n\n## Re-prompt for permissions\n\nBy setting the **prompt=consent** parameter when calling the [/authorize](https://auth0.com/docs/api/authentication/reference#social) endpoint of the [Authorization API](https://auth0.com/docs/api/authentication), your user will be prompted again to grant permissions for your application.\n\nThis parameter can also be set using Lock as an [Authentication Parameter](https://auth0.com/docs/libraries/lock/lock-authentication-parameters) with **prompt: 'consent'**.\n\nAlternatively, you can set this with [Auth0.js](https://github.com/auth0/auth0.js) using **prompt: 'consent'**.\n\n## Keep reading\n\n*   [Learn more about handling declined Facebook permissions](https://developers.facebook.com/docs/facebook-login/handling-declined-permissions)\n    \n*   [Learn more about GitHub scopes](https://developer.github.com/v3/oauth/#scopes)",
    "title": "Handle Declined Authorization Permissions",
    "description": "Learn how to re-prompt the user to grant permissions for your application.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/facebook-native",
    "markdown": "# Add Facebook Login to Native Apps\n\nYou can add functionality to your native application to allow your users to authenticate using Facebook natively, within the application. This does not require redirection via a web browser and will let mobile applications comply with the [Facebook Developer Policy](https://developers.facebook.com/policy/), which requires that mobile applications use the Facebook SDK for [Android](https://developers.facebook.com/docs/android) or [iOS](https://developers.facebook.com/docs/ios) to authenticate.\n\n## How it works\n\nThe Native Facebook login flow works as follows:\n\n*   **Step 1**: The application authenticates a user via the Facebook SDK and acquires an Access Token.\n    \n*   **Step 2**: The application uses that Access Token to request a special [Facebook Session Info Access Token](https://developers.facebook.com/docs/facebook-login/access-tokens/session-info-access-token).\n    \n*   **Step 3**: Use the Facebook SDK to retrieve the users's profile.\n    \n*   **Step 4**: The application can then use the Facebook Session Info token to authenticate with Auth0.\n    \n\n## Prerequisites\n\nBefore you configure Native Facebook login for your native app via Auth0, you must:\n\n1.  [Set up Facebook as an Auth0 connection](https://marketplace.auth0.com/integrations/facebook-social-connection)\n    \n2.  [Use the relevant Facebook SDK in your application](https://developers.facebook.com/docs/apis-and-sdks/)\n    \n3.  Navigate to [Auth0 Dashboard > Applications > Applications](https://manage.auth0.com/#/applications), and create an application with Auth0 (if you have not already).\n    \n4.  At the bottom of the settings page, select **Show Advanced Settings** and then the **Device Settings** view. Under **Native Social Login**, enable the **Enable Sign In with Facebook** toggle.\n    \n    ![Native Social Login Settings](https://images.ctfassets.net/cdy7uua7fh8z/5p2RaaeAtZyJzcoCfkF4tW/19b4592f966f983229e3d9ece67d0089/dashboard-applications-edit_view-settings-advanced_device-settings_facebook-enabled.png)\n\n## Implementation\n\nThe process to authenticate a user profile using Native Facebook login is a four-step one, from your application's perspective:\n\n### Step 1\n\nThe application authenticates a user via the Facebook SDK. It will obtain an Access Token from Facebook.\n\n## Step 2\n\nThe application uses the Access Token to request a [Facebook Session Info Access Token](https://developers.facebook.com/docs/facebook-login/access-tokens/session-info-access-token).\n\nThis request will look similar to the following:\n\n```\nGET https://graph.facebook.com/v5.0/oauth/access_token?grant_type=fb_attenuate_token&client_id=457704041391802&fb_exchange_token=<facebook_access_token>\n```\n\nand the response:\n\n```\n{\n    \"access_token\": \"XAAGgR4b...1lHWNCpqrAhcpoAZDZD\",\n    \"token_type\": \"bearer\",\n    \"expires_in\": 5183924\n}\n```\n\n### Step 3\n\nThe application needs to retrieve the user profile from Facebook using the Facebook SDK, which will end in a request similar to the following:\n\n```\nGET https://graph.facebook.com/v5.0/<facebook user id>?access_token=<facebook access token>&fields=email,name\n```\n\n### Step 4\n\nThe application can then use the session info Access Token and the Facebook user profile to authenticate with Auth0 by calling Auth0's `/oauth/token` endpoint using the Token Exchange flow with the `facebook-session-access-token` token type. If all goes well, Auth0 will return a normal response from the exchange, with the addition of the user profile. The user profile should be a JSON object, encoded as a string.\n\nto configure this snippet with your account\n\n```\nPOST https://{yourDomain}/oauth/token\n\ngrant_type: 'urn:ietf:params:oauth:grant-type:token-exchange'\nsubject_token_type: 'http://auth0.com/oauth/token-type/facebook-info-session-access-token'\naudience: 'your-api'\nscope: 'read:appointments openid profile email email_verified'\nsubject_token: 'XAAGgR4b...1lHWNCpqrUHZAEtUuZAhcpoAZDZD'\nclient_id: '{yourClientId}'\nuser_profile: '{\"email\":\"john@example.com\", \"name\":\"John Doe\"}'\n```\n\nand the response from Auth0:\n\n```\n{\n    \"access_token\": \"eyJ0eXA..yXQaPLVXg\",\n    \"id_token\": \"eyJ0.tFE5HPipdOsA\",\n    \"scope\": \"openid profile email read:appointments\",\n    \"expires_in\": 86400,\n    \"token_type\": \"Bearer\"\n}\n```\n\n## User Profile and Email Validation\n\nIn the previous example, you had to retrieve the User Profile from Facebook and include it in the call to `/oauth/token`. This is because the Facebook Session Access Token cannot be used to directly retrieve the profile, and the Facebook Access Token cannot be sent directly to the server, due to [Apple's AppStore Review Guidelines](https://developer.apple.com/app-store/review/guidelines). Therefore, it must be retrieved in the client and sent to Auth0 in this fashion.\n\nGiven that Auth0 can't guarantee that the user profile is the same that was returned by Facebook, it will set the `email_verified` field to `false`.\n\n## Logout\n\nSince the native login implementation does not make use of standard browser-based flows, application owners must also take care to perform logout appropriately. When an application needs to perform a logout, it should also [Revoke the Auth0 Refresh Token](https://auth0.com/docs/api/authentication#revoke-refresh-token).\n\n## Keep reading\n\n*   [Native Facebook Login with iOS Swift](https://auth0.com/docs/quickstart/native/ios-swift-facebook-login)\n    \n*   [Native Facebook Login with Android](https://auth0.com/docs/quickstart/native/android-facebook-login)\n    \n*   [Rate Limits on Native Social Logins](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/rate-limit-policy)",
    "title": "Add Facebook Login to Native Apps",
    "description": "Learn how to add login functionality to your native app with Facebook. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/devkeys",
    "markdown": "# Test Social Connections with Auth0 Developer Keys\n\nWhen using any of the available [social identity providers](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers), you need to register your application with the relevant identity provider in order to obtain a Client ID and Client Secret.\n\nAuth0 developer keys are not available in [Private Cloud deployments](https://auth0.com/docs/deploy-monitor).\n\nFor production environments, make sure to [follow the steps for your chosen provider](https://auth0.com/docs/authenticate/identity-providers) to obtain the Client ID and Client Secret from the provider to avoid the [limitations](#limitations-of-developer-keys) of using developer keys. For instructions on converting Google developer keys to production keys, [read this Auth0 Developer Lab.](https://developer.auth0.com/resources/labs/authentication/google-social-connection-to-login#set-up-google-production-keys)\n\n#### Custom developer keys\n\nOne or more connections are using Auth0 development keys which are only intended for use in development and testing. The connections should be configured with your own Developer Keys to enable the consent page to show your logo instead of Auth0's and to configure Single Sign-on (SSO) for these connections. Auth0 development keys are not recommended for Production environments.\n\n#### Client ID and Client Secret\n\nThe exact terminology of a Client ID / Client Secret may differ between various Identity Providers. For example, X refers to these as a Consumer Key / Consumer Secret and LinkedIn refers to an API Key / Secret Key.\n\n## Limitations of developer keys\n\nThe Auth0 developer keys are to be used for testing purposes so there are a few caveats you need to be aware of when using them. These may cause your application to behave differently--or some functionality to not work at all--depending on whether you use your own Client ID and Client Secret, or whether you use the Auth0 developer keys.\n\nWhen using the Auth0 developer keys, the authentication flow for the various identity providers may display Auth0's name, logo, and information to your users. When you register your own application, you have the opportunity to use your own logo and other application information instead.\n\n![Consent screen](https://images.ctfassets.net/cdy7uua7fh8z/5YcLIDCt3RaAkmK1cTeCJL/e85e16195e84aa52f7675faacd126853/consent-screen.png)\n\n## Limitations of developer keys when using Universal Login\n\nIf you are using the [Classic Login experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience) - and in some circumstances, the [Universal Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/new-experience) - the follow limitations also apply:\n\n1.  You cannot use developer keys with [custom domains](https://auth0.com/docs/customize/custom-domains).\n    \n2.  [Single Sign-On](https://auth0.com/docs/authenticate/single-sign-on) will not function properly when using the Auth0 developer keys. The reason for this is that the Auth0 developer applications with all the relevant Identity Providers are configured to call back to the URL `https://login.auth0.com/login/callback` instead of the **callback URL** for your own tenant, for example `https://{yourDomain}/login/callback`. This results in the SSO cookie not being set on your own tenant domain, so the next time a user authenticates, no SSO cookie will be detected, even if you configured your application to **Use Auth0 instead of the Identity Provider to do Single Sign-on** (legacy tenants only).\n    \n3.  [Redirecting users from Rules](https://auth0.com/docs/customize/rules/redirect-users) will not function properly. This is because redirect rules are resumed on the endpoint `https://{yourDomain}/continue`. When using Auth0's developer keys, the session is established on a special endpoint that is generic and tenant agnostic, and calling `/continue` will not find your previous session, resulting in an error.\n    \n4.  [Federated Logout](https://auth0.com/docs/authenticate/login/logout) does not work. When using the Auth0 developer keys, calling `/v2/logout?federated` will sign the user out of Auth0, but not out of the Social Identity Provider.\n    \n5.  `prompt=none` won't work on the [/authorize](https://auth0.com/docs/api/authentication/reference#social) endpoint. [Auth0.js](https://auth0.com/docs/libraries/auth0js)' checkSession() method uses `prompt=none` internally, so that won't work either.\n    \n6.  If Auth0 is acting as a SAML Identity Provider, and you use a social connection with the Auth0 developer keys, the generated SAML response will have some errors, like a missing `InResponseTo` attribute or an empty `AudienceRestriction` element.\n    \n7.  [Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication) will not function properly. When MFA authentication is successful, a post will generate in `https://{yourDomain}/mf`. When using Auth0's developer keys, the session is established on a special endpoint that is generic and tenant agnostic, and calling `/mf` will not find your previous session, resulting in an error",
    "title": "Test Social Connections with Auth0 Developer Keys",
    "description": "Explore what you need to be aware of when using Auth0 Developer Keys with social identity providers.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/tiktok",
    "markdown": "# Create a Custom Social Connection with TikTok\n\n## Configure TikTok\n\nYou can use TikTok as a social login to your application. Access and configure your TikTok developer account using the following steps:\n\n1.  In TikTok developer, select **Manage apps**.\n    \n2.  Select **Connect an app**.\n    \n3.  Under the **Configuration** section, add an application icon, application name, and description.\n    \n4.  Under **Platforms**, choose your application type:\n    \n    1.  For Web applications, add a valid URL.\n        \n    2.  For Android, add the Android package name, Play Store URL, and application signature(s).\n        \n    3.  For iOS, add the App Store URL and Bundle ID.\n        \n5.  Under the Product menu, select **Add Product**.\n    \n6.  Select the **Login Kit**.\n    \n7.  Then, select the **TikTok API**.\n    \n8.  In the Product section, add the URL of your Terms of Service page, the URL of your Privacy Policy page, and your redirect domain to the Login Kit. The redirect domain is your Auth0 domain found in [Dashboard > Applications > Applications](http://manage.auth0.com/#/applications) under the **Settings** tab. For example: `dev-test-1.us.auth0.com`.\n    \n9.  Select **Save Changes**. Then, select **Submit for review**.\n    \n10.  Wait until your application status moves from `Staging` to `Production`. It could take up to several hours for TikTok to review your application and update the status.\n    \n\n## Configure Auth0\n\nYou must create a custom connection to associate your TikTok instance with Auth0.\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Social](http://manage.auth0.com/#/social).\n    \n2.  Choose **Create Connection**.\n    \n3.  Scroll to the bottom of the list and choose **Create Custom**.\n    \n4.  Enter the following to create a **New Custom Social Connection**:\n    \n    1.  Name: TikTok\n        \n    2.  Authorization URL: TikTok’s Authorization URL `https://www.tiktok.com/auth/authorize/`\n        \n    3.  Token URL: This will eventually be your proxy. Use a placeholder URL: `https://example.com`\n        \n    4.  Scope: `user.info.basic`\n        \n    5.  Client ID: Client key assigned to you by TikTok\n        \n    6.  Client Secret: Client secret assigned to you by TikTok\n        \n5.  Configure the [Fetch User Profile Script](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/oauth2#fetch-user-profile-script) to fetch profile information from [TikTok's user\\_info endpoint](https://developers.tiktok.com/doc/tiktok-api-v2-get-user-info/). Map attributes to Auth0’s normalized user profile.\n    \n\n```\nfunction fetchUserProfile(accessToken, context, cb) {\n  const axios = require('axios@0.22.0');\n  const userInfoEndpoint = 'https://open.tiktokapis.com/v2/user/info?fields=union_id';\n  const headers = { 'Authorization': 'Bearer ' + accessToken };\n\n  axios\n    .get(userInfoEndpoint, { headers })\n    .then(res => {\n      if (res.status !== 200) {\n        return cb(new Error(res.data));\n      }\n\n      const profile = {\n        user_id: res.data.user.union_id,\n      };\n\n      cb(null, profile);\n    })\n    .catch(err => cb(err));\n}\n```\n\n6\\. Click **Create**.\n\n7\\. Navigate to the application you want to use with the TikTok connection under [Dashboard > Applications > Applications](http://manage.auth0.com/#/applications).\n\n8\\. Under the **Connections** tab, toggle on the TikTok option.\n\n## Pass customs parameters to TikTok with the Management API\n\nSince TikTok uses a `client_key` parameter instead of `client_id`, you must use the Management API to pass the `client_key` parameter during authentication.\n\nTo use the Management API, you need to generate an access token.\n\n1.  Navigate to Auth0 [Dashboard > Applications > APIs](http://manage.auth0.com/#/apis) and select the **Auth0 Management API**.\n    \n2.  Select the **API Explorer** tab.\n    \n3.  Select **Create & Authorize Test Application.**\n    \n    ![Screenshot of Create & Authorize Test Application for TikTok](https://images.ctfassets.net/cdy7uua7fh8z/6S8RzEMC4lV9bS7XCPWRMY/697d0270b3623a70d4406985361a9b1b/image3.png)\n4.  Copy the provided token.\n    \n5.  Navigate to the [Auth0 Management API Explorer](https://auth0.com/docs/api/management/v2). You may need to open an incognito window.\n    \n6.  Select **Set API Token** in the top, left-hand corner.\n    \n    ![Screenshot of Set API Token for TikTok](https://images.ctfassets.net/cdy7uua7fh8z/6994KjTIdvDNrye8ghN4og/a6d1eb83bce4a5b38f8ebce7188ee2ca/image2.png)\n7.  Paste the token and select **Set Token**.\n    \n\nYou should now be able to configure your Auth0 tenant with the Management API.\n\n### Configure the \\`client\\_key\\` field\n\n1.  Use the [Get a connection](https://auth0.com/docs/api/management/v2#!/Connections/get_connections_by_id) method to retrieve the \\`options\\` object values. The following is a sample response object:\n    \n\n```\n{\n  \"options\": {\n    \"client_id\": \"\",\n    \"client_secret\": \"\",\n    \"scope\": \"user.info.basic\"\n  }\n}\n```\n\n2\\. Add the `upstream_params` object with the `client_key` field:\n\n```\n{\n  \"options\": {\n    \"client_id\": \"\",\n    \"client_secret\": \"\",\n    \"scope\": \"user.info.basic\",\n    \"upstream_params\": { \n      \"client_key\": { \"value\": \"<Client Key from TikTok>\" } \n    }\n  }\n}\n```\n\n3\\. Use the [Update a connection](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id) method with the `options` object as the body. Auth0 will send the `client_key=<value>` parameter to [TikTok's authorization endpoint](https://developers.tiktok.com/doc/login-kit-web/).\n\n## Access token request\n\nYou cannot pass custom parameters in a request to the Authentication API's [`/token`](https://developers.tiktok.com/doc/login-kit-manage-user-access-tokens/) endpoint to gain an access or ID token. You must proxy the request to the token endpoint and append the `client_key` parameter programmatically with proxy endpoints in your environment.\n\n### Deploy TikTok integration proxy\n\n1.  Use the sample code from the [GitHub](https://github.com/tylerkeesling/tiktok-access-token-proxy) repository and follow the instructions in the README to install dependencies and start the development server.\n    \n    1.  The example server has one `POST` route, `/proxy/token`. The server should be running on `http://localhost:3333`. \n        \n2.  Copy the proxy endpoint to be used in your TikTok Developer setup. The proxy endpoint should be something similar to: [`https://405a-104-129-13b-250.ngrok.io/proxy/token`](https://405a-104-129-13b-250.ngrok.io/proxy/token).\n    \n3.  In TikTok Developer, navigate back to the social connection configuration. Update the Token URL that you set to `https://example.com` and enter the proxy URL.\n    \n\nOnce the configuration is saved, your users should be able to log in with TikTok.",
    "title": "Create a Custom Social Connection with TikTok",
    "description": "Learn how to create a custom social connection with TikTok ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/organizations/configure-organizations/enable-connections",
    "markdown": "# Enable Organization Connections\n\nYou can enable specific connections for each [organization](https://auth0.com/docs/manage-users/organizations/organizations-overview) to provide users with different login options. After you enable a connection, it is added to the organization login prompt, and users can authenticate through that connection to access your applications.\n\nTo enable a connection for an organization, the connection **must** already exist in your tenant. Supported connections include [database connections](https://auth0.com/docs/connections/database), [social connections](https://auth0.com/docs/connections/identity-providers-social), and [enterprise connections](https://auth0.com/docs/connections/identity-providers-enterprise).\n\n## Organization Properties\n\nWhen using organizations, some connections have additional properties that you can configure:\n\n| **Property** | **Connection Types** | **Description** |\n| --- | --- | --- |\n| Membership On Authentication | All connection types | When enabled, this property automatically assigns organization membership to end-users the first time they authenticate with the connection.<br><br>Membership on Authentication is useful in scenarios where all users with the ability to authenticate with a specific connection can be assumed to be members of an organization. |\n| Organization Signup | Database connections only | This property determines whether or not end-users can access a signup link on the login prompt that allows them to gain membership to an Organization. To use Organization Signup, you must also enable Membership On Authentication.<br><br>Organization Signup is useful is scenarios where users need self-service access to join Organizations, such as:<br><br>*   When Organizations are used to model open-membership user populations such as workspaces.<br>*   In business-to-business-to-consumer (B2B2C) use cases where users can freely sign up for accounts. |\n| Display connection as a button | Enterprise connections only | This optional property determines whether or not a specific connection displays as an option on the organization login prompt.<br><br>**Note**: If this option is disabled for a connection, end-users can still authenticate via the connection and log in to applications in the context of the organization by sending the connection parameter directly in the authorization request. They can also authenticate with this connection if you are using the [Identifier First with Home Realm Discovery](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication profile in combination with the [Prompt for Credentials](https://auth0.com/docs/manage-users/organizations/login-flows-for-organizations#configure-the-login-flow-for-your-application) organization login flow. |\n\n## Configure Organization Connections\n\nYou can configure connections for organizations using either the Auth0 Dashboard or the Management API.\n\n#### Auth0 Dashboard\n\nTo enable a connection via the Auth0 Dashboard:\n\n1.  Navigate to [Auth0 Dashboard > Organizations](https://manage.auth0.com/#/organizations), and select the organization for which you want to configure connections.\n    \n2.  Select the **Connections** view, then select **Enable Connections**.\n    \n3.  Choose the connection you want to enable, and select **Enable Connection**.\n    \n4.  In the Authentication section, locate **Membership On Authentication** and choose whether to enable or disable auto-membership. When enabled, auto-membership automatically adds all users logging in with the connection as members of the organization.\n    \n5.  **For Database connections only**: In the Organization Signup section, choose whether to enable or disable self-service signups. When enabled, users can access a signup link on the login prompt to create their account and automatically gain membership to the organization.\n    \n    *   **Note**: To enable this property, you must first enable **Membership on Authentication**.\n        \n6.  **For Enterprise connections only**: In the Connection button section, optionally enable the **Display connection as a button** property to display the connection as an option on the organization login prompt.\n    \n7.  Select **Save**.",
    "title": "Enable Organization Connections",
    "description": "Learn to enable Organization connections using the Auth0 Dashboard and Management API.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/adfs",
    "markdown": "# Connect Your App to ADFS\n\nTo connect your application to Microsoft's Active Directory Federation Services (ADFS), you will need to provide the following information to your ADFS administrator:\n\n*   Realm Identifier: `urn:auth0:{yourTenant}`\n    \n*   Endpoint: `https://{yourDomain}/login/callback` or `https://<YOUR CUSTOM DOMAIN>/login/callback`, if you are using a [custom domain](https://auth0.com/docs/customize/custom-domains).\n    \n\n#### Federated metadata\n\nThe Federation Metadata file contains information about the ADFS server's certificates. If the Federation Metadata endpoint (`/FederationMetadata/2007-06/FederationMetadata.xml`) is enabled in ADFS, Auth0 can periodically (once a day) look for changes in the configuration, like a new signing certificate added to prepare for a rollover. Because of this, enabling the Federation Metadata endpoint is preferred to providing a standalone metadata file. If you provide a standalone metadata file, we will notify you via email when the certificates are close to their expiration date.\n\nYou can use a script to to setup the connection or set it up manually.\n\n## Scripted setup\n\nRun the following two commands in the Windows PowerShell window.\n\n```\n(new-object Net.WebClient -property @{Encoding = [Text.Encoding]::UTF8}).DownloadString(\"https://raw.github.com/auth0/adfs-auth0/master/adfs.ps1\") | iex\n```\n\n```\nAddRelyingParty \"urn:auth0:{yourTenant}\" \"https://{yourDomain}/login/callback\"\n```\n\nFor automated integration, this script uses the [ADFS PowerShell SnapIn](http://technet.microsoft.com/en-us/library/adfs2-powershell-basics.aspx) to create and configure a **Relying Party** that will issue, for the authenticated user, the following claims: **email**, **upn**, **given name**, and **surname**.\n\nThe script creates the Relying Party Trust on ADFS, as follows:\n\n```\n$realm = \"urn:auth0:{yourTenant}\";\n$webAppEndpoint = \"https://{yourDomain}/login/callback\";\nAdd-PSSnapin Microsoft.Adfs.Powershell\nAdd-ADFSRelyingPartyTrust -Name $realm -Identifier $realm -WSFedEndpoint $webAppEndpoint\n$rp = Get-ADFSRelyingPartyTrust -Name $realm\n```\n\nThe script also creates rules to output the most common attributes, such as email, UPN, given name, or surname:\n\n```\n$rules = @'\n@RuleName = \"Store: ActiveDirectory -> Mail (ldap attribute: mail), Name (ldap attribute: displayName), Name ID (ldap attribute: userPrincipalName), GivenName (ldap attribute: givenName), Surname (ldap attribute: sn)\"\nc:[Type == \"http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsaccountname\", Issuer == \"AD AUTHORITY\"]\n=> issue(store = \"Active Directory\",\n    types = (\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\",\n             \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\",\n             \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n             \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\",\n             \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\"), query = \";mail,displayName,userPrincipalName,givenName,sn;{0}\", param = c.Value);\n'@\nSet-ADFSRelyingPartyTrust –TargetName $realm -IssuanceTransformRules $rules\n$rSet = New-ADFSClaimRuleSet –ClaimRule '=> issue(Type = \"http://schemas.microsoft.com/authorization/claims/permit\", Value = \"true\");'\nSet-ADFSRelyingPartyTrust –TargetName $realm –IssuanceAuthorizationRules $rSet.ClaimRulesString\n```\n\n## Manual setup part 1: Add a Relying Party Trust\n\n1.  Open the ADFS Management Console.\n    \n2.  On the right side of the console, click **Add Relying Party Trust**\\*\n    \n3.  Click **Start**.\n    \n4.  Select **Enter data about the relying party manually**, and click **Next**.\n    \n5.  Type a name (such as `{yourAppName}`), and click **Next**.\n    \n6.  Use the default (`ADFS 2.0 profile`), and click **Next**.\n    \n7.  Use the default (`no encryption certificate`), and click **Next**.\n    \n8.  Check **Enable support for the WS-Federation...**, and type this value in the textbox: `https://{yourDomain}/login/callback`,or if you are using a [custom domain](https://auth0.com/docs/customize/custom-domains), use `https://<YOUR CUSTOM DOMAIN>/login/callback`\n    \n9.  Click **Next**.\n    \n10.  Add a Relying Party Trust identifier with this value: `urn:auth0:{yourTenant}`\n    \n11.  Click **Add**, and then **Next**.\n    \n12.  Leave the default `Permit all users...`, and click **Next**.\n    \n13.  Click **Next**, and then **Close**.\n    \n\n## Manual setup part 2: Add a claim issuance policy rule\n\n1.  If you're using Windows Server 2019, the Edit Claim Issuance Policy dialog box automatically opens when you finish the Add Relying Party Trust wizard. If you're using Windows 2012 or 2016, follow these steps:\n    \n    | In Windows Server 2012 | In Windows Server 2016 |\n    | --- | --- |\n    | In the Actions panel on the right side of the console, find the Relying Party Trust you just created. Beneath it, click **Edit Claim Issuance Policy**. | In the console tree, under ADFS, click **Relying Party Trusts**. On the right side of the console, find the Relying Party Trust you just created. Right-click it and click **Edit Claim Issuance Policy**. |\n    \n2.  In the Edit Claim Issuance Policy Window, under Issuance Transform Rules, click **Add Rule...**.\n    \n3.  Leave the default `Send LDAP Attributes as Claims`.\n    \n4.  Give the rule a name that describes what it does.\n    \n5.  Under Attribute Store, select **Active Directory**.\n    \n6.  Select these mappings under `Mapping of LDAP attributes to outgoing claim types`, and click **Finish**.\n    \n    | LDAP Attribute | Outgoing Claim Type |\n    | --- | --- |\n    | E-Mail-Addresses | E-Mail Address |\n    | Display-Name | Name |\n    | User-Principal-Name | Name ID |\n    | Given-Name | Given Name |\n    | Surname | Surname |\n    \n\n### Add additional LDAP attributes\n\nThe mappings in the previous steps are the most commonly used, but if you need additional LDAP attributes with information about the user, you can add more claim mappings.\n\n1.  If you closed the window on the previous step, select **Edit Claim Rules** on the context menu for the Relying Party Trust you created, and edit the rule.\n    \n2.  Create an additional row for every LDAP attribute you need, choosing the attribute name in the left column and desired claim type in the right column.\n    \n3.  If the claim type you are looking for doesn't exist, you have two options:\n    \n    1.  Type a [namespace-qualified name](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims) for the new claim (for example, `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/department`).\n        \n    2.  Register a new claim type (under **ADFS > Services > Claim Descriptions** on the ADFS admin console), and use the claim name in the mapping. Auth0 uses the name part of the claim type (for example `department` in `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/department`) as the attribute name for the user profile.\n        \n\n## Next Steps\n\nNow that you have a working connection, the next step is to configure your application to use it. You can follow our step-by-step quickstarts or use our libraries and API.\n\n*   [Get started with our Quickstarts](https://auth0.com/docs/quickstarts)\n    \n*   [Configure your application using our Lock login form](https://auth0.com/docs/libraries/lock)\n    \n*   [Configure your application using our Auth0.js library and your own UI](https://auth0.com/docs/libraries/auth0js)\n    \n*   [Use our Authentication API to authenticate](https://auth0.com/docs/api/authentication)",
    "title": "Connect Your App to ADFS",
    "description": "Learn how to connect your application to Active Directory Federation Services (ADFS) using enterprise connections.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap",
    "markdown": "# Connect Your App to Active Directory using LDAP\n\nAuth0 integrates with Active Directory (AD) using Lightweight Directory Access Protocol (LDAP) through an **Active Directory/LDAP Connector** that you install on your network.\n\nThe **AD/LDAP Connector** (1), is a bridge between your **Active Directory/LDAP** (2) and the **Auth0 Service** (3). This bridge is necessary because AD/LDAP is typically restricted to your internal network, and Auth0 is a cloud service running in a completely different context.\n\n![Overview Diagram of AD/LDAP Connector](https://images.ctfassets.net/cdy7uua7fh8z/2HT4cRvUDzA2OdEPlfgLDV/be32ffe82562dc8f07fdd2097f14d881/ldap-connect.png)\n\nFor [high availability and load balancing](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/ad-ldap-high-availability), you can install multiple instances of the connector. All connections are outbound from the connector to the Auth0 Server, so changes to your firewall are generally unnecessary.\n\n## Prerequisites\n\nBefore beginning:\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n    *   Select an appropriate **Application Type**.\n        \n    *   Add an **Allowed Callback URL** of `**{https://yourApp/callback}**`.\n        \n    *   Make sure your Application's [**Grant Types**](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n        \n\n## Steps\n\nTo connect your application to Active Directory/LDAP, you must:\n\n1.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0) and download the installer\n    \n2.  [Install the connector on your network](#install-the-connector-on-your-network)\n    \n3.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application)\n    \n4.  [Test the connection](#test-the-connection)\n    \n\n## Create an enterprise connection in Auth0\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **Active Directory / LDAP**, and select its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create**:\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant. Once set, this name can't be changed. |\n    | **Display name** (optional) | Text used to customize the login button for Universal Login. When set, the Universal Login login button reads: \"Continue with {Display name}\". |\n    | **Logo URL** (optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    | **IdP Domains** (optional) | Comma-separated list of valid email domains that will be allowed to log in using this connection. Only needed if using the Lock login widget. |\n    | **Disable cache** | When enabled, disables caching. |\n    | **Use client SSL certificate authentication** | When enabled, uses client SSL certificate authentication. |\n    | **Use Windows Integrated Auth (Kerberos)** | When enabled, you will be asked to enter a range of IP addresses. When users log in through these IP addresses, Kerberos will be used; otherwise, AD/LDAP username/password will be requested. Typically, the IP range entered represent intranet addresses. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    \n    ![Enter AD / LDAP Connection Details](https://images.ctfassets.net/cdy7uua7fh8z/2IR80sIwNNyPlDMxIjWv8e/b6748243f90ce0e7d771a39cef24cb0f/LDAP_Connection__1_.png)\n3.  Download the provided installer and make note of the provided **Provisioning Ticket URL**.\n    \n\n## Install the connector on your network\n\nSet up the [AD/LDAP Connector](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector) by following the instructions for your platform:\n\n*   [Install the AD/LDAP Connector on Windows](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/install-configure-ad-ldap-connector)\n    \n*   [Install the AD/LDAP Connector on Non-Microsoft Platforms](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap/ad-ldap-connector/install-configure-ad-ldap-connector)\n    \n\n## Enable the enterprise connection for your Auth0 application\n\nTo use your new AD connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n## Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).\n\n## Next Steps\n\n*   [Integrate with Auth0 using one of our libraries](https://auth0.com/docs/libraries)\n    \n*   [Integrate with Auth0 using our Authentication API](https://auth0.com/docs/api/authentication)\n    \n*   [Read more about the authentication flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow)\n    \n*   [Pass additional parameters to the Identity Provider](https://auth0.com/docs/authenticate/identity-providers/pass-parameters-to-idps)\n    \n*   [Re-prompt users for permissions](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/reprompt-permissions)",
    "title": "Connect Your App to Active Directory using LDAP",
    "description": "Learn how to connect your app to Active Directory (AD) using Lightweight Directory Access Protocol (LDAP) through an enterprise connection.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/ping-federate",
    "markdown": "# Connect Your PingFederate Server to Auth0\n\nAuth0 lets you create [PingFederate Server](https://documentation.pingidentity.com/pingfederate/pf84/#gettingStartedGuide/concept/gettingStarted.html) connections.\n\n## Prerequisites\n\nBefore beginning:\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n    *   Select an appropriate **Application Type**.\n        \n    *   Add an **Allowed Callback URL** of **`{https://yourApp/callback}`**.\n        \n    *   Make sure your Application's [Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n        \n\n## Steps\n\nAs long as your server is configured in the standard way, to connect your PingFederate server to Auth0 you must:\n\n1.  [Get the signing certificate from the IdP](#get-the-signing-certificate-from-the-idp) and [convert it to Base64](#convert-signing-certificate-to-base64).\n    \n2.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0).\n    \n3.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application).\n    \n4.  [Test the connection](#test-the-connection).\n    \n\n## Get the signing certificate from the IdP\n\nWith PingFederate Server, Auth0 acts as the service provider, so you will need to retrieve an X.509 signing certificate from the IdP (in PEM or CER format); later, you will upload this to Auth0. The methods for retrieving this certificate vary, so please see the [PingFederate documentation](https://documentation.pingidentity.com/pingfederate/pf84/index.shtml#concept_digitalSignatureSettings.html) for instructions on managing your server's certificates.\n\n### Convert signing certificate to Base64\n\nBefore you upload the X.509 signing certificate to Auth0, you must convert the file to Base64. To do this, either use a [simple online tool](https://www.base64decode.org/) or run the following command in Bash: `cat signing-cert.crt | base64`.\n\n## Create an enterprise connection in Auth0\n\nNext, if your server is configured in the standard way, you will need to create and configure a PingFederate Enterprise Connection in Auth0 and upload your X.509 signing certificate. This task can be performed using Auth0's Dashboard.\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **Ping Federate**, and select its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create:**\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant. Once set, this name can't be changed. |\n    | **PingFederate Server URL** | URL for your PingFederate Server. |\n    | **X.509 Signing Certificate** | PingFederate Server public key (encoded in PEM or CER) you retrieved from the IdP earlier in this process. |\n    | **Sign Request** | When enabled, the SAML authentication request will be signed. (Be sure to download and provide the PingFederate server with your [tenant's certificate](https://{yourdomain}/pem).) |\n    | **Sign Request Algorithm** | Algorithm Auth0 will use to sign the SAML assertions. Ensure this matches your PingFederate Server's configuration. |\n    | **Sign Request Digest Algorithm** | Algorithm Auth0 will use for the sign request digest. Ensure this matches your PingFederate Server's configuration. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    \n    ![Configure Ping Federate Settings](https://images.ctfassets.net/cdy7uua7fh8z/6gBIIx0DC8363S1NNGBCqA/5e58d3fbde75661eb170d8bd0cbcda61/PingFederate.png)\n3.  In the **Login Experience** view, configure how users log in with this connection.\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Identity Provider domains** | A comma-separated list of the domains that can be authenticated in the Identify Provider. This is only applicable when using [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication with Universal Login. |\n    | **Add button** (Optional) | Display a button for this connection in the login page. |\n    | **Button display name** (Optional) | Text used to customize the login button for Universal Login. When set the button reads: \"Continue with {Button display name}\". |\n    | **Button logo URL** (Optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    \n\n## Enable the enterprise connection for your Auth0 application\n\nTo use your new PingFederate enterprise connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n## Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).",
    "title": "Connect Your PingFederate Server to Auth0",
    "description": "Learn how to create an enterprise connection between a PingFederate Server and Auth0.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory-native",
    "markdown": "# Connect Your Native App to Microsoft Azure Active Directory Using Resource Owner Flow\n\nIn addition to the WS-Federation and OpenID Connect flows, it's also possible to use the [Resource Owner](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow) flow with Azure AD. This flow allows you to capture and validate a user's credentials (email and password) instead of showing the Azure AD login page. For security and Single Sign-on (SSO) reasons, this is not the recommended approach; still, the Resource Owner flow can be useful in Native mobile scenarios or to batch-process authentication with Azure AD.\n\nThis configuration requires two applications: a Web Application and/or Web API, and a Native Application. From Azure AD's point of view, users will be authenticated using the Native Application to gain access to the Web Application and/or Web API.\n\n![Overview Diagram of Azure AD Apps using Resource Owner flow](https://images.ctfassets.net/cdy7uua7fh8z/6Uy9Q35rn0d9rankvlJuBT/6a5fa5175db76fd1cab35b79f0a213ea/azure-ad-native-app.png)\n\n## Prerequisites\n\n[Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications):\n\n1.  Select **Native** for the **Application Type**.\n    \n2.  Add an **Allowed Callback URL**. Your callback URL format will vary depending on your platform. For details about the format for your platform, see our [Native Quickstarts](https://auth0.com/docs/quickstart/native).\n    \n3.  Ensure your Application's [Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n    \n\n## Steps\n\nTo connect your application using Resource Owner flow, you must:\n\n1.  [Set up your applications in the Microsoft Azure portal](#set-up-your-applications-in-the-microsoft-azure-portal).\n    \n2.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0).\n    \n3.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application).\n    \n4.  [Test the connection](#test-the-connection).\n    \n\n## Set up your applications in the Microsoft Azure portal\n\n### Register a new web application\n\nTo learn how to register your application with Azure AD, read [Quickstart: Register an application with the Microsoft identity platform on Microsoft Docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app).\n\nWhile setting up your application, make sure you use the following settings:\n\n*   If you want to allow users from external organizations (like other Azure AD directories), select **Accounts in any organizational directory (Any Azure AD directory - Multitenant)** when setting **Supported account types**.\n    \n*   When asked to set a **Redirect URI**, select **Web** and enter your callback URL: `https://{yourDomain}/login/callback`.\n    \n\n#### Find your Auth0 domain name for redirects\n\nIf your Auth0 domain name is not shown above and you are not using our [custom domains](https://auth0.com/docs/customize/custom-domains) feature, your domain name is a concatenation of your tenant name, your regional subdomain, and `auth0.com`, separated by the dot (`.`) symbol.\n\nFor example, if your tenant name is `exampleco-enterprises`, and your tenant is in the US region, your Auth0 domain name would be `exampleco-enterprises.us.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.us.auth0.com/login/callback`.\n\nHowever, if your tenant is in the US region and was created before June 2020, then your Auth0 domain name would be `exampleco-enterprises.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.auth0.com/login/callback`.\n\nIf you are using [custom domains](https://auth0.com/docs/customize/custom-domains), your **Redirect URI** would be `https://<YOUR CUSTOM DOMAIN>/login/callback`.\n\nDuring this process, record the **Application (client) ID** that Microsoft generates for your application (you can find this on the application's **Overview** screen) as you will need it later in the tutorial.\n\n### Configure your web application to expose an API\n\nTo learn how to configure your Web application to expose an API with Azure AD, read [Quickstart: Configure an application to expose web APIs on Microsoft Docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-expose-web-apis).\n\nWhile configuring your app, make sure you use the following settings:\n\n*   When asked to set a **Scope name**, enter `API.Access`.\n    \n\nDuring this process, record the **Application ID URI** that Microsoft generates for your application as you will need it later in the tutorial.\n\n### Register a new native application\n\nTo learn how to register a native application in Azure, read [Quickstart: Register an application with the Microsoft identity platform on Microsoft Docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app).\n\nWhile setting up your app, make sure you use the following settings:\n\n*   If you want to allow users from external organizations (like other Azure AD directories), select **Accounts in any organizational directory (Any Azure AD directory - Multitenant)** when setting **Supported account types**.\n    \n*   When asked to set a **Redirect URI**, select `Public client/native (mobile & desktop)` and enter your callback URL. Your callback URL format will vary depending on your platform. For details about the format for your platform, read [Native Quickstarts](https://auth0.com/docs/quickstart/native).\n    \n\nDuring this process, record the **Application (client) ID** that Microsoft generates for your application (you can find this on the application's **Overview** screen) as you will need it later in the tutorial.\n\n### Create a client secret for your native application\n\nTo learn how to create a client secret, read [Quickstart: Configure a client application to access web APIs - Add Credentials to your web application on Microsoft Docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-credentials-to-your-web-application).\n\nGenerate a **Client secret** and record its value. You will need it later in the tutorial.\n\n### Add permissions for your native application\n\nTo learn how to add permissions for your **Native** application, read [Quickstart: Configure a client application to access web APIs - Add permissions to access web APIs on Microsoft Docs](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-permissions-to-access-web-apis).\n\nAuth0 requires that you enable the least privileged permissions necessary (for the Microsoft Graph API and for the Web application you configured to expose an API) for this configuration to work properly. To learn more about Microsoft Graph API permissions, read [Microsoft Graph permissions reference on Microsoft Docs](https://learn.microsoft.com/en-us/graph/permissions-reference).\n\nWhile setting up your permissions, make sure you use the following settings for Microsoft Graph API:\n\n*   When asked for a permission type, choose **Delegated permissions**.\n    \n    *   Under **User**, select **User.Read** so your app can sign in users and read the signed-in user's profile.\n        \n    *   Under **Directory**, select **Directory.Read.All** so your app can read directory data on the signed-in user's behalf.\n        \n\nFor your Web app that you configured to expose an API, make sure you use the following settings:\n\n*   When asked for a permission type, choose **Delegated permissions**.\n    \n    *   Under **API**, select **API.Access** so your app can access your API on the user's behalf.\n        \n\n## Configure the connection in Auth0\n\nAfter creating both applications in Azure AD, you can configure the Auth0 connection:\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **Microsoft Azure AD**, and select the add (**+**) button.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create**:\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant. Once set, this name can't be changed. |\n    | **Microsoft Azure AD Domain** | Your Azure AD domain name. You can find this on your Azure AD directory's overview page in the Microsoft Azure portal. |\n    | **Client ID** | Unique identifier for your registered Azure AD application. Enter the saved value of the **Application (client) ID** for the Native application you registered in Azure AD. |\n    | **Client Secret** | String used to gain access to your registered Azure AD application. Enter the saved value of the **Client secret** for the Native app you registered in Azure AD. |\n    | **Use common endpoint** (optional) | When enabled, your application will dynamically accept users from new directories. Typically enabled if you selected a multitenant option for **Supported account types** for the application you registered in Azure AD. When enabled, Auth0 will redirect users to Azure's common login endpoint, and Azure will perform _Home Realm Discovery_ based on the domain of the user's email address. |\n    | **Identity API** | API used by Auth0 to interact with Azure AD endpoints. Learn about the differences in behavior in Microsoft's [Why update to Microsoft identity platform (v2.0)](https://docs.microsoft.com/en-us/azure/active-directory/develop/azure-ad-endpoint-comparison) doc. Select `Azure Active Directory (v1)`, and for **App ID URI**, enter the saved value of the **Application ID URI** that was created when you configured your Web application to expose an API. |\n    | **Attributes** | Basic attributes for the signed-in user that your app can access. Indicates how much information you want stored in the Auth0 User Profile. |\n    | **Extended Attributes** (optional) | Extended attributes for the signed-in user that your app can access. |\n    | **Auth0 APIs** (optional) | When selected, indicates that you require the ability to make calls to the Azure AD Users API. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    | **Email Verification** | Choose how Auth0 sets the `email_verified` field in the user profile. To learn more, see [Email Verification for Azure AD and ADFS](https://auth0.com/docs/connections/azuread-adfs-email-verification). |\n    \n    ![Create new Azure AD connection](https://images.ctfassets.net/cdy7uua7fh8z/1r6WTgLJUlbiV9jligIwER/4fd549986503d804ffbcc785b4ef70df/Azure_AD_Connection.png)\n\n## Enable the enterprise connection for your Auth0 application\n\nTo use your new Azure AD enterprise connection, you must [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n## Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).\n\n## Group Memberships and Advanced Profile Information\n\nIn this native flow, Auth0 will receive an Access Token from Azure AD which has been issued for your Azure AD Web application. As a result, features like loading group memberships and advanced profile information will no longer work because the Access Token received by Azure AD can no longer be used to query the Azure AD Graph API for this additional information.\n\nHowever, if you depend on group memberships and advanced profile information, you can change your configuration to accommodate your needs:\n\n1.  In Azure, configure your Native application with additional permissions for the Microsoft Graph API:\n    \n    *   When asked for a permission type, choose **Delegated permissions**.\n        \n        *   Under **Directory**, select **Directory.AccessAsUser.All**, so your app can access the directory as the signed-in user.\n            \n2.  In Auth0, modify your Azure AD enterprise connection:\n    \n    *   In **Identity API**, select `Azure Active Directory (v1)`, and for **App ID URI**, enter the URI of the Azure AD Graph API:\n        \n        ```\n        https://graph.windows.net\n        ```\n        \n\n## Next Steps\n\n*   [Integrate with Auth0 using one of our libraries](https://auth0.com/docs/libraries)\n    \n*   [Integrate with Auth0 using our Authentication API](https://auth0.com/docs/api/authentication)\n    \n*   [Read more about the authentication flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow)\n    \n*   [Pass additional parameters to the Identity Provider](https://auth0.com/docs/authenticate/identity-providers/pass-parameters-to-idps)\n    \n*   [Re-prompt users for permissions](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/reprompt-permissions)",
    "title": "Connect Your Native App to Microsoft Azure Active Directory Using Resource Owner Flow",
    "description": "Learn how to connect your app to Microsoft Azure Active Directory using an enterprise connection with the Resource Owner flow.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory/v2",
    "markdown": "# Connect Your App to Microsoft Azure Active Directory\n\nYou can integrate with Microsoft Azure Active Directory (AD) if you want to let users:\n\n*   From within your company use your application from an Azure AD controlled by you or your organization.\n    \n*   From other companies' Azure ADs use your application. (We recommend that you configure external directories as different connections.)\n    \n\n## Steps\n\nTo connect your application to Azure AD, you must:\n\n1.  [Register your app with Azure AD](#register-your-app-with-azure-ad)\n    \n2.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0)\n    \n3.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application)\n    \n4.  [Test the connection](#test-the-connection)\n    \n\n### Register your app with Azure AD\n\nTo register your app with Azure AD, see Microsoft's [Quickstart: Register an application with the Microsoft identity platform](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app).\n\nDuring registration, configure the following settings:\n\n| Option | Setting |\n| --- | --- |\n| **Supported account types** | To allow users from external organizations (like other Azure AD directories) choose the appropriate multitenant option. Multitenant options include the following: **Accounts in any organizational directory (Any Azure AD directory - Multitenant)**. |\n| **Redirect URI** | Select a Redirect URI type of **Web**, and enter your callback URL: `https://{yourDomain}/login/callback`. |\n\n#### Find your Auth0 domain name for redirects\n\nIf your Auth0 domain name is not shown above and you are not using our [custom domains](https://auth0.com/docs/customize/custom-domains) feature, your domain name is a concatenation of your tenant name, your regional subdomain, and `auth0.com`, separated by the dot (`.`) symbol.\n\nFor example, if your tenant name is `exampleco-enterprises`, and your tenant is in the US region, your Auth0 domain name would be `exampleco-enterprises.us.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.us.auth0.com/login/callback`.\n\nHowever, if your tenant is in the US region and was created before June 2020, then your Auth0 domain name would be `exampleco-enterprises.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.auth0.com/login/callback`.\n\nIf you are using [custom domains](https://auth0.com/docs/customize/custom-domains), your **Redirect URI** would be `https://<YOUR CUSTOM DOMAIN>/login/callback`.\n\nDuring this process, Microsoft generates an **Application (client) ID** for your application; you can find this on the app's **Overview** screen. **Make note of this value.**\n\n#### Create a client secret\n\nTo create a client secret, see Microsoft's [Quickstart: Configure a client application to access web APIs - Add Credentials to your web application](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app#add-credentials).\n\nOnce generated, **make note of this value**.\n\n#### Add permissions\n\nTo add permissions, see Microsoft's [Quickstart: Configure a client application to access web APIs - Add permissions to access web APIs](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-permissions-to-access-web-apis).\n\nWhile configuring permissions, consider the following:\n\nIf you want to enable extended attributes (such as E**xtended Profile** or **Security Groups**), then you will need to configure the following permissions for the **Microsoft Graph API**.\n\n| Delegated Permissions | Description |\n| --- | --- |\n| **Users > User.Read** | So your app can sign in users and read the signed-in users' profiles. |\n| **Directory > Directory.Read.All** | So your app can read directory data on the signed-in user's behalf. |\n\n### Create an enterprise connection in Auth0\n\nCreate and configure an Azure AD Enterprise Connection in Auth0. Make sure you have the **Application (client) ID** and the **Client secret** generated when you set up your app in the Microsoft Azure portal.\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **Microsoft Azure AD**, and select its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create**:\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant. Once set, this name can't be changed. |\n    | **Microsoft Azure AD Domain** | Your Azure AD domain name. You can find this on your Azure AD directory's overview page in the Microsoft Azure portal. |\n    | **Client ID** | Unique identifier for your registered Azure AD application. Enter the saved value of the **Application (client) ID** for the app you just registered in Azure AD. |\n    | **Client Secret** | String used to gain access to your registered Azure AD application. Enter the saved value of the **Client secret** for the app you just registered in Azure AD. |\n    | **Use common endpoint** | (Optional) When enabled, your application will dynamically accept users from new directories. Typically enabled if you selected a multi-tenant option for **Supported account types** for the application you just registered in Azure AD. When enabled, Auth0 will redirect users to Azure's common login endpoint, and Azure will perform _Home Realm Discovery_ based on the domain of the user's email address. |\n    | **Identity API** | API used by Auth0 to interact with Azure AD endpoints. Learn about the differences in behavior in Microsoft's [Why update to Microsoft identity platform (v2.0)](https://docs.microsoft.com/en-us/azure/active-directory/develop/azure-ad-endpoint-comparison) doc. |\n    | **Attributes** | Basic attributes for the signed-in user that your app can access. Indicates how much information you want stored in the Auth0 User Profile. |\n    | **Extended Attributes** (optional) | Extended attributes for the signed-in user that your app can access. |\n    | **Auth0 APIs** (optional) | When selected, indicates that we require the ability to make calls to the Azure AD API, which allows us to search for users in the Azure AD Graph even if they never logged in to Auth0. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    | **Email Verification** | Choose how Auth0 sets the `email_verified` field in the user profile. To learn more, see [Email Verification for Azure AD and ADFS](https://auth0.com/docs/connections/azuread-adfs-email-verification). |\n    \n    ![Create new Azure AD connection](https://images.ctfassets.net/cdy7uua7fh8z/1r6WTgLJUlbiV9jligIwER/4fd549986503d804ffbcc785b4ef70df/Azure_AD_Connection.png)\n3.  In the **Login Experience** view, you can configure how users log in with this connection.\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Identity Provider domains** | A comma-separated list of the domains that can be authenticated in the Identify Provider. This is only applicable when using [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication with Universal Login. |\n    | **Add button** (Optional) | Display a button for this connection in the login page. |\n    | **Button display name** (Optional) | Text used to customize the login button for Universal Login. When set the button reads: \"Continue with {Button display name}\". |\n    | **Button logo URL** (Optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    \n4.  If you have appropriate Azure AD administrative permissions to give consent to the application so users can log in, then click **Continue**. You will be asked to [log in to your Azure AD account](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent#requesting-consent-for-an-entire-tenant) and give consent. Otherwise, provide the given URL to your administrator so that they can give consent.\n    \n\n### Enable the enterprise connection for your Auth0 application\n\nTo use your new Azure AD enterprise connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n### Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).\n\n## Troubleshooting\n\nHere are some troubleshooting tips:\n\n**I registered my application with Azure AD, but when I go back to my Azure Active Directory App registrations, I can't see my application.**\n\nYou may have accidentally registered your app in the wrong Azure AD directory (or not have created an Azure AD directory at all before registering your app). It's likely easiest to re-register your app in Azure AD. Make sure you are in the correct directory when you register the app. If you need to create an Azure AD directory, follow Microsoft's [Quickstart: Create a new tenant in Azure Active Directory - Create a new tenant for your organization](https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-access-create-new-tenant#create-a-new-tenant-for-your-organization).\n\n**I receive the following error message: \"Access cannot be granted to this service because the service listing is not properly configured by the publisher\".**\n\nTo resolve this, try changing the **Supported account types** for your registered Azure AD app. Make sure you have chosen an appropriate multitenant option in the Azure AD app's Authentication settings. Multitenant options include the following: **Accounts in any organizational directory (Any Azure AD directory - Multitenant)**.\n\n**When users try to log in, we receive the following error message: \"invalid\\_request; failed to obtain access token\".**\n\nThe most likely reason for this error is an invalid or expired Azure AD **Client secret**. To resolve this, generate a new **Client secret** for your app in Azure AD, then update the **Client Secret** in the enterprise connection configured with Auth0.\n\n## Signing Key Rollover in Azure AD\n\nSigning keys are used by the identity provider to sign the authentication token it issues, and by the consumer application (Auth0 in this case) to validate the authenticity of the generated token.\n\nFor security purposes, Azure AD’s signing key [rolls on a periodic basis](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-signing-key-rollover). If this happens, **you do not need to take any action**. Auth0 will use the new key automatically.\n\n## Remove unverified label\n\nIf you're using a custom domain, the application consent prompt for Azure AD login may label your domain as \"unverified\". To remove the unverified label:\n\n1.  Verify the domain for the Auth0 application: [Add your custom domain name using the Azure Active Directory portal](https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/add-custom-domain#add-your-custom-domain-name-to-azure-ad).\n    \n2.  Assign the verified domain to the Auth0 application: [How to: Configure an application's publisher domain](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-configure-publisher-domain#configure-publisher-domain-using-the-azure-portal).\n    \n\n## Next Steps\n\n*   [Integrate with Auth0 using one of our libraries](https://auth0.com/docs/libraries)\n    \n*   [Integrate with Auth0 using our Authentication API](https://auth0.com/docs/api/authentication)\n    \n*   [Read more about the authentication flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow)\n    \n*   [Pass additional parameters to the Identity Provider](https://auth0.com/docs/authenticate/identity-providers/pass-parameters-to-idps)\n    \n*   [Re-prompt users for permissions](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/reprompt-permissions)",
    "title": "Connect Your App to Microsoft Azure Active Directory",
    "description": "Learn how to connect your app to Microsoft Azure Active Directory using an enterprise connection.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/google-apps",
    "markdown": "# Connect Your App to Google Workspace\n\n#### Using Google Social and Enterprise Connections\n\nIf you have an existing [Google Social Connection](https://marketplace.auth0.com/integrations/google-social-connection) for your application and you create a new Google Workspace connection for the same domain, users affiliated with the social connection with now be logged in with the new enterprise connection. This will occur regardless of whether you enable the Google Workspace enterprise connection.\n\n## Prerequisites\n\nBefore you begin:\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n    *   Select an appropriate **Application Type**.\n        \n    *   Add an **Allowed Callback URL** of **`{https://yourApp/callback}`**.\n        \n    *   Make sure your Application's [Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n        \n\n## Steps\n\nTo connect your application to Google Workspace, you must:\n\n1.  [Set up your app in Google](#set-up-your-app-in-google)\n    \n2.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0)\n    \n3.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application)\n    \n4.  [Test the connection](#test-the-connection)\n    \n\n#### Google Workspace account\n\nBefore proceeding, you will need a valid Google Workspace account and must have **your own** Google Workspace Organization for which you are an administrator.\n\n## Set up your app in Google\n\nTo allow users to log in using Google Workspace, you must register your application in the Google developer console.\n\n### Register a new application\n\nTo learn how to register a new application with Google, follow Google's [Setting up OAuth 2.0](https://support.google.com/googleapi/answer/6158849) doc. During this process, Google will generate a **Client ID** and **Client Secret** for your application; make note of these.\n\nWhile setting up your app, be sure to use these settings:\n\n*   On the **OAuth consent screen**, under **Authorized domains**, add `auth0.com`.\n    \n*   When asked to select an application type, choose **Web application** and set the following parameters:\n    \n    | Field | Description |\n    | --- | --- |\n    | Name | The name of your application. |\n    | Authorized JavaScript origins | `https://{yourDomain}` |\n    | Authorized redirect URIs | `https://{yourDomain}/login/callback` |\n    \n    #### Find your Auth0 domain name for redirects\n    \n    If your Auth0 domain name is not shown above and you are not using our [custom domains](https://auth0.com/docs/customize/custom-domains) feature, your domain name is a concatenation of your tenant name, your regional subdomain, and `auth0.com`, separated by the dot (`.`) symbol.\n    \n    For example, if your tenant name is `exampleco-enterprises`, and your tenant is in the US region, your Auth0 domain name would be `exampleco-enterprises.us.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.us.auth0.com/login/callback`.\n    \n    However, if your tenant is in the US region and was created before June 2020, then your Auth0 domain name would be `exampleco-enterprises.auth0.com` and your **Redirect URI** would be `https://exampleco-enterprises.auth0.com/login/callback`.\n    \n    If you are using [custom domains](https://auth0.com/docs/customize/custom-domains), your **Redirect URI** would be `https://<YOUR CUSTOM DOMAIN>/login/callback`.\n    \n\n### Enable the Admin SDK Service\n\nIf you plan to connect to Google Workspace enterprise domains, you need to enable the **Admin SDK Service**. To learn how, follow Google's [Enable and disable APIs](https://support.google.com/googleapi/answer/6158841) doc.\n\n## Create an enterprise connection in Auth0\n\nNext, you will need to create and configure a Google Workspace Enterprise Connection in Auth0. Make sure you have the **Client ID** and **Client Secret** generated when you set up your app in the Google developer console.\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **Google Workspace**, and click its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create:**\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant. Once set, this name can't be changed. |\n    | **Google Workspace Domain** | Google Workspace domain name for your organization. |\n    | **Client ID** | Unique identifier for your registered Google application. Enter the saved value of the **Client ID** for the app you just registered in the Google developer console. |\n    | **Client Secret** | String used to gain access to your registered Google application. Enter the saved value of the **Client Secret** for the app you just registered in the Google developer console. |\n    | **Attributes** | Basic attributes for the signed-in user that your app can access. Indicates how much information you want stored in the Auth0 User Profile. Options include: **Basic Profile** (`email`, `email verified` flag) and **Extended Profile** (name, public profile URL, photo, gender, birthdate, country, language, and timezone). |\n    | **Extended Attributes** (optional) | Extended attributes for the signed-in user that your app can access. Options include: **Groups** (distribution list(s) to which the user belongs), **Is Domain Administrator** (indicates whether the user is a domain administrator), **Is Account Suspended** (indicates whether the user's account is suspended), and **Agreed to Terms** (indicates whether the user has agreed to the terms of service). |\n    | **Auth0 APIs** (optional) | When **Enable Users API** is selected, indicates that you require the ability to make calls to the Google Directory API. |\n    | **Auth0 User ID** (optional) | By default, the Auth0 `user_id` maps to `email`. By enabling **Use ID instead of Email for Auth0 User ID**, `user_id` instead maps to `id`. This can only be set for new connections and cannot be changed once configured. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    \n    ![Create Google Workspace Connection](https://images.ctfassets.net/cdy7uua7fh8z/5s3W98sar77mRxZ3F3s0Ol/ff0c036b26e95a6bbf7bbc3ca5a772fe/Google_Workspace_form_-_1px.png)\n3.  If you have appropriate administrative permissions to configure your Google Workspace settings so you can use Google's Admin APIs, then click **Continue**. Otherwise, provide the given URL to your administrator so that they can adjust the required settings.\n    \n4.  On the **Login Experience** tab, you can configure how users log in with this connection.\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Identity Provider domains** | A comma-separated list of the domains that can be authenticated in the Identify Provider. This is only applicable when using [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication with Universal Login. |\n    | **Add button** (Optional) | Display a button for this connection in the login page. |\n    | **Button display name** (Optional) | Text used to customize the login button for Universal Login. When set the button reads: \"Continue with {Button display name}\". |\n    | **Button logo URL** (Optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    \n\n## Work with the connection\n\n### Enable the enterprise connection for your Auth0 application\n\nTo use your new AD connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n### Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).\n\n### Request Refresh Tokens from Google\n\nGoogle always returns an Access Token, which is stored in the user profile. If you add `access_type=offline&approval_prompt=force` to the authorization request, Auth0 will forward these parameters to Google. Google will then return a Refresh Token, which will also be stored in the user profile.\n\n### Use Identity Provider Tokens from Google\n\nTo retrieve additional user and group details beyond what Auth0 retrieves by default, you can use the access tokens returned from Google to call Google's APIs. To securely access these tokens, follow the guidelines provided in [Identity Provider Access Tokens](https://auth0.com/docs/secure/tokens/access-tokens/identity-provider-access-tokens).\n\nFor Google Workspace, Auth0 stores access tokens and refresh tokens on the `user` object for individual users and on the `connection` object for workspace admins.\n\nTo retrieve all extended group properties for a user with Google's Directory Admin API, navigate to the Goolgle Workspace connection in your [Auth0 Dashboard](https://manage.auth0.com/#/connections/enterprise) and enable the **Groups** extended attribute. Then, complete administrator consent using the **Setup** tab.\n\nAfter these steps are complete, use the [Get a connection](https://auth0.com/docs/api/management/v2/connections/get-connections-by-id) endpoint of the Auth0 Management API to retrieve the admin access token stored on the `connection` object. You can then use this token to call Google's [Manage Groups](https://developers.google.com/admin-sdk/directory/v1/guides/manage-groups#get_all_member_groups) endpoint.\n\n**Example call**:\n\n```\ncurl -H \"Authorization: OAuth {admin_access_token}\" https://admin.googleapis.com/admin/directory/v1/groups\\?userKey={user_key}\n```\n\n### Validate authentication with Actions\n\nYou can use `post-login` [Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) to validate whether authentication events are coming from legitimate users who are members of a Google organization. This can help mitigate potential vulnerability by preventing unauthorized access to your applications after users are no longer part of your organization.\n\nTo verify legitimate Google authentications, use `post-login` Actions to validate the `idp_tenant_domain` claim associated with the user and ensure the value matches the expected organization for that user.\n\nYou can only verify `idp_tenant_domain` for users who authenticate with the following connection types:\n\n*   Google Social\n    \n*   Google Workspace\n    \n*   Google OIDC\n    \n\n#### Example\n\nThe following example demonstrates how you can validate the `idp_tenant_domain` using `post-login` Actions.\n\n```\nexports.onExecutePostLogin = async (event, api) => {\n\n // Example to block social accounts\n if (event.connection.strategy === 'google-oauth2' \n && !event.user.idp_tenant_domain) // Non-organization Accounts\n {\n   api.access.deny('Account not allowed for login');\n }\n\n // Example to only permit allowlisted organization accounts\n if (event.connection.strategy === 'google-oauth2' \n && event.user.idp_tenant_domain != \"allowedOrganization.com\") \n {\n   api.access.deny('Your Google Organization is not allowed to login');\n }\n\n};\n```\n\nIf a Google Workspace admin is deleted, any Google Workspace Enterprise connections they have set up and authorized will need to be reauthorized by a new Google Workspace admin to avoid login failures. This can be done by having the new admin use the link in the **Setup** tab for the Google Workspace Enterprise connection.\n\n## Next Steps\n\n*   [Integrate with Auth0 using one of our libraries](https://auth0.com/docs/libraries)\n    \n*   [Integrate with Auth0 using our Authentication API](https://auth0.com/docs/api/authentication)\n    \n*   [Read more about the authentication flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow)\n    \n*   [Pass additional parameters to the Identity Provider](https://auth0.com/docs/authenticate/identity-providers/pass-parameters-to-idps)\n    \n*   [Re-prompt users for permissions](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/reprompt-permissions)",
    "title": "Connect Your App to Google Workspace",
    "description": "Learn how to connect your app to Google Workspace using an enterprise connection.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azuread-adfs-email-verification",
    "markdown": "# Email Verification for Azure AD and ADFS\n\nAuth0 user's profile has an `email_verified` field, which can be set in different ways depending on the connection type. For database connections, users must go through an email validation flow to get the email verified. For federated connections, identity providers can return the `email_verified` field based on their own criteria.\n\nAzure AD and ADFS cannot guarantee that the emails they return have been verified:\n\n*   In ADFS, the ADFS administrator can configure any email they want.\n    \n*   In Azure AD, depending on how the Azure AD tenant is configured, email addresses returned by Azure AD may or may not correspond to Office mailboxes. Auth0 can't know whether they do or not.\n    \n\nHowever, if you know how an Azure AD or ADFS is configured and managed, you can decide to trust that the emails from those accounts are verified.\n\nTo accommodate both needs, Azure AD and ADFS connections have an **Email Verification** property with two values:\n\n*   Always set `email_verified` to `true`\n    \n*   Always set `email_verified` to `false`\n    \n\nThe Azure AD connection also has a **Use Common Endpoint** property. When it's enabled, the user can authenticate with any Azure AD tenant. Given it's not possible to trust that any Azure AD tenant will return verified emails, the **Email Verification** property will need to be set to **Always set** `**email_verified**` **to** `**false**`.\n\nWhen the property is set to **Always set** `**email_verified**` **to** `**false**`, users will get `email_verified` set to `false` the next time they log in, unless [syncing user profile attributes at each login](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0) is disabled.\n\nIn previous versions, Auth0 always set the `email_verified` field to `true` in Azure AD and ADFS connections. If you were using Azure AD and ADFS connections in the past, you will have a tenant setting that will override the Connection Setting for **Email Verification** and keep the previous behavior.\n\nYou can find the new tenant setting in the [Auth0 Dashboard > Settings > Advanced](https://manage.auth0.com/#/tenant/advanced). Locate the **Migrations** section, then find **Default to** `**Email Verification**` **setting for Azure AD/ADFS connections**.\n\n![Dashboard - Advanced Tenant Settings - Migrations](https://images.ctfassets.net/cdy7uua7fh8z/4K1rQIv6p96KPCYOrhjXz4/be0f7b104d743fd0d3d42d18df97e144/dashboard-tenant-edit_view-advanced_migrations_azure-adfs.png)\n\nWhen this setting is disabled, `email_verified` will always be `true` for Azure AD/ADFS connections. When enabled, it will use the `Email Verification` setting at the connection level.\n\nIf your application requires that the emails from an Azure AD/ADFS connection's users are always verified, you can enable the **Enable email verification flow during login for Azure AD and ADFS connections** option in the tenant's **Advanced Settings** section.\n\nAfter the user authenticates for the first time with a non-verified email, Auth0 will ask the user to verify their email by entering a one-time-use code that will be sent to their email account:\n\n![Auth0 - Email Verification Prompt - One-Time Code](https://images.ctfassets.net/cdy7uua7fh8z/i92GJgntVuU5QK37adugH/51b66e40d90d953a9d8e974f03371e84/azuread-adfs-email-verification.png)\n\nIf the user completes this step, the `email_verified` field will be set to `true`, and users will not be prompted again for email verification, unless Azure AD or ADFS return a different email for the user.\n\nThis new screen is rendered using the Universal Login experience, even if you are using Classic Login. To learn how to customize it, read [Customize Universal Login Pages](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates).\n\nTo learn how to customize the email that is sent to users, read [Verify Emails using Auth0](https://auth0.com/docs/manage-users/user-accounts/verify-emails).",
    "title": "Email Verification for Azure AD and ADFS",
    "description": "Describes how to control how the `email_verified` field is set for Azure AD and ADFS.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/choose-a-connection-type-for-azure-ad",
    "markdown": "# Choose a Connection Type for Azure AD\n\nYou can connected your Auth0 instance to Microsoft Azure Active Directory in three ways. Review the options to determine the best approach for your situation.\n\nAuth0 recommends starting with the native Microsoft Azure AD connection. If you need further customization, review the SAML connection configuration. Also, if your organization has additional restrictions on OAuth code flows, review the Enterprise OIDC configuration.\n\nThe table below illustrates the main differences in these connection types. Review these capabilities to determine the best connection type for your organization.\n\n| Connection Type | “Native” Azure AD | Enterprise OIDC | SAML |\n| --- | --- | --- | --- |\n| **Protocol** | OAuth authorization code flow | OAuth implicit flow OR OAuth authorization code flow | SAML |\n| **Can receive optional claims from Azure AD?** | No  | Yes | Yes |\n| **Federated logout support (“Single Logout” or SLO)** | Yes | No  | Yes |\n| **Receive AD Groups** | Yes, friendly names | Yes, object IDs | Yes, object IDs |\n| **Receive Extended Profile** | Yes | No  | No  |\n\n## Microsoft Azure AD\n\nThe first connection type is the **Microsoft Azure AD** connection in [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/dashboard/#/connections/enterprise).\n\nThis connection type uses the OAuth authorization code flow. The Microsoft Azure AD connection accepts claims from an `id_token` and directly queries the Microsoft Graph API. If configured, the query searches for groups and additional profile information. Microsoft Azure AD ignores any custom claims included in the `id_token`.\n\n### Connection Features and Considerations\n\nBecause this connection type is the native workflow, it is explicitly compatible with extended AD features. The Azure AD connection maps profile attributes directly to your Auth0 user profiles from the Microsoft Graph API.\n\nThe extended profile option offers three attributes not available in other connection types. You must [enable permission to query the Microsoft Graph API](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory/v2#add-permissions) to use the receive the extended profile features.The table below compares the Azure AD Graph Attributes across the connection types:\n\n| Graph Attribute | Auth0 Profile Attribute | Data type | Equivalent optional claim for OIDC or SAML |\n| --- | --- | --- | --- |\n| businessPhones | phone | array | \\-  |\n| givenName | given\\_name | string | given\\_name |\n| jobTitle | job\\_title | string | \\-  |\n| mobilePhone | mobile | string | \\-  |\n| preferredLanguage | preferred\\_language | string | xms\\_pl |\n| surname | family\\_name | string | family\\_name |\n| userPrincipalName | upn | string | upn |\n\n### Group Configuration\n\nIf you [enable permission to query the Microsoft Graph API](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory/v2#add-permissions), Auth0 automatically retrieves groups for the user and maps these to the `groups` attribute in the Auth0 profile. Auth0 maps these group \"friendly names\" and does not need to configure a custom claim because these groups map directly from the Microsoft Graph API.\n\n## SAML\n\nThe SAML connection type uses the SAML protocol and supports attribute mapping and all standard SAML features.\n\n### Connection Features and Considerations\n\nThe SAML connection type is the most flexible of the available connection types because it supports optional claims and [federated logouts](https://docs.microsoft.com/en-us/azure/active-directory/develop/single-sign-out-saml-protocol). If you need both of these features, SAML is the only connection type that supports both simultaneously.\n\n### Group Configuration\n\nFor Auth0 to accept group information with the SAML connection type, you must configure your Azure AD with optional attributes in the SAML response. Auth0 then maps the groups to the `group_ids` attribute in the user's Auth0 profile.\n\n## Enterprise OIDC\n\nThe Enterprise Open ID Connect type can use either OAuth Implicit or Authorization Code workflows. This connection maps custom claims in the `id_token` to the Auth0 User Profile. To learn more about authentication flows, visit the [Authentication and Authorization Flows documentation](https://auth0.com/docs/get-started/authentication-and-authorization-flow).\n\n### Connection Features and Considerations\n\nIf you cannot provide client secrets in your login flow due to regulations or privacy protocols, the Implicit Flow the OIDC connection offers could be a preferred method. If you require custom claims but do not want to configure the additional SAML features, the OIDC connection can reduce complexity.\n\n### Group Configuration\n\nFor Auth0 to accept group information with the OIDC connection type, you must configure your Azure AD with an optional claim to add `groups` in the `id_token` of your request. Auth0 then maps these groups to the `group_ids` attribute in the user’s Auth0 profile.\n\n## Learn more\n\n*   [Connect Your App to Microsoft Azure Active Directory](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory/v2)",
    "title": "Choose a Connection Type for Azure AD",
    "description": "Describes Azure connection types and features.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/saml",
    "markdown": "# Connect Your App to SAML Identity Providers\n\nAuth0 lets you create SAML Identity Provider (IdP) connections.\n\n## Prerequisites\n\nBefore beginning:\n\n*   [Register your Application with Auth0](https://auth0.com/docs/get-started/auth0-overview/create-applications).\n    \n    *   Select an appropriate **Application Type**.\n        \n    *   Add an **Allowed Callback URL** of **`{https://yourApp/callback}`**.\n        \n    *   Make sure your Application's [Grant Types](https://auth0.com/docs/get-started/applications/update-grant-types) include the appropriate flows.\n        \n*   Decide on the name of this enterprise connection\n    \n    *   The Post-back URL (also called Assertion Consumer Service URL) becomes: `https://{yourDomain}/login/callback?connection={yourConnectionName}`\n        \n    *   The Entity ID becomes: `urn:auth0:{yourTenant}:{yourConnectionName}`\n        \n\n## Steps\n\nTo connect your application to a SAML Identity Provider, you must:\n\n1.  Enter the Post-back URL and Entity ID at the IdP (to learn how, read about [SAML Identity Provider Configuration Settings](https://auth0.com/docs/authenticate/protocols/saml/saml-identity-provider-configuration-settings)).\n    \n2.  [Get the signing certificate from the IdP](#get-the-signing-certificate-from-the-idp) and [convert it to Base64](#convert-signing-certificate-to-base64).\n    \n3.  [Create an enterprise connection in Auth0](#create-an-enterprise-connection-in-auth0).\n    \n4.  [Enable the enterprise connection for your Auth0 Application](#enable-the-enterprise-connection-for-your-auth0-application).\n    \n5.  [Set up mappings](#set-up-mappings) (unnecessary for most cases).\n    \n6.  [Test the connection](#test-the-connection).\n    \n\n## Get the signing certificate from the IdP\n\nWith SAML Login, Auth0 acts as the service provider, so you will need to retrieve an X.509 signing certificate from the SAML IdP (in PEM or CER format); later, you will upload this to Auth0. The methods for retrieving this certificate vary, so please see your IdP's documentation if you need additional assistance.\n\n### Convert signing certificate to Base64\n\nYou can use the Management API or the Auth0 Dashboard to upload the X.509 signing certificate. If you use the Management API, you must convert the file to Base64. To do this, either use a [simple online tool](https://www.base64decode.org/) or run the following command in Bash: `cat signing-cert.crt | base64`.\n\n## Create an enterprise connection in Auth0\n\nNext, you will need to create and configure a SAML Enterprise Connection in Auth0 and upload your X.509 signing certificate. This task can be performed using either Auth0's Dashboard or Management API.\n\n### Create an enterprise connection using the Dashboard\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise), locate **SAML**, and select its `+`.\n    \n    ![Dashboard - Connections - Enterprise](https://images.ctfassets.net/cdy7uua7fh8z/1fSTcrZpkgkPR64NnI1lr8/f300e7e7844385fcc15172c7e512a10d/Enterprise_Connections_screenshot.png)\n2.  Enter details for your connection, and select **Create:**\n    \n    | Field | Description |\n    | --- | --- |\n    | **Connection name** | Logical identifier for your connection; it must be unique for your tenant and the same name used when setting the Post-back URL and Entity ID at the IdP. Once set, this name can't be changed. |\n    | **Sign In URL** | SAML single login URL. |\n    | **X.509 Signing Certificate** | Signing certificate (encoded in PEM or CER) you retrieved from the IdP earlier in this process. |\n    | **Enable Sign Out** | When enabled, a specific Sign Out URL can be set. Otherwise, the Sign In URL is used by default. |\n    | **Sign Out URL** (optional) | SAML single logout URL. |\n    | **User ID Attribute** (optional) | Attribute in the SAML token that will be mapped to the `user_id` property in Auth0. |\n    | **Debug Mode** | When enabled, more verbose logging will be performed during the authentication process. |\n    | **Sign Request** | When enabled, the SAML authentication request will be signed. (Be sure to download and provide the accompanying certificate so the SAML IdP can validate the assertions' signature.) |\n    | **Sign Request Algorithm** | Algorithm Auth0 will use to sign the SAML assertions. |\n    | **Sign Request Digest Algorithm** | Algorithm Auth0 will use for the sign request digest. |\n    | **Protocol Binding** | HTTP binding supported by the IdP. |\n    | **Request Template** (optional) | Template that formats the SAML request. |\n    | **Sync user profile attributes at each login** | When enabled, Auth0 automatically syncs user profile data with each user login, thereby ensuring that changes made in the connection source are automatically updated in Auth0. |\n    \n    ![Configure SAML Settings](https://images.ctfassets.net/cdy7uua7fh8z/7hvlp8kjva9uFzm5nwsBTQ/4c9f4d01438a3dab6cfb19a5d61d3f13/SAML_Connection_2.png)\n3.  In the **Login Experience** view, configure how users log in with this connection.\n    \n    | **Field** | **Description** |\n    | --- | --- |\n    | **Identity Provider domains** | A comma-separated list of the domains that can be authenticated in the Identify Provider. This is only applicable when using [Identifier First](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first) authentication with Universal Login. |\n    | **Add button** (Optional) | Display a button for this connection in the login page. |\n    | **Button display name** (Optional) | Text used to customize the login button for Universal Login. When set the button reads: \"Continue with {Button display name}\". |\n    | **Button logo URL** (Optional) | URL of image used to customize the login button for Universal Login. When set, the Universal Login login button displays the image as a 20px by 20px square. |\n    \n4.  If you have appropriate administrative permissions to complete the integration, click **Continue** to learn about the custom parameters needed to configure your IdP. Otherwise, provide the given URL to your administrator so that they can adjust the required settings.\n    \n\n### Create an enterprise connection using the Management API\n\nYou can also use the [Management API](https://auth0.com/docs/api/management/v2) to create your SAML Connection. When doing so, you may choose to specify each SAML configuration field manually or else specify a SAML metadata document that contains the configuration values.\n\n#### Create a connection using specified values\n\nMake a `POST` call to the [Create a Connection endpoint](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id). Be sure to replace `MGMT_API_ACCESS_TOKEN`, `CONNECTION_NAME`, `SIGN_IN_ENDPOINT_URL`, `SIGN_OUT_ENDPOINT_URL`, and `BASE64_SIGNING_CERT` placeholder values with your Management API Access Token, connection name, sign in URL, sign out URL, and Base64-encoded signing certificate (in PEM or CER format), respectively.\n\n*   [cURL](#966e23590b344805bf7d12b75151b008_shell)\n*   [C#](#966e23590b344805bf7d12b75151b008_csharp)\n*   [Go](#966e23590b344805bf7d12b75151b008_go)\n*   [Java](#966e23590b344805bf7d12b75151b008_java)\n*   [Node.JS](#966e23590b344805bf7d12b75151b008_node)\n*   [Obj-C](#966e23590b344805bf7d12b75151b008_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\", \"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\", \"signatureAlgorithm\": \"rsa-sha256\", \"digestAlgorithm\": \"sha256\", \"fieldsMap\": {}, \"signingCert\": \"BASE64_SIGNING_CERT\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    strategy: 'samlp',\n    name: 'CONNECTION_NAME',\n    options: {\n      signInEndpoint: 'SIGN_IN_ENDPOINT_URL',\n      signOutEndpoint: 'SIGN_OUT_ENDPOINT_URL',\n      signatureAlgorithm: 'rsa-sha256',\n      digestAlgorithm: 'sha256',\n      fieldsMap: {},\n      signingCert: 'BASE64_SIGNING_CERT'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"samlp\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"signInEndpoint\": @\"SIGN_IN_ENDPOINT_URL\", @\"signOutEndpoint\": @\"SIGN_OUT_ENDPOINT_URL\", @\"signatureAlgorithm\": @\"rsa-sha256\", @\"digestAlgorithm\": @\"sha256\", @\"fieldsMap\": @{  }, @\"signingCert\": @\"BASE64_SIGNING_CERT\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"signInEndpoint\\\": \\\"SIGN_IN_ENDPOINT_URL\\\", \\\"signOutEndpoint\\\": \\\"SIGN_OUT_ENDPOINT_URL\\\", \\\"signatureAlgorithm\\\": \\\"rsa-sha256\\\", \\\"digestAlgorithm\\\": \\\"sha256\\\", \\\"fieldsMap\\\": {}, \\\"signingCert\\\": \\\"BASE64_SIGNING_CERT\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"strategy\": \"samlp\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\n    \"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\",\n    \"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\",\n    \"signatureAlgorithm\": \"rsa-sha256\",\n    \"digestAlgorithm\": \"sha256\",\n    \"fieldsMap\": [],\n    \"signingCert\": \"BASE64_SIGNING_CERT\"\n  ]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Value | Description |\n| --- | --- |\n| `MGMT_API_ACCESS_TOKEN` | [Access Token for the Management API](https://auth0.com/docs/api/management/v2/tokens) with the scope `create:connections`. |\n| `CONNECTION_NAME` | Τhe name of the connection to be created. |\n| `SIGN_IN_ENDPONT_URL` | SAML single login URL for the connection to be created. |\n| `SIGN_OUT_ENDPOINT_URL` | SAML single logout URL for the connection to be created. |\n| `BASE64_SIGNING_CERT` | X.509 signing certificate (encoded in PEM or CER) you retrieved from the IdP. |\n\nOr, in JSON:\n\n```\n{\n\t\"strategy\": \"samlp\",\n  \t\"name\": \"CONNECTION_NAME\",\n  \t\"options\": {\n    \t\"signInEndpoint\": \"SIGN_IN_ENDPOINT_URL\",\n    \t\"signOutEndpoint\": \"SIGN_OUT_ENDPOINT_URL\",\n    \t\"signatureAlgorithm\": \"rsa-sha256\",\n    \t\"digestAlgorithm\": \"sha256\",\n    \t\"fieldsMap\": {\n     \t\t...\n    \t},\n    \t\"signingCert\": \"BASE64_SIGNING_CERT\"\n  \t}\n}\n```\n\n#### Create a connection using SAML metadata\n\nRather than specifying each SAML configuration field, you can specify a SAML metadata document that contains the configuration values. When specifying a SAML metadata document, you may provide either the XML content of the document (`metadataXml`) or the URL of the document (`metadataUrl`). When providing the URL, content is downloaded only once; the connection will not automatically reconfigure if the content of the URL changes in the future.\n\n##### Provide metadata document content\n\nUse the `metadataXml` option to provide content of the document:\n\n*   [cURL](#bf808167d002424ea040de52b4cb0fb8_shell)\n*   [C#](#bf808167d002424ea040de52b4cb0fb8_csharp)\n*   [Go](#bf808167d002424ea040de52b4cb0fb8_go)\n*   [Java](#bf808167d002424ea040de52b4cb0fb8_java)\n*   [Node.JS](#bf808167d002424ea040de52b4cb0fb8_node)\n*   [Obj-C](#bf808167d002424ea040de52b4cb0fb8_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataXml\": \"<EntityDescriptor entityID='\\''urn:saml-idp'\\'' xmlns='\\''urn:oasis:names:tc:SAML:2.0:metadata'\\''>...</EntityDescriptor>\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    strategy: 'samlp',\n    name: 'CONNECTION_NAME',\n    options: {\n      metadataXml: '<EntityDescriptor entityID=\\'urn:saml-idp\\' xmlns=\\'urn:oasis:names:tc:SAML:2.0:metadata\\'>...</EntityDescriptor>'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"samlp\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"metadataXml\": @\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataXml\\\": \\\"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"strategy\": \"samlp\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\"metadataXml\": \"<EntityDescriptor entityID='urn:saml-idp' xmlns='urn:oasis:names:tc:SAML:2.0:metadata'>...</EntityDescriptor>\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n##### Provide a metadata document URL\n\nUse the `metadataUrl` option to provide the URL of the document:\n\n*   [cURL](#ce208c9625a740f1add1aa50bcb5e8f3_shell)\n*   [C#](#ce208c9625a740f1add1aa50bcb5e8f3_csharp)\n*   [Go](#ce208c9625a740f1add1aa50bcb5e8f3_go)\n*   [Java](#ce208c9625a740f1add1aa50bcb5e8f3_java)\n*   [Node.JS](#ce208c9625a740f1add1aa50bcb5e8f3_node)\n*   [Obj-C](#ce208c9625a740f1add1aa50bcb5e8f3_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/connections' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"strategy\": \"samlp\", \"name\": \"CONNECTION_NAME\", \"options\": { \"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\" } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/connections\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/connections\"\n\n\tpayload := strings.NewReader(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/connections\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/connections',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {\n    strategy: 'samlp',\n    name: 'CONNECTION_NAME',\n    options: {\n      metadataUrl: 'https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX'\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"strategy\": @\"samlp\",\n                              @\"name\": @\"CONNECTION_NAME\",\n                              @\"options\": @{ @\"metadataUrl\": @\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/connections\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/connections\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/connections\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/connections\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"strategy\\\": \\\"samlp\\\", \\\"name\\\": \\\"CONNECTION_NAME\\\", \\\"options\\\": { \\\"metadataUrl\\\": \\\"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\\\" } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\n  \"strategy\": \"samlp\",\n  \"name\": \"CONNECTION_NAME\",\n  \"options\": [\"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\"]\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/connections\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\nWhen providing the URL, content is downloaded only once; the connection will not automatically reconfigure if the content of the URL changes in the future.\n\n##### Refresh existing connection information with metadata URL\n\nIf you have a B2B implementation and federate to Auth0 with your own SAML identity provider, you may need to refresh connection information stored in Auth0, such as signing certificate changes, endpoint URL changes, or new assertion fields. Auth0 does this automatically for ADFS connections, but not for SAML connections.\n\nYou can create a batch process (cron job) to do a periodic refresh. The process can run every few weeks and perform a PATCH call to `/api/v2/connections/CONNECTION_ID` endpoint, passing a body containing `{options: {metadataUrl: '$URL'}}` where `$URL` is the same metadata URL with which you created the connection. You use the metadata URL to create a new temporary connection, then compare the properties of the old and new connections. If anything is different, update the new connection and then delete the temporary connection.\n\n1.  Create SAML connection with `options.metadataUrl`. The connection object will be populated with information from the metadata.\n    \n2.  Update metadata content in the URL.\n    \n3.  Send a PATCH to the `/api/v2/connections/CONNECTION_ID` endpoint with `{options: {metadataUrl: '$URL'}}`. Now the connection object is updated with the new metadata content.\n    \n\n## Specify a custom Entity ID\n\nTo specify a custom Entity ID, use the Management API to override the default `urn:auth0:YOUR_TENANT:YOUR_CONNECTION_NAME`. Set the `connection.options.entityID` property when the connection is first created or by updating an existing connection.\n\nThe JSON example below can be used to create a new SAML connection using the SAML IdP’s metadata URL while also specifying a custom Entity ID. The Entity ID is still unique since it is created using the name of the connection.\n\n```\n{\n  \"strategy\": \"samlp\", \n  \"name\": \"{yourConnectionName}\", \n  \"options\": { \n    \"metadataUrl\": \"https://saml-idp/samlp/metadata/uarlU13n63e0feZNJxOCNZ1To3a9H7jX\",\n    \"entityId\": \"urn:your-custom-sp-name:{yourConnectionName}\"\n  }\n}\n```\n\n## Enable the enterprise connection for your Auth0 application\n\nTo use your new SAML enterprise connection, you must first [enable the connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/enable-enterprise-connections) for your Auth0 Applications.\n\n## Set up mappings\n\nSelect the **Mappings** view, enter mappings between the `{}`, and select **Save**.\n\n![Configure SAML Mappings](https://images.ctfassets.net/cdy7uua7fh8z/3matGqveShEDX89p8Bcmwr/6e8a1924c2d2ebde8fd980ed47f78d13/dashboard-connections-enterprise-edit_view-mappings_saml.png)\n\n**Mappings for non-standard PingFederate Servers:**\n\n```\n{\n    \"user_id\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n    \"email\": \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\"\n}\n```\n\n**Mappings for SSO Circle**\n\n```\n{\n  \"email\": \"EmailAddress\",\n  \"given_name\": \"FirstName\",\n  \"family_name\": \"LastName\"\n}\n```\n\n**Map either of two claims to one user attribute**\n\n```\n{\n  \"given_name\": [\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname\",\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n  ]\n}\n```\n\n**How to map name identifier to a user attribute**\n\n```\n{\n  \"user_id\": [\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\",\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn\",\n    \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\"\n  ]\n}\n```\n\n## Test the connection\n\nNow you're ready to [test your connection](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/test-enterprise-connections).",
    "title": "Connect Your App to SAML Identity Providers",
    "description": "Learn how to connect to SAML Identity Providers using an enterprise connection.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/overview-custom-db-connections",
    "markdown": "# Authenticate with Your Own User Store\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nUse a custom database connection when you want to provide access to your own independent (legacy) identity data store for the following purposes:\n\n*   **Authentication**: Use your database as an identity provider in Auth0 to authenticate users. (Referred to as legacy authentication.)\n    \n*   **Import Users**: Use automatic migration (trickle or lazy migration)\n    \n*   **Proxy access to an Auth0 tenant**: Use Auth0 multi-tenant architecture.\n    \n\nYou can create and configure a custom database connection by doing one of the following tasks:\n\n1.  Use the [Create connections](https://auth0.com/docs/api/management/v2#!/Connections/post_connections) endpoint with the `auth0` strategy.\n    \n2.  Navigate to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database), create the connection, and enable the **Use my own database** option to allow database action script editing.\n    \n    ![Enable Custom Database Use My Own Database Option](https://images.ctfassets.net/cdy7uua7fh8z/3kgHDpBFdVWNq9XOfhsTXI/5a18f3634d4d9efa121db32b6cb3d93d/dashboard-connections-database-edit_view-custom-database_use-my-own-database__1_.png)\n\n## How it works\n\nAs shown in the diagram below, you use custom database connections as part of Universal Login workflow in order to obtain user identity information from your own, legacy identity store.\n\n![Custom Database Connections Anatomy](https://images.ctfassets.net/cdy7uua7fh8z/2lHqvZKFiEbAXURU2gmchc/626cac94211c266f2135a41456b2e49d/custom-database-connections.png)\n\nIn addition to artifacts common for all [database connection](https://auth0.com/docs/authenticate/database-connections) types, a custom database connection allows you to configure action scripts: custom code that’s used when interfacing with your legacy identity store. Auth0 provides [custom database action script templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates) for configuration, and the ones you use will depend on whether you are creating a custom database connection for legacy authentication or for automatic migration.\n\n#### Best practice\n\nAction scripts can be implemented as anonymous functions, however anonymous functions make it hard in debugging situations when it comes to interpreting the call-stack generated as a result of any exceptional error condition. For convenience, we recommend providing a function name for each action script.\n\n### Legacy authentication scenario\n\nIn a legacy authentication scenario, a new user record is created within Auth0 during the user's first login, but Auth0 does not store a hash of the user's password. Auth0 will always use the legacy identity store and the identity it contains when authenticating the user.\n\n### Automatic migration scenario\n\nDuring automatic or trickle migration, Auth0 creates a new user in an identity store (database) managed by Auth0. From then on, Auth0 always uses the identity in the Auth0 managed identity store for authenticating the user. For this to occur, first Auth0 requires the user be authenticated against the legacy identity store and only if this succeeds will the new user be created. The new user will be created using the same id and password that was supplied during authentication.\n\n#### Best practice\n\nCreation of a user in an automatic migration scenario typically occurs after the `login` action script completes. We therefore recommend that you do not attempt any deletion of a user from a legacy identity store as an inline operation (i.e., within the `login` script) but perform the deletion as an independent process. This will prevent accidental deletion of a user should an error condition occur during the migration process.\n\nIn an automatic migration scenario, users remain in the legacy identity store and can be deleted or archived if required. One side effect of this can occur if a user is deleted from Auth0 but still remains present in the legacy identity store. In this case, a login actioned by the deleted user could result in either the `login` and/or `getUser` script being executed and the user being migrated from the legacy identity store once again.\n\n#### Best practice\n\nWe recommend marking any legacy user identity as having been migrated before either `login` or `getUser` completes and prior to any eventual legacy store deletion.\n\n## Size\n\nThe total size of implementation for any action script should not exceed 100 kB. The larger the size the more latency is introduced due to the packaging and transport process employed by the Auth0 serverless Webtask platform, and this will have an impact on the performance of your system.\n\n## Environment\n\nAction scripts execute as a series of called JavaScript functions in an instance of a serverless Webtask container. As part of this, a specific environment is provided, together with a number of artifacts supplied by both the Webtask container and the Auth0 authentication server (your Auth0 tenant) itself.\n\n### npm modules\n\nAuth0 serverless Webtask containers can make use of a [wide range of npm modules](https://auth0-extensions.github.io/canirequire/); `npm` modules not only reduce the overall size of action script code implementation, but also provide access to a wide range of pre-built functionality.\n\nMany publicly available `npm` modules are supported out-of-the-box. The list has been compiled and vetted for any potential security concerns. If you require an `npm` module that is not supported out-of-the-box, then you can make a request through the [Auth0 support portal](https://support.auth0.com/) or your Auth0 representative. Auth0 will evaluate your request to determine suitability. There is currently no support in Auth0 for the user of `npm` modules from private repositories.\n\n### Variables\n\nAuth0 action scripts support environment variables, accessed via what is known as the globally-available `configuration` object. To learn more, read the Add Configuration Parameters section in [Create Custom Database Connections](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection).\n\n#### Best practice\n\nThe `configuration` object should be treated as read-only, and should be used for storing sensitive information such as credentials or API keys for accessing external identity stores. This mitigates having security sensitive values hard coded in an action script.\n\nThe configuration object can also be used to support whatever [Software Development Life Cycle (SDLC)](https://auth0.com/docs/get-started/auth0-overview/create-tenants/set-up-multiple-environments) strategies you employ by allowing you to define variables that have tenant specific values. This mitigates hard coded values in an action script which may change depending upon which tenant is executing it.\n\n### global object\n\nAuth0 serverless Webtask containers are provisioned from a pool that's associated with each Auth0 tenant. Each container instance makes available the `global` object, which can be accessed across all action scripts that execute within the container instance. The `global` object acts as a global variable that’s unique to the container, and that can be used to define information or functions used across all action scripts that run in the container instance.\n\nThis means that the `global` object can be used to cache expensive resources as long as those resources are not user-specific. For example, you could use it to store an Access Token for a third-party (logging) API that provides non-user-specific functionality. Or you could store an Access Token to your own non-user-specific API defined in Auth0 and obtained via the [Client Credentials Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow).\n\nEach time a Webtask container is recycled, or for each instantiation of a new Webtask container, the `global` object it defines is reset. Thus, any declaration of assignment within the `global` object associated with a container should also include provision for initialization too.\n\n#### Best practice\n\nTo provide performance flexibility, serverless Webtask containers are provisioned in Auth0 on an ad-hoc basis and are also subject to various recycle policies. In general, we recommend that you do not consider the life of a `global` object to be anything more than 20 minutes.\n\n## Security\n\n### Access legacy identity storage via custom API\n\nProtecting legacy identity storage from general access is a recommended best practice. Exposing a database directly to the internet, for example, can be extremely problematic: database interfaces for SQL and the like are extremely open in terms of functionality, which violates the principle of least privilege when it comes to security.\n\n#### Best practice\n\nWe recommend that you implement an API to provide least privilege to your legacy identity store (database), rather than simply opening up general access via the internet.\n\nThe alternative is to create a simple (custom) API, protected via use of an access token, that each action script can call. This would act as the interface to the legacy identity store. Client credentials grant flow can then be used to obtain an access token from within a script, and this can subsequently be cached for reuse in the `global` object in order to improve performance. The API can then provide a discrete number of protected endpoints that perform only the legacy management functionality required (for example, `read user`, `change password`).\n\n#### Best practice\n\nBy default, Auth0 will give you a token for any API if you authenticate successfully and include the appropriate audience. Restricting access to the legacy identity store API by restricting access token allocation via use of a Rule, will prevent unauthorized usage and mitigate a number of attack vector scenarios, such as where redirect to `/authorize` is intercepted and the audience to the API is added.\n\n### Allowlist access to legacy identity storage\n\nWhether managing access to a legacy identity store via custom API, or using the native interface provided, restricting access to the list of IP addresses associated with your Auth0 tenant. Allowlisting constrains access to the legacy identity store ensuring that only custom database action scripts defined in Auth0 are permitted.\n\n## Learn more\n\n*   [Create Custom Database Connections](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection)\n*   [Custom Database Action Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates)\n*   [Troubleshoot Custom Databases](https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling)\n*   [Import and Export Users](https://auth0.com/docs/manage-users/user-migration)",
    "title": "Authenticate with Your Own User Store",
    "description": "Learn about authenticating users using your database as an identity provider.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection",
    "markdown": "# Create Custom Database Connections\n\n#### Availability varies by Auth0 plan\n\nYour Auth0 plan or custom agreement affects whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nIf you have your own user database, you can use it as an identity provider in Auth0 to authenticate users. In this process, you will create the custom database connection, create database action scripts, and add configuration parameters.\n\nAuth0 allows you to create connections and scripts for most of the commonly-used databases, including:\n\n*   ASP.NET Membership Provider\n    \n*   MongoDB\n    \n*   MySQL\n    \n*   PostgreSQL\n    \n*   SQLServer\n    \n*   Windows Azure SQL Database\n    \n*   Web services accessed via Basic Auth\n    \n\nYou can connect to any kind of database or web service with a properly-configured custom script. Note that input sanitization must be completed on the customer end; Auth0 does not sanitize or validate any username/password combination passed by a custom database.\n\n#### Network firewall\n\nIf you are behind a firewall, this feature may require that you add the appropriate Auth0 IP addresses to the Allow List to work properly.\n\n## Create the connection in the Auth0 Dashboard\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/#/connections/database), and select **Create DB Connection**.\n    \n    ![Select connection](https://images.ctfassets.net/cdy7uua7fh8z/6shISO4Uw6XqldxxGnbrqW/0215e069f09c6baebd1d7abb5b3ae253/2024-03-20_16-39-37.png)\n2.  Configure the connection's settings, and click **Create**:\n    \n    | **Parameter** | **Definition** |\n    | --- | --- |\n    | **Name** | The name of the connection. The name must start and end with an alphanumeric character, contain only alphanumeric characters and dashes, and not exceed 35 characters. |\n    | **Requires Username** | Forces users to provide a username _and_ email address during registration. |\n    | **Username length** | Sets the minimum and maximum length for a username. |\n    | **Disable Signups** | Prevents signups to your application. You will still be able to create users with your API credentials or via the Auth0 Dashboard. |\n    \n    Once Auth0 creates your connection, you'll have the following views (in addition to the **Settings** view):\n    *   Password Policy\n        \n    *   Custom Database\n        \n    *   Applications\n        \n    *   Try Connection\n        \n3.  Select the **Custom Database** view, and enable the **Use my own database** switch.\n    \n    ![Enable Custom Database Use My Own Database Option](https://images.ctfassets.net/cdy7uua7fh8z/3kgHDpBFdVWNq9XOfhsTXI/5a18f3634d4d9efa121db32b6cb3d93d/dashboard-connections-database-edit_view-custom-database_use-my-own-database__1_.png)\n\n## Create database action scripts\n\nToggling the **Use my own database** switch enables the **Database Action Scripts** area where you will create scripts to configure how authentication works when using your database. You can write your database action scripts, or you can select a template from the **Templates** dropdown and modifying it as necessary.\n\nYou **must** configure a `login` script; additional scripts for user functionality are optional.\n\nThe available database action scripts are:\n\n| **Name** | **Description** | **Parameters** |\n| --- | --- | --- |\n| **Login**  <br>Required | Executes each time a user attempts to log in. | `email`, `password` |\n| **Create** | Executes when a user signs up. | `user.email`, `user.password` |\n| **Verify** | Executes after a user follows the verification link. | `email` |\n| **Change Password** | Executes when a user clicks on the confirmation link after a reset password request. | `email`, `newPassword` |\n| **Get User** | Retrieves a user profile from your database without authenticating the user. | `email` |\n| **Delete** | Executes when a user is deleted using the API or Auth0 Dashboard. | `id` |\n| **Change Email** | Executes when a change in the email address, or the email address status, for a user occurs. | `email`, `newEmail`, `verified` |\n\nTo learn more about the scripts, read [Custom Database Action Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates) and [Custom Database Action Script Execution Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution).\n\n### Create a Login script\n\n#### Avoid user ID collisions with multiple databases\n\nThe `id` (or alternatively `user_id`) property in the returned user profile will be used by Auth0 to identify the user.\n\nIf you are using multiple custom database connections, then `id` value must be unique across all the custom database connections to avoid user ID collisions. Our recommendation is to prefix the value of `id` with the connection name (omitting any whitespace). To learn more about user IDs, read [Identify Users](https://auth0.com/docs/manage-users/user-accounts/identify-users).\n\nThe following steps use an example for a MySQL database login script\n\n1.  After toggling the **Use my own database** switch, the **Database Action Scripts** area is enabled. Make sure you are on the **Login** tab.\n    \n2.  Use the **Templates** dropdown to select the MySQL database script template.\n    \n    ```\n    function login(email, password, callback) {\n      var bcrypt = require('bcrypt');\n      var mysql = require('mysql');\n      var connection = mysql.createConnection({\n        host: 'localhost',\n        user: 'me',\n        password: 'secret',\n        database: 'mydb'\n      });\n      connection.connect();\n      var query = \"SELECT id, nickname, email, password \" +\n        \"FROM users WHERE email = ?\";\n      connection.query(query, [email], function (err, results) {\n        if (err) return callback(err);\n        if (results.length === 0) return callback(new WrongUsernameOrPasswordError(email));\n        var user = results[0];\n        bcrypt.compare(password, user.password, function (err, isValid) {\n          if (err) {\n            callback(err);\n          } else if (!isValid) {\n            callback(new WrongUsernameOrPasswordError(email));\n          } else {\n            callback(null, {\n              // This prefix (replace with your own custom DB name)\n              // ensure uniqueness across different custom DBs if there's the\n              // possibility of collisions (e.g. if the user ID is an email address or an integer)\n              id: 'MyConnection1|' + user.id.toString(),\n              nickname: user.nickname,\n              email: user.email\n            });\n          }\n        });\n      });\n    }\n    ```\n    \n    The above script connects to a MySQL database and executes a query to retrieve the first user with `email == user.email`. With the `bcrypt.compareSync` method, it then validates that the passwords match, and if successful, returns an object containing the user profile information including `id`, `nickname`, and `email`. This script assumes that you have a `users` table containing these columns. The `id` returned by Login script is used to construct the user ID attribute of the user profile.\n3.  Click **Save**.\n    \n4.  Click **Try** to test the script. (This step will also save your script.)\n    \n\nScript templates are not used by Auth0 until you click **Save** or **Try**. This is true even if you only modify one script and haven't made changes to any others. You must click **Save** at least once for all the scripts to be in place.\n\n## Custom database support for Organizations\n\nIf you use custom database connections in conjunction with Organizations, you can use the `context` parameter in the script signature to make Organization details like `id`, `name`, and `metadata` available to your custom database action scripts. Organization data is passed in the context object when the associated action happens in the context of an organization; for example, when a user authenticates on an organization’s login prompt, the login action script is passed. To learn more, read [Database Connections](https://auth0.com/docs/authenticate/database-connections).\n\n### Enable context object\n\n1.  Navigate to [Auth0 Dashboard > Authentication > Database](https://manage.auth0.com/dashboard/us/#/connections/database/).\n    \n2.  Select your database connection.\n    \n3.  Under the **Custom Database** tab, find **Context objects in database scripts** and select **Enable**.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/5XO1ypTfQXgRAGx1WBzZRq/a40fe281c749f64d37dabd44c2adffb7/2022-10-28_11-36-37.png)\n\n### Use Organization context\n\nOnce the context object is enabled in Dashboard, you can add a \\`context\\` object to your custom database action scripts, inserted directly preceding the callback parameter. When events are triggered with Organization context, the corresponding data is made available to your custom database action scripts in the format below:\n\n```\n{\n\"organization\": {\n\"display_name\": \"My Organization\",\n\"id\": \"org_XXXXXX\",\n\"metadata\": {\n\"foo\": \"bar\"\n},\n\"name\": \"my-organization\"\n}\n}\n```\n\n## Add configuration parameters\n\nYou can store parameters, like the credentials required to connect to your database, in the **Settings** section below the script editor. These will be available for all of your scripts, and you can access the parameter values using the `configuration` object in your database action scripts (i.e., `configuration.MYSQL_PASSWORD`).\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/5wa0UuUFCLBCc8WlLBax7m/9f88227b6f17cad3bbf4bef23398af26/Screenshot_2023-11-02_at_2.12.37_PM.png)\n\nUse the added parameters in your scripts to configure the connection. For example, you might add the following to the MySQL Login script:\n\n```\nfunction login (username, password, callback) {\n  var mysql = require('mysql');\n  var connection = mysql.createConnection({\n    host     : configuration.MYSQL_HOST,\n    user     : 'me',\n    password : configuration.MYSQL_PASSWORD,\n    database : 'mydb'\n  });\n}\n```\n\n## Learn more\n\n*   [Custom Database Connection and Action Script Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts)\n*   [Troubleshoot Custom Databases](https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling)\n*   [Import and Export Users](https://auth0.com/docs/manage-users/user-migration)",
    "title": "Create Custom Database Connections",
    "description": "Learn how to create a database connection.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/test-custom-database-connections",
    "markdown": "# Test Custom Database Connections\n\nIf you use the Auth0-hosted database structure to store your users, you can test the connection by authenticating users against the same or a separate tenant.\n\n## Test with import users to Auth0 enabled\n\nWhen import users is enabled, users are gradually migrated from your external user store to Auth0 user store. In the process, users will be authenticated against the external store the first time they successfully log in. All further login attempts will be executed against the Auth0 user store. To learn more, read about automatic migrations in [Import and Export Users](https://auth0.com/docs/manage-users/user-migration).\n\n### Create a test tenant and application\n\n1.  Use the Auth0 Dashboard to [create a new tenant](https://auth0.com/docs/get-started/auth0-overview/create-tenants).\n    \n2.  Navigate to [Applications > Applications](https://manage.auth0.com/#/applications/applications) and create a [Machine-to-Machine](https://manage.auth0.com/#/applications/applications/create) application.\n    \n3.  Enable both the **Password** and **Client Credential** grant for this application (both grants should be enabled for this test).\n    \n    ![Auth0 Dashboard > Applications > Advanced Settings](https://images.ctfassets.net/cdy7uua7fh8z/4caAveuhYurCDb5F8mdImm/9e3afe264a82f96972026bfbedec263b/2024-03-13_16-29-39.png)\n4.  To authorize your application, navigate to [Applications > APIs](https://manage.auth0.com/#/apis).\n    \n5.  Select **Management API**.\n    \n6.  Under the **Machine-to-Machine Applications** tab, use the toggle to authorize your test application.\n    \n    ![Applications > APIs > Management API, Machine-to-machine tab](https://images.ctfassets.net/cdy7uua7fh8z/3bqp2332CdbVm7zNVZraFV/019eb5c15133b179e14f40006420a62b/2024-03-13_16-31-21.png)\n7.  Select the drop-down menu to enable the following Auth0 Management API scopes:\n    \n    *   `read:users`\n        \n    *   `update:users`\n        \n    *   `delete:users`\n        \n    *   `create:users`\n        \n    *   `read:users_app_metadata`\n        \n    *   `update:users_app_metadata`\n        \n    *   `create:users_app_metadata`\n        \n        ![Auth0 Dashboard > APIs > Management API > Scopes](https://images.ctfassets.net/cdy7uua7fh8z/2vW8zD1iIObuqb0i59yw77/c43bafa05b271a4343af51cb5c8ce1ce/2024-03-14_10-28-19.png)\n\n### Create test database connections\n\nAfter you create a tenant and an application in Dashboard, create a source database connection and a target database connection.\n\n1.  Navigate to [Authentication > Database](https://manage.auth0.com/#/connections/database) to create a new database connection to be the source.\n    \n2.  Name your test source connection, enable **Requires Username**, and select **Create**.\n    \n    ![Auth0 Dashboard > Authenticate > Database > Create new database connection](https://images.ctfassets.net/cdy7uua7fh8z/5xizPnXaAf8UkX33ozRqml/734d2bdd25a30e9a13ffdc696f25fb62/2024-03-15_09-34-40.png)\n3.  Create a second database to be the target with the same configuration from step 2.\n    \n4.  In your target database, switch to the **Custom Database** view and toggle on **Use my own database**.\n    \n    ![Auth0 Dashboard > Authenticate > Database > Select the target database > Custom Database](https://images.ctfassets.net/cdy7uua7fh8z/3RPDWRDxbR9OPfGvm2AAKm/2afdecaebc60701f718745412622e71c/2024-03-15_11-11-56.png)\n5.  Switch to the **Settings** view and enable **Import Users to Auth0**.\n    \n6.  Switch to the **Custom Database** view, and then locate the **Database settings** section. Add the following information from your source database created in step 1:\n    \n    | **Key** | **Value** |\n    | --- | --- |\n    | `client_id` | Client ID of the application you created. |\n    | `client_secret` | Client Secret of the application you created. |\n    | `auth0_domain` | Your tenant name in the Auth0 domain: `yourTenant.us.auth0.com`. |\n    | `source_database` | Name of the source connection. |\n    \n7.  Update the [Login](https://auth0.com/docs/authenticate/database-connections/test-custom-db#login) and [Get User](https://auth0.com/docs/authenticate/database-connections/test-custom-db#get-user) database action scripts in your target database. To learn more about best practices using database action scripts, read [Custom Database Connection and Action Scripts Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts).\n    \n8.  Select **Save and Try** on each script. You should monitor the Real-time Webtask Logs Extension `console.log` output. To learn more, read [Real-time Webtask Logs Extension](https://auth0.com/docs/customize/extensions/real-time-webtask-logs).\n    \n9.  Select **Try Connection** to test the connection live.\n    \n\n## Test without Import Users enabled\n\n1.  Repeat steps in [Create a test tenant and application](https://www.auth0.com/docs/authenticate/database-connections/test-custom-db#create-a-test-tenant-and-application).\n    \n2.  Create one test database connection.\n    \n3.  Make sure **Import Users to Auth0** under your source database settings is disabled. Users will authenticate against the external user store during each login attempt.\n    \n4.  Update all database actions scripts with the samples below.\n    \n\n### Get User script\n\nThe [Get User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user) script implements an executable function that determines the current state of a user. \n\nWhen **Import Users to Auth0** is enabled, the Get User script runs when a user attempts to sign up to check if the user already exists in the external user store. \n\nThe Get User script also runs when a user attempts to:\n\n*   Change a user's email address ([Change Email](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email) script)\n    \n*   Log in ([Login](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login) script)\n    \n*   Change a user's password ([Change Password](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password) script)\n    \n\nWhen **Import Users to Auth0** is disabled, the Get User script runs when a user attempts to sign up to check if the user already exists in the external user store. If a user already exists in the external user store, it will not execute the Create script.\n\nThe Get User script also runs when a user attempts to:\n\n*   Create a user ([Create](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create) script)\n    \n*   Change a user's email address ([Change Email](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email) script)\n    \n*   Change a user's password ([Change Password](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password) script)\n    \n\n#### Example\n\n```\nasync function getUser(user, context, callback) {\n    log(`Script started.`);\n    log(`Requesting an Access Token from \"${configuration.auth0_domain}\".`);\n    let accessToken = await getAccessToken();\n    accessToken = accessToken.access_token;\n    if (!accessToken) return log(`Failed to get an Access Token from \"${configuration.auth0_domain}\".`, true);\n    log(`The Access Token is available. Searching for user \"${user}\" in \"${configuration.source_database}\"`);\n    user = user.toLowerCase();\n    const searchQuery = encodeURI(`identities.connection:\"${configuration.source_database}\"+AND+(email:${user} OR username:${user})`);\n    var options = {\n        method: `GET`,\n        url: `https://${configuration.auth0_domain}/api/v2/users?q=${searchQuery}`,\n        headers: {\n            Authorization: `Bearer ${accessToken}`,\n        }\n    };\n    request(options, function (error, response) {\n        if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n        let search_results = JSON.parse(response.body);\n        let profile = null;\n        if (search_results.length > 0) {\n            log(`A user \"${user}\" is FOUND in \"${configuration.source_database}\" database.`);\n            profile = {\n                user_id: search_results[0].user_id.toString(),\n                nickname: search_results[0].nickname,\n                username: search_results[0].username,\n                email: search_results[0].email\n            };\n        } else {\n            log(`A user \"${user}\" is NOT FOUND in \"${configuration.source_database}\" database.`);\n        }\n        log(`Script completed!`);\n        return callback(null, profile);\n    });\n    /* -- GET ACCESS TOKEN VIA CLIENT CREDENTIALS -- */\n    async function getAccessToken() {\n        var options = {\n            method: `POST`,\n            url: `https://${configuration.auth0_domain}/oauth/token`,\n            headers: {\n                \"Content-Type\": `application/x-www-form-urlencoded`,\n            },\n            form: {\n                grant_type: `client_credentials`,\n                client_id: configuration.client_id,\n                client_secret: configuration.client_secret,\n                audience: `https://${configuration.auth0_domain}/api/v2/`\n            },\n            json: true\n        };\n        return new Promise(function (resolve) {\n            request(options, function (error, response) {\n                resolve(error || response.body);\n            });\n        });\n    }\n    /* -- LOGGING -- */\n    function log(message, error = false) {\n        const script_name = `GET USER`;\n        const error_label = error ? `(ERROR)` : ``;\n        const return_message = `${script_name}: ${error_label} ${message}`;\n        console.log(return_message);\n        if (error) return callback(new Error(return_message));\n    }\n}\n```\n\n### Login script\n\nThe [Login](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login) script implements an executable function that authenticates a user when a user logs in. If the user exists in the target database (Auth0), it authenticates them using that record. Otherwise, it authenticates the user with their record in the source database (external).\n\n#### Example\n\n```\nfunction login(usernameOrEmail, password, context, callback) {\n  log(`Script started.`);\n  const jwt = require('jsonwebtoken');\n  const options = {\n    method: `POST`,\n    url: `https://${configuration.auth0_domain}/oauth/token`,\n    headers: { \"Content-Type\": `application/x-www-form-urlencoded` },\n    json: true,\n    form: {\n      grant_type: `http://auth0.com/oauth/grant-type/password-realm`,\n      client_id: configuration.client_id,\n      client_secret: configuration.client_secret,\n      username: usernameOrEmail,\n      password: password,\n      realm: `${configuration.source_database}`\n    }\n  };\n  request(options, function (error, response, body) {\n    log(`Attempting to authenticate a user \"${usernameOrEmail}\" against \"${configuration.source_database}\" database in \"${configuration.auth0_domain}\" tenant.`);\n    if (error) return log(`Cannot connect to \"${configuration.auth0_domain}\" database.`, true);\n    if (response.statusCode !== 200) {\n      console.log(`LOGIN: (ERROR) ${response.body.error_description}`);\n      return callback(new WrongUsernameOrPasswordError(usernameOrEmail, `LOGIN: (ERROR) ${response.body.error_description}`));\n    }\n    log(`Successfuly authenticated user \"${usernameOrEmail}\" against \"${configuration.source_database}\" database in \"${configuration.auth0_domain}\" tenant.`);\n    const decoded_id_token = jwt.decode(body.id_token);\n    const profile = {\n      user_id: decoded_id_token.sub,\n      nickname: decoded_id_token.nickname,\n      username: decoded_id_token.username,\n      email: decoded_id_token.email\n    };\n    log(`Script completed.`);\n    return callback(null, profile);\n  });\n  /* -- LOGGING -- */\n  function log(message, error = false) {\n    const script_name = `LOGIN`;\n    const error_label = error ? `(ERROR)` : ``;\n    const return_message = `${script_name}: ${error_label} ${message}`;\n    console.log(return_message);\n    if (error) return callback(new Error(return_message));\n  }\n}\n```\n\n### Create script\n\nThe [Create script](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create) implements an executable function that creates a corresponding user record in the external database when a user signs up through Universal Login, or is created in the Auth0 Dashboard or with the Auth0 Management API.\n\n#### Example\n\n```\nasync function create(user, context, callback) {\n  log(`Script started.`);\n  log(`Requesting an Access Token from \"${configuration.auth0_domain}\".`);\n  let accessToken = await getAccessToken();\n  if (!accessToken.access_token) return log(`Failed to get an Access Token from \"${configuration.auth0_domain}\".`, true);\n  accessToken = accessToken.access_token;\n  log(`The Access Token is available. Attempting to create a user \"${user.email}\" in \"${configuration.source_database}\"`);\n  const options = {\n    method: `POST`,\n    url: `https://${configuration.auth0_domain}/api/v2/users`,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      \"Content-Type\": `application/x-www-form-urlencoded`\n    },\n    form: {\n      connection: configuration.source_database,\n      email: user.email,\n      password: user.password,\n      username: user.username\n    },\n    json: true\n  };\n  request(options, function (error, response) {\n    if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n    switch (response.statusCode) {\n      case 201:\n        log(`The user \"${user.email}\" is successfuly created in \"${configuration.source_database}\" database.`);\n        return callback(null);\n      case 409:\n        return callback(new ValidationError(`user_exists`, `The user already exists in \"${configuration.source_database}\" database.`));\n      default:\n        return log(`Failed to create a user \"${user.email}\" in \"${configuration.source_database}\" database. Error: \"${response.statusCode}, ${response.body.message}\"`, true);\n    }\n  });\n  /* -- GET ACCESS TOKEN VIA CLIENT CREDENTIALS -- */\n  async function getAccessToken() {\n    var options = {\n      method: `POST`,\n      url: `https://${configuration.auth0_domain}/oauth/token`,\n      headers: {\n        \"Content-Type\": `application/x-www-form-urlencoded`,\n      },\n      form: {\n        grant_type: `client_credentials`,\n        client_id: configuration.client_id,\n        client_secret: configuration.client_secret,\n        audience: `https://${configuration.auth0_domain}/api/v2/`\n      },\n      json: true\n    };\n    return new Promise(function (resolve) {\n      request(options, function (error, response) {\n        resolve(error || response.body);\n      });\n    });\n  }\n  /* -- LOGGING -- */\n  function log(message, error = false) {\n    const script_name = `CREATE`;\n    const error_label = error ? `(ERROR)` : ``;\n    const return_message = `${script_name}: ${error_label} ${message}`;\n    console.log(return_message);\n    if (error) return callback(new Error(return_message));\n  }\n}\n```\n\n### Delete script\n\nThe [Delete script](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete) implements an executable function that deletes a user from Auth0 and the external database in the same operation when a user is deleted in the Auth0 Dashboard or with the Auth0 Management API.\n\n#### Example\n\n```\nasync function deleteUser(user, context, callback) {\n  log(`Script started.`);\n  log(`Requesting an Access Token from \"${configuration.auth0_domain}\".`);\n  let accessToken = await getAccessToken();\n  if (!accessToken.access_token) return log(`Failed to get an Access Token from \"${configuration.auth0_domain}\".`, true);\n  accessToken = accessToken.access_token;\n  log(`The Access Token is available. Attempting to delete a user \"${user}\" from \"${configuration.source_database}\"`);\n  const options = {\n    method: `DELETE`,\n    url: `https://${configuration.auth0_domain}/api/v2/users/${user}`,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      \"Content-Type\": `application/x-www-form-urlencoded`\n    },\n    json: true\n  };\n  request(options, function (error, response) {\n    if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n    switch (response.statusCode) {\n      case 204:\n        log(`The user \"${user}\" is successfuly deleted from \"${configuration.source_database}\" database.`);\n        return callback(null);\n      default:\n        return log(`Failed to delete a user \"${user}\" from \"${configuration.source_database}\" database. Error: \"${response.statusCode}, ${response.body.message}\"`, true);\n    }\n  });\n  /* -- GET ACCESS TOKEN VIA CLIENT CREDENTIALS -- */\n  async function getAccessToken() {\n    var options = {\n      method: `POST`,\n      url: `https://${configuration.auth0_domain}/oauth/token`,\n      headers: {\n        \"Content-Type\": `application/x-www-form-urlencoded`,\n      },\n      form: {\n        grant_type: `client_credentials`,\n        client_id: configuration.client_id,\n        client_secret: configuration.client_secret,\n        audience: `https://${configuration.auth0_domain}/api/v2/`\n      },\n      json: true\n    };\n    return new Promise(function (resolve) {\n      request(options, function (error, response) {\n        resolve(error || response.body);\n      });\n    });\n  }\n  /* -- LOGGING -- */\n  function log(message, error = false) {\n    const script_name = `DELETE`;\n    const error_label = error ? `(ERROR)` : ``;\n    const return_message = `${script_name}: ${error_label} ${message}`;\n    console.log(return_message);\n    if (error) return callback(new Error(return_message));\n  }\n}\n```\n\n### Verify script\n\nThe [Verify script](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify) implements an executable function that marks the verification status of a user’s email address in the external database when a user clicks on the link in the verification email sent by Auth0.\n\n#### Example\n\n```\nasync function verify(user, context, callback) {\n  log(`Script started.`);\n  log(`Requesting an Access Token from \"${configuration.auth0_domain}\".`);\n  let accessToken = await getAccessToken();\n  if (!accessToken.access_token) return log(`Failed to get an Access Token from \"${configuration.auth0_domain}\".`, true);\n  accessToken = accessToken.access_token;\n  log(`The Access Token is available. Searching for user \"${user}\" in \"${configuration.source_database}\"`);\n  user = user.toLowerCase();\n  const searchQuery = encodeURI(`identities.connection:\"${configuration.source_database}\"+AND+(email:${user} OR username:${user})`);\n  var options = {\n    method: `GET`,\n    url: `https://${configuration.auth0_domain}/api/v2/users?q=${searchQuery}`,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n    }\n  };\n  request(options, function (error, response) {\n    if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n    let search_results = JSON.parse(response.body);\n    if (search_results.length > 0) {\n      log(`A user \"${user}\" is found in \"${configuration.source_database}\" database.`);\n      const user_id = search_results[0].user_id.toString();\n      log(`Attempting to mark user \"${user_id}\" as verified in \"${configuration.source_database}\" database`);\n      const options = {\n        method: `PATCH`,\n        url: `https://${configuration.auth0_domain}/api/v2/users/${user_id}`,\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          \"Content-Type\": `application/x-www-form-urlencoded`\n        },\n        form: {\n          email_verified: true,\n        },\n        json: true\n      };\n      request(options, function (error, response) {\n        if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n        switch (response.statusCode) {\n          case 200:\n            log(`The user \"${user}\" is marked as verified in \"${configuration.source_database}\" database.`);\n            return callback(null, true);\n          default:\n            return log(`Failed to mark a user \"${user}\" as verified in \"${configuration.source_database}\" database. Error: \"${response.statusCode}, ${response.body.message}\"`, true);\n        }\n      });\n    } else {\n      log(`A user \"${user}\" is not found in \"${configuration.source_database}\" database. Unable to verify.`, true);\n    }\n  });\n  /* -- GET ACCESS TOKEN VIA CLIENT CREDENTIALS -- */\n  async function getAccessToken() {\n    var options = {\n      method: `POST`,\n      url: `https://${configuration.auth0_domain}/oauth/token`,\n      headers: {\n        \"Content-Type\": `application/x-www-form-urlencoded`,\n      },\n      form: {\n        grant_type: `client_credentials`,\n        client_id: configuration.client_id,\n        client_secret: configuration.client_secret,\n        audience: `https://${configuration.auth0_domain}/api/v2/`\n      },\n      json: true\n    };\n    return new Promise(function (resolve) {\n      request(options, function (error, response) {\n        resolve(error || response.body);\n      });\n    });\n  }\n  /* -- LOGGING -- */\n  function log(message, error = false) {\n    const script_name = `VERIFY`;\n    const error_label = error ? `(ERROR)` : ``;\n    const return_message = `${script_name}: ${error_label} ${message}`;\n    console.log(return_message);\n    if (error) return callback(new Error(return_message));\n  }\n}\n```\n\n### Change Password script\n\nThe [Change Password script](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password) implements an executable function that updates a user's password in the external database when a password change workflow starts from the Auth0 Dashboard or the Auth0 Management API.\n\n#### Example\n\n```\nasync function changePassword(user, newPassword, context, callback) {\n  log(`Script started.`);\n  log(`Requesting an Access Token from \"${configuration.auth0_domain}\".`);\n  let accessToken = await getAccessToken();\n  if (!accessToken.access_token) return log(`Failed to get an Access Token from \"${configuration.auth0_domain}\".`, true);\n  accessToken = accessToken.access_token;\n  log(`The Access Token is available. Searching for user \"${user}\" in \"${configuration.source_database}\" database.`);\n  user = user.toLowerCase();\n  const searchQuery = encodeURI(`identities.connection:\"${configuration.source_database}\"+AND+(email:${user} OR username:${user})`);\n  var options = {\n    method: `GET`,\n    url: `https://${configuration.auth0_domain}/api/v2/users?q=${searchQuery}`,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n    }\n  };\n  request(options, function (error, response) {\n    if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n    let search_results = JSON.parse(response.body);\n    if (search_results.length > 0) {\n      log(`A user \"${user}\" is found in \"${configuration.source_database}\" database.`);\n      const user_id = search_results[0].user_id.toString();\n      log(`Attempting to change password for user \"${user_id}\" in \"${configuration.source_database}\" database.`);\n      const options = {\n        method: `PATCH`,\n        url: `https://${configuration.auth0_domain}/api/v2/users/${user_id}`,\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          \"Content-Type\": `application/x-www-form-urlencoded`\n        },\n        form: {\n          password: newPassword,\n        },\n        json: true\n      };\n      request(options, function (error, response) {\n        if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n        switch (response.statusCode) {\n          case 200:\n            log(`The user \"${user}\" password successfully changed in \"${configuration.source_database}\" database.`);\n            return callback(null, true);\n          default:\n            return log(`Failed to change password for \"${user}\"  in \"${configuration.source_database}\" database. Error: \"${response.statusCode}, ${response.body.message}\"`, true);\n        }\n      });\n    } else {\n      log(`A user \"${user}\" is not found in \"${configuration.source_database}\" database. Unable to change password.`, true);\n    }\n  });\n  /* -- GET ACCESS TOKEN VIA CLIENT CREDENTIALS -- */\n  async function getAccessToken() {\n    var options = {\n      method: `POST`,\n      url: `https://${configuration.auth0_domain}/oauth/token`,\n      headers: {\n        \"Content-Type\": `application/x-www-form-urlencoded`,\n      },\n      form: {\n        grant_type: `client_credentials`,\n        client_id: configuration.client_id,\n        client_secret: configuration.client_secret,\n        audience: `https://${configuration.auth0_domain}/api/v2/`\n      },\n      json: true\n    };\n    return new Promise(function (resolve) {\n      request(options, function (error, response) {\n        resolve(error || response.body);\n      });\n    });\n  }\n  /* -- LOGGING -- */\n  function log(message, error = false) {\n    const script_name = `CHANGE PASSWORD`;\n    const error_label = error ? `(ERROR)` : ``;\n    const return_message = `${script_name}: ${error_label} ${message}`;\n    console.log(return_message);\n    if (error) return callback(new Error(return_message));\n  }\n}\n```\n\n### Change Email script\n\nThe [Change Email](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email) script implements an executable function that updates a user's email address when the user changes their email address or their email address verification status.\n\nThis script is not available in the Auth0 Dashboard. You must call the Management API [Update a connection](https://auth0.com/docs/api/management/v2/connections/patch-connections-by-id) endpoint and provide the `options.customScripts.change_email` property.\n\n#### Example\n\n```\nasync function changeEmail(user, newEmail, verified, callback) {\n  log(`Script started.`);\n  log(`Requesting an Access Token from \"${configuration.auth0_domain}\".`);\n  let accessToken = await getAccessToken();\n  if (!accessToken.access_token) return log(`Failed to get an Access Token from \"${configuration.auth0_domain}\".`, true);\n  accessToken = accessToken.access_token;\n  log(`The Access Token is available. Searching for user \"${user}\" in \"${configuration.source_database}\" database.`);\n  user = user.toLowerCase();\n  const searchQuery = encodeURI(`identities.connection:\"${configuration.source_database}\"+AND+(email:${user} OR username:${user})`);\n  var options = {\n    method: `GET`,\n    url: `https://${configuration.auth0_domain}/api/v2/users?q=${searchQuery}`,\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n    }\n  };\n  request(options, function (error, response) {\n    if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n    let search_results = JSON.parse(response.body);\n    if (search_results.length > 0) {\n      log(`A user \"${user}\" is found in \"${configuration.source_database}\" database.`);\n      const user_id = search_results[0].user_id.toString();\n      log(`Attempting to change email / verified status for user \"${user_id}\" in \"${configuration.source_database}\" database.`);\n      const options = {\n        method: `PATCH`,\n        url: `https://${configuration.auth0_domain}/api/v2/users/${user_id}`,\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          \"Content-Type\": `application/x-www-form-urlencoded`\n        },\n        form: {\n          email: newEmail,\n          email_verified: verified || false\n        },\n        json: true\n      };\n      request(options, function (error, response) {\n        if (error) return log(`Cannot connect to \"${configuration.source_database}\" database.`, true);\n        switch (response.statusCode) {\n          case 200:\n            log(`The user \"${user}\" email / verified status successfully changed in \"${configuration.source_database}\" database.`);\n            return callback(null, true);\n          default:\n            return log(`Failed to change email / verified status for \"${user}\"  in \"${configuration.source_database}\" database. Error: \"${response.statusCode}, ${response.body.message}\"`, true);\n        }\n      });\n    } else {\n      log(`A user \"${user}\" is not found in \"${configuration.source_database}\" database. Unable to change email / verified status.`, true);\n    }\n  });\n  /* -- GET ACCESS TOKEN VIA CLIENT CREDENTIALS -- */\n  async function getAccessToken() {\n    var options = {\n      method: `POST`,\n      url: `https://${configuration.auth0_domain}/oauth/token`,\n      headers: {\n        \"Content-Type\": `application/x-www-form-urlencoded`,\n      },\n      form: {\n        grant_type: `client_credentials`,\n        client_id: configuration.client_id,\n        client_secret: configuration.client_secret,\n        audience: `https://${configuration.auth0_domain}/api/v2/`\n      },\n      json: true\n    };\n    return new Promise(function (resolve) {\n      request(options, function (error, response) {\n        resolve(error || response.body);\n      });\n    });\n  }\n  /* -- LOGGING -- */\n  function log(message, error = false) {\n    const script_name = `CHANGE EMAIL`;\n    const error_label = error ? `(ERROR)` : ``;\n    const return_message = `${script_name}: ${error_label} ${message}`;\n    console.log(return_message);\n    if (error) return callback(new Error(return_message));\n  }\n}\n```\n\n## Learn more\n\n*   [Password Strength in Auth0 Database Connections](https://auth0.com/docs/authenticate/database-connections/password-strength)\n*   [Custom Database Action Script Environment Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/environment)\n*   [Password Options in Auth0 Database Connections](https://auth0.com/docs/authenticate/database-connections/password-options)\n*   [Configure Identity Provider Connection for User Profile Updates](https://auth0.com/docs/manage-users/user-accounts/user-profiles/configure-connection-sync-with-auth0)\n*   [Connection Settings Best Practices](https://auth0.com/docs/authenticate/connection-settings-best-practices)\n*   [Create Custom Database Connections](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection)",
    "title": "Test Custom Database Connections",
    "description": "Describes how to test your custom database connections in Auth0 Dashboard.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts",
    "markdown": "# Custom Database Connection and Action Script Best Practices\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\nExtensibility provides the ability to add custom login in Auth0 as a mechanism for building out last-mile solutions for Identity and Access Management (IdAM). Auth0 extensibility comes in several forms:\n\n*   [**Actions**](https://auth0.com/docs/customize/actions): Actions are secure, tenant-specific, versioned functions written in Node.js that execute at certain points within the Auth0 platform. Use actions to customize and extend Auth0's capabilities with custom login.\n    \n*   [Rules](https://auth0.com/docs/customize/rules): Run when artifacts for user authenticity are generated. For example:\n    \n    *   ID Token in OpenID Connect (OIDC)\n        \n    *   Access Token in OAuth 2.0\n        \n    *   An assertion in SAML\n        \n*   [Hooks](https://auth0.com/docs/customize/hooks): Provide additional extensibility when there is an exchange of non-user-related artifacts and when user identities are created such as pre-user registration and post-user registration.\n    \n*   **Scripts for both custom database connections and migrations**: Used to integrate with an existing user identity store or where automatic user migration from an independent or legacy identity store are required. For more more configuration information, review [Create Custom Database Connections.](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection)\n    \n\nEach extensibility type uses Node.js running on the Auth0 platform in an Auth0 tenant.\n\nWhatever the use case, Auth0 extensibility provides comprehensive and sophisticated capability to tailor IdAM operations to your exact requirements. However, if not utilized in the right way, this can open up the potential for improper or unintended use which can lead to problematic situations down the line. In an attempt to address matters ahead of time, this document provides best practice guidance to both designers and implementers, and we recommend reading it in its entirety at least once, even if you've already started your journey with Auth0.\n\n## Learn more\n\n*   [Custom Database Connection Anatomy Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/anatomy)\n*   [Custom Database Action Script Environment Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/environment)\n*   [Custom Database Action Script Execution Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution)\n*   [Custom Database Connection Security Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/connection-security)\n*   [Error Handling Best Practices](https://auth0.com/docs/troubleshoot/error-handling-best-practices)\n*   [Rules Testing Best Practices](https://auth0.com/docs/rules-best-practices/rules-testing-best-practices)",
    "title": "Custom Database Connection and Action Script Best Practices",
    "description": "Learn about best practices for custom database connections and database action scripts.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions/flows-and-triggers",
    "markdown": "# Explore Flows and Triggers\n\nThe processes which can be extended with Actions are called Flows. Each Flow is made up of one or more Triggers and represents the logical pipeline through which information moves during a single point in the Auth0 journey. Multiple Actions can be added to a Trigger, with each Action executing in the order in which it was placed. Some Triggers are executed synchronously, blocking the flow in which they are involved, and some are executed asynchronously.\n\nTo explore reference objects and blueprints for specific Actions for a trigger, select the trigger below, noting Auth0's definition of a [passwordless connection](https://auth0.com/docs/authenticate/passwordless).\n\n| Flow | Runs | Trigger(s) | Execution | Example Uses |\n| --- | --- | --- | --- | --- |\n| [Login](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow) | As a user logs in. | post-login | Synchronous | *   Modify access and ID tokens<br>*   Call APIs to enrich user profiles or send notifications<br>*   Create authorization rules and make access decisions based on custom logic<br>*   Conditionally enable MFA<br>*   Redirect users to an external site |\n| [Machine to Machine](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow) | When an access token is issued via the Client Credentials Flow. | credentials-exchange | Synchronous | *   Prevent tokens from being issued<br>*   Add custom claims to the access token |\n| [Password Reset](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset) | After the user completes the first challenge, but before the user enters a new password. | post-challenge | Synchronous | *   Challenge a user with an additional MFA factor before allowing them to set a new password<br><br>*   Redirect the user to a third-party website/service, such as a custom MFA provider, before allowing them to set a new password |\n| [Pre User Registration](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow) | Before a user is added to a Database or Passwordless Connection. | pre-user-registration | Synchronous | *   Prevent creation of a user in Auth0<br>*   Add custom app\\_metadata or user\\_metadata to a newly created user |\n| [Post User Registration](https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow) | After a user is added to a Database or Passwordless Connection. | post-user-registration | Asynchronous | *   Send a new user notification<br>*   Create a record in a CRM system |\n| [Post Change Password](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow) | After a password is changed for a Database Connection user. | post-change-password | Asynchronous | *   Send an email to a user to notify them that their password has been changed<br>*   Call an API to revoke a user’s sessions in other systems after their password has been change |\n| [Send Phone Message](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow) | To send a Phone or SMS message as part of a Custom MFA Provider. | send-phone-message | Synchronous | Use a custom provider for sending MFA Phone or SMS messages |\n\n## Learn more\n\n*   [Login Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow)\n*   [Machine to Machine Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/machine-to-machine-flow)\n*   [Pre User Registration Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/pre-user-registration-flow)\n*   [Post User Registration Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/post-user-registration-flow)\n*   [Post Change Password Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow)\n*   [Send Phone Message Flow](https://auth0.com/docs/customize/actions/flows-and-triggers/send-phone-message-flow)",
    "title": "Explore Flows and Triggers",
    "description": "Learn about triggers, which are events that automatically invokes an Action when a specific operation, such as a user logging in, occurs at runtime.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience",
    "markdown": "# Classic Login Experience\n\nClassic Login is an Auth0-hosted login experience that relies on JavaScript for customization. Implementing Classic Login is less complex than embedding the authentication process directly in your app, and it can help prevent the dangers of cross-origin authentication.\n\nClassic Login is built on top of Auth0's JavaScript libraries ([Lock.js](https://auth0.com/docs/libraries/lock), [auth0.js](https://auth0.com/docs/libraries/auth0js), MFA Widget, and Password Reset). When customizing Classic Login pages in the Auth0 Dashboard, the default templates use the same JavaScript libraries to create a more natural transition between the default user interface and a custom one.\n\nAfter choosing a default template for your Classic Login pages, you can modify it to meet your needs. You can also customize a variety of behavioral and appearance elements of the Lock widget. The Auth0.js templates offer additional flexibility as you can create a custom user interface and modify it to match your application's style.\n\n## Implement Classic Login\n\nTo learn how to set up your application to use Classic Login, read our [Quickstarts](https://auth0.com/docs/quickstarts). Choose the approach that best fits your technologies, and the Quickstarts walk you through the implementation.\n\n## Learn more\n\n*   [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login)\n*   [Customize Classic Login](https://auth0.com/docs/customize/login-pages/classic-login)\n*   [Customize Classic Login Pages](https://auth0.com/docs/customize/login-pages/classic-login/customization-classic)\n*   [Customize Classic Login Pages with Lock or SDK](https://auth0.com/docs/customize/login-pages/classic-login/customize-with-lock-sdk)\n*   [Customize MFA for Classic Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login)",
    "title": "Classic Login Experience",
    "description": "An overview of the Classic Login experience",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling",
    "markdown": "# Troubleshoot Custom Databases\n\nYou can use return errors resulting from your custom database connection for troubleshooting purposes. We will also cover some basic troubleshooting steps for your scripts.\n\n## Types of errors\n\nYou may receive different types of errors from a database connection:\n\n| Error | Login Script | Description |\n| --- | --- | --- |\n| `new WrongUsernameOrPasswordError(<email or user_id>, <message>)` | Login | Occurs when the user's credentials are invalid. Passing no arguments or a falsey first argument will result in the error being logged as an `fu` event (invalid username/email) with an empty string for a `user_id`. Providing a truthy first argument will result in the error being logged as an `fp` event (the user exists, but the password is invalid) with a `user_id` value of `auth0\\|<first argument>`. To learn more, read [Log Event Type Codes](https://auth0.com/docs/deploy-monitor/logs/log-event-type-codes). |\n| `new ValidationError(<user_exists>, <message>)` | Create | Occurs when a user already exists in your database. |\n| `callback(<null>,<false>)` | Change Password | Occurs when the user's password was not updated. |\n| `callback(<null>)` | Get User | Occurs when the user is not found. |\n| `new UnauthorizedError(<message>)` | All Login Scripts | Occurs when something went wrong while trying to reach the database. Preferred way of communicating errors back from custom databases to front-end. |\n| `new Error(<message>)` | All Login Scripts | Occurs when something went wrong while trying to reach the database. |\n| `error code: auth0_idp_error; user already exists` | Create | Occurs in legacy identity store when you attempt to create a user that already exists in your legacy identity store or in Auth0. |\n| `error code: auth0_idp_error; user already exists` | Delete | Occurs in legacy identity store when you attempt to delete a user with custom database scripts. Error could also manifest as `Error! There was a problem deleting user@example.com` or `Sandbox Error: Please implement the Delete script for this database connection at https://manage.auth0.com/#/connections/database`. |\n\n## Return errors\n\nTo return an error, call the **callback** function while passing **error** as the first parameter:\n\nExample:\n\n```\ncallback(new ValidationError('email-too-long', 'Email is too long.'));\n```\n\n### Returning errors when using Lock\n\nIf you use Lock, you can [customize the error messages](https://auth0.com/docs/customize/login-pages/classic-login/customize-lock-error-messages) that will be displayed by adding them to the dictionary.\n\n## Troubleshooting errors\n\nTest the script using the **Try** button.\n\nIf you do not get the expected result or you receive an error, install the [Real-time Webtask Logs extension](https://auth0.com/docs/customize/extensions/real-time-webtask-logs), use `console.log()` statements in your script, and try the connection again. The output of `console.log()` will print to the Real-time Webtask Logs window.\n\nYou may experience errors using action scripts to import, create, or delete users. Use `console.logs` to verify the error is a result of using action scripts. To learn more, read [Custom Database Action Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates).",
    "title": "Troubleshoot Custom Databases",
    "description": "Describes how to handle errors and troubleshoot when using your database as an identity provider.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/passkeys/monitor-passkey-events-in-tenant-logs",
    "markdown": "# Monitor Passkey Events in Tenant Logs\n\nYou can monitor passkey flows associated with your database connections through [tenant logs](https://auth0.com/docs/deploy-monitor/logs).\n\nYou can view log events in the Auth0 Dashboard ([Monitoring > Logs](https://manage.auth0.com/#/logs)) or retrieve logs using the [Management API](https://auth0.com/docs/api/management/v2/logs/get-logs).\n\n| **Event code** | **Scenario** | **Notes** |\n| --- | --- | --- |\n| `ss` | During signup, a user registered a passkey as their primary authentication method. | This log event contains the `details.authentication_methods` array field with the entry value `passkey`.<br><br>If a user registered with a password, this array field contains the entry value `pwd`. |\n| `s` | During login, a user authenticated with a passkey. | This log event contains the `details.prompts` array which lists the set of prompts a user navigated through during login.<br><br>If a user authenticated using a passkey, the array contains an element with the following field: `\"performed_amr\": [\"phr\"]`. |\n| `gd_enrollment_complete` | A progressive or local enrollment flow was successfully completed. | This log event contains the `details.authenticator.type` field with the value `passkey` if a user enrolled a passkey. |\n| `gd_webauthn_enrollment_failed` | An error occurred during a progressive or local enrollment flow. | This log event contains the `details.authentication_methods array` field with the entry value `passkey` if a user tried to enroll a passkey. |",
    "title": "Monitor Passkey Events in Tenant Logs",
    "description": "Learn how to identify and monitor passkey events in your tenant logs.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow",
    "markdown": "# Post Change Password Flow\n\nThe Post Change Password Flow runs after a user resets or changes their password. You can use this flow to email the user after a password change or to notify another system that the user’s password has changed, so that other sessions not managed by Auth0 can be revoked.\n\n![Diagram showing the Actions Post Change Password Flow.](https://images.ctfassets.net/cdy7uua7fh8z/3i65TvmTpHkyDTqKvXAkMi/3adb8f0bd195cec4dd0a82cb87b270b9/post-change-password-flow.png)\n\nActions in this flow are non-blocking (asynchronous), which means the Auth0 pipeline will continue to run without waiting for the Action to finish its execution. Thus, the Action's outcome does not affect the Auth0 transaction.\n\n## Triggers\n\n### Post Change Password\n\nThe `post-change-password` trigger runs after a database connection user resets or changes their password.\n\nMultiple Actions can be bound to this trigger, and the Actions will run in order. However, these Actions will be run asynchronously and will not block the password reset process.\n\n### Reference\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow/event-object): Provides contextual information about the user and the connection on which the password was changed.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/post-change-password-flow/api-object): Provides methods for changing the behavior of the flow.\n    \n\n## Common use cases\n\n### Invalidate the user’s session in another system\n\nA post-change-password Action can be used to invalidate the user's session in another system:\n\n```\nconst axios = require(\"axios\");\n\n/**\n * @param {Event} event - Details about user whose password was changed.\n */\nexports.onExecutePostChangePassword = async (event) => {\n  axios.post(\"https://my-api.exampleco.com/revoke-session\", { params: { email: event.user.email }});\n};\n```\n\n### Send an email after the user changes their password\n\n```\nconst axios = require(\"axios\");\n\nexports.onExecutePostChangePassword = async (event) => {\n  try {\n    // https://sendgrid.api-docs.io/v3.0/mail-send\n    axios.post('https://api.sendgrid.com/v3/mail/send',\n      {\n        personalizations: [{\n          to: [{ email: event.user.email }]\n        }],\n        from: { email: 'admin@exampleco.com' },\n        subject: 'Your password was changed',\n        content: [{\n          type: 'text/plain',\n          value: 'The password for your ' + event.connection.name + ' account ' + event.user.email + ' was recently changed.'\n        }]\n      },\n      {\n        headers: {\n          'Authorization': 'Bearer ' + event.secrets.SENDGRID_API_KEY\n        },\n      }\n    );\n  } catch (err) {\n    console.log(`Error sending email to ${event.user.email}:`, err.message)\n  }\n};\n```",
    "title": "Post Change Password Flow",
    "description": "Learn about the Post Change Password flow and the post-change-password Action trigger, which runs after a Database connection user resets or changes their password. This trigger can be used to notify another system that the user’s password has changed.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/passkeys/configure-passkey-policy",
    "markdown": "# Configure Passkey Policy\n\nYou can enable passkeys as an authentication method and configure your passkey policy in the Auth0 Dashboard.\n\n## Prerequisites\n\nTo enable passkeys as an authentication method for your database connection, you must configure your Auth0 tenant to fulfill the following prerequisites.\n\nIf these prerequisites are not met and you try to enable passkeys, the Auth0 Dashboard displays the **Passkey Authentication Prerequisites** readiness checklist and shows any unmet requirements.\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/51aI3GgLqE4rTw93V26DZ0/5a800debe7068edc41b948d16a0ec3f2/Passkey_Authentication_Prerequisities__popup_.png)\n\nAfter you enable passkeys as an authentication method for a database connection, you can use the readiness checklist to monitor the status of each requirement and access the relevant settings.\n\nTo view the **Passkey Authentication Prerequisites** readiness checklist:\n\n1.  In the Auth0 Dashboard, go to [Authentication > Database](https://manage.auth0.com/dashboard/#/connections/database).\n    \n2.  Select a connection.\n    \n3.  Switch to the **Authentication Methods** view.\n    \n4.  Select **Configure** on the **Passkeys** card.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/1aY0EHAVCx9zsDyy8FlrzH/cefbaceed45f33460d3a5feeab885909/Dashboard_-_Passkey_Authentication_Prerequisites__Checklist_.png)\n\n### Enable New Universal Login Experience\n\nEnable and configure the [New Universal Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience).\n\n#### Disable Custom Login Page setting\n\nThe **Customize Login Page** setting allows you to customize login pages when using a [custom domain](https://auth0.com/docs/customize/custom-domains).\n\n1.  In the Auth0 Dashboard, go to [Branding > Universal Login > Advanced Options > Login](https://manage.auth0.com/#/login_page).\n    \n2.  Disable the **Custom Login Page** toggle.\n    \n\n### Enable Identifier First authentication\n\nEnable and configure [Identifier First authentication](https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first).\n\n### Update database connection settings\n\nYou must update specific settings for your database connection to use passkeys as an authentication method.\n\n#### Disable Requires Username setting\n\nThe **Requires Username** setting requires users to provide both a username and their email when logging in to a database connection.\n\n1.  In the Auth0 Dashboard, go to [Authentication > Database](https://manage.auth0.com/#/connections/database).\n    \n2.  Select a connection.\n    \n3.  Switch to the **Settings** view.\n    \n4.  Disable the **Requires Username** toggle.\n    \n\n#### Disable Use my own database setting unless Import Users to Auth0 setting is enabled\n\nThe **Use my own database** setting allows you to use an external database to store users on a [custom database](https://auth0.com/docs/authenticate/database-connections/custom-db/create-db-connection) connection.\n\nThe **Import Users to Auth0** settings allows you to automatically import users from an external database to Auth0. For more information, read [Import and Export Users](https://auth0.com/docs/manage-users/user-migration/user-migration-scenarios).\n\nIf the **Import Users to Auth0** setting is not enabled on your tenant, you must disable the **Use my own database** setting to configure passkeys:\n\n1.  In the Auth0 Dashboard, go to [Authentication > Database](https://manage.auth0.com/#/connections/database).\n    \n2.  Select a connection.\n    \n3.  Switch to the **Custom Database** view.\n    \n4.  Disable the **Use my own database** toggle.\n    \n\n## Best practices\n\nTo ensure the best experience for end users when using passkeys, consider the items below.\n\n*   **Configure a custom domain:** When a user enrolls a passkey, it associates with the relying party domain. If the domain name changes at any time, all of the passkeys associated with the old domain become invalid. Configure a [custom domain](https://auth0.com/docs/customize/custom-domains) for your tenant prior to enabling passkeys to avoid any interruptions for end-users.\n    \n*   **Enable passkeys for a single database connection**: Enable passkeys for a maximum of one database connection.\n    \n*   **Consider limitations for Organization users:** Users cannot use passkeys when creating an account through an [Organization invitation email](https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members). To allow these users to create passkeys, use an alternate method of user creation or ensure [progressive enrollment](#progressive-enrollment) is enabled.\n    \n\n## Enable passkeys as an authentication method\n\nYou can enable passkeys as an authentication method for your database connection in the Auth0 Dashboard:\n\n1.  Go to [Authentication > Database](https://manage.auth0.com/#/connections/database).\n    \n2.  Select a connection.\n    \n3.  Switch to the **Authentication Methods** view.\n    \n4.  Enable the toggle on the **Passkey** card.\n    \n    ![](https://images.ctfassets.net/cdy7uua7fh8z/2mSuzaVEsxVPD6WnGtfWjk/6979022362947098bc667e22ef0721b3/Dashboard_-_Authentication_Methods.png)\n\n## Configure your policy\n\nYou can configure the passkey policy for your database connection in the Auth0 Dashboard:\n\n1.  Go to [Authentication > Database](https://manage.auth0.com/#/connections/database).\n    \n2.  Select a connection.\n    \n3.  Switch to the **Authentication Methods** view.\n    \n4.  Select **Configure** on the **Passkey** card.\n    \n\n### Passkey Challenge\n\nThis setting determines how users can trigger passkey authentication during login and signup.\n\n| **Passkey authentication UI** | **Description** |\n| --- | --- |\n| Autofill | Users must log in with their browser’s autofill feature to leverage passkeys. Autofill allows users to select a saved account from a dropdown menu when engaging with the login prompt. With autofill, users do not need to manually enter their credentials. |\n| Passkey button | Users must select the **Continue with a passkey** button on the login prompt. |\n| Both | Users can trigger passkey authentication using autofill or by selecting the **Continue with a passkey** button on the login prompt. |\n\n![](https://images.ctfassets.net/cdy7uua7fh8z/Q8xHHuKUvs4BMAJOKvq6M/9b21eedf85e43080cdbe673c97ffc378/login-passkey_default.png)\n\n### Progressive Enrollment\n\nEnabled by default, progressive enrollment prompts users to create a passkey (if they have not done so already) after logging in with their email and password. This step is not required and users can choose to delay this action every 30 days.\n\nProgressive enrollment is useful when migrating users to a new passkey flow as it offers a more seamless transition between authentication methods.\n\nWhen a user creates their passkey, it is added to their account as an authentication method. Their standard email or username and password remain valid and can be used to log in as needed. Passkeys do not replace or invalidate users’ standard credentials.\n\n### Local Enrollment\n\nEnabled by default, local enrollment prompts existing users to create a local passkey when using a cross-device passkey to log in to a new device.\n\nFor example, existing passkey users can use a QR code to log in to a new device that is within physical proximity of a previously-enrolled device. If local enrollment is enabled in this scenario, the user is prompted to create a local passkey on the new device after they log in with the QR code. If desired, users can choose to skip this action.",
    "title": "Configure Passkey Policy",
    "description": "Learn how to enable passkeys as an authentication method and configure your passkey policy.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page",
    "markdown": "# Customize Classic Password Reset Page\n\n#### Resetting a password?\n\nThis page describes how you can customize a Classic Login password reset page.\n\nIf you need assistance resetting a password, review the following documentation instead:\n\n*   For tenant administrators resetting other users' passwords: [Change Users' Passwords](https://auth0.com/docs/authenticate/database-connections/password-change)\n    \n*   For individuals resetting their own passwords: [Reset Auth0 Account Password](https://auth0.com/docs/troubleshoot/customer-support/reset-account-passwords)\n    \n\nIf you are using Classic Login, the password reset page provides your users with a way to change their passwords if they cannot log in. Within the password reset page, Auth0 handles all required functionality, including:\n\n*   Hosting the page itself\n    \n*   Redirecting the user wanting to reset their password as necessary\n    \n*   Ensuring the user's password meets your defined requirements\n    \n*   Automatically redirecting the user after they reset their password\n    \n\nTo create a consistently branded experience throughout the login flow, you can customize how the password reset prompt displays to users. You can also update the password reset page to display certain personal information if appropriate.\n\n## Enable password reset page customization\n\nThe password reset page is enabled for all Auth0 users by default and does not require customization. However, you can enable [advanced customization](https://auth0.com/docs/customize/login-pages/classic-login/customization-classic) if you wish to update the branding and other elements of the password reset page.\n\nTo enable advanced customization from the Auth0 Dashboard:\n\n1.  Navigate to [Branding > Universal Login > Password Reset tab](https://manage.auth0.com/#/password_reset).\n    \n2.  Enable the **Customize Password Reset Page** toggle.\n    \n\nIn the code editor below the toggle, you can now directly modify the page template.\n\n![Branding Universal Login Password Reset Tab Customize Password Reset Page Toggle](https://images.ctfassets.net/cdy7uua7fh8z/5gwXwgXNWtiKZJlg3LX3nn/0decad4895539437dbe4ecabe55dcdde/dashboard-branding-universal-login-password-reset.png)\n\n## Edit password reset page\n\nAfter enabling customization for the password reset page, you can use the built-in code editor to modify its HTML, style the page using CSS, and change the JavaScript used to retrieve and display custom variables. Ensure you select **Save Changes** below the code editor to save your updates.\n\n### Display custom information on the Password Reset Page\n\nYou can display personalized information on the password reset page. This is done by editing the embedded JavaScript using the password reset page editor:\n\n```\nnew Auth0ChangePassword({\n      container:         \"change-password-widget-container\",     // required\n      email:             \"{{email}}\",                            // DO NOT CHANGE THIS\n      csrf_token:        '{{csrf_token}}',                       // DO NOT CHANGE THIS\n      ticket:            '{{ticket}}',                           // DO NOT CHANGE THIS\n      password_policy:   '{{password_policy}}',                  // DO NOT CHANGE THIS\n      theme: {\n        icon: \"{{tenant.picture_url | default: '//cdn.auth0.com/styleguide/1.0.0/img/badge.png'}}\",\n        primaryColor: \"#ea5323\"\n      },\n      dict: {\n        // passwordPlaceholder: \"your new password\",\n        // passwordConfirmationPlaceholder: \"confirm your new password\",\n        // passwordConfirmationMatchError: \"Please ensure the password and the confirmation are the same.\",\n        // passwordStrength: {\n        //   containsAtLeast: \"Contain at least %d of the following %d types of characters:\",\n        //   identicalChars: \"No more than %d identical characters in a row (such as, \\\"%s\\\" not allowed)\",\n        //   nonEmpty: \"Non-empty password required\",\n        //   numbers: \"Numbers (such as 0-9)\",\n        //   lengthAtLeast: \"At least %d characters in length\",\n        //   lowerCase: \"Lower case letters (a-z)\",\n        //   shouldContain: \"Should contain:\",\n        //   specialCharacters: \"Special characters (such as !@#$%^&*)\",\n        //   upperCase: \"Upper case letters (A-Z)\"\n        // },\n        // successMessage: \"Your password has been reset successfully.\",\n        // configurationError: \"An error occurred. There appears to be a misconfiguration in the form.\",\n        // networkError: \"The server cannot be reached, there is a problem with the network.\",\n        // timeoutError: \"The server cannot be reached, please try again.\",\n        // serverError: \"There was an error processing the password reset.\",\n        // headerText: \"Enter a new password for<br />{email}\",\n        // title: \"Change Password\",\n        // weakPasswordError: \"Password is too weak.\"\n        // passwordHistoryError: \"Password has previously been used.\"\n      }\n    });\n```\n\nFor example, the sample template snippet below shows the variable `tenant.picture_url`. This variable returns the Logo URL value defined in [Dashboard > Settings](https://manage.auth0.com/#/tenant).\n\n```\nnew Auth0ChangePassword({\n      theme: {\n        icon: \"{{tenant.picture_url | default: '//cdn.auth0.com/styleguide/1.0.0/img/badge.png'}}\",\n      }\n    });\n```\n\nAuth0 retrieves the logo at the URL and displays it on the password reset prompt. If Auth0 can't resolve the URL, it'll display the default image.\n\n#### Custom variables\n\nYou can use the following custom variables to display personalized information on the password reset page:\n\n| Variable | Description |\n| --- | --- |\n| `email` | The email address of the user requesting the password change |\n| `ticket` | The ticket representing the given password reset request |\n| `csrf_token` | Token used to prevent CSRF activity |\n| `tenant.name` | The name associated with your Auth0 tenant |\n| `tenant.friendly_name` | The name displayed for your Auth0 tenant |\n| `tenant.picture_url` | The URL leading to the logo representing you in Auth0 |\n| `tenant.support_email` | The support email address for your company displayed to your Auth0 users |\n| `tenant.support_url` | The support URL for your company displayed to your Auth0 users |\n| `lang` | The user's language |\n| `password_policy` | The active connection's security policy. You can see what this is using `https://manage.auth0.com/#/connections/database/con_YOUR-CONNECTION-ID/security`. Be sure to provide your connection ID in the URL.) |\n| `password_complexity_options` | Object containing settings for the password complexity requirements |\n| `min_length` | The minimum length required for newly-created passwords. Can range from 1 to 128 characters in length |\n\n**Notes:**\n\n*   You can set/check the values for your tenant variables in the Settings area in [Dashboard > Settings](https://manage.auth0.com/#/tenant).\n    \n*   You cannot make customizations conditional based on the Application ID (`client_id`).\n    \n\n#### Custom error messages\n\nIf your custom database script returns a custom error, you can map an error description using the `dict` property:\n\n```\nnew Auth0ChangePassword({\n  // ...other options\n  dict: {\n    yourCustomError: 'This is a custom error message'\n  }\n});\n\nfunction changePassword(email, newPassword, callback) {\n  callback(new ValidationError('yourCustomError'));\n}\n```\n\n## Update password reset prompt\n\nIf you do not enable customization for the password reset page, Auth0 will handle updates necessary for the script, including changes to the version number of the included password reset prompt.\n\n**When you enable customization for the password reset page**, you assume responsibility for updating and maintaining the script. This includes updating the version number for the password reset prompt. With customization enabled, Auth0 cannot update your script automatically without potentially interfering with the changes you've made.\n\nThe current version of the password reset prompt is 1.5.5. Use this link to call the latest version, including future minor version updates:\n\n`https://cdn.auth0.com/js/change-password-1.5.min.js`\n\n## Revert changes\n\nTo revert the password reset page to an earlier design, you can:\n\n*   Revert to the last saved template by clicking **Reset to Last.**\n    \n*   Revert to the default template provided by Auth0 by clicking **Reset to Default**.\n    \n\n## Learn more\n\n*   [Customize Classic Login Pages](https://auth0.com/docs/customize/login-pages/classic-login/customization-classic)\n*   [Customize MFA for Classic Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-classic-login)\n*   [Check Error Messages](https://auth0.com/docs/troubleshoot/basic-issues/check-error-messages)\n*   [Self Change Password Errors](https://auth0.com/docs/troubleshoot/authentication-issues/self-change-password-errors)",
    "title": "Customize Classic Password Reset Page",
    "description": "Learn how to customize a Classic Login password reset page.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow",
    "markdown": "# Login Flow\n\nThe Login Flow runs when a user logs in to any application in an Auth0 tenant.\n\n![Diagram showing the Actions Login Flow.](https://images.ctfassets.net/cdy7uua7fh8z/2SkfIOm4fFOJ8N0GNJwam8/6615558d16d5827b985434f497b42b8d/Login_Flow__1_.png)\n\nActions in this flow are blocking (synchronous), which means they execute as part of a trigger's process and will prevent the rest of the Auth0 pipeline from running until the Action is complete.\n\n## Triggers\n\n### Login / Post Login\n\nThe `post-login` trigger is a function executed after a user logs in and when a Refresh Token is requested.\n\n#### References\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/event-object): Provides contextual information about a single user logging in via Auth0.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/api-object): Provides methods for changing the behavior of the flow.\n    \n\n## Common use cases\n\n### Access control\n\nA post-login Action can be used to provide custom logic used to deny access to a user who is attempting to access an application:\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.user.email && event.user.email.endsWith(\"@example.com\") && event.client.name === \"My SPA\") {\n    api.access.deny(`Access to ${event.client.name} is not allowed.`);\n  }\n};\n```\n\n### Allow access only on weekdays for a specific application\n\nLet's say you have an application that you want to make sure is only accessible during weekdays. To do this, you would create the following Action:\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\n exports.onExecutePostLogin = async (event, api) => {\n  if (event.client.name === \"APP_NAME\") {\n    const d = new Date().getDay();\n\n    if (d === 0 || d === 6) {\n      api.access.deny(\"This app is only available during the week.\");\n    }\n  }\n}\n```\n\n### Deny access to anyone calling an API\n\nLet's say you want to deny access to all users who are calling an API. This means that you need to deny access depending on the audience value for your API, which you can find in the **API Audience** field of your API in [Dashboard > Applications > APIs](https://manage.auth0.com/#/apis). To do this, you would create the following Action:\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\n exports.onExecutePostLogin = async (event, api) => {\n  // In Actions, an API will be referred to as a Resource Server.\n  if (event.resource_server && event.resource_server.identifier === \"http://todoapi2.api\") {\n    api.access.deny(\"end_users_not_allowed\");\n  }\n}\n```\n\n### Add user roles to ID and Access tokens\n\nTo add user roles to Auth0-issued tokens, use the `event.authorization` object along with the `api.idToken.setCustomClaim` and `api.accessToken.setCustomClaim` methods:\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  const namespace = 'https://my-app.example.com';\n  if (event.authorization) {\n    api.idToken.setCustomClaim(`${namespace}/roles`, event.authorization.roles);\n    api.accessToken.setCustomClaim(`${namespace}/roles`, event.authorization.roles);\n  }\n}\n```\n\n*   A custom claim cannot include certain terms, and we strongly recommend using namespaced claim that takes the form of a URI. See [our documentation on custom claims](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims) for more information.\n    \n*   The JWT returned to the requesting application is built and signed at the end of the trigger processing. The final, signed JWT is not accessible in an Action.\n    \n\n### Enrich the user profile\n\nAuth0 provides a system for storing metadata on a [User Profile](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles). In order to set `user_metadata` or `app_metadata` on a user’s profile during their login, use the `api.user.setUserMetadata` or `api.user.setAppMetadata` functions.\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  api.user.setUserMetadata(\"favorite_color\", \"blue\");\n};\n```\n\nOnce all post-login actions have been executed, Actions will update the user profile in a single operation. This operation is subject to the \"Write Users\" [rate limit](https://auth0.com/docs/support/policies/rate-limit-policy/management-api-endpoint-rate-limits).\n\n### Enforce custom MFA policy\n\nA post-login Action can be used to dynamically require MFA for a user according to your application’s needs.\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  // Require MFA for anyone logging in from North America.\n  if (event.request.geoip.continentCode === \"NA\") {\n    api.multifactor.enable(\"any\");\n  };\n};\n```\n\nAn MFA Provider must be configured in order to enable MFA during a login. To learn more, read [Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication).\n\n### Reduce friction with passkeys\n\nA post-login Action can be used to reduce the friction by dynamically skipping MFA for a user that has authenticated with a passkey.\n\n```\n/**\n* Handler that will be called during the execution of a PostLogin flow.\n*\n* @param {Event} event - Details about the user and the context in which they are logging in.\n* @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n*/\nexports.onExecutePostLogin = async (event, api) => {\n // Check if a passkey was used to authenticate\n const skipMFA = event.authentication?.methods.some(\n   (method) => method.name === \"passkey\"\n );\n\n // If a passkey was used skip MFA\n if (skipMFA) {\n   api.multifactor.enable(\"none\");\n }\n};\n```\n\nThe connection must have passkeys and MFA enabled. To learn more, read [Passkeys](https://auth0.com/docs/authenticate/database-connections/passkeys) and [Multi-Factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication).\n\n### Redirect the user to an external site\n\nSimilar to [Redirect Rules](https://auth0.com/docs/customize/rules/redirect-users), a post-login Action can be used to send the user to an external site. When completed, the user can be redirected back to Auth0 to continue their login flow. In the example below, a Redirect Action is used to prompt the user to provide their favorite color.\n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  // Skip the redirect if the user has already chosen a favorite color.\n  if (event.user.user_metadata.favorite_color) {\n    return;\n  }\n\n  const token = api.redirect.encodeToken({\n    secret: event.secrets.MY_SHARED_SECRET,\n    payload: {\n      email: event.user.email,\n    },\n  });\n\n  // Send the user to https://my-app.example.com along\n  // with a `session_token` query string param.\n  api.redirect.sendUserTo(\"https://my-app.example.com\", { \n    query: { session_token: token }\n  });\n};\n\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onContinuePostLogin = async (event, api) => {\n  // Once the /continue endpoint has been called, unpack the signed token\n  // and store the favorite color as user metadata.\n\n  const payload = api.redirect.validateToken({\n    secret: event.secrets.MY_SHARED_SECRET,\n  });\n\n  api.user.setUserMetadata(\"favorite_color\", payload.favorite_color);\n};\n```\n\nThe Actions pipeline will be suspended while the user is redirected. Once the user continues their Auth0 login process, the Actions pipeline will resume where it was suspended. Actions that were executed prior to the Redirect will not be executed again.\n\nTo learn more about Redirect Actions, read [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions).\n\n### Modify scopes on an access token\n\nWhen modifying the scopes associated with an access token, ensure you adhere to the best practices surrounding audience specification.\n\n*   Always check for expected audience before adding scopes.\n    \n*   Prevent using untrusted input when adding scopes.\n    \n\n```\n/**\n * @param {Event} event - Details about the user and the context in which they are logging in.\n * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.\n */\nexports.onExecutePostLogin = async (event, api) => {\n  if (event.request.query.audience === 'https://example.com/api') {\n    api.accessToken.addScope(\"read:xyz\");\n  }\n};\n```\n\n## Learn more\n\n*   [Manage User Metadata with the post-login Action Trigger](https://auth0.com/docs/manage-users/user-accounts/metadata/manage-user-metadata)\n*   [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions)\n*   [Understand How Metadata Works in User Profiles](https://auth0.com/docs/manage-users/user-accounts/metadata)",
    "title": "Login Flow",
    "description": "Learn about the Actions Login Flow and the post-login Action trigger, which is executed after a user logs in and when a Refresh Token is requested.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset",
    "markdown": "# Password Reset Flow\n\nThe Password Reset Flow runs during the password reset process when a user completes the first challenge, typically a link to the [user's email](https://auth0.com/docs/secure/multi-factor-authentication/authenticate-using-ropg-flow-with-mfa/enroll-and-challenge-email-authenticators), but before a new password is set. You can use this flow to challenge a user with an additional multi-factor authentication (MFA) factor or to redirect the user to an external site, such as a third-party verifier.\n\nAfter verification, users can provide the new password for their account.\n\n![To use the Password Reset Flow, navigate to Dashboard > Actions > Flows ](https://images.ctfassets.net/cdy7uua7fh8z/1Pugm9fFYCmdhh7QO5Klzm/7f7eefbf810fd4ebeb22d6393151ffa2/2023-08-14_15-54-03.png)\n\nActions in this flow are blocking (synchronous), which means they execute as part of a trigger's process and will prevent the rest of the Auth0 pipeline from running until the Action is complete.\n\n## Triggers\n\n### PostChallenge\n\nThe `post-challenge` trigger is a function that executes after a user completes the first password reset challenge, typically an email magic link. You can create up to four Actions in your tenant that leverage the `post-challenge` trigger.\n\n#### References\n\n*   [Event object](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset/event-object): Provides contextual information about a single user logging in via Auth0.\n    \n*   [API object](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset/api-object): Provides methods for changing the behavior of the flow.\n    \n\n## Limitations\n\nThe Password Reset Flow does not support [Active Directory/LDAP connections](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/active-directory-ldap).\n\n## Common use cases\n\n### Secure password reset with additional MFA factors\n\nA `password-reset` / `post-challenge` Actions can issue an MFA challenge after the user completes the first challenge. For example, you can issue a WebAuthn-based challenge as a secondary factor if your tenant has WebAuthN enabled as a factor.\n\n```\n/**@type {PasswordResetPostChallengeAction}**/\nmodule.exports.onExecutePostChallenge = async (event, api) => {\n  const enrolledFactors = event.user.enrolledFactors.map((x) => ({\n    type: x.type\n  }));\n  api.authentication.challengeWith({ type: 'webauthn-roaming' }, { additionalFactors: enrolledFactors });\n};\n```\n\n### Redirect users to a third-party application\n\nIn addition to an MFA challenge, you can also try adding a redirect in the custom Action, for example, to a third-party verifier or risk assessor.\n\n```\n/** @type {PasswordResetPostChallengeAction}\n * This sample action redirects the user to an example app\n * and then continues the action after the redirect to challenge\n * the user with an MFA factor\n */\n\nmodule.exports.onExecutePostChallenge = async (event, api) => {\n  // Send the user to https://my-app.example.com\n  api.redirect.sendUserTo('https://my-app.example.com');\n};\n\nmodule.exports.onContinuePostChallenge = async (event, api) => {\n  const enrolledFactors = event.user.enrolledFactors.map((x) => ({\n    type: x.type\n  }));\n\n  // Challenge the user with email otp OR another enrolled factor\n  api.authentication.challengeWith({ type: 'email' }, { additionalFactors: enrolledFactors });\n\n  // Example of how to challenge the user with multiple options\n  // in this case email otp OR sms otp\n  // api.authentication.challengeWithAny([{ type: 'email' }, { type: 'sms' }]);\n};\n```\n\nThe Actions pipeline is not active while Auth0 redirects the user. Once the user continues the Auth0 login process, the Actions pipeline resumes. Actions that were executed prior to the redirect are not executed again. To learn more, review [Redirect with Actions](https://auth0.com/docs/customize/actions/flows-and-triggers/login-flow/redirect-with-actions).",
    "title": "Password Reset Flow",
    "description": "Learn about the Actions Password Reset Flow, which is executed after a user completes the first challenge but before the user sets a password.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience",
    "markdown": "# Universal Login Experience\n\n[Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) provides the essential feature of an authorization server: the login flow. When a user needs to prove their identity to gain access to your application, you can redirect them to Universal Login and let Auth0 handle the authentication process.\n\nThe Universal Login experience offers a streamlined implementation with easy-to-use customization tools. For advanced customization, you can also create page templates that allow you to modify the code of your login pages. This experience also supports a variety of features, such as [localization](https://auth0.com/docs/customize/internationalization-and-localization/universal-login-internationalization), [WebAuthn](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn), [multi-factor authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication), [Auth0 Organizations](https://auth0.com/docs/manage-users/organizations/organizations-overview), and more.\n\nConfiguring Universal Login is dynamic and does not require any application-level changes, as web pages hosted on Auth0’s centralized authentication server drive the login flow. Additionally, you won’t need to manually update your code for your applications to benefit from improvements Auth0 makes to Universal Login.\n\n## Universal Login features and functionality\n\nThe following sections provide additional details about the Universal Login experience. For a feature comparison between Universal Login and Classic Login, review [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login).\n\n### Customization\n\n*   You can specify a Liquid Template for all pages in the login flow with [Page Templates](https://auth0.com/docs/customize/login-pages/universal-login/customize-templates).\n    \n*   You can customize page branding, including colors, fonts, custom logo URLs, and more, with the [no-code editor](https://auth0.com/docs/customize/login-pages/universal-login/customize-themes) in the Auth0 Dashboard, or with the Management API [Branding](https://auth0.com/docs/api/management/v2#!/Branding/patch_branding) endpoints.\n    \n*   You can configure the favicon URL with the Auth0 Management API [Branding](https://auth0.com/docs/api/management/v2#!/Branding/patch_branding) endpoints.\n    \n*   You can customize page text with either the Auth0 Dashboard or the Management API. To learn more, review [Customize Universal Login Text Elements](https://auth0.com/docs/customize/login-pages/universal-login/customize-text-elements).\n    \n*   You can customize signup and login prompts with the Auth0 Management API. To learn more, review [Customize Signup and Login prompts](https://auth0.com/docs/customize/login-pages/universal-login/customize-signup-and-login-prompts).\n    \n\n### Login\n\n*   You can use [Passwordless with WebAuthn with Device Biometrics](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics).\n    \n*   If you are using [development keys](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/devkeys) for social providers:\n    \n    *   Single Sign-on (SSO) and Silent Authentication will work properly. This is not supported in the Classic Login experience.\n        \n    *   Users receive a warning on the login page stating the tenant is configured with development keys.\n        \n*   A button is rendered for each social and enterprise connection.\n    \n*   If you redirect users to the `/login` page directly, they will receive an error unless you configured a default login route. To learn more, review [Configure Default Login Routes](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes). You should always redirect users to the proper authorization request endpoint (e.g., `/authorize` if you are using OpenID Connect).\n    \n*   You can specify the `login_hint` when redirecting to Auth0 and use this information to populate the username/email field for the login or signup page.\n    \n*   Passkeys are available as an authentication method for [database connections](https://auth0.com/docs/authenticate/database-connections). Passkeys are a phishing-resistant alternative to traditional authentication factors (such as username/password) that offer an easier and more secure login experience to users. To learn more, review [Passkeys](https://auth0.com/docs/authenticate/database-connections/passkeys).\n    \n\n### Signup\n\n*   You can have users land directly on the signup page instead of the login page by specifying the `screen_hint=signup` parameter when redirecting to `/authorize`. You can combine this paramter with `prompt=login` to indicate whether you want to always show the authentication page or skip the page if an existing session exists.\n    \n\n| `/authorize` parameters | No existing session | Existing session |\n| --- | --- | --- |\n| no extra parameters | Shows the login page | Redirects to the callback url |\n| `screen_hint=signup` | Shows the signup page | Redirects to the callback url |\n| `prompt=login` | Shows the login page | Shows the login page |\n| `prompt=login&screen_hint=signup` | Shows the signup page | Shows the signup page |\n\n### Multi-factor authentication\n\n*   If users have more than one MFA factor enrolled (e.g., SMS and push notifications), the Universal Login MFA page lets the user choose their preferred option.\n    \n*   You can use voice or email as an MFA factor. To learn more, review [Configure SMS and Voice Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa) and [MFA Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors).\n    \n*   If you are using the Guardian SDK to create your own native application to handle Push Notifications, you can configure the name of the application and the URLs to download them in the **Push via Auth0 Guardian** option in the [Dashboard > Security > Multi-Factor Auth](https://manage.auth0.com/#/mfa) section.\n    \n*   If you have a rule that sets the MFA provider to `google-authenticator`, you must enable that OTP factor in the [Dashboard > Security > Multi-Factor Auth](https://manage.auth0.com/#/mfa) section.\n    \n*   You can use [WebAuthn](https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn) for MFA.\n    \n*   Using [Actions](https://auth0.com/docs/customize/actions), you customize your MFA flows to challenge users with a specific factor or series of factors. You can also leverage user metadata, such as roles or Organization memberships, to create more individualized experiences. To learn more, review [Customize MFA Selection in Universal Login](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa/customize-mfa-selection-universal-login).\n    \n\n## Password reset\n\n*   The Universal Login experience redirects users to the default login route when it succeeds and handles the error cases as part of the Universal Login flow. The Redirect URL in the email template will be ignored. Note that you must provide an **Application Login URI** in the [Dashboard > Applications > Applications](https://auth0.com/docs/get-started/applications/application-settings) **Settings** tab for the redirect URLs to work.\n    \n*   If the database connection is set to **Require Username**, the password reset flow prompts the user for their username and sends a password reset email to the associated email address. To learn more, review [Adding Username for Database Connections](https://auth0.com/docs/authenticate/database-connections/require-username).\n    \n*   Using [Actions](https://auth0.com/docs/customize/actions), you can incorporate a secondary challenge into your [password reset flows](https://auth0.com/docs/customize/actions/flows-and-triggers/password-reset). Specifically, the `post-challenge` trigger allows you to present an additional challenge to users after they complete their first step (typically a link in a password reset email) but before they create their new password. Using this trigger, you can redirect users to an external site, such as a third-party verifier, or challenge them with an additional MFA factor. Users must complete this second challenge in order to update their password.\n    \n    *   **Note**: You can customize the MFA prompts displayed to users during the password reset flow. To learn more, review [Customize Universal Login Text Prompts.](https://auth0.com/docs/customize/login-pages/universal-login/customize-text-elements)\n        \n\n## Custom database connections\n\nWhen using custom database connections:\n\n*   The password reset flow will function properly even if you return errors from the change password script.\n    \n*   The errors returned in `ValidationErrors` or `WrongUsernameOrPasswordError` will be displayed on the corresponding pages. To learn more, review [Troubleshoot Custom Databases](https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling).\n    \n\n## Email verification\n\nAfter a user clicks the email verification link, they'll be redirected to a page that will confirm that their email is verified. If the default login route is configured, users will be able to click a button and get redirected to it.\n\n## Password autocomplete\n\nUniversal Login pages use the [autocomplete attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) for password fields.\n\nOn the signup and password reset pages, `autocomplete` is set to `\"new-password\"`. This signals the password manager to prompt the user to generate a secure, random password. The user has to provide explicit consent to save the password in the password manager.\n\nOn the login page `autocomplete` is set to `\"current-password\"`. The login page automatically fills in the password if it's available in the browser's password manager.\n\nNote that turning off password autocompletion does not increase security:\n\n*   Users need to opt-in for saving the password in the browser’s password manager\n    \n*   Once it’s saved in the password manager, any user with access to the computer can go into the password manager and get the password whether the password is auto-filled on the login screen or not. If users are logged-in to the browser then they are prompted for their password before viewing saved passwords. If not, everyone can see them.\n    \n*   In the case of Safari, users are asked to enter their Mac password or use Touch ID before the password is completed.\n    \n\n## Implement Universal Login\n\nTo learn how to set up your application to use Universal Login, read our [Quickstarts](https://auth0.com/docs/quickstarts). Choose the approach that best fits your technologies, and the Quickstarts walk you through the implementation.\n\n## Learn more\n\n*   [Configure Default Login Routes](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes)\n*   [Configure SMS and Voice Notifications for MFA](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors/configure-sms-voice-notifications-mfa)\n*   [Multi-Factor Authentication Factors](https://auth0.com/docs/secure/multi-factor-authentication/multi-factor-authentication-factors)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Check Login and Logout Issues](https://auth0.com/docs/troubleshoot/authentication-issues/check-login-and-logout-issues)\n*   [Troubleshoot Multi-Factor Authentication Issues](https://auth0.com/docs/troubleshoot/authentication-issues/troubleshoot-mfa-issues)",
    "title": "Universal Login Experience",
    "description": "An overview of the Universal Login experience",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/api/management/v2/connections/patch-connections-by-id",
    "markdown": "Auth0 Management API v2",
    "title": "Auth0 Management API v2",
    "description": null,
    "languageCode": "en"
  },
  {
    "url": "https://auth0.com/docs/secure/attack-protection/brute-force-protection",
    "markdown": "# Brute-Force Protection\n\nBrute-force protection safeguards against a single IP address attacking a single user account. When a given IP address tries and fails multiple times to log in as the same user, brute-force protection:\n\n*   Blocks the suspicious IP address from logging in as that user.\n    \n*   Sends a [notification](#notifications) to the affected user.\n    \n\nIf an IP address is blocked due to brute-force protection, it remains blocked until one of these events occurs:\n\n*   An administrator [removes the block](https://auth0.com/docs/api/management/v2/#!/User_Blocks/get_user_blocks).\n    \n*   An administrator raises the **Brute Force Threshold** described below.\n    \n*   Thirty (30) days pass from the last failed login attempt.\n    \n*   The affected user selects the unblock link in the email notification (if configured).\n    \n*   The affected user changes their password (on all linked accounts).\n    \n\n## Configure brute-force protection\n\nAuth0 strongly recommends that you do not disable brute-force protection for the connection. If you disable it, you can enable it again using the Dashboard.\n\n1.  Go to [Dashboard > Security > Attack Protection](https://manage.auth0.com/#/security/attack-protection) and select **Brute-force Protection**. Enable the toggle at the top of the page if it is disabled.\n    \n    ![Dashboard Security Attack Protection Brute-force Protection](https://images.ctfassets.net/cdy7uua7fh8z/sEIc4abtu9NxcZsohSzxG/95499d90c7af136bf605003e33b9250e/Auth0_Dashboard_-_Brute-force_Protection.png)\n2.  In the **Detection** section:\n    \n    1.  Under **Brute Force Threshold**, select **Default** to use the standard limit of 10 maximum attempts, or select **Custom** to set the limit of maximum attempts to a value between 1 and 100.\n        \n    2.  Under **Manage IP Addresses**, enter the list of trusted IP addresses in the **IP AllowList** field. Brute-force protection will not be enforced for login attempts originating from these IP addresses.\n        \n3.  In the **Response** section:\n    \n    1.  Under **Block Settings**, enable the **Block Brute-force Logins** toggle to block attempts from suspicious IP addresses to safeguard against brute-force attacks that occur from a single IP address and target a single user account.\n        \n    2.  Under **Block Settings**, enable **Account Lockout** to trigger blocks irrespective of IP address. When this setting is enabled and a user consecutively attempts and fails to login, future attempts to log in from that user from any IP address will be blocked. You can adjust maximum attempts under **Brute Force Threshold**. By default, the Account Lockout toggle is disabled.\n        \n    3.  Under **Notifications**, enable the **Send notifications to the affected users** toggle to send an email notification to the user when their account has been blocked.\n        \n4.  Click **Save**.\n    \n\n## Notifications\n\nIf **Send notifications to the affected users** is enabled, Auth0 sends an SMS or email notification to a user when their account has been blocked.\n\n### SMS\n\nAuth0 sends an SMS to the user if they use a phone identifier in the login flow. SMS notifications are limited at a maximum of 1 per hour per identifier.\n\n### Email\n\nAuth0 sends an email to the user if they use a non-phone identifier in the login flow. Email notifications are limited at a maximum of 1 per hour per unique IP address.\n\nBy default, email notifications contain a link that allows the user to unblock their account. To learn more, read [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails).\n\n## Special use cases\n\nBecause brute-force protection depends on the IP address of the user, the following use cases require additional configuration:\n\n*   **ROPG on the backend**: Using this call does not get the IP address of the user; however, to make brute-force protection work correctly, you can configure your application and [send the IP address of the user as part of the request](https://auth0.com/docs/authorization/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection#configure-your-application-to-trust-the-ip-address).\n    \n*   **User authentication from the same IP address:** Users who are behind a proxy are more likely to reach set limits and trigger brute-force protection.\n    \n\nTo learn more, read [Avoid Common Issues with Resource Owner Password Flow and Attack Protection](https://auth0.com/docs/get-started/authentication-and-authorization-flow/resource-owner-password-flow/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection).\n\n## Learn more\n\n*   [Flexible Identifiers and Attributes](https://auth0.com/docs/authenticate/database-connections/flexible-identifiers-and-attributes)\n*   [Activate and Configure Attributes for Flexible Identifiers](https://auth0.com/docs/authenticate/database-connections/activate-and-configure-attributes-for-flexible-identifiers)\n*   [Customize Blocked Account Emails](https://auth0.com/docs/customize/email/customize-blocked-account-emails)\n*   [View Attack Protection Log Events](https://auth0.com/docs/secure/attack-protection/view-attack-protection-events)\n*   [User/Password Authentication Rate Limits](https://auth0.com/docs/support/policies/rate-limit-policy/database-connections-rate-limits)",
    "title": "Brute-Force Protection",
    "description": "Learn how to brute-force protection works in Auth0 and how to configure responses. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first",
    "markdown": "# Configure Identifier First Authentication\n\nIdentifier First login flows prompt users for their identifier and authentication method in two separate steps. For example, when you authenticate to Google websites, you enter your email first, click next, and then enter your password.\n\n## How it works\n\nThis two-step approach lets you customize a user's experience depending on the identifier they entered:\n\n*   When a user enters a corporate email (for example, `user@acme.com`), you can redirect them to acme.com’s corporate login page.\n    \n*   If a user enters an email for a personal account, you can prompt them for their password.\n    \n*   If the user's device is enrolled with WebAuthn w/Device Biometrics, they can use their device's biometric authenticators instead of a password.\n    \n\n![Auth0 Universal Login Identifier First authentication flow diagram](https://images.ctfassets.net/cdy7uua7fh8z/31S2oC0o2NRiV2RsVE3yIw/5bac735d6a53792875d4793a26ae8931/HRD_Docs.png)\n\n## Configure Identifier First\n\n1.  Go to [Dashboard > Authentication > Authentication Profile](https://manage.auth0.com/#/authentication-profiles).\n    \n2.  Pick the flow you want to use:\n    \n    *   Identifier + Password: Users will enter their identifier and password on the same screen.\n        \n    *   Identifier First: Users will enter their identifier on the first screen. If the identifier matches the Identity Provider domain of the enterprise connection, users will be redirected to the enterprise connection's login page. If not, they will enter their password.\n        \n    *   Identifier First + Biometrics: The same as above, but if users are logging in from a device that supports WebAuthn w/Device Biometrics, they will be prompted to enroll that device, and they can use it in subsequent logins. You can learn more about this feature [here](https://auth0.com/docs/authenticate/login/auth0-universal-login/passwordless-login/webauthn-device-biometrics)\n        \n\n## Define Home Realm Discovery identity providers\n\nWhen a user enters their email, Auth0 will check if the domain matches one from a registered Enterprise connection. If there's a match, Auth0 redirects the user to the enterprise identity provider’s login page. If the domain doesn't match, the user is prompted to enter their password. This is also known as Home Realm Discovery (HRD).\n\n1.  Go to [Dashboard > Authentication > Enterprise](https://manage.auth0.com/#/connections/enterprise).\n    \n2.  Select a connection.\n    \n3.  In the **Login Experience** tab set a maximum of 1000 domains. If you need more, please [contact support](https://support.auth0.com/).\n    \n4.  (Optional) Choose to display a button in the login page in addition to, or instead, of using the Identity Provider domains.\n    \n\n![Auth0 Authentication Enterprise Google Workspace Login Experience Tab Home Realm Discovery and Buttons](https://images.ctfassets.net/cdy7uua7fh8z/2urIgscBUaaMYHYFH1JJhX/cabd57d792abf01cb86df9cf509dd6a4/image.png)",
    "title": "Configure Identifier First Authentication",
    "description": "Learn how to configure Identifier First authentication with Universal Login.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers",
    "markdown": "# Configure Phone Messaging Providers\n\nAuth0 allows you to configure your own phone messaging provider to help you manage, monitor, and troubleshoot your SMS and voice communications. You can only configure one phone provider for all SMS and voice communications per tenant.\n\nAuth0 currently supports the following phone messaging providers:\n\n*   [Twilio](https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers/configure-twilio-as-a-phone-messaging-provider)\n    \n\n## Learn more\n\n*   [Configure Twilio as a Phone Messaging Provider](https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers/configure-twilio-as-a-phone-messaging-provider)",
    "title": "Configure Phone Messaging Providers",
    "description": "Learn how to configure phone messaging providers in the Auth0 Dashboard.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes",
    "markdown": "# Configure Default Login Routes\n\nIn certain cases (described below), Auth0 may need to redirect back to the application's Login Initiation endpoint, using OIDC third-party initiated login. To learn more, read [Initiating Login from a Third Party](https://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin) at the [OpenID Foundation](https://openid.net/).\n\nYou can configure these URIs with the Dashboard in [Application Settings](https://manage.auth0.com/#/applications/settings) or [Tenant Advanced Settings](https://manage.auth0.com/#/tenant/advanced) or with the Management API.\n\n*   [cURL](#0670cd400b5541eab60c976994e504f0_shell)\n*   [C#](#0670cd400b5541eab60c976994e504f0_csharp)\n*   [Go](#0670cd400b5541eab60c976994e504f0_go)\n*   [Java](#0670cd400b5541eab60c976994e504f0_java)\n*   [Node.JS](#0670cd400b5541eab60c976994e504f0_node)\n*   [Obj-C](#0670cd400b5541eab60c976994e504f0_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/clients/{yourClientId}' \\\n  --header 'authorization: Bearer API2_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{\"initiate_login_uri\": \"<login_url>\"}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/clients/{yourClientId}\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer API2_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{\\\"initiate_login_uri\\\": \\\"<login_url>\\\"}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/clients/{yourClientId}\"\n\n\tpayload := strings.NewReader(\"{\\\"initiate_login_uri\\\": \\\"<login_url>\\\"}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer API2_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/clients/{yourClientId}\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer API2_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{\\\"initiate_login_uri\\\": \\\"<login_url>\\\"}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/clients/{yourClientId}',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer API2_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {initiate_login_uri: '<login_url>'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer API2_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"initiate_login_uri\": @\"<login_url>\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/clients/{yourClientId}\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/clients/{yourClientId}\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"initiate_login_uri\\\": \\\"<login_url>\\\"}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer API2_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"initiate_login_uri\\\": \\\"<login_url>\\\"}\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer API2_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/clients/{yourClientId}\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/clients/{yourClientId}\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer API2_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{\\\"initiate_login_uri\\\": \\\"<login_url>\\\"}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer API2_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"initiate_login_uri\": \"<login_url>\"] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/clients/{yourClientId}\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n* * *\n\nThe `login_url` should point to a route in the application that ends up redirecting to Auth0's `/authorize` endpoint, e.g. `https://mycompany.org/login`. Note that it requires `https` and it cannot point to `localhost`. `login_url` can include query parameters and a URI fragment.\n\nAs per the OIDC Third Party Initiated Login specification, the `iss` parameter containing Issuer Identifier will be added as a query string parameter to `login_url` before redirecting.\n\n## Redirect default login route scenarios\n\n### Users bookmark login page\n\nWhen an application initiates the login process, it navigates to `https://{yourDomain}/authorize` with a set of [required parameters](https://auth0.com/docs/api/authentication#login). Auth0 then redirects end-users to an `https://{yourDomain}/login` page, with a URL that looks like:\n\n`https://{yourDomain}/login?state=g6Fo2SBjNTRyanlVa3ZqeHN4d1htTnh&...`\n\nThe `state` parameter points to a record in an internal database where we track the status of the authorization transaction. Whenever the transaction completes, or after a set time passes, the record is deleted from the internal database.\n\nIf you are using Organizations and the end-user bookmarks the organization login prompt, Auth0 also includes the `organization` parameter when it redirects the user to the default login route.\n\nSometimes users bookmark the login page, and when they navigate to the bookmarked `/login` URL, the transaction record is no longer there and Auth0 cannot continue with the login flow. In that case, Auth0 will redirect to the default client URL if configured, or the tenant level URL if not. If no default login URL is set, Auth0 will render an error page.\n\n### Complete password reset flow\n\nAfter completing the password reset flow and the default URI for the application or tenant is configured, users will see a button that will let them navigate back to the login page.\n\nThis behavior only happens when you enable the Universal Login experience. With Classic Login, you need to configure the redirect URL in the Change Password template. To learn more, read [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n\nFor tenants using Universal Login, the [`/post-password-change`](https://auth0.com/docs/api/management/v2/#!/Tickets/post_password_change) endpoint supports redirecting users back to a specific application. When `client_id` is specified and the application's login URI is set, users will see a button sending them back to the application after completing a password reset.\n\n*   [cURL](#5937f03c89064ad5b2a5a0a03c04737e_shell)\n*   [C#](#5937f03c89064ad5b2a5a0a03c04737e_csharp)\n*   [Go](#5937f03c89064ad5b2a5a0a03c04737e_go)\n*   [Java](#5937f03c89064ad5b2a5a0a03c04737e_java)\n*   [Node.JS](#5937f03c89064ad5b2a5a0a03c04737e_node)\n*   [Obj-C](#5937f03c89064ad5b2a5a0a03c04737e_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/tickets/password-change' \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"user_id\": \"A_USER_ID\", \"client_id\": \"A_CLIENT_ID\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/tickets/password-change\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddParameter(\"application/json\", \"{ \\\"user_id\\\": \\\"A_USER_ID\\\", \\\"client_id\\\": \\\"A_CLIENT_ID\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/tickets/password-change\"\n\n\tpayload := strings.NewReader(\"{ \\\"user_id\\\": \\\"A_USER_ID\\\", \\\"client_id\\\": \\\"A_CLIENT_ID\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/tickets/password-change\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .body(\"{ \\\"user_id\\\": \\\"A_USER_ID\\\", \\\"client_id\\\": \\\"A_CLIENT_ID\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/tickets/password-change',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN'\n  },\n  data: {user_id: 'A_USER_ID', client_id: 'A_CLIENT_ID'}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\" };\nNSDictionary *parameters = @{ @\"user_id\": @\"A_USER_ID\",\n                              @\"client_id\": @\"A_CLIENT_ID\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/tickets/password-change\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/tickets/password-change\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"user_id\\\": \\\"A_USER_ID\\\", \\\"client_id\\\": \\\"A_CLIENT_ID\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"user_id\\\": \\\"A_USER_ID\\\", \\\"client_id\\\": \\\"A_CLIENT_ID\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/tickets/password-change\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/tickets/password-change\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest.body = \"{ \\\"user_id\\\": \\\"A_USER_ID\\\", \\\"client_id\\\": \\\"A_CLIENT_ID\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\"\n]\nlet parameters = [\n  \"user_id\": \"A_USER_ID\",\n  \"client_id\": \"A_CLIENT_ID\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/tickets/password-change\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Complete email verification flow\n\nAs part of the signup process, users get an email to verify their email address. If they click on the link, they will land on a page that says that the email was verified, with a button to go back to the application. When clicked, users will be redirected to the login page, and if they already have a valid session, they'll end up being redirected to the application.\n\nThis behavior only happens when the Universal Login experience is enabled. With Classic Login, you need to configure the redirect URL in the Verification Email template.\n\n### Invite organization members\n\nWhen users are invited to join an [Organization](https://auth0.com/docs/manage-users/organizations/organizations-overview), they receive an invitation link by email. If they select the link, they are redirected to the configured default login route with invitation-specific parameters appended.\n\nFor example, if you have an organization-enabled application with an **Application Login URI** set to `https://myapp.com/login`, then the link sent in the email invitation that an end-user receives will be: `https://myapp.com/login?invitation={invitation_ticket_id}&organization={organization_id}&organization_name={organization_name}`.\n\nThus, the route in your application must accept `invitation` and `organization` parameters through the query string. To start the invitation acceptance transaction, it should forward both parameters along with the end-user to your Auth0 `/authorize` endpoint.\n\n### Disabled cookies\n\nIf a user navigates to `https://{yourDomain}/authorize` with cookies disabled in their browser, Auth0 redirects the user to the application login URI. If the application login URI is not set, the redirect is sent to the tenant login URI instead.\n\nSending the user back to the login page can potentially cause a redirect loop. To avoid this issue, use a landing page to check the availability of cookies; if disabled, warn the user to enable them if they wish to continue.\n\n## Learn more\n\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)\n*   [Check Error Messages](https://auth0.com/docs/troubleshoot/basic-issues/check-error-messages)\n*   [Manage Authentication Factors with Authentication API](https://auth0.com/docs/secure/multi-factor-authentication/manage-mfa-auth0-apis/manage-authenticator-factors-mfa-api)",
    "title": "Configure Default Login Routes",
    "description": "Learn how to configure your tenant's and application's default login routes.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/organizations/organizations-overview",
    "markdown": "# Understand How Auth0 Organizations Work\n\n#### Availability varies by Auth0 plan and login method\n\nBoth your specific login implementation and your Auth0 plan or custom agreement affect whether this feature is available. To learn more, read [Pricing](https://auth0.com/pricing).\n\n## Business cases\n\nThe Auth0 Organizations feature best supports business-to-business (B2B) implementations that have applications that end-users access.\n\n![B2B Organizations Business Case diagram](https://images.ctfassets.net/cdy7uua7fh8z/4l47Xknr2LpuMSOX0T3yCP/800877a39f474faa0c6d83551d56c337/b2b-business-case.png)\n\nCommon features of B2B implementations include:\n\n*   A product that is licensed to another business for use by their employees.\n    \n*   Each organization requires its own federation and lightweight branding of the authentication experience.\n    \n*   Access levels in the application can be represented by roles that are assigned to members of each organization.\n    \n\nLet’s explore some example business cases to highlight the ways in which Organizations can help.\n\n## Sample scenario\n\nTravel0 is a fictitious company that offers online travel services and has set up an Auth0 tenant. Travel0 has several applications, but we’ll focus on one application that could benefit from using Organizations.\n\n**Travel0 Adventure Management**: An online application that allows its customers to create and market adventures, such as whitewater rafting, horseback riding, and zip lining. Each adventure is led by a guide who can use the application to sign up and manage scheduling. Guides may be either employed by the customer directly or freelance.\n\nCustomers of the application include:\n\n*   **Granite Outpost Rafting and Ziplines**: An established company that directly employs their large staff of guides, but sometimes also reaches out to freelance guides. They have their own IdP that they use for their employees.\n    \n*   **AdventureZ**: A large event company that directly employs a large number of guides, but also uses freelancers, though rarely. They also facilitate their direct employees’ ability to freelance for other companies who are in need of guides. They have their own IdP that they use for their employees.\n    \n*   **Rocky Mountain High Adventures**: A new company just coming to market. The co-founders run most of their tours, and they reach out to freelancers for help during busy times. They don’t have an IT staff, and have neither the time nor inclination to set up their own identity provider (IdP). They have a contract with AdventureZ that allows any AdventureZ employees to freelance for them.\n    \n\n## Planning considerations\n\nWhen setting up organizations, consider the following:\n\n*   **Login experience**: Will users be required to select an organization when logging in? Will users see the application’s default login page or a customized login page for their organization?\n    \n*   **Connection model**: Will any users be shared between organizations? Do users need to be able to log in using an organization’s own internal identity provider?\n    \n*   **Roles**: Does the application need users to have specific roles assigned within their organizations? Do you intend to build a custom dashboard that allows administrators to self-manage their organizations using assigned roles?\n    \n\n### Login experience\n\nFirst, you must decide what the user should experience when they log in to an organization. You can choose to send the end-user directly to a specific Organization’s login prompt in Auth0, or you can send them to a prompt in which they can enter the name of the Organization with which they want to log in.\n\nAdditionally, you must choose whether to use the default Universal Login page that is configured for your application or to customize a login page specific to each organization using page templates. To learn more, see [Create Your First Organization](https://auth0.com/docs/manage-users/organizations/create-first-organization).\n\n### Connection model\n\nEach organization will usually map directly to one of your business customers or partners, but users can be members of multiple organizations. Understanding how users map to customer organizations will help you determine how to model your organizations and connections. There are two user scenarios:\n\n*   **Users are isolated to an organization**: Every user is a member of exactly one organization. Either users will never need to be part of multiple organizations, or it would make more sense for users to create a separate identity for each organization.\n    \n*   **Users are shared between organizations**: Any user may belong to multiple organizations and should be able to use the same identity to navigate between organizations.\n    \n\nUsing our Travel0 Adventure Management example, let’s assume the following users:\n\n*   **Jonno**: A guide who is directly employed by Rocky Mountain High Adventures and who should be able to log in to only Rocky Mountain’s organization. Because Rocky Mountain does not have its own IdP, Jonno’s credentials are stored in the Travel0 database connection and Jonno is assigned membership to the Rocky Mountain organization.\n    \n*   **Hiroko**: A guide who is directly employed by Granite Outpost Rafting and Ziplines and who should be able to log in to only Granite Outpost’s organization. Because Granite Outpost has its own IdP, Hiroko’s credentials may be stored in either the Travel0 database connection or an enterprise connection that Granite Outpost has set up to represent their IdP, and then Hiroko must also be assigned membership in Granite Outpost’s organization. If using Granite Outpost’s IdP, then the enterprise connection must also be enabled for the organization.\n    \n*   **Emilio**: A guide who freelances for both Rocky Mountain High Adventures and Granite Outpost Rafting and Ziplines and should be able to log in to both organizations. If we want Emilio to be able to use the same credentials for both organizations, then Emilio’s credentials should be stored in the Travel0 database connection, and Emilio should be assigned membership in both Rocky Mountain and Granite Outpost organizations. Otherwise, Emilio will need to set up one set of credentials in the Travel0 database connection for Rocky Mountain High Adventures and be assigned membership in the Rocky Mountain High organization, then set up another set of credentials in either the Travel0 database connection or Granite Outpost’s enterprise connection and be assigned membership in the Granite Outpost organization. Finally, if using Granite Outpost’s IdP, the configured enterprise connection must be enabled for the Granite Outpost organization.\n    \n*   **Sumana**: A guide who is directly employed by AdventureZ, but sometimes freelances for Rocky Mountain High Adventures under the contract Rocky Mountain has with AdventureZ. AdventureZ and Rocky Mountain have rating systems for their guides, and Sumana’s ratings need to carry over from AdventureZ to Rocky Mountain and be combined between organizations. Either Sumana’s credentials should be stored in the Travel0 database connection and membership should be assigned for both the Rocky Mountain and AdventureZ organizations, or if AdventureZ wants to share their IdP, then Sumana’s credentials should be stored in an enterprise connection that AdventureZ has set up to represent their IdP and the configured enterprise connection must be enabled for both the Rocky Mountain and AdventureZ organizations. If Sumana is also invited to freelance for Granite Outpost Rafting and Ziplines, then her credentials could be stored in the Travel0 database connection or she could be added to Granite Outpost’s IdP, and membership should be assigned to the Granite Outpost organization.\n    \n\nOnce you have determined how many organizations you will have and what your connection model should look like, you can set up [database](https://auth0.com/docs/connections/database), [social](https://auth0.com/docs/connections/identity-providers-social), or [enterprise](https://auth0.com/docs/connections/identity-providers-enterprise) connections; [create organizations](https://auth0.com/docs/manage-users/organizations/configure-organizations/create-organizations); and [configure organization membership](https://auth0.com/docs/manage-users/organizations/configure-organizations/invite-members) or [enable organization connections](https://auth0.com/docs/manage-users/organizations/configure-organizations/enable-connections).\n\n### Roles\n\nMembers of organizations can be [assigned roles](https://auth0.com/docs/manage-users/organizations/configure-organizations/add-member-roles). You can use these roles to define access control for your application. For example, if you built a dashboard for your users using our API and SDKs, you could assign an administrator role to certain members and allow them to self-manage their organizations through your dashboard.\n\n## Limitations\n\nThe Auth0 Organizations feature has the following limitations:\n\n*   Your Auth0 subscription plan affects the availability of this feature. To learn more, read [Auth0 Pricing](https://auth0.com/pricing/).\n    \n*   Supported only for Universal Login (not supported for Classic Login or Lock.js).\n    \n*   Organizations-enabled applications are not compatible with the following grants and protocols: Resource Owner Password, Client Credentials, Device Authorization Flow, WS-Fed (Auth0 as IdP).\n    \n*   Does not support:\n    \n    *   Custom domains per organization (For example, using the sample scenario, if Rocky Mountain High Adventures and Granite Outpost Rafting and Ziplining could both use `login.travel0.com` as login domains, then Organizations would be useful. Alternatively, if Rocky Mountain High Adventures wanted to use `login.rockymountain.com` and Granite Outpost wanted to use `login.graniteoutpost.com`, then you would need to use multiple Auth0 tenants.\n        \n    *   Integration with the Delegated Administration Extension.\n        \n    *   Integration with the Authorization Extension.\n        \n    *   Integration with third-party applications.\n        \n\n## Learn more\n\n*   [Create Your First Organization](https://auth0.com/docs/manage-users/organizations/create-first-organization)\n*   [Custom Development with Organizations](https://auth0.com/docs/manage-users/organizations/custom-development)\n*   [Work with Tokens and Organizations](https://auth0.com/docs/manage-users/organizations/using-tokens)\n*   [Configure Organizations](https://auth0.com/docs/manage-users/organizations/configure-organizations)\n*   [Entity Limit Policy](https://auth0.com/docs/troubleshoot/customer-support/operational-policies/entity-limit-policy)",
    "title": "Understand How Auth0 Organizations Work",
    "description": "Describes how Auth0 Organizations work, use cases, a sample scenario, planning, and limitations.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profiles",
    "markdown": "# Normalized User Profiles\n\nThe normalized user profile is an Auth0-specific way of standardizing and storing user-related information. Because every Identity Provider (IdP) provides a different set of information about a user, Auth0 normalizes common profile properties into a protocol-agnostic representation of the user when storing user-related claims. For example, `family_name` in the normalized user profile contains details that may be returned to an IdP as `surname` or `last_name`.\n\nAs such, the Auth0 claims included in the normalized user profile differ from the standard set of claims that can be returned in ID Tokens from the [Authentication API's `oauth/token` endpoint](https://auth0.com/docs/api/authentication#get-token) or in the response from the [`/userinfo`](https://auth0.com/docs/api/authentication#user-profile) endpoint (both of which follow the requirements detailed in the OIDC specification).\n\nTo learn about the attributes included in the normalized user profile and understand how you can work with them, read [User Profile Structure](https://auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure).\n\n## Learn more\n\n*   [Sample User Profiles](https://auth0.com/docs/manage-users/user-accounts/user-profiles/sample-user-profiles)\n*   [User Profile Root Attributes](https://auth0.com/docs/manage-users/user-accounts/user-profiles/root-attributes)\n*   [User Data Storage](https://auth0.com/docs/secure/security-guidance/data-security/user-data-storage)\n*   [Check User Profiles](https://auth0.com/docs/troubleshoot/authentication-issues/check-user-profiles)\n*   [Check API Calls](https://auth0.com/docs/troubleshoot/authentication-issues/check-api-calls)",
    "title": "Normalized User Profiles",
    "description": "Understand how Auth0 normalizes common user properties in the user profile.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password",
    "markdown": "# Change Password Script Templates\n\nThe Change Password script implements the defined function to change the specified user's password in the external database. We recommend naming this function `changePassword`.\n\nThe script is used only in a [legacy authentication scenario](https://auth0.com/docs/authenticate/database-connections/custom-db/overview-custom-db-connections) and is required if you want to change a user's password in the external database. It will execute when a user performs a [password reset workflow](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page), or when a password change workflow is started from the Auth0 Dashboard or the Auth0 Management API.\n\n## ChangePassword function\n\nThe `changePassword` function should:\n\n*   Update the user's password in the external database.\n    \n*   Return `true` (or an object containing the `last_password_reset` property) if the password change operation succeeded. If the `last_password_reset` property is present in the object, it will be updated on the user's profile.\n    \n*   Return `false` if the password change operation failed.\n    \n*   Return an error if the external database could not be reached.\n    \n\n### Definition\n\nThe `changePassword` function accepts three parameters and returns a `callback` function:\n\n```\nchangePassword(email, newPassword, callback): function\n```\n\n| **Parameter** | **Type** | **Description** |\n| --- | --- | --- |\n| `email` | String | User's email address in Auth0 and external database. |\n| `newPassword` | String | Value to be set as user's new password in the external database. This value is sent as plaintext to the function and [should be encrypted](#Encryption) before being sent to the external database. |\n| `callback` | Function | Used to pass data or operation result data through the pipeline. |\n\n### Example\n\nThis is a pseudo-JavaScript example of how you could implement the `changePassword` function. For language-specific examples, read [Language-specific script examples](#language-specific-script-examples).\n\n```\nfunction changePassword(email, newPassword, callback) {\n  // Hash the provided password \n  let hashedPassword = hash(newPassword);\n\n  // Prepare the API call\n  let options = {\n    url: \"https://example.com/api/users\",\n    body: {\n      email: email,\n      password: hashedPassword\n    }\n  };\n\n  // Call the API\n  send(options, err => {\n    if (err && err.id == \"FAIL_CHANGE_PASSWORD\") {\n      // Return false in callback if password change failed\n      return callback(null, false);\n    } else if (err) {\n      // Return error in callback if other error occurred\n      return callback(new Error(\"My custom error message.\");\n    } else {\n      // Return true in callback if password change operation succeeded\n      return callback(null, true);\n\n      // Or return an object containing the `last_password_reset` property \n      // if the password change operation succeeded.\n      // If the `last_password_reset` property is present in the object,\n      // it will be updated on the user's profile.\n      return callback(null, { \"last_password_reset\": Date.now() });\n    }\n  });\n}\n```\n\n### Encryption\n\nTo prevent any potential data leak, encrypt the password value using a cryptographic hash encryption library such as `bcrypt`.\n\n#### Example\n\n```\nbcrypt.hash(password, 10, function (err, hash) {\n    if (err) {\n        return callback(err);\n    } else {\n        // Return hashed password\n    }\n});\n```\n\n## Callback function\n\nThe `callback` function accepts two parameters and is used to pass error data or indicate the result of the operation.\n\n### Definition\n\n```\ncallback(error, operationResult | resultObj): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n| `operationResult` | Boolean | Optional | Indicates the result of the change password operation. |\n| `resultObj` | Object | Optional | Indicates that the change password operation succeeded. If the `last_password_reset` property is present, it will be updated on the user's profile. |\n\n### Return a success\n\nIf the change password operation succeeded, return the `callback` function, and pass a `null` value as the `error` parameter and a `true` value as the `operationResult` parameter.\n\n#### Example\n\n```\nreturn callback(null, true);\n```\n\n### Return a success and update last\\_password\\_reset attribute\n\nIf the change password operation succeeded, return the `callback` function, and pass a `null` value as the `error` parameter and an object value as the `profile` parameter. If `last_password_reset` attribute is provided in the object, it will be updated on the user's profile.\n\n#### Example\n\n```\nreturn callback(null, { \"last_password_reset\": Date.now() });\n```\n\n### Return a failure\n\nIf the change password operation failed, return the `callback` function, and pass a `null` value as the `error` parameter and a `false` value as the `operationResult` parameter.\n\n#### Example\n\n```\nreturn callback(null, false);\n```\n\n### Return an error\n\nIf an error occurs, return `callback` function, and pass relevant error information as the `error` parameter.\n\n#### Example\n\n```\nreturn callback(new Error(\"My custom error message.\"));\n```\n\n## Language-specific script examples\n\nAuth0 provides sample scripts for use with the following languages/technologies:\n\n*   [JavaScript](#javascript)\n    \n*   [ASP.NET Membership Provider (MVC3 - Universal Providers)](#asp-net-membership-provider-mvc3-universal-providers-)\n    \n*   [ASP.NET Membership Provider (MVC4 - Simple Membership)](#asp-net-membership-provider-mvc4-simple-membership-)\n    \n*   [MongoDB](#mongodb)\n    \n*   [MySQL](#mysql)\n    \n*   [PostgreSQL](#postgresql)\n    \n*   [SQL Server](#sql-server)\n    \n*   [Windows Azure SQL Database](#windows-azure-sql-database)\n    \n\n### JavaScript\n\n```\nfunction changePassword(email, newPassword, callback) {\n  // This script should change the password stored for the current user in your\n  // database. It is executed when the user clicks on the confirmation link\n  // after a reset password request.\n  // The content and behavior of password confirmation emails can be customized\n  // here: https://manage.auth0.com/#/emails\n  // The `newPassword` parameter of this function is in plain text. It must be\n  // hashed/salted to match whatever is stored in your database.\n  //\n  // There are three ways that this script can finish:\n  // 1. The user's password was updated successfully:\n  //     callback(null, true);\n  // 2. The user's password was not updated:\n  //     callback(null, false);\n  // 3. Something went wrong while trying to reach your database:\n  //     callback(new Error(\"my error message\"));\n  //\n  // If an error is returned, it will be passed to the query string of the page\n  // to which the user is being redirected after clicking the confirmation link.\n  // For example, returning `callback(new Error(\"error\"))` and redirecting to\n  // https://example.com would redirect to the following URL:\n  //     https://example.com?email=alice%40example.com&message=error&success=false\n  const msg = 'Please implement the Change Password script for this database ' +\n    'connection at https://manage.auth0.com/#/connections/database';\n  return callback(new Error(msg));\n}\n```\n\n### ASP.NET Membership Provider (MVC3 - Universal Providers)\n\n```\nfunction changePassword(email, newPassword, callback) {\n  var crypto = require('crypto');\n  var Connection = require('tedious').Connection;\n  var Request = require('tedious').Request;\n  var TYPES = require('tedious').TYPES\n  var connection = new Connection({\n    userName:  'the username',\n    password:  'the password',\n    server:    'the server',\n    options: {\n      database:  'the db name',\n      // encrypt: true   for Windows Azure enable this\n    }\n  });\n  /**\n   * hashPassword\n   *\n   * This function creates a hashed version of the password to store in the database.\n   *\n   * @password  {[string]}      the password entered by the user\n   * @return    {[string]}      the hashed password\n   */\n  function hashPassword(password, salt) {\n    // the default implementation uses HMACSHA256 and since Key length is 64\n    // and default salt is 16 bytes, Membership will fill the buffer repeating the salt\n    var key = Buffer.concat([salt, salt, salt, salt]);\n    var hmac = crypto.createHmac('sha256', key);\n    hmac.update(Buffer.from(password, 'ucs2'));\n    var hashed = hmac.digest('base64');\n    return hashed;\n  }\n  connection.on('debug', function(text) {\n      // if you have connection issues, uncomment this to get more detailed info\n      //console.log(text);\n  }).on('errorMessage', function(text) {\n      // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    updateMembershipUser(email, newPassword, function(err, wasUpdated) {\n      if (err) {\n        return callback(err); // this will return a 500\n      }\n      callback(null, wasUpdated);\n    });\n  });\n  function updateMembershipUser(email, newPassword, callback) {\n    var salt            = crypto.randomBytes(16);\n    var hashedPassword  = hashPassword(newPassword, salt);\n    var updateMembership =\n      'UPDATE Memberships '+\n      'SET Password=@NewPassword, PasswordSalt=@NewSalt, LastPasswordChangedDate=GETDATE() '+\n      'WHERE Email=@Email';\n    var updateMembershipQuery = new Request(updateMembership, function (membershipErr, membershipCount) {\n      if (membershipErr) {\n        return callback(membershipErr);\n      }\n      callback(null, membershipCount > 0);\n    });\n    updateMembershipQuery.addParameter('NewPassword', TYPES.VarChar, hashedPassword);\n    updateMembershipQuery.addParameter('NewSalt',     TYPES.VarChar, salt.toString('base64'));\n    updateMembershipQuery.addParameter('Email',       TYPES.VarChar, email);\n    connection.execSql(updateMembershipQuery);\n  }\n}\n```\n\n### ASP.NET Membership Provider (MVC4 - Simple Membership)\n\n```\nfunction changePassword(email, newPassword, callback) {\n  var crypto = require('crypto');\n  var Connection = require('tedious').Connection;\n  var Request = require('tedious').Request;\n  var TYPES = require('tedious').TYPES\n  var connection = new Connection({\n    userName:  'the username',\n    password:  'the password',\n    server:    'the server',\n    options: {\n      database:  'the db name',\n      // encrypt: true for Windows Azure enable this\n    }\n  });\n  /**\n   * hashPassword\n   *\n   * This function hashes a password using HMAC SHA256 algorithm.\n   *\n   * @password    {[string]}    password to be hased\n   * @salt        {[string]}    salt to be used in the hashing process\n   * @callback    {[function]}  callback to be called after hashing the password\n   */\n  function hashPassword(password, salt, callback) {\n    var iterations         = 1000;\n    var passwordHashLength = 32;\n    crypto.pbkdf2(password, salt, iterations, passwordHashLength, function (err, hashed) {\n      if (err) {\n        return callback(err);\n      }\n      var result = Buffer.concat([Buffer.from([0], 1), salt, Buffer.from(hashed, 'binary')]);\n      var resultBase64 = result.toString('base64');\n      callback(null, resultBase64);\n    });\n  }\n  connection.on('debug', function(text) {\n      // if you have connection issues, uncomment this to get more detailed info\n      //console.log(text);\n  }).on('errorMessage', function(text) {\n      // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    updateMembershipUser(email, newPassword, function(err, wasUpdated) {\n      if (err) {\n        return callback(err); // this will return a 500\n      }\n      callback(null, wasUpdated);\n    });\n  });\n  function findUserId(email, callback) {\n    var findUserIdFromEmail =\n      'SELECT UserProfile.UserId FROM ' +\n      'UserProfile INNER JOIN webpages_Membership ' +\n      'ON UserProfile.UserId = webpages_Membership.UserId ' +\n      'WHERE UserName = @Email';\n    var findUserIdFromEmailQuery = new Request(findUserIdFromEmail, function (err, rowCount, rows) {\n      if (err) {\n        return callback(err);\n      }\n      // No record found with that email\n      if (rowCount < 1) {\n        return callback(null, null);\n      }\n      var userId = rows[0][0].value;\n      callback(null, userId);\n    });\n    findUserIdFromEmailQuery.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(findUserIdFromEmailQuery);\n  }\n  function updateMembershipUser(email, newPassword, callback) {\n    findUserId(email, function (err, userId) {\n      if (err) {\n        return callback(err);\n      }\n      if (userId === null) {\n        return callback();\n      }\n      var salt = crypto.randomBytes(16);\n      var updateMembership =\n        'UPDATE webpages_Membership '+\n        'SET Password=@NewPassword, PasswordChangedDate=GETDATE() '+\n        'WHERE UserId=@UserId';\n      var updateMembershipQuery = new Request(updateMembership, function (err, rowCount) {\n        if (err) {\n          return callback(err);\n        }\n        if (rowCount < 1) {\n          return callback();\n        }\n        callback(null, rowCount > 0);\n      });\n      hashPassword(newPassword, salt, function (err, hashedPassword) {\n        if (err) {\n          return callback(err);\n        }\n        updateMembershipQuery.addParameter('NewPassword',   TYPES.VarChar, hashedPassword);\n        updateMembershipQuery.addParameter('UserId',        TYPES.VarChar, userId);\n        connection.execSql(updateMembershipQuery);\n      });\n    });\n  }\n}\n```\n\n### MongoDB\n\n```\nfunction changePassword(email, newPassword, callback) {\n  const bcrypt = require('bcrypt');\n  const MongoClient = require('mongodb@3.1.4').MongoClient;\n  const client = new MongoClient('mongodb://user:pass@mymongoserver.com');\n  client.connect(function (err) {\n    if (err) return callback(err);\n    const db = client.db('db-name');\n    const users = db.collection('users');\n    bcrypt.hash(newPassword, 10, function (err, hash) {\n      if (err) {\n        client.close();\n        return callback(err);\n      }\n      users.update({ email: email }, { $set: { password: hash } }, function (err, count) {\n        client.close();\n        if (err) return callback(err);\n        callback(null, count > 0);\n      });\n    });\n  });\n}\n```\n\n### MySQL\n\n```\nfunction changePassword(email, newPassword, callback) {\n  const mysql = require('mysql');\n  const bcrypt = require('bcrypt');\n  const connection = mysql({\n    host: 'localhost',\n    user: 'me',\n    password: 'secret',\n    database: 'mydb'\n  });\n  connection.connect();\n  const query = 'UPDATE users SET password = ? WHERE email = ?';\n  bcrypt.hash(newPassword, 10, function(err, hash) {\n    if (err) return callback(err);\n    connection.query(query, [ hash, email ], function(err, results) {\n      if (err) return callback(err);\n      callback(null, results.length > 0);\n    });\n  });\n}\n```\n\n### PostgreSQL\n\n```\nfunction changePassword (email, newPassword, callback) {\n  //this example uses the \"pg\" library\n  //more info here: https://github.com/brianc/node-postgres\n  const bcrypt = require('bcrypt');\n  const postgres = require('pg');\n  const conString = 'postgres://user:pass@localhost/mydb';\n  postgres.connect(conString, function (err, client, done) {\n    if (err) return callback(err);\n    bcrypt.hash(newPassword, 10, function (err, hash) {\n      if (err) return callback(err);\n      const query = 'UPDATE users SET password = $1 WHERE email = $2';\n      client.query(query, [hash, email], function (err, result) {\n        // NOTE: always call `done()` here to close\n        // the connection to the database\n        done();\n        return callback(err, result && result.rowCount > 0);\n      });\n    });\n  });\n}\n```\n\n### SQL Server\n\n```\nfunction changePassword (email, newPassword, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://tediousjs.github.io/tedious/\n  const bcrypt = require('bcrypt');\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName:  'test',\n    password:  'test',\n    server:    'localhost',\n    options:  {\n      database: 'mydb'\n    }\n  });\n  const query = 'UPDATE dbo.Users SET Password = @NewPassword WHERE Email = @Email';\n  connection.on('debug', function(text) {\n    console.log(text);\n  }).on('errorMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const request = new Request(query, function (err, rows) {\n      if (err) return callback(err);\n      callback(null, rows > 0);\n    });\n    bcrypt.hash(newPassword, 10, function (err, hash) {\n      if (err) return callback(err);\n      request.addParameter('NewPassword', TYPES.VarChar, hash);\n      request.addParameter('Email', TYPES.VarChar, email);\n      connection.execSql(request);\n    });\n  });\n}\n```\n\n### Windows Azure SQL Database\n\n```\nfunction changePassword (email, newPassword, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  var Connection = require('tedious@1.11.0').Connection;\n  var Request = require('tedious@1.11.0').Request;\n  var TYPES = require('tedious@1.11.0').TYPES;\n  var bcrypt = require('bcrypt');\n  var connection = new Connection({\n    userName:  'your-user@your-server-id.database.windows.net',\n    password:  'the-password',\n    server:    'your-server-id.database.windows.net',\n    options:  {\n      database: 'mydb',\n      encrypt:  true\n    }\n  });\n  var query = 'UPDATE dbo.Users SET Password = @NewPassword ' +\n    'WHERE Email = @Email';\n  connection.on('debug', function(text) {\n    // Uncomment next line in order to enable debugging messages\n    // console.log(text);\n  }).on('errorMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function(text) {\n    // Uncomment next line in order to enable information messages\n    // console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) { return callback(err); }\n    var request = new Request(query, function (err, rows) {\n      if (err) { return callback(err); }\n      console.log('rows: ' + rows);\n      callback(null, rows > 0);\n    });\n    bcrypt.hash(newPassword, 10, function (err, hash) {\n      if (err) { return callback(err); }\n      request.addParameter('NewPassword', TYPES.VarChar, hash);\n      request.addParameter('Email', TYPES.VarChar, email);\n      connection.execSql(request);\n    });\n  });\n}\n```\n\n## Learn more\n\n*   [Create Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n*   [Delete Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n*   [Get User Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n*   [Login Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n*   [Verify Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)\n*   [Change Email Script Template](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)",
    "title": "Change Password Script Templates",
    "description": "Describes custom database action script templates for changing a user's password.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create",
    "markdown": "# Create Script Templates\n\nThe Create script implements the defined function when a user is created. We recommend naming this function `create`.\n\nThis script is optional. If it's enabled, when a user signs up through Universal Login or is created through the Auth0 Dashboard or Auth0 Management API, Auth0 will run the script to create a corresponding user record in the external database.\n\nWhen a user is created in Auth0, Auth0 calls a series of scripts:\n\n1.  [Get User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user): Verifies that the user does not already exist in Auth0 or the external database.\n    \n2.  Create: Creates the user in the external database.\n    \n3.  [Login](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login): Verifies that the user was created successfully.\n    \n\n## Create function\n\nThe `create` function should:\n\n*   Send the user's profile data to the external database's API.\n    \n*   Return an error if the user creation operation failed.\n    \n\n### Definition\n\nThe `create` function accept two parameters and returns a `callback` function:\n\n```\ncreate(user, callback): function\n```\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `user` | Object. Contains [user profile data](#user-object-parameter) sourced from the user creation process. |\n| `callback` | Function. Used to pass error data through the pipeline. |\n\n### Example\n\nThis is a pseudo-JavaScript example of how you could implement the `create` function. For language-specific examples, read [Language-specific script examples](#language-specific-script-examples).\n\n```\nfunction create(user, callback) {\n  // Send user profile data to external database API\n  let hashedPassword = hash(user.password);\n\n  let options = {\n    url: \"https://example.com/api/create\",\n    body: {\n      email: user.email,\n      username: user.username,\n      password: hashedPassword\n    }\n  };\n\n  send(options, err => {\n    // Return error in callback if user already exists\n    if (err && err.id === \"USER_ALREADY_EXISTS\") {\n      return callback(new ValidationError(\"user_exists\", \"My custom error message.\"));\n    } else if (err) {\n      // Return error in callback if error occurred\n      return callback(new Error(\"My custom error message.\"));\n    }\n\n    // Return `null` value in callback if user creation operation succeeded\n    return callback(null);\n  });\n}\n```\n\n### Encryption\n\nEncrypt the password value using a cryptographic hash encryption library such as `bcrypt` to prevent any potential data leak.\n\n#### Example\n\n```\nbcrypt.hash(password, 10, function (err, hash) {\n    if (err) {\n        return callback(err);\n    } else {\n        // Return hashed password\n    }\n});\n```\n\n## Callback function\n\nThe `callback` function accepts one parameter and returns a function.\n\n### Definition\n\n```\ncallback(error): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n\n### Return a success\n\nIf the user creation operation succeeded, return the `callback` function, and pass a `null` value as the `error` parameter.\n\n#### Example\n\n### Return an error\n\nIf an error occurs, return the callback function, and pass relevant error information to the the `error` parameter.\n\n#### ValidationError type object\n\nThe `ValidationError` custom error type object allows you to pass data that will be displayed in your [Tenant Logs](https://auth0.com/docs/deploy-monitor/logs).\n\n##### Constructor\n\nThe `ValidationError` constructor accepts up to two parameters:\n\n```\nnew ValidationError(errorCode[, message]): ValidationError\n```\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `errorCode` | (Required) String. Specifies the type of error. |\n| `message` | (Optional) String. Contains information about the error. |\n\n#### Return error that user already exists\n\nIf you return an error with the value of `user_exists` for the `errorCode` parameter, Auth0 will record an `fs` tenant log event.\n\n##### Example\n\n```\nreturn callback(new ValidationError(\"user_exists\", \"My custom error message.\"));\n```\n\n| **Tenant Log Event Field** | **Value** |\n| --- | --- |\n| **Code** | `fs` |\n| **Event** | Failed Signup |\n| **Description** | `My custom error message.` |\n\n## User object parameter\n\nThe `user` object parameter contains a predefined set of properties sourced from the user creation process:\n\n| **Property** | **Description** |\n| --- | --- |\n| `client_id` | The Auth0 application's client ID if the user signed up through Universal Login, or the API key if the user was created through the Auth0 Dashboard or Management API. |\n| `tenant` | The Auth0 tenant name. |\n| `email` | The user's email address. |\n| `password` | The user's password in plain text. |\n| `username` | The user's username. Required only if the custom database connection has the [**Requires Username**](https://auth0.com/docs/connections/database/require-username) setting enabled. |\n| `connection` | The Auth0 connection name. |\n| `user_metadata` | Contains the properties of the `user_metadata` object on the user's Auth0 profile, if the object exists. |\n| `app_metadata` | Contains the properties of the `app_metadata` object on the user's Auth0 profile, if the object exists. |\n\n### Username property\n\nIf your custom database connection has the [Requires Username](https://auth0.com/docs/authenticate/database-connections/require-username) setting enabled, then the [Login](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login) and [Get User](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user) scripts must support the `username` property, so you should store it in your external database.\n\n### User and app metadata\n\nThe `user_metadata` and `app_metadata` properties do not need to be stored in your external database. Auth0 automatically stores these values as part of the [user profile](https://auth0.com/docs/videos/get-started-series/learn-user-profiles) record created internally.\n\n### Custom sign up fields\n\nIf you [create and use custom fields](https://auth0.com/docs/libraries/custom-signup#using-the-api) during the sign up process, they will be included in the `user` object.\n\n### Example\n\n```\n{\n    client_id: \"8tkMo6n1QkKOazqPcSQd8wU7LzXYibgK\",\n    tenant: \"{yourAuth0Tenant}\",\n    email: \"username@domain.com\",\n    password: \"mySuperSecretPassword123\",\n    username: \"username456\",\n    user_metadata: {\n        \"language\": \"en\"\n    },\n    app_metadata: {\n        \"plan\": \"full\"\n    }\n}\n```\n\n## Language-specific script examples\n\nAuth0 provides sample scripts for use with the following languages/technologies:\n\n*   [JavaScript](#javascript)\n    \n*   [ASP.NET Membership Provider (MVC3 - Universal Providers)](#asp-net-membership-provider-mvc3-universal-providers-)\n    \n*   [ASP.NET Membership Provider (MVC4 - Simple Membership)](#asp-net-membership-provider-mvc4-simple-membership-)\n    \n*   [MongoDB](#mongodb)\n    \n*   [MySQL](#mysql)\n    \n*   [PostgreSQL](#postgresql)\n    \n*   [SQL Server](#sql-server)\n    \n*   [Windows Azure SQL Database](#windows-azure-sql-database)\n    \n*   [Request with Basic Auth](#request-with-basic-auth)\n    \n\n### JavaScript\n\n```\nfunction create(user, callback) {\n  // This script should create a user entry in your existing database. It will\n  // be executed when a user attempts to sign up, or when a user is created\n  // through the Auth0 Dashboard or Management API.\n  // When this script has finished executing, the Login script will be\n  // executed immediately afterwards, to verify that the user was created\n  // successfully.\n  //\n  // The user object will always contain the following properties:\n  // * email: the user's email\n  // * password: the password entered by the user, in plain text\n  // * tenant: the name of this Auth0 account\n  // * client_id: the client ID of the application where the user signed up, or\n  //              API key if created through the Management API or Auth0 Dashboard\n  // * connection: the name of this database connection\n  //\n  // There are three ways this script can finish:\n  // 1. A user was successfully created\n  //     callback(null);\n  // 2. This user already exists in your database\n  //     callback(new ValidationError(\"user_exists\", \"my error message\"));\n  // 3. Something went wrong while trying to reach your database\n  //     callback(new Error(\"my error message\"));\n  const msg = 'Please implement the Create script for this database connection ' +\n    'at https://manage.auth0.com/#/connections/database';\n  return callback(new Error(msg));\n}\n```\n\n### ASP.NET Membership Provider (MVC3 - Universal Providers)\n\n```\nfunction create(user, callback) {\n  const crypto = require('crypto');\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true,\n      // Required to retrieve userId needed for Membership entity creation\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  const applicationId = 'your-application-id-goes-here';\n  /**\n   * hashPassword\n   *\n   * This function creates a hashed version of the password to store in the database.\n   *\n   * @password  {[string]}      the password entered by the user\n   * @return    {[string]}      the hashed password\n   */\n  function hashPassword(password, salt) {\n    // the default implementation uses HMACSHA256 and since Key length is 64\n    // and default salt is 16 bytes, Membership will fill the buffer repeating the salt\n    const key = Buffer.concat([salt, salt, salt, salt]);\n    const hmac = crypto.createHmac('sha256', key);\n    hmac.update(Buffer.from(password, 'ucs2'));\n    return hmac.digest('base64');\n  }\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    // console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) {\n      return callback(err);\n    }\n    createMembershipUser(user, function(err, user) {\n      if (err) return callback(err); // this will return a 500\n      if (!user) return callback(); // this will return a 401\n      callback(null, user);\n    });\n  });\n  function createMembershipUser(user, callback) {\n    const userData = {\n      UserName: user.email,\n      ApplicationId: applicationId\n    };\n    const createUser =\n      'INSERT INTO Users (UserName, LastActivityDate, ApplicationId, UserId, IsAnonymous) ' +\n      'OUTPUT Inserted.UserId ' +\n      'VALUES (@UserName, GETDATE(), @ApplicationId, NEWID(), \\'false\\')';\n    const createUserQuery = new Request(createUser, function(err, rowCount, rows) {\n      if (err) return callback(err);\n      // No records added\n      if (rowCount === 0) return callback(null);\n      const userId = rows[0][0].value;\n      const salt = crypto.randomBytes(16);\n      const membershipData = {\n        ApplicationId: applicationId,\n        Email: user.email,\n        Password: hashPassword(user.password, salt),\n        PasswordSalt: salt.toString('base64'),\n        UserId: userId\n      };\n      const createMembership =\n        'INSERT INTO Memberships (ApplicationId, UserId, Password, PasswordFormat, ' +\n        'PasswordSalt, Email, isApproved, isLockedOut, CreateDate, LastLoginDate, ' +\n        'LastPasswordChangedDate, LastLockoutDate, FailedPasswordAttemptCount, ' +\n        'FailedPasswordAttemptWindowStart, FailedPasswordAnswerAttemptCount, ' +\n        'FailedPasswordAnswerAttemptWindowsStart) ' +\n        'VALUES ' +\n        '(@ApplicationId, @UserId, @Password, 1, @PasswordSalt, ' +\n        '@Email, \\'false\\', \\'false\\', GETDATE(), GETDATE(), GETDATE(), GETDATE(), 0, 0, 0, 0)';\n      const createMembershipQuery = new Request(createMembership, function(err, rowCount) {\n        if (err) return callback(err);\n        if (rowCount === 0) return callback(null);\n        callback(null, rowCount > 0);\n      });\n      createMembershipQuery.addParameter('ApplicationId', TYPES.VarChar, membershipData.ApplicationId);\n      createMembershipQuery.addParameter('Email', TYPES.VarChar, membershipData.Email);\n      createMembershipQuery.addParameter('Password', TYPES.VarChar, membershipData.Password);\n      createMembershipQuery.addParameter('PasswordSalt', TYPES.VarChar, membershipData.PasswordSalt);\n      createMembershipQuery.addParameter('UserId', TYPES.VarChar, membershipData.UserId);\n      connection.execSql(createMembershipQuery);\n    });\n    createUserQuery.addParameter('UserName', TYPES.VarChar, userData.UserName);\n    createUserQuery.addParameter('ApplicationId', TYPES.VarChar, userData.ApplicationId);\n    connection.execSql(createUserQuery);\n  }\n}\n```\n\n### ASP.NET Membership Provider (MVC4 - Simple Membership)\n\n```\nfunction create(user, callback) {\n  const crypto = require('crypto');\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true,\n      // Required to retrieve userId needed for Membership entity creation\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  /**\n   * hashPassword\n   *\n   * This function hashes a password using HMAC SHA256 algorithm.\n   *\n   * @password    {[string]}    password to be hased\n   * @salt        {[string]}    salt to be used in the hashing process\n   * @callback    {[function]}  callback to be called after hashing the password\n   */\n  function hashPassword(password, salt, callback) {\n    const iterations = 1000;\n    const passwordHashLength = 32;\n    crypto.pbkdf2(password, salt, iterations, passwordHashLength, 'sha1', function (err, hashed) {\n      if (err) return callback(err);\n      const result = Buffer.concat([Buffer.from([0], 1), salt, Buffer.from(hashed, 'binary')]);\n      const resultBase64 = result.toString('base64');\n      callback(null, resultBase64);\n    });\n  }\n  connection.on('debug', function (text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    // console.log(text);\n  }).on('errorMessage', function (text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const createUser =\n      'INSERT INTO UserProfile (UserName) ' +\n      'OUTPUT Inserted.UserId ' +\n      'VALUES (@UserName)';\n    const createUserQuery = new Request(createUser, function (err, rowCount, rows) {\n      if (err || rowCount === 0) return callback(err);\n      const userId = rows[0][0].value;\n      const salt = crypto.randomBytes(16);\n      const createMembership =\n        'INSERT INTO webpages_Membership ' +\n        '(UserId, CreateDate, IsConfirmed, PasswordFailuresSinceLastSuccess, Password, PasswordSalt) ' +\n        'VALUES ' +\n        '(@UserId, GETDATE(), \\'false\\', 0, @Password, \\'\\')';\n      const createMembershipQuery = new Request(createMembership, function (err, rowCount) {\n        if (err || rowCount === 0) return callback(err);\n        callback(null, rowCount > 0);\n      });\n      hashPassword(user.password, salt, function (err, hashedPassword) {\n        if (err) return callback(err);\n        createMembershipQuery.addParameter('Password', TYPES.VarChar, hashedPassword);\n        createMembershipQuery.addParameter('PasswordSalt', TYPES.VarChar, salt.toString('base64'));\n        createMembershipQuery.addParameter('UserId', TYPES.VarChar, userId);\n        connection.execSql(createMembershipQuery);\n      });\n    });\n    createUserQuery.addParameter('UserName', TYPES.VarChar, user.email);\n    connection.execSql(createUserQuery);\n  });\n}\n```\n\n### MongoDB\n\n```\nfunction create(user, callback) {\n  const bcrypt = require('bcrypt');\n  const MongoClient = require('mongodb@3.1.4').MongoClient;\n  const client = new MongoClient('mongodb://user:pass@mymongoserver.com');\n  client.connect(function (err) {\n    if (err) return callback(err);\n    const db = client.db('db-name');\n    const users = db.collection('users');\n    users.findOne({ email: user.email }, function (err, withSameMail) {\n      if (err || withSameMail) {\n        client.close();\n        return callback(err || new Error('the user already exists'));\n      }\n      bcrypt.hash(user.password, 10, function (err, hash) {\n        if (err) {\n          client.close();\n          return callback(err);\n        }\n        user.password = hash;\n        users.insert(user, function (err, inserted) {\n          client.close();\n          if (err) return callback(err);\n          callback(null);\n        });\n      });\n    });\n  });\n}\n```\n\n### MySQL\n\n```\nfunction create(user, callback) {\n  const mysql = require('mysql');\n  const bcrypt = require('bcrypt');\n  const connection = mysql({\n    host: 'localhost',\n    user: 'me',\n    password: 'secret',\n    database: 'mydb'\n  });\n  connection.connect();\n  const query = 'INSERT INTO users SET ?';\n  bcrypt.hash(user.password, 10, function(err, hash) {\n    if (err) return callback(err);\n    const insert = {\n      password: hash,\n      email: user.email\n    };\n    connection.query(query, insert, function(err, results) {\n      if (err) return callback(err);\n      if (results.length === 0) return callback();\n      callback(null);\n    });\n  });\n}\n```\n\n### PostgreSQL\n\n```\nfunction create(user, callback) {\n  //this example uses the \"pg\" library\n  //more info here: https://github.com/brianc/node-postgres\n  const bcrypt = require('bcrypt');\n  const postgres = require('pg');\n  const conString = 'postgres://user:pass@localhost/mydb';\n  postgres.connect(conString, function (err, client, done) {\n    if (err) return callback(err);\n    bcrypt.hash(user.password, 10, function (err, hashedPassword) {\n      if (err) return callback(err);\n      const query = 'INSERT INTO users(email, password) VALUES ($1, $2)';\n      client.query(query, [user.email, hashedPassword], function (err, result) {\n        // NOTE: always call `done()` here to close\n        // the connection to the database\n        done();\n        return callback(err);\n      });\n    });\n  });\n}\n```\n\n### SQL Server\n\n```\nfunction create(user, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  const bcrypt = require('bcrypt');\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName:  'test',\n    password:  'test',\n    server:    'localhost',\n    options:  {\n      database: 'mydb'\n    }\n  });\n  const query = 'INSERT INTO dbo.Users SET Email = @Email, Password = @Password';\n  connection.on('debug', function(text) {\n    console.log(text);\n  }).on('errorMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const request = new Request(query, function (err, rows) {\n      if (err) return callback(err);\n      callback(null);\n    });\n    bcrypt.hash(user.password, 10, function(err, hash) {\n      if (err) return callback(err);\n      request.addParameter('Email', TYPES.VarChar, user.email);\n      request.addParameter('Password', TYPES.VarChar, hash);\n      connection.execSql(request);\n    });\n  });\n}\n```\n\n### Windows Azure SQL Database\n\n```\nfunction create (user, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  var Connection = require('tedious@1.11.0').Connection;\n  var Request = require('tedious@1.11.0').Request;\n  var TYPES = require('tedious@1.11.0').TYPES;\n  var bcrypt = require('bcrypt');\n  var connection = new Connection({\n    userName:  'your-user@your-server-id.database.windows.net',\n    password:  'the-password',\n    server:    'your-server-id.database.windows.net',\n    options:  {\n      database: 'mydb',\n      encrypt:  true\n    }\n  });\n  var query = \"INSERT INTO users (Email, Password) VALUES (@Email, @Password)\";\n  connection.on('debug', function(text) {\n    // Uncomment next line in order to enable debugging messages\n    // console.log(text);\n  }).on('errorMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function(text) {\n    // Uncomment next line in order to enable information messages\n    // console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) { return callback(err); }\n    var request = new Request(query, function (err, rows) {\n      if (err) { return callback(err); }\n      console.log('rows: ' + rows);\n      callback(null);\n    });\n    bcrypt.hash(user.password, 10, function (err, hashedPassword) {\n      if (err) { return callback(err); }\n      request.addParameter('Email', TYPES.VarChar, user.email);\n      request.addParameter('Password', TYPES.VarChar, hashedPassword);\n      connection.execSql(request);\n    });\n  });\n}\n```\n\n### Request with Basic Auth\n\n```\nfunction create(user, callback) {\n  const request = require('request');\n  request.post({\n    url: 'https://myserviceurl.com/users',\n    json: user\n    //for more options check:\n    //https://github.com/mikeal/request#requestoptions-callback\n  }, function(err, response, body) {\n    if (err) return callback(err);\n    callback(null);\n  });\n}\n```\n\n## Troubleshoot\n\nIf you are unable to create a user in either your legacy database or Auth0:\n\n1.  Check the `console.log()` statements with the Auth0's [Real-time Webtask Logs extension](https://auth0.com/docs/customize/extensions/real-time-webtask-logs).\n    \n2.  Find the user in your legacy database and delete accordingly. If the partial user state is in Auth0, use the Management API's [Delete a User](https://auth0.com/docs/api/management/v2#!/Users/delete_users_by_id) endpoint or [Delete a Connection User](https://auth0.com/docs/api/management/v2#!/Connections/delete_users_by_email) endpoint.\n    \n3.  Make sure **Import Mode** is disabled, then configure the create script.\n    \n\n## Learn more\n\n*   [Login Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n*   [Get User Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n*   [Delete Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n*   [Verify Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)\n*   [Change Password Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n*   [Change Email Script Template](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)",
    "title": "Create Script Templates",
    "description": "Describes custom database action script templates for user creation.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete",
    "markdown": "# Delete Script Templates\n\nThe Delete script implements the defined function to delete a specified user from an external database. We recommend naming this function `deleteUser`.\n\nThe script is only used in a [legacy authentication scenario](https://auth0.com/docs/authenticate/database-connections/custom-db/overview-custom-db-connections), and is required if you want to delete a user from Auth0 and your external database in the same operation.\n\n## DeleteUser function\n\nThe `deleteUser` function should:\n\n*   Remove the specified user from the external database.\n    \n*   Return a `null` value if the deletion succeeded.\n    \n*   Return an error if the deletion failed.\n    \n\n### Definition\n\nThe `deleteUser` function accepts two parameters and returns a `callback` function:\n\n```\ndeleteUser(id, callback): function\n```\n\n| **Parameter** | **Type** | **Description** |\n| --- | --- | --- |\n| `id` | String | User’s identity `user_id`. Does not start with `auth0`. |\n| `callback` | Function | Used to pass error or profile data through the pipeline. |\n\n### Example\n\nThis is a pseudo-JavaScript example of how you could implement the `deleteUser` function. For language-specific examples, read [Language-specific script examples](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete#language-specific-script-examples).\n\n```\nfunction deleteUser(id, callback) {\n  // Send user identifier to external database API\n  let options = {\n    url: \"https://example.com/api/deleteUser\",\n    body: {\n      id: id\n    }\n  };\n\n  send(options, (err, profileData) => {\n    // Return error in callback if deletion failed\n    if (err) {\n      return callback(new Error(\"My custom error message.\"));\n    }\n\n    // Return null value in callback if deletion succeeded\n    return callback(null);\n  });\n}\n```\n\n## Callback function\n\nThe `callback` function accepts one parameter and returns a function.\n\n### Definition\n\n```\ncallback(error): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n\n### Return a success\n\nIf the user was successfully deleted in your external database, return the `callback` function, and pass a `null` value for the `error` parameter.\n\n#### Example\n\n### Return an error\n\nIf an error occurs, return the `callback` function, and pass relevant error information to the `error` parameter.\n\n#### Example\n\n```\nreturn callback(new Error(\"My custom error message.\"));\n```\n\n## Language-specific script examples\n\nAuth0 provides sample scripts for use with the following languages/technologies:\n\n*   [JavaScript](#javascript)\n    \n*   [ASP.NET Membership Provider (MVC3 - Universal Providers)](#asp-net-membership-provider-mvc3-universal-providers-)\n    \n*   [ASP.NET Membership Provider (MVC4 - Simple Membership)](#asp-net-membership-provider-mvc4-simple-membership-)\n    \n*   [MongoDB](#mongodb)\n    \n*   [MySQL](#mysql)\n    \n*   [PostgreSQL](#postgresql)\n    \n*   [SQL Server](#sql-server)\n    \n*   [Windows Azure SQL Database](#windows-azure-sql-database)\n    \n\n### JavaScript\n\n```\nfunction remove (id, callback) {\n  // This script remove a user from your existing database.\n  // It is executed whenever a user is deleted from the Management API or Auth0 dashboard.\n  //\n  // There are two ways that this script can finish:\n  // 1. The user was removed successfully:\n  //     callback(null);\n  // 2. Something went wrong while trying to reach your database:\n  //     callback(new Error(\"my error message\"));\n  var msg = \"Please implement the Delete script for this database \" +\n       \"connection at https://manage.auth0.com/#/connections/database\";\n  return callback(new Error(msg));\n}\n```\n\n### ASP.NET Membership Provider (MVC3 - Universal Providers)\n\n```\nfunction remove(id, callback) {\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true,\n      // Required to retrieve userId needed for Membership entity creation\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    // console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) return callback(err);\n    executeDelete(['Memberships', 'Users'], function(err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n  });\n  function executeDelete(tables, callback) {\n    const query = tables.map(function(table) {\n      return 'DELETE FROM ' + table + ' WHERE UserId = @UserId';\n    }).join(';');\n    const request = new Request(query, function(err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n    request.addParameter('UserId', TYPES.VarChar, id);\n    connection.execSql(request);\n  }\n}\n```\n\n### ASP.NET Membership Provider (MVC4 - Simple Membership)\n\n```\nfunction remove(id, callback) {\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true,\n      // Required to retrieve userId needed for Membership entity creation\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  connection.on('debug', function (text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    // console.log(text);\n  }).on('errorMessage', function (text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    executeDelete(['webpages_Membership', 'UserProfile'], function (err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n  });\n  function executeDelete(tables, callback) {\n    const query = tables.map(function (table) {\n      return 'DELETE FROM ' + table + ' WHERE UserId = @UserId';\n    }).join(';');\n    const request = new Request(query, function (err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n    request.addParameter('UserId', TYPES.VarChar, id);\n    connection.execSql(request);\n  }\n}\n```\n\n### MongoDB\n\n```\nfunction remove(id, callback) {\n  const MongoClient = require('mongodb@3.1.4').MongoClient;\n  const client = new MongoClient('mongodb://user:pass@mymongoserver.com');\n  client.connect(function (err) {\n    if (err) return callback(err);\n    const db = client.db('db-name');\n    const users = db.collection('users');\n    users.remove({ _id: id }, function (err) {\n      client.close();\n      if (err) return callback(err);\n      callback(null);\n    });\n  });\n}\n```\n\n### MySQL\n\n```\nfunction remove(id, callback) {\n  const mysql = require('mysql');\n  const connection = mysql({\n    host: 'localhost',\n    user: 'me',\n    password: 'secret',\n    database: 'mydb'\n  });\n  connection.connect();\n  const query = 'DELETE FROM users WHERE id = ?';\n  connection.query(query, [ id ], function(err) {\n    if (err) return callback(err);\n    callback(null);\n  });\n}\n```\n\n### PostgreSQL\n\n```\nfunction remove(id, callback) {\n  //this example uses the \"pg\" library\n  //more info here: https://github.com/brianc/node-postgres\n  const postgres = require('pg');\n  const conString = 'postgres://user:pass@localhost/mydb';\n  postgres.connect(conString, function (err, client, done) {\n    if (err) return callback(err);\n    const query = 'DELETE FROM users WHERE id = $1';\n    client.query(query, [id], function (err) {\n      // NOTE: always call `done()` here to close\n      // the connection to the database\n      done();\n      return callback(err);\n    });\n  });\n}\n```\n\n### SQL Server\n\n```\nfunction remove(id, callback) {\n  // this example uses the \"tedious\" library\n  // more info here: http://pekim.github.io/tedious/index.html\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName:  'test',\n    password:  'test',\n    server:    'localhost',\n    options:  {\n      database: 'mydb'\n    }\n  });\n  const query = 'DELETE FROM dbo.Users WHERE id = @UserId';\n  connection.on('debug', function (text) {\n    console.log(text);\n  }).on('errorMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const request = new Request(query, function (err) {\n      if (err) return callback(err);\n      callback(null);\n    });\n    request.addParameter('UserId', TYPES.VarChar, id);\n    connection.execSql(request);\n  });\n}\n```\n\n### Windows Azure SQL Database\n\n```\nfunction remove (id, callback) {\n  // this example uses the \"tedious\" library\n  // more info here: http://pekim.github.io/tedious/index.html\n  var Connection = require('tedious@1.11.0').Connection;\n  var Request = require('tedious@1.11.0').Request;\n  var TYPES = require('tedious@1.11.0').TYPES;\n  var connection = new Connection({\n    userName: 'your-user@your-server-id.database.windows.net',\n    password: 'the-password',\n    server: 'your-server-id.database.windows.net',\n    options: {\n      database: 'mydb',\n      encrypt: true\n    }\n  });\n  connection.on('debug', function (text) {\n    console.log(text);\n  }).on('errorMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) { return callback(err); }\n    var query = 'DELETE FROM users WHERE id = @UserId';\n    var request = new Request(query, function (err) {\n      if (err) { return callback(err); }\n      callback(null);\n    });\n    request.addParameter('UserId', TYPES.VarChar, id);\n    connection.execSql(request);\n  });\n}\n```\n\n## Learn more\n\n*   [Change Password Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n*   [Create Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n*   [Get User Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n*   [Login Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n*   [Verify Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)\n*   [Change Email Script Template](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)",
    "title": "Delete Script Templates",
    "description": "Describes custom database action script templates for user deletion.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email",
    "markdown": "# Change Email Script Template\n\nThe Change Email script implements the defined function when a user's email address or their email address verification status changes. We recommend naming this function `changeEmail`.\n\nThe script is only used in a [legacy authentication scenario](https://auth0.com/docs/authenticate/database-connections/custom-db/overview-custom-db-connections), and is required if you want to update a user's email address (and/or email address verification status) in Auth0 and your external database in the same operation.\n\nThe Change Email script is not configurable through the Auth0 Dashboard. To manage this script, you must use the Auth0 Management API [Create a connection](https://auth0.com/docs/api/management/v2#!/Connections/post_connections) or [Update a connection](https://auth0.com/docs/api/management/v2#!/Connections/patch_connections_by_id) endpoint, or the [Auth0 Deploy CLI](https://auth0.com/docs/deploy-monitor/deploy-cli-tool).\n\n## ChangeEmail function\n\nThe changeEmail function should:\n\n*   Update the user's email address in the external database.\n    \n*   Return an error if the operation failed or an error occurred.\n    \n\n### Definition\n\nThe `changeEmail` function accepts four parameters and returns a `callback` function:\n\n```\nchangeEmail(email, newEmail, verified, callback): function\n```\n\n| **Parameter** | **Type** | **Description** |\n| --- | --- | --- |\n| `email` | String | User's current email address. |\n| `newEmail` | String | Value to be set as user's new email address in external database. |\n| `verified` | Boolean | Email verification status of the new email address. |\n| `callback` | Function | Used to pass error data through the pipeline. |\n\n### Example\n\nThis is a pseudo-JavaScript example of how you could implement the `changeEmail` function:\n\n```\nfunction (email, newEmail, verified, callback) {\n  // Prepare the API call\n  let options = {\n    url: \"https://example.com/api/users\",\n    action: \"PATCH\",\n    body: {\n      email: email,\n      new_email: newEmail,\n      email_verified: verified\n    }\n  };\n\n  // Call the API\n  send(options, err => {\n    // Return `false` value in callback if operation failed\n    if (err && err.id == \"FAIL_CHANGE_EMAIL\") {\n      return callback(null, false);\n    } else if (err) {\n      // Return error in callback if unspecified error occurred\n      return callback(new Error(\"My custom error message.\"));\n    }\n\n    // Return `true` value in callback if operation succeeded\n    return callback(null, true);\n  });\n```\n\n## Callback function\n\nThe `callback` function accepts two parameters and returns a function.\n\n### Definition\n\n```\ncallback(error, operationResult): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n| `operationResult` | Boolean | Optional | Indicates the result of the change email operation. |\n\n### Return a success\n\nIf the change email operation succeeded, return the `callback` function, and pass a `null` value as the `error` parameter and a `true` value as the `operationResult` parameter:\n\n```\nreturn callback(null, true);\n```\n\n### Return a failure\n\nIf the change email operation failed, return the `callback` function, and pass a `null` value as the `error` parameter and a `false` value as the `operationResult` parameter:\n\n```\nreturn callback(null, false);\n```\n\n### Return an error\n\nIf an error occurred, return the `callback` function, and pass relevant error information as the `error` parameter:\n\n```\nreturn callback(new Error(\"My custom error message.\"));\n```\n\n## Learn more\n\n*   [Change Password Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n*   [Create Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n*   [Delete Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n*   [Get User Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n*   [Login Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n*   [Verify Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)",
    "title": "Change Email Script Template",
    "description": "Describes the custom database action script for changing a user's email.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user",
    "markdown": "# Get User Script Templates\n\nThe Get User script implements the function executed to determine the current state of existence of a user. We recommend naming this function `getUser`.\n\nThis script is required for [automatic migration](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database), and conditionally required for legacy authentication depending on the operations configured for the connection.\n\nIf automatic migration is configured for the connection, the script is executed whenever the following operations occur:\n\n*   Change email\n    \n*   Sign up\n    \n*   Password reset\n    \n\nIf legacy authentication is configured for the connection, the script is executed whenever the following operations occur:\n\n*   Create user\n    \n*   Change email\n    \n*   Change password\n    \n*   Password reset\n    \n\n## Get User function\n\nThe `getUser` function should:\n\n*   Send the user's identifier to the external database's API.\n    \n*   Return the profile data of the user if the user was found.\n    \n*   Return an error if there was an issue determining whether the user exists or not.\n    \n\n### Definition\n\nThe `getUser` function accepts two parameters and returns a `callback` function:\n\n```\ngetUser(email, callback): function\n```\n\n| **Parameter** | **Type** | **Description** |\n| --- | --- | --- |\n| `email` | String | The user's email address. |\n| `callback` | Function | Used to pass error or profile data through the pipeline |\n\n### Example\n\nThis is a pseudo-Javascript example of how you could implement the `getUser` function. For language-specific examples, read [Language-specific script examples](#language-specific-script-examples).\n\n```\nfunction getUser(email, callback) {\n  // Send user identifier to external database API\n  let options = {\n    url: \"https://example.com/api/search-users\",\n    body: {\n      email: email\n    }\n  };\n\n  send(options, (err, profileData) => {\n    // Return error in callback if there was an issue finding the user\n    if (err) {\n      return callback(new Error(\"Could not determine if user exists or not.\"));\n    } else {\n      // Return null in callback if user was not found, return profile data in callback if user was found\n      if (!profileData) {\n        return callback(null);\n      } else {\n        let profile = {\n          email: profileData.email,\n          user_id: profileData.userId\n        };\n\n        return callback(null, profile);\n      }\n    }\n  });\n}\n```\n\n## Callback function\n\nThe `callback` function is used to pass user profile data or error data through the pipeline.\n\n### Definition\n\nThe `callback` function accepts up to two parameters and returns a function:\n\n```\ncallback(error[,profile]): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n| `profile` | Object | Optional | Contains the user's profile data. |\n\n### Return the user profile (user found)\n\nIf the user is found, pass a `null` value to the `error` parameter, and pass the user's profile data to the `profile` parameter in [normalized form](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profile-schema). In addition to the standard fields, you can include the `user_metadata`, `app_metadata`, and `mfa_factors` fields.\n\n#### Example\n\n```\nreturn callback(null, {\n    username: \"username\",\n    user_id: \"my-custom-db|username@domain.com\",\n    email: \"username@domain.com\",\n    email_verified: false,\n    user_metadata: {\n        language: \"en\"\n    },\n    app_metadata: {\n        plan: \"full\"\n    },\n    mfa_factors: [\n      {\n        phone: {\n          value: \"+15551234567\"\n        }\n      },\n    ]\n});\n```\n\n### Return no user profile (user not found)\n\nIf the user is not found, pass a `null` value to the `error` parameter, and omit the `profile` parameter.\n\n#### Example\n\n### Return an error\n\nIf an error occurs, pass error data to the `error` parameter with relevant information about what went wrong. For more information, read [Troubleshoot Custom Databases](https://auth0.com/docs/authenticate/database-connections/custom-db/error-handling).\n\n#### Example\n\n```\nreturn callback(new Error(\"My custom error message.\"));\n```\n\n## Language-specific script examples\n\nAuth0 provides sample scripts for use with the following languages/technologies:\n\n*   [JavaScript](#javascript)\n    \n*   [ASP.NET Membership Provider (MVC3 - Universal Providers)](#asp-net-membership-provider-mvc3-universal-providers-)\n    \n*   [ASP.NET Membership Provider (MVC4 - Simple Membership)](#asp-net-membership-provider-mvc4-simple-membership-)\n    \n*   [MongoDB](#mongodb)\n    \n*   [MySQL](#mysql)\n    \n*   [PostgreSQL](#postgresql)\n    \n*   [SQL Server](#sql-server)\n    \n*   [Windows Azure SQL Database](#windows-azure-sql-database)\n    \n*   [Axios](#axios)\n    \n*   [Stormpath](#stormpath)\n    \n\n### JavaScript\n\n```\nfunction getByEmail(email, callback) {\n  // This script should retrieve a user profile from your existing database,\n  // without authenticating the user.\n  // It is used to check if a user exists before executing flows that do not\n  // require authentication (signup and password reset).\n  //\n  // There are three ways this script can finish:\n  // 1. A user was successfully found. The profile should be in the following\n  // format: https://auth0.com/docs/users/normalized/auth0/normalized-user-profile-schema.\n  //     callback(null, profile);\n  // 2. A user was not found\n  //     callback(null);\n  // 3. Something went wrong while trying to reach your database:\n  //     callback(new Error(\"my error message\"));\n  const msg = 'Please implement the Get User script for this database connection ' +\n    'at https://manage.auth0.com/#/connections/database';\n  return callback(new Error(msg));\n}\n```\n\n### ASP.NET Membership Provider (MVC3 - Universal Providers)\n\n```\nfunction getByEmail(email, callback) {\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true // for Windows Azure\n    }\n  });\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    //console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) return callback(err);\n    var user = {};\n    const query =\n      'SELECT Memberships.UserId, Email, Users.UserName ' +\n      'FROM Memberships INNER JOIN Users ' +\n      'ON Users.UserId = Memberships.UserId ' +\n      'WHERE Memberships.Email = @Username OR Users.UserName = @Username';\n    const getMembershipQuery = new Request(query, function(err, rowCount) {\n      if (err) return callback(err);\n      if (rowCount < 1) return callback();\n      callback(null, user);\n    });\n    getMembershipQuery.addParameter('Username', TYPES.VarChar, email);\n    getMembershipQuery.on('row', function(fields) {\n      user = {\n        user_id: fields.UserId.value,\n        nickname: fields.UserName.value,\n        email: fields.Email.value\n      };\n    });\n    connection.execSql(getMembershipQuery);\n  });\n}\n```\n\n### ASP.NET Membership Provider (MVC4 - Simple Membership)\n\n```\nfunction getByEmail(email, callback) {\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true // for Windows Azure\n    }\n  });\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    //console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) return callback(err);\n    var user = {};\n    const query =\n      'SELECT webpages_Membership.UserId, UserName, UserProfile.UserName from webpages_Membership ' +\n      'INNER JOIN UserProfile ON UserProfile.UserId = webpages_Membership.UserId ' +\n      'WHERE UserProfile.UserName = @Username';\n    const getMembershipQuery = new Request(query, function (err, rowCount) {\n      if (err) return callback(err);\n      if (rowCount < 1) return callback();\n      callback(null, user);\n    });\n    getMembershipQuery.addParameter('Username', TYPES.VarChar, email);\n    getMembershipQuery.on('row', function (fields) {\n      user = {\n        user_id: fields.UserId.value,\n        nickname: fields.UserName.value,\n        email: fields.UserName.value\n      };\n    });\n    connection.execSql(getMembershipQuery);\n  });\n}\n```\n\n### MongoDB\n\n```\nfunction getByEmail(email, callback) {\n  const MongoClient = require('mongodb@5.1.0').MongoClient;\n  const client = new MongoClient('mongodb://user:pass@mymongoserver.com');\n  client.connect(function (err) {\n    if (err) return callback(err);\n    const db = client.db('db-name');\n    const users = db.collection('users');\n    users.findOne({ email: email }, function (err, user) {\n      client.close();\n      if (err) return callback(err);\n      if (!user) return callback(null, null);\n      return callback(null, {\n        user_id: user._id.toString(),\n        nickname: user.nickname,\n        email: user.email\n      });\n    });\n  });\n}\n```\n\n### MySQL\n\n```\nfunction getByEmail(email, callback) {\n  const mysql = require('mysql');\n  const connection = mysql({\n    host: 'localhost',\n    user: 'me',\n    password: 'secret',\n    database: 'mydb'\n  });\n  connection.connect();\n  const query = 'SELECT id, nickname, email FROM users WHERE email = ?';\n  connection.query(query, [ email ], function(err, results) {\n    if (err || results.length === 0) return callback(err || null);\n    const user = results[0];\n    callback(null, {\n      user_id: user.id.toString(),\n      nickname: user.nickname,\n      email: user.email\n    });\n  });\n}\n```\n\n### PostgreSQL\n\n```\nfunction loginByEmail(email, callback) {\n  //this example uses the \"pg\" library\n  //more info here: https://github.com/brianc/node-postgres\n  const postgres = require('pg');\n  const conString = 'postgres://user:pass@localhost/mydb';\n  postgres.connect(conString, function (err, client, done) {\n    if (err) return callback(err);\n    const query = 'SELECT id, nickname, email FROM users WHERE email = $1';\n    client.query(query, [email], function (err, result) {\n      // NOTE: always call `done()` here to close\n      // the connection to the database\n      done();\n      if (err || result.rows.length === 0) return callback(err);\n      const user = result.rows[0];\n      return callback(null, {\n        user_id: user.id,\n        nickname: user.nickname,\n        email: user.email\n      });\n    });\n  });\n}\n```\n\n### SQL Server\n\n```\nfunction getByEmail(email, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName:  'test',\n    password:  'test',\n    server:    'localhost',\n    options:  {\n      database: 'mydb'\n    }\n  });\n  const query = 'SELECT Id, Nickname, Email FROM dbo.Users WHERE Email = @Email';\n  connection.on('debug', function (text) {\n    console.log(text);\n  }).on('errorMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const request = new Request(query, function (err, rowCount, rows) {\n      if (err) return callback(err);\n      callback(null, {\n        user_id: rows[0][0].value,\n        nickname: rows[0][1].value,\n        email: rows[0][2].value\n      });\n    });\n    request.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(request);\n  });\n}\n```\n\n### Windows Azure SQL Database\n\n```\nfunction getByEmail (name, callback) {\n  var profile = {\n    user_id:     \"103547991597142817347\",\n    nickname:    \"johnfoo\",\n    email:       \"johnfoo@gmail.com\",\n    name:        \"John Foo\",\n    given_name:  \"John\",\n    family_name: \"Foo\"\n  };\n  callback(null, profile);\n}\n```\n\n### Axios\n\n```\nasync function getUserAsync(email, callback) {\n  //should be updated as new versions of axios are made available (https://auth0-extensions.github.io/canirequire/#axios)\n  const axios = require(\"axios@0.22.0\");\n\n  let response;\n\n  try {\n    response = await axios.post(\n      //store API url in connection settings to better support SDLC environments\n      configuration.baseAPIUrl + \"/getUser\",\n      //user credentials passed as request body\n      {\n        email: email,\n      },\n      {\n        timeout: 10000, //end call gracefully if request times out so script can do necessary callback\n        headers: {\n          //securing api call with apiKey stored in connection settings.\n          //quick and easy approach however using M2M tokens is more secure as\n          // a secret must not be shared between client and API.\n          \"x-api-key\": configuration.apiKey,\n        },\n      }\n    );\n  } catch (e) {\n    if (e.response.status === 404) {\n      //assuming api returns 404 when no user with specified email/username found\n      return callback(null, null);\n    }\n    //callback for any other error type\n    return callback(new Error(e.message));\n  }\n\n  try {\n    let user = response.data;\n\n    //if using multiple custom db connections in your tenant prefix the\n    //user_id with a connection specific key ex: \"connName|\" + user.user_id\n    //this ensures unique user ids across all db connections\n    return callback(null, {\n      user_id: user.user_id,\n      email: user.email,\n    });\n  } catch (e) {\n    return callback(new Error(e.message));\n  }\n}\n```\n\n### Stormpath\n\n```\nfunction getByEmail(email, callback) {\n  // Replace the {yourStormpathClientId} with your Stormpath ID\n  var url = 'https://api.stormpath.com/v1/applications/{yourStormpathClientId}/accounts';\n  // Add your Stormpath API Client ID and Secret\n  var apiCredentials = {\n    user : '{yourStormpathApiId}',\n    password: '{yourStormpathApiSecret}'\n  };\n  // Make a GET request to find a user by email\n  request({\n    url: url,\n    method: 'GET',\n    auth: apiCredentials,\n    qs: { q: email },\n    json: true\n  }, function (error, response, body) {\n    if (response.statusCode !== 200) return callback();\n    var user = body.items[0];\n    if (!user) return callback();\n    var id = user.href.replace('https://api.stormpath.com/v1/accounts/', '');\n    return callback(null, {\n      user_id: id,\n      username: user.username,\n      email: user.email,\n      email_verified: true\n      // Add any additional fields you would like to carry over from Stormpath\n    });\n  });\n}\n```\n\n## Learn more\n\n*   [Change Password Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n*   [Create Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n*   [Delete Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n*   [Login Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n*   [Verify Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)\n*   [Change Email Script Template](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)",
    "title": "Get User Script Templates",
    "description": "Describes custom database action script templates for user search.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/login-pages/classic-login",
    "markdown": "# Customize Classic Login\n\nClassic Login is an Auth0-hosted login experience that relies on JavaScript for customization. Implementing Classic Login is less complex than embedding the authentication process directly in your app, and it can help prevent the dangers of cross-origin authentication.\n\nClassic Login serves as an alternative to [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience). For a feature comparison between the two login experiences, review [Universal Login vs. Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login).",
    "title": "Customize Classic Login",
    "description": "Learn how to customize the Classic Login experience",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/execution",
    "markdown": "# Custom Database Action Script Execution Best Practices\n\nA custom database connection type allows you to configure action scripts, which contain custom code Auth0 uses to interface with your legacy identity store. Action scripts are a named JavaScript function that accepts a predefined set of parameters.\n\n## Webtask containers\n\nAction scripts execute within an individual Webtask container with an execution limit of approximately 20 seconds. After the functions execute, the container is recycled.\n\nWhen a container is recycled, it terminates the action script’s pending operations. This may result in an error condition being returned and a potential reset of the `global` object. For more information on the `global` object, read [Custom Database Action Script Environment Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/environment).\n\n## Asynchronous features\n\nAsynchronous features of JavaScript, including [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) objects and [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function), are supported in action scripts.\n\nYou can use asynchronous features to execute non-blocking operations within an action script, but make sure that these operations do not exceed the execution limit of the Webtask container. When the Webtask container is recycled, it will terminate any pending operations, which may result in unexpected behavior or an error.\n\nIf you are making a call to an external service or API within your action script, set the function to time out after a reasonable duration, and [return an error](#error-handling) if the external service or API cannot be reached.\n\n### Examples\n\nAuth0 supports using [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) objects and [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) within action scripts.\n\n#### Promise object\n\nThis example uses the built-in JavaScript `fetch` method, which gets a resource from a network then returns a Promise object, written using [promise chains](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#chaining).\n\n```\nfunction login(userNameOrEmail, password, callback) {\n\tconst hashedPassword = hash(password);\n\tconst apiEndpoint = 'https://example.com/api/authenticate';\n\tconst options = {\n\t\tmethod: 'POST',\n\t\tbody: {\n\t\t\temail: userNameOrEmail,\n\t\t\tpassword: hashedPassword\n\t\t}\n\t};\n\n\tfetch(apiEndpoint, options) \n\t\t.then((response) => {\n\t\t\tif (!response.ok) {\n\t\t\t\treturn callback(new Error(`HTTP error! Status: ${response.status}`));\n\t\t\t}\n\n\t\t\treturn response.json();\n\t\t})\n\t\t.then((response) => {\n\t\t\tif (response.err) {\n\t\t\t\treturn callback(new Error(`Error authenticating user: ${err}`));\n\t\t\t}\n\n\t\t\tlet profile = {\n\t\t\t\temail: response.profileData.email,\n\t\t\t\tusername: response.profileData.username\n\t\t\t};\n\n\t\t\treturn callback(null, profile);\n\t\t})\n\t\t.catch((err) => {\n\t\t\treturn callback(new Error(`An error occurred: ${err}`));\n\t\t});\n  }\n```\n\n#### Async function\n\nThis example uses the built-in JavaScript `fetch` method, which gets a resource from a network then returns a Promise object, written using [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).\n\n```\nasync function login(userNameOrEmail, password, callback) {\n\tconst hashedPassword = hash(password);\n\tconst apiEndpoint = 'https://example.com/api/authenticate';\n\tconst options = {\n\t\tmethod: 'POST',\n\t\tbody: {\n\t\t\temail: userNameOrEmail,\n\t\t\tpassword: hashedPassword\n\t\t}\n\t};\n\n\tconst response = await fetch(apiEndpoint, options);\n\n\tif (!response.ok) {\n\t\treturn callback(new Error(`HTTP error! Status: ${response.status}`));\n\t}\n\n\tconst result = response.json();\n\n\tif (result.err) {\n\t\treturn callback(new Error(`Error authenticating user: ${err}`));\n\t}\n\n\tlet profile = {\n\t\temail: response.profileData.email,\n\t\tusername: response.profileData.username\n\t};\n\n\treturn callback(null, profile);\n}\n```\n\n## Callback function\n\nThe `callback` function signals the action script’s operation is complete and must be called exactly once. An action script should complete immediately after a call to the `callback` function, preferably by explicitly using the `return` statement.\n\n### Asynchronous processing\n\nIf an action script uses asynchronous processing, then the `callback` function must be called after all asynchronous operations complete.\n\n### Parameters\n\nIf the `callback` function is called with no parameters, it will be executed as if a `null` parameter had been provided.\n\n## Size\n\nThe total size of implementation for any action script must not exceed 100kB. This size limitation excludes imported `npm` modules. For more information on `npm` modules, read [Custom Database Action Script Environment Best Practices](https://auth0.com/docs/authenticate/database-connections/custom-db/custom-database-connections-scripts/environment).\n\nThe larger the size of a script, the more latency is introduced based on the packaging and transport process employed by the Webtask platform. The size impacts the performance of the system.\n\n## Anonymous functions\n\nAction scripts can be implemented as anonymous functions, but it is not recommended that you do so. Anonymous functions make it difficult to debug the action script and interpret the call-stack generated as a result of any exceptional error condition. To learn more about anonymous functions, read [IIFE on MDN Web Docs](https://developer.mozilla.org/en-US/docs/Glossary/IIFE).\n\n## Error handling\n\nPass an `Error` object to the `callback` function with a descriptive message of the error:\n\n```\nreturn callback(new Error('My custom error message'));\n```\n\n## Security\n\n### Database interface vs. API\n\nEnsure to secure all communications between Auth0 and your legacy identity store. If your legacy identity store does not already have an API implemented, it is highly recommended that you do so.\n\nIf your legacy identity store has an API available, you can [register the API](https://auth0.com/docs/get-started/auth0-overview/set-up-apis) through Auth0, and [create an Action](https://auth0.com/docs/manage-users/access-control/sample-use-cases-actions-with-authorization#deny-access-to-anyone-calling-an-api) to restrict access from end users.\n\nIf your legacy identity store does not have an API available—and implementing one is not feasible—you can still communicate with your database directly. Make sure to [add Auth0 IP addresses to your firewall’s allow list](https://auth0.com/docs/secure/security-guidance/data-security/allowlist) to allow inbound traffic from Auth0.\n\n## Identity provider tokens\n\nIf the `user` object returns the `access_token` and `refresh_token` properties, Auth0 handles them differently from other types of user information. Auth0 stores them in the `user` object's `identities` property:\n\n```\n{\n    \"email\": \"you@example.com\",\n    \"updated_at\": \"2019-03-15T15:56:44.577Z\",\n    \"user_id\": \"auth0|some_unique_id\",\n    \"nickname\": \"a_nick_name\",\n    \"identities\": [ \n        {\n            \"user_id\": \"some_unique_id\",\n            \"access_token\": \"e1b5.................92ba\",\n            \"refresh_token\": \"a90c.................620b\",\n            \"provider\": \"auth0\", \"connection\": \"custom_db_name\",\n            \"isSocial\": false \n        }\n  ], \n  \"created_at\": \"2019-03-15T15:56:44.577Z\",\n  \"last_ip\": \"192.168.1.1\",\n  \"last_login\": \"2019-03-15T15:56:44.576Z\",\n  \"logins_count\": 3\n}\n```\n\nIf you want to retrieve either of these properties with the Auth0 Management API, include the `read:user_idp_tokens` scope when [requesting an Access Token](https://auth0.com/docs/secure/tokens/access-tokens/get-management-api-access-tokens-for-production).",
    "title": "Custom Database Action Script Execution Best Practices",
    "description": "Learn about best practices for custom database action script execution.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/login-pages/universal-login",
    "markdown": "# Customize Universal Login\n\n[Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) provides the essential feature of an authorization server: the login flow. When a user needs to prove their identity to gain access to your application, you can redirect them to Universal Login and let Auth0 handle the authentication process.\n\nConfiguring Universal Login is dynamic and does not require any application-level changes, as web pages hosted on Auth0’s centralized authentication server completely drive the login flow. Additionally, you don’t need to manually update your code for your applications to benefit from improvements Auth0 makes to Universal Login.\n\nFrom the Auth0 Dashboard, you can customize the appearance and behavior of login pages to create a consistent, branded experience. For advanced use cases, you can also change the code of each page individually.",
    "title": "Customize Universal Login",
    "description": "An overview of Universal Login customization",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify",
    "markdown": "# Verify Script Templates\n\nThe Verify script implements the function executed to mark the verification status of a user’s email address in an external database. We recommend naming this function `verify`.\n\nThis script is only used in legacy authentication scenarios, and is required to support user email address verification. A verified email address is critical to a number of workflow scenarios in Auth0, and implementing this script will provide support for these out of the box.\n\nIf it's enabled, this script is executed when a user clicks on the link in the verification email sent by Auth0.\n\n## Verify function\n\nThe `verify` function should:\n\n*   Update the `email_verified` (or equivalent) attribute in the user's profile in the external database.\n    \n*   Return `true` if the update action succeeded.\n    \n*   Return an error if the update action failed.\n    \n\n### Definition\n\nThe `verify` function accepts two parameters and returns a `callback` function:\n\n```\nverify(email, callback): function\n```\n\n| **Parameter** | **Type** | **Description** |\n| --- | --- | --- |\n| `email` | String | User's email address. |\n| `callback` | Function | Used to pass error or profile data through the pipeline. |\n\n### Example\n\nThis is a pseudo-JavaScript example of how you could implement the `login` function. For language-specific examples, read [Language-specific script examples](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify#language-specific-script-examples).\n\n```\nfunction verify(email, callback) {\n  // Send email to external database API\n  let options = {\n    url: \"https://example.com/api/verify\",\n    body: {\n      email: email\n    }\n  };\n\n  send(options, (err) => {\n    // Return error in callback if update failed\n    if (err) {\n      return callback(new Error(email, \"My custom error message.\"));\n    } else {\n      // Return true in callback if update succeeded\n      return callback(null, true);\n    }\n  });\n}\n```\n\n## Callback function\n\nThe `callback` function is used to pass user profile data or error data through the pipeline.\n\n### Definition\n\nThe `callback` function accepts up to two parameters and returns a function:\n\n```\ncallback(error, [verified]): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n| `verified` | Boolean | Optional | Contains value that represents the user's verification status in the external database (`true` or `false`). Only required if the value is `true`. |\n\n### Return a success\n\nIf the user's verification status was updated successfully in the external database, pass a `null` value for the `error` parameter, and a `true` value for the `verified` parameter.\n\n#### Example\n\n### Return an error\n\nIf an error occurs, the `error` parameter should contain relevant information about what went wrong.\n\n#### Example\n\n```\nreturn callback(new Error(\"My custom error message.\"));\n```\n\n## Language-specific script examples\n\nAuth0 provides sample scripts for use with the following languages/technologies:\n\n*   [JavaScript](#javascript)\n    \n*   [ASP.NET Membership Provider (MVC3 - Universal Providers)](#asp-net-membership-provider-mvc3-universal-providers-)\n    \n*   [ASP.NET Membership Provider (MVC4 - Simple Membership)](#asp-net-membership-provider-mvc4-simple-membership-)\n    \n*   [MongoDB](#mongodb)\n    \n*   [MySQL](#mysql)\n    \n*   [PostgreSQL](#postgresql)\n    \n*   [SQL Server](#sql-server)\n    \n*   [Windows Azure SQL Database](#windows-azure-sql-database)\n    \n\n### JavaScript\n\n```\nfunction verify(email, callback) {\n  // This script should mark the current user's email address as verified in\n  // your database.\n  // It is executed whenever a user clicks the verification link sent by email.\n  // These emails can be customized at https://manage.auth0.com/#/emails.\n  // It is safe to assume that the user's email already exists in your database,\n  // because verification emails, if enabled, are sent immediately after a\n  // successful signup.\n  //\n  // There are two ways that this script can finish:\n  // 1. The user's email was verified successfully\n  //     callback(null, true);\n  // 2. Something went wrong while trying to reach your database:\n  //     callback(new Error(\"my error message\"));\n  //\n  // If an error is returned, it will be passed to the query string of the page\n  // where the user is being redirected to after clicking the verification link.\n  // For example, returning `callback(new Error(\"error\"))` and redirecting to\n  // https://example.com would redirect to the following URL:\n  //     https://example.com?email=alice%40example.com&message=error&success=false\n  const msg = 'Please implement the Verify script for this database connection ' +\n    'at https://manage.auth0.com/#/connections/database';\n  return callback(new Error(msg));\n}\n```\n\n### ASP.NET Membership Provider (MVC3 - Universal Providers)\n\n```\nfunction verify(email, callback) {\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true,\n      // Required to retrieve userId needed for Membership entity creation\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    //console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) return callback(err);\n    verifyMembershipUser(email, function(err, wasUpdated) {\n      if (err) return callback(err); // this will return a 500\n      callback(null, wasUpdated);\n    });\n  });\n  function verifyMembershipUser(email, callback) {\n    // isApproved field is the email verification flag\n    const updateMembership =\n      'UPDATE Memberships SET isApproved = \\'true\\' ' +\n      'WHERE isApproved = \\'false\\' AND Email = @Email';\n    const updateMembershipQuery = new Request(updateMembership, function(err, rowCount) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, rowCount > 0);\n    });\n    updateMembershipQuery.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(updateMembershipQuery);\n  }\n}\n```\n\n### ASP.NET Membership Provider (MVC4 - Simple Membership)\n\n```\nfunction verify (email, callback) {\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true,\n      // Required to retrieve userId needed for Membership entity creation\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    //console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    verifyMembershipUser(email, function(err, wasUpdated) {\n      if (err) return callback(err); // this will return a 500\n      callback(null, wasUpdated);\n    });\n  });\n  function findUserId(email, callback) {\n    const findUserIdFromEmail =\n      'SELECT UserProfile.UserId FROM ' +\n      'UserProfile INNER JOIN webpages_Membership ' +\n      'ON UserProfile.UserId = webpages_Membership.UserId ' +\n      'WHERE UserName = @Username';\n    const findUserIdFromEmailQuery = new Request(findUserIdFromEmail, function (err, rowCount, rows) {\n      if (err || rowCount < 1) return callback(err);\n      const userId = rows[0][0].value;\n      callback(null, userId);\n    });\n    findUserIdFromEmailQuery.addParameter('Username', TYPES.VarChar, email);\n    connection.execSql(findUserIdFromEmailQuery);\n  }\n  function verifyMembershipUser(email, callback) {\n    findUserId(email, function (err, userId) {\n      if (err || !userId) return callback(err);\n      // isConfirmed field is the email verification flag\n      const updateMembership =\n        'UPDATE webpages_Membership SET isConfirmed = \\'true\\' ' +\n        'WHERE isConfirmed = \\'false\\' AND UserId = @UserId';\n      const updateMembershipQuery = new Request(updateMembership, function (err, rowCount) {\n        return callback(err, rowCount > 0);\n      });\n      updateMembershipQuery.addParameter('UserId', TYPES.VarChar, userId);\n      connection.execSql(updateMembershipQuery);\n    });\n  }\n}\n```\n\n### MongoDB\n\n```\nfunction verify (email, callback) {\n  const MongoClient = require('mongodb@3.1.4').MongoClient;\n  const client = new MongoClient('mongodb://user:pass@mymongoserver.com');\n  client.connect(function (err) {\n    if (err) return callback(err);\n    const db = client.db('db-name');\n    const users = db.collection('users');\n    const query = { email: email, email_verified: false };\n    users.update(query, { $set: { email_verified: true } }, function (err, count) {\n      client.close();\n      if (err) return callback(err);\n      callback(null, count > 0);\n    });\n  });\n}\n```\n\n### MySQL\n\n```\nfunction verify(email, callback) {\n  const mysql = require('mysql');\n  const connection = mysql({\n    host: 'localhost',\n    user: 'me',\n    password: 'secret',\n    database: 'mydb'\n  });\n  connection.connect();\n  const query = 'UPDATE users SET email_Verified = true WHERE email_Verified = false AND email = ?';\n  connection.query(query, [ email ], function(err, results) {\n    if (err) return callback(err);\n    callback(null, results.length > 0);\n  });\n}\n```\n\n### PostgreSQL\n\n```\nfunction verify (email, callback) {\n  //this example uses the \"pg\" library\n  //more info here: https://github.com/brianc/node-postgres\n  const postgres = require('pg');\n  const conString = 'postgres://user:pass@localhost/mydb';\n  postgres.connect(conString, function (err, client, done) {\n    if (err) return callback(err);\n    const query = 'UPDATE users SET email_Verified = true WHERE email_Verified = false AND email = $1';\n    client.query(query, [email], function (err, result) {\n      // NOTE: always call `done()` here to close\n      // the connection to the database\n      done();\n      return callback(err, result && result.rowCount > 0);\n    });\n  });\n}\n```\n\n### SQL Server\n\n```\nfunction verify (email, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  const sqlserver = require('tedious@1.11.0');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName:  'test',\n    password:  'test',\n    server:    'localhost',\n    options:  {\n      database: 'mydb'\n    }\n  });\n  const query = 'UPDATE dbo.Users SET Email_Verified = true WHERE Email_Verified = false AND Email = @Email';\n  connection.on('debug', function(text) {\n    console.log(text);\n  }).on('errorMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const request = new Request(query, function (err, rows) {\n      if (err) return callback(err);\n      callback(null, rows > 0);\n    });\n    request.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(request);\n  });\n}\n```\n\n### Windows Azure SQL Database\n\n```\nfunction verify (email, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  var Connection = require('tedious@1.11.0').Connection;\n  var Request = require('tedious@1.11.0').Request;\n  var TYPES = require('tedious@1.11.0').TYPES;\n  var connection = new Connection({\n    userName:  'your-user@your-server-id.database.windows.net',\n    password:  'the-password',\n    server:    'your-server-id.database.windows.net',\n    options:  {\n      database: 'mydb',\n      encrypt:  true\n    }\n  });\n  var query =\n    'UPDATE Users SET Email_Verified=\\'TRUE\\' ' +\n    'WHERE Email_Verified=\\'FALSE\\' AND Email=@Email';\n  connection.on('debug', function(text) {\n    // Uncomment next line in order to enable debugging messages\n    // console.log(text);\n  }).on('errorMessage', function(text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function(text) {\n    // Uncomment next line in order to enable information messages\n    // console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) { return callback(err); }\n    var request = new Request(query, function (err, rows) {\n      if (err) { return callback(err); }\n      console.log('rows: ' + rows);\n      callback(null, rows > 0);\n    });\n    request.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(request);\n  });\n}\n```\n\n## Learn more\n\n*   [Login Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login)\n*   [Get User Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n*   [Create Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n*   [Delete Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n*   [Change Password Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n*   [Change Email Script Template](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)",
    "title": "Verify Script Templates",
    "description": "Describes custom database action script templates for user email verification.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/database-connections/custom-db/templates/login",
    "markdown": "# Login Script Templates\n\nThe Login script implements the function executed each time a user is required to authenticate. We recommend naming this function `login`.\n\nThis script is required for both legacy authentication and for [automatic migration](https://auth0.com/docs/manage-users/user-migration/configure-automatic-migration-from-your-database). If automatic migration is configured for the connection, the migration process will be triggered after the first time the user logs in successfully.\n\n## Login function\n\nThe `login` function should:\n\n*   Send the provided user credentials to the external database’s API.\n    \n*   Return the profile data of the user if authentication is successful.\n    \n*   Return an error if authentication is unsuccessful.\n    \n\n### Definition\n\nThe `login` function accepts three parameters and returns a `callback` function:\n\n```\nlogin(userNameOrEmail, password, callback): function\n```\n\n| **Parameter** | **Type** | **Description** |\n| --- | --- | --- |\n| `userNameOrEmail` | String | The user's username or email. |\n| `password` | String | The user's password in plain text. |\n| `callback` | Function | Used to pass error or profile data through the pipeline. |\n\n### Example\n\nThis is a pseudo-JavaScript example of how you could implement the `login` function. For language-specific examples, read [Language-specific script examples](#language-specific-script-examples).\n\n```\nfunction login(userNameOrEmail, password, callback) {\n  // Send credentials to external database API\n  let hashedPassword = hash(password);\n\n  let options = {\n    url: \"https://example.com/api/authenticate\",\n    body: {\n      email: userNameOrEmail,\n      password: hashedPassword\n    }\n  };\n\n  send(options, (err, profileData) => {\n    // Return error in callback if authentication is unsuccessful\n    if (err) {\n      return callback(new WrongUsernameOrPasswordError(userNameOrEmail, \"My custom error message.\"));\n    } else {\n      // Return profile data in callback if authentication is successful\n      let profile = {\n        username: profileData.username,\n        email: profileData.emailAddress,\n        user_id: profileData.userId\n      };\n\n      return callback(null, profile);\n    }\n  });\n}\n```\n\n### Encryption\n\nEncrypt the `password` value using a cryptographic hash encryption library such as `bcrypt` to prevent any potential data leak.\n\n#### Example\n\n```\nbcrypt.hash(password, 10, function (err, hash) {\n    if (err) {\n        return callback(err);\n    } else {\n        // Return hashed password\n    }\n});\n```\n\n## Callback function\n\nThe `callback` function is used to pass user profile data or error data through the pipeline.\n\n### Definition\n\nThe `callback` function accepts up to two parameters and returns a function:\n\n```\ncallback(error[, profile]): function\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `error` | Object | Required | Contains error data. |\n| `profile` | Object | Optional | Contains the user's profile data. |\n\n### Return the user profile\n\nIf the user authenticates successfully, their profile data must be returned in the `profile` object in [normalized form](https://auth0.com/docs/manage-users/user-accounts/user-profiles/normalized-user-profile-schema). In addition to the standard fields, you can include the `user_metadata`, `app_metadata`, and `mfa_factors` fields.\n\n#### Example\n\n```\nreturn callback(null, {\n    username: \"username\",\n    user_id: \"my-custom-db|username@domain.com\",\n    email: \"username@domain.com\",\n    email_verified: false,\n    user_metadata: {\n        language: \"en\"\n    },\n    app_metadata: {\n        plan: \"full\"\n    },\n    mfa_factors: [\n      {\n        phone: {\n          value: \"+15551234567\"\n        }\n      },\n    ]\n});\n```\n\n### Return an error\n\nIf an error occurs, the `error` parameter should contain relevant information about what went wrong.\n\n#### WrongUsernameOrPasswordError type object\n\nThe `WrongUsernameOrPasswordError` custom error type object allows you to pass data that will be displayed in your [Tenant Logs](https://auth0.com/docs/deploy-monitor/logs).\n\n##### Constructor\n\nThe `WrongUsernameOrPasswordError` constructor accepts up to two parameters:\n\n```\nnew WrongUsernameOrPasswordError(userNameOrEmail[, message]): WrongUsernameOrPasswordError\n```\n\n| **Parameter** | **Type** | **Required** | **Description** |\n| --- | --- | --- | --- |\n| `userNameOrEmail` | String | Required | Contains the user's username or email, or a `null` value. |\n| `message` | String | Optional | Contains information about the error. |\n\n#### Return error with username or email\n\nIf you return an error with a value for the `userNameOrEmail` field, Auth0 will record an `fp` tenant log event.\n\n##### Example\n\n```\nreturn callback(new WrongUsernameOrPasswordError(userNameOrEmail, \"My custom error message\"));\n```\n\n| **Tenant Log Event Field** | **Value** |\n| --- | --- |\n| **Code** | `fp` |\n| **Event** | Failed Login (Incorrect Password) |\n| **Description** | `My custom error message` |\n\n#### Return error without username or email\n\nIf you return an error with a `null` value for the `userNameOrEmail` field, Auth0 will record an `fu` tenant log event.\n\n##### Example\n\n```\nreturn callback(new WrongUsernameOrPasswordError(null, \"My custom error message\"));\n```\n\n| **Tenant Log Event Field** | **Value** |\n| --- | --- |\n| **Code** | `fu` |\n| **Event** | Failed Login (Invalid Email/Username) |\n| **Description** | `My custom error message` |\n\n## Sync user profile attributes at each login\n\nEnable the **Sync user profile attributes at each login** setting if you want Auth0 to update the `name`, `nickname`, `given_name`, `family_name`, and/or `picture` fields with the values returned from the external database on each login.\n\nIf you do not enable this setting, the values returned from the external database the first time the user logs in will persist on subsequent logins, even if they've changed in the external database.\n\n## Language-specific script examples\n\nAuth0 provides sample scripts for use with the following languages/technologies:\n\n*   [JavaScript](#javascript)\n    \n*   [ASP.NET Membership Provider (MVC3 - Universal Providers)](#asp-net-membership-provider-mvc3-universal-providers-)\n    \n*   [ASP.NET Membership Provider (MVC4 - Simple Membership)](#asp-net-membership-provider-mvc4-simple-membership-)\n    \n*   [MongoDB](#mongodb)\n    \n*   [MySQL](#mysql)\n    \n*   [PostgreSQL](#postgresql)\n    \n*   [SQL Server](#sql-server)\n    \n*   [Windows Azure SQL Database](#windows-azure-sql-database)\n    \n*   [Axios](#axios)\n    \n*   [Stormpath](#stormpath)\n    \n\n### JavaScript\n\n```\nfunction login(email, password, callback) {\n  // This script should authenticate a user against the credentials stored in\n  // your database.\n  // It is executed when a user attempts to log in or immediately after signing\n  // up (as a verification that the user was successfully signed up).\n  //\n  // Everything returned by this script will be set as part of the user profile\n  // and will be visible by any of the tenant admins. Avoid adding attributes\n  // with values such as passwords, keys, secrets, etc.\n  //\n  // The `password` parameter of this function is in plain text. It must be\n  // hashed/salted to match whatever is stored in your database. For example:\n  //\n  //     var bcrypt = require('bcrypt@0.8.5');\n  //     bcrypt.compare(password, dbPasswordHash, function(err, res)) { ... }\n  //\n  // There are three ways this script can finish:\n  // 1. The user's credentials are valid. The returned user profile should be in\n  // the following format: https://auth0.com/docs/users/normalized/auth0/normalized-user-profile-schema\n  //     var profile = {\n  //       user_id: ..., // user_id is mandatory\n  //       email: ...,\n  //       [...]\n  //     };\n  //     callback(null, profile);\n  // 2. The user's credentials are invalid\n  //     callback(new WrongUsernameOrPasswordError(email, \"my error message\"));\n  // 3. Something went wrong while trying to reach your database\n  //     callback(new Error(\"my error message\"));\n  //\n  // A list of Node.js modules which can be referenced is available here:\n  //\n  //    https://tehsis.github.io/webtaskio-canirequire/\n  const msg = 'Please implement the Login script for this database connection ' +\n    'at https://manage.auth0.com/#/connections/database';\n  return callback(new Error(msg));\n}\n```\n\n### ASP.NET Membership Provider (MVC3 - Universal Providers)\n\n```\nfunction login(email, password, callback) {\n  const crypto = require('crypto');\n  const sqlserver = require('tedious@11.0.3');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true // for Windows Azure\n    }\n  });\n  /**\n   * hashPassword\n   *\n   * This function creates a hashed version of the password to store in the database.\n   *\n   * @password  {[string]}      the password entered by the user\n   * @return    {[string]}      the hashed password\n   */\n  function hashPassword(password, salt) {\n    // the default implementation uses HMACSHA256 and since Key length is 64\n    // and default salt is 16 bytes, Membership will fill the buffer repeating the salt\n    const key = Buffer.concat([salt, salt, salt, salt]);\n    const hmac = crypto.createHmac('sha256', key);\n    hmac.update(Buffer.from(password, 'ucs2'));\n    return hmac.digest('base64');\n  }\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    //console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) return callback(err);\n    getMembershipUser(email, function(err, user) {\n      if (err || !user || !user.profile || !user.password) return callback(err || new WrongUsernameOrPasswordError(email));\n      const salt = Buffer.from(user.password.salt, 'base64');\n      if (hashPassword(password, salt).toString('base64') !== user.password.password) {\n        return callback(new WrongUsernameOrPasswordError(email));\n      }\n      callback(null, user.profile);\n    });\n  });\n\n  // Membership Provider implementation used on Microsoft.AspNet.Providers NuGet\n  /**\n   * getMembershipUser\n   *\n   * This function gets a username or email and returns a the user membership provider\n   * info, password hashes and salt\n   *\n   * @usernameOrEmail  {[string]}       the username or email, the method will do a\n   *                                    query on both with an OR\n   *\n   * @callback         {[Function]}     first argument will be the Error if any,\n   *                                    and second argument will be a user object\n   */\n  function getMembershipUser(usernameOrEmail, done) {\n    var user = null;\n    const query =\n      'SELECT Memberships.UserId, Email, Users.UserName, Password ' +\n      'FROM Memberships INNER JOIN Users ' +\n      'ON Users.UserId = Memberships.UserId ' +\n      'WHERE Memberships.Email = @Username OR Users.UserName = @Username';\n    const getMembershipQuery = new Request(query, function(err, rowCount) {\n      if (err || rowCount < 1) return done(err);\n      done(err, user);\n    });\n    getMembershipQuery.addParameter('Username', TYPES.VarChar, usernameOrEmail);\n    getMembershipQuery.on('row', function(fields) {\n      user = {\n        profile: {\n          user_id: fields.UserId.value,\n          nickname: fields.UserName.value,\n          email: fields.Email.value,\n        },\n        password: {\n          password: fields.Password.value,\n          salt: fields.PasswordSalt.value\n        }\n      };\n    });\n    connection.execSql(getMembershipQuery);\n  }\n}\n```\n\n### ASP.NET Membership Provider (MVC4 - Simple Membership)\n\n```\nfunction login(email, password, callback) {\n  const crypto = require('crypto');\n  const sqlserver = require('tedious@11.0.3');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName: 'the username',\n    password: 'the password',\n    server: 'the server',\n    options: {\n      database: 'the db name',\n      encrypt: true // for Windows Azure\n    }\n  });\n  function fixedTimeComparison(a, b) {\n    var mismatch = (a.length === b.length ? 0 : 1);\n    if (mismatch) {\n      b = a;\n    }\n    for (var i = 0, il = a.length; i < il; ++i) {\n      const ac = a.charCodeAt(i);\n      const bc = b.charCodeAt(i);\n      mismatch += (ac === bc ? 0 : 1);\n    }\n    return (mismatch === 0);\n  }\n\n  /**\n   * validatePassword\n   *\n   * This function gets the password entered by the user, and the original password\n   * hash and salt from database and performs an HMAC SHA256 hash.\n   *\n   * @password      {[string]}      the password entered by the user\n   * @originalHash  {[string]}      the original password hashed from the database\n   *                                (including the salt).\n   * @return        {[bool]}        true if password validates\n   */\n  function validatePassword(password, originalHash, callback) {\n    const iterations = 1000;\n    const hashBytes = Buffer.from(originalHash, 'base64');\n    const salt = hashBytes.slice(1, 17);\n    const hash = hashBytes.slice(17, 49);\n    crypto.pbkdf2(password, salt, iterations, hash.length, 'sha1', function(err, hashed) {\n      if (err) return callback(err);\n      const hashedBase64 = Buffer.from(hashed, 'binary').toString('base64');\n      const isValid = fixedTimeComparison(hash.toString('base64'), hashedBase64);\n      return callback(null, isValid);\n    });\n  }\n\n  connection.on('debug', function(text) {\n    // if you have connection issues, uncomment this to get more detailed info\n    //console.log(text);\n  }).on('errorMessage', function(text) {\n    // this will show any errors when connecting to the SQL database or with the SQL statements\n    console.log(JSON.stringify(text));\n  });\n  connection.on('connect', function(err) {\n    if (err) return callback(err);\n    getMembershipUser(email, function(err, user) {\n      if (err || !user || !user.profile) return callback(err || new WrongUsernameOrPasswordError(email));\n      validatePassword(password, user.password, function(err, isValid) {\n        if (err || !isValid) return callback(err || new WrongUsernameOrPasswordError(email));\n        callback(null, user.profile);\n      });\n    });\n  });\n\n  // Membership Provider implementation used on Microsoft.AspNet.Providers NuGet\n  /**\n   * getMembershipUser\n   *\n   * This function gets a username or email and returns a user info, password hashes and salt\n   *\n   * @usernameOrEamil   {[string]}    the username or email, the method will do a query\n   *                                  on both with an OR\n   * @callback          {[Function]}  first argument will be the Error if any, and second\n   *                                  argument will be a user object\n   */\n  function getMembershipUser(usernameOrEmail, done) {\n    var user = null;\n    const query =\n      'SELECT webpages_Membership.UserId, UserName, UserProfile.UserName, Password from webpages_Membership ' +\n      'INNER JOIN UserProfile ON UserProfile.UserId = webpages_Membership.UserId ' +\n      'WHERE UserProfile.UserName = @Username';\n    const getMembershipQuery = new Request(query, function(err, rowCount) {\n      if (err || rowCount < 1) return done(err);\n      done(err, user);\n    });\n    getMembershipQuery.addParameter('Username', TYPES.VarChar, usernameOrEmail);\n    getMembershipQuery.on('row', function(fields) {\n      user = {\n        profile: {\n          user_id: fields.UserId.value,\n          nickname: fields.UserName.value,\n          email: fields.UserName.value,\n        },\n        password: fields.Password.value\n      };\n    });\n    connection.execSql(getMembershipQuery);\n  }\n}\n```\n\n### MongoDB\n\n```\nfunction login(email, password, callback) {\n  const bcrypt = require('bcrypt');\n  const MongoClient = require('mongodb@3.1.4').MongoClient;\n  const client = new MongoClient('mongodb://user:pass@mymongoserver.com');\n  client.connect(function (err) {\n    if (err) return callback(err);\n    const db = client.db('db-name');\n    const users = db.collection('users');\n    users.findOne({ email: email }, function (err, user) {\n      if (err || !user) {\n        client.close();\n        return callback(err || new WrongUsernameOrPasswordError(email));\n      }\n      bcrypt.compare(password, user.password, function (err, isValid) {\n        client.close();\n        if (err || !isValid) return callback(err || new WrongUsernameOrPasswordError(email));\n        return callback(null, {\n            user_id: user._id.toString(),\n            nickname: user.nickname,\n            email: user.email\n          });\n      });\n    });\n  });\n}\n```\n\n### MySQL\n\n```\nfunction login(email, password, callback) {\n  const mysql = require('mysql');\n  const bcrypt = require('bcrypt');\n  const connection = mysql({\n    host: 'localhost',\n    user: 'me',\n    password: 'secret',\n    database: 'mydb'\n  });\n  connection.connect();\n  const query = 'SELECT id, nickname, email, password FROM users WHERE email = ?';\n  connection.query(query, [ email ], function(err, results) {\n    if (err) return callback(err);\n    if (results.length === 0) return callback(new WrongUsernameOrPasswordError(email));\n    const user = results[0];\n    bcrypt.compare(password, user.password, function(err, isValid) {\n      if (err || !isValid) return callback(err || new WrongUsernameOrPasswordError(email));\n      callback(null, {\n        user_id: user.id.toString(),\n        nickname: user.nickname,\n        email: user.email\n      });\n    });\n  });\n}\n```\n\n### PostgreSQL\n\n```\nfunction login(email, password, callback) {\n  //this example uses the \"pg\" library\n  //more info here: https://github.com/brianc/node-postgres\n  const bcrypt = require('bcrypt');\n  const postgres = require('pg');\n  const conString = 'postgres://user:pass@localhost/mydb';\n  postgres.connect(conString, function (err, client, done) {\n    if (err) return callback(err);\n    const query = 'SELECT id, nickname, email, password FROM users WHERE email = $1';\n    client.query(query, [email], function (err, result) {\n      // NOTE: always call `done()` here to close\n      // the connection to the database\n      done();\n      if (err || result.rows.length === 0) return callback(err || new WrongUsernameOrPasswordError(email));\n      const user = result.rows[0];\n      bcrypt.compare(password, user.password, function (err, isValid) {\n        if (err || !isValid) return callback(err || new WrongUsernameOrPasswordError(email));\n        return callback(null, {\n          user_id: user.id,\n          nickname: user.nickname,\n          email: user.email\n        });\n      });\n    });\n  });\n}\n```\n\n### SQL Server\n\n```\nfunction login(email, password, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  const bcrypt = require('bcrypt');\n  const sqlserver = require('tedious@11.0.3');\n  const Connection = sqlserver.Connection;\n  const Request = sqlserver.Request;\n  const TYPES = sqlserver.TYPES;\n  const connection = new Connection({\n    userName:  'test',\n    password:  'test',\n    server:    'localhost',\n    options:  {\n      database: 'mydb',\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  const query = 'SELECT Id, Nickname, Email, Password FROM dbo.Users WHERE Email = @Email';\n  connection.on('debug', function (text) {\n    console.log(text);\n  }).on('errorMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  }).on('infoMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) return callback(err);\n    const request = new Request(query, function (err, rowCount, rows) {\n      if (err || rowCount < 1) return callback(err || new WrongUsernameOrPasswordError(email));\n      bcrypt.compare(password, rows[0][3].value, function (err, isValid) {\n        if (err || !isValid) return callback(err || new WrongUsernameOrPasswordError(email));\n        callback(null, {\n          user_id: rows[0][0].value,\n          nickname: rows[0][1].value,\n          email: rows[0][2].value\n        });\n      });\n    });\n    request.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(request);\n  });\n}\n```\n\n### Windows Azure SQL Database\n\n```\nfunction login(email, password, callback) {\n  //this example uses the \"tedious\" library\n  //more info here: http://pekim.github.io/tedious/index.html\n  var Connection = require('tedious@11.0.3').Connection;\n  var Request = require('tedious@11.0.3').Request;\n  var TYPES = require('tedious@11.0.3').TYPES;\n  var bcrypt = require('bcrypt');\n  var connection = new Connection({\n    userName: 'your-user@your-server-id.database.windows.net',\n    password: 'the-password',\n    server: 'your-server-id.database.windows.net',\n    options: {\n      database: 'mydb',\n      encrypt: true,\n      rowCollectionOnRequestCompletion: true\n    }\n  });\n  var query = \"SELECT Id, Email, Password \" +\n    \"FROM dbo.Users WHERE Email = @Email\";\n  connection.on('debug', function (text) {\n    // Uncomment next line in order to enable debugging messages\n    // console.log(text);\n  }).on('errorMessage', function (text) {\n    console.log(JSON.stringify(text, null, 2));\n    return callback(text);\n  }).on('infoMessage', function (text) {\n    // Uncomment next line in order to enable information messages\n    // console.log(JSON.stringify(text, null, 2));\n  });\n  connection.on('connect', function (err) {\n    if (err) { return callback(err); }\n    var request = new Request(query, function (err, rowCount, rows) {\n      if (err) {\n        callback(new Error(err));\n      } else if (rowCount < 1) {\n        callback(new WrongUsernameOrPasswordError(email));\n      } else {\n        bcrypt.compare(password, rows[0][2].value, function (err, isValid) {\n          if (err) { callback(new Error(err)); }\n          else if (!isValid) { callback(new WrongUsernameOrPasswordError(email)); }\n          else {\n            callback(null, {\n              user_id: rows[0][0].value,\n              email: rows[0][1].value\n            });\n          }\n        });\n      }\n    });\n    request.addParameter('Email', TYPES.VarChar, email);\n    connection.execSql(request);\n  });\n}\n```\n\n### Axios\n\n```\nasync function loginAsync(email, password, callback) {\n  //should be updated as new versions of axios are made available (https://auth0-extensions.github.io/canirequire/#axios)\n  const axios = require(\"axios@0.22.0\");\n\n  let response;\n\n  try {\n    response = await axios.post(\n      //store API url in connection settings to better support SDLC environments\n      configuration.baseAPIUrl + \"/login\",\n      //user credentials passed as request body\n      {\n        email: email,\n        password: password,\n      },\n      {\n        timeout: 10000, //end call gracefully if request times out so script can do necessary callback\n        headers: {\n          //securing api call with apiKey stored in connection settings.\n          //quick and easy approach however using M2M tokens is more secure as\n          // a secret must not be shared between client and API.\n          \"x-api-key\": configuration.apiKey,\n        },\n      }\n    );\n  } catch (e) {\n    if (e.response.status === 404) {\n      //assuming api returns 404 when email/username/password invalid\n      return callback(\n        new WrongUsernameOrPasswordError(email, \"Invalid credentials provided.\")\n      );\n    }\n    //callback for any other error type\n    return callback(new Error(e.message));\n  }\n\n  try {\n    let user = response.data;\n\n    //if using multiple custom db connections in your tenant prefix the\n    //user_id with a connection specific key ex: \"connName|\" + user.user_id\n    //this ensures unique user ids across all db connections\n    return callback(null, {\n      user_id: user.user_id,\n      email: user.email,\n    });\n  } catch (e) {\n    return callback(new Error(e.message));\n  }\n}\n```\n\n### Stormpath\n\n```\nfunction login(username, password, callback) {\n  // Replace the {yourStormpathClientId} with your Stormpath ID\n  var url = 'https://api.stormpath.com/v1/applications/{yourStormpathClientId}/loginAttempts';\n  // Add your Stormpath API Client ID and Secret\n  var apiCredentials = {\n    user : '{yourStormpathApiId}',\n    password: '{yourStormpathApiSecret}'\n  };\n  // Stormpath requires the user credentials be passed in as a base64 encoded message\n  var credentials = Buffer.from(username + ':' + password).toString('base64');\n  // Make a POST request to authenticate a user\n  request({\n    url: url,\n    method: 'POST',\n    auth: apiCredentials,\n    json: {\n      type: 'basic',\n      // Passing in the base64 encoded credentials\n      value: credentials\n    }\n  }, function (error, response, body) {\n    // If response is successful we'll continue\n    if (response.statusCode !== 200) return callback();\n    // A successful response will return a URL to get the user information\n    var accountUrl = body.account.href;\n    // Make a second request to get the user info.\n    request({\n      url: accountUrl,\n      auth: apiCredentials,\n      json: true\n    }, function (errorUserInfo, responseUserInfo, bodyUserInfo) {\n      // If we get a successful response, we'll process it\n      if (responseUserInfo.statusCode !== 200) return callback();\n      // To get the user identifier, we'll strip out the Stormpath API\n      var id = bodyUserInfo.href.replace('https://api.stormpath.com/v1/accounts/', '');\n      // Finally, we'll set the data we want to store in Auth0 and migrate the user\n      return callback(null, {\n        user_id : id,\n        username: bodyUserInfo.username,\n        email: bodyUserInfo.email,\n        // We set the users email_verified to true as we assume if they were a valid\n        // user in Stormpath, they have already verified their email\n        // If this field is not set, the user will get an email asking them to verify\n        // their account. You can decide how to handle this for your use case\n        email_verified: true\n        // Add any additional fields you would like to carry over from Stormpath\n      });\n    });\n  });\n}\n```\n\n## Learn more\n\n*   [Change Password Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-password)\n*   [Create Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/create)\n*   [Delete Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/delete)\n*   [Get User Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/get-user)\n*   [Verify Script Templates](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/verify)\n*   [Change Email Script Template](https://auth0.com/docs/authenticate/database-connections/custom-db/templates/change-email)",
    "title": "Login Script Templates",
    "description": "Describes custom database action script templates for user login.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/login-pages/customize-consent-prompts",
    "markdown": "# Customize Consent Prompts\n\nWhen a third-party application requests scopes, users see a consent prompt. By default, this prompt uses the scope **name** to generate text and groups all scopes for a resource, displaying the resource's actions in a single line.\n\nIf you require a specialized consent prompt, for example, parental consent, you need to build your own custom consent form. Be aware that laws vary according to country.\n\nFor example, let's say you have an Auth0-registered API with the following defined scopes:\n\n*   `read:messages`: Be able to read your email messages\n    \n*   `write:messages`: Write messages\n    \n\nThe consent prompt will display **Messages: read and write your messages**.\n\nInstead, you can use your defined scope **description** to generate this text. In this case, the consent dialog would display: **Be able to read your email messages**, **Write messages**.\n\nThis change is made at the tenant level, so it will affect consent prompts for all APIs on the tenant.\n\n## Use scope descriptions to generate consent prompt text\n\nSet your tenant's **use\\_scope\\_descriptions\\_for\\_consent** flag to `true` by making the following API call:\n\n*   [cURL](#bf38a41d218945f0b5db9d679df700e0_shell)\n*   [C#](#bf38a41d218945f0b5db9d679df700e0_csharp)\n*   [Go](#bf38a41d218945f0b5db9d679df700e0_go)\n*   [Java](#bf38a41d218945f0b5db9d679df700e0_java)\n*   [Node.JS](#bf38a41d218945f0b5db9d679df700e0_node)\n*   [Obj-C](#bf38a41d218945f0b5db9d679df700e0_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/tenants/settings' \\\n  --header 'authorization: Bearer API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"flags\": { \"use_scope_descriptions_for_consent\": true } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/tenants/settings\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/tenants/settings\"\n\n\tpayload := strings.NewReader(\"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/tenants/settings\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/tenants/settings',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {flags: {use_scope_descriptions_for_consent: true}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"flags\": @{ @\"use_scope_descriptions_for_consent\": @YES } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/tenants/settings\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/tenants/settings\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/tenants/settings\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/tenants/settings\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": true } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"flags\": [\"use_scope_descriptions_for_consent\": true]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/tenants/settings\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Use scope names to generate consent prompt text\n\nSet your tenant's **use\\_scope\\_descriptions\\_for\\_consent** flag to `false` by making the following API call:\n\n*   [cURL](#bffd3be8551c43e1822b5baf98aaaf65_shell)\n*   [C#](#bffd3be8551c43e1822b5baf98aaaf65_csharp)\n*   [Go](#bffd3be8551c43e1822b5baf98aaaf65_go)\n*   [Java](#bffd3be8551c43e1822b5baf98aaaf65_java)\n*   [Node.JS](#bffd3be8551c43e1822b5baf98aaaf65_node)\n*   [Obj-C](#bffd3be8551c43e1822b5baf98aaaf65_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/tenants/settings' \\\n  --header 'authorization: Bearer API_ACCESS_TOKEN' \\\n  --header 'cache-control: no-cache' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"flags\": { \"use_scope_descriptions_for_consent\": false } }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/tenants/settings\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer API_ACCESS_TOKEN\");\nrequest.AddHeader(\"cache-control\", \"no-cache\");\nrequest.AddParameter(\"application/json\", \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": false } }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/tenants/settings\"\n\n\tpayload := strings.NewReader(\"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": false } }\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer API_ACCESS_TOKEN\")\n\treq.Header.Add(\"cache-control\", \"no-cache\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/tenants/settings\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer API_ACCESS_TOKEN\")\n  .header(\"cache-control\", \"no-cache\")\n  .body(\"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": false } }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/tenants/settings',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer API_ACCESS_TOKEN',\n    'cache-control': 'no-cache'\n  },\n  data: {flags: {use_scope_descriptions_for_consent: false}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer API_ACCESS_TOKEN\",\n                           @\"cache-control\": @\"no-cache\" };\nNSDictionary *parameters = @{ @\"flags\": @{ @\"use_scope_descriptions_for_consent\": @NO } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/tenants/settings\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/tenants/settings\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": false } }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer API_ACCESS_TOKEN\",\n    \"cache-control: no-cache\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": false } }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer API_ACCESS_TOKEN\",\n    'cache-control': \"no-cache\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/tenants/settings\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/tenants/settings\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer API_ACCESS_TOKEN'\nrequest[\"cache-control\"] = 'no-cache'\nrequest.body = \"{ \\\"flags\\\": { \\\"use_scope_descriptions_for_consent\\\": false } }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer API_ACCESS_TOKEN\",\n  \"cache-control\": \"no-cache\"\n]\nlet parameters = [\"flags\": [\"use_scope_descriptions_for_consent\": false]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/tenants/settings\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n## Learn more\n\n*   [Scopes](https://auth0.com/docs/get-started/apis/scopes)\n*   [Sample Use Cases: Scopes and Claims](https://auth0.com/docs/get-started/apis/scopes/sample-use-cases-scopes-and-claims)\n*   [OpenID Connect Scopes](https://auth0.com/docs/get-started/apis/scopes/openid-connect-scopes)\n*   [API Scopes](https://auth0.com/docs/get-started/apis/scopes/api-scopes)\n*   [Auth0 Security Bulletin for Assigning Scopes Based on Email Address](https://auth0.com/docs/secure/security-guidance/security-bulletins/2019-09-05-scopes)",
    "title": "Customize Consent Prompts",
    "description": "Describes how to customize the consent prompt presented to users during authorization.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/login-pages/custom-error-pages",
    "markdown": "# Customize Error Pages\n\nWhen an authorization error occurs, and your callback URL is valid, the Authorization Server returns the appropriate error and state parameters to your callback URL. If your callback URL is invalid, your application will display the [default Auth0 error page](https://auth0.com/docs/authenticate/login/auth0-universal-login/error-pages).\n\nYour application may also display the default Auth0 error page for reasons other than an invalid callback URL, such as:\n\n*   Required parameters are missing when calling the Auth0 Authentication API [Login endpoint](https://auth0.com/docs/api/authentication#login).\n    \n*   User opens an expired password reset link (when using the Classic Login experience).\n    \n*   User navigates to a bookmarked login page and a [Default Login Route](https://auth0.com/docs/authenticate/login/auth0-universal-login/configure-default-login-routes) is not specified.\n    \n\n## Parameters\n\nIf you choose to configure a custom error page, the Authorization Server will return parameters appended to the URL as a query string.\n\n| **Parameter** | **Description** |\n| --- | --- |\n| `client_id` | Identifier of the Auth0 application. |\n| `connection` | Connection used at the time of error. |\n| `lang` | Language set for use at the time of error. |\n| `error` | Error code of the error. |\n| `error_description` | Description of the error. |\n| `tracking` | Identifier used by Auth0 to find errors in internal logs. |\n\nParameters presented vary depending on the error type and are specific to the request. For example, if the request which resulted in an error did not contain a `client_id`, the Authorization Server will not return the `client_id` parameter.\n\n## Display a custom error page\n\nIf you want to display a custom error page, you have two options:\n\n1.  Redirect users to a custom error page using either the Auth0 Dashboard or the Auth0 Management API.\n    \n2.  Configure Auth0 to render a custom error page on your behalf via the Management API.\n    \n\n### Redirect users to a custom error page using the Dashboard\n\nUse the Dashboard to configure Auth0 to redirect users to a custom error page:\n\n1.  Navigate to [Auth0 Dashboard > Tenant Settings](https://manage.auth0.com/#/tenant/).\n    \n2.  Locate the **Error Pages** section.\n    \n3.  Select the **Redirect users to your own error page** option.\n    \n4.  Enter the URL of the error page you would like your users to see, and select **Save**.\n    \n\n### Redirect users to a custom error page using the Management API\n\nUse the Management API [Update Tenant Settings](https://auth0.com/docs/api/management/v2/#!/Tenants/patch_settings) endpoint. Replace the `{mgmtApiAccessToken}` placeholder value with your Management API Access Token, and update the value of the `url` field in the JSON body to point to the location of the error page.\n\n*   [cURL](#36308a408045434d8d59041687b8b880_shell)\n*   [C#](#36308a408045434d8d59041687b8b880_csharp)\n*   [Go](#36308a408045434d8d59041687b8b880_go)\n*   [Java](#36308a408045434d8d59041687b8b880_java)\n*   [Node.JS](#36308a408045434d8d59041687b8b880_node)\n*   [Obj-C](#36308a408045434d8d59041687b8b880_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url 'https://{yourDomain}/api/v2/tenants/settings' \\\n  --header 'authorization: Bearer {mgmtApiAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{\"error_page\": {\"html\": \"\", \"show_log_link\":false, \"url\": \"http://www.example.com\"}}'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/tenants/settings\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer {mgmtApiAccessToken}\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"error_page\\\": {\\\"html\\\": \\\"\\\", \\\"show_log_link\\\":false, \\\"url\\\": \\\"http://www.example.com\\\"}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/tenants/settings\"\n\n\tpayload := strings.NewReader(\"{\\\"error_page\\\": {\\\"html\\\": \\\"\\\", \\\"show_log_link\\\":false, \\\"url\\\": \\\"http://www.example.com\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer {mgmtApiAccessToken}\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://{yourDomain}/api/v2/tenants/settings\")\n  .header(\"authorization\", \"Bearer {mgmtApiAccessToken}\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"error_page\\\": {\\\"html\\\": \\\"\\\", \\\"show_log_link\\\":false, \\\"url\\\": \\\"http://www.example.com\\\"}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://{yourDomain}/api/v2/tenants/settings',\n  headers: {\n    authorization: 'Bearer {mgmtApiAccessToken}',\n    'content-type': 'application/json'\n  },\n  data: {error_page: {html: '', show_log_link: false, url: 'http://www.example.com'}}\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer {mgmtApiAccessToken}\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"error_page\": @{ @\"html\": @\"\", @\"show_log_link\": @NO, @\"url\": @\"http://www.example.com\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/tenants/settings\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/tenants/settings\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"error_page\\\": {\\\"html\\\": \\\"\\\", \\\"show_log_link\\\":false, \\\"url\\\": \\\"http://www.example.com\\\"}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {mgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{\\\"error_page\\\": {\\\"html\\\": \\\"\\\", \\\"show_log_link\\\":false, \\\"url\\\": \\\"http://www.example.com\\\"}}\"\n\nheaders = {\n    'authorization': \"Bearer {mgmtApiAccessToken}\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/{yourDomain}/api/v2/tenants/settings\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/tenants/settings\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer {mgmtApiAccessToken}'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"error_page\\\": {\\\"html\\\": \\\"\\\", \\\"show_log_link\\\":false, \\\"url\\\": \\\"http://www.example.com\\\"}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer {mgmtApiAccessToken}\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"error_page\": [\n    \"html\": \"\",\n    \"show_log_link\": false,\n    \"url\": \"http://www.example.com\"\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/tenants/settings\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Value | Description |\n| --- | --- |\n| `MGMT_API_ACCESS_TOKEN` | [Access Token for the Management API](https://auth0.com/docs/api/management/v2/tokens) with the scope `update:tenant_settings`. |\n| `show_log_link` | Indicates whether to show a link to the error in your tenant logs. Valid values are `true` and `false`. |\n| `url` | Location of the custom error page to which you want to redirect. |\n\n### Render a custom error page\n\nUse the Management API [Update Tenant Settings](https://auth0.com/docs/api/management/v2/#!/Tenants/patch_settings) endpoint. Replace the `{mgmtApiAccessToken}` placeholder value with your Management API Access Token, and update the value of the `html` field in the JSON body to a string containing the HTML of your page.\n\nYou can use Liquid syntax to include the following variables:\n\n*   `{client_id}`\n    \n*   `{connection}`\n    \n*   `{lang}`\n    \n*   `{error}`\n    \n*   `{error_description}`\n    \n*   `{tracking}`\n    \n\n*   [cURL](#000d7970b9c94b6fa732eb83749cdd8a_shell)\n*   [C#](#000d7970b9c94b6fa732eb83749cdd8a_csharp)\n*   [Go](#000d7970b9c94b6fa732eb83749cdd8a_go)\n*   [Java](#000d7970b9c94b6fa732eb83749cdd8a_java)\n*   [Node.JS](#000d7970b9c94b6fa732eb83749cdd8a_node)\n*   [Obj-C](#000d7970b9c94b6fa732eb83749cdd8a_objc)\n*   [...](#)\n\n```\ncurl --request PATCH \\\n  --url https://login.auth0.com/api/v2/tenants/settings \\\n  --header 'authorization: Bearer MGMT_API_ACCESS_TOKEN' \\\n  --header 'content-type: application/json' \\\n  --data '{\"error_page\": {\"html\": \"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'\\''now'\\'' | date: '\\''%Y %h'\\''}}.</h1>\", \"show_log_link\": false, \"url\": \"\"}}'\n```\n\n```\nvar client = new RestClient(\"https://login.auth0.com/api/v2/tenants/settings\");\nvar request = new RestRequest(Method.PATCH);\nrequest.AddHeader(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\");\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddParameter(\"application/json\", \"{\\\"error_page\\\": {\\\"html\\\": \\\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\\\", \\\"show_log_link\\\": false, \\\"url\\\": \\\"\\\"}}\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://login.auth0.com/api/v2/tenants/settings\"\n\n\tpayload := strings.NewReader(\"{\\\"error_page\\\": {\\\"html\\\": \\\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\\\", \\\"show_log_link\\\": false, \\\"url\\\": \\\"\\\"}}\")\n\n\treq, _ := http.NewRequest(\"PATCH\", url, payload)\n\n\treq.Header.Add(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n\treq.Header.Add(\"content-type\", \"application/json\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.patch(\"https://login.auth0.com/api/v2/tenants/settings\")\n  .header(\"authorization\", \"Bearer MGMT_API_ACCESS_TOKEN\")\n  .header(\"content-type\", \"application/json\")\n  .body(\"{\\\"error_page\\\": {\\\"html\\\": \\\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\\\", \\\"show_log_link\\\": false, \\\"url\\\": \\\"\\\"}}\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'PATCH',\n  url: 'https://login.auth0.com/api/v2/tenants/settings',\n  headers: {\n    authorization: 'Bearer MGMT_API_ACCESS_TOKEN',\n    'content-type': 'application/json'\n  },\n  data: {\n    error_page: {\n      html: '<h1>{{error | escape }} {{error_description | escape }} This error was generated {{\\'now\\' | date: \\'%Y %h\\'}}.</h1>',\n      show_log_link: false,\n      url: ''\n    }\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"authorization\": @\"Bearer MGMT_API_ACCESS_TOKEN\",\n                           @\"content-type\": @\"application/json\" };\nNSDictionary *parameters = @{ @\"error_page\": @{ @\"html\": @\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\", @\"show_log_link\": @NO, @\"url\": @\"\" } };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://login.auth0.com/api/v2/tenants/settings\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"PATCH\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://login.auth0.com/api/v2/tenants/settings\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"PATCH\",\n  CURLOPT_POSTFIELDS => \"{\\\"error_page\\\": {\\\"html\\\": \\\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\\\", \\\"show_log_link\\\": false, \\\"url\\\": \\\"\\\"}}\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer MGMT_API_ACCESS_TOKEN\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"login.auth0.com\")\n\npayload = \"{\\\"error_page\\\": {\\\"html\\\": \\\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\\\", \\\"show_log_link\\\": false, \\\"url\\\": \\\"\\\"}}\"\n\nheaders = {\n    'authorization': \"Bearer MGMT_API_ACCESS_TOKEN\",\n    'content-type': \"application/json\"\n    }\n\nconn.request(\"PATCH\", \"/api/v2/tenants/settings\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://login.auth0.com/api/v2/tenants/settings\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Patch.new(url)\nrequest[\"authorization\"] = 'Bearer MGMT_API_ACCESS_TOKEN'\nrequest[\"content-type\"] = 'application/json'\nrequest.body = \"{\\\"error_page\\\": {\\\"html\\\": \\\"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\\\", \\\"show_log_link\\\": false, \\\"url\\\": \\\"\\\"}}\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"authorization\": \"Bearer MGMT_API_ACCESS_TOKEN\",\n  \"content-type\": \"application/json\"\n]\nlet parameters = [\"error_page\": [\n    \"html\": \"<h1>{{error | escape }} {{error_description | escape }} This error was generated {{'now' | date: '%Y %h'}}.</h1>\",\n    \"show_log_link\": false,\n    \"url\": \"\"\n  ]] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://login.auth0.com/api/v2/tenants/settings\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"PATCH\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n| Value | Description |\n| --- | --- |\n| `MGMT_API_ACCESS_TOKEN` | [Access Token for the Management API](https://auth0.com/docs/api/management/v2/tokens) with the scope `update:tenant_settings`. |\n| `show_log_link` | Indicates whether to show a link to the error in your tenant logs. Valid values are `true` and `false`. |\n| `html` | HTML of the custom error page you want to render. |\n\nTo prevent XSS vulnerabilities, sanitize your custom template using Liquid's [escape](https://shopify.github.io/liquid/filters/escape/) and [strip\\_html](https://shopify.github.io/liquid/filters/strip_html/) filters.\n\n## Learn more\n\n*   [Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login)",
    "title": "Customize Error Pages",
    "description": "Learn how to create a custom error page for authorization error events.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login",
    "markdown": "# Universal Login vs. Classic Login\n\n[Auth0 Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) provides the essential feature of an authorization server: the login flow. When a user needs to prove their identity to gain access to your application, you can redirect them to Universal Login and let Auth0 handle the authentication process. \n\nUniversal Login is Auth0's primary hosted login solution. [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience) features easy-to-use customization tools and promotes a simpler, faster experience for end-users. Alternatively, Auth0 also supports [Classic Login](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience), a hosted login experience that uses JavaScript controls for customization.\n\nTo help you choose the best solution for your needs, the table below compares the features of both login experiences.\n\n| **Feature** | **Universal Login** | **Classic Login** |\n| --- | --- | --- |\n| **Adopt new features without changing HTML** | Yes | No  |\n| **Ongoing development and new feature additions** | Yes | No  |\n| **Lightweight HTML** | Yes | No  |\n| **JavaScript required** | No  | Yes |\n| **Customization** | Yes, using [page templates](https://auth0.com/docs/customize/universal-login-pages/universal-login-page-templates \"Universal login page templates\") or the [no-code editor](https://auth0.com/docs/customize/universal-login-pages/customize-new-universal-login-with-the-no-code-editor) | Yes, using HTML, and only for login, multi-factor authentication (MFA), and password reset pages |\n| **No-Code solution** | Yes, using the [no-code editor](https://auth0.com/docs/customize/universal-login-pages/customize-new-universal-login-with-the-no-code-editor) | No  |\n| **Passwordless authentication** | Yes | Yes, with [SMS or Email](https://auth0.com/docs/connections/passwordless) |\n| **Email magic link** | No  | [Yes](https://auth0.com/docs/authenticate/passwordless/authentication-methods/email-magic-link) |\n| **Passkeys** | [Yes](https://auth0.com/docs/authenticate/database-connections/passkeys \"Passkeys\") | No  |\n| **WebAuthn and device biometrics** | [Yes](https://auth0.com/docs/mfa/fido-authentication-with-webauthn) | No  |\n| **Web Content Accessibility Guidelines (WCAG) Compliance** | Yes | No  |\n| **Organizations support** | [Yes](https://auth0.com/docs/organizations) | No  |\n| **Terms of service acceptance on signup** | Yes | [Yes](https://auth0.com/docs/libraries/lock/lock-configuration#showterms-boolean-) |\n| **Custom fields on signup** | Yes | [Yes](https://auth0.com/docs/libraries/lock/lock-configuration#additionalsignupfields-array-) |\n| **Full localization** | Yes, in [these](https://auth0.com/docs/universal-login/i18n) languages | Only for the login page |\n| **Customizable localized text on all pages** | [Yes](https://auth0.com/docs/universal-login/text-customization) | No  |\n| **Email MFA** | [Yes](https://auth0.com/docs/mfa/configure-email-notifications-for-mfa) | No  |\n| **Voice MFA** | [Yes](https://auth0.com/docs/mfa/configure-sms-voice-notifications-mfa) | No  |\n| **Duo MFA** | Yes, but Duo must be the only MFA factor enabled | Yes |\n| **MFA customization with Actions** | [Yes](https://auth0.com/docs/secure/multi-factor-authentication/customize-mfa-selection-nul) | No  |\n| **Buttons for enterprise connections** | [Yes](https://auth0.com/docs/universal-login/identifier-first#define-home-realm-discovery-identity-providers) | No  |\n| **Ability to disable self-service password recovery** | Yes | [Yes](https://auth0.com/docs/libraries/lock/lock-configuration#allowforgotpassword-boolean) |\n| **Custom URLs for password reset and user signup** | Yes, using page templates **and** a custom-built password reset or signup page | [Yes](https://auth0.com/docs/libraries/lock/lock-configuration#forgotpasswordlink-string-) |\n| **Kerberos support for AD/LDAP connections** | No  | [Yes](https://auth0.com/docs/extensions/ad-ldap-connector/configure-ad-ldap-connector-with-kerberos#auto-login-with-lock) |\n| **Requires exposing identity provider domains in a public endpoint** | No  | [Yes](https://auth0.com/docs/config/tenant-settings#advanced) |\n\n## Learn more\n\n*   [Universal Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/universal-experience)\n*   [Classic Login Experience](https://auth0.com/docs/authenticate/login/auth0-universal-login/universal-login-vs-classic-login/classic-experience)\n*   [Centralized Universal Login vs. Embedded Login](https://auth0.com/docs/authenticate/login/universal-vs-embedded-login)",
    "title": "Universal Login vs. Classic Login",
    "description": "Compares features available in the Universal Login and Classic Login experiences",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/manage-email-flow",
    "markdown": "# Customize Email Handling\n\nOur default email flow can address the requirements of most applications. Sometimes, however, you may require more flexibility, such as when implementing:\n\n*   localization\n    \n*   custom **Redirect To** URLs based on user or tenant\n    \n*   different email templates per application or tenant\n    \n\nThe Auth0 Management API provides endpoints to help you manage your email flow to control when and how emails are sent. If necessary, you can also implement your own Custom Email endpoints and use the Auth0 Management API endpoints to help manage the rest of the flow.\n\n## Verification emails\n\nA verification email should be sent to every user for which the `email_verified` property is `false`. Typically, these are users in database connections or users authenticating with social providers that do not validate email addresses upon new user registration.\n\nYou can send verification emails in more than one way:\n\nThe [Send an email address verification email endpoint](https://auth0.com/docs/api/management/v2#!/Jobs/post_verification_email) sends the user an email prompting them to verify their email address.\n\n*   [cURL](#e983c89301e347ecad0326b393b7fa1b_shell)\n*   [C#](#e983c89301e347ecad0326b393b7fa1b_csharp)\n*   [Go](#e983c89301e347ecad0326b393b7fa1b_go)\n*   [Java](#e983c89301e347ecad0326b393b7fa1b_java)\n*   [Node.JS](#e983c89301e347ecad0326b393b7fa1b_node)\n*   [Obj-C](#e983c89301e347ecad0326b393b7fa1b_objc)\n*   [...](#)\n\n```\ncurl --request POST \\\n  --url 'https://{yourDomain}/api/v2/jobs/verification-email' \\\n  --header 'authorization: Bearer {yourMgmtApiAccessToken}' \\\n  --header 'content-type: application/json' \\\n  --data '{ \"user_id\": \"{userIdOfVerifyEmailRecipient}\", \"client_id\": \"{yourAppClientId}\",\"identity\": {\"user_id\": \"5457edea1b8f22891a000004\",\"provider\": \"google-oauth2\"}, \"organization_id\": \"{yourOrganizationId}\" }'\n```\n\n```\nvar client = new RestClient(\"https://{yourDomain}/api/v2/jobs/verification-email\");\nvar request = new RestRequest(Method.POST);\nrequest.AddHeader(\"content-type\", \"application/json\");\nrequest.AddHeader(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\");\nrequest.AddParameter(\"application/json\", \"{ \\\"user_id\\\": \\\"{userIdOfVerifyEmailRecipient}\\\", \\\"client_id\\\": \\\"{yourAppClientId}\\\",\\\"identity\\\": {\\\"user_id\\\": \\\"5457edea1b8f22891a000004\\\",\\\"provider\\\": \\\"google-oauth2\\\"}, \\\"organization_id\\\": \\\"{yourOrganizationId}\\\" }\", ParameterType.RequestBody);\nIRestResponse response = client.Execute(request);\n```\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc main() {\n\n\turl := \"https://{yourDomain}/api/v2/jobs/verification-email\"\n\n\tpayload := strings.NewReader(\"{ \\\"user_id\\\": \\\"{userIdOfVerifyEmailRecipient}\\\", \\\"client_id\\\": \\\"{yourAppClientId}\\\",\\\"identity\\\": {\\\"user_id\\\": \\\"5457edea1b8f22891a000004\\\",\\\"provider\\\": \\\"google-oauth2\\\"}, \\\"organization_id\\\": \\\"{yourOrganizationId}\\\" }\")\n\n\treq, _ := http.NewRequest(\"POST\", url, payload)\n\n\treq.Header.Add(\"content-type\", \"application/json\")\n\treq.Header.Add(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n\n\tres, _ := http.DefaultClient.Do(req)\n\n\tdefer res.Body.Close()\n\tbody, _ := ioutil.ReadAll(res.Body)\n\n\tfmt.Println(res)\n\tfmt.Println(string(body))\n\n}\n```\n\n```\nHttpResponse<String> response = Unirest.post(\"https://{yourDomain}/api/v2/jobs/verification-email\")\n  .header(\"content-type\", \"application/json\")\n  .header(\"authorization\", \"Bearer {yourMgmtApiAccessToken}\")\n  .body(\"{ \\\"user_id\\\": \\\"{userIdOfVerifyEmailRecipient}\\\", \\\"client_id\\\": \\\"{yourAppClientId}\\\",\\\"identity\\\": {\\\"user_id\\\": \\\"5457edea1b8f22891a000004\\\",\\\"provider\\\": \\\"google-oauth2\\\"}, \\\"organization_id\\\": \\\"{yourOrganizationId}\\\" }\")\n  .asString();\n```\n\n```\nvar axios = require(\"axios\").default;\n\nvar options = {\n  method: 'POST',\n  url: 'https://{yourDomain}/api/v2/jobs/verification-email',\n  headers: {\n    'content-type': 'application/json',\n    authorization: 'Bearer {yourMgmtApiAccessToken}'\n  },\n  data: {\n    user_id: '{userIdOfVerifyEmailRecipient}',\n    client_id: '{yourAppClientId}',\n    identity: {user_id: '5457edea1b8f22891a000004', provider: 'google-oauth2'},\n    organization_id: '{yourOrganizationId}'\n  }\n};\n\naxios.request(options).then(function (response) {\n  console.log(response.data);\n}).catch(function (error) {\n  console.error(error);\n});\n```\n\n```\n#import <Foundation/Foundation.h>\n\nNSDictionary *headers = @{ @\"content-type\": @\"application/json\",\n                           @\"authorization\": @\"Bearer {yourMgmtApiAccessToken}\" };\nNSDictionary *parameters = @{ @\"user_id\": @\"{userIdOfVerifyEmailRecipient}\",\n                              @\"client_id\": @\"{yourAppClientId}\",\n                              @\"identity\": @{ @\"user_id\": @\"5457edea1b8f22891a000004\", @\"provider\": @\"google-oauth2\" },\n                              @\"organization_id\": @\"{yourOrganizationId}\" };\n\nNSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];\n\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://{yourDomain}/api/v2/jobs/verification-email\"]\n                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy\n                                                   timeoutInterval:10.0];\n[request setHTTPMethod:@\"POST\"];\n[request setAllHTTPHeaderFields:headers];\n[request setHTTPBody:postData];\n\nNSURLSession *session = [NSURLSession sharedSession];\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n                                                if (error) {\n                                                    NSLog(@\"%@\", error);\n                                                } else {\n                                                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n                                                    NSLog(@\"%@\", httpResponse);\n                                                }\n                                            }];\n[dataTask resume];\n```\n\n```\n$curl = curl_init();\n\ncurl_setopt_array($curl, [\n  CURLOPT_URL => \"https://{yourDomain}/api/v2/jobs/verification-email\",\n  CURLOPT_RETURNTRANSFER => true,\n  CURLOPT_ENCODING => \"\",\n  CURLOPT_MAXREDIRS => 10,\n  CURLOPT_TIMEOUT => 30,\n  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n  CURLOPT_CUSTOMREQUEST => \"POST\",\n  CURLOPT_POSTFIELDS => \"{ \\\"user_id\\\": \\\"{userIdOfVerifyEmailRecipient}\\\", \\\"client_id\\\": \\\"{yourAppClientId}\\\",\\\"identity\\\": {\\\"user_id\\\": \\\"5457edea1b8f22891a000004\\\",\\\"provider\\\": \\\"google-oauth2\\\"}, \\\"organization_id\\\": \\\"{yourOrganizationId}\\\" }\",\n  CURLOPT_HTTPHEADER => [\n    \"authorization: Bearer {yourMgmtApiAccessToken}\",\n    \"content-type: application/json\"\n  ],\n]);\n\n$response = curl_exec($curl);\n$err = curl_error($curl);\n\ncurl_close($curl);\n\nif ($err) {\n  echo \"cURL Error #:\" . $err;\n} else {\n  echo $response;\n}\n```\n\n```\nimport http.client\n\nconn = http.client.HTTPSConnection(\"\")\n\npayload = \"{ \\\"user_id\\\": \\\"{userIdOfVerifyEmailRecipient}\\\", \\\"client_id\\\": \\\"{yourAppClientId}\\\",\\\"identity\\\": {\\\"user_id\\\": \\\"5457edea1b8f22891a000004\\\",\\\"provider\\\": \\\"google-oauth2\\\"}, \\\"organization_id\\\": \\\"{yourOrganizationId}\\\" }\"\n\nheaders = {\n    'content-type': \"application/json\",\n    'authorization': \"Bearer {yourMgmtApiAccessToken}\"\n    }\n\nconn.request(\"POST\", \"/{yourDomain}/api/v2/jobs/verification-email\", payload, headers)\n\nres = conn.getresponse()\ndata = res.read()\n\nprint(data.decode(\"utf-8\"))\n```\n\n```\nrequire 'uri'\nrequire 'net/http'\nrequire 'openssl'\n\nurl = URI(\"https://{yourDomain}/api/v2/jobs/verification-email\")\n\nhttp = Net::HTTP.new(url.host, url.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nrequest = Net::HTTP::Post.new(url)\nrequest[\"content-type\"] = 'application/json'\nrequest[\"authorization\"] = 'Bearer {yourMgmtApiAccessToken}'\nrequest.body = \"{ \\\"user_id\\\": \\\"{userIdOfVerifyEmailRecipient}\\\", \\\"client_id\\\": \\\"{yourAppClientId}\\\",\\\"identity\\\": {\\\"user_id\\\": \\\"5457edea1b8f22891a000004\\\",\\\"provider\\\": \\\"google-oauth2\\\"}, \\\"organization_id\\\": \\\"{yourOrganizationId}\\\" }\"\n\nresponse = http.request(request)\nputs response.read_body\n```\n\n```\nimport Foundation\n\nlet headers = [\n  \"content-type\": \"application/json\",\n  \"authorization\": \"Bearer {yourMgmtApiAccessToken}\"\n]\nlet parameters = [\n  \"user_id\": \"{userIdOfVerifyEmailRecipient}\",\n  \"client_id\": \"{yourAppClientId}\",\n  \"identity\": [\n    \"user_id\": \"5457edea1b8f22891a000004\",\n    \"provider\": \"google-oauth2\"\n  ],\n  \"organization_id\": \"{yourOrganizationId}\"\n] as [String : Any]\n\nlet postData = JSONSerialization.data(withJSONObject: parameters, options: [])\n\nlet request = NSMutableURLRequest(url: NSURL(string: \"https://{yourDomain}/api/v2/jobs/verification-email\")! as URL,\n                                        cachePolicy: .useProtocolCachePolicy,\n                                    timeoutInterval: 10.0)\nrequest.httpMethod = \"POST\"\nrequest.allHTTPHeaderFields = headers\nrequest.httpBody = postData as Data\n\nlet session = URLSession.shared\nlet dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in\n  if (error != nil) {\n    print(error)\n  } else {\n    let httpResponse = response as? HTTPURLResponse\n    print(httpResponse)\n  }\n})\n\ndataTask.resume()\n```\n\n### Require verified email for login\n\nYou can require users to verify their email before logging in with a rule:\n\n```\nfunction (user, context, callback) {\n  if (!user.email_verified) {\n    return callback(new UnauthorizedError('Please verify your email before logging in.'));\n  } else {\n    return callback(null, user, context);\n  }\n}\n```\n\n### Custom redirects\n\nA custom redirect is useful when you want to direct users to certain URLs based on user attributes or on the tenant. The Auth0 Management API provides a [Create Email Verification Ticket endpoint](https://auth0.com/docs/api/management/v2/#!/Tickets/post_email_verification) that generates the verification link for each user. This endpoint allows you to specify the `result_url` to which users will be redirected after they have validated their email address by clicking the link in the verification email.\n\nWe recommend AllowList the URL in the [Auth0 Dashboard](https://manage.auth0.com/#/templates/provider). For details, see [Add Addresses to AllowList](https://auth0.com/docs/secure/security-guidance/data-security/allowlist).\n\n## Welcome emails\n\nA welcome email is sent to users once they have verified their email address.\n\n### Send welcome email using your own API\n\nUsing a [rule](https://auth0.com/docs/customize/rules), you can call your API to send a welcome email only if the user's email address has been verified and the email has not been sent previously.\n\n```\nfunction (user, context, callback) {\n\n  const request = require('request');\n\n  if (!user.email_verified || user.welcome_email_sent) {\n    return callback(null, user, context);\n  }\n\n  request.post({\n    url: 'https://yourapi.yourcompany.com/mail/welcome',\n    json: {\n      user: user,\n      context: context,\n      secretToken: configuration.MY_SECRET_TOKEN,\n    },\n    timeout: 5000\n  }, function(err, response, body){\n    if (err)\n      return callback(new Error(err));\n\n    // Email sent flag persisted in the user's profile.\n    user.app_metadata.welcome_email_sent = true;\n    return callback(null, user, context);\n  });\n}\n```\n\n## Password reset emails\n\nYou can create a password change ticket using the Auth0 Management API [Create a Password Change Ticket](https://auth0.com/docs/api/management/v2/#!/Tickets/post_password_change) endpoint, and then send the password change ticket URL in an email to the user. When the user clicks the link, they will be prompted to reset their password through the Universal Login flow.\n\n## Learn more\n\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)",
    "title": "Customize Email Handling",
    "description": "Learn how to customize email flow and control when and how emails are sent.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/send-email-invitations-for-application-signup",
    "markdown": "# Send Email Invitations for Application Signup\n\nTo restrict user signups or create accounts in bulk for your application, your application can provision users with user invitations.\n\nA typical user invitation workflow follows the steps below:\n\n1.  Administrator creates a user account.\n    \n2.  Administrator sends a registration email invitation to the user.\n    \n3.  User follows a link in the invitation email to set up a password for the account.\n    \n4.  User creates and verifies a password.\n    \n5.  User signs in.\n    \n\n## Generate invitations\n\nA user invitation is basically a change password link repurposed as an invitation. The user invitation email is derived from the \"change password\" template. With Auth0, there are two common approaches to implementing user invitations:\n\n*   [Customize an email template](https://auth0.com/docs/customize/email/email-templates) and use it to [send a change password email](https://auth0.com/docs/customize/email/manage-email-flow).\n    \n*   Create a password change ticket.\n    \n\nYou can allow a user to access an existing account that you have created on their behalf. Then, send the user a unique link to set their password. You generate the unique link by creating a Password Change ticket where your invitation app calls the `/password-change` [Management API endpoint](https://auth0.com/docs/api/management/v2/#!/Tickets/post_password_change). You will need to:\n\n*   [Create an Auth0 database user](https://auth0.com/docs/authenticate/database-connections) with the `user.email_verified` parameter set to `false`. You can use the [Create a User](https://auth0.com/docs/api/management/v2/#!/Users/post_users) endpoint.\n    \n*   Have access to and [configure an external email service](https://auth0.com/docs/customize/email/smtp-email-providers)\n    \n*   [Get a Management API access token](https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens/get-management-api-access-tokens-for-testing)\n    \n\n### Create password change tickets\n\n1.  Specify the user using `user_id` or email and `connection_id` to the \n    \n    [Management API endpoint](https://auth0.com/docs/api/management/v2#!/Tickets/post_password_change)\n    \n2.  Specify where the redirect sends the user. The `result_url` parameter is the redirect location your application sends the user after they set their password. In this case, the `result_url` should be your app login page. To learn more, read [Redirect Users After Login](https://auth0.com/docs/authenticate/login/redirect-users-after-login).\n    \n3.  Specify the lifespan of the invitation link. Use the `ttl_sec` parameter to set how long the invitation link will remain active. The `ttl_sec` parameter should align with your relevant security concerns. The link is a one-time use, so once the user has set their password, it is not vulnerable to reuse.\n    \n4.  Verify the email address. If sent to a registered email account, set the `mark_email_as_verified` parameter as `true`. You **should not** set the email verification to `true` if the email account is not registered. A successful request to this endpoint will return a ticket URL. You will use that URL to create the user invitation.\n    \n\n```\ncurl -- request POST \\\n  --url 'https://{yourAuth0Tenant}/api/v2/tickets/password-change' \\\n  --header \"Content-Type: application/json\" \\\n  --data '{\"result_url\": \"{yourResultURL}\",\"user_id\":,{yourUserID}\",\"client_id\":\"{yourClientID\",\"ttl_sec\":0,\"mark_email_as_verified\":false,\"includeEmailInRedirect\":false}'\n```\n\n### Add query parameters ticket URL\n\nYou can add query parameters to the URL to customize the password reset UI. The returned URL has a unique code value that allows the user to set their password followed by a `#`. Do not edit anything before the `#`.\n\nAdd a parameter to specify a set password workflow UI. Example:\n\nAdd a parameter to identify the target app. Example:\n\n### Create email template\n\nThe email invitation needs to be sent with your existing email service provider. [Customize the password change email template](https://auth0.com/docs/customize/email/email-templates) so the language in the email aligns with your use case. Include the link generated from the steps above. The text in the email should explain:\n\n*   The next steps to claiming the user account.\n    \n*   The expiration of the link.\n    \n*   Steps to generate a new invite if it has expired.\n    \n\nFor example, when creating the user to invite, you might add a property to `user.app_metadata` that shows this user account was invited. Then in your email template you could check for this property:\n\n```\n{% if user.app_metadata.invitedToMyApp == true %}\n  // user invitation email\n{% else %}\n  // password change email\n{% endif %}\n```\n\n## Customize Password Reset UI\n\nOnce the user clicks the link in the invitation they will be brought to the Universal Login Password Reset page where they will set a password for their account. Since this page is used both for the forgot password workflow and for your user invitations, you will want to use the query parameters you defined earlier to identify the invite workflow and customize the UI accordingly. To learn more, read [Customize Password Reset Page](https://auth0.com/docs/customize/login-pages/classic-login/customize-password-reset-page).\n\n## Complete the user experience\n\nIn most cases, once the user has set their password, you grant them access to the target app. The target app initiates the login sequence with the following steps:\n\n1.  User submits password.\n    \n2.  Change password screen redirects return URL.\n    \n3.  Target app redirects to `/authorize`.\n    \n4.  User submits their credentials.\n    \n5.  User is authenticated into the app.\n    \n\nThe workflow involves redirects but it is possible for the transition from the set password form to the login form to appear seamless to the end user.\n\nIf you're using Classic Login, the `result_url` you set when you created the password change ticket is where the user will be redirected after creating their password. In this case, you want the URL to be on the site the user has been invited to so that it can initiate the login workflow. Your target app will need to parse the `success` parameter to confirm no errors occurred then immediately initiate the redirect back to Auth0 to log the user in.\n\nTo optimize the user experience, you can have the target app parse the `email` parameter and include it with the authentication request as the `login_hint` parameter. This will pre-fill the user's email address in the login form.\n\n## Learn more\n\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)\n*   [Customize Email Handling](https://auth0.com/docs/customize/email/manage-email-flow)\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)",
    "title": "Send Email Invitations for Application Signup",
    "description": "Describes how to customize the signup process to invite users to signup for an account in the context of a specific Auth0 application. ",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/customize-blocked-account-emails",
    "markdown": "# Customize Blocked Account Emails\n\nWhen Auth0 sends an email to notify a user that their account has been blocked due to suspicious activity, the message contains a link to re-enable the origin of the request.\n\nThe email sent to the user looks like this:\n\n![Example blocked access attempt email](https://images.ctfassets.net/cdy7uua7fh8z/YE2n7LHBZzI1JviQVARYC/0f400783c5c7563b8abc3b5443f7ddda/bfp-2015-12-29_1832.png)\n\n1.  To customize the template used for this message, go to [Dashboard > Branding > Email Templates](https://manage.auth0.com/#/templates).\n    \n2.  From the **Template** dropdown, select **Blocked Account Email**.\n    \n    ![Dashboard Branding Email Templates Blocked Account Email Template](https://images.ctfassets.net/cdy7uua7fh8z/7IeblHplWeWajmEhlLWwGR/8f76e4b9aa88fcb03a6206df381e4c07/dashboard-branding-email-templates-blocked-account-email.png)\n3.  Make the desired changes. To learn more, read [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates).\n    \n4.  To test, click **Try,** enter a valid email address that you have access to view, and choose the correct connection type.\n    \n5.  Click **Cancel**, returning to the email template page. You can make any changes and try again, then select **Save** when you are satisfied with the results.\n    \n\n## Learn more\n\n*   [Customize Email Templates](https://auth0.com/docs/customize/email/email-templates)",
    "title": "Customize Blocked Account Emails",
    "description": "Describes how to customize blocked account emails.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/configure-test-smtp-email-servers",
    "markdown": "# Configure Test SMTP Email Server\n\nWhile working in your development or testing environment, we recommend that you use a test SMTP server so that you can:\n\n*   Check for successful email deliveries.\n    \n*   View how emails you sent appear to recipients prior to go live.\n    \n\nYou can either set up your own SMTP server or use a third-party service. Once you have either your own SMTP server set up or a test service available, you provide its credentials the way you typically would for a [third-party email provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider).\n\nAuth0 does not allow certain \"false\" domains commonly used during testing. Use real email addresses to avoid disruption or errors.\n\nHere are some third-party email testing services you can use:\n\n*   [Debug Mail](https://debugmail.io/)\n    \n*   [FakeSMTP](https://nilhcem.github.io/FakeSMTP/)\n    \n*   [Haraka](https://haraka.github.io/)\n    \n*   [MailTrap](https://mailtrap.io/)\n    \n*   [smtp4dev](https://smtp4dev.codeplex.com/)\n    \n\n## Learn more\n\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)\n*   [Configure Custom External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider)",
    "title": "Configure Test SMTP Email Server",
    "description": "Describes how to set up a test SMTP server while in development or testing stages.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/smtp-email-providers",
    "markdown": "# Configure External SMTP Email Providers\n\nAuth0 allows you to configure your own SMTP email provider so you can more completely manage, monitor, and troubleshoot your email communications. Auth0's built-in email infrastructure should be used for testing emails only. You can only configure one email provider which will be used for all emails.\n\nAuth0 currently supports the following providers:\n\n*   [Mandrill](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mandrill-as-external-smtp-email-provider)\n    \n*   [Amazon SES](https://auth0.com/docs/customize/email/smtp-email-providers/configure-amazon-ses-as-external-smtp-email-provider)\n    \n*   [Azure Communication Services](https://auth0.com/docs/customize/email/smtp-email-providers/configure-azure-comm-service-as-smtp-email-provider)\n    \n*   [Microsoft 365](https://auth0.com/docs/customize/email/smtp-email-providers/configure-365-exchange-as-smtp-email-provider)\n    \n*   [SendGrid](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sendgrid-as-external-smtp-email-provider)\n    \n*   [SparkPost](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sparkpost-as-external-smtp-email-provider)\n    \n*   [Mailgun](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mailgun-as-external-smtp-email-provider)\n    \n\nYou can also configure a [third-party email provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider) such as Gmail or Yahoo.\n\nYou configure external email providers at [Auth0 Dashboard > Branding > Email Provider](https://manage.auth0.com/#/templates/provider).\n\n![Auth0 Branding Email Provider External SMTP](https://images.ctfassets.net/cdy7uua7fh8z/7isvLmP7JGkOivXcyeihM6/55a2657bf424f9e4f3b75c0d674957ba/Custom_Email_Provider__1_.png)\n\n## Learn more\n\n*   [Configure Custom External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider)\n*   [Configure Amazon SES as External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-amazon-ses-as-external-smtp-email-provider)\n*   [Configure Mandrill as External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mandrill-as-external-smtp-email-provider)\n*   [Configure SendGrid as External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sendgrid-as-external-smtp-email-provider)\n*   [Configure SparkPost as External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-sparkpost-as-external-smtp-email-provider)\n*   [Configure Mailgun as External SMTP Email Provider](https://auth0.com/docs/customize/email/smtp-email-providers/configure-mailgun-as-external-smtp-email-provider)",
    "title": "Configure External SMTP Email Providers",
    "description": "Learn how to configure your own SMTP email provider, so you can more completely manage, monitor, and troubleshoot your email communications.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/configure-a-custom-email-provider",
    "markdown": "# Configure a Custom Email Provider\n\nYou can set up any email provider using the Custom Email Provider option. It leverages our [Actions Code Editor](https://auth0.com/docs/customize/actions/actions-overview) to give you full control of the email delivery process.\n\n## Configure Custom Email Provider\n\n1.  Go to [Auth0 Dashboard > Branding > Email Provider](https://manage.auth0.com/#/templates/provider).\n    \n2.  Enable the **Use my own email provider** toggle.\n    \n3.  In the **Email Provider** Section, select **Custom Provider**.\n    \n4.  Click the **+** button next to **Custom Email Provider** to open the Actions Code Editor.\n    \n5.  In the Actions Code Editor Window, add the appropriate code to deliver messages to your provider:\n    \n    1.  Consult with your provider's documentation to understand how to deliver messages to their API.\n        \n    2.  Add any required [secrets](https://auth0.com/docs/customize/actions/write-your-first-action) to authenticate with the API.\n        \n    3.  Like other Actions, use the [Management API](https://auth0.com/docs/api/management/v2/actions/get-actions) to manage the Action and its [versions](https://auth0.com/docs/customize/actions/manage-versions).\n        \n6.  Deploy your action by clicking the **Deploy** button in the top right corner of the page.\n    \n7.  Navigate back by clicking **Back to Email Provider** in the top left corner. You should see a green check and **Enabled** in the **Provider Configuration** section.\n    \n8.  Finalize your custom provider by clicking **Save**.\n    \n9.  Make sure to test your configuration by sending a test email using the **Send Test Email** button.\n    \n\n## Use Cases\n\nWhile the primary use case is to deliver messages to providers that are not supported by the default email options, other use cases include:\n\n*   Retrying failures\n    \n*   Changing recipient(s)\n    \n*   Changing message payload\n    \n*   Creating Organization-specific logic\n    \n\n## Remove the Action\n\nThe **Custom Email Provider** option on [Auth0 Dashboard > Branding > Email Provider](https://manage.auth0.com/#/templates/provider) must be disabled before the Action can be deleted in order to prevent accidental email delivery failures.",
    "title": "Configure a Custom Email Provider",
    "description": "Learn how to set up a code-based custom email provider.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/troubleshoot-custom-email-provider-delivery-issues",
    "markdown": "# Troubleshoot Custom Email Provider Delivery Issues\n\nAuth0 allows you to configure your own SMTP email providers to manage, monitor, and troubleshoot your email communications. If you experience email delivery issues, there are several settings to review before contacting Auth0 support.\n\nYou must use a custom email provider. The [built-in email provider](https://manage.auth0.com/#/templates/provider) is for testing only and should not be a substitute for long term email management.\n\n## Review your infrastructure and domain configuration\n\nConfigure your email provider with the following authentication standards:\n\n*   DomainKeys Identified Mail ([DKIM](http://dkim.org/))\n    \n*   Sender Policy Framework ([SPF](https://datatracker.ietf.org/doc/rfc7208/))\n    \n*   Domain-based Message Authentication, Reporting, and Conformance ([DMARC](https://dmarc.org/))\n    \n\nYou can use several tools to review the settings of DNS records relating to DKIM, SPF, and DMARC. Built-in command line tools like `dig` and `nslookup` can help you diagnose your MX records and other common routing issues.\n\nOnline tools like [MXToolBox](https://mxtoolbox.com/) and [DNSChecker](https://dnschecker.org/all-tools.php) can also analyze settings related to authentication standards and are helpful in identifying misconfigurations or changes needed in your email settings.\n\n## Microsoft Exchange specific issues\n\nIf you use Microsoft Exchange as your email provider, your emails may be quarantined if Exchange deems them as high-risk. This can happen when emails route from an outside source.\n\nIf Microsoft Exchange quarantines messages, an administrator can view the messages in a special inbox and determine if there is a DMARC alignment failure, causing the messages to appear as spam.\n\n## SendGrid specific issues\n\nIf you use SendGrid as your email provider, your emails may be suppressed if the recipient's email server rejects the message. To learn more, read [Different Types of Suppression in SendGrid Docs](https://docs.sendgrid.com/ui/sending-email/index-suppressions#different-types-of-suppressions).\n\nIn certain cases, SendGrid will “Drop” a message to a specific email address in order to protect your sender reputation. To learn more about \"Drops\" and how to remove them, read [Drops on SendGrid Docs](https://docs.sendgrid.com/glossary/drops).\n\nIf you are using [passwordless authentication with email](https://auth0.com/docs/authenticate/passwordless#email), ensure that the **From** email address value for your passwordless connection matches the **From** email address value you're using for SendGrid.\n\n## Contacting Auth0 Support\n\nIf you review your custom email provider settings and ensure your domain implements DKIM, SPF, and DMARC protocols and your email delivery is still failing, you may need to contact the Auth0 support team for review.\n\nOur support team can verify if your email provider receives messages and the error returned if they are not accepted. To learn more, read [Open and Manage Support Tickets](https://auth0.com/docs/troubleshoot/customer-support/open-and-manage-support-tickets).\n\n## Diagnose email delivery issues\n\nIf you have configured a custom provider but are not receiving notifications that emails are being sent, verify your provider configuration details in Auth0 and confirm your custom provider is available. To view log data regarding email notification errors, go to [Dashboard > Monitoring > Logs](https://manage.auth0.com/#/logs) and filter results on the `Failed Sending Notification` event type.\n\n## Learn more\n\n*   [Customize Emails](https://auth0.com/docs/customize/email)",
    "title": "Troubleshoot Custom Email Provider Delivery Issues",
    "description": "Describes the steps to find and resolve email delivery issues.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/email/smtp-email-providers/configure-custom-external-smtp-email-provider",
    "markdown": "# Configure Custom External SMTP Email Provider\n\n#### Before you start\n\n*   Provider must support LOGIN [authentication](https://en.wikipedia.org/wiki/SMTP_Authentication).\n    \n*   Provider must support [TLS 1.2](https://en.wikipedia.org/wiki/STARTTLS) or higher.\n    \n*   Provider must have a certificate signed by a public certificate authority (CA).\n    \n*   Configure your provider to [allow inbound connections from Auth0](https://auth0.com/docs/secure/security-guidance/data-security/allowlist). To see the list of required IP addresses, Public Cloud customers can navigate to [Auth0 Dashboard > Branding > Email Provider](https://manage.auth0.com/#/templates/provider). Private Cloud customers can contact [Auth0 Support](https://support.auth0.com/) and request IPs specific to their instance.\n    \n\nYou can configure your own SMTP email provider to manage, monitor, and troubleshoot your email communications, and customize email templates.\n\n## Configure custom SMTP server\n\n1.  Go to [Auth0 Dashboard > Branding > Email Provider](https://manage.auth0.com/#/templates/provider).\n    \n2.  Enable the **Use my own email provider** toggle.\n    \n3.  Select **SMTP**.\n    \n4.  Enter a **From** email address, and then enter your SMTP server's **Host**, **Port**, **Username**, and **Password**. Common ports include 25 and 587. Avoid using port 25 if possible, as many providers have limitations on this port.\n    \n    ![Auth0 Branding Email Provider SMTP Provider Settings](https://images.ctfassets.net/cdy7uua7fh8z/7jYUb6ktBllv6yr25f5zJK/b18e9f1812afb7dced38acb3823e10e4/Dashboard_-_Branding_-_Email_Provider_-_SMTP_Provider_Settings.png)\n5.  Click **Save**.\n    \n\n## Test email delivery\n\nYou can now send a test email using the **Send Test Email** button. If you have configured everything correctly, you will receive a confirmation email. If you do not receive an email after a few minutes, please check your [Auth0 logs](https://manage.auth0.com/#/logs) for any failures.\n\nSMTP makes it easy to set up test services that allow you to test that your setup is working without spamming your users. To learn more, see [Set Up Test SMTP Servers](https://auth0.com/docs/email/testing).\n\n## Learn more\n\n*   [Configure External SMTP Email Providers](https://auth0.com/docs/customize/email/smtp-email-providers)",
    "title": "Configure Custom External SMTP Email Provider",
    "description": "Learn how to configure a custom external SMTP email provider.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/manage-users/user-migration/user-migration-scenarios",
    "markdown": "# User Migration Scenarios\n\n```\nfunction login(username, password, callback) {\n  // Replace the {yourStormpathClientId} attribute with your Stormpath ID\n  var url = 'https://api.stormpath.com/v1/applications/{yourStormpathClientId}/loginAttempts';\n\n  // Stormpath requires the user credentials be passed in as a base64 encoded message\n  var message = username + ':' + password;\n  var pass = new Buffer(message).toString('base64');\n\n  // Here we are making the POST request to authenticate a user\n  request({\n    url: url,\n    method: 'POST',\n    auth: {\n      // Your API Client ID\n      user: '{yourStormpathClientId}',\n      // Your API Client Secret\n      password: '{yourStormpathClientSecret}'\n    },\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    json: {\n      type: 'basic',\n      // Passing in the base64 encoded credentials\n      value: pass\n    }\n  }, function (error, response, body) {\n    // If response is successful we'll continue\n    if (response.statusCode !== 200) return callback();\n    // A successful response will return a URL to get the user information\n    var accountUrl = body.account.href;\n\n    // We'll make a second request to get the user info. This time it will be a GET request\n    request({\n      url: accountUrl,\n      method: 'GET',\n      auth: {\n        // Your API Client ID\n        user: '{yourStormpathClientId}',\n        // YOUR API Client Secret\n        password: '{yourStormpathClientSecret}'\n      }\n    }, function (errorUserInfo, responseUserInfo, bodyUserInfo) {\n      // If we get a successful response, we'll process it\n      if (responseUserInfo.statusCode !== 200) return callback();\n\n      var parsedBody = JSON.parse(bodyUserInfo);\n      // To get the user identifier, we'll strip out the Stormpath API\n      var id = parsedBody.href.replace('https://api.stormpath.com/v1/accounts/', '');\n\n      // Finally, we'll set the data we want to store in Auth0 and migrate the user\n      return callback(null, {\n        user_id : id,\n        username: parsedBody.username,\n        email: parsedBody.email,\n        // We set the users email_verified to true as we assume if they were a valid\n        // user in Stormpath, they have already verified their email\n        // If this field is not set, the user will get an email asking them to verify\n        // their account\n        email_verified: true,\n        // Add any additional fields you would like to carry over from Stormpath\n      });\n    });\n  });\n}\n```",
    "title": "User Migration Scenarios",
    "description": "User migrations scenarios from various platforms using multiple methods.",
    "languageCode": null
  },
  {
    "url": "https://auth0.com/docs/customize/extensions/real-time-webtask-logs",
    "markdown": "# Real-time Webtask Logs Extension\n\nThe Real-time Webtask Logs extension displays all logs in real-time for the custom code in your account. This includes all `console.log` output and exceptions. `Console.logs` are helpful if you have issues with database scripts. You can view the results from your database scripts such as success messages, error messages, and `console.log()` statements.\n\nTo learn more, see [Real-time Auth0 Webtask Logs](https://github.com/auth0/auth0-extension-realtime-logs) in Auth0's Github repository.\n\n## Configure the extension\n\nTo install and configure this extension:\n\n1.  Navigate to the [Extensions](https://manage.auth0.com/#/extensions) page of the [Auth0 Dashboard](https://manage.auth0.com/#), and click the **Real-time Webtask Logs** box. The **Install Extension** window opens.\n    \n    ![Dashboard - Extensions - Realtime Webtask Logs - Install](https://images.ctfassets.net/cdy7uua7fh8z/78UOfoBBDaFYdGY3RSkKlv/cf0f52a9563c1b888b0c7ed15155ed15/dashboard-extensions-real-time-webtask-logs-install.png)\n2.  Click the **Install** button.\n    \n\n## Use the extension\n\nTo view your logs:\n\n1.  Navigate to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **Installed Extensions**.\n    \n2.  Select **Real-time Webtask Logs**.\n    \n    ![Dashboard - Extensions - Realtime Webtask Logs - View Realtime Logs](https://images.ctfassets.net/cdy7uua7fh8z/5l2chLavwbt07werCJeRUw/1c9bec05ebf7977e5740e563e36b04c6/view-realtime-logs.png)\n\nTo view the logs in fullscreen mode, click **Full Screen Mode**. To exit fullscreen mode, press the **Escape** key.\n\nTo clear all logs, click **Clear Console**.\n\n## Debug rules\n\nYou can use the Real-time Webtask Logs extension to debug any Rules in your implementation, including all `console.log` output and exceptions. To learn more, read [Auth0 Rules](https://auth0.com/docs/customize/rules).\n\nIn the following example, you will create a generic Hello World rule, run it, and use the Real-time Webtask Logs extension to see the results.\n\n1.  Navigate to [Auth0 Dashboard > Auth Pipeline > Rules](https://manage.auth0.com/#/rules), and select **Create Rule**.\n    \n2.  Select the **Empty rule** template, paste the code below (or modify it as you like), and **Save Changes**.\n    \n    ```\n    function (user, context, callback) {\n      user.hello = 'world';\n      console.log('===> set \"hello\" for ' + user.name);\n      callback(null, user, context);\n    }\n    ```\n    \n3.  Open a new tab, navigate to [Auth0 Dashboard > Extensions](https://manage.auth0.com/#/extensions), and select **Installed Extensions**.\n    \n4.  Select **Real-time Webtask Logs**. You are now viewing logs real-time and are ready to try your rule.\n    \n5.  Switch to your Rules tab, and click **Try This Rule**.\n    \n6.  Switch to your Real-time Webtask Logs tab to see the results.\n    \n    ![Dashboard - Extensions - Realtime Webtask Logs - View Rules Example](https://images.ctfassets.net/cdy7uua7fh8z/qa2qa4s8rpR1Il0A9CejV/e07294e593e42f16f687b9d0a94e24fc/view-rules-example.png)\n\n## Learn more\n\n*   [Auth0 Rules](https://auth0.com/docs/customize/rules)",
    "title": "Real-time Webtask Logs Extension",
    "description": "Learn how to configure and use the Auth0 Real-time Webtask Logs extension.",
    "languageCode": null
  }
]